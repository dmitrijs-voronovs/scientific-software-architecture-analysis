id,quality_attribute,keyword,matched_word,match_idx,sentence,source,filename,author,repo,version,wiki,url
https://qutip.org/docs/4.2/modules/qutip/control/dump.html:9850,Availability,avail,available,9850,"e summary) is to be dumped""""""; if (self.dump_fid_err and self.dump_grad_norm and self.dump_grad):; return True; else:; return False. def _apply_level(self, level=None):; if level is None:; level = self._level. if not _is_string(level):; raise ValueError(""Dump level must be a string""); level = level.upper(); if level == 'CUSTOM':; if self._level == 'CUSTOM':; # dumping level has not changed keep the same specific config; pass; else:; # Switching to custom, start from SUMMARY; level = 'SUMMARY'. if level == 'SUMMARY':; self.dump_summary = True; self.dump_fid_err = False; self.dump_grad_norm = False; self.dump_grad = False; elif level == 'FULL':; self.dump_summary = True; self.dump_fid_err = True; self.dump_grad_norm = True; self.dump_grad = True; else:; raise ValueError(""No option for dumping level '{}'"".format(level)). [docs] def add_iter_summary(self):; """"""add copy of current optimizer iteration summary""""""; optim = self.parent; if optim.iter_summary is None:; raise RuntimeError(""Cannot add iter_summary as not available""); ois = copy.copy(optim.iter_summary); ois.idx = len(self.iter_summary); self.iter_summary.append(ois); if self.write_to_file:; if ois.idx == 0:; f = open(self.summary_file, 'w'); f.write(""{}\n{}\n"".format(; ois.get_header_line(self.summary_sep),; ois.get_value_line(self.summary_sep))); else:; f = open(self.summary_file, 'a'); f.write(""{}\n"".format(; ois.get_value_line(self.summary_sep))). f.close(); return ois. @property; def fid_err_file(self):; if self._fid_err_file is None:; fname = ""{}-fid_err_log.{}"".format(self.fname_base,; self.dump_file_ext); self._fid_err_file = os.path.join(self.dump_dir, fname); return self._fid_err_file. [docs] def update_fid_err_log(self, fid_err):; """"""add an entry to the fid_err log""""""; self.fid_err_log.append(fid_err); if self.write_to_file:; if len(self.fid_err_log) == 1:; mode = 'w'; else:; mode = 'a'; f = open(self.fid_err_file, mode); f.write(""{}\n"".format(fid_err)); f.close(). @property; def grad_norm_file(self):",MatchSource.WIKI,docs/4.2/modules/qutip/control/dump.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/control/dump.html
https://qutip.org/docs/4.2/modules/qutip/control/dump.html:12975,Availability,error,errors,12975,"ed then it must be a byte mode file; as numpy.savetxt is used, and requires this.; """"""; fall = None; # If specific file given then write everything to it; if hasattr(f, 'write'):; if not 'b' in f.mode:; raise RuntimeError(""File stream must be in binary mode""); # write all to this stream; fall = f; fs = f; closefall = False; closefs = False; elif f:; # Assume f is a filename; fall = open(f, 'wb'); fs = fall; closefs = False; closefall = True; else:; self.create_dump_dir(); closefall = False; if self.dump_summary:; fs = open(self.summary_file, 'wb'); closefs = True. if self.dump_summary:; for ois in self.iter_summary:; if ois.idx == 0:; fs.write(asbytes(""{}\n{}\n"".format(; ois.get_header_line(self.summary_sep),; ois.get_value_line(self.summary_sep)))); else:; fs.write(asbytes(""{}\n"".format(; ois.get_value_line(self.summary_sep)))). if closefs:; fs.close(); logger.info(""Optim dump summary saved to {}"".format(; self.summary_file)). if self.dump_fid_err:; if fall:; fall.write(asbytes(""Fidelity errors:\n"")); np.savetxt(fall, self.fid_err_log); else:; np.savetxt(self.fid_err_file, self.fid_err_log). if self.dump_grad_norm:; if fall:; fall.write(asbytes(""gradients norms:\n"")); np.savetxt(fall, self.grad_norm_log); else:; np.savetxt(self.grad_norm_file, self.grad_norm_log). if self.dump_grad:; g_num = 0; for grad in self.grad_log:; g_num += 1; if fall:; fall.write(asbytes(""gradients (call {}):\n"".format(g_num))); np.savetxt(fall, grad); else:; fname = ""{}-fid_err_gradients{}.{}"".format(self.fname_base,; g_num,; self.dump_file_ext); fpath = os.path.join(self.dump_dir, fname); np.savetxt(fpath, grad, delimiter=self.data_sep). if closefall:; fall.close(); logger.info(""Optim dump saved to {}"".format(f)); else:; if fall:; logger.info(""Optim dump saved to specified stream""); else:; logger.info(""Optim dump saved to {}"".format(self.dump_dir)). [docs]class DynamicsDump(Dump):; """"""; A container for dumps of dynamics data.; Mainly time evolution calculations. Attributes; ----------; dum",MatchSource.WIKI,docs/4.2/modules/qutip/control/dump.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/control/dump.html
https://qutip.org/docs/4.2/modules/qutip/control/dump.html:17927,Availability,avail,available,17927,"se:; raise ValueError(""No option for dumping level '{}'"".format(level)). [docs] def add_evo_dump(self):; """"""Add dump of current time evolution generating objects""""""; dyn = self.parent; item = EvoCompDumpItem(self); item.idx = len(self.evo_dumps); self.evo_dumps.append(item); if self.dump_amps:; item.ctrl_amps = copy.deepcopy(dyn.ctrl_amps); if self.dump_dyn_gen:; item.dyn_gen = copy.deepcopy(dyn._dyn_gen); if self.dump_prop:; item.prop = copy.deepcopy(dyn._prop); if self.dump_prop_grad:; item.prop_grad = copy.deepcopy(dyn._prop_grad); if self.dump_fwd_evo:; item.fwd_evo = copy.deepcopy(dyn._fwd_evo); if self.dump_onwd_evo:; item.onwd_evo = copy.deepcopy(dyn._onwd_evo); if self.dump_onto_evo:; item.onto_evo = copy.deepcopy(dyn._onto_evo). if self.write_to_file:; item.writeout(); return item. [docs] def add_evo_comp_summary(self, dump_item_idx=None):; """"""add copy of current evo comp summary""""""; dyn = self.parent; if dyn.tslot_computer.evo_comp_summary is None:; raise RuntimeError(""Cannot add evo_comp_summary as not available""); ecs = copy.copy(dyn.tslot_computer.evo_comp_summary); ecs.idx = len(self.evo_summary); ecs.evo_dump_idx = dump_item_idx; if dyn.stats:; ecs.iter_num = dyn.stats.num_iter; ecs.fid_func_call_num = dyn.stats.num_fidelity_func_calls; ecs.grad_func_call_num = dyn.stats.num_grad_func_calls. self.evo_summary.append(ecs); if self.write_to_file:; if ecs.idx == 0:; f = open(self.summary_file, 'w'); f.write(""{}\n{}\n"".format(; ecs.get_header_line(self.summary_sep),; ecs.get_value_line(self.summary_sep))); else:; f = open(self.summary_file, 'a'); f.write(""{}\n"".format(ecs.get_value_line(self.summary_sep))). f.close(); return ecs. [docs] def writeout(self, f=None):; """"""write all the dump items and the summary out to file(s); Parameters; ----------; f : filename or filehandle; If specified then all summary and object data will go in one file.; If None is specified then type specific files will be generated; in the dump_dir; If a filehandle is specified then ",MatchSource.WIKI,docs/4.2/modules/qutip/control/dump.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/control/dump.html
https://qutip.org/docs/4.2/modules/qutip/control/dump.html:25937,Deployability,update,updated,25937,"s.path.join(dump.dump_dir, fname), 'wb'); closef = True; for dg in self.dyn_gen:; f.write(asbytes(""Evolution from {} to end\n"".format(k))); np.savetxt(f, self.fwd_evo[k], delimiter=dump.data_sep); k += 1; if closef: f.close(). # onto evolution; if not self.onto_evo is None:; k = 0; if fall:; f = fall; f.write(asbytes(""Onto evolution\n"")); else:; fname = ""{}-onto_evo.{}"".format(fnbase,; dump.dump_file_ext); f = open(os.path.join(dump.dump_dir, fname), 'wb'); closef = True; for dg in self.dyn_gen:; f.write(asbytes(""Evolution from {} onto target\n"".format(k))); np.savetxt(f, self.fwd_evo[k], delimiter=dump.data_sep); k += 1; if closef: f.close(). if closefall:; fall.close(). [docs]class DumpSummaryItem(object):; """"""A summary of the most recent iteration; Abstract class only. Attributes:; idx : int; Index in the summary list in which this is stored; """"""; min_col_width = 11; summary_property_names = (). summary_property_fmt_type = (). summary_property_fmt_prec = (). @classmethod; def get_header_line(cls, sep=' '):; if sep == ' ':; line = ''; i = 0; for a in cls.summary_property_names:; if i > 0:; line += sep; i += 1; line += format(a, str(max(len(a), cls.min_col_width)) + 's'); else:; line = sep.join(cls.summary_property_names); return line. def reset(self):; self.idx = 0. def get_value_line(self, sep=' '):; line = """"; i = 0; for a in zip(self.summary_property_names,; self.summary_property_fmt_type,; self.summary_property_fmt_prec):; if i > 0:; line += sep; i += 1; v = getattr(self, a[0]); w = max(len(a[0]), self.min_col_width); if v is not None:; fmt = ''; if sep == ' ':; fmt += str(w); else:; fmt += '0'; if a[2] > 0:; fmt += '.' + str(a[2]); fmt += a[1]; line += format(v, fmt); else:; if sep == ' ':; line += format('None', str(w) + 's'); else:; line += 'None'. return line. Â© Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, and A.L. Grimsmo.; Last updated on Jan 17, 2018. . Built with Sphinx using a theme provided by Read the Docs. . ",MatchSource.WIKI,docs/4.2/modules/qutip/control/dump.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/control/dump.html
https://qutip.org/docs/4.2/modules/qutip/control/dump.html:2845,Integrability,depend,depends,2845," (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE; # OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.; ###############################################################################. """"""; Classes that enable the storing of historical objects created during the; pulse optimisation.; These are intented for debugging.; See the optimizer and dynamics objects for instrutcions on how to enable; data dumping.; """""". import os; import numpy as np; import copy; # QuTiP logging; import qutip.logging_utils; logger = qutip.logging_utils.get_logger(); # QuTiP control modules; import qutip.control.io as qtrlio; from numpy.compat import asbytes. DUMP_DIR = ""~/.qtrl_dump"". def _is_string(var):; try:; if isinstance(var, basestring):; return True; except NameError:; try:; if isinstance(var, str):; return True; except:; return False; except:; return False. return False. [docs]class Dump(object):; """"""; A container for dump items.; The lists for dump items is depends on the type; Note: abstract class. Attributes; ----------; parent : some control object (Dynamics or Optimizer); aka the host. Object that generates the data that is dumped and is; host to this dump object. dump_dir : str; directory where files (if any) will be written out; the path and be relative or absolute; use ~/ to specify user home directory; Note: files are only written when write_to_file is True; of writeout is called explicitly; Defaults to ~/.qtrl_dump. level : string; level of data dumping: SUMMARY, FULL or CUSTOM; See property docstring for details; Set automatically if dump is created by the setting host dumping attrib. write_to_file : bool; When set True data and summaries (as configured) will be written; interactively to file during the processing; Set during instantiation by the host based on its dump_to_file attrib. dump_file_ext : str; Default file extension for any file names that are auto generated. fname_base : str; First part of any auto generated file names.; ",MatchSource.WIKI,docs/4.2/modules/qutip/control/dump.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/control/dump.html
https://qutip.org/docs/4.2/modules/qutip/control/dump.html:3554,Modifiability,config,configured,3554,"nce(var, basestring):; return True; except NameError:; try:; if isinstance(var, str):; return True; except:; return False; except:; return False. return False. [docs]class Dump(object):; """"""; A container for dump items.; The lists for dump items is depends on the type; Note: abstract class. Attributes; ----------; parent : some control object (Dynamics or Optimizer); aka the host. Object that generates the data that is dumped and is; host to this dump object. dump_dir : str; directory where files (if any) will be written out; the path and be relative or absolute; use ~/ to specify user home directory; Note: files are only written when write_to_file is True; of writeout is called explicitly; Defaults to ~/.qtrl_dump. level : string; level of data dumping: SUMMARY, FULL or CUSTOM; See property docstring for details; Set automatically if dump is created by the setting host dumping attrib. write_to_file : bool; When set True data and summaries (as configured) will be written; interactively to file during the processing; Set during instantiation by the host based on its dump_to_file attrib. dump_file_ext : str; Default file extension for any file names that are auto generated. fname_base : str; First part of any auto generated file names.; This is usually overridden in the subclass. dump_summary : bool; If True a summary is recorded each time a new item is added to the; the dump.; Default is True. summary_sep : str; delimiter for the summary file.; default is a space. data_sep : str; delimiter for the data files (arrays saved to file).; default is a space. summary_file : str; File path for summary file.; Automatically generated. Can be set specifically. """"""; def __init__(self):; self.reset(). def reset(self):; if self.parent:; self.log_level = self.parent.log_level; self.write_to_file = self.parent.dump_to_file; else:; self.write_to_file = False; self._dump_dir = None; self.dump_file_ext = ""txt""; self._fname_base = 'dump'; self.dump_summary = True; self.summary_sep = ' '",MatchSource.WIKI,docs/4.2/modules/qutip/control/dump.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/control/dump.html
https://qutip.org/docs/4.2/modules/qutip/control/dump.html:9241,Modifiability,config,config,9241,"reset(self); self._apply_level(); self.iter_summary = []; self.fid_err_log = []; self.grad_norm_log = []; self.grad_log = []; self._fname_base = 'optimdump'; self._fid_err_file = None; self._grad_norm_file = None. def clear(self):; del self.iter_summary[:]; self.fid_err_log[:]; self.grad_norm_log[:]; self.grad_log[:]. @property; def dump_any(self):; """"""True if anything other than the summary is to be dumped""""""; if (self.dump_fid_err or self.dump_grad_norm or self.dump_grad):; return True; else:; return False. @property; def dump_all(self):; """"""True if everything (ignoring the summary) is to be dumped""""""; if (self.dump_fid_err and self.dump_grad_norm and self.dump_grad):; return True; else:; return False. def _apply_level(self, level=None):; if level is None:; level = self._level. if not _is_string(level):; raise ValueError(""Dump level must be a string""); level = level.upper(); if level == 'CUSTOM':; if self._level == 'CUSTOM':; # dumping level has not changed keep the same specific config; pass; else:; # Switching to custom, start from SUMMARY; level = 'SUMMARY'. if level == 'SUMMARY':; self.dump_summary = True; self.dump_fid_err = False; self.dump_grad_norm = False; self.dump_grad = False; elif level == 'FULL':; self.dump_summary = True; self.dump_fid_err = True; self.dump_grad_norm = True; self.dump_grad = True; else:; raise ValueError(""No option for dumping level '{}'"".format(level)). [docs] def add_iter_summary(self):; """"""add copy of current optimizer iteration summary""""""; optim = self.parent; if optim.iter_summary is None:; raise RuntimeError(""Cannot add iter_summary as not available""); ois = copy.copy(optim.iter_summary); ois.idx = len(self.iter_summary); self.iter_summary.append(ois); if self.write_to_file:; if ois.idx == 0:; f = open(self.summary_file, 'w'); f.write(""{}\n{}\n"".format(; ois.get_header_line(self.summary_sep),; ois.get_value_line(self.summary_sep))); else:; f = open(self.summary_file, 'a'); f.write(""{}\n"".format(; ois.get_value_line(self.summar",MatchSource.WIKI,docs/4.2/modules/qutip/control/dump.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/control/dump.html
https://qutip.org/docs/4.2/modules/qutip/control/dump.html:16295,Modifiability,config,config,16295,"any(self):; """"""True if any of the calculation objects are to be dumped""""""; if (self.dump_amps or; self.dump_dyn_gen or; self.dump_prop or; self.dump_prop_grad or; self.dump_fwd_evo or; self.dump_onwd_evo or; self.dump_onto_evo):; return True; else:; return False. @property; def dump_all(self):; """"""True if all of the calculation objects are to be dumped""""""; dyn = self.parent; if (self.dump_amps and; self.dump_dyn_gen and; self.dump_prop and; self.dump_prop_grad and; self.dump_fwd_evo and; (self.dump_onwd_evo) or; (self.dump_onwd_evo == dyn.fid_computer.uses_onwd_evo) and; (self.dump_onto_evo or; (self.dump_onto_evo == dyn.fid_computer.uses_onto_evo))):; return True; else:; return False. def _apply_level(self, level=None):; dyn = self.parent; if level is None:; level = self._level. if not _is_string(level):; raise ValueError(""Dump level must be a string""); level = level.upper(); if level == 'CUSTOM':; if self._level == 'CUSTOM':; # dumping level has not changed keep the same specific config; pass; else:; # Switching to custom, start from SUMMARY; level = 'SUMMARY'. if level == 'SUMMARY':; self.dump_summary = True; self.dump_amps = False; self.dump_dyn_gen = False; self.dump_prop = False; self.dump_prop_grad = False; self.dump_fwd_evo = False; self.dump_onwd_evo = False; self.dump_onto_evo = False; elif level == 'FULL':; self.dump_summary = True; self.dump_amps = True; self.dump_dyn_gen = True; self.dump_prop = True; self.dump_prop_grad = True; self.dump_fwd_evo = True; self.dump_onwd_evo = dyn.fid_computer.uses_onwd_evo; self.dump_onto_evo = dyn.fid_computer.uses_onto_evo; else:; raise ValueError(""No option for dumping level '{}'"".format(level)). [docs] def add_evo_dump(self):; """"""Add dump of current time evolution generating objects""""""; dyn = self.parent; item = EvoCompDumpItem(self); item.idx = len(self.evo_dumps); self.evo_dumps.append(item); if self.dump_amps:; item.ctrl_amps = copy.deepcopy(dyn.ctrl_amps); if self.dump_dyn_gen:; item.dyn_gen = copy.deepcopy(dyn._",MatchSource.WIKI,docs/4.2/modules/qutip/control/dump.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/control/dump.html
https://qutip.org/docs/4.2/modules/qutip/control/dump.html:2219,Performance,optimiz,optimizer,2219,"LDERS AND CONTRIBUTORS; # ""AS IS"" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT; # LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A; # PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT; # HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,; # SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT; # LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,; # DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY; # THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT; # (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE; # OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.; ###############################################################################. """"""; Classes that enable the storing of historical objects created during the; pulse optimisation.; These are intented for debugging.; See the optimizer and dynamics objects for instrutcions on how to enable; data dumping.; """""". import os; import numpy as np; import copy; # QuTiP logging; import qutip.logging_utils; logger = qutip.logging_utils.get_logger(); # QuTiP control modules; import qutip.control.io as qtrlio; from numpy.compat import asbytes. DUMP_DIR = ""~/.qtrl_dump"". def _is_string(var):; try:; if isinstance(var, basestring):; return True; except NameError:; try:; if isinstance(var, str):; return True; except:; return False; except:; return False. return False. [docs]class Dump(object):; """"""; A container for dump items.; The lists for dump items is depends on the type; Note: abstract class. Attributes; ----------; parent : some control object (Dynamics or Optimizer); aka the host. Object that generates the data that is dumped and is; host to this dump object. dump_dir : str; directory where files (if any) will be written out; the path and be relative or absolute; use ~/ to specify user home directory; Note: files are only written when write_to_file i",MatchSource.WIKI,docs/4.2/modules/qutip/control/dump.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/control/dump.html
https://qutip.org/docs/4.2/modules/qutip/control/dump.html:7464,Performance,optimiz,optimizer,7464,"lf, value):; if not _is_string(value):; raise ValueError(""File name base must be a string""); self._fname_base = value; self._summary_file_path = None. @property; def summary_file(self):; if self._summary_file_path is None:; fname = ""{}-summary.{}"".format(self._fname_base, self.dump_file_ext); self._summary_file_path = os.path.join(self.dump_dir, fname); return self._summary_file_path. @summary_file.setter; def summary_file(self, value):; if not _is_string(value):; raise ValueError(""File path must be a string""); self._summary_file_specified = True; if os.path.abspath(value):; self._summary_file_path = value; elif '~' in value:; self._summary_file_path = os.path.expanduser(value); else:; self._summary_file_path = os.path.join(self.dump_dir, value). [docs]class OptimDump(Dump):; """"""; A container for dumps of optimisation data generated during the pulse; optimisation. Attributes; ----------; dump_summary : bool; When True summary items are appended to the iter_summary. iter_summary : list of :class:`optimizer.OptimIterSummary`; Summary at each iteration. dump_fid_err : bool; When True values are appended to the fid_err_log. fid_err_log : list of float; Fidelity error at each call of the fid_err_func. dump_grad_norm : bool; When True values are appended to the fid_err_log. grad_norm_log : list of float; Gradient norm at each call of the grad_norm_log. dump_grad : bool; When True values are appended to the grad_log. grad_log : list of ndarray; Gradients at each call of the fid_grad_func. """"""; def __init__(self, optim, level='SUMMARY'):; from qutip.control.optimizer import Optimizer; if not isinstance(optim, Optimizer):; raise TypeError(""Must instantiate with {} type"".format(; Optimizer)); self.parent = optim; self._level = level; self.reset(). def reset(self):; Dump.reset(self); self._apply_level(); self.iter_summary = []; self.fid_err_log = []; self.grad_norm_log = []; self.grad_log = []; self._fname_base = 'optimdump'; self._fid_err_file = None; self._grad_norm_file = N",MatchSource.WIKI,docs/4.2/modules/qutip/control/dump.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/control/dump.html
https://qutip.org/docs/4.2/modules/qutip/control/dump.html:8029,Performance,optimiz,optimizer,8029,"; self._summary_file_path = os.path.expanduser(value); else:; self._summary_file_path = os.path.join(self.dump_dir, value). [docs]class OptimDump(Dump):; """"""; A container for dumps of optimisation data generated during the pulse; optimisation. Attributes; ----------; dump_summary : bool; When True summary items are appended to the iter_summary. iter_summary : list of :class:`optimizer.OptimIterSummary`; Summary at each iteration. dump_fid_err : bool; When True values are appended to the fid_err_log. fid_err_log : list of float; Fidelity error at each call of the fid_err_func. dump_grad_norm : bool; When True values are appended to the fid_err_log. grad_norm_log : list of float; Gradient norm at each call of the grad_norm_log. dump_grad : bool; When True values are appended to the grad_log. grad_log : list of ndarray; Gradients at each call of the fid_grad_func. """"""; def __init__(self, optim, level='SUMMARY'):; from qutip.control.optimizer import Optimizer; if not isinstance(optim, Optimizer):; raise TypeError(""Must instantiate with {} type"".format(; Optimizer)); self.parent = optim; self._level = level; self.reset(). def reset(self):; Dump.reset(self); self._apply_level(); self.iter_summary = []; self.fid_err_log = []; self.grad_norm_log = []; self.grad_log = []; self._fname_base = 'optimdump'; self._fid_err_file = None; self._grad_norm_file = None. def clear(self):; del self.iter_summary[:]; self.fid_err_log[:]; self.grad_norm_log[:]; self.grad_log[:]. @property; def dump_any(self):; """"""True if anything other than the summary is to be dumped""""""; if (self.dump_fid_err or self.dump_grad_norm or self.dump_grad):; return True; else:; return False. @property; def dump_all(self):; """"""True if everything (ignoring the summary) is to be dumped""""""; if (self.dump_fid_err and self.dump_grad_norm and self.dump_grad):; return True; else:; return False. def _apply_level(self, level=None):; if level is None:; level = self._level. if not _is_string(level):; raise ValueError(""Dump l",MatchSource.WIKI,docs/4.2/modules/qutip/control/dump.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/control/dump.html
https://qutip.org/docs/4.2/modules/qutip/control/dump.html:9714,Performance,optimiz,optimizer,9714," self.dump_grad):; return True; else:; return False. @property; def dump_all(self):; """"""True if everything (ignoring the summary) is to be dumped""""""; if (self.dump_fid_err and self.dump_grad_norm and self.dump_grad):; return True; else:; return False. def _apply_level(self, level=None):; if level is None:; level = self._level. if not _is_string(level):; raise ValueError(""Dump level must be a string""); level = level.upper(); if level == 'CUSTOM':; if self._level == 'CUSTOM':; # dumping level has not changed keep the same specific config; pass; else:; # Switching to custom, start from SUMMARY; level = 'SUMMARY'. if level == 'SUMMARY':; self.dump_summary = True; self.dump_fid_err = False; self.dump_grad_norm = False; self.dump_grad = False; elif level == 'FULL':; self.dump_summary = True; self.dump_fid_err = True; self.dump_grad_norm = True; self.dump_grad = True; else:; raise ValueError(""No option for dumping level '{}'"".format(level)). [docs] def add_iter_summary(self):; """"""add copy of current optimizer iteration summary""""""; optim = self.parent; if optim.iter_summary is None:; raise RuntimeError(""Cannot add iter_summary as not available""); ois = copy.copy(optim.iter_summary); ois.idx = len(self.iter_summary); self.iter_summary.append(ois); if self.write_to_file:; if ois.idx == 0:; f = open(self.summary_file, 'w'); f.write(""{}\n{}\n"".format(; ois.get_header_line(self.summary_sep),; ois.get_value_line(self.summary_sep))); else:; f = open(self.summary_file, 'a'); f.write(""{}\n"".format(; ois.get_value_line(self.summary_sep))). f.close(); return ois. @property; def fid_err_file(self):; if self._fid_err_file is None:; fname = ""{}-fid_err_log.{}"".format(self.fname_base,; self.dump_file_ext); self._fid_err_file = os.path.join(self.dump_dir, fname); return self._fid_err_file. [docs] def update_fid_err_log(self, fid_err):; """"""add an entry to the fid_err log""""""; self.fid_err_log.append(fid_err); if self.write_to_file:; if len(self.fid_err_log) == 1:; mode = 'w'; else:; mode = 'a",MatchSource.WIKI,docs/4.2/modules/qutip/control/dump.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/control/dump.html
https://qutip.org/docs/4.2/modules/qutip/control/dump.html:2357,Testability,log,logging,2357,"NOT; # LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A; # PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT; # HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,; # SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT; # LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,; # DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY; # THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT; # (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE; # OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.; ###############################################################################. """"""; Classes that enable the storing of historical objects created during the; pulse optimisation.; These are intented for debugging.; See the optimizer and dynamics objects for instrutcions on how to enable; data dumping.; """""". import os; import numpy as np; import copy; # QuTiP logging; import qutip.logging_utils; logger = qutip.logging_utils.get_logger(); # QuTiP control modules; import qutip.control.io as qtrlio; from numpy.compat import asbytes. DUMP_DIR = ""~/.qtrl_dump"". def _is_string(var):; try:; if isinstance(var, basestring):; return True; except NameError:; try:; if isinstance(var, str):; return True; except:; return False; except:; return False. return False. [docs]class Dump(object):; """"""; A container for dump items.; The lists for dump items is depends on the type; Note: abstract class. Attributes; ----------; parent : some control object (Dynamics or Optimizer); aka the host. Object that generates the data that is dumped and is; host to this dump object. dump_dir : str; directory where files (if any) will be written out; the path and be relative or absolute; use ~/ to specify user home directory; Note: files are only written when write_to_file is True; of writeout is called explicitly; Defaults to ~/.qtrl_dump. level : string; leve",MatchSource.WIKI,docs/4.2/modules/qutip/control/dump.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/control/dump.html
https://qutip.org/docs/4.2/modules/qutip/control/dump.html:2394,Testability,log,logger,2394,"ABILITY AND FITNESS FOR A; # PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT; # HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,; # SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT; # LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,; # DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY; # THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT; # (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE; # OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.; ###############################################################################. """"""; Classes that enable the storing of historical objects created during the; pulse optimisation.; These are intented for debugging.; See the optimizer and dynamics objects for instrutcions on how to enable; data dumping.; """""". import os; import numpy as np; import copy; # QuTiP logging; import qutip.logging_utils; logger = qutip.logging_utils.get_logger(); # QuTiP control modules; import qutip.control.io as qtrlio; from numpy.compat import asbytes. DUMP_DIR = ""~/.qtrl_dump"". def _is_string(var):; try:; if isinstance(var, basestring):; return True; except NameError:; try:; if isinstance(var, str):; return True; except:; return False; except:; return False. return False. [docs]class Dump(object):; """"""; A container for dump items.; The lists for dump items is depends on the type; Note: abstract class. Attributes; ----------; parent : some control object (Dynamics or Optimizer); aka the host. Object that generates the data that is dumped and is; host to this dump object. dump_dir : str; directory where files (if any) will be written out; the path and be relative or absolute; use ~/ to specify user home directory; Note: files are only written when write_to_file is True; of writeout is called explicitly; Defaults to ~/.qtrl_dump. level : string; level of data dumping: SUMMARY, FULL or CUSTOM; See prop",MatchSource.WIKI,docs/4.2/modules/qutip/control/dump.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/control/dump.html
https://qutip.org/docs/4.2/modules/qutip/control/dump.html:4729,Testability,log,logger,4729," : str; Default file extension for any file names that are auto generated. fname_base : str; First part of any auto generated file names.; This is usually overridden in the subclass. dump_summary : bool; If True a summary is recorded each time a new item is added to the; the dump.; Default is True. summary_sep : str; delimiter for the summary file.; default is a space. data_sep : str; delimiter for the data files (arrays saved to file).; default is a space. summary_file : str; File path for summary file.; Automatically generated. Can be set specifically. """"""; def __init__(self):; self.reset(). def reset(self):; if self.parent:; self.log_level = self.parent.log_level; self.write_to_file = self.parent.dump_to_file; else:; self.write_to_file = False; self._dump_dir = None; self.dump_file_ext = ""txt""; self._fname_base = 'dump'; self.dump_summary = True; self.summary_sep = ' '; self.data_sep = ' '; self._summary_file_path = None; self._summary_file_specified = False. @property; def log_level(self):; return logger.level. @log_level.setter; def log_level(self, lvl):; """"""; Set the log_level attribute and set the level of the logger; that is call logger.setLevel(lvl); """"""; logger.setLevel(lvl). @property; def level(self):; """"""; The level of data dumping that will occur; - SUMMARY : A summary will be recorded; - FULL : All possible dumping; - CUSTOM : Some customised level of dumping; When first set to CUSTOM this is equivalent to SUMMARY. It is then up; to the user to specify what specifically is dumped; """"""; lvl = 'CUSTOM'; if (self.dump_summary and not self.dump_any):; lvl = 'SUMMARY'; elif (self.dump_summary and self.dump_all):; lvl = 'FULL'. return lvl. @level.setter; def level(self, value):; self._level = value; self._apply_level(). @property; def dump_any(self):; raise NotImplemented(""This is an abstract class, ""; ""use subclass such as DynamicsDump or OptimDump""). @property; def dump_all(self):; raise NotImplemented(""This is an abstract class, ""; ""use subclass such as ",MatchSource.WIKI,docs/4.2/modules/qutip/control/dump.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/control/dump.html
https://qutip.org/docs/4.2/modules/qutip/control/dump.html:4847,Testability,log,logger,4847,"t of any auto generated file names.; This is usually overridden in the subclass. dump_summary : bool; If True a summary is recorded each time a new item is added to the; the dump.; Default is True. summary_sep : str; delimiter for the summary file.; default is a space. data_sep : str; delimiter for the data files (arrays saved to file).; default is a space. summary_file : str; File path for summary file.; Automatically generated. Can be set specifically. """"""; def __init__(self):; self.reset(). def reset(self):; if self.parent:; self.log_level = self.parent.log_level; self.write_to_file = self.parent.dump_to_file; else:; self.write_to_file = False; self._dump_dir = None; self.dump_file_ext = ""txt""; self._fname_base = 'dump'; self.dump_summary = True; self.summary_sep = ' '; self.data_sep = ' '; self._summary_file_path = None; self._summary_file_specified = False. @property; def log_level(self):; return logger.level. @log_level.setter; def log_level(self, lvl):; """"""; Set the log_level attribute and set the level of the logger; that is call logger.setLevel(lvl); """"""; logger.setLevel(lvl). @property; def level(self):; """"""; The level of data dumping that will occur; - SUMMARY : A summary will be recorded; - FULL : All possible dumping; - CUSTOM : Some customised level of dumping; When first set to CUSTOM this is equivalent to SUMMARY. It is then up; to the user to specify what specifically is dumped; """"""; lvl = 'CUSTOM'; if (self.dump_summary and not self.dump_any):; lvl = 'SUMMARY'; elif (self.dump_summary and self.dump_all):; lvl = 'FULL'. return lvl. @level.setter; def level(self, value):; self._level = value; self._apply_level(). @property; def dump_any(self):; raise NotImplemented(""This is an abstract class, ""; ""use subclass such as DynamicsDump or OptimDump""). @property; def dump_all(self):; raise NotImplemented(""This is an abstract class, ""; ""use subclass such as DynamicsDump or OptimDump""). @property; def dump_dir(self):; if self._dump_dir is None:; self.create_du",MatchSource.WIKI,docs/4.2/modules/qutip/control/dump.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/control/dump.html
https://qutip.org/docs/4.2/modules/qutip/control/dump.html:4868,Testability,log,logger,4868,"t of any auto generated file names.; This is usually overridden in the subclass. dump_summary : bool; If True a summary is recorded each time a new item is added to the; the dump.; Default is True. summary_sep : str; delimiter for the summary file.; default is a space. data_sep : str; delimiter for the data files (arrays saved to file).; default is a space. summary_file : str; File path for summary file.; Automatically generated. Can be set specifically. """"""; def __init__(self):; self.reset(). def reset(self):; if self.parent:; self.log_level = self.parent.log_level; self.write_to_file = self.parent.dump_to_file; else:; self.write_to_file = False; self._dump_dir = None; self.dump_file_ext = ""txt""; self._fname_base = 'dump'; self.dump_summary = True; self.summary_sep = ' '; self.data_sep = ' '; self._summary_file_path = None; self._summary_file_specified = False. @property; def log_level(self):; return logger.level. @log_level.setter; def log_level(self, lvl):; """"""; Set the log_level attribute and set the level of the logger; that is call logger.setLevel(lvl); """"""; logger.setLevel(lvl). @property; def level(self):; """"""; The level of data dumping that will occur; - SUMMARY : A summary will be recorded; - FULL : All possible dumping; - CUSTOM : Some customised level of dumping; When first set to CUSTOM this is equivalent to SUMMARY. It is then up; to the user to specify what specifically is dumped; """"""; lvl = 'CUSTOM'; if (self.dump_summary and not self.dump_any):; lvl = 'SUMMARY'; elif (self.dump_summary and self.dump_all):; lvl = 'FULL'. return lvl. @level.setter; def level(self, value):; self._level = value; self._apply_level(). @property; def dump_any(self):; raise NotImplemented(""This is an abstract class, ""; ""use subclass such as DynamicsDump or OptimDump""). @property; def dump_all(self):; raise NotImplemented(""This is an abstract class, ""; ""use subclass such as DynamicsDump or OptimDump""). @property; def dump_dir(self):; if self._dump_dir is None:; self.create_du",MatchSource.WIKI,docs/4.2/modules/qutip/control/dump.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/control/dump.html
https://qutip.org/docs/4.2/modules/qutip/control/dump.html:4895,Testability,log,logger,4895,"class. dump_summary : bool; If True a summary is recorded each time a new item is added to the; the dump.; Default is True. summary_sep : str; delimiter for the summary file.; default is a space. data_sep : str; delimiter for the data files (arrays saved to file).; default is a space. summary_file : str; File path for summary file.; Automatically generated. Can be set specifically. """"""; def __init__(self):; self.reset(). def reset(self):; if self.parent:; self.log_level = self.parent.log_level; self.write_to_file = self.parent.dump_to_file; else:; self.write_to_file = False; self._dump_dir = None; self.dump_file_ext = ""txt""; self._fname_base = 'dump'; self.dump_summary = True; self.summary_sep = ' '; self.data_sep = ' '; self._summary_file_path = None; self._summary_file_specified = False. @property; def log_level(self):; return logger.level. @log_level.setter; def log_level(self, lvl):; """"""; Set the log_level attribute and set the level of the logger; that is call logger.setLevel(lvl); """"""; logger.setLevel(lvl). @property; def level(self):; """"""; The level of data dumping that will occur; - SUMMARY : A summary will be recorded; - FULL : All possible dumping; - CUSTOM : Some customised level of dumping; When first set to CUSTOM this is equivalent to SUMMARY. It is then up; to the user to specify what specifically is dumped; """"""; lvl = 'CUSTOM'; if (self.dump_summary and not self.dump_any):; lvl = 'SUMMARY'; elif (self.dump_summary and self.dump_all):; lvl = 'FULL'. return lvl. @level.setter; def level(self, value):; self._level = value; self._apply_level(). @property; def dump_any(self):; raise NotImplemented(""This is an abstract class, ""; ""use subclass such as DynamicsDump or OptimDump""). @property; def dump_all(self):; raise NotImplemented(""This is an abstract class, ""; ""use subclass such as DynamicsDump or OptimDump""). @property; def dump_dir(self):; if self._dump_dir is None:; self.create_dump_dir(); return self._dump_dir. @dump_dir.setter; def dump_dir(self, valu",MatchSource.WIKI,docs/4.2/modules/qutip/control/dump.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/control/dump.html
https://qutip.org/docs/4.2/modules/qutip/control/dump.html:6323,Testability,log,logger,6323,"elf.dump_summary and self.dump_all):; lvl = 'FULL'. return lvl. @level.setter; def level(self, value):; self._level = value; self._apply_level(). @property; def dump_any(self):; raise NotImplemented(""This is an abstract class, ""; ""use subclass such as DynamicsDump or OptimDump""). @property; def dump_all(self):; raise NotImplemented(""This is an abstract class, ""; ""use subclass such as DynamicsDump or OptimDump""). @property; def dump_dir(self):; if self._dump_dir is None:; self.create_dump_dir(); return self._dump_dir. @dump_dir.setter; def dump_dir(self, value):; self._dump_dir = value; if not self.create_dump_dir():; self._dump_dir = None. [docs] def create_dump_dir(self):; """"""; Checks dump directory exists, creates it if not; """"""; if self._dump_dir is None or len(self._dump_dir) == 0:; self._dump_dir = DUMP_DIR. dir_ok, self._dump_dir, msg = qtrlio.create_dir(; self._dump_dir, desc='dump'). if not dir_ok:; self.write_to_file = False; msg += ""\ndump file output will be suppressed.""; logger.error(msg). return dir_ok. @property; def fname_base(self):; return self._fname_base. @fname_base.setter; def fname_base(self, value):; if not _is_string(value):; raise ValueError(""File name base must be a string""); self._fname_base = value; self._summary_file_path = None. @property; def summary_file(self):; if self._summary_file_path is None:; fname = ""{}-summary.{}"".format(self._fname_base, self.dump_file_ext); self._summary_file_path = os.path.join(self.dump_dir, fname); return self._summary_file_path. @summary_file.setter; def summary_file(self, value):; if not _is_string(value):; raise ValueError(""File path must be a string""); self._summary_file_specified = True; if os.path.abspath(value):; self._summary_file_path = value; elif '~' in value:; self._summary_file_path = os.path.expanduser(value); else:; self._summary_file_path = os.path.join(self.dump_dir, value). [docs]class OptimDump(Dump):; """"""; A container for dumps of optimisation data generated during the pulse; optimisat",MatchSource.WIKI,docs/4.2/modules/qutip/control/dump.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/control/dump.html
https://qutip.org/docs/4.2/modules/qutip/control/dump.html:10581,Testability,log,log,10581," = True; self.dump_grad = True; else:; raise ValueError(""No option for dumping level '{}'"".format(level)). [docs] def add_iter_summary(self):; """"""add copy of current optimizer iteration summary""""""; optim = self.parent; if optim.iter_summary is None:; raise RuntimeError(""Cannot add iter_summary as not available""); ois = copy.copy(optim.iter_summary); ois.idx = len(self.iter_summary); self.iter_summary.append(ois); if self.write_to_file:; if ois.idx == 0:; f = open(self.summary_file, 'w'); f.write(""{}\n{}\n"".format(; ois.get_header_line(self.summary_sep),; ois.get_value_line(self.summary_sep))); else:; f = open(self.summary_file, 'a'); f.write(""{}\n"".format(; ois.get_value_line(self.summary_sep))). f.close(); return ois. @property; def fid_err_file(self):; if self._fid_err_file is None:; fname = ""{}-fid_err_log.{}"".format(self.fname_base,; self.dump_file_ext); self._fid_err_file = os.path.join(self.dump_dir, fname); return self._fid_err_file. [docs] def update_fid_err_log(self, fid_err):; """"""add an entry to the fid_err log""""""; self.fid_err_log.append(fid_err); if self.write_to_file:; if len(self.fid_err_log) == 1:; mode = 'w'; else:; mode = 'a'; f = open(self.fid_err_file, mode); f.write(""{}\n"".format(fid_err)); f.close(). @property; def grad_norm_file(self):; if self._grad_norm_file is None:; fname = ""{}-grad_norm_log.{}"".format(self.fname_base,; self.dump_file_ext); self._grad_norm_file = os.path.join(self.dump_dir, fname); return self._grad_norm_file. [docs] def update_grad_norm_log(self, grad_norm):; """"""add an entry to the grad_norm log""""""; self.grad_norm_log.append(grad_norm); if self.write_to_file:; if len(self.grad_norm_log) == 1:; mode = 'w'; else:; mode = 'a'; f = open(self.grad_norm_file, mode); f.write(""{}\n"".format(grad_norm)); f.close(). [docs] def update_grad_log(self, grad):; """"""add an entry to the grad log""""""; self.grad_log.append(grad); if self.write_to_file:; fname = ""{}-fid_err_gradients{}.{}"".format(self.fname_base,; len(self.grad_log),; self.dump_",MatchSource.WIKI,docs/4.2/modules/qutip/control/dump.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/control/dump.html
https://qutip.org/docs/4.2/modules/qutip/control/dump.html:11109,Testability,log,log,11109,"get_header_line(self.summary_sep),; ois.get_value_line(self.summary_sep))); else:; f = open(self.summary_file, 'a'); f.write(""{}\n"".format(; ois.get_value_line(self.summary_sep))). f.close(); return ois. @property; def fid_err_file(self):; if self._fid_err_file is None:; fname = ""{}-fid_err_log.{}"".format(self.fname_base,; self.dump_file_ext); self._fid_err_file = os.path.join(self.dump_dir, fname); return self._fid_err_file. [docs] def update_fid_err_log(self, fid_err):; """"""add an entry to the fid_err log""""""; self.fid_err_log.append(fid_err); if self.write_to_file:; if len(self.fid_err_log) == 1:; mode = 'w'; else:; mode = 'a'; f = open(self.fid_err_file, mode); f.write(""{}\n"".format(fid_err)); f.close(). @property; def grad_norm_file(self):; if self._grad_norm_file is None:; fname = ""{}-grad_norm_log.{}"".format(self.fname_base,; self.dump_file_ext); self._grad_norm_file = os.path.join(self.dump_dir, fname); return self._grad_norm_file. [docs] def update_grad_norm_log(self, grad_norm):; """"""add an entry to the grad_norm log""""""; self.grad_norm_log.append(grad_norm); if self.write_to_file:; if len(self.grad_norm_log) == 1:; mode = 'w'; else:; mode = 'a'; f = open(self.grad_norm_file, mode); f.write(""{}\n"".format(grad_norm)); f.close(). [docs] def update_grad_log(self, grad):; """"""add an entry to the grad log""""""; self.grad_log.append(grad); if self.write_to_file:; fname = ""{}-fid_err_gradients{}.{}"".format(self.fname_base,; len(self.grad_log),; self.dump_file_ext); fpath = os.path.join(self.dump_dir, fname); np.savetxt(fpath, grad, delimiter=self.data_sep). [docs] def writeout(self, f=None):; """"""write all the logs and the summary out to file(s). Parameters; ----------; f : filename or filehandle; If specified then all summary and object data will go in one file.; If None is specified then type specific files will be generated; in the dump_dir; If a filehandle is specified then it must be a byte mode file; as numpy.savetxt is used, and requires this.; """"""; fall = None; #",MatchSource.WIKI,docs/4.2/modules/qutip/control/dump.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/control/dump.html
https://qutip.org/docs/4.2/modules/qutip/control/dump.html:11396,Testability,log,log,11396,"g.{}"".format(self.fname_base,; self.dump_file_ext); self._fid_err_file = os.path.join(self.dump_dir, fname); return self._fid_err_file. [docs] def update_fid_err_log(self, fid_err):; """"""add an entry to the fid_err log""""""; self.fid_err_log.append(fid_err); if self.write_to_file:; if len(self.fid_err_log) == 1:; mode = 'w'; else:; mode = 'a'; f = open(self.fid_err_file, mode); f.write(""{}\n"".format(fid_err)); f.close(). @property; def grad_norm_file(self):; if self._grad_norm_file is None:; fname = ""{}-grad_norm_log.{}"".format(self.fname_base,; self.dump_file_ext); self._grad_norm_file = os.path.join(self.dump_dir, fname); return self._grad_norm_file. [docs] def update_grad_norm_log(self, grad_norm):; """"""add an entry to the grad_norm log""""""; self.grad_norm_log.append(grad_norm); if self.write_to_file:; if len(self.grad_norm_log) == 1:; mode = 'w'; else:; mode = 'a'; f = open(self.grad_norm_file, mode); f.write(""{}\n"".format(grad_norm)); f.close(). [docs] def update_grad_log(self, grad):; """"""add an entry to the grad log""""""; self.grad_log.append(grad); if self.write_to_file:; fname = ""{}-fid_err_gradients{}.{}"".format(self.fname_base,; len(self.grad_log),; self.dump_file_ext); fpath = os.path.join(self.dump_dir, fname); np.savetxt(fpath, grad, delimiter=self.data_sep). [docs] def writeout(self, f=None):; """"""write all the logs and the summary out to file(s). Parameters; ----------; f : filename or filehandle; If specified then all summary and object data will go in one file.; If None is specified then type specific files will be generated; in the dump_dir; If a filehandle is specified then it must be a byte mode file; as numpy.savetxt is used, and requires this.; """"""; fall = None; # If specific file given then write everything to it; if hasattr(f, 'write'):; if not 'b' in f.mode:; raise RuntimeError(""File stream must be in binary mode""); # write all to this stream; fall = f; fs = f; closefall = False; closefs = False; elif f:; # Assume f is a filename; fall = open(f, 'wb'",MatchSource.WIKI,docs/4.2/modules/qutip/control/dump.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/control/dump.html
https://qutip.org/docs/4.2/modules/qutip/control/dump.html:11706,Testability,log,logs,11706," mode = 'a'; f = open(self.fid_err_file, mode); f.write(""{}\n"".format(fid_err)); f.close(). @property; def grad_norm_file(self):; if self._grad_norm_file is None:; fname = ""{}-grad_norm_log.{}"".format(self.fname_base,; self.dump_file_ext); self._grad_norm_file = os.path.join(self.dump_dir, fname); return self._grad_norm_file. [docs] def update_grad_norm_log(self, grad_norm):; """"""add an entry to the grad_norm log""""""; self.grad_norm_log.append(grad_norm); if self.write_to_file:; if len(self.grad_norm_log) == 1:; mode = 'w'; else:; mode = 'a'; f = open(self.grad_norm_file, mode); f.write(""{}\n"".format(grad_norm)); f.close(). [docs] def update_grad_log(self, grad):; """"""add an entry to the grad log""""""; self.grad_log.append(grad); if self.write_to_file:; fname = ""{}-fid_err_gradients{}.{}"".format(self.fname_base,; len(self.grad_log),; self.dump_file_ext); fpath = os.path.join(self.dump_dir, fname); np.savetxt(fpath, grad, delimiter=self.data_sep). [docs] def writeout(self, f=None):; """"""write all the logs and the summary out to file(s). Parameters; ----------; f : filename or filehandle; If specified then all summary and object data will go in one file.; If None is specified then type specific files will be generated; in the dump_dir; If a filehandle is specified then it must be a byte mode file; as numpy.savetxt is used, and requires this.; """"""; fall = None; # If specific file given then write everything to it; if hasattr(f, 'write'):; if not 'b' in f.mode:; raise RuntimeError(""File stream must be in binary mode""); # write all to this stream; fall = f; fs = f; closefall = False; closefs = False; elif f:; # Assume f is a filename; fall = open(f, 'wb'); fs = fall; closefs = False; closefall = True; else:; self.create_dump_dir(); closefall = False; if self.dump_summary:; fs = open(self.summary_file, 'wb'); closefs = True. if self.dump_summary:; for ois in self.iter_summary:; if ois.idx == 0:; fs.write(asbytes(""{}\n{}\n"".format(; ois.get_header_line(self.summary_sep),; ois.ge",MatchSource.WIKI,docs/4.2/modules/qutip/control/dump.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/control/dump.html
https://qutip.org/docs/4.2/modules/qutip/control/dump.html:12838,Testability,log,logger,12838,"ata will go in one file.; If None is specified then type specific files will be generated; in the dump_dir; If a filehandle is specified then it must be a byte mode file; as numpy.savetxt is used, and requires this.; """"""; fall = None; # If specific file given then write everything to it; if hasattr(f, 'write'):; if not 'b' in f.mode:; raise RuntimeError(""File stream must be in binary mode""); # write all to this stream; fall = f; fs = f; closefall = False; closefs = False; elif f:; # Assume f is a filename; fall = open(f, 'wb'); fs = fall; closefs = False; closefall = True; else:; self.create_dump_dir(); closefall = False; if self.dump_summary:; fs = open(self.summary_file, 'wb'); closefs = True. if self.dump_summary:; for ois in self.iter_summary:; if ois.idx == 0:; fs.write(asbytes(""{}\n{}\n"".format(; ois.get_header_line(self.summary_sep),; ois.get_value_line(self.summary_sep)))); else:; fs.write(asbytes(""{}\n"".format(; ois.get_value_line(self.summary_sep)))). if closefs:; fs.close(); logger.info(""Optim dump summary saved to {}"".format(; self.summary_file)). if self.dump_fid_err:; if fall:; fall.write(asbytes(""Fidelity errors:\n"")); np.savetxt(fall, self.fid_err_log); else:; np.savetxt(self.fid_err_file, self.fid_err_log). if self.dump_grad_norm:; if fall:; fall.write(asbytes(""gradients norms:\n"")); np.savetxt(fall, self.grad_norm_log); else:; np.savetxt(self.grad_norm_file, self.grad_norm_log). if self.dump_grad:; g_num = 0; for grad in self.grad_log:; g_num += 1; if fall:; fall.write(asbytes(""gradients (call {}):\n"".format(g_num))); np.savetxt(fall, grad); else:; fname = ""{}-fid_err_gradients{}.{}"".format(self.fname_base,; g_num,; self.dump_file_ext); fpath = os.path.join(self.dump_dir, fname); np.savetxt(fpath, grad, delimiter=self.data_sep). if closefall:; fall.close(); logger.info(""Optim dump saved to {}"".format(f)); else:; if fall:; logger.info(""Optim dump saved to specified stream""); else:; logger.info(""Optim dump saved to {}"".format(self.dump_dir)). [docs]c",MatchSource.WIKI,docs/4.2/modules/qutip/control/dump.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/control/dump.html
https://qutip.org/docs/4.2/modules/qutip/control/dump.html:13643,Testability,log,logger,13643,"format(; ois.get_header_line(self.summary_sep),; ois.get_value_line(self.summary_sep)))); else:; fs.write(asbytes(""{}\n"".format(; ois.get_value_line(self.summary_sep)))). if closefs:; fs.close(); logger.info(""Optim dump summary saved to {}"".format(; self.summary_file)). if self.dump_fid_err:; if fall:; fall.write(asbytes(""Fidelity errors:\n"")); np.savetxt(fall, self.fid_err_log); else:; np.savetxt(self.fid_err_file, self.fid_err_log). if self.dump_grad_norm:; if fall:; fall.write(asbytes(""gradients norms:\n"")); np.savetxt(fall, self.grad_norm_log); else:; np.savetxt(self.grad_norm_file, self.grad_norm_log). if self.dump_grad:; g_num = 0; for grad in self.grad_log:; g_num += 1; if fall:; fall.write(asbytes(""gradients (call {}):\n"".format(g_num))); np.savetxt(fall, grad); else:; fname = ""{}-fid_err_gradients{}.{}"".format(self.fname_base,; g_num,; self.dump_file_ext); fpath = os.path.join(self.dump_dir, fname); np.savetxt(fpath, grad, delimiter=self.data_sep). if closefall:; fall.close(); logger.info(""Optim dump saved to {}"".format(f)); else:; if fall:; logger.info(""Optim dump saved to specified stream""); else:; logger.info(""Optim dump saved to {}"".format(self.dump_dir)). [docs]class DynamicsDump(Dump):; """"""; A container for dumps of dynamics data.; Mainly time evolution calculations. Attributes; ----------; dump_summary : bool; If True a summary is recorded. evo_summary : list of :class:`tslotcomp.EvoCompSummary'; Summary items are appended if dump_summary is True; at each recomputation of the evolution. dump_amps : bool; If True control amplitudes are dumped. dump_dyn_gen : bool; If True the dynamics generators (Hamiltonians) are dumped. dump_prop : bool; If True propagators are dumped. dump_prop_grad : bool; If True propagator gradients are dumped. dump_fwd_evo : bool; If True forward evolution operators are dumped. dump_onwd_evo : bool; If True onward evolution operators are dumped. dump_onto_evo : bool; If True onto (or backward) evolution operators are dumped. ev",MatchSource.WIKI,docs/4.2/modules/qutip/control/dump.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/control/dump.html
https://qutip.org/docs/4.2/modules/qutip/control/dump.html:13709,Testability,log,logger,13709,"_value_line(self.summary_sep)))); else:; fs.write(asbytes(""{}\n"".format(; ois.get_value_line(self.summary_sep)))). if closefs:; fs.close(); logger.info(""Optim dump summary saved to {}"".format(; self.summary_file)). if self.dump_fid_err:; if fall:; fall.write(asbytes(""Fidelity errors:\n"")); np.savetxt(fall, self.fid_err_log); else:; np.savetxt(self.fid_err_file, self.fid_err_log). if self.dump_grad_norm:; if fall:; fall.write(asbytes(""gradients norms:\n"")); np.savetxt(fall, self.grad_norm_log); else:; np.savetxt(self.grad_norm_file, self.grad_norm_log). if self.dump_grad:; g_num = 0; for grad in self.grad_log:; g_num += 1; if fall:; fall.write(asbytes(""gradients (call {}):\n"".format(g_num))); np.savetxt(fall, grad); else:; fname = ""{}-fid_err_gradients{}.{}"".format(self.fname_base,; g_num,; self.dump_file_ext); fpath = os.path.join(self.dump_dir, fname); np.savetxt(fpath, grad, delimiter=self.data_sep). if closefall:; fall.close(); logger.info(""Optim dump saved to {}"".format(f)); else:; if fall:; logger.info(""Optim dump saved to specified stream""); else:; logger.info(""Optim dump saved to {}"".format(self.dump_dir)). [docs]class DynamicsDump(Dump):; """"""; A container for dumps of dynamics data.; Mainly time evolution calculations. Attributes; ----------; dump_summary : bool; If True a summary is recorded. evo_summary : list of :class:`tslotcomp.EvoCompSummary'; Summary items are appended if dump_summary is True; at each recomputation of the evolution. dump_amps : bool; If True control amplitudes are dumped. dump_dyn_gen : bool; If True the dynamics generators (Hamiltonians) are dumped. dump_prop : bool; If True propagators are dumped. dump_prop_grad : bool; If True propagator gradients are dumped. dump_fwd_evo : bool; If True forward evolution operators are dumped. dump_onwd_evo : bool; If True onward evolution operators are dumped. dump_onto_evo : bool; If True onto (or backward) evolution operators are dumped. evo_dumps : list of :class:`EvoCompDumpItem`; A new dump i",MatchSource.WIKI,docs/4.2/modules/qutip/control/dump.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/control/dump.html
https://qutip.org/docs/4.2/modules/qutip/control/dump.html:13769,Testability,log,logger,13769,"e(asbytes(""{}\n"".format(; ois.get_value_line(self.summary_sep)))). if closefs:; fs.close(); logger.info(""Optim dump summary saved to {}"".format(; self.summary_file)). if self.dump_fid_err:; if fall:; fall.write(asbytes(""Fidelity errors:\n"")); np.savetxt(fall, self.fid_err_log); else:; np.savetxt(self.fid_err_file, self.fid_err_log). if self.dump_grad_norm:; if fall:; fall.write(asbytes(""gradients norms:\n"")); np.savetxt(fall, self.grad_norm_log); else:; np.savetxt(self.grad_norm_file, self.grad_norm_log). if self.dump_grad:; g_num = 0; for grad in self.grad_log:; g_num += 1; if fall:; fall.write(asbytes(""gradients (call {}):\n"".format(g_num))); np.savetxt(fall, grad); else:; fname = ""{}-fid_err_gradients{}.{}"".format(self.fname_base,; g_num,; self.dump_file_ext); fpath = os.path.join(self.dump_dir, fname); np.savetxt(fpath, grad, delimiter=self.data_sep). if closefall:; fall.close(); logger.info(""Optim dump saved to {}"".format(f)); else:; if fall:; logger.info(""Optim dump saved to specified stream""); else:; logger.info(""Optim dump saved to {}"".format(self.dump_dir)). [docs]class DynamicsDump(Dump):; """"""; A container for dumps of dynamics data.; Mainly time evolution calculations. Attributes; ----------; dump_summary : bool; If True a summary is recorded. evo_summary : list of :class:`tslotcomp.EvoCompSummary'; Summary items are appended if dump_summary is True; at each recomputation of the evolution. dump_amps : bool; If True control amplitudes are dumped. dump_dyn_gen : bool; If True the dynamics generators (Hamiltonians) are dumped. dump_prop : bool; If True propagators are dumped. dump_prop_grad : bool; If True propagator gradients are dumped. dump_fwd_evo : bool; If True forward evolution operators are dumped. dump_onwd_evo : bool; If True onward evolution operators are dumped. dump_onto_evo : bool; If True onto (or backward) evolution operators are dumped. evo_dumps : list of :class:`EvoCompDumpItem`; A new dump item is appended at each recomputation of the evo",MatchSource.WIKI,docs/4.2/modules/qutip/control/dump.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/control/dump.html
https://qutip.org/docs/4.2/modules/qutip/control/dump.html:19756,Testability,log,logger,19756,"data will go in one file.; If None is specified then type specific files will be generated; in the dump_dir; If a filehandle is specified then it must be a byte mode file; as numpy.savetxt is used, and requires this.; """"""; fall = None; # If specific file given then write everything to it; if hasattr(f, 'write'):; if not 'b' in f.mode:; raise RuntimeError(""File stream must be in binary mode""); # write all to this stream; fall = f; fs = f; closefall = False; closefs = False; elif f:; # Assume f is a filename; fall = open(f, 'wb'); fs = fall; closefs = False; closefall = True; else:; self.create_dump_dir(); closefall = False; if self.dump_summary:; fs = open(self.summary_file, 'wb'); closefs = True. if self.dump_summary:; for ecs in self.evo_summary:; if ecs.idx == 0:; fs.write(asbytes(""{}\n{}\n"".format(; ecs.get_header_line(self.summary_sep),; ecs.get_value_line(self.summary_sep)))); else:; fs.write(asbytes(""{}\n"".format(; ecs.get_value_line(self.summary_sep)))). if closefs:; fs.close(); logger.info(""Dynamics dump summary saved to {}"".format(; self.summary_file)). for di in self.evo_dumps:; di.writeout(fall). if closefall:; fall.close(); logger.info(""Dynamics dump saved to {}"".format(f)); else:; if fall:; logger.info(""Dynamics dump saved to specified stream""); else:; logger.info(""Dynamics dump saved to {}"".format(self.dump_dir)). [docs]class DumpItem(object):; """"""; An item in a dump list; """"""; def __init__(self):; pass. [docs]class EvoCompDumpItem(DumpItem):; """"""; A copy of all objects generated to calculate one time evolution; Note the attributes are only set if the corresponding; :class:`DynamicsDump` dump_ attribute is set.; """"""; def __init__(self, dump):; if not isinstance(dump, DynamicsDump):; raise TypeError(""Must instantiate with {} type"".format(; DynamicsDump)); self.parent = dump; self.reset(). def reset(self):; self.idx = None; # self.num_ctrls = None; # self.num_tslots = None; self.ctrl_amps = None; self.dyn_gen = None; self.prop = None; self.prop_grad = No",MatchSource.WIKI,docs/4.2/modules/qutip/control/dump.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/control/dump.html
https://qutip.org/docs/4.2/modules/qutip/control/dump.html:19909,Testability,log,logger,19909," a byte mode file; as numpy.savetxt is used, and requires this.; """"""; fall = None; # If specific file given then write everything to it; if hasattr(f, 'write'):; if not 'b' in f.mode:; raise RuntimeError(""File stream must be in binary mode""); # write all to this stream; fall = f; fs = f; closefall = False; closefs = False; elif f:; # Assume f is a filename; fall = open(f, 'wb'); fs = fall; closefs = False; closefall = True; else:; self.create_dump_dir(); closefall = False; if self.dump_summary:; fs = open(self.summary_file, 'wb'); closefs = True. if self.dump_summary:; for ecs in self.evo_summary:; if ecs.idx == 0:; fs.write(asbytes(""{}\n{}\n"".format(; ecs.get_header_line(self.summary_sep),; ecs.get_value_line(self.summary_sep)))); else:; fs.write(asbytes(""{}\n"".format(; ecs.get_value_line(self.summary_sep)))). if closefs:; fs.close(); logger.info(""Dynamics dump summary saved to {}"".format(; self.summary_file)). for di in self.evo_dumps:; di.writeout(fall). if closefall:; fall.close(); logger.info(""Dynamics dump saved to {}"".format(f)); else:; if fall:; logger.info(""Dynamics dump saved to specified stream""); else:; logger.info(""Dynamics dump saved to {}"".format(self.dump_dir)). [docs]class DumpItem(object):; """"""; An item in a dump list; """"""; def __init__(self):; pass. [docs]class EvoCompDumpItem(DumpItem):; """"""; A copy of all objects generated to calculate one time evolution; Note the attributes are only set if the corresponding; :class:`DynamicsDump` dump_ attribute is set.; """"""; def __init__(self, dump):; if not isinstance(dump, DynamicsDump):; raise TypeError(""Must instantiate with {} type"".format(; DynamicsDump)); self.parent = dump; self.reset(). def reset(self):; self.idx = None; # self.num_ctrls = None; # self.num_tslots = None; self.ctrl_amps = None; self.dyn_gen = None; self.prop = None; self.prop_grad = None; self.fwd_evo = None; self.onwd_evo = None; self.onto_evo = None. [docs] def writeout(self, f=None):; """""" write all the objects out to files. Paramete",MatchSource.WIKI,docs/4.2/modules/qutip/control/dump.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/control/dump.html
https://qutip.org/docs/4.2/modules/qutip/control/dump.html:19978,Testability,log,logger,19978,"his.; """"""; fall = None; # If specific file given then write everything to it; if hasattr(f, 'write'):; if not 'b' in f.mode:; raise RuntimeError(""File stream must be in binary mode""); # write all to this stream; fall = f; fs = f; closefall = False; closefs = False; elif f:; # Assume f is a filename; fall = open(f, 'wb'); fs = fall; closefs = False; closefall = True; else:; self.create_dump_dir(); closefall = False; if self.dump_summary:; fs = open(self.summary_file, 'wb'); closefs = True. if self.dump_summary:; for ecs in self.evo_summary:; if ecs.idx == 0:; fs.write(asbytes(""{}\n{}\n"".format(; ecs.get_header_line(self.summary_sep),; ecs.get_value_line(self.summary_sep)))); else:; fs.write(asbytes(""{}\n"".format(; ecs.get_value_line(self.summary_sep)))). if closefs:; fs.close(); logger.info(""Dynamics dump summary saved to {}"".format(; self.summary_file)). for di in self.evo_dumps:; di.writeout(fall). if closefall:; fall.close(); logger.info(""Dynamics dump saved to {}"".format(f)); else:; if fall:; logger.info(""Dynamics dump saved to specified stream""); else:; logger.info(""Dynamics dump saved to {}"".format(self.dump_dir)). [docs]class DumpItem(object):; """"""; An item in a dump list; """"""; def __init__(self):; pass. [docs]class EvoCompDumpItem(DumpItem):; """"""; A copy of all objects generated to calculate one time evolution; Note the attributes are only set if the corresponding; :class:`DynamicsDump` dump_ attribute is set.; """"""; def __init__(self, dump):; if not isinstance(dump, DynamicsDump):; raise TypeError(""Must instantiate with {} type"".format(; DynamicsDump)); self.parent = dump; self.reset(). def reset(self):; self.idx = None; # self.num_ctrls = None; # self.num_tslots = None; self.ctrl_amps = None; self.dyn_gen = None; self.prop = None; self.prop_grad = None; self.fwd_evo = None; self.onwd_evo = None; self.onto_evo = None. [docs] def writeout(self, f=None):; """""" write all the objects out to files. Parameters; ----------; f : filename or filehandle; If specified th",MatchSource.WIKI,docs/4.2/modules/qutip/control/dump.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/control/dump.html
https://qutip.org/docs/4.2/modules/qutip/control/dump.html:20041,Testability,log,logger,20041,"then write everything to it; if hasattr(f, 'write'):; if not 'b' in f.mode:; raise RuntimeError(""File stream must be in binary mode""); # write all to this stream; fall = f; fs = f; closefall = False; closefs = False; elif f:; # Assume f is a filename; fall = open(f, 'wb'); fs = fall; closefs = False; closefall = True; else:; self.create_dump_dir(); closefall = False; if self.dump_summary:; fs = open(self.summary_file, 'wb'); closefs = True. if self.dump_summary:; for ecs in self.evo_summary:; if ecs.idx == 0:; fs.write(asbytes(""{}\n{}\n"".format(; ecs.get_header_line(self.summary_sep),; ecs.get_value_line(self.summary_sep)))); else:; fs.write(asbytes(""{}\n"".format(; ecs.get_value_line(self.summary_sep)))). if closefs:; fs.close(); logger.info(""Dynamics dump summary saved to {}"".format(; self.summary_file)). for di in self.evo_dumps:; di.writeout(fall). if closefall:; fall.close(); logger.info(""Dynamics dump saved to {}"".format(f)); else:; if fall:; logger.info(""Dynamics dump saved to specified stream""); else:; logger.info(""Dynamics dump saved to {}"".format(self.dump_dir)). [docs]class DumpItem(object):; """"""; An item in a dump list; """"""; def __init__(self):; pass. [docs]class EvoCompDumpItem(DumpItem):; """"""; A copy of all objects generated to calculate one time evolution; Note the attributes are only set if the corresponding; :class:`DynamicsDump` dump_ attribute is set.; """"""; def __init__(self, dump):; if not isinstance(dump, DynamicsDump):; raise TypeError(""Must instantiate with {} type"".format(; DynamicsDump)); self.parent = dump; self.reset(). def reset(self):; self.idx = None; # self.num_ctrls = None; # self.num_tslots = None; self.ctrl_amps = None; self.dyn_gen = None; self.prop = None; self.prop_grad = None; self.fwd_evo = None; self.onwd_evo = None; self.onto_evo = None. [docs] def writeout(self, f=None):; """""" write all the objects out to files. Parameters; ----------; f : filename or filehandle; If specified then all object data will go in one file.; If None i",MatchSource.WIKI,docs/4.2/modules/qutip/control/dump.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/control/dump.html
https://qutip.org/docs/4.2/modules/qutip/control/dump.html:8462,Usability,clear,clear,8462,"er.OptimIterSummary`; Summary at each iteration. dump_fid_err : bool; When True values are appended to the fid_err_log. fid_err_log : list of float; Fidelity error at each call of the fid_err_func. dump_grad_norm : bool; When True values are appended to the fid_err_log. grad_norm_log : list of float; Gradient norm at each call of the grad_norm_log. dump_grad : bool; When True values are appended to the grad_log. grad_log : list of ndarray; Gradients at each call of the fid_grad_func. """"""; def __init__(self, optim, level='SUMMARY'):; from qutip.control.optimizer import Optimizer; if not isinstance(optim, Optimizer):; raise TypeError(""Must instantiate with {} type"".format(; Optimizer)); self.parent = optim; self._level = level; self.reset(). def reset(self):; Dump.reset(self); self._apply_level(); self.iter_summary = []; self.fid_err_log = []; self.grad_norm_log = []; self.grad_log = []; self._fname_base = 'optimdump'; self._fid_err_file = None; self._grad_norm_file = None. def clear(self):; del self.iter_summary[:]; self.fid_err_log[:]; self.grad_norm_log[:]; self.grad_log[:]. @property; def dump_any(self):; """"""True if anything other than the summary is to be dumped""""""; if (self.dump_fid_err or self.dump_grad_norm or self.dump_grad):; return True; else:; return False. @property; def dump_all(self):; """"""True if everything (ignoring the summary) is to be dumped""""""; if (self.dump_fid_err and self.dump_grad_norm and self.dump_grad):; return True; else:; return False. def _apply_level(self, level=None):; if level is None:; level = self._level. if not _is_string(level):; raise ValueError(""Dump level must be a string""); level = level.upper(); if level == 'CUSTOM':; if self._level == 'CUSTOM':; # dumping level has not changed keep the same specific config; pass; else:; # Switching to custom, start from SUMMARY; level = 'SUMMARY'. if level == 'SUMMARY':; self.dump_summary = True; self.dump_fid_err = False; self.dump_grad_norm = False; self.dump_grad = False; elif level == 'FU",MatchSource.WIKI,docs/4.2/modules/qutip/control/dump.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/control/dump.html
https://qutip.org/docs/4.2/modules/qutip/control/dump.html:15216,Usability,clear,clear,15216,". dump_dyn_gen : bool; If True the dynamics generators (Hamiltonians) are dumped. dump_prop : bool; If True propagators are dumped. dump_prop_grad : bool; If True propagator gradients are dumped. dump_fwd_evo : bool; If True forward evolution operators are dumped. dump_onwd_evo : bool; If True onward evolution operators are dumped. dump_onto_evo : bool; If True onto (or backward) evolution operators are dumped. evo_dumps : list of :class:`EvoCompDumpItem`; A new dump item is appended at each recomputation of the evolution.; That is if any of the calculation objects are to be dumped. """"""; def __init__(self, dynamics, level='SUMMARY'):; from qutip.control.dynamics import Dynamics; if not isinstance(dynamics, Dynamics):; raise TypeError(""Must instantiate with {} type"".format(; Dynamics)); self.parent = dynamics; self._level = level; self.reset(). def reset(self):; Dump.reset(self); self._apply_level(); self.evo_dumps = []; self.evo_summary = []; self._fname_base = 'dyndump'. def clear(self):; del self.evo_dumps[:]; del self.evo_summary[:]. @property; def dump_any(self):; """"""True if any of the calculation objects are to be dumped""""""; if (self.dump_amps or; self.dump_dyn_gen or; self.dump_prop or; self.dump_prop_grad or; self.dump_fwd_evo or; self.dump_onwd_evo or; self.dump_onto_evo):; return True; else:; return False. @property; def dump_all(self):; """"""True if all of the calculation objects are to be dumped""""""; dyn = self.parent; if (self.dump_amps and; self.dump_dyn_gen and; self.dump_prop and; self.dump_prop_grad and; self.dump_fwd_evo and; (self.dump_onwd_evo) or; (self.dump_onwd_evo == dyn.fid_computer.uses_onwd_evo) and; (self.dump_onto_evo or; (self.dump_onto_evo == dyn.fid_computer.uses_onto_evo))):; return True; else:; return False. def _apply_level(self, level=None):; dyn = self.parent; if level is None:; level = self._level. if not _is_string(level):; raise ValueError(""Dump level must be a string""); level = level.upper(); if level == 'CUSTOM':; if self._level",MatchSource.WIKI,docs/4.2/modules/qutip/control/dump.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/control/dump.html
https://qutip.org/docs/4.2/modules/qutip/control/dynamics.html:3385,Availability,error,errors,3385,"the dynamics generators (Hamiltonians,; Limbladians etc). The dynamics for the time slices are calculated here, along; with the evolution as determined by the control amplitudes. See the subclass descriptions and choose the appropriate class for the; application. The choice depends on the type of matrix used to define; the dynamics. These class implement functions for getting the dynamics generators for; the combined (drift + ctrls) dynamics with the approriate operator applied. Note the methods in these classes were inspired by:; DYNAMO - Dynamic Framework for Quantum Optimal Control; See Machnes et.al., arXiv.1011.4874; """"""; import os; import warnings; import numpy as np; import scipy.linalg as la; import scipy.sparse as sp; # QuTiP; from qutip import Qobj; from qutip.sparse import sp_eigs, _dense_eigs; import qutip.settings as settings; # QuTiP logging; import qutip.logging_utils as logging; logger = logging.get_logger(); # QuTiP control modules; import qutip.control.errors as errors; import qutip.control.tslotcomp as tslotcomp; import qutip.control.fidcomp as fidcomp; import qutip.control.propcomp as propcomp; import qutip.control.symplectic as sympl; import qutip.control.dump as qtrldump. DEF_NUM_TSLOTS = 10; DEF_EVO_TIME = 1.0. def _is_string(var):; try:; if isinstance(var, basestring):; return True; except NameError:; try:; if isinstance(var, str):; return True; except:; return False; except:; return False. return False; ; def _check_ctrls_container(ctrls):; """"""; Check through the controls container.; Convert to an array if its a list of lists; return the processed container; raise type error if the container structure is invalid; """"""; if isinstance(ctrls, (list, tuple)):; # Check to see if list of lists; try:; if isinstance(ctrls[0], (list, tuple)):; ctrls = np.array(ctrls); except:; pass; ; if isinstance(ctrls, np.ndarray):; if len(ctrls.shape) != 2:; raise TypeError(""Incorrect shape for ctrl dyn gen array""); for k in range(ctrls.shape[0]):; for j in range(c",MatchSource.WIKI,docs/4.2/modules/qutip/control/dynamics.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/control/dynamics.html
https://qutip.org/docs/4.2/modules/qutip/control/dynamics.html:3395,Availability,error,errors,3395,"the dynamics generators (Hamiltonians,; Limbladians etc). The dynamics for the time slices are calculated here, along; with the evolution as determined by the control amplitudes. See the subclass descriptions and choose the appropriate class for the; application. The choice depends on the type of matrix used to define; the dynamics. These class implement functions for getting the dynamics generators for; the combined (drift + ctrls) dynamics with the approriate operator applied. Note the methods in these classes were inspired by:; DYNAMO - Dynamic Framework for Quantum Optimal Control; See Machnes et.al., arXiv.1011.4874; """"""; import os; import warnings; import numpy as np; import scipy.linalg as la; import scipy.sparse as sp; # QuTiP; from qutip import Qobj; from qutip.sparse import sp_eigs, _dense_eigs; import qutip.settings as settings; # QuTiP logging; import qutip.logging_utils as logging; logger = logging.get_logger(); # QuTiP control modules; import qutip.control.errors as errors; import qutip.control.tslotcomp as tslotcomp; import qutip.control.fidcomp as fidcomp; import qutip.control.propcomp as propcomp; import qutip.control.symplectic as sympl; import qutip.control.dump as qtrldump. DEF_NUM_TSLOTS = 10; DEF_EVO_TIME = 1.0. def _is_string(var):; try:; if isinstance(var, basestring):; return True; except NameError:; try:; if isinstance(var, str):; return True; except:; return False; except:; return False. return False; ; def _check_ctrls_container(ctrls):; """"""; Check through the controls container.; Convert to an array if its a list of lists; return the processed container; raise type error if the container structure is invalid; """"""; if isinstance(ctrls, (list, tuple)):; # Check to see if list of lists; try:; if isinstance(ctrls[0], (list, tuple)):; ctrls = np.array(ctrls); except:; pass; ; if isinstance(ctrls, np.ndarray):; if len(ctrls.shape) != 2:; raise TypeError(""Incorrect shape for ctrl dyn gen array""); for k in range(ctrls.shape[0]):; for j in range(c",MatchSource.WIKI,docs/4.2/modules/qutip/control/dynamics.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/control/dynamics.html
https://qutip.org/docs/4.2/modules/qutip/control/dynamics.html:4021,Availability,error,error,4021,"ort numpy as np; import scipy.linalg as la; import scipy.sparse as sp; # QuTiP; from qutip import Qobj; from qutip.sparse import sp_eigs, _dense_eigs; import qutip.settings as settings; # QuTiP logging; import qutip.logging_utils as logging; logger = logging.get_logger(); # QuTiP control modules; import qutip.control.errors as errors; import qutip.control.tslotcomp as tslotcomp; import qutip.control.fidcomp as fidcomp; import qutip.control.propcomp as propcomp; import qutip.control.symplectic as sympl; import qutip.control.dump as qtrldump. DEF_NUM_TSLOTS = 10; DEF_EVO_TIME = 1.0. def _is_string(var):; try:; if isinstance(var, basestring):; return True; except NameError:; try:; if isinstance(var, str):; return True; except:; return False; except:; return False. return False; ; def _check_ctrls_container(ctrls):; """"""; Check through the controls container.; Convert to an array if its a list of lists; return the processed container; raise type error if the container structure is invalid; """"""; if isinstance(ctrls, (list, tuple)):; # Check to see if list of lists; try:; if isinstance(ctrls[0], (list, tuple)):; ctrls = np.array(ctrls); except:; pass; ; if isinstance(ctrls, np.ndarray):; if len(ctrls.shape) != 2:; raise TypeError(""Incorrect shape for ctrl dyn gen array""); for k in range(ctrls.shape[0]):; for j in range(ctrls.shape[1]):; if not isinstance(ctrls[k, j], Qobj):; raise TypeError(""All control dyn gen must be Qobj""); elif isinstance(ctrls, (list, tuple)):; for ctrl in ctrls:; if not isinstance(ctrl, Qobj):; raise TypeError(""All control dyn gen must be Qobj"") ; else:; raise TypeError(""Controls list or array not set correctly""); ; return ctrls; ; def _check_drift_dyn_gen(drift):; if not isinstance(drift, Qobj):; if not isinstance(drift, (list, tuple)):; raise TypeError(""drift should be a Qobj or a list of Qobj""); else:; for d in drift:; if not isinstance(d, Qobj):; raise TypeError(; ""drift should be a Qobj or a list of Qobj""). warnings.simplefilter('always', Deprec",MatchSource.WIKI,docs/4.2/modules/qutip/control/dynamics.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/control/dynamics.html
https://qutip.org/docs/4.2/modules/qutip/control/dynamics.html:7527,Availability,error,error,7527,"_utils,; in decreasing levels of messaging, are:; DEBUG_INTENSE, DEBUG_VERBOSE, DEBUG, INFO, WARN, ERROR, CRITICAL; Anything WARN or above is effectively 'quiet' execution,; assuming everything runs as expected.; The default NOTSET implies that the level will be taken from; the QuTiP settings file, which by default is WARN. params: Dictionary; The key value pairs are the attribute name and value; Note: attributes are created if they do not exist already,; and are overwritten if they do. stats : Stats; Attributes of which give performance stats for the optimisation; set to None to reduce overhead of calculating stats.; Note it is (usually) shared with the Optimizer object. tslot_computer : TimeslotComputer (subclass instance); Used to manage when the timeslot dynamics; generators, propagators, gradients etc are updated. prop_computer : PropagatorComputer (subclass instance); Used to compute the propagators and their gradients. fid_computer : FidelityComputer (subclass instance); Used to computer the fidelity error and the fidelity error; gradient. memory_optimization : int; Level of memory optimisation. Setting to 0 (default) means that; execution speed is prioritized over memory.; Setting to 1 means that some memory prioritisation steps will be; taken, for instance using Qobj (and hence sparse arrays) as the; the internal operator data type, and not caching some operators; Potentially further memory saving maybe made with; memory_optimization > 1. ; The options are processed in _set_memory_optimizations, see; this for more information. Individual memory saving options can be; switched by settting them directly (see below). oper_dtype : type; Data type for internal dynamics generators, propagators and time; evolution operators. This can be ndarray or Qobj, or (in theory) any; other representaion that supports typical matrix methods (e.g. dot); ndarray performs best for smaller quantum systems.; Qobj may perform better for larger systems, and will also; perform better ",MatchSource.WIKI,docs/4.2/modules/qutip/control/dynamics.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/control/dynamics.html
https://qutip.org/docs/4.2/modules/qutip/control/dynamics.html:7550,Availability,error,error,7550,"_utils,; in decreasing levels of messaging, are:; DEBUG_INTENSE, DEBUG_VERBOSE, DEBUG, INFO, WARN, ERROR, CRITICAL; Anything WARN or above is effectively 'quiet' execution,; assuming everything runs as expected.; The default NOTSET implies that the level will be taken from; the QuTiP settings file, which by default is WARN. params: Dictionary; The key value pairs are the attribute name and value; Note: attributes are created if they do not exist already,; and are overwritten if they do. stats : Stats; Attributes of which give performance stats for the optimisation; set to None to reduce overhead of calculating stats.; Note it is (usually) shared with the Optimizer object. tslot_computer : TimeslotComputer (subclass instance); Used to manage when the timeslot dynamics; generators, propagators, gradients etc are updated. prop_computer : PropagatorComputer (subclass instance); Used to compute the propagators and their gradients. fid_computer : FidelityComputer (subclass instance); Used to computer the fidelity error and the fidelity error; gradient. memory_optimization : int; Level of memory optimisation. Setting to 0 (default) means that; execution speed is prioritized over memory.; Setting to 1 means that some memory prioritisation steps will be; taken, for instance using Qobj (and hence sparse arrays) as the; the internal operator data type, and not caching some operators; Potentially further memory saving maybe made with; memory_optimization > 1. ; The options are processed in _set_memory_optimizations, see; this for more information. Individual memory saving options can be; switched by settting them directly (see below). oper_dtype : type; Data type for internal dynamics generators, propagators and time; evolution operators. This can be ndarray or Qobj, or (in theory) any; other representaion that supports typical matrix methods (e.g. dot); ndarray performs best for smaller quantum systems.; Qobj may perform better for larger systems, and will also; perform better ",MatchSource.WIKI,docs/4.2/modules/qutip/control/dynamics.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/control/dynamics.html
https://qutip.org/docs/4.2/modules/qutip/control/dynamics.html:27760,Availability,error,errors,27760," self.dumping = 'SUMMARY'; self.dump.write_to_file = True; self.dump.create_dump_dir(); logger.info(""Dynamics dump will be written to:\n{}"".format(; self.dump.dump_dir)). def _create_decomp_lists(self):; """"""; Create lists that will hold the eigen decomposition; used in calculating propagators and gradients; Note: used with PropCompDiag propagator calcs; """"""; n_ts = self.num_tslots; self._decomp_curr = [False for x in range(n_ts)]; self._prop_eigen = [object for x in range(n_ts)]; self._dyn_gen_eigenvectors = [object for x in range(n_ts)]; if self.cache_dyn_gen_eigenvectors_adj:; self._dyn_gen_eigenvectors_adj = [object for x in range(n_ts)]; self._dyn_gen_factormatrix = [object for x in range(n_ts)]. [docs] def initialize_controls(self, amps, init_tslots=True):; """"""; Set the initial control amplitudes and time slices; Note this must be called after the configuration is complete; before any dynamics can be calculated; """"""; if not isinstance(self.prop_computer, propcomp.PropagatorComputer):; raise errors.UsageError(; ""No prop_computer (propagator computer) ""; ""set. A default should be assigned by the Dynamics subclass""). if not isinstance(self.tslot_computer, tslotcomp.TimeslotComputer):; raise errors.UsageError(; ""No tslot_computer (Timeslot computer)""; "" set. A default should be assigned by the Dynamics class""). if not isinstance(self.fid_computer, fidcomp.FidelityComputer):; raise errors.UsageError(; ""No fid_computer (Fidelity computer)""; "" set. A default should be assigned by the Dynamics subclass""). self.ctrl_amps = None; if not self._timeslots_initialized:; init_tslots = True; if init_tslots:; self.init_timeslots(); self._init_evo(); self.tslot_computer.init_comp(); self.fid_computer.init_comp(); self._ctrls_initialized = True; self.update_ctrl_amps(amps). def check_ctrls_initialized(self):; if not self._ctrls_initialized:; raise errors.UsageError(; ""Controls not initialised. ""; ""Ensure Dynamics.initialize_controls has been ""; ""executed with the initial control a",MatchSource.WIKI,docs/4.2/modules/qutip/control/dynamics.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/control/dynamics.html
https://qutip.org/docs/4.2/modules/qutip/control/dynamics.html:27961,Availability,error,errors,27961,"; """"""; Create lists that will hold the eigen decomposition; used in calculating propagators and gradients; Note: used with PropCompDiag propagator calcs; """"""; n_ts = self.num_tslots; self._decomp_curr = [False for x in range(n_ts)]; self._prop_eigen = [object for x in range(n_ts)]; self._dyn_gen_eigenvectors = [object for x in range(n_ts)]; if self.cache_dyn_gen_eigenvectors_adj:; self._dyn_gen_eigenvectors_adj = [object for x in range(n_ts)]; self._dyn_gen_factormatrix = [object for x in range(n_ts)]. [docs] def initialize_controls(self, amps, init_tslots=True):; """"""; Set the initial control amplitudes and time slices; Note this must be called after the configuration is complete; before any dynamics can be calculated; """"""; if not isinstance(self.prop_computer, propcomp.PropagatorComputer):; raise errors.UsageError(; ""No prop_computer (propagator computer) ""; ""set. A default should be assigned by the Dynamics subclass""). if not isinstance(self.tslot_computer, tslotcomp.TimeslotComputer):; raise errors.UsageError(; ""No tslot_computer (Timeslot computer)""; "" set. A default should be assigned by the Dynamics class""). if not isinstance(self.fid_computer, fidcomp.FidelityComputer):; raise errors.UsageError(; ""No fid_computer (Fidelity computer)""; "" set. A default should be assigned by the Dynamics subclass""). self.ctrl_amps = None; if not self._timeslots_initialized:; init_tslots = True; if init_tslots:; self.init_timeslots(); self._init_evo(); self.tslot_computer.init_comp(); self.fid_computer.init_comp(); self._ctrls_initialized = True; self.update_ctrl_amps(amps). def check_ctrls_initialized(self):; if not self._ctrls_initialized:; raise errors.UsageError(; ""Controls not initialised. ""; ""Ensure Dynamics.initialize_controls has been ""; ""executed with the initial control amplitudes.""). def get_amp_times(self):; return self.time[:self.num_tslots]. [docs] def save_amps(self, file_name=None, times=None, amps=None, verbose=False):; """"""; Save a file with the current control a",MatchSource.WIKI,docs/4.2/modules/qutip/control/dynamics.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/control/dynamics.html
https://qutip.org/docs/4.2/modules/qutip/control/dynamics.html:28154,Availability,error,errors,28154,"mp_curr = [False for x in range(n_ts)]; self._prop_eigen = [object for x in range(n_ts)]; self._dyn_gen_eigenvectors = [object for x in range(n_ts)]; if self.cache_dyn_gen_eigenvectors_adj:; self._dyn_gen_eigenvectors_adj = [object for x in range(n_ts)]; self._dyn_gen_factormatrix = [object for x in range(n_ts)]. [docs] def initialize_controls(self, amps, init_tslots=True):; """"""; Set the initial control amplitudes and time slices; Note this must be called after the configuration is complete; before any dynamics can be calculated; """"""; if not isinstance(self.prop_computer, propcomp.PropagatorComputer):; raise errors.UsageError(; ""No prop_computer (propagator computer) ""; ""set. A default should be assigned by the Dynamics subclass""). if not isinstance(self.tslot_computer, tslotcomp.TimeslotComputer):; raise errors.UsageError(; ""No tslot_computer (Timeslot computer)""; "" set. A default should be assigned by the Dynamics class""). if not isinstance(self.fid_computer, fidcomp.FidelityComputer):; raise errors.UsageError(; ""No fid_computer (Fidelity computer)""; "" set. A default should be assigned by the Dynamics subclass""). self.ctrl_amps = None; if not self._timeslots_initialized:; init_tslots = True; if init_tslots:; self.init_timeslots(); self._init_evo(); self.tslot_computer.init_comp(); self.fid_computer.init_comp(); self._ctrls_initialized = True; self.update_ctrl_amps(amps). def check_ctrls_initialized(self):; if not self._ctrls_initialized:; raise errors.UsageError(; ""Controls not initialised. ""; ""Ensure Dynamics.initialize_controls has been ""; ""executed with the initial control amplitudes.""). def get_amp_times(self):; return self.time[:self.num_tslots]. [docs] def save_amps(self, file_name=None, times=None, amps=None, verbose=False):; """"""; Save a file with the current control amplitudes in each timeslot; The first column in the file will be the start time of the slot. Parameters; ----------; file_name : string; Name of the file; If None given the def_amps_fname attri",MatchSource.WIKI,docs/4.2/modules/qutip/control/dynamics.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/control/dynamics.html
https://qutip.org/docs/4.2/modules/qutip/control/dynamics.html:28615,Availability,error,errors,28615,"fter the configuration is complete; before any dynamics can be calculated; """"""; if not isinstance(self.prop_computer, propcomp.PropagatorComputer):; raise errors.UsageError(; ""No prop_computer (propagator computer) ""; ""set. A default should be assigned by the Dynamics subclass""). if not isinstance(self.tslot_computer, tslotcomp.TimeslotComputer):; raise errors.UsageError(; ""No tslot_computer (Timeslot computer)""; "" set. A default should be assigned by the Dynamics class""). if not isinstance(self.fid_computer, fidcomp.FidelityComputer):; raise errors.UsageError(; ""No fid_computer (Fidelity computer)""; "" set. A default should be assigned by the Dynamics subclass""). self.ctrl_amps = None; if not self._timeslots_initialized:; init_tslots = True; if init_tslots:; self.init_timeslots(); self._init_evo(); self.tslot_computer.init_comp(); self.fid_computer.init_comp(); self._ctrls_initialized = True; self.update_ctrl_amps(amps). def check_ctrls_initialized(self):; if not self._ctrls_initialized:; raise errors.UsageError(; ""Controls not initialised. ""; ""Ensure Dynamics.initialize_controls has been ""; ""executed with the initial control amplitudes.""). def get_amp_times(self):; return self.time[:self.num_tslots]. [docs] def save_amps(self, file_name=None, times=None, amps=None, verbose=False):; """"""; Save a file with the current control amplitudes in each timeslot; The first column in the file will be the start time of the slot. Parameters; ----------; file_name : string; Name of the file; If None given the def_amps_fname attribuite will be used. times : List type (or string); List / array of the start times for each slot; If None given this will be retrieved through get_amp_times(); If 'exclude' then times will not be saved in the file, just; the amplitudes. amps : Array[num_tslots, num_ctrls]; Amplitudes to be saved; If None given the ctrl_amps attribute will be used. verbose : Boolean; If True then an info message will be logged; """"""; self.check_ctrls_initialized(). inctimes ",MatchSource.WIKI,docs/4.2/modules/qutip/control/dynamics.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/control/dynamics.html
https://qutip.org/docs/4.2/modules/qutip/control/dynamics.html:30271,Availability,error,error,30271,"; If 'exclude' then times will not be saved in the file, just; the amplitudes. amps : Array[num_tslots, num_ctrls]; Amplitudes to be saved; If None given the ctrl_amps attribute will be used. verbose : Boolean; If True then an info message will be logged; """"""; self.check_ctrls_initialized(). inctimes = True; if file_name is None:; file_name = self.def_amps_fname; if amps is None:; amps = self.ctrl_amps; if times is None:; times = self.get_amp_times(); else:; if _is_string(times):; if times.lower() == 'exclude':; inctimes = False; else:; logger.warn(""Unknown option for times '{}' ""; ""when saving amplitudes"".format(times)); times = self.get_amp_times(). try:; if inctimes:; shp = amps.shape; data = np.empty([shp[0], shp[1] + 1], dtype=float); data[:, 0] = times; data[:, 1:] = amps; else:; data = amps. np.savetxt(file_name, data, delimiter='\t', fmt='%14.6g'). if verbose:; logger.info(""Amplitudes saved to file: "" + file_name); except Exception as e:; logger.error(""Failed to save amplitudes due to underling ""; ""error: {}"".format(e)). [docs] def update_ctrl_amps(self, new_amps):; """"""; Determine if any amplitudes have changed. If so, then mark the; timeslots as needing recalculation; The actual work is completed by the compare_amps method of the; timeslot computer; """""". if self.log_level <= logging.DEBUG_INTENSE:; logger.log(logging.DEBUG_INTENSE, ""Updating amplitudes...\n""; ""Current control amplitudes:\n"" + str(self.ctrl_amps) +; ""\n(potenially) new amplitudes:\n"" + str(new_amps)). self.tslot_computer.compare_amps(new_amps). [docs] def flag_system_changed(self):; """"""; Flag evolution, fidelity and gradients as needing recalculation; """"""; self.evo_current = False; self.fid_computer.flag_system_changed(). [docs] def get_drift_dim(self):; """"""; Returns the size of the matrix that defines the drift dynamics; that is assuming the drift is NxN, then this returns N; """"""; if self.dyn_shape is None:; self.refresh_drift_attribs(); return self.dyn_shape[0]; ; [docs] def refresh_drift_a",MatchSource.WIKI,docs/4.2/modules/qutip/control/dynamics.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/control/dynamics.html
https://qutip.org/docs/4.2/modules/qutip/control/dynamics.html:30325,Availability,error,error,30325,"; If 'exclude' then times will not be saved in the file, just; the amplitudes. amps : Array[num_tslots, num_ctrls]; Amplitudes to be saved; If None given the ctrl_amps attribute will be used. verbose : Boolean; If True then an info message will be logged; """"""; self.check_ctrls_initialized(). inctimes = True; if file_name is None:; file_name = self.def_amps_fname; if amps is None:; amps = self.ctrl_amps; if times is None:; times = self.get_amp_times(); else:; if _is_string(times):; if times.lower() == 'exclude':; inctimes = False; else:; logger.warn(""Unknown option for times '{}' ""; ""when saving amplitudes"".format(times)); times = self.get_amp_times(). try:; if inctimes:; shp = amps.shape; data = np.empty([shp[0], shp[1] + 1], dtype=float); data[:, 0] = times; data[:, 1:] = amps; else:; data = amps. np.savetxt(file_name, data, delimiter='\t', fmt='%14.6g'). if verbose:; logger.info(""Amplitudes saved to file: "" + file_name); except Exception as e:; logger.error(""Failed to save amplitudes due to underling ""; ""error: {}"".format(e)). [docs] def update_ctrl_amps(self, new_amps):; """"""; Determine if any amplitudes have changed. If so, then mark the; timeslots as needing recalculation; The actual work is completed by the compare_amps method of the; timeslot computer; """""". if self.log_level <= logging.DEBUG_INTENSE:; logger.log(logging.DEBUG_INTENSE, ""Updating amplitudes...\n""; ""Current control amplitudes:\n"" + str(self.ctrl_amps) +; ""\n(potenially) new amplitudes:\n"" + str(new_amps)). self.tslot_computer.compare_amps(new_amps). [docs] def flag_system_changed(self):; """"""; Flag evolution, fidelity and gradients as needing recalculation; """"""; self.evo_current = False; self.fid_computer.flag_system_changed(). [docs] def get_drift_dim(self):; """"""; Returns the size of the matrix that defines the drift dynamics; that is assuming the drift is NxN, then this returns N; """"""; if self.dyn_shape is None:; self.refresh_drift_attribs(); return self.dyn_shape[0]; ; [docs] def refresh_drift_a",MatchSource.WIKI,docs/4.2/modules/qutip/control/dynamics.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/control/dynamics.html
https://qutip.org/docs/4.2/modules/qutip/control/dynamics.html:40893,Availability,error,errors,40893,"nge(0, self.num_tslots):; self._onto_evo_qobj.append(Qobj(self._onto_evo[k],; dims=self.sys_dims)); self._onto_evo_qobj.append(self.onto_evo_target). return self._onto_evo_qobj. [docs] def compute_evolution(self):; """"""; Recalculate the time evolution operators; Dynamics generators (e.g. Hamiltonian) and; prop (propagators) are calculated as necessary; Actual work is completed by the recompute_evolution method; of the timeslot computer; """""". # Check if values are already current, otherwise calculate all values; if not self.evo_current:; if self.log_level <= logging.DEBUG_VERBOSE:; logger.log(logging.DEBUG_VERBOSE, ""Computing evolution""); self.tslot_computer.recompute_evolution(); self.evo_current = True; return True; else:; return False. def _ensure_decomp_curr(self, k):; """"""; Checks to see if the diagonalisation has been completed since; the last update of the dynamics generators; (after the amplitude update); If not then the diagonlisation is completed; """"""; if self._decomp_curr is None:; raise errors.UsageError(""Decomp lists have not been created""); if not self._decomp_curr[k]:; self._spectral_decomp(k). def _spectral_decomp(self, k):; """"""; Calculate the diagonalization of the dynamics generator; generating lists of eigenvectors, propagators in the diagonalised; basis, and the 'factormatrix' used in calculating the propagator; gradient; Not implemented in this base class, because the method is specific; to the matrix type; """"""; raise errors.UsageError(""Decomposition cannot be completed by ""; ""this class. Try a(nother) subclass""). def _is_unitary(self, A):; """"""; Checks whether operator A is unitary; A can be either Qobj or ndarray; """"""; if isinstance(A, Qobj):; unitary = np.allclose(np.eye(A.shape[0]), A*A.dag().full(),; atol=self.unitarity_tol); else:; unitary = np.allclose(np.eye(len(A)), A.dot(A.T.conj()),; atol=self.unitarity_tol). return unitary. def _calc_unitary_err(self, A):; if isinstance(A, Qobj):; err = np.sum(abs(np.eye(A.shape[0]) - A*A.dag().full()));",MatchSource.WIKI,docs/4.2/modules/qutip/control/dynamics.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/control/dynamics.html
https://qutip.org/docs/4.2/modules/qutip/control/dynamics.html:41342,Availability,error,errors,41342,"nian) and; prop (propagators) are calculated as necessary; Actual work is completed by the recompute_evolution method; of the timeslot computer; """""". # Check if values are already current, otherwise calculate all values; if not self.evo_current:; if self.log_level <= logging.DEBUG_VERBOSE:; logger.log(logging.DEBUG_VERBOSE, ""Computing evolution""); self.tslot_computer.recompute_evolution(); self.evo_current = True; return True; else:; return False. def _ensure_decomp_curr(self, k):; """"""; Checks to see if the diagonalisation has been completed since; the last update of the dynamics generators; (after the amplitude update); If not then the diagonlisation is completed; """"""; if self._decomp_curr is None:; raise errors.UsageError(""Decomp lists have not been created""); if not self._decomp_curr[k]:; self._spectral_decomp(k). def _spectral_decomp(self, k):; """"""; Calculate the diagonalization of the dynamics generator; generating lists of eigenvectors, propagators in the diagonalised; basis, and the 'factormatrix' used in calculating the propagator; gradient; Not implemented in this base class, because the method is specific; to the matrix type; """"""; raise errors.UsageError(""Decomposition cannot be completed by ""; ""this class. Try a(nother) subclass""). def _is_unitary(self, A):; """"""; Checks whether operator A is unitary; A can be either Qobj or ndarray; """"""; if isinstance(A, Qobj):; unitary = np.allclose(np.eye(A.shape[0]), A*A.dag().full(),; atol=self.unitarity_tol); else:; unitary = np.allclose(np.eye(len(A)), A.dot(A.T.conj()),; atol=self.unitarity_tol). return unitary. def _calc_unitary_err(self, A):; if isinstance(A, Qobj):; err = np.sum(abs(np.eye(A.shape[0]) - A*A.dag().full())); else:; err = np.sum(abs(np.eye(len(A)) - A.dot(A.T.conj()))). return err. [docs] def unitarity_check(self):; """"""; Checks whether all propagators are unitary; """"""; for k in range(self.num_tslots):; if not self._is_unitary(self._prop[k]):; logger.warning(; ""Progator of timeslot {} is not unitary",MatchSource.WIKI,docs/4.2/modules/qutip/control/dynamics.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/control/dynamics.html
https://qutip.org/docs/4.2/modules/qutip/control/dynamics.html:46350,Availability,down,down,46350,"rating lists of eigenvectors, propagators in the diagonalised; basis, and the 'factormatrix' used in calculating the propagator; gradient; """""". if self.oper_dtype == Qobj:; H = self._dyn_gen[k]; # Returns eigenvalues as array (row); # and eigenvectors as rows of an array; eig_val, eig_vec = sp_eigs(H.data, H.isherm, ; sparse=self.sparse_eigen_decomp); eig_vec = eig_vec.T. elif self.oper_dtype == np.ndarray:; H = self._dyn_gen[k]; # returns row vector of eigenvals, columns with the eigenvecs; eig_val, eig_vec = np.linalg.eigh(H); else:; if sparse:; H = self._dyn_gen[k].toarray(); else:; H = self._dyn_gen[k]; # returns row vector of eigenvals, columns with the eigenvecs; eig_val, eig_vec = la.eigh(H). # assuming H is an nxn matrix, find n; n = self.get_drift_dim(). # Calculate the propagator in the diagonalised basis; eig_val_tau = -1j*eig_val*self.tau[k]; prop_eig = np.exp(eig_val_tau). # Generate the factor matrix through the differences; # between each of the eigenvectors and the exponentiations; # create nxn matrix where each eigen val is repeated n times; # down the columns; o = np.ones([n, n]); eig_val_cols = eig_val_tau*o; # calculate all the differences by subtracting it from its transpose; eig_val_diffs = eig_val_cols - eig_val_cols.T; # repeat for the propagator; prop_eig_cols = prop_eig*o; prop_eig_diffs = prop_eig_cols - prop_eig_cols.T; # the factor matrix is the elementwise quotient of the; # differeneces between the exponentiated eigen vals and the; # differences between the eigen vals; # need to avoid division by zero that would arise due to denegerate; # eigenvalues and the diagonals; degen_mask = np.abs(eig_val_diffs) < self.fact_mat_round_prec; eig_val_diffs[degen_mask] = 1; factors = prop_eig_diffs / eig_val_diffs; # for degenerate eigenvalues the factor is just the exponent; factors[degen_mask] = prop_eig_cols[degen_mask]. # Store eigenvectors, propagator and factor matric; # for use in propagator computations; self._decomp_curr[k] = True; if isin",MatchSource.WIKI,docs/4.2/modules/qutip/control/dynamics.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/control/dynamics.html
https://qutip.org/docs/4.2/modules/qutip/control/dynamics.html:7326,Deployability,update,updated,7326,"ystems at least, the optimisation; performance is much better using ndarrays to represent these operators.; However. Attributes; ----------; log_level : integer; level of messaging output from the logger.; Options are attributes of qutip.logging_utils,; in decreasing levels of messaging, are:; DEBUG_INTENSE, DEBUG_VERBOSE, DEBUG, INFO, WARN, ERROR, CRITICAL; Anything WARN or above is effectively 'quiet' execution,; assuming everything runs as expected.; The default NOTSET implies that the level will be taken from; the QuTiP settings file, which by default is WARN. params: Dictionary; The key value pairs are the attribute name and value; Note: attributes are created if they do not exist already,; and are overwritten if they do. stats : Stats; Attributes of which give performance stats for the optimisation; set to None to reduce overhead of calculating stats.; Note it is (usually) shared with the Optimizer object. tslot_computer : TimeslotComputer (subclass instance); Used to manage when the timeslot dynamics; generators, propagators, gradients etc are updated. prop_computer : PropagatorComputer (subclass instance); Used to compute the propagators and their gradients. fid_computer : FidelityComputer (subclass instance); Used to computer the fidelity error and the fidelity error; gradient. memory_optimization : int; Level of memory optimisation. Setting to 0 (default) means that; execution speed is prioritized over memory.; Setting to 1 means that some memory prioritisation steps will be; taken, for instance using Qobj (and hence sparse arrays) as the; the internal operator data type, and not caching some operators; Potentially further memory saving maybe made with; memory_optimization > 1. ; The options are processed in _set_memory_optimizations, see; this for more information. Individual memory saving options can be; switched by settting them directly (see below). oper_dtype : type; Data type for internal dynamics generators, propagators and time; evolution operators",MatchSource.WIKI,docs/4.2/modules/qutip/control/dynamics.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/control/dynamics.html
https://qutip.org/docs/4.2/modules/qutip/control/dynamics.html:18549,Deployability,configurat,configuration,18549,"USTOM this is equivalent to SUMMARY. It is then up; to the user to specify which operators are dumped; WARNING: FULL could consume a lot of memory!; """"""; if self.dump is None:; lvl = 'NONE'; else:; lvl = self.dump.level. return lvl. @dumping.setter; def dumping(self, value):; if value is None:; self.dump = None; else:; if not _is_string(value):; raise TypeError(""Value must be string value""); lvl = value.upper(); if lvl == 'NONE':; self.dump = None; else:; if not isinstance(self.dump, qtrldump.DynamicsDump):; self.dump = qtrldump.DynamicsDump(self, level=lvl); else:; self.dump.level = lvl. @property; def dump_dir(self):; if self.dump:; return self.dump.dump_dir; else:; return None. @dump_dir.setter; def dump_dir(self, value):; if not self.dump:; self.dumping = 'SUMMARY'; self.dump.dump_dir = value. def _create_computers(self):; """"""; Create the default timeslot, fidelity and propagator computers; """"""; # The time slot computer. By default it is set to UpdateAll; # can be set to DynUpdate in the configuration; # (see class file for details); if self.config.tslot_type == 'DYNAMIC':; self.tslot_computer = tslotcomp.TSlotCompDynUpdate(self); else:; self.tslot_computer = tslotcomp.TSlotCompUpdateAll(self). self.prop_computer = propcomp.PropCompFrechet(self); self.fid_computer = fidcomp.FidCompTraceDiff(self). def clear(self):; self.ctrl_amps = None; self.evo_current = False; if self.fid_computer is not None:; self.fid_computer.clear(). @property; def num_tslots(self):; if not self._timeslots_initialized:; self.init_timeslots(); return self._num_tslots. @num_tslots.setter; def num_tslots(self, value):; self._num_tslots = value; if self._timeslots_initialized:; self._tau = None; self.init_timeslots(). @property; def evo_time(self):; if not self._timeslots_initialized:; self.init_timeslots(); return self._evo_time. @evo_time.setter; def evo_time(self, value):; self._evo_time = value; if self._timeslots_initialized:; self._tau = None; self.init_timeslots(). @property; def tau(s",MatchSource.WIKI,docs/4.2/modules/qutip/control/dynamics.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/control/dynamics.html
https://qutip.org/docs/4.2/modules/qutip/control/dynamics.html:27614,Deployability,configurat,configuration,27614,"p_lists(). if (self.log_level <= logging.DEBUG; and isinstance(self, DynamicsUnitary)):; self.unitarity_check_level = 1. if self.dump_to_file:; if self.dump is None:; self.dumping = 'SUMMARY'; self.dump.write_to_file = True; self.dump.create_dump_dir(); logger.info(""Dynamics dump will be written to:\n{}"".format(; self.dump.dump_dir)). def _create_decomp_lists(self):; """"""; Create lists that will hold the eigen decomposition; used in calculating propagators and gradients; Note: used with PropCompDiag propagator calcs; """"""; n_ts = self.num_tslots; self._decomp_curr = [False for x in range(n_ts)]; self._prop_eigen = [object for x in range(n_ts)]; self._dyn_gen_eigenvectors = [object for x in range(n_ts)]; if self.cache_dyn_gen_eigenvectors_adj:; self._dyn_gen_eigenvectors_adj = [object for x in range(n_ts)]; self._dyn_gen_factormatrix = [object for x in range(n_ts)]. [docs] def initialize_controls(self, amps, init_tslots=True):; """"""; Set the initial control amplitudes and time slices; Note this must be called after the configuration is complete; before any dynamics can be calculated; """"""; if not isinstance(self.prop_computer, propcomp.PropagatorComputer):; raise errors.UsageError(; ""No prop_computer (propagator computer) ""; ""set. A default should be assigned by the Dynamics subclass""). if not isinstance(self.tslot_computer, tslotcomp.TimeslotComputer):; raise errors.UsageError(; ""No tslot_computer (Timeslot computer)""; "" set. A default should be assigned by the Dynamics class""). if not isinstance(self.fid_computer, fidcomp.FidelityComputer):; raise errors.UsageError(; ""No fid_computer (Fidelity computer)""; "" set. A default should be assigned by the Dynamics subclass""). self.ctrl_amps = None; if not self._timeslots_initialized:; init_tslots = True; if init_tslots:; self.init_timeslots(); self._init_evo(); self.tslot_computer.init_comp(); self.fid_computer.init_comp(); self._ctrls_initialized = True; self.update_ctrl_amps(amps). def check_ctrls_initialized(self):; if not ",MatchSource.WIKI,docs/4.2/modules/qutip/control/dynamics.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/control/dynamics.html
https://qutip.org/docs/4.2/modules/qutip/control/dynamics.html:40741,Deployability,update,update,40741,"_onto_evo_qobj is None:; if self.oper_dtype == Qobj:; self._onto_evo_qobj = self._onto_evo; else:; self._onto_evo_qobj = []; for k in range(0, self.num_tslots):; self._onto_evo_qobj.append(Qobj(self._onto_evo[k],; dims=self.sys_dims)); self._onto_evo_qobj.append(self.onto_evo_target). return self._onto_evo_qobj. [docs] def compute_evolution(self):; """"""; Recalculate the time evolution operators; Dynamics generators (e.g. Hamiltonian) and; prop (propagators) are calculated as necessary; Actual work is completed by the recompute_evolution method; of the timeslot computer; """""". # Check if values are already current, otherwise calculate all values; if not self.evo_current:; if self.log_level <= logging.DEBUG_VERBOSE:; logger.log(logging.DEBUG_VERBOSE, ""Computing evolution""); self.tslot_computer.recompute_evolution(); self.evo_current = True; return True; else:; return False. def _ensure_decomp_curr(self, k):; """"""; Checks to see if the diagonalisation has been completed since; the last update of the dynamics generators; (after the amplitude update); If not then the diagonlisation is completed; """"""; if self._decomp_curr is None:; raise errors.UsageError(""Decomp lists have not been created""); if not self._decomp_curr[k]:; self._spectral_decomp(k). def _spectral_decomp(self, k):; """"""; Calculate the diagonalization of the dynamics generator; generating lists of eigenvectors, propagators in the diagonalised; basis, and the 'factormatrix' used in calculating the propagator; gradient; Not implemented in this base class, because the method is specific; to the matrix type; """"""; raise errors.UsageError(""Decomposition cannot be completed by ""; ""this class. Try a(nother) subclass""). def _is_unitary(self, A):; """"""; Checks whether operator A is unitary; A can be either Qobj or ndarray; """"""; if isinstance(A, Qobj):; unitary = np.allclose(np.eye(A.shape[0]), A*A.dag().full(),; atol=self.unitarity_tol); else:; unitary = np.allclose(np.eye(len(A)), A.dot(A.T.conj()),; atol=self.unitarity_t",MatchSource.WIKI,docs/4.2/modules/qutip/control/dynamics.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/control/dynamics.html
https://qutip.org/docs/4.2/modules/qutip/control/dynamics.html:40797,Deployability,update,update,40797,"_onto_evo_qobj is None:; if self.oper_dtype == Qobj:; self._onto_evo_qobj = self._onto_evo; else:; self._onto_evo_qobj = []; for k in range(0, self.num_tslots):; self._onto_evo_qobj.append(Qobj(self._onto_evo[k],; dims=self.sys_dims)); self._onto_evo_qobj.append(self.onto_evo_target). return self._onto_evo_qobj. [docs] def compute_evolution(self):; """"""; Recalculate the time evolution operators; Dynamics generators (e.g. Hamiltonian) and; prop (propagators) are calculated as necessary; Actual work is completed by the recompute_evolution method; of the timeslot computer; """""". # Check if values are already current, otherwise calculate all values; if not self.evo_current:; if self.log_level <= logging.DEBUG_VERBOSE:; logger.log(logging.DEBUG_VERBOSE, ""Computing evolution""); self.tslot_computer.recompute_evolution(); self.evo_current = True; return True; else:; return False. def _ensure_decomp_curr(self, k):; """"""; Checks to see if the diagonalisation has been completed since; the last update of the dynamics generators; (after the amplitude update); If not then the diagonlisation is completed; """"""; if self._decomp_curr is None:; raise errors.UsageError(""Decomp lists have not been created""); if not self._decomp_curr[k]:; self._spectral_decomp(k). def _spectral_decomp(self, k):; """"""; Calculate the diagonalization of the dynamics generator; generating lists of eigenvectors, propagators in the diagonalised; basis, and the 'factormatrix' used in calculating the propagator; gradient; Not implemented in this base class, because the method is specific; to the matrix type; """"""; raise errors.UsageError(""Decomposition cannot be completed by ""; ""this class. Try a(nother) subclass""). def _is_unitary(self, A):; """"""; Checks whether operator A is unitary; A can be either Qobj or ndarray; """"""; if isinstance(A, Qobj):; unitary = np.allclose(np.eye(A.shape[0]), A*A.dag().full(),; atol=self.unitarity_tol); else:; unitary = np.allclose(np.eye(len(A)), A.dot(A.T.conj()),; atol=self.unitarity_t",MatchSource.WIKI,docs/4.2/modules/qutip/control/dynamics.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/control/dynamics.html
https://qutip.org/docs/4.2/modules/qutip/control/dynamics.html:43737,Deployability,configurat,configuration,43737,"o compute the exponent; The eigen decomposition is also used to calculate the propagator gradient.; The method is taken from DYNAMO (see file header). Attributes; ----------; drift_ham : Qobj; This is the drift Hamiltonian for unitary dynamics; It is mapped to drift_dyn_gen during initialize_controls. ctrl_ham : List of Qobj; These are the control Hamiltonians for unitary dynamics; It is mapped to ctrl_dyn_gen during initialize_controls. H : List of Qobj; The combined drift and control Hamiltonians for each timeslot; These are the dynamics generators for unitary dynamics.; It is mapped to dyn_gen during initialize_controls; """""". def reset(self):; Dynamics.reset(self); self.id_text = 'UNIT'; self.drift_ham = None; self.ctrl_ham = None; self.H = None; self._dyn_gen_phase = -1j; self.apply_params(). def _create_computers(self):; """"""; Create the default timeslot, fidelity and propagator computers; """"""; # The time slot computer. By default it is set to _UpdateAll; # can be set to _DynUpdate in the configuration; # (see class file for details); if self.config.tslot_type == 'DYNAMIC':; self.tslot_computer = tslotcomp.TSlotCompDynUpdate(self); else:; self.tslot_computer = tslotcomp.TSlotCompUpdateAll(self). # set the default fidelity computer; self.fid_computer = fidcomp.FidCompUnitary(self); # set the default propagator computer; self.prop_computer = propcomp.PropCompDiag(self). def initialize_controls(self, amplitudes, init_tslots=True):; # Either the _dyn_gen or _ham names can be used; # This assumes that one or other has been set in the configuration. self._map_dyn_gen_to_ham(); Dynamics.initialize_controls(self, amplitudes, init_tslots=init_tslots); #self.H = self._dyn_gen. def _map_dyn_gen_to_ham(self):; if self.drift_dyn_gen is None:; self.drift_dyn_gen = self.drift_ham; else:; self.drift_ham = self.drift_dyn_gen. if self.ctrl_dyn_gen is None:; self.ctrl_dyn_gen = self.ctrl_ham; else:; self.ctrl_ham = self.ctrl_dyn_gen. self._dyn_gen_mapped = True. @property; def num",MatchSource.WIKI,docs/4.2/modules/qutip/control/dynamics.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/control/dynamics.html
https://qutip.org/docs/4.2/modules/qutip/control/dynamics.html:44288,Deployability,configurat,configuration,44288,"control Hamiltonians for each timeslot; These are the dynamics generators for unitary dynamics.; It is mapped to dyn_gen during initialize_controls; """""". def reset(self):; Dynamics.reset(self); self.id_text = 'UNIT'; self.drift_ham = None; self.ctrl_ham = None; self.H = None; self._dyn_gen_phase = -1j; self.apply_params(). def _create_computers(self):; """"""; Create the default timeslot, fidelity and propagator computers; """"""; # The time slot computer. By default it is set to _UpdateAll; # can be set to _DynUpdate in the configuration; # (see class file for details); if self.config.tslot_type == 'DYNAMIC':; self.tslot_computer = tslotcomp.TSlotCompDynUpdate(self); else:; self.tslot_computer = tslotcomp.TSlotCompUpdateAll(self). # set the default fidelity computer; self.fid_computer = fidcomp.FidCompUnitary(self); # set the default propagator computer; self.prop_computer = propcomp.PropCompDiag(self). def initialize_controls(self, amplitudes, init_tslots=True):; # Either the _dyn_gen or _ham names can be used; # This assumes that one or other has been set in the configuration. self._map_dyn_gen_to_ham(); Dynamics.initialize_controls(self, amplitudes, init_tslots=init_tslots); #self.H = self._dyn_gen. def _map_dyn_gen_to_ham(self):; if self.drift_dyn_gen is None:; self.drift_dyn_gen = self.drift_ham; else:; self.drift_ham = self.drift_dyn_gen. if self.ctrl_dyn_gen is None:; self.ctrl_dyn_gen = self.ctrl_ham; else:; self.ctrl_ham = self.ctrl_dyn_gen. self._dyn_gen_mapped = True. @property; def num_ctrls(self):; if not self._dyn_gen_mapped:; self._map_dyn_gen_to_ham(); if self._num_ctrls is None:; self._num_ctrls = self._get_num_ctrls(); return self._num_ctrls. def _get_onto_evo_target(self):; """"""; Get the adjoint of the target.; Used for calculating the 'backward' evolution; """"""; if self.oper_dtype == Qobj:; self._onto_evo_target = self.target.dag(); else:; self._onto_evo_target = self._target.T.conj(); return self._onto_evo_target. def _spectral_decomp(self, k):; """"""; Ca",MatchSource.WIKI,docs/4.2/modules/qutip/control/dynamics.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/control/dynamics.html
https://qutip.org/docs/4.2/modules/qutip/control/dynamics.html:50173,Deployability,configurat,configuration,50173,"; eigvecadj_unit = self._is_unitary(; self._dyn_gen_eigenvectors_adj[k]); else:; eigvecadj_unit = None; msg = (""prop unit: {}; H herm: {}; ""; ""eigval unit: {}; eigvec unit: {}; ""; ""eigvecadj_unit: {}"".format(; prop_unit, herm, eigval_unit, eigvec_unit,; eigvecadj_unit)); logger.info(msg). [docs]class DynamicsSymplectic(Dynamics):; """"""; Symplectic systems; This is the subclass to use for systems where the dynamics is described; by symplectic matrices, e.g. coupled oscillators, quantum optics. Attributes; ----------; omega : array[drift_dyn_gen.shape]; matrix used in the calculation of propagators (time evolution); with symplectic systems.; ; """""". def reset(self):; Dynamics.reset(self); self.id_text = 'SYMPL'; self._omega = None; self._omega_qobj = None; self.grad_exact = True; self.apply_params(). def _create_computers(self):; """"""; Create the default timeslot, fidelity and propagator computers; """"""; # The time slot computer. By default it is set to _UpdateAll; # can be set to _DynUpdate in the configuration; # (see class file for details); if self.config.tslot_type == 'DYNAMIC':; self.tslot_computer = tslotcomp.TSlotCompDynUpdate(self); else:; self.tslot_computer = tslotcomp.TSlotCompUpdateAll(self). self.prop_computer = propcomp.PropCompFrechet(self); self.fid_computer = fidcomp.FidCompTraceDiff(self). @property; def omega(self):; if self._omega is None:; self._get_omega(); if self._omega_qobj is None:; self._omega_qobj = Qobj(self._omega, dims=self.dyn_dims); return self._omega_qobj. def _get_omega(self):; if self._omega is None:; n = self.get_drift_dim() // 2; omg = sympl.calc_omega(n); if self.oper_dtype == Qobj:; self._omega = Qobj(omg, dims=self.dyn_dims); self._omega_qobj = self._omega; elif self.oper_dtype == sp.csr_matrix:; self._omega = sp.csr_matrix(omg); else:; self._omega = omg; return self._omega; ; @property; def dyn_gen_phase(self):; """"""; The prephasing operator for the symplectic group generators; usually refered to as \Omega; """"""; # Cannot be calcul",MatchSource.WIKI,docs/4.2/modules/qutip/control/dynamics.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/control/dynamics.html
https://qutip.org/docs/4.2/modules/qutip/control/dynamics.html:51735,Deployability,update,updated,51735,"reset(self):; Dynamics.reset(self); self.id_text = 'SYMPL'; self._omega = None; self._omega_qobj = None; self.grad_exact = True; self.apply_params(). def _create_computers(self):; """"""; Create the default timeslot, fidelity and propagator computers; """"""; # The time slot computer. By default it is set to _UpdateAll; # can be set to _DynUpdate in the configuration; # (see class file for details); if self.config.tslot_type == 'DYNAMIC':; self.tslot_computer = tslotcomp.TSlotCompDynUpdate(self); else:; self.tslot_computer = tslotcomp.TSlotCompUpdateAll(self). self.prop_computer = propcomp.PropCompFrechet(self); self.fid_computer = fidcomp.FidCompTraceDiff(self). @property; def omega(self):; if self._omega is None:; self._get_omega(); if self._omega_qobj is None:; self._omega_qobj = Qobj(self._omega, dims=self.dyn_dims); return self._omega_qobj. def _get_omega(self):; if self._omega is None:; n = self.get_drift_dim() // 2; omg = sympl.calc_omega(n); if self.oper_dtype == Qobj:; self._omega = Qobj(omg, dims=self.dyn_dims); self._omega_qobj = self._omega; elif self.oper_dtype == sp.csr_matrix:; self._omega = sp.csr_matrix(omg); else:; self._omega = omg; return self._omega; ; @property; def dyn_gen_phase(self):; """"""; The prephasing operator for the symplectic group generators; usually refered to as \Omega; """"""; # Cannot be calculated until the dyn_shape is set; # that is after the drift Hamitonan has been set.; if self._dyn_gen_phase is None:; self._dyn_gen_phase = self._get_omega(). return self._dyn_gen_phase. def _apply_phase(self, dg):; """"""; Apply some phase factor or operator; """"""; if self.dyn_gen_phase is None:; phased_dg = dg; else:; if hasattr(self.dyn_gen_phase, 'dot'):; phased_dg = -dg.dot(self.dyn_gen_phase); else:; phased_dg = -dg*self.dyn_gen_phase; return phased_dg. Â© Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, and A.L. Grimsmo.; Last updated on Jan 17, 2018. . Built with Sphinx using a theme provided by Read the Docs. . ",MatchSource.WIKI,docs/4.2/modules/qutip/control/dynamics.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/control/dynamics.html
https://qutip.org/docs/4.2/modules/qutip/control/dynamics.html:7091,Energy Efficiency,reduce,reduce,7091,"nerators; (Hamiltonians, Lindbladians etc), the propagators from one timeslot to; the next, and the evolution operators. Due to the large number of matrix; additions and multiplications, for small systems at least, the optimisation; performance is much better using ndarrays to represent these operators.; However. Attributes; ----------; log_level : integer; level of messaging output from the logger.; Options are attributes of qutip.logging_utils,; in decreasing levels of messaging, are:; DEBUG_INTENSE, DEBUG_VERBOSE, DEBUG, INFO, WARN, ERROR, CRITICAL; Anything WARN or above is effectively 'quiet' execution,; assuming everything runs as expected.; The default NOTSET implies that the level will be taken from; the QuTiP settings file, which by default is WARN. params: Dictionary; The key value pairs are the attribute name and value; Note: attributes are created if they do not exist already,; and are overwritten if they do. stats : Stats; Attributes of which give performance stats for the optimisation; set to None to reduce overhead of calculating stats.; Note it is (usually) shared with the Optimizer object. tslot_computer : TimeslotComputer (subclass instance); Used to manage when the timeslot dynamics; generators, propagators, gradients etc are updated. prop_computer : PropagatorComputer (subclass instance); Used to compute the propagators and their gradients. fid_computer : FidelityComputer (subclass instance); Used to computer the fidelity error and the fidelity error; gradient. memory_optimization : int; Level of memory optimisation. Setting to 0 (default) means that; execution speed is prioritized over memory.; Setting to 1 means that some memory prioritisation steps will be; taken, for instance using Qobj (and hence sparse arrays) as the; the internal operator data type, and not caching some operators; Potentially further memory saving maybe made with; memory_optimization > 1. ; The options are processed in _set_memory_optimizations, see; this for more informati",MatchSource.WIKI,docs/4.2/modules/qutip/control/dynamics.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/control/dynamics.html
https://qutip.org/docs/4.2/modules/qutip/control/dynamics.html:22210,Energy Efficiency,efficient,efficient,22210,")); ; if self.cache_phased_dyn_gen is None:; if self.memory_optimization > 0:; self.cache_phased_dyn_gen = False; else:; self.cache_phased_dyn_gen = True; logger.info(""phased dynamics generator caching {}"".format(; self.cache_phased_dyn_gen)); ; if self.cache_prop_grad is None:; if self.memory_optimization > 0:; self.cache_prop_grad = False; else:; self.cache_prop_grad = True ; logger.info(""propagator gradient caching {}"".format(; self.cache_prop_grad)); ; if self.cache_dyn_gen_eigenvectors_adj is None:; if self.memory_optimization > 0:; self.cache_dyn_gen_eigenvectors_adj = False; else:; self.cache_dyn_gen_eigenvectors_adj = True ; logger.info(""eigenvector adjoint caching {}"".format(; self.cache_dyn_gen_eigenvectors_adj)); ; if self.sparse_eigen_decomp is None:; if self.memory_optimization > 1:; self.sparse_eigen_decomp = True; else:; self.sparse_eigen_decomp = False ; logger.info(""use sparse eigen decomp {}"".format(; self.sparse_eigen_decomp)); ; def _choose_oper_dtype(self):; """"""; Attempt select most efficient internal operator data type; """""". if self.memory_optimization > 0:; self.oper_dtype = Qobj; else:; # Method taken from Qobj.expm(); # if method is not explicitly given, try to make a good choice; # between sparse and dense solvers by considering the size of the; # system and the number of non-zero elements.; if self.time_depend_drift:; dg = self.drift_dyn_gen[0]; else:; dg = self.drift_dyn_gen; if self.time_depend_ctrl_dyn_gen:; ctrls = self.ctrl_dyn_gen[0, :]; else:; ctrls = self.ctrl_dyn_gen; for c in ctrls:; dg = dg + c. N = dg.data.shape[0]; n = dg.data.nnz. if N ** 2 < 100 * n:; # large number of nonzero elements, revert to dense solver; self.oper_dtype = np.ndarray; elif N > 400:; # large system, and quite sparse -> qutips sparse method; self.oper_dtype = Qobj; else:; # small system, but quite sparse -> qutips sparse/dense method; self.oper_dtype = np.ndarray. return self.oper_dtype. def _init_evo(self):; """"""; Create the container lists / arrays for t",MatchSource.WIKI,docs/4.2/modules/qutip/control/dynamics.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/control/dynamics.html
https://qutip.org/docs/4.2/modules/qutip/control/dynamics.html:2675,Integrability,depend,depends,2675,"ICES; LOSS OF USE,; # DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY; # THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT; # (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE; # OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.; ###############################################################################. # @author: Alexander Pitchford; # @email1: agp1@aber.ac.uk; # @email2: alex.pitchford@gmail.com; # @organization: Aberystwyth University; # @supervisor: Daniel Burgarth. """"""; Classes that define the dynamics of the (quantum) system and target evolution; to be optimised.; The contols are also defined here, i.e. the dynamics generators (Hamiltonians,; Limbladians etc). The dynamics for the time slices are calculated here, along; with the evolution as determined by the control amplitudes. See the subclass descriptions and choose the appropriate class for the; application. The choice depends on the type of matrix used to define; the dynamics. These class implement functions for getting the dynamics generators for; the combined (drift + ctrls) dynamics with the approriate operator applied. Note the methods in these classes were inspired by:; DYNAMO - Dynamic Framework for Quantum Optimal Control; See Machnes et.al., arXiv.1011.4874; """"""; import os; import warnings; import numpy as np; import scipy.linalg as la; import scipy.sparse as sp; # QuTiP; from qutip import Qobj; from qutip.sparse import sp_eigs, _dense_eigs; import qutip.settings as settings; # QuTiP logging; import qutip.logging_utils as logging; logger = logging.get_logger(); # QuTiP control modules; import qutip.control.errors as errors; import qutip.control.tslotcomp as tslotcomp; import qutip.control.fidcomp as fidcomp; import qutip.control.propcomp as propcomp; import qutip.control.symplectic as sympl; import qutip.control.dump as qtrldump. DEF_NUM_TSLOTS = 10; DEF_EVO_TIME = 1.0. def _is_string(var):; try:; if isinstance(var",MatchSource.WIKI,docs/4.2/modules/qutip/control/dynamics.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/control/dynamics.html
https://qutip.org/docs/4.2/modules/qutip/control/dynamics.html:5122,Integrability,message,message,5122,"ls[0], (list, tuple)):; ctrls = np.array(ctrls); except:; pass; ; if isinstance(ctrls, np.ndarray):; if len(ctrls.shape) != 2:; raise TypeError(""Incorrect shape for ctrl dyn gen array""); for k in range(ctrls.shape[0]):; for j in range(ctrls.shape[1]):; if not isinstance(ctrls[k, j], Qobj):; raise TypeError(""All control dyn gen must be Qobj""); elif isinstance(ctrls, (list, tuple)):; for ctrl in ctrls:; if not isinstance(ctrl, Qobj):; raise TypeError(""All control dyn gen must be Qobj"") ; else:; raise TypeError(""Controls list or array not set correctly""); ; return ctrls; ; def _check_drift_dyn_gen(drift):; if not isinstance(drift, Qobj):; if not isinstance(drift, (list, tuple)):; raise TypeError(""drift should be a Qobj or a list of Qobj""); else:; for d in drift:; if not isinstance(d, Qobj):; raise TypeError(; ""drift should be a Qobj or a list of Qobj""). warnings.simplefilter('always', DeprecationWarning) #turn off filter; def _attrib_deprecation(message, stacklevel=3):; """"""; Issue deprecation warning; Using stacklevel=3 will ensure message refers the function; calling with the deprecated parameter,; """"""; warnings.warn(message, DeprecationWarning, stacklevel=stacklevel). def _func_deprecation(message, stacklevel=3):; """"""; Issue deprecation warning; Using stacklevel=3 will ensure message refers the function; calling with the deprecated parameter,; """"""; warnings.warn(message, DeprecationWarning, stacklevel=stacklevel). [docs]class Dynamics(object):; """"""; This is a base class only. See subclass descriptions and choose an; appropriate one for the application. Note that initialize_controls must be called before most of the methods; can be used. init_timeslots can be called sometimes earlier in order; to access timeslot related attributes. This acts as a container for the operators that are used to calculate; time evolution of the system under study. That is the dynamics generators; (Hamiltonians, Lindbladians etc), the propagators from one timeslot to; the next, and the evol",MatchSource.WIKI,docs/4.2/modules/qutip/control/dynamics.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/control/dynamics.html
https://qutip.org/docs/4.2/modules/qutip/control/dynamics.html:5210,Integrability,message,message,5210,"ls[0], (list, tuple)):; ctrls = np.array(ctrls); except:; pass; ; if isinstance(ctrls, np.ndarray):; if len(ctrls.shape) != 2:; raise TypeError(""Incorrect shape for ctrl dyn gen array""); for k in range(ctrls.shape[0]):; for j in range(ctrls.shape[1]):; if not isinstance(ctrls[k, j], Qobj):; raise TypeError(""All control dyn gen must be Qobj""); elif isinstance(ctrls, (list, tuple)):; for ctrl in ctrls:; if not isinstance(ctrl, Qobj):; raise TypeError(""All control dyn gen must be Qobj"") ; else:; raise TypeError(""Controls list or array not set correctly""); ; return ctrls; ; def _check_drift_dyn_gen(drift):; if not isinstance(drift, Qobj):; if not isinstance(drift, (list, tuple)):; raise TypeError(""drift should be a Qobj or a list of Qobj""); else:; for d in drift:; if not isinstance(d, Qobj):; raise TypeError(; ""drift should be a Qobj or a list of Qobj""). warnings.simplefilter('always', DeprecationWarning) #turn off filter; def _attrib_deprecation(message, stacklevel=3):; """"""; Issue deprecation warning; Using stacklevel=3 will ensure message refers the function; calling with the deprecated parameter,; """"""; warnings.warn(message, DeprecationWarning, stacklevel=stacklevel). def _func_deprecation(message, stacklevel=3):; """"""; Issue deprecation warning; Using stacklevel=3 will ensure message refers the function; calling with the deprecated parameter,; """"""; warnings.warn(message, DeprecationWarning, stacklevel=stacklevel). [docs]class Dynamics(object):; """"""; This is a base class only. See subclass descriptions and choose an; appropriate one for the application. Note that initialize_controls must be called before most of the methods; can be used. init_timeslots can be called sometimes earlier in order; to access timeslot related attributes. This acts as a container for the operators that are used to calculate; time evolution of the system under study. That is the dynamics generators; (Hamiltonians, Lindbladians etc), the propagators from one timeslot to; the next, and the evol",MatchSource.WIKI,docs/4.2/modules/qutip/control/dynamics.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/control/dynamics.html
https://qutip.org/docs/4.2/modules/qutip/control/dynamics.html:5298,Integrability,message,message,5298,"hape for ctrl dyn gen array""); for k in range(ctrls.shape[0]):; for j in range(ctrls.shape[1]):; if not isinstance(ctrls[k, j], Qobj):; raise TypeError(""All control dyn gen must be Qobj""); elif isinstance(ctrls, (list, tuple)):; for ctrl in ctrls:; if not isinstance(ctrl, Qobj):; raise TypeError(""All control dyn gen must be Qobj"") ; else:; raise TypeError(""Controls list or array not set correctly""); ; return ctrls; ; def _check_drift_dyn_gen(drift):; if not isinstance(drift, Qobj):; if not isinstance(drift, (list, tuple)):; raise TypeError(""drift should be a Qobj or a list of Qobj""); else:; for d in drift:; if not isinstance(d, Qobj):; raise TypeError(; ""drift should be a Qobj or a list of Qobj""). warnings.simplefilter('always', DeprecationWarning) #turn off filter; def _attrib_deprecation(message, stacklevel=3):; """"""; Issue deprecation warning; Using stacklevel=3 will ensure message refers the function; calling with the deprecated parameter,; """"""; warnings.warn(message, DeprecationWarning, stacklevel=stacklevel). def _func_deprecation(message, stacklevel=3):; """"""; Issue deprecation warning; Using stacklevel=3 will ensure message refers the function; calling with the deprecated parameter,; """"""; warnings.warn(message, DeprecationWarning, stacklevel=stacklevel). [docs]class Dynamics(object):; """"""; This is a base class only. See subclass descriptions and choose an; appropriate one for the application. Note that initialize_controls must be called before most of the methods; can be used. init_timeslots can be called sometimes earlier in order; to access timeslot related attributes. This acts as a container for the operators that are used to calculate; time evolution of the system under study. That is the dynamics generators; (Hamiltonians, Lindbladians etc), the propagators from one timeslot to; the next, and the evolution operators. Due to the large number of matrix; additions and multiplications, for small systems at least, the optimisation; performance is much better u",MatchSource.WIKI,docs/4.2/modules/qutip/control/dynamics.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/control/dynamics.html
https://qutip.org/docs/4.2/modules/qutip/control/dynamics.html:5373,Integrability,message,message,5373,", Qobj):; raise TypeError(""All control dyn gen must be Qobj""); elif isinstance(ctrls, (list, tuple)):; for ctrl in ctrls:; if not isinstance(ctrl, Qobj):; raise TypeError(""All control dyn gen must be Qobj"") ; else:; raise TypeError(""Controls list or array not set correctly""); ; return ctrls; ; def _check_drift_dyn_gen(drift):; if not isinstance(drift, Qobj):; if not isinstance(drift, (list, tuple)):; raise TypeError(""drift should be a Qobj or a list of Qobj""); else:; for d in drift:; if not isinstance(d, Qobj):; raise TypeError(; ""drift should be a Qobj or a list of Qobj""). warnings.simplefilter('always', DeprecationWarning) #turn off filter; def _attrib_deprecation(message, stacklevel=3):; """"""; Issue deprecation warning; Using stacklevel=3 will ensure message refers the function; calling with the deprecated parameter,; """"""; warnings.warn(message, DeprecationWarning, stacklevel=stacklevel). def _func_deprecation(message, stacklevel=3):; """"""; Issue deprecation warning; Using stacklevel=3 will ensure message refers the function; calling with the deprecated parameter,; """"""; warnings.warn(message, DeprecationWarning, stacklevel=stacklevel). [docs]class Dynamics(object):; """"""; This is a base class only. See subclass descriptions and choose an; appropriate one for the application. Note that initialize_controls must be called before most of the methods; can be used. init_timeslots can be called sometimes earlier in order; to access timeslot related attributes. This acts as a container for the operators that are used to calculate; time evolution of the system under study. That is the dynamics generators; (Hamiltonians, Lindbladians etc), the propagators from one timeslot to; the next, and the evolution operators. Due to the large number of matrix; additions and multiplications, for small systems at least, the optimisation; performance is much better using ndarrays to represent these operators.; However. Attributes; ----------; log_level : integer; level of messaging output ",MatchSource.WIKI,docs/4.2/modules/qutip/control/dynamics.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/control/dynamics.html
https://qutip.org/docs/4.2/modules/qutip/control/dynamics.html:5461,Integrability,message,message,5461,", Qobj):; raise TypeError(""All control dyn gen must be Qobj""); elif isinstance(ctrls, (list, tuple)):; for ctrl in ctrls:; if not isinstance(ctrl, Qobj):; raise TypeError(""All control dyn gen must be Qobj"") ; else:; raise TypeError(""Controls list or array not set correctly""); ; return ctrls; ; def _check_drift_dyn_gen(drift):; if not isinstance(drift, Qobj):; if not isinstance(drift, (list, tuple)):; raise TypeError(""drift should be a Qobj or a list of Qobj""); else:; for d in drift:; if not isinstance(d, Qobj):; raise TypeError(; ""drift should be a Qobj or a list of Qobj""). warnings.simplefilter('always', DeprecationWarning) #turn off filter; def _attrib_deprecation(message, stacklevel=3):; """"""; Issue deprecation warning; Using stacklevel=3 will ensure message refers the function; calling with the deprecated parameter,; """"""; warnings.warn(message, DeprecationWarning, stacklevel=stacklevel). def _func_deprecation(message, stacklevel=3):; """"""; Issue deprecation warning; Using stacklevel=3 will ensure message refers the function; calling with the deprecated parameter,; """"""; warnings.warn(message, DeprecationWarning, stacklevel=stacklevel). [docs]class Dynamics(object):; """"""; This is a base class only. See subclass descriptions and choose an; appropriate one for the application. Note that initialize_controls must be called before most of the methods; can be used. init_timeslots can be called sometimes earlier in order; to access timeslot related attributes. This acts as a container for the operators that are used to calculate; time evolution of the system under study. That is the dynamics generators; (Hamiltonians, Lindbladians etc), the propagators from one timeslot to; the next, and the evolution operators. Due to the large number of matrix; additions and multiplications, for small systems at least, the optimisation; performance is much better using ndarrays to represent these operators.; However. Attributes; ----------; log_level : integer; level of messaging output ",MatchSource.WIKI,docs/4.2/modules/qutip/control/dynamics.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/control/dynamics.html
https://qutip.org/docs/4.2/modules/qutip/control/dynamics.html:5549,Integrability,message,message,5549," not isinstance(ctrl, Qobj):; raise TypeError(""All control dyn gen must be Qobj"") ; else:; raise TypeError(""Controls list or array not set correctly""); ; return ctrls; ; def _check_drift_dyn_gen(drift):; if not isinstance(drift, Qobj):; if not isinstance(drift, (list, tuple)):; raise TypeError(""drift should be a Qobj or a list of Qobj""); else:; for d in drift:; if not isinstance(d, Qobj):; raise TypeError(; ""drift should be a Qobj or a list of Qobj""). warnings.simplefilter('always', DeprecationWarning) #turn off filter; def _attrib_deprecation(message, stacklevel=3):; """"""; Issue deprecation warning; Using stacklevel=3 will ensure message refers the function; calling with the deprecated parameter,; """"""; warnings.warn(message, DeprecationWarning, stacklevel=stacklevel). def _func_deprecation(message, stacklevel=3):; """"""; Issue deprecation warning; Using stacklevel=3 will ensure message refers the function; calling with the deprecated parameter,; """"""; warnings.warn(message, DeprecationWarning, stacklevel=stacklevel). [docs]class Dynamics(object):; """"""; This is a base class only. See subclass descriptions and choose an; appropriate one for the application. Note that initialize_controls must be called before most of the methods; can be used. init_timeslots can be called sometimes earlier in order; to access timeslot related attributes. This acts as a container for the operators that are used to calculate; time evolution of the system under study. That is the dynamics generators; (Hamiltonians, Lindbladians etc), the propagators from one timeslot to; the next, and the evolution operators. Due to the large number of matrix; additions and multiplications, for small systems at least, the optimisation; performance is much better using ndarrays to represent these operators.; However. Attributes; ----------; log_level : integer; level of messaging output from the logger.; Options are attributes of qutip.logging_utils,; in decreasing levels of messaging, are:; DEBUG_INTENSE, DEBU",MatchSource.WIKI,docs/4.2/modules/qutip/control/dynamics.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/control/dynamics.html
https://qutip.org/docs/4.2/modules/qutip/control/dynamics.html:14858,Integrability,depend,depending,14858,"; """"""; def __init__(self, optimconfig, params=None):; self.config = optimconfig; self.params = params; self.reset(). def reset(self):; # Link to optimiser object if self is linked to one; self.parent = None; # Main functional attributes; self.time = None; self.initial = None; self.target = None; self.ctrl_amps = None; self.initial_ctrl_scaling = 1.0; self.initial_ctrl_offset = 0.0; self.drift_dyn_gen = None; self.ctrl_dyn_gen = None; self._tau = None; self._evo_time = None; self._num_ctrls = None; self._num_tslots = None; # attributes used for processing evolution; self.memory_optimization = 0; self.oper_dtype = None; self.cache_phased_dyn_gen = None; self.cache_prop_grad = None; self.cache_dyn_gen_eigenvectors_adj = None; self.sparse_eigen_decomp = None; self.dyn_dims = None; self.dyn_shape = None; self.sys_dims = None; self.sys_shape = None; self.time_depend_drift = False; self.time_depend_ctrl_dyn_gen = False; # These internal attributes will be of the internal operator data type; # used to compute the evolution; # Note this maybe ndarray, Qobj or some other depending on oper_dtype; self._drift_dyn_gen = None; self._ctrl_dyn_gen = None; self._phased_ctrl_dyn_gen = None; self._dyn_gen_phase = None; self._initial = None; self._target = None; self._onto_evo_target = None; self._dyn_gen = None; self._phased_dyn_gen = None; self._prop = None; self._prop_grad = None; self._fwd_evo = None; self._onwd_evo = None; self._onto_evo = None; # The _qobj attribs are Qobj representations of the equivalent; # internal attribute. They are only set when the extenal accessors; # are used; self._onto_evo_target_qobj = None; self._dyn_gen_qobj = None; self._prop_qobj = None; self._prop_grad_qobj = None; self._fwd_evo_qobj = None; self._onwd_evo_qobj = None; self._onto_evo_qobj = None; # Atrributes used in diagonalisation; # again in internal operator data type (see above); self._decomp_curr = None; self._prop_eigen = None; self._dyn_gen_eigenvectors = None; self._dyn_gen_eigenvectors_a",MatchSource.WIKI,docs/4.2/modules/qutip/control/dynamics.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/control/dynamics.html
https://qutip.org/docs/4.2/modules/qutip/control/dynamics.html:29535,Integrability,message,message,29535,"s(amps). def check_ctrls_initialized(self):; if not self._ctrls_initialized:; raise errors.UsageError(; ""Controls not initialised. ""; ""Ensure Dynamics.initialize_controls has been ""; ""executed with the initial control amplitudes.""). def get_amp_times(self):; return self.time[:self.num_tslots]. [docs] def save_amps(self, file_name=None, times=None, amps=None, verbose=False):; """"""; Save a file with the current control amplitudes in each timeslot; The first column in the file will be the start time of the slot. Parameters; ----------; file_name : string; Name of the file; If None given the def_amps_fname attribuite will be used. times : List type (or string); List / array of the start times for each slot; If None given this will be retrieved through get_amp_times(); If 'exclude' then times will not be saved in the file, just; the amplitudes. amps : Array[num_tslots, num_ctrls]; Amplitudes to be saved; If None given the ctrl_amps attribute will be used. verbose : Boolean; If True then an info message will be logged; """"""; self.check_ctrls_initialized(). inctimes = True; if file_name is None:; file_name = self.def_amps_fname; if amps is None:; amps = self.ctrl_amps; if times is None:; times = self.get_amp_times(); else:; if _is_string(times):; if times.lower() == 'exclude':; inctimes = False; else:; logger.warn(""Unknown option for times '{}' ""; ""when saving amplitudes"".format(times)); times = self.get_amp_times(). try:; if inctimes:; shp = amps.shape; data = np.empty([shp[0], shp[1] + 1], dtype=float); data[:, 0] = times; data[:, 1:] = amps; else:; data = amps. np.savetxt(file_name, data, delimiter='\t', fmt='%14.6g'). if verbose:; logger.info(""Amplitudes saved to file: "" + file_name); except Exception as e:; logger.error(""Failed to save amplitudes due to underling ""; ""error: {}"".format(e)). [docs] def update_ctrl_amps(self, new_amps):; """"""; Determine if any amplitudes have changed. If so, then mark the; timeslots as needing recalculation; The actual work is completed by t",MatchSource.WIKI,docs/4.2/modules/qutip/control/dynamics.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/control/dynamics.html
https://qutip.org/docs/4.2/modules/qutip/control/dynamics.html:13839,Modifiability,config,config,13839,"ty of the system evolution is checked at at; evolution recomputation.; level 1 checks all propagators; level 2 checks eigen basis as well; Default is 0. unitarity_tol :; Tolerance used in checking if operator is unitary; Default is 1e-10. dump : :class:`dump.DynamicsDump`; Store of historical calculation data.; Set to None (Default) for no storing of historical data; Use dumping property to set level of data dumping. dumping : string; level of data dumping: NONE, SUMMARY, FULL or CUSTOM; See property docstring for details. dump_to_file : bool; If set True then data will be dumped to file during the calculations; dumping will be set to SUMMARY during init_evo if dump_to_file is True; and dumping not set.; Default is False. dump_dir : string; Basically a link to dump.dump_dir. Exists so that it can be set through; dyn_params.; If dump is None then will return None or will set dumping to SUMMARY; when setting a path; ; """"""; def __init__(self, optimconfig, params=None):; self.config = optimconfig; self.params = params; self.reset(). def reset(self):; # Link to optimiser object if self is linked to one; self.parent = None; # Main functional attributes; self.time = None; self.initial = None; self.target = None; self.ctrl_amps = None; self.initial_ctrl_scaling = 1.0; self.initial_ctrl_offset = 0.0; self.drift_dyn_gen = None; self.ctrl_dyn_gen = None; self._tau = None; self._evo_time = None; self._num_ctrls = None; self._num_tslots = None; # attributes used for processing evolution; self.memory_optimization = 0; self.oper_dtype = None; self.cache_phased_dyn_gen = None; self.cache_prop_grad = None; self.cache_dyn_gen_eigenvectors_adj = None; self.sparse_eigen_decomp = None; self.dyn_dims = None; self.dyn_shape = None; self.sys_dims = None; self.sys_shape = None; self.time_depend_drift = False; self.time_depend_ctrl_dyn_gen = False; # These internal attributes will be of the internal operator data type; # used to compute the evolution; # Note this maybe ndarray, Qobj or some o",MatchSource.WIKI,docs/4.2/modules/qutip/control/dynamics.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/control/dynamics.html
https://qutip.org/docs/4.2/modules/qutip/control/dynamics.html:16001,Modifiability,config,config,16001,"._initial = None; self._target = None; self._onto_evo_target = None; self._dyn_gen = None; self._phased_dyn_gen = None; self._prop = None; self._prop_grad = None; self._fwd_evo = None; self._onwd_evo = None; self._onto_evo = None; # The _qobj attribs are Qobj representations of the equivalent; # internal attribute. They are only set when the extenal accessors; # are used; self._onto_evo_target_qobj = None; self._dyn_gen_qobj = None; self._prop_qobj = None; self._prop_grad_qobj = None; self._fwd_evo_qobj = None; self._onwd_evo_qobj = None; self._onto_evo_qobj = None; # Atrributes used in diagonalisation; # again in internal operator data type (see above); self._decomp_curr = None; self._prop_eigen = None; self._dyn_gen_eigenvectors = None; self._dyn_gen_eigenvectors_adj = None; self._dyn_gen_factormatrix = None; self.fact_mat_round_prec = 1e-10. # Debug and information attribs; self.stats = None; self.id_text = 'DYN_BASE'; self.def_amps_fname = ""ctrl_amps.txt""; self.log_level = self.config.log_level; # Internal flags; self._dyn_gen_mapped = False; self._timeslots_initialized = False; self._ctrls_initialized = False; self._ctrl_dyn_gen_checked = False; self._drift_dyn_gen_checked = False; # Unitary checking; self.unitarity_check_level = 0; self.unitarity_tol = 1e-10; # Data dumping; self.dump = None; self.dump_to_file = False. self.apply_params(). # Create the computing objects; self._create_computers(). self.clear(). [docs] def apply_params(self, params=None):; """"""; Set object attributes based on the dictionary (if any) passed in the; instantiation, or passed as a parameter; This is called during the instantiation automatically.; The key value pairs are the attribute name and value; Note: attributes are created if they do not exist already,; and are overwritten if they do.; """"""; if not params:; params = self.params. if isinstance(params, dict):; self.params = params; for key in params:; setattr(self, key, params[key]). @property; def log_level(self):; return logger.le",MatchSource.WIKI,docs/4.2/modules/qutip/control/dynamics.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/control/dynamics.html
https://qutip.org/docs/4.2/modules/qutip/control/dynamics.html:18549,Modifiability,config,configuration,18549,"USTOM this is equivalent to SUMMARY. It is then up; to the user to specify which operators are dumped; WARNING: FULL could consume a lot of memory!; """"""; if self.dump is None:; lvl = 'NONE'; else:; lvl = self.dump.level. return lvl. @dumping.setter; def dumping(self, value):; if value is None:; self.dump = None; else:; if not _is_string(value):; raise TypeError(""Value must be string value""); lvl = value.upper(); if lvl == 'NONE':; self.dump = None; else:; if not isinstance(self.dump, qtrldump.DynamicsDump):; self.dump = qtrldump.DynamicsDump(self, level=lvl); else:; self.dump.level = lvl. @property; def dump_dir(self):; if self.dump:; return self.dump.dump_dir; else:; return None. @dump_dir.setter; def dump_dir(self, value):; if not self.dump:; self.dumping = 'SUMMARY'; self.dump.dump_dir = value. def _create_computers(self):; """"""; Create the default timeslot, fidelity and propagator computers; """"""; # The time slot computer. By default it is set to UpdateAll; # can be set to DynUpdate in the configuration; # (see class file for details); if self.config.tslot_type == 'DYNAMIC':; self.tslot_computer = tslotcomp.TSlotCompDynUpdate(self); else:; self.tslot_computer = tslotcomp.TSlotCompUpdateAll(self). self.prop_computer = propcomp.PropCompFrechet(self); self.fid_computer = fidcomp.FidCompTraceDiff(self). def clear(self):; self.ctrl_amps = None; self.evo_current = False; if self.fid_computer is not None:; self.fid_computer.clear(). @property; def num_tslots(self):; if not self._timeslots_initialized:; self.init_timeslots(); return self._num_tslots. @num_tslots.setter; def num_tslots(self, value):; self._num_tslots = value; if self._timeslots_initialized:; self._tau = None; self.init_timeslots(). @property; def evo_time(self):; if not self._timeslots_initialized:; self.init_timeslots(); return self._evo_time. @evo_time.setter; def evo_time(self, value):; self._evo_time = value; if self._timeslots_initialized:; self._tau = None; self.init_timeslots(). @property; def tau(s",MatchSource.WIKI,docs/4.2/modules/qutip/control/dynamics.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/control/dynamics.html
https://qutip.org/docs/4.2/modules/qutip/control/dynamics.html:18604,Modifiability,config,config,18604,"o specify which operators are dumped; WARNING: FULL could consume a lot of memory!; """"""; if self.dump is None:; lvl = 'NONE'; else:; lvl = self.dump.level. return lvl. @dumping.setter; def dumping(self, value):; if value is None:; self.dump = None; else:; if not _is_string(value):; raise TypeError(""Value must be string value""); lvl = value.upper(); if lvl == 'NONE':; self.dump = None; else:; if not isinstance(self.dump, qtrldump.DynamicsDump):; self.dump = qtrldump.DynamicsDump(self, level=lvl); else:; self.dump.level = lvl. @property; def dump_dir(self):; if self.dump:; return self.dump.dump_dir; else:; return None. @dump_dir.setter; def dump_dir(self, value):; if not self.dump:; self.dumping = 'SUMMARY'; self.dump.dump_dir = value. def _create_computers(self):; """"""; Create the default timeslot, fidelity and propagator computers; """"""; # The time slot computer. By default it is set to UpdateAll; # can be set to DynUpdate in the configuration; # (see class file for details); if self.config.tslot_type == 'DYNAMIC':; self.tslot_computer = tslotcomp.TSlotCompDynUpdate(self); else:; self.tslot_computer = tslotcomp.TSlotCompUpdateAll(self). self.prop_computer = propcomp.PropCompFrechet(self); self.fid_computer = fidcomp.FidCompTraceDiff(self). def clear(self):; self.ctrl_amps = None; self.evo_current = False; if self.fid_computer is not None:; self.fid_computer.clear(). @property; def num_tslots(self):; if not self._timeslots_initialized:; self.init_timeslots(); return self._num_tslots. @num_tslots.setter; def num_tslots(self, value):; self._num_tslots = value; if self._timeslots_initialized:; self._tau = None; self.init_timeslots(). @property; def evo_time(self):; if not self._timeslots_initialized:; self.init_timeslots(); return self._evo_time. @evo_time.setter; def evo_time(self, value):; self._evo_time = value; if self._timeslots_initialized:; self._tau = None; self.init_timeslots(). @property; def tau(self):; if not self._timeslots_initialized:; self.init_timeslots();",MatchSource.WIKI,docs/4.2/modules/qutip/control/dynamics.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/control/dynamics.html
https://qutip.org/docs/4.2/modules/qutip/control/dynamics.html:20100,Modifiability,config,config,20100,".evo_current = False; if self.fid_computer is not None:; self.fid_computer.clear(). @property; def num_tslots(self):; if not self._timeslots_initialized:; self.init_timeslots(); return self._num_tslots. @num_tslots.setter; def num_tslots(self, value):; self._num_tslots = value; if self._timeslots_initialized:; self._tau = None; self.init_timeslots(). @property; def evo_time(self):; if not self._timeslots_initialized:; self.init_timeslots(); return self._evo_time. @evo_time.setter; def evo_time(self, value):; self._evo_time = value; if self._timeslots_initialized:; self._tau = None; self.init_timeslots(). @property; def tau(self):; if not self._timeslots_initialized:; self.init_timeslots(); return self._tau. @tau.setter; def tau(self, value):; self._tau = value; self.init_timeslots(). [docs] def init_timeslots(self):; """"""; Generate the timeslot duration array 'tau' based on the evo_time; and num_tslots attributes, unless the tau attribute is already set; in which case this step in ignored; Generate the cumulative time array 'time' based on the tau values; """"""; # set the time intervals to be equal timeslices of the total if; # the have not been set already (as part of user config); if self._num_tslots is None:; self._num_tslots = DEF_NUM_TSLOTS; if self._evo_time is None:; self._evo_time = DEF_EVO_TIME. if self._tau is None:; self._tau = np.ones(self._num_tslots, dtype='f') * \; self._evo_time/self._num_tslots; else:; self._num_tslots = len(self._tau); self._evo_time = np.sum(self._tau). self.time = np.zeros(self._num_tslots+1, dtype=float); # set the cumulative time by summing the time intervals; for t in range(self._num_tslots):; self.time[t+1] = self.time[t] + self._tau[t]. self._timeslots_initialized = True; ; def _set_memory_optimizations(self):; """"""; Set various memory optimisation attributes based on the ; memory_optimization attribute; If they have been set already, e.g. in apply_params; then they will not be overidden here; """"""; logger.info(""Setting memory opt",MatchSource.WIKI,docs/4.2/modules/qutip/control/dynamics.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/control/dynamics.html
https://qutip.org/docs/4.2/modules/qutip/control/dynamics.html:27614,Modifiability,config,configuration,27614,"p_lists(). if (self.log_level <= logging.DEBUG; and isinstance(self, DynamicsUnitary)):; self.unitarity_check_level = 1. if self.dump_to_file:; if self.dump is None:; self.dumping = 'SUMMARY'; self.dump.write_to_file = True; self.dump.create_dump_dir(); logger.info(""Dynamics dump will be written to:\n{}"".format(; self.dump.dump_dir)). def _create_decomp_lists(self):; """"""; Create lists that will hold the eigen decomposition; used in calculating propagators and gradients; Note: used with PropCompDiag propagator calcs; """"""; n_ts = self.num_tslots; self._decomp_curr = [False for x in range(n_ts)]; self._prop_eigen = [object for x in range(n_ts)]; self._dyn_gen_eigenvectors = [object for x in range(n_ts)]; if self.cache_dyn_gen_eigenvectors_adj:; self._dyn_gen_eigenvectors_adj = [object for x in range(n_ts)]; self._dyn_gen_factormatrix = [object for x in range(n_ts)]. [docs] def initialize_controls(self, amps, init_tslots=True):; """"""; Set the initial control amplitudes and time slices; Note this must be called after the configuration is complete; before any dynamics can be calculated; """"""; if not isinstance(self.prop_computer, propcomp.PropagatorComputer):; raise errors.UsageError(; ""No prop_computer (propagator computer) ""; ""set. A default should be assigned by the Dynamics subclass""). if not isinstance(self.tslot_computer, tslotcomp.TimeslotComputer):; raise errors.UsageError(; ""No tslot_computer (Timeslot computer)""; "" set. A default should be assigned by the Dynamics class""). if not isinstance(self.fid_computer, fidcomp.FidelityComputer):; raise errors.UsageError(; ""No fid_computer (Fidelity computer)""; "" set. A default should be assigned by the Dynamics subclass""). self.ctrl_amps = None; if not self._timeslots_initialized:; init_tslots = True; if init_tslots:; self.init_timeslots(); self._init_evo(); self.tslot_computer.init_comp(); self.fid_computer.init_comp(); self._ctrls_initialized = True; self.update_ctrl_amps(amps). def check_ctrls_initialized(self):; if not ",MatchSource.WIKI,docs/4.2/modules/qutip/control/dynamics.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/control/dynamics.html
https://qutip.org/docs/4.2/modules/qutip/control/dynamics.html:43737,Modifiability,config,configuration,43737,"o compute the exponent; The eigen decomposition is also used to calculate the propagator gradient.; The method is taken from DYNAMO (see file header). Attributes; ----------; drift_ham : Qobj; This is the drift Hamiltonian for unitary dynamics; It is mapped to drift_dyn_gen during initialize_controls. ctrl_ham : List of Qobj; These are the control Hamiltonians for unitary dynamics; It is mapped to ctrl_dyn_gen during initialize_controls. H : List of Qobj; The combined drift and control Hamiltonians for each timeslot; These are the dynamics generators for unitary dynamics.; It is mapped to dyn_gen during initialize_controls; """""". def reset(self):; Dynamics.reset(self); self.id_text = 'UNIT'; self.drift_ham = None; self.ctrl_ham = None; self.H = None; self._dyn_gen_phase = -1j; self.apply_params(). def _create_computers(self):; """"""; Create the default timeslot, fidelity and propagator computers; """"""; # The time slot computer. By default it is set to _UpdateAll; # can be set to _DynUpdate in the configuration; # (see class file for details); if self.config.tslot_type == 'DYNAMIC':; self.tslot_computer = tslotcomp.TSlotCompDynUpdate(self); else:; self.tslot_computer = tslotcomp.TSlotCompUpdateAll(self). # set the default fidelity computer; self.fid_computer = fidcomp.FidCompUnitary(self); # set the default propagator computer; self.prop_computer = propcomp.PropCompDiag(self). def initialize_controls(self, amplitudes, init_tslots=True):; # Either the _dyn_gen or _ham names can be used; # This assumes that one or other has been set in the configuration. self._map_dyn_gen_to_ham(); Dynamics.initialize_controls(self, amplitudes, init_tslots=init_tslots); #self.H = self._dyn_gen. def _map_dyn_gen_to_ham(self):; if self.drift_dyn_gen is None:; self.drift_dyn_gen = self.drift_ham; else:; self.drift_ham = self.drift_dyn_gen. if self.ctrl_dyn_gen is None:; self.ctrl_dyn_gen = self.ctrl_ham; else:; self.ctrl_ham = self.ctrl_dyn_gen. self._dyn_gen_mapped = True. @property; def num",MatchSource.WIKI,docs/4.2/modules/qutip/control/dynamics.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/control/dynamics.html
https://qutip.org/docs/4.2/modules/qutip/control/dynamics.html:43792,Modifiability,config,config,43792,"lculate the propagator gradient.; The method is taken from DYNAMO (see file header). Attributes; ----------; drift_ham : Qobj; This is the drift Hamiltonian for unitary dynamics; It is mapped to drift_dyn_gen during initialize_controls. ctrl_ham : List of Qobj; These are the control Hamiltonians for unitary dynamics; It is mapped to ctrl_dyn_gen during initialize_controls. H : List of Qobj; The combined drift and control Hamiltonians for each timeslot; These are the dynamics generators for unitary dynamics.; It is mapped to dyn_gen during initialize_controls; """""". def reset(self):; Dynamics.reset(self); self.id_text = 'UNIT'; self.drift_ham = None; self.ctrl_ham = None; self.H = None; self._dyn_gen_phase = -1j; self.apply_params(). def _create_computers(self):; """"""; Create the default timeslot, fidelity and propagator computers; """"""; # The time slot computer. By default it is set to _UpdateAll; # can be set to _DynUpdate in the configuration; # (see class file for details); if self.config.tslot_type == 'DYNAMIC':; self.tslot_computer = tslotcomp.TSlotCompDynUpdate(self); else:; self.tslot_computer = tslotcomp.TSlotCompUpdateAll(self). # set the default fidelity computer; self.fid_computer = fidcomp.FidCompUnitary(self); # set the default propagator computer; self.prop_computer = propcomp.PropCompDiag(self). def initialize_controls(self, amplitudes, init_tslots=True):; # Either the _dyn_gen or _ham names can be used; # This assumes that one or other has been set in the configuration. self._map_dyn_gen_to_ham(); Dynamics.initialize_controls(self, amplitudes, init_tslots=init_tslots); #self.H = self._dyn_gen. def _map_dyn_gen_to_ham(self):; if self.drift_dyn_gen is None:; self.drift_dyn_gen = self.drift_ham; else:; self.drift_ham = self.drift_dyn_gen. if self.ctrl_dyn_gen is None:; self.ctrl_dyn_gen = self.ctrl_ham; else:; self.ctrl_ham = self.ctrl_dyn_gen. self._dyn_gen_mapped = True. @property; def num_ctrls(self):; if not self._dyn_gen_mapped:; self._map_dyn_gen_to_h",MatchSource.WIKI,docs/4.2/modules/qutip/control/dynamics.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/control/dynamics.html
https://qutip.org/docs/4.2/modules/qutip/control/dynamics.html:44288,Modifiability,config,configuration,44288,"control Hamiltonians for each timeslot; These are the dynamics generators for unitary dynamics.; It is mapped to dyn_gen during initialize_controls; """""". def reset(self):; Dynamics.reset(self); self.id_text = 'UNIT'; self.drift_ham = None; self.ctrl_ham = None; self.H = None; self._dyn_gen_phase = -1j; self.apply_params(). def _create_computers(self):; """"""; Create the default timeslot, fidelity and propagator computers; """"""; # The time slot computer. By default it is set to _UpdateAll; # can be set to _DynUpdate in the configuration; # (see class file for details); if self.config.tslot_type == 'DYNAMIC':; self.tslot_computer = tslotcomp.TSlotCompDynUpdate(self); else:; self.tslot_computer = tslotcomp.TSlotCompUpdateAll(self). # set the default fidelity computer; self.fid_computer = fidcomp.FidCompUnitary(self); # set the default propagator computer; self.prop_computer = propcomp.PropCompDiag(self). def initialize_controls(self, amplitudes, init_tslots=True):; # Either the _dyn_gen or _ham names can be used; # This assumes that one or other has been set in the configuration. self._map_dyn_gen_to_ham(); Dynamics.initialize_controls(self, amplitudes, init_tslots=init_tslots); #self.H = self._dyn_gen. def _map_dyn_gen_to_ham(self):; if self.drift_dyn_gen is None:; self.drift_dyn_gen = self.drift_ham; else:; self.drift_ham = self.drift_dyn_gen. if self.ctrl_dyn_gen is None:; self.ctrl_dyn_gen = self.ctrl_ham; else:; self.ctrl_ham = self.ctrl_dyn_gen. self._dyn_gen_mapped = True. @property; def num_ctrls(self):; if not self._dyn_gen_mapped:; self._map_dyn_gen_to_ham(); if self._num_ctrls is None:; self._num_ctrls = self._get_num_ctrls(); return self._num_ctrls. def _get_onto_evo_target(self):; """"""; Get the adjoint of the target.; Used for calculating the 'backward' evolution; """"""; if self.oper_dtype == Qobj:; self._onto_evo_target = self.target.dag(); else:; self._onto_evo_target = self._target.T.conj(); return self._onto_evo_target. def _spectral_decomp(self, k):; """"""; Ca",MatchSource.WIKI,docs/4.2/modules/qutip/control/dynamics.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/control/dynamics.html
https://qutip.org/docs/4.2/modules/qutip/control/dynamics.html:50173,Modifiability,config,configuration,50173,"; eigvecadj_unit = self._is_unitary(; self._dyn_gen_eigenvectors_adj[k]); else:; eigvecadj_unit = None; msg = (""prop unit: {}; H herm: {}; ""; ""eigval unit: {}; eigvec unit: {}; ""; ""eigvecadj_unit: {}"".format(; prop_unit, herm, eigval_unit, eigvec_unit,; eigvecadj_unit)); logger.info(msg). [docs]class DynamicsSymplectic(Dynamics):; """"""; Symplectic systems; This is the subclass to use for systems where the dynamics is described; by symplectic matrices, e.g. coupled oscillators, quantum optics. Attributes; ----------; omega : array[drift_dyn_gen.shape]; matrix used in the calculation of propagators (time evolution); with symplectic systems.; ; """""". def reset(self):; Dynamics.reset(self); self.id_text = 'SYMPL'; self._omega = None; self._omega_qobj = None; self.grad_exact = True; self.apply_params(). def _create_computers(self):; """"""; Create the default timeslot, fidelity and propagator computers; """"""; # The time slot computer. By default it is set to _UpdateAll; # can be set to _DynUpdate in the configuration; # (see class file for details); if self.config.tslot_type == 'DYNAMIC':; self.tslot_computer = tslotcomp.TSlotCompDynUpdate(self); else:; self.tslot_computer = tslotcomp.TSlotCompUpdateAll(self). self.prop_computer = propcomp.PropCompFrechet(self); self.fid_computer = fidcomp.FidCompTraceDiff(self). @property; def omega(self):; if self._omega is None:; self._get_omega(); if self._omega_qobj is None:; self._omega_qobj = Qobj(self._omega, dims=self.dyn_dims); return self._omega_qobj. def _get_omega(self):; if self._omega is None:; n = self.get_drift_dim() // 2; omg = sympl.calc_omega(n); if self.oper_dtype == Qobj:; self._omega = Qobj(omg, dims=self.dyn_dims); self._omega_qobj = self._omega; elif self.oper_dtype == sp.csr_matrix:; self._omega = sp.csr_matrix(omg); else:; self._omega = omg; return self._omega; ; @property; def dyn_gen_phase(self):; """"""; The prephasing operator for the symplectic group generators; usually refered to as \Omega; """"""; # Cannot be calcul",MatchSource.WIKI,docs/4.2/modules/qutip/control/dynamics.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/control/dynamics.html
https://qutip.org/docs/4.2/modules/qutip/control/dynamics.html:50228,Modifiability,config,config,50228,"dj[k]); else:; eigvecadj_unit = None; msg = (""prop unit: {}; H herm: {}; ""; ""eigval unit: {}; eigvec unit: {}; ""; ""eigvecadj_unit: {}"".format(; prop_unit, herm, eigval_unit, eigvec_unit,; eigvecadj_unit)); logger.info(msg). [docs]class DynamicsSymplectic(Dynamics):; """"""; Symplectic systems; This is the subclass to use for systems where the dynamics is described; by symplectic matrices, e.g. coupled oscillators, quantum optics. Attributes; ----------; omega : array[drift_dyn_gen.shape]; matrix used in the calculation of propagators (time evolution); with symplectic systems.; ; """""". def reset(self):; Dynamics.reset(self); self.id_text = 'SYMPL'; self._omega = None; self._omega_qobj = None; self.grad_exact = True; self.apply_params(). def _create_computers(self):; """"""; Create the default timeslot, fidelity and propagator computers; """"""; # The time slot computer. By default it is set to _UpdateAll; # can be set to _DynUpdate in the configuration; # (see class file for details); if self.config.tslot_type == 'DYNAMIC':; self.tslot_computer = tslotcomp.TSlotCompDynUpdate(self); else:; self.tslot_computer = tslotcomp.TSlotCompUpdateAll(self). self.prop_computer = propcomp.PropCompFrechet(self); self.fid_computer = fidcomp.FidCompTraceDiff(self). @property; def omega(self):; if self._omega is None:; self._get_omega(); if self._omega_qobj is None:; self._omega_qobj = Qobj(self._omega, dims=self.dyn_dims); return self._omega_qobj. def _get_omega(self):; if self._omega is None:; n = self.get_drift_dim() // 2; omg = sympl.calc_omega(n); if self.oper_dtype == Qobj:; self._omega = Qobj(omg, dims=self.dyn_dims); self._omega_qobj = self._omega; elif self.oper_dtype == sp.csr_matrix:; self._omega = sp.csr_matrix(omg); else:; self._omega = omg; return self._omega; ; @property; def dyn_gen_phase(self):; """"""; The prephasing operator for the symplectic group generators; usually refered to as \Omega; """"""; # Cannot be calculated until the dyn_shape is set; # that is after the drift Hamitona",MatchSource.WIKI,docs/4.2/modules/qutip/control/dynamics.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/control/dynamics.html
https://qutip.org/docs/4.2/modules/qutip/control/dynamics.html:6294,Performance,perform,performance,6294,"ter,; """"""; warnings.warn(message, DeprecationWarning, stacklevel=stacklevel). def _func_deprecation(message, stacklevel=3):; """"""; Issue deprecation warning; Using stacklevel=3 will ensure message refers the function; calling with the deprecated parameter,; """"""; warnings.warn(message, DeprecationWarning, stacklevel=stacklevel). [docs]class Dynamics(object):; """"""; This is a base class only. See subclass descriptions and choose an; appropriate one for the application. Note that initialize_controls must be called before most of the methods; can be used. init_timeslots can be called sometimes earlier in order; to access timeslot related attributes. This acts as a container for the operators that are used to calculate; time evolution of the system under study. That is the dynamics generators; (Hamiltonians, Lindbladians etc), the propagators from one timeslot to; the next, and the evolution operators. Due to the large number of matrix; additions and multiplications, for small systems at least, the optimisation; performance is much better using ndarrays to represent these operators.; However. Attributes; ----------; log_level : integer; level of messaging output from the logger.; Options are attributes of qutip.logging_utils,; in decreasing levels of messaging, are:; DEBUG_INTENSE, DEBUG_VERBOSE, DEBUG, INFO, WARN, ERROR, CRITICAL; Anything WARN or above is effectively 'quiet' execution,; assuming everything runs as expected.; The default NOTSET implies that the level will be taken from; the QuTiP settings file, which by default is WARN. params: Dictionary; The key value pairs are the attribute name and value; Note: attributes are created if they do not exist already,; and are overwritten if they do. stats : Stats; Attributes of which give performance stats for the optimisation; set to None to reduce overhead of calculating stats.; Note it is (usually) shared with the Optimizer object. tslot_computer : TimeslotComputer (subclass instance); Used to manage when the timeslot ",MatchSource.WIKI,docs/4.2/modules/qutip/control/dynamics.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/control/dynamics.html
https://qutip.org/docs/4.2/modules/qutip/control/dynamics.html:7036,Performance,perform,performance,7036,"nerators; (Hamiltonians, Lindbladians etc), the propagators from one timeslot to; the next, and the evolution operators. Due to the large number of matrix; additions and multiplications, for small systems at least, the optimisation; performance is much better using ndarrays to represent these operators.; However. Attributes; ----------; log_level : integer; level of messaging output from the logger.; Options are attributes of qutip.logging_utils,; in decreasing levels of messaging, are:; DEBUG_INTENSE, DEBUG_VERBOSE, DEBUG, INFO, WARN, ERROR, CRITICAL; Anything WARN or above is effectively 'quiet' execution,; assuming everything runs as expected.; The default NOTSET implies that the level will be taken from; the QuTiP settings file, which by default is WARN. params: Dictionary; The key value pairs are the attribute name and value; Note: attributes are created if they do not exist already,; and are overwritten if they do. stats : Stats; Attributes of which give performance stats for the optimisation; set to None to reduce overhead of calculating stats.; Note it is (usually) shared with the Optimizer object. tslot_computer : TimeslotComputer (subclass instance); Used to manage when the timeslot dynamics; generators, propagators, gradients etc are updated. prop_computer : PropagatorComputer (subclass instance); Used to compute the propagators and their gradients. fid_computer : FidelityComputer (subclass instance); Used to computer the fidelity error and the fidelity error; gradient. memory_optimization : int; Level of memory optimisation. Setting to 0 (default) means that; execution speed is prioritized over memory.; Setting to 1 means that some memory prioritisation steps will be; taken, for instance using Qobj (and hence sparse arrays) as the; the internal operator data type, and not caching some operators; Potentially further memory saving maybe made with; memory_optimization > 1. ; The options are processed in _set_memory_optimizations, see; this for more informati",MatchSource.WIKI,docs/4.2/modules/qutip/control/dynamics.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/control/dynamics.html
https://qutip.org/docs/4.2/modules/qutip/control/dynamics.html:8387,Performance,perform,performs,8387,"ompute the propagators and their gradients. fid_computer : FidelityComputer (subclass instance); Used to computer the fidelity error and the fidelity error; gradient. memory_optimization : int; Level of memory optimisation. Setting to 0 (default) means that; execution speed is prioritized over memory.; Setting to 1 means that some memory prioritisation steps will be; taken, for instance using Qobj (and hence sparse arrays) as the; the internal operator data type, and not caching some operators; Potentially further memory saving maybe made with; memory_optimization > 1. ; The options are processed in _set_memory_optimizations, see; this for more information. Individual memory saving options can be; switched by settting them directly (see below). oper_dtype : type; Data type for internal dynamics generators, propagators and time; evolution operators. This can be ndarray or Qobj, or (in theory) any; other representaion that supports typical matrix methods (e.g. dot); ndarray performs best for smaller quantum systems.; Qobj may perform better for larger systems, and will also; perform better when (custom) fidelity measures use Qobj methods; such as partial trace.; See _choose_oper_dtype for how this is chosen when not specified; ; cache_phased_dyn_gen : bool; If True then the dynamics generators will be saved with and ; without the propagation prefactor (if there is one); Defaults to True when memory_optimization=0, otherwise False; ; cache_prop_grad : bool; If the True then the propagator gradients (for exact gradients) will; be computed when the propagator are computed and cache until; the are used by the fidelity computer. If False then the ; fidelity computer will calculate them as needed.; Defaults to True when memory_optimization=0, otherwise False; ; cache_dyn_gen_eigenvectors_adj: bool; If True then DynamicsUnitary will cached the adjoint of ; the Hamiltion eignvector matrix; Defaults to True when memory_optimization=0, otherwise False; ; sparse_eigen_decomp: boo",MatchSource.WIKI,docs/4.2/modules/qutip/control/dynamics.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/control/dynamics.html
https://qutip.org/docs/4.2/modules/qutip/control/dynamics.html:8440,Performance,perform,perform,8440,"o computer the fidelity error and the fidelity error; gradient. memory_optimization : int; Level of memory optimisation. Setting to 0 (default) means that; execution speed is prioritized over memory.; Setting to 1 means that some memory prioritisation steps will be; taken, for instance using Qobj (and hence sparse arrays) as the; the internal operator data type, and not caching some operators; Potentially further memory saving maybe made with; memory_optimization > 1. ; The options are processed in _set_memory_optimizations, see; this for more information. Individual memory saving options can be; switched by settting them directly (see below). oper_dtype : type; Data type for internal dynamics generators, propagators and time; evolution operators. This can be ndarray or Qobj, or (in theory) any; other representaion that supports typical matrix methods (e.g. dot); ndarray performs best for smaller quantum systems.; Qobj may perform better for larger systems, and will also; perform better when (custom) fidelity measures use Qobj methods; such as partial trace.; See _choose_oper_dtype for how this is chosen when not specified; ; cache_phased_dyn_gen : bool; If True then the dynamics generators will be saved with and ; without the propagation prefactor (if there is one); Defaults to True when memory_optimization=0, otherwise False; ; cache_prop_grad : bool; If the True then the propagator gradients (for exact gradients) will; be computed when the propagator are computed and cache until; the are used by the fidelity computer. If False then the ; fidelity computer will calculate them as needed.; Defaults to True when memory_optimization=0, otherwise False; ; cache_dyn_gen_eigenvectors_adj: bool; If True then DynamicsUnitary will cached the adjoint of ; the Hamiltion eignvector matrix; Defaults to True when memory_optimization=0, otherwise False; ; sparse_eigen_decomp: bool; If True then DynamicsUnitary will use the sparse eigenvalue ; decomposition.; Defaults to True when",MatchSource.WIKI,docs/4.2/modules/qutip/control/dynamics.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/control/dynamics.html
https://qutip.org/docs/4.2/modules/qutip/control/dynamics.html:8490,Performance,perform,perform,8490,"o computer the fidelity error and the fidelity error; gradient. memory_optimization : int; Level of memory optimisation. Setting to 0 (default) means that; execution speed is prioritized over memory.; Setting to 1 means that some memory prioritisation steps will be; taken, for instance using Qobj (and hence sparse arrays) as the; the internal operator data type, and not caching some operators; Potentially further memory saving maybe made with; memory_optimization > 1. ; The options are processed in _set_memory_optimizations, see; this for more information. Individual memory saving options can be; switched by settting them directly (see below). oper_dtype : type; Data type for internal dynamics generators, propagators and time; evolution operators. This can be ndarray or Qobj, or (in theory) any; other representaion that supports typical matrix methods (e.g. dot); ndarray performs best for smaller quantum systems.; Qobj may perform better for larger systems, and will also; perform better when (custom) fidelity measures use Qobj methods; such as partial trace.; See _choose_oper_dtype for how this is chosen when not specified; ; cache_phased_dyn_gen : bool; If True then the dynamics generators will be saved with and ; without the propagation prefactor (if there is one); Defaults to True when memory_optimization=0, otherwise False; ; cache_prop_grad : bool; If the True then the propagator gradients (for exact gradients) will; be computed when the propagator are computed and cache until; the are used by the fidelity computer. If False then the ; fidelity computer will calculate them as needed.; Defaults to True when memory_optimization=0, otherwise False; ; cache_dyn_gen_eigenvectors_adj: bool; If True then DynamicsUnitary will cached the adjoint of ; the Hamiltion eignvector matrix; Defaults to True when memory_optimization=0, otherwise False; ; sparse_eigen_decomp: bool; If True then DynamicsUnitary will use the sparse eigenvalue ; decomposition.; Defaults to True when",MatchSource.WIKI,docs/4.2/modules/qutip/control/dynamics.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/control/dynamics.html
https://qutip.org/docs/4.2/modules/qutip/control/dynamics.html:8998,Performance,cache,cache,8998,"parse arrays) as the; the internal operator data type, and not caching some operators; Potentially further memory saving maybe made with; memory_optimization > 1. ; The options are processed in _set_memory_optimizations, see; this for more information. Individual memory saving options can be; switched by settting them directly (see below). oper_dtype : type; Data type for internal dynamics generators, propagators and time; evolution operators. This can be ndarray or Qobj, or (in theory) any; other representaion that supports typical matrix methods (e.g. dot); ndarray performs best for smaller quantum systems.; Qobj may perform better for larger systems, and will also; perform better when (custom) fidelity measures use Qobj methods; such as partial trace.; See _choose_oper_dtype for how this is chosen when not specified; ; cache_phased_dyn_gen : bool; If True then the dynamics generators will be saved with and ; without the propagation prefactor (if there is one); Defaults to True when memory_optimization=0, otherwise False; ; cache_prop_grad : bool; If the True then the propagator gradients (for exact gradients) will; be computed when the propagator are computed and cache until; the are used by the fidelity computer. If False then the ; fidelity computer will calculate them as needed.; Defaults to True when memory_optimization=0, otherwise False; ; cache_dyn_gen_eigenvectors_adj: bool; If True then DynamicsUnitary will cached the adjoint of ; the Hamiltion eignvector matrix; Defaults to True when memory_optimization=0, otherwise False; ; sparse_eigen_decomp: bool; If True then DynamicsUnitary will use the sparse eigenvalue ; decomposition.; Defaults to True when memory_optimization<=1, otherwise False. num_tslots : integer; Number of timeslots (aka timeslices). num_ctrls : integer; Number of controls.; Note this is calculated as the length of ctrl_dyn_gen when first used.; And is recalculated during initialise_controls only. evo_time : float; Total time for the evol",MatchSource.WIKI,docs/4.2/modules/qutip/control/dynamics.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/control/dynamics.html
https://qutip.org/docs/4.2/modules/qutip/control/dynamics.html:9256,Performance,cache,cached,9256,"eory) any; other representaion that supports typical matrix methods (e.g. dot); ndarray performs best for smaller quantum systems.; Qobj may perform better for larger systems, and will also; perform better when (custom) fidelity measures use Qobj methods; such as partial trace.; See _choose_oper_dtype for how this is chosen when not specified; ; cache_phased_dyn_gen : bool; If True then the dynamics generators will be saved with and ; without the propagation prefactor (if there is one); Defaults to True when memory_optimization=0, otherwise False; ; cache_prop_grad : bool; If the True then the propagator gradients (for exact gradients) will; be computed when the propagator are computed and cache until; the are used by the fidelity computer. If False then the ; fidelity computer will calculate them as needed.; Defaults to True when memory_optimization=0, otherwise False; ; cache_dyn_gen_eigenvectors_adj: bool; If True then DynamicsUnitary will cached the adjoint of ; the Hamiltion eignvector matrix; Defaults to True when memory_optimization=0, otherwise False; ; sparse_eigen_decomp: bool; If True then DynamicsUnitary will use the sparse eigenvalue ; decomposition.; Defaults to True when memory_optimization<=1, otherwise False. num_tslots : integer; Number of timeslots (aka timeslices). num_ctrls : integer; Number of controls.; Note this is calculated as the length of ctrl_dyn_gen when first used.; And is recalculated during initialise_controls only. evo_time : float; Total time for the evolution. tau : array[num_tslots] of float; Duration of each timeslot; Note that if this is set before initialize_controls is called; then num_tslots and evo_time are calculated from tau, otherwise; tau is generated from num_tslots and evo_time, that is; equal size time slices. time : array[num_tslots+1] of float; Cumulative time for the evolution, that is the time at the start; of each time slice. drift_dyn_gen : Qobj or list of Qobj; Drift or system dynamics generator (Hamiltonian);",MatchSource.WIKI,docs/4.2/modules/qutip/control/dynamics.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/control/dynamics.html
https://qutip.org/docs/4.2/modules/qutip/control/dynamics.html:46808,Safety,avoid,avoid,46808," eig_vec = np.linalg.eigh(H); else:; if sparse:; H = self._dyn_gen[k].toarray(); else:; H = self._dyn_gen[k]; # returns row vector of eigenvals, columns with the eigenvecs; eig_val, eig_vec = la.eigh(H). # assuming H is an nxn matrix, find n; n = self.get_drift_dim(). # Calculate the propagator in the diagonalised basis; eig_val_tau = -1j*eig_val*self.tau[k]; prop_eig = np.exp(eig_val_tau). # Generate the factor matrix through the differences; # between each of the eigenvectors and the exponentiations; # create nxn matrix where each eigen val is repeated n times; # down the columns; o = np.ones([n, n]); eig_val_cols = eig_val_tau*o; # calculate all the differences by subtracting it from its transpose; eig_val_diffs = eig_val_cols - eig_val_cols.T; # repeat for the propagator; prop_eig_cols = prop_eig*o; prop_eig_diffs = prop_eig_cols - prop_eig_cols.T; # the factor matrix is the elementwise quotient of the; # differeneces between the exponentiated eigen vals and the; # differences between the eigen vals; # need to avoid division by zero that would arise due to denegerate; # eigenvalues and the diagonals; degen_mask = np.abs(eig_val_diffs) < self.fact_mat_round_prec; eig_val_diffs[degen_mask] = 1; factors = prop_eig_diffs / eig_val_diffs; # for degenerate eigenvalues the factor is just the exponent; factors[degen_mask] = prop_eig_cols[degen_mask]. # Store eigenvectors, propagator and factor matric; # for use in propagator computations; self._decomp_curr[k] = True; if isinstance(factors, np.ndarray):; self._dyn_gen_factormatrix[k] = factors; else:; self._dyn_gen_factormatrix[k] = np.array(factors). if self.oper_dtype == Qobj:; self._prop_eigen[k] = Qobj(np.diagflat(prop_eig),; dims=self.dyn_dims); self._dyn_gen_eigenvectors[k] = Qobj(eig_vec,; dims=self.dyn_dims); # The _dyn_gen_eigenvectors_adj list is not used in; # memory optimised modes; if self._dyn_gen_eigenvectors_adj is not None:; self._dyn_gen_eigenvectors_adj[k] = \; self._dyn_gen_eigenvectors[k].dag(); else",MatchSource.WIKI,docs/4.2/modules/qutip/control/dynamics.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/control/dynamics.html
https://qutip.org/docs/4.2/modules/qutip/control/dynamics.html:5889,Security,access,access,5889,"ould be a Qobj or a list of Qobj""); else:; for d in drift:; if not isinstance(d, Qobj):; raise TypeError(; ""drift should be a Qobj or a list of Qobj""). warnings.simplefilter('always', DeprecationWarning) #turn off filter; def _attrib_deprecation(message, stacklevel=3):; """"""; Issue deprecation warning; Using stacklevel=3 will ensure message refers the function; calling with the deprecated parameter,; """"""; warnings.warn(message, DeprecationWarning, stacklevel=stacklevel). def _func_deprecation(message, stacklevel=3):; """"""; Issue deprecation warning; Using stacklevel=3 will ensure message refers the function; calling with the deprecated parameter,; """"""; warnings.warn(message, DeprecationWarning, stacklevel=stacklevel). [docs]class Dynamics(object):; """"""; This is a base class only. See subclass descriptions and choose an; appropriate one for the application. Note that initialize_controls must be called before most of the methods; can be used. init_timeslots can be called sometimes earlier in order; to access timeslot related attributes. This acts as a container for the operators that are used to calculate; time evolution of the system under study. That is the dynamics generators; (Hamiltonians, Lindbladians etc), the propagators from one timeslot to; the next, and the evolution operators. Due to the large number of matrix; additions and multiplications, for small systems at least, the optimisation; performance is much better using ndarrays to represent these operators.; However. Attributes; ----------; log_level : integer; level of messaging output from the logger.; Options are attributes of qutip.logging_utils,; in decreasing levels of messaging, are:; DEBUG_INTENSE, DEBUG_VERBOSE, DEBUG, INFO, WARN, ERROR, CRITICAL; Anything WARN or above is effectively 'quiet' execution,; assuming everything runs as expected.; The default NOTSET implies that the level will be taken from; the QuTiP settings file, which by default is WARN. params: Dictionary; The key value pairs are th",MatchSource.WIKI,docs/4.2/modules/qutip/control/dynamics.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/control/dynamics.html
https://qutip.org/docs/4.2/modules/qutip/control/dynamics.html:15356,Security,access,accessors,15356,"self.memory_optimization = 0; self.oper_dtype = None; self.cache_phased_dyn_gen = None; self.cache_prop_grad = None; self.cache_dyn_gen_eigenvectors_adj = None; self.sparse_eigen_decomp = None; self.dyn_dims = None; self.dyn_shape = None; self.sys_dims = None; self.sys_shape = None; self.time_depend_drift = False; self.time_depend_ctrl_dyn_gen = False; # These internal attributes will be of the internal operator data type; # used to compute the evolution; # Note this maybe ndarray, Qobj or some other depending on oper_dtype; self._drift_dyn_gen = None; self._ctrl_dyn_gen = None; self._phased_ctrl_dyn_gen = None; self._dyn_gen_phase = None; self._initial = None; self._target = None; self._onto_evo_target = None; self._dyn_gen = None; self._phased_dyn_gen = None; self._prop = None; self._prop_grad = None; self._fwd_evo = None; self._onwd_evo = None; self._onto_evo = None; # The _qobj attribs are Qobj representations of the equivalent; # internal attribute. They are only set when the extenal accessors; # are used; self._onto_evo_target_qobj = None; self._dyn_gen_qobj = None; self._prop_qobj = None; self._prop_grad_qobj = None; self._fwd_evo_qobj = None; self._onwd_evo_qobj = None; self._onto_evo_qobj = None; # Atrributes used in diagonalisation; # again in internal operator data type (see above); self._decomp_curr = None; self._prop_eigen = None; self._dyn_gen_eigenvectors = None; self._dyn_gen_eigenvectors_adj = None; self._dyn_gen_factormatrix = None; self.fact_mat_round_prec = 1e-10. # Debug and information attribs; self.stats = None; self.id_text = 'DYN_BASE'; self.def_amps_fname = ""ctrl_amps.txt""; self.log_level = self.config.log_level; # Internal flags; self._dyn_gen_mapped = False; self._timeslots_initialized = False; self._ctrls_initialized = False; self._ctrl_dyn_gen_checked = False; self._drift_dyn_gen_checked = False; # Unitary checking; self.unitarity_check_level = 0; self.unitarity_tol = 1e-10; # Data dumping; self.dump = None; self.dump_to_file = False. s",MatchSource.WIKI,docs/4.2/modules/qutip/control/dynamics.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/control/dynamics.html
https://qutip.org/docs/4.2/modules/qutip/control/dynamics.html:3260,Testability,log,logging,3260,". """"""; Classes that define the dynamics of the (quantum) system and target evolution; to be optimised.; The contols are also defined here, i.e. the dynamics generators (Hamiltonians,; Limbladians etc). The dynamics for the time slices are calculated here, along; with the evolution as determined by the control amplitudes. See the subclass descriptions and choose the appropriate class for the; application. The choice depends on the type of matrix used to define; the dynamics. These class implement functions for getting the dynamics generators for; the combined (drift + ctrls) dynamics with the approriate operator applied. Note the methods in these classes were inspired by:; DYNAMO - Dynamic Framework for Quantum Optimal Control; See Machnes et.al., arXiv.1011.4874; """"""; import os; import warnings; import numpy as np; import scipy.linalg as la; import scipy.sparse as sp; # QuTiP; from qutip import Qobj; from qutip.sparse import sp_eigs, _dense_eigs; import qutip.settings as settings; # QuTiP logging; import qutip.logging_utils as logging; logger = logging.get_logger(); # QuTiP control modules; import qutip.control.errors as errors; import qutip.control.tslotcomp as tslotcomp; import qutip.control.fidcomp as fidcomp; import qutip.control.propcomp as propcomp; import qutip.control.symplectic as sympl; import qutip.control.dump as qtrldump. DEF_NUM_TSLOTS = 10; DEF_EVO_TIME = 1.0. def _is_string(var):; try:; if isinstance(var, basestring):; return True; except NameError:; try:; if isinstance(var, str):; return True; except:; return False; except:; return False. return False; ; def _check_ctrls_container(ctrls):; """"""; Check through the controls container.; Convert to an array if its a list of lists; return the processed container; raise type error if the container structure is invalid; """"""; if isinstance(ctrls, (list, tuple)):; # Check to see if list of lists; try:; if isinstance(ctrls[0], (list, tuple)):; ctrls = np.array(ctrls); except:; pass; ; if isinstance(ctrls, np.n",MatchSource.WIKI,docs/4.2/modules/qutip/control/dynamics.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/control/dynamics.html
https://qutip.org/docs/4.2/modules/qutip/control/dynamics.html:3299,Testability,log,logging,3299,"(quantum) system and target evolution; to be optimised.; The contols are also defined here, i.e. the dynamics generators (Hamiltonians,; Limbladians etc). The dynamics for the time slices are calculated here, along; with the evolution as determined by the control amplitudes. See the subclass descriptions and choose the appropriate class for the; application. The choice depends on the type of matrix used to define; the dynamics. These class implement functions for getting the dynamics generators for; the combined (drift + ctrls) dynamics with the approriate operator applied. Note the methods in these classes were inspired by:; DYNAMO - Dynamic Framework for Quantum Optimal Control; See Machnes et.al., arXiv.1011.4874; """"""; import os; import warnings; import numpy as np; import scipy.linalg as la; import scipy.sparse as sp; # QuTiP; from qutip import Qobj; from qutip.sparse import sp_eigs, _dense_eigs; import qutip.settings as settings; # QuTiP logging; import qutip.logging_utils as logging; logger = logging.get_logger(); # QuTiP control modules; import qutip.control.errors as errors; import qutip.control.tslotcomp as tslotcomp; import qutip.control.fidcomp as fidcomp; import qutip.control.propcomp as propcomp; import qutip.control.symplectic as sympl; import qutip.control.dump as qtrldump. DEF_NUM_TSLOTS = 10; DEF_EVO_TIME = 1.0. def _is_string(var):; try:; if isinstance(var, basestring):; return True; except NameError:; try:; if isinstance(var, str):; return True; except:; return False; except:; return False. return False; ; def _check_ctrls_container(ctrls):; """"""; Check through the controls container.; Convert to an array if its a list of lists; return the processed container; raise type error if the container structure is invalid; """"""; if isinstance(ctrls, (list, tuple)):; # Check to see if list of lists; try:; if isinstance(ctrls[0], (list, tuple)):; ctrls = np.array(ctrls); except:; pass; ; if isinstance(ctrls, np.ndarray):; if len(ctrls.shape) != 2:; raise TypeE",MatchSource.WIKI,docs/4.2/modules/qutip/control/dynamics.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/control/dynamics.html
https://qutip.org/docs/4.2/modules/qutip/control/dynamics.html:3308,Testability,log,logger,3308,"(quantum) system and target evolution; to be optimised.; The contols are also defined here, i.e. the dynamics generators (Hamiltonians,; Limbladians etc). The dynamics for the time slices are calculated here, along; with the evolution as determined by the control amplitudes. See the subclass descriptions and choose the appropriate class for the; application. The choice depends on the type of matrix used to define; the dynamics. These class implement functions for getting the dynamics generators for; the combined (drift + ctrls) dynamics with the approriate operator applied. Note the methods in these classes were inspired by:; DYNAMO - Dynamic Framework for Quantum Optimal Control; See Machnes et.al., arXiv.1011.4874; """"""; import os; import warnings; import numpy as np; import scipy.linalg as la; import scipy.sparse as sp; # QuTiP; from qutip import Qobj; from qutip.sparse import sp_eigs, _dense_eigs; import qutip.settings as settings; # QuTiP logging; import qutip.logging_utils as logging; logger = logging.get_logger(); # QuTiP control modules; import qutip.control.errors as errors; import qutip.control.tslotcomp as tslotcomp; import qutip.control.fidcomp as fidcomp; import qutip.control.propcomp as propcomp; import qutip.control.symplectic as sympl; import qutip.control.dump as qtrldump. DEF_NUM_TSLOTS = 10; DEF_EVO_TIME = 1.0. def _is_string(var):; try:; if isinstance(var, basestring):; return True; except NameError:; try:; if isinstance(var, str):; return True; except:; return False; except:; return False. return False; ; def _check_ctrls_container(ctrls):; """"""; Check through the controls container.; Convert to an array if its a list of lists; return the processed container; raise type error if the container structure is invalid; """"""; if isinstance(ctrls, (list, tuple)):; # Check to see if list of lists; try:; if isinstance(ctrls[0], (list, tuple)):; ctrls = np.array(ctrls); except:; pass; ; if isinstance(ctrls, np.ndarray):; if len(ctrls.shape) != 2:; raise TypeE",MatchSource.WIKI,docs/4.2/modules/qutip/control/dynamics.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/control/dynamics.html
https://qutip.org/docs/4.2/modules/qutip/control/dynamics.html:3317,Testability,log,logging,3317,"(quantum) system and target evolution; to be optimised.; The contols are also defined here, i.e. the dynamics generators (Hamiltonians,; Limbladians etc). The dynamics for the time slices are calculated here, along; with the evolution as determined by the control amplitudes. See the subclass descriptions and choose the appropriate class for the; application. The choice depends on the type of matrix used to define; the dynamics. These class implement functions for getting the dynamics generators for; the combined (drift + ctrls) dynamics with the approriate operator applied. Note the methods in these classes were inspired by:; DYNAMO - Dynamic Framework for Quantum Optimal Control; See Machnes et.al., arXiv.1011.4874; """"""; import os; import warnings; import numpy as np; import scipy.linalg as la; import scipy.sparse as sp; # QuTiP; from qutip import Qobj; from qutip.sparse import sp_eigs, _dense_eigs; import qutip.settings as settings; # QuTiP logging; import qutip.logging_utils as logging; logger = logging.get_logger(); # QuTiP control modules; import qutip.control.errors as errors; import qutip.control.tslotcomp as tslotcomp; import qutip.control.fidcomp as fidcomp; import qutip.control.propcomp as propcomp; import qutip.control.symplectic as sympl; import qutip.control.dump as qtrldump. DEF_NUM_TSLOTS = 10; DEF_EVO_TIME = 1.0. def _is_string(var):; try:; if isinstance(var, basestring):; return True; except NameError:; try:; if isinstance(var, str):; return True; except:; return False; except:; return False. return False; ; def _check_ctrls_container(ctrls):; """"""; Check through the controls container.; Convert to an array if its a list of lists; return the processed container; raise type error if the container structure is invalid; """"""; if isinstance(ctrls, (list, tuple)):; # Check to see if list of lists; try:; if isinstance(ctrls[0], (list, tuple)):; ctrls = np.array(ctrls); except:; pass; ; if isinstance(ctrls, np.ndarray):; if len(ctrls.shape) != 2:; raise TypeE",MatchSource.WIKI,docs/4.2/modules/qutip/control/dynamics.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/control/dynamics.html
https://qutip.org/docs/4.2/modules/qutip/control/dynamics.html:6456,Testability,log,logger,6456,"n warning; Using stacklevel=3 will ensure message refers the function; calling with the deprecated parameter,; """"""; warnings.warn(message, DeprecationWarning, stacklevel=stacklevel). [docs]class Dynamics(object):; """"""; This is a base class only. See subclass descriptions and choose an; appropriate one for the application. Note that initialize_controls must be called before most of the methods; can be used. init_timeslots can be called sometimes earlier in order; to access timeslot related attributes. This acts as a container for the operators that are used to calculate; time evolution of the system under study. That is the dynamics generators; (Hamiltonians, Lindbladians etc), the propagators from one timeslot to; the next, and the evolution operators. Due to the large number of matrix; additions and multiplications, for small systems at least, the optimisation; performance is much better using ndarrays to represent these operators.; However. Attributes; ----------; log_level : integer; level of messaging output from the logger.; Options are attributes of qutip.logging_utils,; in decreasing levels of messaging, are:; DEBUG_INTENSE, DEBUG_VERBOSE, DEBUG, INFO, WARN, ERROR, CRITICAL; Anything WARN or above is effectively 'quiet' execution,; assuming everything runs as expected.; The default NOTSET implies that the level will be taken from; the QuTiP settings file, which by default is WARN. params: Dictionary; The key value pairs are the attribute name and value; Note: attributes are created if they do not exist already,; and are overwritten if they do. stats : Stats; Attributes of which give performance stats for the optimisation; set to None to reduce overhead of calculating stats.; Note it is (usually) shared with the Optimizer object. tslot_computer : TimeslotComputer (subclass instance); Used to manage when the timeslot dynamics; generators, propagators, gradients etc are updated. prop_computer : PropagatorComputer (subclass instance); Used to compute the propagat",MatchSource.WIKI,docs/4.2/modules/qutip/control/dynamics.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/control/dynamics.html
https://qutip.org/docs/4.2/modules/qutip/control/dynamics.html:16996,Testability,log,logger,16996,"self.log_level = self.config.log_level; # Internal flags; self._dyn_gen_mapped = False; self._timeslots_initialized = False; self._ctrls_initialized = False; self._ctrl_dyn_gen_checked = False; self._drift_dyn_gen_checked = False; # Unitary checking; self.unitarity_check_level = 0; self.unitarity_tol = 1e-10; # Data dumping; self.dump = None; self.dump_to_file = False. self.apply_params(). # Create the computing objects; self._create_computers(). self.clear(). [docs] def apply_params(self, params=None):; """"""; Set object attributes based on the dictionary (if any) passed in the; instantiation, or passed as a parameter; This is called during the instantiation automatically.; The key value pairs are the attribute name and value; Note: attributes are created if they do not exist already,; and are overwritten if they do.; """"""; if not params:; params = self.params. if isinstance(params, dict):; self.params = params; for key in params:; setattr(self, key, params[key]). @property; def log_level(self):; return logger.level. @log_level.setter; def log_level(self, lvl):; """"""; Set the log_level attribute and set the level of the logger; that is call logger.setLevel(lvl); """"""; logger.setLevel(lvl). @property; def dumping(self):; """"""; The level of data dumping that will occur during the time evolution; calculation.; - NONE : No processing data dumped (Default); - SUMMARY : A summary of each time evolution will be recorded; - FULL : All operators used or created in the calculation dumped; - CUSTOM : Some customised level of dumping; When first set to CUSTOM this is equivalent to SUMMARY. It is then up; to the user to specify which operators are dumped; WARNING: FULL could consume a lot of memory!; """"""; if self.dump is None:; lvl = 'NONE'; else:; lvl = self.dump.level. return lvl. @dumping.setter; def dumping(self, value):; if value is None:; self.dump = None; else:; if not _is_string(value):; raise TypeError(""Value must be string value""); lvl = value.upper(); if lvl == 'NONE':; se",MatchSource.WIKI,docs/4.2/modules/qutip/control/dynamics.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/control/dynamics.html
https://qutip.org/docs/4.2/modules/qutip/control/dynamics.html:17114,Testability,log,logger,17114,"s_initialized = False; self._ctrls_initialized = False; self._ctrl_dyn_gen_checked = False; self._drift_dyn_gen_checked = False; # Unitary checking; self.unitarity_check_level = 0; self.unitarity_tol = 1e-10; # Data dumping; self.dump = None; self.dump_to_file = False. self.apply_params(). # Create the computing objects; self._create_computers(). self.clear(). [docs] def apply_params(self, params=None):; """"""; Set object attributes based on the dictionary (if any) passed in the; instantiation, or passed as a parameter; This is called during the instantiation automatically.; The key value pairs are the attribute name and value; Note: attributes are created if they do not exist already,; and are overwritten if they do.; """"""; if not params:; params = self.params. if isinstance(params, dict):; self.params = params; for key in params:; setattr(self, key, params[key]). @property; def log_level(self):; return logger.level. @log_level.setter; def log_level(self, lvl):; """"""; Set the log_level attribute and set the level of the logger; that is call logger.setLevel(lvl); """"""; logger.setLevel(lvl). @property; def dumping(self):; """"""; The level of data dumping that will occur during the time evolution; calculation.; - NONE : No processing data dumped (Default); - SUMMARY : A summary of each time evolution will be recorded; - FULL : All operators used or created in the calculation dumped; - CUSTOM : Some customised level of dumping; When first set to CUSTOM this is equivalent to SUMMARY. It is then up; to the user to specify which operators are dumped; WARNING: FULL could consume a lot of memory!; """"""; if self.dump is None:; lvl = 'NONE'; else:; lvl = self.dump.level. return lvl. @dumping.setter; def dumping(self, value):; if value is None:; self.dump = None; else:; if not _is_string(value):; raise TypeError(""Value must be string value""); lvl = value.upper(); if lvl == 'NONE':; self.dump = None; else:; if not isinstance(self.dump, qtrldump.DynamicsDump):; self.dump = qtrldump.Dynam",MatchSource.WIKI,docs/4.2/modules/qutip/control/dynamics.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/control/dynamics.html
https://qutip.org/docs/4.2/modules/qutip/control/dynamics.html:17135,Testability,log,logger,17135,"s_initialized = False; self._ctrls_initialized = False; self._ctrl_dyn_gen_checked = False; self._drift_dyn_gen_checked = False; # Unitary checking; self.unitarity_check_level = 0; self.unitarity_tol = 1e-10; # Data dumping; self.dump = None; self.dump_to_file = False. self.apply_params(). # Create the computing objects; self._create_computers(). self.clear(). [docs] def apply_params(self, params=None):; """"""; Set object attributes based on the dictionary (if any) passed in the; instantiation, or passed as a parameter; This is called during the instantiation automatically.; The key value pairs are the attribute name and value; Note: attributes are created if they do not exist already,; and are overwritten if they do.; """"""; if not params:; params = self.params. if isinstance(params, dict):; self.params = params; for key in params:; setattr(self, key, params[key]). @property; def log_level(self):; return logger.level. @log_level.setter; def log_level(self, lvl):; """"""; Set the log_level attribute and set the level of the logger; that is call logger.setLevel(lvl); """"""; logger.setLevel(lvl). @property; def dumping(self):; """"""; The level of data dumping that will occur during the time evolution; calculation.; - NONE : No processing data dumped (Default); - SUMMARY : A summary of each time evolution will be recorded; - FULL : All operators used or created in the calculation dumped; - CUSTOM : Some customised level of dumping; When first set to CUSTOM this is equivalent to SUMMARY. It is then up; to the user to specify which operators are dumped; WARNING: FULL could consume a lot of memory!; """"""; if self.dump is None:; lvl = 'NONE'; else:; lvl = self.dump.level. return lvl. @dumping.setter; def dumping(self, value):; if value is None:; self.dump = None; else:; if not _is_string(value):; raise TypeError(""Value must be string value""); lvl = value.upper(); if lvl == 'NONE':; self.dump = None; else:; if not isinstance(self.dump, qtrldump.DynamicsDump):; self.dump = qtrldump.Dynam",MatchSource.WIKI,docs/4.2/modules/qutip/control/dynamics.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/control/dynamics.html
https://qutip.org/docs/4.2/modules/qutip/control/dynamics.html:17162,Testability,log,logger,17162,"_checked = False; self._drift_dyn_gen_checked = False; # Unitary checking; self.unitarity_check_level = 0; self.unitarity_tol = 1e-10; # Data dumping; self.dump = None; self.dump_to_file = False. self.apply_params(). # Create the computing objects; self._create_computers(). self.clear(). [docs] def apply_params(self, params=None):; """"""; Set object attributes based on the dictionary (if any) passed in the; instantiation, or passed as a parameter; This is called during the instantiation automatically.; The key value pairs are the attribute name and value; Note: attributes are created if they do not exist already,; and are overwritten if they do.; """"""; if not params:; params = self.params. if isinstance(params, dict):; self.params = params; for key in params:; setattr(self, key, params[key]). @property; def log_level(self):; return logger.level. @log_level.setter; def log_level(self, lvl):; """"""; Set the log_level attribute and set the level of the logger; that is call logger.setLevel(lvl); """"""; logger.setLevel(lvl). @property; def dumping(self):; """"""; The level of data dumping that will occur during the time evolution; calculation.; - NONE : No processing data dumped (Default); - SUMMARY : A summary of each time evolution will be recorded; - FULL : All operators used or created in the calculation dumped; - CUSTOM : Some customised level of dumping; When first set to CUSTOM this is equivalent to SUMMARY. It is then up; to the user to specify which operators are dumped; WARNING: FULL could consume a lot of memory!; """"""; if self.dump is None:; lvl = 'NONE'; else:; lvl = self.dump.level. return lvl. @dumping.setter; def dumping(self, value):; if value is None:; self.dump = None; else:; if not _is_string(value):; raise TypeError(""Value must be string value""); lvl = value.upper(); if lvl == 'NONE':; self.dump = None; else:; if not isinstance(self.dump, qtrldump.DynamicsDump):; self.dump = qtrldump.DynamicsDump(self, level=lvl); else:; self.dump.level = lvl. @property; def dum",MatchSource.WIKI,docs/4.2/modules/qutip/control/dynamics.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/control/dynamics.html
https://qutip.org/docs/4.2/modules/qutip/control/dynamics.html:20880,Testability,log,logger,20880,"ttribute is already set; in which case this step in ignored; Generate the cumulative time array 'time' based on the tau values; """"""; # set the time intervals to be equal timeslices of the total if; # the have not been set already (as part of user config); if self._num_tslots is None:; self._num_tslots = DEF_NUM_TSLOTS; if self._evo_time is None:; self._evo_time = DEF_EVO_TIME. if self._tau is None:; self._tau = np.ones(self._num_tslots, dtype='f') * \; self._evo_time/self._num_tslots; else:; self._num_tslots = len(self._tau); self._evo_time = np.sum(self._tau). self.time = np.zeros(self._num_tslots+1, dtype=float); # set the cumulative time by summing the time intervals; for t in range(self._num_tslots):; self.time[t+1] = self.time[t] + self._tau[t]. self._timeslots_initialized = True; ; def _set_memory_optimizations(self):; """"""; Set various memory optimisation attributes based on the ; memory_optimization attribute; If they have been set already, e.g. in apply_params; then they will not be overidden here; """"""; logger.info(""Setting memory optimisations for level {}"".format(; self.memory_optimization)); ; if self.oper_dtype is None:; self._choose_oper_dtype(); logger.info(""Internal operator data type choosen to be {}"".format(; self.oper_dtype)); else:; logger.info(""Using operator data type {}"".format(; self.oper_dtype)); ; if self.cache_phased_dyn_gen is None:; if self.memory_optimization > 0:; self.cache_phased_dyn_gen = False; else:; self.cache_phased_dyn_gen = True; logger.info(""phased dynamics generator caching {}"".format(; self.cache_phased_dyn_gen)); ; if self.cache_prop_grad is None:; if self.memory_optimization > 0:; self.cache_prop_grad = False; else:; self.cache_prop_grad = True ; logger.info(""propagator gradient caching {}"".format(; self.cache_prop_grad)); ; if self.cache_dyn_gen_eigenvectors_adj is None:; if self.memory_optimization > 0:; self.cache_dyn_gen_eigenvectors_adj = False; else:; self.cache_dyn_gen_eigenvectors_adj = True ; logger.info(""eigenvec",MatchSource.WIKI,docs/4.2/modules/qutip/control/dynamics.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/control/dynamics.html
https://qutip.org/docs/4.2/modules/qutip/control/dynamics.html:21031,Testability,log,logger,21031,"timeslices of the total if; # the have not been set already (as part of user config); if self._num_tslots is None:; self._num_tslots = DEF_NUM_TSLOTS; if self._evo_time is None:; self._evo_time = DEF_EVO_TIME. if self._tau is None:; self._tau = np.ones(self._num_tslots, dtype='f') * \; self._evo_time/self._num_tslots; else:; self._num_tslots = len(self._tau); self._evo_time = np.sum(self._tau). self.time = np.zeros(self._num_tslots+1, dtype=float); # set the cumulative time by summing the time intervals; for t in range(self._num_tslots):; self.time[t+1] = self.time[t] + self._tau[t]. self._timeslots_initialized = True; ; def _set_memory_optimizations(self):; """"""; Set various memory optimisation attributes based on the ; memory_optimization attribute; If they have been set already, e.g. in apply_params; then they will not be overidden here; """"""; logger.info(""Setting memory optimisations for level {}"".format(; self.memory_optimization)); ; if self.oper_dtype is None:; self._choose_oper_dtype(); logger.info(""Internal operator data type choosen to be {}"".format(; self.oper_dtype)); else:; logger.info(""Using operator data type {}"".format(; self.oper_dtype)); ; if self.cache_phased_dyn_gen is None:; if self.memory_optimization > 0:; self.cache_phased_dyn_gen = False; else:; self.cache_phased_dyn_gen = True; logger.info(""phased dynamics generator caching {}"".format(; self.cache_phased_dyn_gen)); ; if self.cache_prop_grad is None:; if self.memory_optimization > 0:; self.cache_prop_grad = False; else:; self.cache_prop_grad = True ; logger.info(""propagator gradient caching {}"".format(; self.cache_prop_grad)); ; if self.cache_dyn_gen_eigenvectors_adj is None:; if self.memory_optimization > 0:; self.cache_dyn_gen_eigenvectors_adj = False; else:; self.cache_dyn_gen_eigenvectors_adj = True ; logger.info(""eigenvector adjoint caching {}"".format(; self.cache_dyn_gen_eigenvectors_adj)); ; if self.sparse_eigen_decomp is None:; if self.memory_optimization > 1:; self.sparse_eigen_decomp ",MatchSource.WIKI,docs/4.2/modules/qutip/control/dynamics.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/control/dynamics.html
https://qutip.org/docs/4.2/modules/qutip/control/dynamics.html:21125,Testability,log,logger,21125,"num_tslots is None:; self._num_tslots = DEF_NUM_TSLOTS; if self._evo_time is None:; self._evo_time = DEF_EVO_TIME. if self._tau is None:; self._tau = np.ones(self._num_tslots, dtype='f') * \; self._evo_time/self._num_tslots; else:; self._num_tslots = len(self._tau); self._evo_time = np.sum(self._tau). self.time = np.zeros(self._num_tslots+1, dtype=float); # set the cumulative time by summing the time intervals; for t in range(self._num_tslots):; self.time[t+1] = self.time[t] + self._tau[t]. self._timeslots_initialized = True; ; def _set_memory_optimizations(self):; """"""; Set various memory optimisation attributes based on the ; memory_optimization attribute; If they have been set already, e.g. in apply_params; then they will not be overidden here; """"""; logger.info(""Setting memory optimisations for level {}"".format(; self.memory_optimization)); ; if self.oper_dtype is None:; self._choose_oper_dtype(); logger.info(""Internal operator data type choosen to be {}"".format(; self.oper_dtype)); else:; logger.info(""Using operator data type {}"".format(; self.oper_dtype)); ; if self.cache_phased_dyn_gen is None:; if self.memory_optimization > 0:; self.cache_phased_dyn_gen = False; else:; self.cache_phased_dyn_gen = True; logger.info(""phased dynamics generator caching {}"".format(; self.cache_phased_dyn_gen)); ; if self.cache_prop_grad is None:; if self.memory_optimization > 0:; self.cache_prop_grad = False; else:; self.cache_prop_grad = True ; logger.info(""propagator gradient caching {}"".format(; self.cache_prop_grad)); ; if self.cache_dyn_gen_eigenvectors_adj is None:; if self.memory_optimization > 0:; self.cache_dyn_gen_eigenvectors_adj = False; else:; self.cache_dyn_gen_eigenvectors_adj = True ; logger.info(""eigenvector adjoint caching {}"".format(; self.cache_dyn_gen_eigenvectors_adj)); ; if self.sparse_eigen_decomp is None:; if self.memory_optimization > 1:; self.sparse_eigen_decomp = True; else:; self.sparse_eigen_decomp = False ; logger.info(""use sparse eigen decomp {}"".for",MatchSource.WIKI,docs/4.2/modules/qutip/control/dynamics.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/control/dynamics.html
https://qutip.org/docs/4.2/modules/qutip/control/dynamics.html:21346,Testability,log,logger,21346,"tslots; else:; self._num_tslots = len(self._tau); self._evo_time = np.sum(self._tau). self.time = np.zeros(self._num_tslots+1, dtype=float); # set the cumulative time by summing the time intervals; for t in range(self._num_tslots):; self.time[t+1] = self.time[t] + self._tau[t]. self._timeslots_initialized = True; ; def _set_memory_optimizations(self):; """"""; Set various memory optimisation attributes based on the ; memory_optimization attribute; If they have been set already, e.g. in apply_params; then they will not be overidden here; """"""; logger.info(""Setting memory optimisations for level {}"".format(; self.memory_optimization)); ; if self.oper_dtype is None:; self._choose_oper_dtype(); logger.info(""Internal operator data type choosen to be {}"".format(; self.oper_dtype)); else:; logger.info(""Using operator data type {}"".format(; self.oper_dtype)); ; if self.cache_phased_dyn_gen is None:; if self.memory_optimization > 0:; self.cache_phased_dyn_gen = False; else:; self.cache_phased_dyn_gen = True; logger.info(""phased dynamics generator caching {}"".format(; self.cache_phased_dyn_gen)); ; if self.cache_prop_grad is None:; if self.memory_optimization > 0:; self.cache_prop_grad = False; else:; self.cache_prop_grad = True ; logger.info(""propagator gradient caching {}"".format(; self.cache_prop_grad)); ; if self.cache_dyn_gen_eigenvectors_adj is None:; if self.memory_optimization > 0:; self.cache_dyn_gen_eigenvectors_adj = False; else:; self.cache_dyn_gen_eigenvectors_adj = True ; logger.info(""eigenvector adjoint caching {}"".format(; self.cache_dyn_gen_eigenvectors_adj)); ; if self.sparse_eigen_decomp is None:; if self.memory_optimization > 1:; self.sparse_eigen_decomp = True; else:; self.sparse_eigen_decomp = False ; logger.info(""use sparse eigen decomp {}"".format(; self.sparse_eigen_decomp)); ; def _choose_oper_dtype(self):; """"""; Attempt select most efficient internal operator data type; """""". if self.memory_optimization > 0:; self.oper_dtype = Qobj; else:; # Method taken f",MatchSource.WIKI,docs/4.2/modules/qutip/control/dynamics.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/control/dynamics.html
https://qutip.org/docs/4.2/modules/qutip/control/dynamics.html:21572,Testability,log,logger,21572,"s):; self.time[t+1] = self.time[t] + self._tau[t]. self._timeslots_initialized = True; ; def _set_memory_optimizations(self):; """"""; Set various memory optimisation attributes based on the ; memory_optimization attribute; If they have been set already, e.g. in apply_params; then they will not be overidden here; """"""; logger.info(""Setting memory optimisations for level {}"".format(; self.memory_optimization)); ; if self.oper_dtype is None:; self._choose_oper_dtype(); logger.info(""Internal operator data type choosen to be {}"".format(; self.oper_dtype)); else:; logger.info(""Using operator data type {}"".format(; self.oper_dtype)); ; if self.cache_phased_dyn_gen is None:; if self.memory_optimization > 0:; self.cache_phased_dyn_gen = False; else:; self.cache_phased_dyn_gen = True; logger.info(""phased dynamics generator caching {}"".format(; self.cache_phased_dyn_gen)); ; if self.cache_prop_grad is None:; if self.memory_optimization > 0:; self.cache_prop_grad = False; else:; self.cache_prop_grad = True ; logger.info(""propagator gradient caching {}"".format(; self.cache_prop_grad)); ; if self.cache_dyn_gen_eigenvectors_adj is None:; if self.memory_optimization > 0:; self.cache_dyn_gen_eigenvectors_adj = False; else:; self.cache_dyn_gen_eigenvectors_adj = True ; logger.info(""eigenvector adjoint caching {}"".format(; self.cache_dyn_gen_eigenvectors_adj)); ; if self.sparse_eigen_decomp is None:; if self.memory_optimization > 1:; self.sparse_eigen_decomp = True; else:; self.sparse_eigen_decomp = False ; logger.info(""use sparse eigen decomp {}"".format(; self.sparse_eigen_decomp)); ; def _choose_oper_dtype(self):; """"""; Attempt select most efficient internal operator data type; """""". if self.memory_optimization > 0:; self.oper_dtype = Qobj; else:; # Method taken from Qobj.expm(); # if method is not explicitly given, try to make a good choice; # between sparse and dense solvers by considering the size of the; # system and the number of non-zero elements.; if self.time_depend_drift:; dg = ",MatchSource.WIKI,docs/4.2/modules/qutip/control/dynamics.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/control/dynamics.html
https://qutip.org/docs/4.2/modules/qutip/control/dynamics.html:21832,Testability,log,logger,21832,"e.g. in apply_params; then they will not be overidden here; """"""; logger.info(""Setting memory optimisations for level {}"".format(; self.memory_optimization)); ; if self.oper_dtype is None:; self._choose_oper_dtype(); logger.info(""Internal operator data type choosen to be {}"".format(; self.oper_dtype)); else:; logger.info(""Using operator data type {}"".format(; self.oper_dtype)); ; if self.cache_phased_dyn_gen is None:; if self.memory_optimization > 0:; self.cache_phased_dyn_gen = False; else:; self.cache_phased_dyn_gen = True; logger.info(""phased dynamics generator caching {}"".format(; self.cache_phased_dyn_gen)); ; if self.cache_prop_grad is None:; if self.memory_optimization > 0:; self.cache_prop_grad = False; else:; self.cache_prop_grad = True ; logger.info(""propagator gradient caching {}"".format(; self.cache_prop_grad)); ; if self.cache_dyn_gen_eigenvectors_adj is None:; if self.memory_optimization > 0:; self.cache_dyn_gen_eigenvectors_adj = False; else:; self.cache_dyn_gen_eigenvectors_adj = True ; logger.info(""eigenvector adjoint caching {}"".format(; self.cache_dyn_gen_eigenvectors_adj)); ; if self.sparse_eigen_decomp is None:; if self.memory_optimization > 1:; self.sparse_eigen_decomp = True; else:; self.sparse_eigen_decomp = False ; logger.info(""use sparse eigen decomp {}"".format(; self.sparse_eigen_decomp)); ; def _choose_oper_dtype(self):; """"""; Attempt select most efficient internal operator data type; """""". if self.memory_optimization > 0:; self.oper_dtype = Qobj; else:; # Method taken from Qobj.expm(); # if method is not explicitly given, try to make a good choice; # between sparse and dense solvers by considering the size of the; # system and the number of non-zero elements.; if self.time_depend_drift:; dg = self.drift_dyn_gen[0]; else:; dg = self.drift_dyn_gen; if self.time_depend_ctrl_dyn_gen:; ctrls = self.ctrl_dyn_gen[0, :]; else:; ctrls = self.ctrl_dyn_gen; for c in ctrls:; dg = dg + c. N = dg.data.shape[0]; n = dg.data.nnz. if N ** 2 < 100 * n:; # lar",MatchSource.WIKI,docs/4.2/modules/qutip/control/dynamics.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/control/dynamics.html
https://qutip.org/docs/4.2/modules/qutip/control/dynamics.html:22074,Testability,log,logger,22074,"data type choosen to be {}"".format(; self.oper_dtype)); else:; logger.info(""Using operator data type {}"".format(; self.oper_dtype)); ; if self.cache_phased_dyn_gen is None:; if self.memory_optimization > 0:; self.cache_phased_dyn_gen = False; else:; self.cache_phased_dyn_gen = True; logger.info(""phased dynamics generator caching {}"".format(; self.cache_phased_dyn_gen)); ; if self.cache_prop_grad is None:; if self.memory_optimization > 0:; self.cache_prop_grad = False; else:; self.cache_prop_grad = True ; logger.info(""propagator gradient caching {}"".format(; self.cache_prop_grad)); ; if self.cache_dyn_gen_eigenvectors_adj is None:; if self.memory_optimization > 0:; self.cache_dyn_gen_eigenvectors_adj = False; else:; self.cache_dyn_gen_eigenvectors_adj = True ; logger.info(""eigenvector adjoint caching {}"".format(; self.cache_dyn_gen_eigenvectors_adj)); ; if self.sparse_eigen_decomp is None:; if self.memory_optimization > 1:; self.sparse_eigen_decomp = True; else:; self.sparse_eigen_decomp = False ; logger.info(""use sparse eigen decomp {}"".format(; self.sparse_eigen_decomp)); ; def _choose_oper_dtype(self):; """"""; Attempt select most efficient internal operator data type; """""". if self.memory_optimization > 0:; self.oper_dtype = Qobj; else:; # Method taken from Qobj.expm(); # if method is not explicitly given, try to make a good choice; # between sparse and dense solvers by considering the size of the; # system and the number of non-zero elements.; if self.time_depend_drift:; dg = self.drift_dyn_gen[0]; else:; dg = self.drift_dyn_gen; if self.time_depend_ctrl_dyn_gen:; ctrls = self.ctrl_dyn_gen[0, :]; else:; ctrls = self.ctrl_dyn_gen; for c in ctrls:; dg = dg + c. N = dg.data.shape[0]; n = dg.data.nnz. if N ** 2 < 100 * n:; # large number of nonzero elements, revert to dense solver; self.oper_dtype = np.ndarray; elif N > 400:; # large system, and quite sparse -> qutips sparse method; self.oper_dtype = Qobj; else:; # small system, but quite sparse -> qutips sparse/dense me",MatchSource.WIKI,docs/4.2/modules/qutip/control/dynamics.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/control/dynamics.html
https://qutip.org/docs/4.2/modules/qutip/control/dynamics.html:25097,Testability,log,logger,25097,"full(); self._target = self.target.full(); if self.time_depend_drift:; self._drift_dyn_gen = [d.full() for d in self.drift_dyn_gen]; else:; self._drift_dyn_gen = self.drift_dyn_gen.full(); if self.time_depend_ctrl_dyn_gen:; self._ctrl_dyn_gen = np.empty([n_ts, n_ctrls], dtype=object); for k in range(n_ts):; for j in range(n_ctrls):; self._ctrl_dyn_gen[k, j] = \; self.ctrl_dyn_gen[k, j].full(); else:; self._ctrl_dyn_gen = [ctrl.full() ; for ctrl in self.ctrl_dyn_gen]; elif self.oper_dtype == sp.csr_matrix:; self._initial = self.initial.data; self._target = self.target.data; if self.time_depend_drift:; self._drift_dyn_gen = [d.data for d in self.drift_dyn_gen]; else:; self._drift_dyn_gen = self.drift_dyn_gen.data; ; if self.time_depend_ctrl_dyn_gen:; self._ctrl_dyn_gen = np.empty([n_ts, n_ctrls], dtype=object); for k in range(n_ts):; for j in range(n_ctrls):; self._ctrl_dyn_gen[k, j] = \; self.ctrl_dyn_gen[k, j].data; else:; self._ctrl_dyn_gen = [ctrl.data for ctrl in self.ctrl_dyn_gen]; else:; logger.warn(""Unknown option '{}' for oper_dtype. ""; ""Assuming that internal drift, ctrls, initial and target ""; ""have been set correctly"".format(self.oper_dtype)); ; if self.cache_phased_dyn_gen and not self.dyn_gen_phase is None:; if self.time_depend_ctrl_dyn_gen:; self._phased_ctrl_dyn_gen = np.empty([n_ts, n_ctrls], ; dtype=object); for k in range(n_ts):; for j in range(n_ctrls):; self._phased_ctrl_dyn_gen[k, j] = self._apply_phase(; self._ctrl_dyn_gen[k, j]); else:; self._phased_ctrl_dyn_gen = [self._apply_phase(ctrl); for ctrl in self._ctrl_dyn_gen]; ; self._dyn_gen = [object for x in range(self.num_tslots)]; if self.cache_phased_dyn_gen:; self._phased_dyn_gen = [object for x in range(self.num_tslots)]; self._prop = [object for x in range(self.num_tslots)]; if self.prop_computer.grad_exact and self.cache_prop_grad:; self._prop_grad = np.empty([self.num_tslots, self.num_ctrls],; dtype=object); # Time evolution operator (forward propagation); self._fwd_evo = [object for x in ",MatchSource.WIKI,docs/4.2/modules/qutip/control/dynamics.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/control/dynamics.html
https://qutip.org/docs/4.2/modules/qutip/control/dynamics.html:26616,Testability,log,logging,26616,"phase(ctrl); for ctrl in self._ctrl_dyn_gen]; ; self._dyn_gen = [object for x in range(self.num_tslots)]; if self.cache_phased_dyn_gen:; self._phased_dyn_gen = [object for x in range(self.num_tslots)]; self._prop = [object for x in range(self.num_tslots)]; if self.prop_computer.grad_exact and self.cache_prop_grad:; self._prop_grad = np.empty([self.num_tslots, self.num_ctrls],; dtype=object); # Time evolution operator (forward propagation); self._fwd_evo = [object for x in range(self.num_tslots+1)]; self._fwd_evo[0] = self._initial; if self.fid_computer.uses_onwd_evo:; # Time evolution operator (onward propagation); self._onwd_evo = [object for x in range(self.num_tslots)]; if self.fid_computer.uses_onto_evo:; # Onward propagation overlap with inverse target; self._onto_evo = [object for x in range(self.num_tslots+1)]; self._onto_evo[self.num_tslots] = self._get_onto_evo_target(). if isinstance(self.prop_computer, propcomp.PropCompDiag):; self._create_decomp_lists(). if (self.log_level <= logging.DEBUG; and isinstance(self, DynamicsUnitary)):; self.unitarity_check_level = 1. if self.dump_to_file:; if self.dump is None:; self.dumping = 'SUMMARY'; self.dump.write_to_file = True; self.dump.create_dump_dir(); logger.info(""Dynamics dump will be written to:\n{}"".format(; self.dump.dump_dir)). def _create_decomp_lists(self):; """"""; Create lists that will hold the eigen decomposition; used in calculating propagators and gradients; Note: used with PropCompDiag propagator calcs; """"""; n_ts = self.num_tslots; self._decomp_curr = [False for x in range(n_ts)]; self._prop_eigen = [object for x in range(n_ts)]; self._dyn_gen_eigenvectors = [object for x in range(n_ts)]; if self.cache_dyn_gen_eigenvectors_adj:; self._dyn_gen_eigenvectors_adj = [object for x in range(n_ts)]; self._dyn_gen_factormatrix = [object for x in range(n_ts)]. [docs] def initialize_controls(self, amps, init_tslots=True):; """"""; Set the initial control amplitudes and time slices; Note this must be called after the ",MatchSource.WIKI,docs/4.2/modules/qutip/control/dynamics.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/control/dynamics.html
https://qutip.org/docs/4.2/modules/qutip/control/dynamics.html:26837,Testability,log,logger,26837,"ject for x in range(self.num_tslots)]; if self.prop_computer.grad_exact and self.cache_prop_grad:; self._prop_grad = np.empty([self.num_tslots, self.num_ctrls],; dtype=object); # Time evolution operator (forward propagation); self._fwd_evo = [object for x in range(self.num_tslots+1)]; self._fwd_evo[0] = self._initial; if self.fid_computer.uses_onwd_evo:; # Time evolution operator (onward propagation); self._onwd_evo = [object for x in range(self.num_tslots)]; if self.fid_computer.uses_onto_evo:; # Onward propagation overlap with inverse target; self._onto_evo = [object for x in range(self.num_tslots+1)]; self._onto_evo[self.num_tslots] = self._get_onto_evo_target(). if isinstance(self.prop_computer, propcomp.PropCompDiag):; self._create_decomp_lists(). if (self.log_level <= logging.DEBUG; and isinstance(self, DynamicsUnitary)):; self.unitarity_check_level = 1. if self.dump_to_file:; if self.dump is None:; self.dumping = 'SUMMARY'; self.dump.write_to_file = True; self.dump.create_dump_dir(); logger.info(""Dynamics dump will be written to:\n{}"".format(; self.dump.dump_dir)). def _create_decomp_lists(self):; """"""; Create lists that will hold the eigen decomposition; used in calculating propagators and gradients; Note: used with PropCompDiag propagator calcs; """"""; n_ts = self.num_tslots; self._decomp_curr = [False for x in range(n_ts)]; self._prop_eigen = [object for x in range(n_ts)]; self._dyn_gen_eigenvectors = [object for x in range(n_ts)]; if self.cache_dyn_gen_eigenvectors_adj:; self._dyn_gen_eigenvectors_adj = [object for x in range(n_ts)]; self._dyn_gen_factormatrix = [object for x in range(n_ts)]. [docs] def initialize_controls(self, amps, init_tslots=True):; """"""; Set the initial control amplitudes and time slices; Note this must be called after the configuration is complete; before any dynamics can be calculated; """"""; if not isinstance(self.prop_computer, propcomp.PropagatorComputer):; raise errors.UsageError(; ""No prop_computer (propagator computer) ""; ""set. A ",MatchSource.WIKI,docs/4.2/modules/qutip/control/dynamics.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/control/dynamics.html
https://qutip.org/docs/4.2/modules/qutip/control/dynamics.html:29551,Testability,log,logged,29551,"s(amps). def check_ctrls_initialized(self):; if not self._ctrls_initialized:; raise errors.UsageError(; ""Controls not initialised. ""; ""Ensure Dynamics.initialize_controls has been ""; ""executed with the initial control amplitudes.""). def get_amp_times(self):; return self.time[:self.num_tslots]. [docs] def save_amps(self, file_name=None, times=None, amps=None, verbose=False):; """"""; Save a file with the current control amplitudes in each timeslot; The first column in the file will be the start time of the slot. Parameters; ----------; file_name : string; Name of the file; If None given the def_amps_fname attribuite will be used. times : List type (or string); List / array of the start times for each slot; If None given this will be retrieved through get_amp_times(); If 'exclude' then times will not be saved in the file, just; the amplitudes. amps : Array[num_tslots, num_ctrls]; Amplitudes to be saved; If None given the ctrl_amps attribute will be used. verbose : Boolean; If True then an info message will be logged; """"""; self.check_ctrls_initialized(). inctimes = True; if file_name is None:; file_name = self.def_amps_fname; if amps is None:; amps = self.ctrl_amps; if times is None:; times = self.get_amp_times(); else:; if _is_string(times):; if times.lower() == 'exclude':; inctimes = False; else:; logger.warn(""Unknown option for times '{}' ""; ""when saving amplitudes"".format(times)); times = self.get_amp_times(). try:; if inctimes:; shp = amps.shape; data = np.empty([shp[0], shp[1] + 1], dtype=float); data[:, 0] = times; data[:, 1:] = amps; else:; data = amps. np.savetxt(file_name, data, delimiter='\t', fmt='%14.6g'). if verbose:; logger.info(""Amplitudes saved to file: "" + file_name); except Exception as e:; logger.error(""Failed to save amplitudes due to underling ""; ""error: {}"".format(e)). [docs] def update_ctrl_amps(self, new_amps):; """"""; Determine if any amplitudes have changed. If so, then mark the; timeslots as needing recalculation; The actual work is completed by t",MatchSource.WIKI,docs/4.2/modules/qutip/control/dynamics.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/control/dynamics.html
https://qutip.org/docs/4.2/modules/qutip/control/dynamics.html:29846,Testability,log,logger,29846," [docs] def save_amps(self, file_name=None, times=None, amps=None, verbose=False):; """"""; Save a file with the current control amplitudes in each timeslot; The first column in the file will be the start time of the slot. Parameters; ----------; file_name : string; Name of the file; If None given the def_amps_fname attribuite will be used. times : List type (or string); List / array of the start times for each slot; If None given this will be retrieved through get_amp_times(); If 'exclude' then times will not be saved in the file, just; the amplitudes. amps : Array[num_tslots, num_ctrls]; Amplitudes to be saved; If None given the ctrl_amps attribute will be used. verbose : Boolean; If True then an info message will be logged; """"""; self.check_ctrls_initialized(). inctimes = True; if file_name is None:; file_name = self.def_amps_fname; if amps is None:; amps = self.ctrl_amps; if times is None:; times = self.get_amp_times(); else:; if _is_string(times):; if times.lower() == 'exclude':; inctimes = False; else:; logger.warn(""Unknown option for times '{}' ""; ""when saving amplitudes"".format(times)); times = self.get_amp_times(). try:; if inctimes:; shp = amps.shape; data = np.empty([shp[0], shp[1] + 1], dtype=float); data[:, 0] = times; data[:, 1:] = amps; else:; data = amps. np.savetxt(file_name, data, delimiter='\t', fmt='%14.6g'). if verbose:; logger.info(""Amplitudes saved to file: "" + file_name); except Exception as e:; logger.error(""Failed to save amplitudes due to underling ""; ""error: {}"".format(e)). [docs] def update_ctrl_amps(self, new_amps):; """"""; Determine if any amplitudes have changed. If so, then mark the; timeslots as needing recalculation; The actual work is completed by the compare_amps method of the; timeslot computer; """""". if self.log_level <= logging.DEBUG_INTENSE:; logger.log(logging.DEBUG_INTENSE, ""Updating amplitudes...\n""; ""Current control amplitudes:\n"" + str(self.ctrl_amps) +; ""\n(potenially) new amplitudes:\n"" + str(new_amps)). self.tslot_computer.co",MatchSource.WIKI,docs/4.2/modules/qutip/control/dynamics.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/control/dynamics.html
https://qutip.org/docs/4.2/modules/qutip/control/dynamics.html:30185,Testability,log,logger,30185,"e (or string); List / array of the start times for each slot; If None given this will be retrieved through get_amp_times(); If 'exclude' then times will not be saved in the file, just; the amplitudes. amps : Array[num_tslots, num_ctrls]; Amplitudes to be saved; If None given the ctrl_amps attribute will be used. verbose : Boolean; If True then an info message will be logged; """"""; self.check_ctrls_initialized(). inctimes = True; if file_name is None:; file_name = self.def_amps_fname; if amps is None:; amps = self.ctrl_amps; if times is None:; times = self.get_amp_times(); else:; if _is_string(times):; if times.lower() == 'exclude':; inctimes = False; else:; logger.warn(""Unknown option for times '{}' ""; ""when saving amplitudes"".format(times)); times = self.get_amp_times(). try:; if inctimes:; shp = amps.shape; data = np.empty([shp[0], shp[1] + 1], dtype=float); data[:, 0] = times; data[:, 1:] = amps; else:; data = amps. np.savetxt(file_name, data, delimiter='\t', fmt='%14.6g'). if verbose:; logger.info(""Amplitudes saved to file: "" + file_name); except Exception as e:; logger.error(""Failed to save amplitudes due to underling ""; ""error: {}"".format(e)). [docs] def update_ctrl_amps(self, new_amps):; """"""; Determine if any amplitudes have changed. If so, then mark the; timeslots as needing recalculation; The actual work is completed by the compare_amps method of the; timeslot computer; """""". if self.log_level <= logging.DEBUG_INTENSE:; logger.log(logging.DEBUG_INTENSE, ""Updating amplitudes...\n""; ""Current control amplitudes:\n"" + str(self.ctrl_amps) +; ""\n(potenially) new amplitudes:\n"" + str(new_amps)). self.tslot_computer.compare_amps(new_amps). [docs] def flag_system_changed(self):; """"""; Flag evolution, fidelity and gradients as needing recalculation; """"""; self.evo_current = False; self.fid_computer.flag_system_changed(). [docs] def get_drift_dim(self):; """"""; Returns the size of the matrix that defines the drift dynamics; that is assuming the drift is NxN, then this return",MatchSource.WIKI,docs/4.2/modules/qutip/control/dynamics.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/control/dynamics.html
https://qutip.org/docs/4.2/modules/qutip/control/dynamics.html:30264,Testability,log,logger,30264," each slot; If None given this will be retrieved through get_amp_times(); If 'exclude' then times will not be saved in the file, just; the amplitudes. amps : Array[num_tslots, num_ctrls]; Amplitudes to be saved; If None given the ctrl_amps attribute will be used. verbose : Boolean; If True then an info message will be logged; """"""; self.check_ctrls_initialized(). inctimes = True; if file_name is None:; file_name = self.def_amps_fname; if amps is None:; amps = self.ctrl_amps; if times is None:; times = self.get_amp_times(); else:; if _is_string(times):; if times.lower() == 'exclude':; inctimes = False; else:; logger.warn(""Unknown option for times '{}' ""; ""when saving amplitudes"".format(times)); times = self.get_amp_times(). try:; if inctimes:; shp = amps.shape; data = np.empty([shp[0], shp[1] + 1], dtype=float); data[:, 0] = times; data[:, 1:] = amps; else:; data = amps. np.savetxt(file_name, data, delimiter='\t', fmt='%14.6g'). if verbose:; logger.info(""Amplitudes saved to file: "" + file_name); except Exception as e:; logger.error(""Failed to save amplitudes due to underling ""; ""error: {}"".format(e)). [docs] def update_ctrl_amps(self, new_amps):; """"""; Determine if any amplitudes have changed. If so, then mark the; timeslots as needing recalculation; The actual work is completed by the compare_amps method of the; timeslot computer; """""". if self.log_level <= logging.DEBUG_INTENSE:; logger.log(logging.DEBUG_INTENSE, ""Updating amplitudes...\n""; ""Current control amplitudes:\n"" + str(self.ctrl_amps) +; ""\n(potenially) new amplitudes:\n"" + str(new_amps)). self.tslot_computer.compare_amps(new_amps). [docs] def flag_system_changed(self):; """"""; Flag evolution, fidelity and gradients as needing recalculation; """"""; self.evo_current = False; self.fid_computer.flag_system_changed(). [docs] def get_drift_dim(self):; """"""; Returns the size of the matrix that defines the drift dynamics; that is assuming the drift is NxN, then this returns N; """"""; if self.dyn_shape is None:; self.refresh",MatchSource.WIKI,docs/4.2/modules/qutip/control/dynamics.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/control/dynamics.html
https://qutip.org/docs/4.2/modules/qutip/control/dynamics.html:30608,Testability,log,logging,30608,"= True; if file_name is None:; file_name = self.def_amps_fname; if amps is None:; amps = self.ctrl_amps; if times is None:; times = self.get_amp_times(); else:; if _is_string(times):; if times.lower() == 'exclude':; inctimes = False; else:; logger.warn(""Unknown option for times '{}' ""; ""when saving amplitudes"".format(times)); times = self.get_amp_times(). try:; if inctimes:; shp = amps.shape; data = np.empty([shp[0], shp[1] + 1], dtype=float); data[:, 0] = times; data[:, 1:] = amps; else:; data = amps. np.savetxt(file_name, data, delimiter='\t', fmt='%14.6g'). if verbose:; logger.info(""Amplitudes saved to file: "" + file_name); except Exception as e:; logger.error(""Failed to save amplitudes due to underling ""; ""error: {}"".format(e)). [docs] def update_ctrl_amps(self, new_amps):; """"""; Determine if any amplitudes have changed. If so, then mark the; timeslots as needing recalculation; The actual work is completed by the compare_amps method of the; timeslot computer; """""". if self.log_level <= logging.DEBUG_INTENSE:; logger.log(logging.DEBUG_INTENSE, ""Updating amplitudes...\n""; ""Current control amplitudes:\n"" + str(self.ctrl_amps) +; ""\n(potenially) new amplitudes:\n"" + str(new_amps)). self.tslot_computer.compare_amps(new_amps). [docs] def flag_system_changed(self):; """"""; Flag evolution, fidelity and gradients as needing recalculation; """"""; self.evo_current = False; self.fid_computer.flag_system_changed(). [docs] def get_drift_dim(self):; """"""; Returns the size of the matrix that defines the drift dynamics; that is assuming the drift is NxN, then this returns N; """"""; if self.dyn_shape is None:; self.refresh_drift_attribs(); return self.dyn_shape[0]; ; [docs] def refresh_drift_attribs(self):; """"""Reset the dyn_shape, dyn_dims and time_depend_drift attribs""""""; ; if isinstance(self.drift_dyn_gen, (list, tuple)):; d0 = self.drift_dyn_gen[0]; self.time_depend_drift = True; else:; d0 = self.drift_dyn_gen; self.time_depend_drift = False. if not isinstance(d0, Qobj):; raise TypeErro",MatchSource.WIKI,docs/4.2/modules/qutip/control/dynamics.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/control/dynamics.html
https://qutip.org/docs/4.2/modules/qutip/control/dynamics.html:30632,Testability,log,logger,30632,"s None:; file_name = self.def_amps_fname; if amps is None:; amps = self.ctrl_amps; if times is None:; times = self.get_amp_times(); else:; if _is_string(times):; if times.lower() == 'exclude':; inctimes = False; else:; logger.warn(""Unknown option for times '{}' ""; ""when saving amplitudes"".format(times)); times = self.get_amp_times(). try:; if inctimes:; shp = amps.shape; data = np.empty([shp[0], shp[1] + 1], dtype=float); data[:, 0] = times; data[:, 1:] = amps; else:; data = amps. np.savetxt(file_name, data, delimiter='\t', fmt='%14.6g'). if verbose:; logger.info(""Amplitudes saved to file: "" + file_name); except Exception as e:; logger.error(""Failed to save amplitudes due to underling ""; ""error: {}"".format(e)). [docs] def update_ctrl_amps(self, new_amps):; """"""; Determine if any amplitudes have changed. If so, then mark the; timeslots as needing recalculation; The actual work is completed by the compare_amps method of the; timeslot computer; """""". if self.log_level <= logging.DEBUG_INTENSE:; logger.log(logging.DEBUG_INTENSE, ""Updating amplitudes...\n""; ""Current control amplitudes:\n"" + str(self.ctrl_amps) +; ""\n(potenially) new amplitudes:\n"" + str(new_amps)). self.tslot_computer.compare_amps(new_amps). [docs] def flag_system_changed(self):; """"""; Flag evolution, fidelity and gradients as needing recalculation; """"""; self.evo_current = False; self.fid_computer.flag_system_changed(). [docs] def get_drift_dim(self):; """"""; Returns the size of the matrix that defines the drift dynamics; that is assuming the drift is NxN, then this returns N; """"""; if self.dyn_shape is None:; self.refresh_drift_attribs(); return self.dyn_shape[0]; ; [docs] def refresh_drift_attribs(self):; """"""Reset the dyn_shape, dyn_dims and time_depend_drift attribs""""""; ; if isinstance(self.drift_dyn_gen, (list, tuple)):; d0 = self.drift_dyn_gen[0]; self.time_depend_drift = True; else:; d0 = self.drift_dyn_gen; self.time_depend_drift = False. if not isinstance(d0, Qobj):; raise TypeError(""Unable to determine",MatchSource.WIKI,docs/4.2/modules/qutip/control/dynamics.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/control/dynamics.html
https://qutip.org/docs/4.2/modules/qutip/control/dynamics.html:30639,Testability,log,log,30639," = self.def_amps_fname; if amps is None:; amps = self.ctrl_amps; if times is None:; times = self.get_amp_times(); else:; if _is_string(times):; if times.lower() == 'exclude':; inctimes = False; else:; logger.warn(""Unknown option for times '{}' ""; ""when saving amplitudes"".format(times)); times = self.get_amp_times(). try:; if inctimes:; shp = amps.shape; data = np.empty([shp[0], shp[1] + 1], dtype=float); data[:, 0] = times; data[:, 1:] = amps; else:; data = amps. np.savetxt(file_name, data, delimiter='\t', fmt='%14.6g'). if verbose:; logger.info(""Amplitudes saved to file: "" + file_name); except Exception as e:; logger.error(""Failed to save amplitudes due to underling ""; ""error: {}"".format(e)). [docs] def update_ctrl_amps(self, new_amps):; """"""; Determine if any amplitudes have changed. If so, then mark the; timeslots as needing recalculation; The actual work is completed by the compare_amps method of the; timeslot computer; """""". if self.log_level <= logging.DEBUG_INTENSE:; logger.log(logging.DEBUG_INTENSE, ""Updating amplitudes...\n""; ""Current control amplitudes:\n"" + str(self.ctrl_amps) +; ""\n(potenially) new amplitudes:\n"" + str(new_amps)). self.tslot_computer.compare_amps(new_amps). [docs] def flag_system_changed(self):; """"""; Flag evolution, fidelity and gradients as needing recalculation; """"""; self.evo_current = False; self.fid_computer.flag_system_changed(). [docs] def get_drift_dim(self):; """"""; Returns the size of the matrix that defines the drift dynamics; that is assuming the drift is NxN, then this returns N; """"""; if self.dyn_shape is None:; self.refresh_drift_attribs(); return self.dyn_shape[0]; ; [docs] def refresh_drift_attribs(self):; """"""Reset the dyn_shape, dyn_dims and time_depend_drift attribs""""""; ; if isinstance(self.drift_dyn_gen, (list, tuple)):; d0 = self.drift_dyn_gen[0]; self.time_depend_drift = True; else:; d0 = self.drift_dyn_gen; self.time_depend_drift = False. if not isinstance(d0, Qobj):; raise TypeError(""Unable to determine drift attributes",MatchSource.WIKI,docs/4.2/modules/qutip/control/dynamics.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/control/dynamics.html
https://qutip.org/docs/4.2/modules/qutip/control/dynamics.html:30643,Testability,log,logging,30643," = self.def_amps_fname; if amps is None:; amps = self.ctrl_amps; if times is None:; times = self.get_amp_times(); else:; if _is_string(times):; if times.lower() == 'exclude':; inctimes = False; else:; logger.warn(""Unknown option for times '{}' ""; ""when saving amplitudes"".format(times)); times = self.get_amp_times(). try:; if inctimes:; shp = amps.shape; data = np.empty([shp[0], shp[1] + 1], dtype=float); data[:, 0] = times; data[:, 1:] = amps; else:; data = amps. np.savetxt(file_name, data, delimiter='\t', fmt='%14.6g'). if verbose:; logger.info(""Amplitudes saved to file: "" + file_name); except Exception as e:; logger.error(""Failed to save amplitudes due to underling ""; ""error: {}"".format(e)). [docs] def update_ctrl_amps(self, new_amps):; """"""; Determine if any amplitudes have changed. If so, then mark the; timeslots as needing recalculation; The actual work is completed by the compare_amps method of the; timeslot computer; """""". if self.log_level <= logging.DEBUG_INTENSE:; logger.log(logging.DEBUG_INTENSE, ""Updating amplitudes...\n""; ""Current control amplitudes:\n"" + str(self.ctrl_amps) +; ""\n(potenially) new amplitudes:\n"" + str(new_amps)). self.tslot_computer.compare_amps(new_amps). [docs] def flag_system_changed(self):; """"""; Flag evolution, fidelity and gradients as needing recalculation; """"""; self.evo_current = False; self.fid_computer.flag_system_changed(). [docs] def get_drift_dim(self):; """"""; Returns the size of the matrix that defines the drift dynamics; that is assuming the drift is NxN, then this returns N; """"""; if self.dyn_shape is None:; self.refresh_drift_attribs(); return self.dyn_shape[0]; ; [docs] def refresh_drift_attribs(self):; """"""Reset the dyn_shape, dyn_dims and time_depend_drift attribs""""""; ; if isinstance(self.drift_dyn_gen, (list, tuple)):; d0 = self.drift_dyn_gen[0]; self.time_depend_drift = True; else:; d0 = self.drift_dyn_gen; self.time_depend_drift = False. if not isinstance(d0, Qobj):; raise TypeError(""Unable to determine drift attributes",MatchSource.WIKI,docs/4.2/modules/qutip/control/dynamics.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/control/dynamics.html
https://qutip.org/docs/4.2/modules/qutip/control/dynamics.html:40445,Testability,log,logging,40445,"._onwd_evo_qobj. @property; def evo_t2targ(self):; _attrib_deprecation(; ""'evo_t2targ' has been replaced by '_onto_evo'""); return self._onto_evo. @property; def onto_evo(self):; """"""; List of evolution operators (Qobj) from the initial to the given; timeslot; """"""; if self._onto_evo is not None:; if self._onto_evo_qobj is None:; if self.oper_dtype == Qobj:; self._onto_evo_qobj = self._onto_evo; else:; self._onto_evo_qobj = []; for k in range(0, self.num_tslots):; self._onto_evo_qobj.append(Qobj(self._onto_evo[k],; dims=self.sys_dims)); self._onto_evo_qobj.append(self.onto_evo_target). return self._onto_evo_qobj. [docs] def compute_evolution(self):; """"""; Recalculate the time evolution operators; Dynamics generators (e.g. Hamiltonian) and; prop (propagators) are calculated as necessary; Actual work is completed by the recompute_evolution method; of the timeslot computer; """""". # Check if values are already current, otherwise calculate all values; if not self.evo_current:; if self.log_level <= logging.DEBUG_VERBOSE:; logger.log(logging.DEBUG_VERBOSE, ""Computing evolution""); self.tslot_computer.recompute_evolution(); self.evo_current = True; return True; else:; return False. def _ensure_decomp_curr(self, k):; """"""; Checks to see if the diagonalisation has been completed since; the last update of the dynamics generators; (after the amplitude update); If not then the diagonlisation is completed; """"""; if self._decomp_curr is None:; raise errors.UsageError(""Decomp lists have not been created""); if not self._decomp_curr[k]:; self._spectral_decomp(k). def _spectral_decomp(self, k):; """"""; Calculate the diagonalization of the dynamics generator; generating lists of eigenvectors, propagators in the diagonalised; basis, and the 'factormatrix' used in calculating the propagator; gradient; Not implemented in this base class, because the method is specific; to the matrix type; """"""; raise errors.UsageError(""Decomposition cannot be completed by ""; ""this class. Try a(nother) subclass""). def",MatchSource.WIKI,docs/4.2/modules/qutip/control/dynamics.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/control/dynamics.html
https://qutip.org/docs/4.2/modules/qutip/control/dynamics.html:40469,Testability,log,logger,40469,"erty; def evo_t2targ(self):; _attrib_deprecation(; ""'evo_t2targ' has been replaced by '_onto_evo'""); return self._onto_evo. @property; def onto_evo(self):; """"""; List of evolution operators (Qobj) from the initial to the given; timeslot; """"""; if self._onto_evo is not None:; if self._onto_evo_qobj is None:; if self.oper_dtype == Qobj:; self._onto_evo_qobj = self._onto_evo; else:; self._onto_evo_qobj = []; for k in range(0, self.num_tslots):; self._onto_evo_qobj.append(Qobj(self._onto_evo[k],; dims=self.sys_dims)); self._onto_evo_qobj.append(self.onto_evo_target). return self._onto_evo_qobj. [docs] def compute_evolution(self):; """"""; Recalculate the time evolution operators; Dynamics generators (e.g. Hamiltonian) and; prop (propagators) are calculated as necessary; Actual work is completed by the recompute_evolution method; of the timeslot computer; """""". # Check if values are already current, otherwise calculate all values; if not self.evo_current:; if self.log_level <= logging.DEBUG_VERBOSE:; logger.log(logging.DEBUG_VERBOSE, ""Computing evolution""); self.tslot_computer.recompute_evolution(); self.evo_current = True; return True; else:; return False. def _ensure_decomp_curr(self, k):; """"""; Checks to see if the diagonalisation has been completed since; the last update of the dynamics generators; (after the amplitude update); If not then the diagonlisation is completed; """"""; if self._decomp_curr is None:; raise errors.UsageError(""Decomp lists have not been created""); if not self._decomp_curr[k]:; self._spectral_decomp(k). def _spectral_decomp(self, k):; """"""; Calculate the diagonalization of the dynamics generator; generating lists of eigenvectors, propagators in the diagonalised; basis, and the 'factormatrix' used in calculating the propagator; gradient; Not implemented in this base class, because the method is specific; to the matrix type; """"""; raise errors.UsageError(""Decomposition cannot be completed by ""; ""this class. Try a(nother) subclass""). def _is_unitary(self, A):",MatchSource.WIKI,docs/4.2/modules/qutip/control/dynamics.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/control/dynamics.html
https://qutip.org/docs/4.2/modules/qutip/control/dynamics.html:40476,Testability,log,log,40476,"rg(self):; _attrib_deprecation(; ""'evo_t2targ' has been replaced by '_onto_evo'""); return self._onto_evo. @property; def onto_evo(self):; """"""; List of evolution operators (Qobj) from the initial to the given; timeslot; """"""; if self._onto_evo is not None:; if self._onto_evo_qobj is None:; if self.oper_dtype == Qobj:; self._onto_evo_qobj = self._onto_evo; else:; self._onto_evo_qobj = []; for k in range(0, self.num_tslots):; self._onto_evo_qobj.append(Qobj(self._onto_evo[k],; dims=self.sys_dims)); self._onto_evo_qobj.append(self.onto_evo_target). return self._onto_evo_qobj. [docs] def compute_evolution(self):; """"""; Recalculate the time evolution operators; Dynamics generators (e.g. Hamiltonian) and; prop (propagators) are calculated as necessary; Actual work is completed by the recompute_evolution method; of the timeslot computer; """""". # Check if values are already current, otherwise calculate all values; if not self.evo_current:; if self.log_level <= logging.DEBUG_VERBOSE:; logger.log(logging.DEBUG_VERBOSE, ""Computing evolution""); self.tslot_computer.recompute_evolution(); self.evo_current = True; return True; else:; return False. def _ensure_decomp_curr(self, k):; """"""; Checks to see if the diagonalisation has been completed since; the last update of the dynamics generators; (after the amplitude update); If not then the diagonlisation is completed; """"""; if self._decomp_curr is None:; raise errors.UsageError(""Decomp lists have not been created""); if not self._decomp_curr[k]:; self._spectral_decomp(k). def _spectral_decomp(self, k):; """"""; Calculate the diagonalization of the dynamics generator; generating lists of eigenvectors, propagators in the diagonalised; basis, and the 'factormatrix' used in calculating the propagator; gradient; Not implemented in this base class, because the method is specific; to the matrix type; """"""; raise errors.UsageError(""Decomposition cannot be completed by ""; ""this class. Try a(nother) subclass""). def _is_unitary(self, A):; """"""; Checks whe",MatchSource.WIKI,docs/4.2/modules/qutip/control/dynamics.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/control/dynamics.html
https://qutip.org/docs/4.2/modules/qutip/control/dynamics.html:40480,Testability,log,logging,40480,"rg(self):; _attrib_deprecation(; ""'evo_t2targ' has been replaced by '_onto_evo'""); return self._onto_evo. @property; def onto_evo(self):; """"""; List of evolution operators (Qobj) from the initial to the given; timeslot; """"""; if self._onto_evo is not None:; if self._onto_evo_qobj is None:; if self.oper_dtype == Qobj:; self._onto_evo_qobj = self._onto_evo; else:; self._onto_evo_qobj = []; for k in range(0, self.num_tslots):; self._onto_evo_qobj.append(Qobj(self._onto_evo[k],; dims=self.sys_dims)); self._onto_evo_qobj.append(self.onto_evo_target). return self._onto_evo_qobj. [docs] def compute_evolution(self):; """"""; Recalculate the time evolution operators; Dynamics generators (e.g. Hamiltonian) and; prop (propagators) are calculated as necessary; Actual work is completed by the recompute_evolution method; of the timeslot computer; """""". # Check if values are already current, otherwise calculate all values; if not self.evo_current:; if self.log_level <= logging.DEBUG_VERBOSE:; logger.log(logging.DEBUG_VERBOSE, ""Computing evolution""); self.tslot_computer.recompute_evolution(); self.evo_current = True; return True; else:; return False. def _ensure_decomp_curr(self, k):; """"""; Checks to see if the diagonalisation has been completed since; the last update of the dynamics generators; (after the amplitude update); If not then the diagonlisation is completed; """"""; if self._decomp_curr is None:; raise errors.UsageError(""Decomp lists have not been created""); if not self._decomp_curr[k]:; self._spectral_decomp(k). def _spectral_decomp(self, k):; """"""; Calculate the diagonalization of the dynamics generator; generating lists of eigenvectors, propagators in the diagonalised; basis, and the 'factormatrix' used in calculating the propagator; gradient; Not implemented in this base class, because the method is specific; to the matrix type; """"""; raise errors.UsageError(""Decomposition cannot be completed by ""; ""this class. Try a(nother) subclass""). def _is_unitary(self, A):; """"""; Checks whe",MatchSource.WIKI,docs/4.2/modules/qutip/control/dynamics.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/control/dynamics.html
https://qutip.org/docs/4.2/modules/qutip/control/dynamics.html:42121,Testability,log,logger,42121,"f eigenvectors, propagators in the diagonalised; basis, and the 'factormatrix' used in calculating the propagator; gradient; Not implemented in this base class, because the method is specific; to the matrix type; """"""; raise errors.UsageError(""Decomposition cannot be completed by ""; ""this class. Try a(nother) subclass""). def _is_unitary(self, A):; """"""; Checks whether operator A is unitary; A can be either Qobj or ndarray; """"""; if isinstance(A, Qobj):; unitary = np.allclose(np.eye(A.shape[0]), A*A.dag().full(),; atol=self.unitarity_tol); else:; unitary = np.allclose(np.eye(len(A)), A.dot(A.T.conj()),; atol=self.unitarity_tol). return unitary. def _calc_unitary_err(self, A):; if isinstance(A, Qobj):; err = np.sum(abs(np.eye(A.shape[0]) - A*A.dag().full())); else:; err = np.sum(abs(np.eye(len(A)) - A.dot(A.T.conj()))). return err. [docs] def unitarity_check(self):; """"""; Checks whether all propagators are unitary; """"""; for k in range(self.num_tslots):; if not self._is_unitary(self._prop[k]):; logger.warning(; ""Progator of timeslot {} is not unitary"".format(k)). [docs]class DynamicsGenMat(Dynamics):; """"""; This sub class can be used for any system where no additional; operator is applied to the dynamics generator before calculating; the propagator, e.g. classical dynamics, Lindbladian; """"""; def reset(self):; Dynamics.reset(self); self.id_text = 'GEN_MAT'; self.apply_params(). [docs]class DynamicsUnitary(Dynamics):; """"""; This is the subclass to use for systems with dynamics described by; unitary matrices. E.g. closed systems with Hermitian Hamiltonians; Note a matrix diagonalisation is used to compute the exponent; The eigen decomposition is also used to calculate the propagator gradient.; The method is taken from DYNAMO (see file header). Attributes; ----------; drift_ham : Qobj; This is the drift Hamiltonian for unitary dynamics; It is mapped to drift_dyn_gen during initialize_controls. ctrl_ham : List of Qobj; These are the control Hamiltonians for unitary dynamics; It is",MatchSource.WIKI,docs/4.2/modules/qutip/control/dynamics.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/control/dynamics.html
https://qutip.org/docs/4.2/modules/qutip/control/dynamics.html:48701,Testability,log,logger,48701,"t None:; self._dyn_gen_eigenvectors_adj[k] = \; self._dyn_gen_eigenvectors[k].dag(); else:; self._prop_eigen[k] = np.diagflat(prop_eig); self._dyn_gen_eigenvectors[k] = eig_vec; # The _dyn_gen_eigenvectors_adj list is not used in; # memory optimised modes; if self._dyn_gen_eigenvectors_adj is not None:; self._dyn_gen_eigenvectors_adj[k] = \; self._dyn_gen_eigenvectors[k].conj().T. def _get_dyn_gen_eigenvectors_adj(self, k):; # The _dyn_gen_eigenvectors_adj list is not used in; # memory optimised modes; if self._dyn_gen_eigenvectors_adj is not None:; return self._dyn_gen_eigenvectors_adj[k]; else:; if self.oper_dtype == Qobj:; return self._dyn_gen_eigenvectors[k].dag(); else:; return self._dyn_gen_eigenvectors[k].conj().T. [docs] def check_unitarity(self):; """"""; Checks whether all propagators are unitary; For propagators found not to be unitary, the potential underlying; causes are investigated.; """"""; for k in range(self.num_tslots):; prop_unit = self._is_unitary(self._prop[k]); if not prop_unit:; logger.warning(; ""Progator of timeslot {} is not unitary"".format(k)); if not prop_unit or self.unitarity_check_level > 1:; # Check Hamiltonian; H = self._dyn_gen[k]; if isinstance(H, Qobj):; herm = H.isherm; else:; diff = np.abs(H.T.conj() - H); herm = False if np.any(diff > settings.atol) else True; eigval_unit = self._is_unitary(self._prop_eigen[k]); eigvec_unit = self._is_unitary(self._dyn_gen_eigenvectors[k]); if self._dyn_gen_eigenvectors_adj is not None:; eigvecadj_unit = self._is_unitary(; self._dyn_gen_eigenvectors_adj[k]); else:; eigvecadj_unit = None; msg = (""prop unit: {}; H herm: {}; ""; ""eigval unit: {}; eigvec unit: {}; ""; ""eigvecadj_unit: {}"".format(; prop_unit, herm, eigval_unit, eigvec_unit,; eigvecadj_unit)); logger.info(msg). [docs]class DynamicsSymplectic(Dynamics):; """"""; Symplectic systems; This is the subclass to use for systems where the dynamics is described; by symplectic matrices, e.g. coupled oscillators, quantum optics. Attributes; ----------; omeg",MatchSource.WIKI,docs/4.2/modules/qutip/control/dynamics.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/control/dynamics.html
https://qutip.org/docs/4.2/modules/qutip/control/dynamics.html:49437,Testability,log,logger,49437,"rs[k].conj().T. [docs] def check_unitarity(self):; """"""; Checks whether all propagators are unitary; For propagators found not to be unitary, the potential underlying; causes are investigated.; """"""; for k in range(self.num_tslots):; prop_unit = self._is_unitary(self._prop[k]); if not prop_unit:; logger.warning(; ""Progator of timeslot {} is not unitary"".format(k)); if not prop_unit or self.unitarity_check_level > 1:; # Check Hamiltonian; H = self._dyn_gen[k]; if isinstance(H, Qobj):; herm = H.isherm; else:; diff = np.abs(H.T.conj() - H); herm = False if np.any(diff > settings.atol) else True; eigval_unit = self._is_unitary(self._prop_eigen[k]); eigvec_unit = self._is_unitary(self._dyn_gen_eigenvectors[k]); if self._dyn_gen_eigenvectors_adj is not None:; eigvecadj_unit = self._is_unitary(; self._dyn_gen_eigenvectors_adj[k]); else:; eigvecadj_unit = None; msg = (""prop unit: {}; H herm: {}; ""; ""eigval unit: {}; eigvec unit: {}; ""; ""eigvecadj_unit: {}"".format(; prop_unit, herm, eigval_unit, eigvec_unit,; eigvecadj_unit)); logger.info(msg). [docs]class DynamicsSymplectic(Dynamics):; """"""; Symplectic systems; This is the subclass to use for systems where the dynamics is described; by symplectic matrices, e.g. coupled oscillators, quantum optics. Attributes; ----------; omega : array[drift_dyn_gen.shape]; matrix used in the calculation of propagators (time evolution); with symplectic systems.; ; """""". def reset(self):; Dynamics.reset(self); self.id_text = 'SYMPL'; self._omega = None; self._omega_qobj = None; self.grad_exact = True; self.apply_params(). def _create_computers(self):; """"""; Create the default timeslot, fidelity and propagator computers; """"""; # The time slot computer. By default it is set to _UpdateAll; # can be set to _DynUpdate in the configuration; # (see class file for details); if self.config.tslot_type == 'DYNAMIC':; self.tslot_computer = tslotcomp.TSlotCompDynUpdate(self); else:; self.tslot_computer = tslotcomp.TSlotCompUpdateAll(self). self.prop_computer = ",MatchSource.WIKI,docs/4.2/modules/qutip/control/dynamics.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/control/dynamics.html
https://qutip.org/docs/4.2/modules/qutip/control/dynamics.html:5037,Usability,simpl,simplefilter,5037,"ls[0], (list, tuple)):; ctrls = np.array(ctrls); except:; pass; ; if isinstance(ctrls, np.ndarray):; if len(ctrls.shape) != 2:; raise TypeError(""Incorrect shape for ctrl dyn gen array""); for k in range(ctrls.shape[0]):; for j in range(ctrls.shape[1]):; if not isinstance(ctrls[k, j], Qobj):; raise TypeError(""All control dyn gen must be Qobj""); elif isinstance(ctrls, (list, tuple)):; for ctrl in ctrls:; if not isinstance(ctrl, Qobj):; raise TypeError(""All control dyn gen must be Qobj"") ; else:; raise TypeError(""Controls list or array not set correctly""); ; return ctrls; ; def _check_drift_dyn_gen(drift):; if not isinstance(drift, Qobj):; if not isinstance(drift, (list, tuple)):; raise TypeError(""drift should be a Qobj or a list of Qobj""); else:; for d in drift:; if not isinstance(d, Qobj):; raise TypeError(; ""drift should be a Qobj or a list of Qobj""). warnings.simplefilter('always', DeprecationWarning) #turn off filter; def _attrib_deprecation(message, stacklevel=3):; """"""; Issue deprecation warning; Using stacklevel=3 will ensure message refers the function; calling with the deprecated parameter,; """"""; warnings.warn(message, DeprecationWarning, stacklevel=stacklevel). def _func_deprecation(message, stacklevel=3):; """"""; Issue deprecation warning; Using stacklevel=3 will ensure message refers the function; calling with the deprecated parameter,; """"""; warnings.warn(message, DeprecationWarning, stacklevel=stacklevel). [docs]class Dynamics(object):; """"""; This is a base class only. See subclass descriptions and choose an; appropriate one for the application. Note that initialize_controls must be called before most of the methods; can be used. init_timeslots can be called sometimes earlier in order; to access timeslot related attributes. This acts as a container for the operators that are used to calculate; time evolution of the system under study. That is the dynamics generators; (Hamiltonians, Lindbladians etc), the propagators from one timeslot to; the next, and the evol",MatchSource.WIKI,docs/4.2/modules/qutip/control/dynamics.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/control/dynamics.html
https://qutip.org/docs/4.2/modules/qutip/control/dynamics.html:16435,Usability,clear,clear,16435,"; self._prop_qobj = None; self._prop_grad_qobj = None; self._fwd_evo_qobj = None; self._onwd_evo_qobj = None; self._onto_evo_qobj = None; # Atrributes used in diagonalisation; # again in internal operator data type (see above); self._decomp_curr = None; self._prop_eigen = None; self._dyn_gen_eigenvectors = None; self._dyn_gen_eigenvectors_adj = None; self._dyn_gen_factormatrix = None; self.fact_mat_round_prec = 1e-10. # Debug and information attribs; self.stats = None; self.id_text = 'DYN_BASE'; self.def_amps_fname = ""ctrl_amps.txt""; self.log_level = self.config.log_level; # Internal flags; self._dyn_gen_mapped = False; self._timeslots_initialized = False; self._ctrls_initialized = False; self._ctrl_dyn_gen_checked = False; self._drift_dyn_gen_checked = False; # Unitary checking; self.unitarity_check_level = 0; self.unitarity_tol = 1e-10; # Data dumping; self.dump = None; self.dump_to_file = False. self.apply_params(). # Create the computing objects; self._create_computers(). self.clear(). [docs] def apply_params(self, params=None):; """"""; Set object attributes based on the dictionary (if any) passed in the; instantiation, or passed as a parameter; This is called during the instantiation automatically.; The key value pairs are the attribute name and value; Note: attributes are created if they do not exist already,; and are overwritten if they do.; """"""; if not params:; params = self.params. if isinstance(params, dict):; self.params = params; for key in params:; setattr(self, key, params[key]). @property; def log_level(self):; return logger.level. @log_level.setter; def log_level(self, lvl):; """"""; Set the log_level attribute and set the level of the logger; that is call logger.setLevel(lvl); """"""; logger.setLevel(lvl). @property; def dumping(self):; """"""; The level of data dumping that will occur during the time evolution; calculation.; - NONE : No processing data dumped (Default); - SUMMARY : A summary of each time evolution will be recorded; - FULL : All operators used",MatchSource.WIKI,docs/4.2/modules/qutip/control/dynamics.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/control/dynamics.html
https://qutip.org/docs/4.2/modules/qutip/control/dynamics.html:18869,Usability,clear,clear,18869,"ring(value):; raise TypeError(""Value must be string value""); lvl = value.upper(); if lvl == 'NONE':; self.dump = None; else:; if not isinstance(self.dump, qtrldump.DynamicsDump):; self.dump = qtrldump.DynamicsDump(self, level=lvl); else:; self.dump.level = lvl. @property; def dump_dir(self):; if self.dump:; return self.dump.dump_dir; else:; return None. @dump_dir.setter; def dump_dir(self, value):; if not self.dump:; self.dumping = 'SUMMARY'; self.dump.dump_dir = value. def _create_computers(self):; """"""; Create the default timeslot, fidelity and propagator computers; """"""; # The time slot computer. By default it is set to UpdateAll; # can be set to DynUpdate in the configuration; # (see class file for details); if self.config.tslot_type == 'DYNAMIC':; self.tslot_computer = tslotcomp.TSlotCompDynUpdate(self); else:; self.tslot_computer = tslotcomp.TSlotCompUpdateAll(self). self.prop_computer = propcomp.PropCompFrechet(self); self.fid_computer = fidcomp.FidCompTraceDiff(self). def clear(self):; self.ctrl_amps = None; self.evo_current = False; if self.fid_computer is not None:; self.fid_computer.clear(). @property; def num_tslots(self):; if not self._timeslots_initialized:; self.init_timeslots(); return self._num_tslots. @num_tslots.setter; def num_tslots(self, value):; self._num_tslots = value; if self._timeslots_initialized:; self._tau = None; self.init_timeslots(). @property; def evo_time(self):; if not self._timeslots_initialized:; self.init_timeslots(); return self._evo_time. @evo_time.setter; def evo_time(self, value):; self._evo_time = value; if self._timeslots_initialized:; self._tau = None; self.init_timeslots(). @property; def tau(self):; if not self._timeslots_initialized:; self.init_timeslots(); return self._tau. @tau.setter; def tau(self, value):; self._tau = value; self.init_timeslots(). [docs] def init_timeslots(self):; """"""; Generate the timeslot duration array 'tau' based on the evo_time; and num_tslots attributes, unless the tau attribute is already set",MatchSource.WIKI,docs/4.2/modules/qutip/control/dynamics.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/control/dynamics.html
https://qutip.org/docs/4.2/modules/qutip/control/dynamics.html:18985,Usability,clear,clear,18985,"None; else:; if not isinstance(self.dump, qtrldump.DynamicsDump):; self.dump = qtrldump.DynamicsDump(self, level=lvl); else:; self.dump.level = lvl. @property; def dump_dir(self):; if self.dump:; return self.dump.dump_dir; else:; return None. @dump_dir.setter; def dump_dir(self, value):; if not self.dump:; self.dumping = 'SUMMARY'; self.dump.dump_dir = value. def _create_computers(self):; """"""; Create the default timeslot, fidelity and propagator computers; """"""; # The time slot computer. By default it is set to UpdateAll; # can be set to DynUpdate in the configuration; # (see class file for details); if self.config.tslot_type == 'DYNAMIC':; self.tslot_computer = tslotcomp.TSlotCompDynUpdate(self); else:; self.tslot_computer = tslotcomp.TSlotCompUpdateAll(self). self.prop_computer = propcomp.PropCompFrechet(self); self.fid_computer = fidcomp.FidCompTraceDiff(self). def clear(self):; self.ctrl_amps = None; self.evo_current = False; if self.fid_computer is not None:; self.fid_computer.clear(). @property; def num_tslots(self):; if not self._timeslots_initialized:; self.init_timeslots(); return self._num_tslots. @num_tslots.setter; def num_tslots(self, value):; self._num_tslots = value; if self._timeslots_initialized:; self._tau = None; self.init_timeslots(). @property; def evo_time(self):; if not self._timeslots_initialized:; self.init_timeslots(); return self._evo_time. @evo_time.setter; def evo_time(self, value):; self._evo_time = value; if self._timeslots_initialized:; self._tau = None; self.init_timeslots(). @property; def tau(self):; if not self._timeslots_initialized:; self.init_timeslots(); return self._tau. @tau.setter; def tau(self, value):; self._tau = value; self.init_timeslots(). [docs] def init_timeslots(self):; """"""; Generate the timeslot duration array 'tau' based on the evo_time; and num_tslots attributes, unless the tau attribute is already set; in which case this step in ignored; Generate the cumulative time array 'time' based on the tau values; """"""; # s",MatchSource.WIKI,docs/4.2/modules/qutip/control/dynamics.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/control/dynamics.html
https://qutip.org/docs/4.2/modules/qutip/control/fidcomp.html:2316,Availability,error,error,2316," NOT; # LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A; # PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT; # HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,; # SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT; # LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,; # DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY; # THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT; # (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE; # OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.; ###############################################################################. # @author: Alexander Pitchford; # @email1: agp1@aber.ac.uk; # @email2: alex.pitchford@gmail.com; # @organization: Aberystwyth University; # @supervisor: Daniel Burgarth. """"""; Fidelity Computer. These classes calculate the fidelity error - function to be minimised; and fidelity error gradient, which is used to direct the optimisation. They may calculate the fidelity as an intermediary step, as in some case; e.g. unitary dynamics, this is more efficient. The idea is that different methods for computing the fidelity can be tried; and compared using simple configuration switches. Note the methods in these classes were inspired by:; DYNAMO - Dynamic Framework for Quantum Optimal Control; See Machnes et.al., arXiv.1011.4874; The unitary dynamics fidelity is taken directly frm DYNAMO; The other fidelity measures are extensions, and the sources are given; in the class descriptions.; """""". import os; import warnings; import numpy as np; import scipy.sparse as sp; # import scipy.linalg as la; import timeit; # QuTiP; from qutip import Qobj; # QuTiP logging; import qutip.logging_utils as logging; logger = logging.get_logger(); # QuTiP control modules; import qutip.control.errors as errors. warnings.simplefilter('always', DeprecationWarning) #turn off filter",MatchSource.WIKI,docs/4.2/modules/qutip/control/fidcomp.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/control/fidcomp.html
https://qutip.org/docs/4.2/modules/qutip/control/fidcomp.html:2363,Availability,error,error,2363," NOT; # LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A; # PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT; # HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,; # SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT; # LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,; # DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY; # THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT; # (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE; # OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.; ###############################################################################. # @author: Alexander Pitchford; # @email1: agp1@aber.ac.uk; # @email2: alex.pitchford@gmail.com; # @organization: Aberystwyth University; # @supervisor: Daniel Burgarth. """"""; Fidelity Computer. These classes calculate the fidelity error - function to be minimised; and fidelity error gradient, which is used to direct the optimisation. They may calculate the fidelity as an intermediary step, as in some case; e.g. unitary dynamics, this is more efficient. The idea is that different methods for computing the fidelity can be tried; and compared using simple configuration switches. Note the methods in these classes were inspired by:; DYNAMO - Dynamic Framework for Quantum Optimal Control; See Machnes et.al., arXiv.1011.4874; The unitary dynamics fidelity is taken directly frm DYNAMO; The other fidelity measures are extensions, and the sources are given; in the class descriptions.; """""". import os; import warnings; import numpy as np; import scipy.sparse as sp; # import scipy.linalg as la; import timeit; # QuTiP; from qutip import Qobj; # QuTiP logging; import qutip.logging_utils as logging; logger = logging.get_logger(); # QuTiP control modules; import qutip.control.errors as errors. warnings.simplefilter('always', DeprecationWarning) #turn off filter",MatchSource.WIKI,docs/4.2/modules/qutip/control/fidcomp.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/control/fidcomp.html
https://qutip.org/docs/4.2/modules/qutip/control/fidcomp.html:3263,Availability,error,errors,3263,"mputer. These classes calculate the fidelity error - function to be minimised; and fidelity error gradient, which is used to direct the optimisation. They may calculate the fidelity as an intermediary step, as in some case; e.g. unitary dynamics, this is more efficient. The idea is that different methods for computing the fidelity can be tried; and compared using simple configuration switches. Note the methods in these classes were inspired by:; DYNAMO - Dynamic Framework for Quantum Optimal Control; See Machnes et.al., arXiv.1011.4874; The unitary dynamics fidelity is taken directly frm DYNAMO; The other fidelity measures are extensions, and the sources are given; in the class descriptions.; """""". import os; import warnings; import numpy as np; import scipy.sparse as sp; # import scipy.linalg as la; import timeit; # QuTiP; from qutip import Qobj; # QuTiP logging; import qutip.logging_utils as logging; logger = logging.get_logger(); # QuTiP control modules; import qutip.control.errors as errors. warnings.simplefilter('always', DeprecationWarning) #turn off filter; def _attrib_deprecation(message, stacklevel=3):; """"""; Issue deprecation warning; Using stacklevel=3 will ensure message refers the function; calling with the deprecated parameter,; """"""; warnings.warn(message, DeprecationWarning, stacklevel=stacklevel). def _func_deprecation(message, stacklevel=3):; """"""; Issue deprecation warning; Using stacklevel=3 will ensure message refers the function; calling with the deprecated parameter,; """"""; warnings.warn(message, DeprecationWarning, stacklevel=stacklevel); ; def _trace(A):; """"""wrapper for calculating the trace""""""; # input is an operator (Qobj, array, sparse etc), so; if isinstance(A, Qobj):; return A.tr(); elif isinstance(A, np.ndarray):; return np.trace(A); else:; #Assume A some sparse matrix; return np.sum(A.diagonal()). [docs]class FidelityComputer(object):; """"""; Base class for all Fidelity Computers.; This cannot be used directly. See subclass descriptions and c",MatchSource.WIKI,docs/4.2/modules/qutip/control/fidcomp.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/control/fidcomp.html
https://qutip.org/docs/4.2/modules/qutip/control/fidcomp.html:3273,Availability,error,errors,3273,"mputer. These classes calculate the fidelity error - function to be minimised; and fidelity error gradient, which is used to direct the optimisation. They may calculate the fidelity as an intermediary step, as in some case; e.g. unitary dynamics, this is more efficient. The idea is that different methods for computing the fidelity can be tried; and compared using simple configuration switches. Note the methods in these classes were inspired by:; DYNAMO - Dynamic Framework for Quantum Optimal Control; See Machnes et.al., arXiv.1011.4874; The unitary dynamics fidelity is taken directly frm DYNAMO; The other fidelity measures are extensions, and the sources are given; in the class descriptions.; """""". import os; import warnings; import numpy as np; import scipy.sparse as sp; # import scipy.linalg as la; import timeit; # QuTiP; from qutip import Qobj; # QuTiP logging; import qutip.logging_utils as logging; logger = logging.get_logger(); # QuTiP control modules; import qutip.control.errors as errors. warnings.simplefilter('always', DeprecationWarning) #turn off filter; def _attrib_deprecation(message, stacklevel=3):; """"""; Issue deprecation warning; Using stacklevel=3 will ensure message refers the function; calling with the deprecated parameter,; """"""; warnings.warn(message, DeprecationWarning, stacklevel=stacklevel). def _func_deprecation(message, stacklevel=3):; """"""; Issue deprecation warning; Using stacklevel=3 will ensure message refers the function; calling with the deprecated parameter,; """"""; warnings.warn(message, DeprecationWarning, stacklevel=stacklevel); ; def _trace(A):; """"""wrapper for calculating the trace""""""; # input is an operator (Qobj, array, sparse etc), so; if isinstance(A, Qobj):; return A.tr(); elif isinstance(A, np.ndarray):; return np.trace(A); else:; #Assume A some sparse matrix; return np.sum(A.diagonal()). [docs]class FidelityComputer(object):; """"""; Base class for all Fidelity Computers.; This cannot be used directly. See subclass descriptions and c",MatchSource.WIKI,docs/4.2/modules/qutip/control/fidcomp.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/control/fidcomp.html
https://qutip.org/docs/4.2/modules/qutip/control/fidcomp.html:5478,Availability,error,error,5478,"-----; log_level : integer; level of messaging output from the logger.; Options are attributes of qutip.logging_utils,; in decreasing levels of messaging, are:; DEBUG_INTENSE, DEBUG_VERBOSE, DEBUG, INFO, WARN, ERROR, CRITICAL; Anything WARN or above is effectively 'quiet' execution,; assuming everything runs as expected.; The default NOTSET implies that the level will be taken from; the QuTiP settings file, which by default is WARN. dimensional_norm : float; Normalisation constant. fid_norm_func : function; Used to normalise the fidelity; See SU and PSU options for the unitary dynamics. grad_norm_func : function; Used to normalise the fidelity gradient; See SU and PSU options for the unitary dynamics. uses_onwd_evo : boolean; flag to specify whether the onwd_evo evolution operator; (see Dynamics) is used by the FidelityComputer. uses_onto_evo : boolean; flag to specify whether the onto_evo evolution operator; (see Dynamics) is used by the FidelityComputer. fid_err : float; Last computed value of the fidelity error. fidelity : float; Last computed value of the normalised fidelity. fidelity_current : boolean; flag to specify whether the fidelity / fid_err are based on the; current amplitude values. Set False when amplitudes change. fid_err_grad: array[num_tslot, num_ctrls] of float; Last computed values for the fidelity error gradients wrt the; control in the timeslot. grad_norm : float; Last computed value for the norm of the fidelity error gradients; (sqrt of the sum of the squares). fid_err_grad_current : boolean; flag to specify whether the fidelity / fid_err are based on the; current amplitude values. Set False when amplitudes change; """"""; def __init__(self, dynamics, params=None):; self.parent = dynamics; self.params = params; self.reset(). [docs] def reset(self):; """"""; reset any configuration data and; clear any temporarily held status data; """"""; self.log_level = self.parent.log_level; self.id_text = 'FID_COMP_BASE'; self.dimensional_norm = 1.0; self.fid_norm_f",MatchSource.WIKI,docs/4.2/modules/qutip/control/fidcomp.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/control/fidcomp.html
https://qutip.org/docs/4.2/modules/qutip/control/fidcomp.html:5794,Availability,error,error,5794,"ed.; The default NOTSET implies that the level will be taken from; the QuTiP settings file, which by default is WARN. dimensional_norm : float; Normalisation constant. fid_norm_func : function; Used to normalise the fidelity; See SU and PSU options for the unitary dynamics. grad_norm_func : function; Used to normalise the fidelity gradient; See SU and PSU options for the unitary dynamics. uses_onwd_evo : boolean; flag to specify whether the onwd_evo evolution operator; (see Dynamics) is used by the FidelityComputer. uses_onto_evo : boolean; flag to specify whether the onto_evo evolution operator; (see Dynamics) is used by the FidelityComputer. fid_err : float; Last computed value of the fidelity error. fidelity : float; Last computed value of the normalised fidelity. fidelity_current : boolean; flag to specify whether the fidelity / fid_err are based on the; current amplitude values. Set False when amplitudes change. fid_err_grad: array[num_tslot, num_ctrls] of float; Last computed values for the fidelity error gradients wrt the; control in the timeslot. grad_norm : float; Last computed value for the norm of the fidelity error gradients; (sqrt of the sum of the squares). fid_err_grad_current : boolean; flag to specify whether the fidelity / fid_err are based on the; current amplitude values. Set False when amplitudes change; """"""; def __init__(self, dynamics, params=None):; self.parent = dynamics; self.params = params; self.reset(). [docs] def reset(self):; """"""; reset any configuration data and; clear any temporarily held status data; """"""; self.log_level = self.parent.log_level; self.id_text = 'FID_COMP_BASE'; self.dimensional_norm = 1.0; self.fid_norm_func = None; self.grad_norm_func = None; self.uses_onwd_evo = False; self.uses_onto_evo = False; self.apply_params(); self.clear(). [docs] def clear(self):; """"""; clear any temporarily held status data; """"""; self.fid_err = None; self.fidelity = None; self.fid_err_grad = None; self.grad_norm = np.inf; self.fidelity_curre",MatchSource.WIKI,docs/4.2/modules/qutip/control/fidcomp.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/control/fidcomp.html
https://qutip.org/docs/4.2/modules/qutip/control/fidcomp.html:5912,Availability,error,error,5912,"_norm : float; Normalisation constant. fid_norm_func : function; Used to normalise the fidelity; See SU and PSU options for the unitary dynamics. grad_norm_func : function; Used to normalise the fidelity gradient; See SU and PSU options for the unitary dynamics. uses_onwd_evo : boolean; flag to specify whether the onwd_evo evolution operator; (see Dynamics) is used by the FidelityComputer. uses_onto_evo : boolean; flag to specify whether the onto_evo evolution operator; (see Dynamics) is used by the FidelityComputer. fid_err : float; Last computed value of the fidelity error. fidelity : float; Last computed value of the normalised fidelity. fidelity_current : boolean; flag to specify whether the fidelity / fid_err are based on the; current amplitude values. Set False when amplitudes change. fid_err_grad: array[num_tslot, num_ctrls] of float; Last computed values for the fidelity error gradients wrt the; control in the timeslot. grad_norm : float; Last computed value for the norm of the fidelity error gradients; (sqrt of the sum of the squares). fid_err_grad_current : boolean; flag to specify whether the fidelity / fid_err are based on the; current amplitude values. Set False when amplitudes change; """"""; def __init__(self, dynamics, params=None):; self.parent = dynamics; self.params = params; self.reset(). [docs] def reset(self):; """"""; reset any configuration data and; clear any temporarily held status data; """"""; self.log_level = self.parent.log_level; self.id_text = 'FID_COMP_BASE'; self.dimensional_norm = 1.0; self.fid_norm_func = None; self.grad_norm_func = None; self.uses_onwd_evo = False; self.uses_onto_evo = False; self.apply_params(); self.clear(). [docs] def clear(self):; """"""; clear any temporarily held status data; """"""; self.fid_err = None; self.fidelity = None; self.fid_err_grad = None; self.grad_norm = np.inf; self.fidelity_current = False; self.fid_err_grad_current = False; self.grad_norm = 0.0. [docs] def apply_params(self, params=None):; """"""; Set object ",MatchSource.WIKI,docs/4.2/modules/qutip/control/fidcomp.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/control/fidcomp.html
https://qutip.org/docs/4.2/modules/qutip/control/fidcomp.html:7887,Availability,error,errors,7887,"lse; self.grad_norm = 0.0. [docs] def apply_params(self, params=None):; """"""; Set object attributes based on the dictionary (if any) passed in the; instantiation, or passed as a parameter; This is called during the instantiation automatically.; The key value pairs are the attribute name and value; Note: attributes are created if they do not exist already,; and are overwritten if they do.; """"""; if not params:; params = self.params. if isinstance(params, dict):; self.params = params; for key in params:; setattr(self, key, params[key]). @property; def log_level(self):; return logger.level ; ; @log_level.setter; def log_level(self, lvl):; """"""; Set the log_level attribute and set the level of the logger; that is call logger.setLevel(lvl); """"""; logger.setLevel(lvl). [docs] def init_comp(self):; """"""; initialises the computer based on the configuration of the Dynamics; """"""; # optionally implemented in subclass; pass. [docs] def get_fid_err(self):; """"""; returns the absolute distance from the maximum achievable fidelity; """"""; # must be implemented by subclass; raise errors.UsageError(; ""No method defined for getting fidelity error.""; "" Suspect base class was used where sub class should have been""). [docs] def get_fid_err_gradient(self):; """"""; Returns the normalised gradient of the fidelity error; in a (nTimeslots x n_ctrls) array wrt the timeslot control amplitude; """"""; # must be implemented by subclass; raise errors.UsageError(""No method defined for getting fidelity""; "" error gradient. Suspect base class was""; "" used where sub class should have been""). [docs] def flag_system_changed(self):; """"""; Flag fidelity and gradients as needing recalculation; """"""; self.fidelity_current = False; # Flag gradient as needing recalculating; self.fid_err_grad_current = False. @property; def uses_evo_t2end(self):; _attrib_deprecation(; ""'uses_evo_t2end' has been replaced by 'uses_onwd_evo'""); return self.uses_onwd_evo. @uses_evo_t2end.setter; def uses_evo_t2end(self, value):; _attrib_deprecati",MatchSource.WIKI,docs/4.2/modules/qutip/control/fidcomp.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/control/fidcomp.html
https://qutip.org/docs/4.2/modules/qutip/control/fidcomp.html:7947,Availability,error,error,7947,"the dictionary (if any) passed in the; instantiation, or passed as a parameter; This is called during the instantiation automatically.; The key value pairs are the attribute name and value; Note: attributes are created if they do not exist already,; and are overwritten if they do.; """"""; if not params:; params = self.params. if isinstance(params, dict):; self.params = params; for key in params:; setattr(self, key, params[key]). @property; def log_level(self):; return logger.level ; ; @log_level.setter; def log_level(self, lvl):; """"""; Set the log_level attribute and set the level of the logger; that is call logger.setLevel(lvl); """"""; logger.setLevel(lvl). [docs] def init_comp(self):; """"""; initialises the computer based on the configuration of the Dynamics; """"""; # optionally implemented in subclass; pass. [docs] def get_fid_err(self):; """"""; returns the absolute distance from the maximum achievable fidelity; """"""; # must be implemented by subclass; raise errors.UsageError(; ""No method defined for getting fidelity error.""; "" Suspect base class was used where sub class should have been""). [docs] def get_fid_err_gradient(self):; """"""; Returns the normalised gradient of the fidelity error; in a (nTimeslots x n_ctrls) array wrt the timeslot control amplitude; """"""; # must be implemented by subclass; raise errors.UsageError(""No method defined for getting fidelity""; "" error gradient. Suspect base class was""; "" used where sub class should have been""). [docs] def flag_system_changed(self):; """"""; Flag fidelity and gradients as needing recalculation; """"""; self.fidelity_current = False; # Flag gradient as needing recalculating; self.fid_err_grad_current = False. @property; def uses_evo_t2end(self):; _attrib_deprecation(; ""'uses_evo_t2end' has been replaced by 'uses_onwd_evo'""); return self.uses_onwd_evo. @uses_evo_t2end.setter; def uses_evo_t2end(self, value):; _attrib_deprecation(; ""'uses_evo_t2end' has been replaced by 'uses_onwd_evo'""); self.uses_onwd_evo = value. @property; def use",MatchSource.WIKI,docs/4.2/modules/qutip/control/fidcomp.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/control/fidcomp.html
https://qutip.org/docs/4.2/modules/qutip/control/fidcomp.html:8115,Availability,error,error,8115," created if they do not exist already,; and are overwritten if they do.; """"""; if not params:; params = self.params. if isinstance(params, dict):; self.params = params; for key in params:; setattr(self, key, params[key]). @property; def log_level(self):; return logger.level ; ; @log_level.setter; def log_level(self, lvl):; """"""; Set the log_level attribute and set the level of the logger; that is call logger.setLevel(lvl); """"""; logger.setLevel(lvl). [docs] def init_comp(self):; """"""; initialises the computer based on the configuration of the Dynamics; """"""; # optionally implemented in subclass; pass. [docs] def get_fid_err(self):; """"""; returns the absolute distance from the maximum achievable fidelity; """"""; # must be implemented by subclass; raise errors.UsageError(; ""No method defined for getting fidelity error.""; "" Suspect base class was used where sub class should have been""). [docs] def get_fid_err_gradient(self):; """"""; Returns the normalised gradient of the fidelity error; in a (nTimeslots x n_ctrls) array wrt the timeslot control amplitude; """"""; # must be implemented by subclass; raise errors.UsageError(""No method defined for getting fidelity""; "" error gradient. Suspect base class was""; "" used where sub class should have been""). [docs] def flag_system_changed(self):; """"""; Flag fidelity and gradients as needing recalculation; """"""; self.fidelity_current = False; # Flag gradient as needing recalculating; self.fid_err_grad_current = False. @property; def uses_evo_t2end(self):; _attrib_deprecation(; ""'uses_evo_t2end' has been replaced by 'uses_onwd_evo'""); return self.uses_onwd_evo. @uses_evo_t2end.setter; def uses_evo_t2end(self, value):; _attrib_deprecation(; ""'uses_evo_t2end' has been replaced by 'uses_onwd_evo'""); self.uses_onwd_evo = value. @property; def uses_evo_t2targ(self):; _attrib_deprecation(; ""'uses_evo_t2targ' has been replaced by 'uses_onto_evo'""); return self.uses_onto_evo. @uses_evo_t2targ.setter; def uses_evo_t2targ(self, value):; _attrib_deprecation(",MatchSource.WIKI,docs/4.2/modules/qutip/control/fidcomp.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/control/fidcomp.html
https://qutip.org/docs/4.2/modules/qutip/control/fidcomp.html:8238,Availability,error,errors,8238," created if they do not exist already,; and are overwritten if they do.; """"""; if not params:; params = self.params. if isinstance(params, dict):; self.params = params; for key in params:; setattr(self, key, params[key]). @property; def log_level(self):; return logger.level ; ; @log_level.setter; def log_level(self, lvl):; """"""; Set the log_level attribute and set the level of the logger; that is call logger.setLevel(lvl); """"""; logger.setLevel(lvl). [docs] def init_comp(self):; """"""; initialises the computer based on the configuration of the Dynamics; """"""; # optionally implemented in subclass; pass. [docs] def get_fid_err(self):; """"""; returns the absolute distance from the maximum achievable fidelity; """"""; # must be implemented by subclass; raise errors.UsageError(; ""No method defined for getting fidelity error.""; "" Suspect base class was used where sub class should have been""). [docs] def get_fid_err_gradient(self):; """"""; Returns the normalised gradient of the fidelity error; in a (nTimeslots x n_ctrls) array wrt the timeslot control amplitude; """"""; # must be implemented by subclass; raise errors.UsageError(""No method defined for getting fidelity""; "" error gradient. Suspect base class was""; "" used where sub class should have been""). [docs] def flag_system_changed(self):; """"""; Flag fidelity and gradients as needing recalculation; """"""; self.fidelity_current = False; # Flag gradient as needing recalculating; self.fid_err_grad_current = False. @property; def uses_evo_t2end(self):; _attrib_deprecation(; ""'uses_evo_t2end' has been replaced by 'uses_onwd_evo'""); return self.uses_onwd_evo. @uses_evo_t2end.setter; def uses_evo_t2end(self, value):; _attrib_deprecation(; ""'uses_evo_t2end' has been replaced by 'uses_onwd_evo'""); self.uses_onwd_evo = value. @property; def uses_evo_t2targ(self):; _attrib_deprecation(; ""'uses_evo_t2targ' has been replaced by 'uses_onto_evo'""); return self.uses_onto_evo. @uses_evo_t2targ.setter; def uses_evo_t2targ(self, value):; _attrib_deprecation(",MatchSource.WIKI,docs/4.2/modules/qutip/control/fidcomp.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/control/fidcomp.html
https://qutip.org/docs/4.2/modules/qutip/control/fidcomp.html:8300,Availability,error,error,8300,"elf.params = params; for key in params:; setattr(self, key, params[key]). @property; def log_level(self):; return logger.level ; ; @log_level.setter; def log_level(self, lvl):; """"""; Set the log_level attribute and set the level of the logger; that is call logger.setLevel(lvl); """"""; logger.setLevel(lvl). [docs] def init_comp(self):; """"""; initialises the computer based on the configuration of the Dynamics; """"""; # optionally implemented in subclass; pass. [docs] def get_fid_err(self):; """"""; returns the absolute distance from the maximum achievable fidelity; """"""; # must be implemented by subclass; raise errors.UsageError(; ""No method defined for getting fidelity error.""; "" Suspect base class was used where sub class should have been""). [docs] def get_fid_err_gradient(self):; """"""; Returns the normalised gradient of the fidelity error; in a (nTimeslots x n_ctrls) array wrt the timeslot control amplitude; """"""; # must be implemented by subclass; raise errors.UsageError(""No method defined for getting fidelity""; "" error gradient. Suspect base class was""; "" used where sub class should have been""). [docs] def flag_system_changed(self):; """"""; Flag fidelity and gradients as needing recalculation; """"""; self.fidelity_current = False; # Flag gradient as needing recalculating; self.fid_err_grad_current = False. @property; def uses_evo_t2end(self):; _attrib_deprecation(; ""'uses_evo_t2end' has been replaced by 'uses_onwd_evo'""); return self.uses_onwd_evo. @uses_evo_t2end.setter; def uses_evo_t2end(self, value):; _attrib_deprecation(; ""'uses_evo_t2end' has been replaced by 'uses_onwd_evo'""); self.uses_onwd_evo = value. @property; def uses_evo_t2targ(self):; _attrib_deprecation(; ""'uses_evo_t2targ' has been replaced by 'uses_onto_evo'""); return self.uses_onto_evo. @uses_evo_t2targ.setter; def uses_evo_t2targ(self, value):; _attrib_deprecation(; ""'uses_evo_t2targ' has been replaced by 'uses_onto_evo'""); self.uses_onto_evo = value. [docs]class FidCompUnitary(FidelityComputer):; """"""; Comput",MatchSource.WIKI,docs/4.2/modules/qutip/control/fidcomp.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/control/fidcomp.html
https://qutip.org/docs/4.2/modules/qutip/control/fidcomp.html:9292,Availability,error,error,9292,"etting fidelity""; "" error gradient. Suspect base class was""; "" used where sub class should have been""). [docs] def flag_system_changed(self):; """"""; Flag fidelity and gradients as needing recalculation; """"""; self.fidelity_current = False; # Flag gradient as needing recalculating; self.fid_err_grad_current = False. @property; def uses_evo_t2end(self):; _attrib_deprecation(; ""'uses_evo_t2end' has been replaced by 'uses_onwd_evo'""); return self.uses_onwd_evo. @uses_evo_t2end.setter; def uses_evo_t2end(self, value):; _attrib_deprecation(; ""'uses_evo_t2end' has been replaced by 'uses_onwd_evo'""); self.uses_onwd_evo = value. @property; def uses_evo_t2targ(self):; _attrib_deprecation(; ""'uses_evo_t2targ' has been replaced by 'uses_onto_evo'""); return self.uses_onto_evo. @uses_evo_t2targ.setter; def uses_evo_t2targ(self, value):; _attrib_deprecation(; ""'uses_evo_t2targ' has been replaced by 'uses_onto_evo'""); self.uses_onto_evo = value. [docs]class FidCompUnitary(FidelityComputer):; """"""; Computes fidelity error and gradient assuming unitary dynamics, e.g.; closed qubit systems; Note fidelity and gradient calculations were taken from DYNAMO; (see file header). Attributes; ----------; phase_option : string; determines how global phase is treated in fidelity calculations:; PSU - global phase ignored; SU - global phase included. fidelity_prenorm : complex; Last computed value of the fidelity before it is normalised; It is stored to use in the gradient normalisation calculation. fidelity_prenorm_current : boolean; flag to specify whether fidelity_prenorm are based on the; current amplitude values. Set False when amplitudes change; """""". def reset(self):; FidelityComputer.reset(self); self.id_text = 'UNIT'; self.uses_onto_evo = True; self._init_phase_option('PSU'); self.apply_params(). def clear(self):; FidelityComputer.clear(self); self.fidelity_prenorm = None; self.fidelity_prenorm_current = False. [docs] def set_phase_option(self, phase_option=None):; """"""; Deprecated - use phase_",MatchSource.WIKI,docs/4.2/modules/qutip/control/fidcomp.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/control/fidcomp.html
https://qutip.org/docs/4.2/modules/qutip/control/fidcomp.html:11074,Availability,error,errors,11074,"'PSU'); self.apply_params(). def clear(self):; FidelityComputer.clear(self); self.fidelity_prenorm = None; self.fidelity_prenorm_current = False. [docs] def set_phase_option(self, phase_option=None):; """"""; Deprecated - use phase_option; Phase options are; SU - global phase important; PSU - global phase is not important; """"""; _func_deprecation(""'set_phase_option' is deprecated. ""; ""Use phase_option property""); self._init_phase_option(phase_option); ; @property; def phase_option(self):; return self._phase_option; ; @phase_option.setter; def phase_option(self, value):; """"""; # Phase options are; # SU - global phase important; # PSU - global phase is not important; """"""; self._init_phase_option(value). def _init_phase_option(self, value):; self._phase_option = value; if value == 'PSU':; self.fid_norm_func = self.normalize_PSU; self.grad_norm_func = self.normalize_gradient_PSU; elif value == 'SU':; self.fid_norm_func = self.normalize_SU; self.grad_norm_func = self.normalize_gradient_SU; elif value is None:; raise errors.UsageError(""phase_option cannot be set to None""; "" for this FidelityComputer.""); else:; raise errors.UsageError(; ""No option for phase_option '{}'"".format(value)); ; [docs] def init_comp(self):; """"""; Check configuration and initialise the normalisation; """"""; if self.fid_norm_func is None or self.grad_norm_func is None:; raise errors.UsageError(""The phase_option must be be set""; ""for this fidelity computer""); self.init_normalization(). [docs] def flag_system_changed(self):; """"""; Flag fidelity and gradients as needing recalculation; """"""; FidelityComputer.flag_system_changed(self); # Flag the fidelity (prenormalisation) value as needing calculation; self.fidelity_prenorm_current = False. [docs] def init_normalization(self):; """"""; Calc norm of <Ufinal | Ufinal> to scale subsequent norms; When considering unitary time evolution operators, this basically; results in calculating the trace of the identity matrix; and is hence equal to the size of the target matrix; ",MatchSource.WIKI,docs/4.2/modules/qutip/control/fidcomp.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/control/fidcomp.html
https://qutip.org/docs/4.2/modules/qutip/control/fidcomp.html:11175,Availability,error,errors,11175,"ty_prenorm_current = False. [docs] def set_phase_option(self, phase_option=None):; """"""; Deprecated - use phase_option; Phase options are; SU - global phase important; PSU - global phase is not important; """"""; _func_deprecation(""'set_phase_option' is deprecated. ""; ""Use phase_option property""); self._init_phase_option(phase_option); ; @property; def phase_option(self):; return self._phase_option; ; @phase_option.setter; def phase_option(self, value):; """"""; # Phase options are; # SU - global phase important; # PSU - global phase is not important; """"""; self._init_phase_option(value). def _init_phase_option(self, value):; self._phase_option = value; if value == 'PSU':; self.fid_norm_func = self.normalize_PSU; self.grad_norm_func = self.normalize_gradient_PSU; elif value == 'SU':; self.fid_norm_func = self.normalize_SU; self.grad_norm_func = self.normalize_gradient_SU; elif value is None:; raise errors.UsageError(""phase_option cannot be set to None""; "" for this FidelityComputer.""); else:; raise errors.UsageError(; ""No option for phase_option '{}'"".format(value)); ; [docs] def init_comp(self):; """"""; Check configuration and initialise the normalisation; """"""; if self.fid_norm_func is None or self.grad_norm_func is None:; raise errors.UsageError(""The phase_option must be be set""; ""for this fidelity computer""); self.init_normalization(). [docs] def flag_system_changed(self):; """"""; Flag fidelity and gradients as needing recalculation; """"""; FidelityComputer.flag_system_changed(self); # Flag the fidelity (prenormalisation) value as needing calculation; self.fidelity_prenorm_current = False. [docs] def init_normalization(self):; """"""; Calc norm of <Ufinal | Ufinal> to scale subsequent norms; When considering unitary time evolution operators, this basically; results in calculating the trace of the identity matrix; and is hence equal to the size of the target matrix; There may be situations where this is not the case, and hence it; is not assumed to be so.; The normalisation functio",MatchSource.WIKI,docs/4.2/modules/qutip/control/fidcomp.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/control/fidcomp.html
https://qutip.org/docs/4.2/modules/qutip/control/fidcomp.html:11409,Availability,error,errors,11409,"""'set_phase_option' is deprecated. ""; ""Use phase_option property""); self._init_phase_option(phase_option); ; @property; def phase_option(self):; return self._phase_option; ; @phase_option.setter; def phase_option(self, value):; """"""; # Phase options are; # SU - global phase important; # PSU - global phase is not important; """"""; self._init_phase_option(value). def _init_phase_option(self, value):; self._phase_option = value; if value == 'PSU':; self.fid_norm_func = self.normalize_PSU; self.grad_norm_func = self.normalize_gradient_PSU; elif value == 'SU':; self.fid_norm_func = self.normalize_SU; self.grad_norm_func = self.normalize_gradient_SU; elif value is None:; raise errors.UsageError(""phase_option cannot be set to None""; "" for this FidelityComputer.""); else:; raise errors.UsageError(; ""No option for phase_option '{}'"".format(value)); ; [docs] def init_comp(self):; """"""; Check configuration and initialise the normalisation; """"""; if self.fid_norm_func is None or self.grad_norm_func is None:; raise errors.UsageError(""The phase_option must be be set""; ""for this fidelity computer""); self.init_normalization(). [docs] def flag_system_changed(self):; """"""; Flag fidelity and gradients as needing recalculation; """"""; FidelityComputer.flag_system_changed(self); # Flag the fidelity (prenormalisation) value as needing calculation; self.fidelity_prenorm_current = False. [docs] def init_normalization(self):; """"""; Calc norm of <Ufinal | Ufinal> to scale subsequent norms; When considering unitary time evolution operators, this basically; results in calculating the trace of the identity matrix; and is hence equal to the size of the target matrix; There may be situations where this is not the case, and hence it; is not assumed to be so.; The normalisation function called should be set to either the; PSU - global phase ignored; SU - global phase respected; """"""; dyn = self.parent; self.dimensional_norm = 1.0; self.dimensional_norm = \; self.fid_norm_func(dyn.target.dag()*dyn.target). [do",MatchSource.WIKI,docs/4.2/modules/qutip/control/fidcomp.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/control/fidcomp.html
https://qutip.org/docs/4.2/modules/qutip/control/fidcomp.html:13749,Availability,error,error,13749," np.real(norm) / self.dimensional_norm. [docs] def normalize_gradient_SU(self, grad):; """"""; Normalise the gradient matrix passed as grad; This SU version respects global phase; """"""; grad_normalized = np.real(grad) / self.dimensional_norm. return grad_normalized. [docs] def normalize_PSU(self, A):; """""". """"""; try:; if A.shape[0] == A.shape[1]:; # input is an operator (Qobj, array, sparse etc), so; norm = _trace(A); else:; raise TypeError(""Cannot compute trace (not square)""); except:; # assume input is already scalar and hence assumed; # to be the prenormalised scalar value, e.g. fidelity; norm = A; return np.abs(norm) / self.dimensional_norm. [docs] def normalize_gradient_PSU(self, grad):; """"""; Normalise the gradient matrix passed as grad; This PSU version is independent of global phase; """"""; fid_pn = self.get_fidelity_prenorm(); grad_normalized = np.real(grad * np.exp(-1j * np.angle(fid_pn)) /; self.dimensional_norm); return grad_normalized. [docs] def get_fid_err(self):; """"""; Gets the absolute error in the fidelity; """"""; return np.abs(1 - self.get_fidelity()). [docs] def get_fidelity(self):; """"""; Gets the appropriately normalised fidelity value; The normalisation is determined by the fid_norm_func pointer; which should be set in the config; """"""; if not self.fidelity_current:; self.fidelity = \; self.fid_norm_func(self.get_fidelity_prenorm()); self.fidelity_current = True; if self.log_level <= logging.DEBUG:; logger.debug(""Fidelity (normalised): {}"".format(self.fidelity)). return self.fidelity. [docs] def get_fidelity_prenorm(self):; """"""; Gets the current fidelity value prior to normalisation; Note the gradient function uses this value; The value is cached, because it is used in the gradient calculation; """"""; if not self.fidelity_prenorm_current:; dyn = self.parent; k = dyn.tslot_computer._get_timeslot_for_fidelity_calc(); dyn.compute_evolution(); if dyn.oper_dtype == Qobj:; f = (dyn._onto_evo[k]*dyn._fwd_evo[k]).tr(); else:; f = _trace(dyn._onto_evo[k].dot(dyn._fwd_e",MatchSource.WIKI,docs/4.2/modules/qutip/control/fidcomp.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/control/fidcomp.html
https://qutip.org/docs/4.2/modules/qutip/control/fidcomp.html:15122,Availability,error,error,15122,"er.debug(""Fidelity (normalised): {}"".format(self.fidelity)). return self.fidelity. [docs] def get_fidelity_prenorm(self):; """"""; Gets the current fidelity value prior to normalisation; Note the gradient function uses this value; The value is cached, because it is used in the gradient calculation; """"""; if not self.fidelity_prenorm_current:; dyn = self.parent; k = dyn.tslot_computer._get_timeslot_for_fidelity_calc(); dyn.compute_evolution(); if dyn.oper_dtype == Qobj:; f = (dyn._onto_evo[k]*dyn._fwd_evo[k]).tr(); else:; f = _trace(dyn._onto_evo[k].dot(dyn._fwd_evo[k])); self.fidelity_prenorm = f; self.fidelity_prenorm_current = True; if dyn.stats is not None:; dyn.stats.num_fidelity_computes += 1; if self.log_level <= logging.DEBUG:; logger.debug(""Fidelity (pre normalisation): {}"".format(; self.fidelity_prenorm)); return self.fidelity_prenorm. [docs] def get_fid_err_gradient(self):; """"""; Returns the normalised gradient of the fidelity error; in a (nTimeslots x n_ctrls) array; The gradients are cached in case they are requested; mutliple times between control updates; (although this is not typically found to happen); """"""; if not self.fid_err_grad_current:; dyn = self.parent; grad_prenorm = self.compute_fid_grad(); if self.log_level <= logging.DEBUG_INTENSE:; logger.log(logging.DEBUG_INTENSE, ""pre-normalised fidelity ""; ""gradients:\n{}"".format(grad_prenorm)); # AJGP: Note this check should not be necessary if dynamics are; # unitary. However, if they are not then this gradient; # can still be used, however the interpretation is dubious; if self.get_fidelity() >= 1:; self.fid_err_grad = self.grad_norm_func(grad_prenorm); else:; self.fid_err_grad = -self.grad_norm_func(grad_prenorm). self.fid_err_grad_current = True; if dyn.stats is not None:; dyn.stats.num_grad_computes += 1. self.grad_norm = np.sqrt(np.sum(self.fid_err_grad**2)); if self.log_level <= logging.DEBUG_INTENSE:; logger.log(logging.DEBUG_INTENSE, ""Normalised fidelity error ""; ""gradients:\n{}"".format(self.fid_e",MatchSource.WIKI,docs/4.2/modules/qutip/control/fidcomp.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/control/fidcomp.html
https://qutip.org/docs/4.2/modules/qutip/control/fidcomp.html:16133,Availability,error,error,16133," in a (nTimeslots x n_ctrls) array; The gradients are cached in case they are requested; mutliple times between control updates; (although this is not typically found to happen); """"""; if not self.fid_err_grad_current:; dyn = self.parent; grad_prenorm = self.compute_fid_grad(); if self.log_level <= logging.DEBUG_INTENSE:; logger.log(logging.DEBUG_INTENSE, ""pre-normalised fidelity ""; ""gradients:\n{}"".format(grad_prenorm)); # AJGP: Note this check should not be necessary if dynamics are; # unitary. However, if they are not then this gradient; # can still be used, however the interpretation is dubious; if self.get_fidelity() >= 1:; self.fid_err_grad = self.grad_norm_func(grad_prenorm); else:; self.fid_err_grad = -self.grad_norm_func(grad_prenorm). self.fid_err_grad_current = True; if dyn.stats is not None:; dyn.stats.num_grad_computes += 1. self.grad_norm = np.sqrt(np.sum(self.fid_err_grad**2)); if self.log_level <= logging.DEBUG_INTENSE:; logger.log(logging.DEBUG_INTENSE, ""Normalised fidelity error ""; ""gradients:\n{}"".format(self.fid_err_grad)). if self.log_level <= logging.DEBUG:; logger.debug(""Gradient (sum sq norm): ""; ""{} "".format(self.grad_norm)). return self.fid_err_grad. [docs] def compute_fid_grad(self):; """"""; Calculates exact gradient of function wrt to each timeslot; control amplitudes. Note these gradients are not normalised; These are returned as a (nTimeslots x n_ctrls) array; """"""; dyn = self.parent; n_ctrls = dyn.num_ctrls; n_ts = dyn.num_tslots. # create n_ts x n_ctrls zero array for grad start point; grad = np.zeros([n_ts, n_ctrls], dtype=complex). dyn.tslot_computer.flag_all_calc_now(); dyn.compute_evolution(). # loop through all ctrl timeslots calculating gradients; time_st = timeit.default_timer(); for j in range(n_ctrls):; for k in range(n_ts):; fwd_evo = dyn._fwd_evo[k] ; onto_evo = dyn._onto_evo[k+1]; if dyn.oper_dtype == Qobj:; g = (onto_evo*dyn._get_prop_grad(k, j)*fwd_evo).tr(); else:; g = _trace(onto_evo.dot(; dyn._get_prop_grad(k, j)).dot(fwd",MatchSource.WIKI,docs/4.2/modules/qutip/control/fidcomp.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/control/fidcomp.html
https://qutip.org/docs/4.2/modules/qutip/control/fidcomp.html:17341,Availability,error,error,17341,"eslot; control amplitudes. Note these gradients are not normalised; These are returned as a (nTimeslots x n_ctrls) array; """"""; dyn = self.parent; n_ctrls = dyn.num_ctrls; n_ts = dyn.num_tslots. # create n_ts x n_ctrls zero array for grad start point; grad = np.zeros([n_ts, n_ctrls], dtype=complex). dyn.tslot_computer.flag_all_calc_now(); dyn.compute_evolution(). # loop through all ctrl timeslots calculating gradients; time_st = timeit.default_timer(); for j in range(n_ctrls):; for k in range(n_ts):; fwd_evo = dyn._fwd_evo[k] ; onto_evo = dyn._onto_evo[k+1]; if dyn.oper_dtype == Qobj:; g = (onto_evo*dyn._get_prop_grad(k, j)*fwd_evo).tr(); else:; g = _trace(onto_evo.dot(; dyn._get_prop_grad(k, j)).dot(fwd_evo)); grad[k, j] = g; if dyn.stats is not None:; dyn.stats.wall_time_gradient_compute += \; timeit.default_timer() - time_st; return grad. [docs]class FidCompTraceDiff(FidelityComputer):; """"""; Computes fidelity error and gradient for general system dynamics; by calculating the the fidelity error as the trace of the overlap; of the difference between the target and evolution resulting from; the pulses with the transpose of the same.; This should provide a distance measure for dynamics described by matrices; Note the gradient calculation is taken from:; 'Robust quantum gates for open systems via optimal control:; Markovian versus non-Markovian dynamics'; Frederik F Floether, Pierre de Fouquieres, and Sophie G Schirmer. Attributes; ----------; scale_factor : float; The fidelity error calculated is of some arbitary scale. This; factor can be used to scale the fidelity error such that it may; represent some physical measure; If None is given then it is caculated as 1/2N, where N; is the dimension of the drift, when the Dynamics are initialised.; """""". def reset(self):; FidelityComputer.reset(self); self.id_text = 'TRACEDIFF'; self.scale_factor = None; self.uses_onwd_evo = True; if not self.parent.prop_computer.grad_exact:; raise errors.UsageError(; ""This FidelityComputer c",MatchSource.WIKI,docs/4.2/modules/qutip/control/fidcomp.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/control/fidcomp.html
https://qutip.org/docs/4.2/modules/qutip/control/fidcomp.html:17421,Availability,error,error,17421,"eslot; control amplitudes. Note these gradients are not normalised; These are returned as a (nTimeslots x n_ctrls) array; """"""; dyn = self.parent; n_ctrls = dyn.num_ctrls; n_ts = dyn.num_tslots. # create n_ts x n_ctrls zero array for grad start point; grad = np.zeros([n_ts, n_ctrls], dtype=complex). dyn.tslot_computer.flag_all_calc_now(); dyn.compute_evolution(). # loop through all ctrl timeslots calculating gradients; time_st = timeit.default_timer(); for j in range(n_ctrls):; for k in range(n_ts):; fwd_evo = dyn._fwd_evo[k] ; onto_evo = dyn._onto_evo[k+1]; if dyn.oper_dtype == Qobj:; g = (onto_evo*dyn._get_prop_grad(k, j)*fwd_evo).tr(); else:; g = _trace(onto_evo.dot(; dyn._get_prop_grad(k, j)).dot(fwd_evo)); grad[k, j] = g; if dyn.stats is not None:; dyn.stats.wall_time_gradient_compute += \; timeit.default_timer() - time_st; return grad. [docs]class FidCompTraceDiff(FidelityComputer):; """"""; Computes fidelity error and gradient for general system dynamics; by calculating the the fidelity error as the trace of the overlap; of the difference between the target and evolution resulting from; the pulses with the transpose of the same.; This should provide a distance measure for dynamics described by matrices; Note the gradient calculation is taken from:; 'Robust quantum gates for open systems via optimal control:; Markovian versus non-Markovian dynamics'; Frederik F Floether, Pierre de Fouquieres, and Sophie G Schirmer. Attributes; ----------; scale_factor : float; The fidelity error calculated is of some arbitary scale. This; factor can be used to scale the fidelity error such that it may; represent some physical measure; If None is given then it is caculated as 1/2N, where N; is the dimension of the drift, when the Dynamics are initialised.; """""". def reset(self):; FidelityComputer.reset(self); self.id_text = 'TRACEDIFF'; self.scale_factor = None; self.uses_onwd_evo = True; if not self.parent.prop_computer.grad_exact:; raise errors.UsageError(; ""This FidelityComputer c",MatchSource.WIKI,docs/4.2/modules/qutip/control/fidcomp.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/control/fidcomp.html
https://qutip.org/docs/4.2/modules/qutip/control/fidcomp.html:17916,Availability,error,error,17916,"range(n_ts):; fwd_evo = dyn._fwd_evo[k] ; onto_evo = dyn._onto_evo[k+1]; if dyn.oper_dtype == Qobj:; g = (onto_evo*dyn._get_prop_grad(k, j)*fwd_evo).tr(); else:; g = _trace(onto_evo.dot(; dyn._get_prop_grad(k, j)).dot(fwd_evo)); grad[k, j] = g; if dyn.stats is not None:; dyn.stats.wall_time_gradient_compute += \; timeit.default_timer() - time_st; return grad. [docs]class FidCompTraceDiff(FidelityComputer):; """"""; Computes fidelity error and gradient for general system dynamics; by calculating the the fidelity error as the trace of the overlap; of the difference between the target and evolution resulting from; the pulses with the transpose of the same.; This should provide a distance measure for dynamics described by matrices; Note the gradient calculation is taken from:; 'Robust quantum gates for open systems via optimal control:; Markovian versus non-Markovian dynamics'; Frederik F Floether, Pierre de Fouquieres, and Sophie G Schirmer. Attributes; ----------; scale_factor : float; The fidelity error calculated is of some arbitary scale. This; factor can be used to scale the fidelity error such that it may; represent some physical measure; If None is given then it is caculated as 1/2N, where N; is the dimension of the drift, when the Dynamics are initialised.; """""". def reset(self):; FidelityComputer.reset(self); self.id_text = 'TRACEDIFF'; self.scale_factor = None; self.uses_onwd_evo = True; if not self.parent.prop_computer.grad_exact:; raise errors.UsageError(; ""This FidelityComputer can only be""; "" used with an exact gradient PropagatorComputer.""); self.apply_params(). [docs] def init_comp(self):; """"""; initialises the computer based on the configuration of the Dynamics; Calculates the scale_factor is not already set; """"""; if self.scale_factor is None:; self.scale_factor = 1.0 / (2.0*self.parent.get_drift_dim()); if self.log_level <= logging.DEBUG:; logger.debug(""Scale factor calculated as {}"".format(; self.scale_factor)). [docs] def get_fid_err(self):; """"""; Gets the",MatchSource.WIKI,docs/4.2/modules/qutip/control/fidcomp.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/control/fidcomp.html
https://qutip.org/docs/4.2/modules/qutip/control/fidcomp.html:18007,Availability,error,error,18007," _trace(onto_evo.dot(; dyn._get_prop_grad(k, j)).dot(fwd_evo)); grad[k, j] = g; if dyn.stats is not None:; dyn.stats.wall_time_gradient_compute += \; timeit.default_timer() - time_st; return grad. [docs]class FidCompTraceDiff(FidelityComputer):; """"""; Computes fidelity error and gradient for general system dynamics; by calculating the the fidelity error as the trace of the overlap; of the difference between the target and evolution resulting from; the pulses with the transpose of the same.; This should provide a distance measure for dynamics described by matrices; Note the gradient calculation is taken from:; 'Robust quantum gates for open systems via optimal control:; Markovian versus non-Markovian dynamics'; Frederik F Floether, Pierre de Fouquieres, and Sophie G Schirmer. Attributes; ----------; scale_factor : float; The fidelity error calculated is of some arbitary scale. This; factor can be used to scale the fidelity error such that it may; represent some physical measure; If None is given then it is caculated as 1/2N, where N; is the dimension of the drift, when the Dynamics are initialised.; """""". def reset(self):; FidelityComputer.reset(self); self.id_text = 'TRACEDIFF'; self.scale_factor = None; self.uses_onwd_evo = True; if not self.parent.prop_computer.grad_exact:; raise errors.UsageError(; ""This FidelityComputer can only be""; "" used with an exact gradient PropagatorComputer.""); self.apply_params(). [docs] def init_comp(self):; """"""; initialises the computer based on the configuration of the Dynamics; Calculates the scale_factor is not already set; """"""; if self.scale_factor is None:; self.scale_factor = 1.0 / (2.0*self.parent.get_drift_dim()); if self.log_level <= logging.DEBUG:; logger.debug(""Scale factor calculated as {}"".format(; self.scale_factor)). [docs] def get_fid_err(self):; """"""; Gets the absolute error in the fidelity; """"""; if not self.fidelity_current:; dyn = self.parent; dyn.compute_evolution(); n_ts = dyn.num_tslots; evo_final = dyn._fwd_evo[n_t",MatchSource.WIKI,docs/4.2/modules/qutip/control/fidcomp.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/control/fidcomp.html
https://qutip.org/docs/4.2/modules/qutip/control/fidcomp.html:18373,Availability,error,errors,18373,"eral system dynamics; by calculating the the fidelity error as the trace of the overlap; of the difference between the target and evolution resulting from; the pulses with the transpose of the same.; This should provide a distance measure for dynamics described by matrices; Note the gradient calculation is taken from:; 'Robust quantum gates for open systems via optimal control:; Markovian versus non-Markovian dynamics'; Frederik F Floether, Pierre de Fouquieres, and Sophie G Schirmer. Attributes; ----------; scale_factor : float; The fidelity error calculated is of some arbitary scale. This; factor can be used to scale the fidelity error such that it may; represent some physical measure; If None is given then it is caculated as 1/2N, where N; is the dimension of the drift, when the Dynamics are initialised.; """""". def reset(self):; FidelityComputer.reset(self); self.id_text = 'TRACEDIFF'; self.scale_factor = None; self.uses_onwd_evo = True; if not self.parent.prop_computer.grad_exact:; raise errors.UsageError(; ""This FidelityComputer can only be""; "" used with an exact gradient PropagatorComputer.""); self.apply_params(). [docs] def init_comp(self):; """"""; initialises the computer based on the configuration of the Dynamics; Calculates the scale_factor is not already set; """"""; if self.scale_factor is None:; self.scale_factor = 1.0 / (2.0*self.parent.get_drift_dim()); if self.log_level <= logging.DEBUG:; logger.debug(""Scale factor calculated as {}"".format(; self.scale_factor)). [docs] def get_fid_err(self):; """"""; Gets the absolute error in the fidelity; """"""; if not self.fidelity_current:; dyn = self.parent; dyn.compute_evolution(); n_ts = dyn.num_tslots; evo_final = dyn._fwd_evo[n_ts]; evo_f_diff = dyn._target - evo_final; if self.log_level <= logging.DEBUG_VERBOSE:; logger.log(logging.DEBUG_VERBOSE, ""Calculating TraceDiff ""; ""fidelity...\n Target:\n{}\n Evo final:\n{}\n""; ""Evo final diff:\n{}"".format(dyn._target, evo_final,; evo_f_diff)). # Calculate the fidelity error u",MatchSource.WIKI,docs/4.2/modules/qutip/control/fidcomp.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/control/fidcomp.html
https://qutip.org/docs/4.2/modules/qutip/control/fidcomp.html:18918,Availability,error,error,18918,"elity error calculated is of some arbitary scale. This; factor can be used to scale the fidelity error such that it may; represent some physical measure; If None is given then it is caculated as 1/2N, where N; is the dimension of the drift, when the Dynamics are initialised.; """""". def reset(self):; FidelityComputer.reset(self); self.id_text = 'TRACEDIFF'; self.scale_factor = None; self.uses_onwd_evo = True; if not self.parent.prop_computer.grad_exact:; raise errors.UsageError(; ""This FidelityComputer can only be""; "" used with an exact gradient PropagatorComputer.""); self.apply_params(). [docs] def init_comp(self):; """"""; initialises the computer based on the configuration of the Dynamics; Calculates the scale_factor is not already set; """"""; if self.scale_factor is None:; self.scale_factor = 1.0 / (2.0*self.parent.get_drift_dim()); if self.log_level <= logging.DEBUG:; logger.debug(""Scale factor calculated as {}"".format(; self.scale_factor)). [docs] def get_fid_err(self):; """"""; Gets the absolute error in the fidelity; """"""; if not self.fidelity_current:; dyn = self.parent; dyn.compute_evolution(); n_ts = dyn.num_tslots; evo_final = dyn._fwd_evo[n_ts]; evo_f_diff = dyn._target - evo_final; if self.log_level <= logging.DEBUG_VERBOSE:; logger.log(logging.DEBUG_VERBOSE, ""Calculating TraceDiff ""; ""fidelity...\n Target:\n{}\n Evo final:\n{}\n""; ""Evo final diff:\n{}"".format(dyn._target, evo_final,; evo_f_diff)). # Calculate the fidelity error using the trace difference norm; # Note that the value should have not imagnary part, so using; # np.real, just avoids the complex casting warning; if dyn.oper_dtype == Qobj:; self.fid_err = self.scale_factor*np.real(; (evo_f_diff.dag()*evo_f_diff).tr()); else:; self.fid_err = self.scale_factor*np.real(_trace(; evo_f_diff.conj().T.dot(evo_f_diff))). if np.isnan(self.fid_err):; self.fid_err = np.Inf. if dyn.stats is not None:; dyn.stats.num_fidelity_computes += 1. self.fidelity_current = True; if self.log_level <= logging.DEBUG:; logger.deb",MatchSource.WIKI,docs/4.2/modules/qutip/control/fidcomp.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/control/fidcomp.html
https://qutip.org/docs/4.2/modules/qutip/control/fidcomp.html:19360,Availability,error,error,19360,"idelityComputer can only be""; "" used with an exact gradient PropagatorComputer.""); self.apply_params(). [docs] def init_comp(self):; """"""; initialises the computer based on the configuration of the Dynamics; Calculates the scale_factor is not already set; """"""; if self.scale_factor is None:; self.scale_factor = 1.0 / (2.0*self.parent.get_drift_dim()); if self.log_level <= logging.DEBUG:; logger.debug(""Scale factor calculated as {}"".format(; self.scale_factor)). [docs] def get_fid_err(self):; """"""; Gets the absolute error in the fidelity; """"""; if not self.fidelity_current:; dyn = self.parent; dyn.compute_evolution(); n_ts = dyn.num_tslots; evo_final = dyn._fwd_evo[n_ts]; evo_f_diff = dyn._target - evo_final; if self.log_level <= logging.DEBUG_VERBOSE:; logger.log(logging.DEBUG_VERBOSE, ""Calculating TraceDiff ""; ""fidelity...\n Target:\n{}\n Evo final:\n{}\n""; ""Evo final diff:\n{}"".format(dyn._target, evo_final,; evo_f_diff)). # Calculate the fidelity error using the trace difference norm; # Note that the value should have not imagnary part, so using; # np.real, just avoids the complex casting warning; if dyn.oper_dtype == Qobj:; self.fid_err = self.scale_factor*np.real(; (evo_f_diff.dag()*evo_f_diff).tr()); else:; self.fid_err = self.scale_factor*np.real(_trace(; evo_f_diff.conj().T.dot(evo_f_diff))). if np.isnan(self.fid_err):; self.fid_err = np.Inf. if dyn.stats is not None:; dyn.stats.num_fidelity_computes += 1. self.fidelity_current = True; if self.log_level <= logging.DEBUG:; logger.debug(""Fidelity error: {}"".format(self.fid_err)). return self.fid_err. [docs] def get_fid_err_gradient(self):; """"""; Returns the normalised gradient of the fidelity error; in a (nTimeslots x n_ctrls) array; The gradients are cached in case they are requested; mutliple times between control updates; (although this is not typically found to happen); """"""; if not self.fid_err_grad_current:; dyn = self.parent; self.fid_err_grad = self.compute_fid_err_grad(); self.fid_err_grad_current = True; if",MatchSource.WIKI,docs/4.2/modules/qutip/control/fidcomp.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/control/fidcomp.html
https://qutip.org/docs/4.2/modules/qutip/control/fidcomp.html:19924,Availability,error,error,19924,"or in the fidelity; """"""; if not self.fidelity_current:; dyn = self.parent; dyn.compute_evolution(); n_ts = dyn.num_tslots; evo_final = dyn._fwd_evo[n_ts]; evo_f_diff = dyn._target - evo_final; if self.log_level <= logging.DEBUG_VERBOSE:; logger.log(logging.DEBUG_VERBOSE, ""Calculating TraceDiff ""; ""fidelity...\n Target:\n{}\n Evo final:\n{}\n""; ""Evo final diff:\n{}"".format(dyn._target, evo_final,; evo_f_diff)). # Calculate the fidelity error using the trace difference norm; # Note that the value should have not imagnary part, so using; # np.real, just avoids the complex casting warning; if dyn.oper_dtype == Qobj:; self.fid_err = self.scale_factor*np.real(; (evo_f_diff.dag()*evo_f_diff).tr()); else:; self.fid_err = self.scale_factor*np.real(_trace(; evo_f_diff.conj().T.dot(evo_f_diff))). if np.isnan(self.fid_err):; self.fid_err = np.Inf. if dyn.stats is not None:; dyn.stats.num_fidelity_computes += 1. self.fidelity_current = True; if self.log_level <= logging.DEBUG:; logger.debug(""Fidelity error: {}"".format(self.fid_err)). return self.fid_err. [docs] def get_fid_err_gradient(self):; """"""; Returns the normalised gradient of the fidelity error; in a (nTimeslots x n_ctrls) array; The gradients are cached in case they are requested; mutliple times between control updates; (although this is not typically found to happen); """"""; if not self.fid_err_grad_current:; dyn = self.parent; self.fid_err_grad = self.compute_fid_err_grad(); self.fid_err_grad_current = True; if dyn.stats is not None:; dyn.stats.num_grad_computes += 1. self.grad_norm = np.sqrt(np.sum(self.fid_err_grad**2)); if self.log_level <= logging.DEBUG_INTENSE:; logger.log(logging.DEBUG_INTENSE, ""fidelity error gradients:\n""; ""{}"".format(self.fid_err_grad)). if self.log_level <= logging.DEBUG:; logger.debug(""Gradient norm: ""; ""{} "".format(self.grad_norm)). return self.fid_err_grad. [docs] def compute_fid_err_grad(self):; """"""; Calculate exact gradient of the fidelity error function; wrt to each timeslot control amplit",MatchSource.WIKI,docs/4.2/modules/qutip/control/fidcomp.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/control/fidcomp.html
https://qutip.org/docs/4.2/modules/qutip/control/fidcomp.html:20072,Availability,error,error,20072,"level <= logging.DEBUG_VERBOSE:; logger.log(logging.DEBUG_VERBOSE, ""Calculating TraceDiff ""; ""fidelity...\n Target:\n{}\n Evo final:\n{}\n""; ""Evo final diff:\n{}"".format(dyn._target, evo_final,; evo_f_diff)). # Calculate the fidelity error using the trace difference norm; # Note that the value should have not imagnary part, so using; # np.real, just avoids the complex casting warning; if dyn.oper_dtype == Qobj:; self.fid_err = self.scale_factor*np.real(; (evo_f_diff.dag()*evo_f_diff).tr()); else:; self.fid_err = self.scale_factor*np.real(_trace(; evo_f_diff.conj().T.dot(evo_f_diff))). if np.isnan(self.fid_err):; self.fid_err = np.Inf. if dyn.stats is not None:; dyn.stats.num_fidelity_computes += 1. self.fidelity_current = True; if self.log_level <= logging.DEBUG:; logger.debug(""Fidelity error: {}"".format(self.fid_err)). return self.fid_err. [docs] def get_fid_err_gradient(self):; """"""; Returns the normalised gradient of the fidelity error; in a (nTimeslots x n_ctrls) array; The gradients are cached in case they are requested; mutliple times between control updates; (although this is not typically found to happen); """"""; if not self.fid_err_grad_current:; dyn = self.parent; self.fid_err_grad = self.compute_fid_err_grad(); self.fid_err_grad_current = True; if dyn.stats is not None:; dyn.stats.num_grad_computes += 1. self.grad_norm = np.sqrt(np.sum(self.fid_err_grad**2)); if self.log_level <= logging.DEBUG_INTENSE:; logger.log(logging.DEBUG_INTENSE, ""fidelity error gradients:\n""; ""{}"".format(self.fid_err_grad)). if self.log_level <= logging.DEBUG:; logger.debug(""Gradient norm: ""; ""{} "".format(self.grad_norm)). return self.fid_err_grad. [docs] def compute_fid_err_grad(self):; """"""; Calculate exact gradient of the fidelity error function; wrt to each timeslot control amplitudes.; Uses the trace difference norm fidelity; These are returned as a (nTimeslots x n_ctrls) array; """"""; dyn = self.parent; n_ctrls = dyn.num_ctrls; n_ts = dyn.num_tslots. # create n_ts x n_ctrls zero a",MatchSource.WIKI,docs/4.2/modules/qutip/control/fidcomp.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/control/fidcomp.html
https://qutip.org/docs/4.2/modules/qutip/control/fidcomp.html:20605,Availability,error,error,20605,"o_f_diff).tr()); else:; self.fid_err = self.scale_factor*np.real(_trace(; evo_f_diff.conj().T.dot(evo_f_diff))). if np.isnan(self.fid_err):; self.fid_err = np.Inf. if dyn.stats is not None:; dyn.stats.num_fidelity_computes += 1. self.fidelity_current = True; if self.log_level <= logging.DEBUG:; logger.debug(""Fidelity error: {}"".format(self.fid_err)). return self.fid_err. [docs] def get_fid_err_gradient(self):; """"""; Returns the normalised gradient of the fidelity error; in a (nTimeslots x n_ctrls) array; The gradients are cached in case they are requested; mutliple times between control updates; (although this is not typically found to happen); """"""; if not self.fid_err_grad_current:; dyn = self.parent; self.fid_err_grad = self.compute_fid_err_grad(); self.fid_err_grad_current = True; if dyn.stats is not None:; dyn.stats.num_grad_computes += 1. self.grad_norm = np.sqrt(np.sum(self.fid_err_grad**2)); if self.log_level <= logging.DEBUG_INTENSE:; logger.log(logging.DEBUG_INTENSE, ""fidelity error gradients:\n""; ""{}"".format(self.fid_err_grad)). if self.log_level <= logging.DEBUG:; logger.debug(""Gradient norm: ""; ""{} "".format(self.grad_norm)). return self.fid_err_grad. [docs] def compute_fid_err_grad(self):; """"""; Calculate exact gradient of the fidelity error function; wrt to each timeslot control amplitudes.; Uses the trace difference norm fidelity; These are returned as a (nTimeslots x n_ctrls) array; """"""; dyn = self.parent; n_ctrls = dyn.num_ctrls; n_ts = dyn.num_tslots. # create n_ts x n_ctrls zero array for grad start point; grad = np.zeros([n_ts, n_ctrls]). dyn.tslot_computer.flag_all_calc_now(); dyn.compute_evolution(). # loop through all ctrl timeslots calculating gradients; time_st = timeit.default_timer(). evo_final = dyn._fwd_evo[n_ts]; evo_f_diff = dyn._target - evo_final; for j in range(n_ctrls):; for k in range(n_ts):; fwd_evo = dyn._fwd_evo[k]; if dyn.oper_dtype == Qobj:; evo_grad = dyn._get_prop_grad(k, j)*fwd_evo; if k+1 < n_ts:; evo_grad = dyn._onwd_evo[k+1",MatchSource.WIKI,docs/4.2/modules/qutip/control/fidcomp.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/control/fidcomp.html
https://qutip.org/docs/4.2/modules/qutip/control/fidcomp.html:20871,Availability,error,error,20871," = True; if self.log_level <= logging.DEBUG:; logger.debug(""Fidelity error: {}"".format(self.fid_err)). return self.fid_err. [docs] def get_fid_err_gradient(self):; """"""; Returns the normalised gradient of the fidelity error; in a (nTimeslots x n_ctrls) array; The gradients are cached in case they are requested; mutliple times between control updates; (although this is not typically found to happen); """"""; if not self.fid_err_grad_current:; dyn = self.parent; self.fid_err_grad = self.compute_fid_err_grad(); self.fid_err_grad_current = True; if dyn.stats is not None:; dyn.stats.num_grad_computes += 1. self.grad_norm = np.sqrt(np.sum(self.fid_err_grad**2)); if self.log_level <= logging.DEBUG_INTENSE:; logger.log(logging.DEBUG_INTENSE, ""fidelity error gradients:\n""; ""{}"".format(self.fid_err_grad)). if self.log_level <= logging.DEBUG:; logger.debug(""Gradient norm: ""; ""{} "".format(self.grad_norm)). return self.fid_err_grad. [docs] def compute_fid_err_grad(self):; """"""; Calculate exact gradient of the fidelity error function; wrt to each timeslot control amplitudes.; Uses the trace difference norm fidelity; These are returned as a (nTimeslots x n_ctrls) array; """"""; dyn = self.parent; n_ctrls = dyn.num_ctrls; n_ts = dyn.num_tslots. # create n_ts x n_ctrls zero array for grad start point; grad = np.zeros([n_ts, n_ctrls]). dyn.tslot_computer.flag_all_calc_now(); dyn.compute_evolution(). # loop through all ctrl timeslots calculating gradients; time_st = timeit.default_timer(). evo_final = dyn._fwd_evo[n_ts]; evo_f_diff = dyn._target - evo_final; for j in range(n_ctrls):; for k in range(n_ts):; fwd_evo = dyn._fwd_evo[k]; if dyn.oper_dtype == Qobj:; evo_grad = dyn._get_prop_grad(k, j)*fwd_evo; if k+1 < n_ts:; evo_grad = dyn._onwd_evo[k+1]*evo_grad; # Note that the value should have not imagnary part, so; # using np.real, just avoids the complex casting warning; g = -2*self.scale_factor*np.real(; (evo_f_diff.dag()*evo_grad).tr()); else:; evo_grad = dyn._get_prop_grad(k, j).dot(fwd_ev",MatchSource.WIKI,docs/4.2/modules/qutip/control/fidcomp.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/control/fidcomp.html
https://qutip.org/docs/4.2/modules/qutip/control/fidcomp.html:23044,Availability,error,error,23044,"yn.stats.wall_time_gradient_compute += \; timeit.default_timer() - time_st; return grad. [docs]class FidCompTraceDiffApprox(FidCompTraceDiff):; """"""; As FidCompTraceDiff, except uses the finite difference method to; compute approximate gradients. Attributes; ----------; epsilon : float; control amplitude offset to use when approximating the gradient wrt; a timeslot control amplitude; ; """"""; def reset(self):; FidelityComputer.reset(self); self.id_text = 'TDAPPROX'; self.uses_onwd_evo = True; self.scale_factor = None; self.epsilon = 0.001; self.apply_params(). [docs] def compute_fid_err_grad(self):; """"""; Calculates gradient of function wrt to each timeslot; control amplitudes. Note these gradients are not normalised; They are calulated; These are returned as a (nTimeslots x n_ctrls) array; """"""; dyn = self.parent; prop_comp = dyn.prop_computer; n_ctrls = dyn.num_ctrls; n_ts = dyn.num_tslots. if self.log_level >= logging.DEBUG:; logger.debug(""Computing fidelity error gradient""); # create n_ts x n_ctrls zero array for grad start point; grad = np.zeros([n_ts, n_ctrls]). dyn.tslot_computer.flag_all_calc_now(); dyn.compute_evolution(); curr_fid_err = self.get_fid_err(). # loop through all ctrl timeslots calculating gradients; time_st = timeit.default_timer(). for j in range(n_ctrls):; for k in range(n_ts):; fwd_evo = dyn._fwd_evo[k]; prop_eps = prop_comp._compute_diff_prop(k, j, self.epsilon); if dyn.oper_dtype == Qobj:; evo_final_eps = fwd_evo*prop_eps; if k+1 < n_ts:; evo_final_eps = evo_final_eps*dyn._onwd_evo[k+1]; evo_f_diff_eps = dyn._target - evo_final_eps; # Note that the value should have not imagnary part, so; # using np.real, just avoids the complex casting warning; fid_err_eps = self.scale_factor*np.real(; (evo_f_diff_eps.dag()*evo_f_diff_eps).tr()); else:; evo_final_eps = fwd_evo.dot(prop_eps); if k+1 < n_ts:; evo_final_eps = evo_final_eps.dot(dyn._onwd_evo[k+1]); evo_f_diff_eps = dyn._target - evo_final_eps; fid_err_eps = self.scale_factor*np.real(_trace(; evo_f",MatchSource.WIKI,docs/4.2/modules/qutip/control/fidcomp.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/control/fidcomp.html
https://qutip.org/docs/4.2/modules/qutip/control/fidcomp.html:2644,Deployability,configurat,configuration,2644,"QUENTIAL DAMAGES (INCLUDING, BUT NOT; # LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,; # DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY; # THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT; # (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE; # OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.; ###############################################################################. # @author: Alexander Pitchford; # @email1: agp1@aber.ac.uk; # @email2: alex.pitchford@gmail.com; # @organization: Aberystwyth University; # @supervisor: Daniel Burgarth. """"""; Fidelity Computer. These classes calculate the fidelity error - function to be minimised; and fidelity error gradient, which is used to direct the optimisation. They may calculate the fidelity as an intermediary step, as in some case; e.g. unitary dynamics, this is more efficient. The idea is that different methods for computing the fidelity can be tried; and compared using simple configuration switches. Note the methods in these classes were inspired by:; DYNAMO - Dynamic Framework for Quantum Optimal Control; See Machnes et.al., arXiv.1011.4874; The unitary dynamics fidelity is taken directly frm DYNAMO; The other fidelity measures are extensions, and the sources are given; in the class descriptions.; """""". import os; import warnings; import numpy as np; import scipy.sparse as sp; # import scipy.linalg as la; import timeit; # QuTiP; from qutip import Qobj; # QuTiP logging; import qutip.logging_utils as logging; logger = logging.get_logger(); # QuTiP control modules; import qutip.control.errors as errors. warnings.simplefilter('always', DeprecationWarning) #turn off filter; def _attrib_deprecation(message, stacklevel=3):; """"""; Issue deprecation warning; Using stacklevel=3 will ensure message refers the function; calling with the deprecated parameter,; """"""; warnings.warn(message, DeprecationWarning, stacklevel=stacklevel). ",MatchSource.WIKI,docs/4.2/modules/qutip/control/fidcomp.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/control/fidcomp.html
https://qutip.org/docs/4.2/modules/qutip/control/fidcomp.html:6269,Deployability,configurat,configuration,6269,"Computer. uses_onto_evo : boolean; flag to specify whether the onto_evo evolution operator; (see Dynamics) is used by the FidelityComputer. fid_err : float; Last computed value of the fidelity error. fidelity : float; Last computed value of the normalised fidelity. fidelity_current : boolean; flag to specify whether the fidelity / fid_err are based on the; current amplitude values. Set False when amplitudes change. fid_err_grad: array[num_tslot, num_ctrls] of float; Last computed values for the fidelity error gradients wrt the; control in the timeslot. grad_norm : float; Last computed value for the norm of the fidelity error gradients; (sqrt of the sum of the squares). fid_err_grad_current : boolean; flag to specify whether the fidelity / fid_err are based on the; current amplitude values. Set False when amplitudes change; """"""; def __init__(self, dynamics, params=None):; self.parent = dynamics; self.params = params; self.reset(). [docs] def reset(self):; """"""; reset any configuration data and; clear any temporarily held status data; """"""; self.log_level = self.parent.log_level; self.id_text = 'FID_COMP_BASE'; self.dimensional_norm = 1.0; self.fid_norm_func = None; self.grad_norm_func = None; self.uses_onwd_evo = False; self.uses_onto_evo = False; self.apply_params(); self.clear(). [docs] def clear(self):; """"""; clear any temporarily held status data; """"""; self.fid_err = None; self.fidelity = None; self.fid_err_grad = None; self.grad_norm = np.inf; self.fidelity_current = False; self.fid_err_grad_current = False; self.grad_norm = 0.0. [docs] def apply_params(self, params=None):; """"""; Set object attributes based on the dictionary (if any) passed in the; instantiation, or passed as a parameter; This is called during the instantiation automatically.; The key value pairs are the attribute name and value; Note: attributes are created if they do not exist already,; and are overwritten if they do.; """"""; if not params:; params = self.params. if isinstance(params, dict):; self.pa",MatchSource.WIKI,docs/4.2/modules/qutip/control/fidcomp.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/control/fidcomp.html
https://qutip.org/docs/4.2/modules/qutip/control/fidcomp.html:7657,Deployability,configurat,configuration,7657,"self.fid_err = None; self.fidelity = None; self.fid_err_grad = None; self.grad_norm = np.inf; self.fidelity_current = False; self.fid_err_grad_current = False; self.grad_norm = 0.0. [docs] def apply_params(self, params=None):; """"""; Set object attributes based on the dictionary (if any) passed in the; instantiation, or passed as a parameter; This is called during the instantiation automatically.; The key value pairs are the attribute name and value; Note: attributes are created if they do not exist already,; and are overwritten if they do.; """"""; if not params:; params = self.params. if isinstance(params, dict):; self.params = params; for key in params:; setattr(self, key, params[key]). @property; def log_level(self):; return logger.level ; ; @log_level.setter; def log_level(self, lvl):; """"""; Set the log_level attribute and set the level of the logger; that is call logger.setLevel(lvl); """"""; logger.setLevel(lvl). [docs] def init_comp(self):; """"""; initialises the computer based on the configuration of the Dynamics; """"""; # optionally implemented in subclass; pass. [docs] def get_fid_err(self):; """"""; returns the absolute distance from the maximum achievable fidelity; """"""; # must be implemented by subclass; raise errors.UsageError(; ""No method defined for getting fidelity error.""; "" Suspect base class was used where sub class should have been""). [docs] def get_fid_err_gradient(self):; """"""; Returns the normalised gradient of the fidelity error; in a (nTimeslots x n_ctrls) array wrt the timeslot control amplitude; """"""; # must be implemented by subclass; raise errors.UsageError(""No method defined for getting fidelity""; "" error gradient. Suspect base class was""; "" used where sub class should have been""). [docs] def flag_system_changed(self):; """"""; Flag fidelity and gradients as needing recalculation; """"""; self.fidelity_current = False; # Flag gradient as needing recalculating; self.fid_err_grad_current = False. @property; def uses_evo_t2end(self):; _attrib_deprecation(; ""'use",MatchSource.WIKI,docs/4.2/modules/qutip/control/fidcomp.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/control/fidcomp.html
https://qutip.org/docs/4.2/modules/qutip/control/fidcomp.html:11287,Deployability,configurat,configuration,11287," Phase options are; SU - global phase important; PSU - global phase is not important; """"""; _func_deprecation(""'set_phase_option' is deprecated. ""; ""Use phase_option property""); self._init_phase_option(phase_option); ; @property; def phase_option(self):; return self._phase_option; ; @phase_option.setter; def phase_option(self, value):; """"""; # Phase options are; # SU - global phase important; # PSU - global phase is not important; """"""; self._init_phase_option(value). def _init_phase_option(self, value):; self._phase_option = value; if value == 'PSU':; self.fid_norm_func = self.normalize_PSU; self.grad_norm_func = self.normalize_gradient_PSU; elif value == 'SU':; self.fid_norm_func = self.normalize_SU; self.grad_norm_func = self.normalize_gradient_SU; elif value is None:; raise errors.UsageError(""phase_option cannot be set to None""; "" for this FidelityComputer.""); else:; raise errors.UsageError(; ""No option for phase_option '{}'"".format(value)); ; [docs] def init_comp(self):; """"""; Check configuration and initialise the normalisation; """"""; if self.fid_norm_func is None or self.grad_norm_func is None:; raise errors.UsageError(""The phase_option must be be set""; ""for this fidelity computer""); self.init_normalization(). [docs] def flag_system_changed(self):; """"""; Flag fidelity and gradients as needing recalculation; """"""; FidelityComputer.flag_system_changed(self); # Flag the fidelity (prenormalisation) value as needing calculation; self.fidelity_prenorm_current = False. [docs] def init_normalization(self):; """"""; Calc norm of <Ufinal | Ufinal> to scale subsequent norms; When considering unitary time evolution operators, this basically; results in calculating the trace of the identity matrix; and is hence equal to the size of the target matrix; There may be situations where this is not the case, and hence it; is not assumed to be so.; The normalisation function called should be set to either the; PSU - global phase ignored; SU - global phase respected; """"""; dyn = self.parent; ",MatchSource.WIKI,docs/4.2/modules/qutip/control/fidcomp.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/control/fidcomp.html
https://qutip.org/docs/4.2/modules/qutip/control/fidcomp.html:15248,Deployability,update,updates,15248,"er.debug(""Fidelity (normalised): {}"".format(self.fidelity)). return self.fidelity. [docs] def get_fidelity_prenorm(self):; """"""; Gets the current fidelity value prior to normalisation; Note the gradient function uses this value; The value is cached, because it is used in the gradient calculation; """"""; if not self.fidelity_prenorm_current:; dyn = self.parent; k = dyn.tslot_computer._get_timeslot_for_fidelity_calc(); dyn.compute_evolution(); if dyn.oper_dtype == Qobj:; f = (dyn._onto_evo[k]*dyn._fwd_evo[k]).tr(); else:; f = _trace(dyn._onto_evo[k].dot(dyn._fwd_evo[k])); self.fidelity_prenorm = f; self.fidelity_prenorm_current = True; if dyn.stats is not None:; dyn.stats.num_fidelity_computes += 1; if self.log_level <= logging.DEBUG:; logger.debug(""Fidelity (pre normalisation): {}"".format(; self.fidelity_prenorm)); return self.fidelity_prenorm. [docs] def get_fid_err_gradient(self):; """"""; Returns the normalised gradient of the fidelity error; in a (nTimeslots x n_ctrls) array; The gradients are cached in case they are requested; mutliple times between control updates; (although this is not typically found to happen); """"""; if not self.fid_err_grad_current:; dyn = self.parent; grad_prenorm = self.compute_fid_grad(); if self.log_level <= logging.DEBUG_INTENSE:; logger.log(logging.DEBUG_INTENSE, ""pre-normalised fidelity ""; ""gradients:\n{}"".format(grad_prenorm)); # AJGP: Note this check should not be necessary if dynamics are; # unitary. However, if they are not then this gradient; # can still be used, however the interpretation is dubious; if self.get_fidelity() >= 1:; self.fid_err_grad = self.grad_norm_func(grad_prenorm); else:; self.fid_err_grad = -self.grad_norm_func(grad_prenorm). self.fid_err_grad_current = True; if dyn.stats is not None:; dyn.stats.num_grad_computes += 1. self.grad_norm = np.sqrt(np.sum(self.fid_err_grad**2)); if self.log_level <= logging.DEBUG_INTENSE:; logger.log(logging.DEBUG_INTENSE, ""Normalised fidelity error ""; ""gradients:\n{}"".format(self.fid_e",MatchSource.WIKI,docs/4.2/modules/qutip/control/fidcomp.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/control/fidcomp.html
https://qutip.org/docs/4.2/modules/qutip/control/fidcomp.html:18576,Deployability,configurat,configuration,18576,"e a distance measure for dynamics described by matrices; Note the gradient calculation is taken from:; 'Robust quantum gates for open systems via optimal control:; Markovian versus non-Markovian dynamics'; Frederik F Floether, Pierre de Fouquieres, and Sophie G Schirmer. Attributes; ----------; scale_factor : float; The fidelity error calculated is of some arbitary scale. This; factor can be used to scale the fidelity error such that it may; represent some physical measure; If None is given then it is caculated as 1/2N, where N; is the dimension of the drift, when the Dynamics are initialised.; """""". def reset(self):; FidelityComputer.reset(self); self.id_text = 'TRACEDIFF'; self.scale_factor = None; self.uses_onwd_evo = True; if not self.parent.prop_computer.grad_exact:; raise errors.UsageError(; ""This FidelityComputer can only be""; "" used with an exact gradient PropagatorComputer.""); self.apply_params(). [docs] def init_comp(self):; """"""; initialises the computer based on the configuration of the Dynamics; Calculates the scale_factor is not already set; """"""; if self.scale_factor is None:; self.scale_factor = 1.0 / (2.0*self.parent.get_drift_dim()); if self.log_level <= logging.DEBUG:; logger.debug(""Scale factor calculated as {}"".format(; self.scale_factor)). [docs] def get_fid_err(self):; """"""; Gets the absolute error in the fidelity; """"""; if not self.fidelity_current:; dyn = self.parent; dyn.compute_evolution(); n_ts = dyn.num_tslots; evo_final = dyn._fwd_evo[n_ts]; evo_f_diff = dyn._target - evo_final; if self.log_level <= logging.DEBUG_VERBOSE:; logger.log(logging.DEBUG_VERBOSE, ""Calculating TraceDiff ""; ""fidelity...\n Target:\n{}\n Evo final:\n{}\n""; ""Evo final diff:\n{}"".format(dyn._target, evo_final,; evo_f_diff)). # Calculate the fidelity error using the trace difference norm; # Note that the value should have not imagnary part, so using; # np.real, just avoids the complex casting warning; if dyn.oper_dtype == Qobj:; self.fid_err = self.scale_factor*np.real(; (",MatchSource.WIKI,docs/4.2/modules/qutip/control/fidcomp.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/control/fidcomp.html
https://qutip.org/docs/4.2/modules/qutip/control/fidcomp.html:20198,Deployability,update,updates,20198,"level <= logging.DEBUG_VERBOSE:; logger.log(logging.DEBUG_VERBOSE, ""Calculating TraceDiff ""; ""fidelity...\n Target:\n{}\n Evo final:\n{}\n""; ""Evo final diff:\n{}"".format(dyn._target, evo_final,; evo_f_diff)). # Calculate the fidelity error using the trace difference norm; # Note that the value should have not imagnary part, so using; # np.real, just avoids the complex casting warning; if dyn.oper_dtype == Qobj:; self.fid_err = self.scale_factor*np.real(; (evo_f_diff.dag()*evo_f_diff).tr()); else:; self.fid_err = self.scale_factor*np.real(_trace(; evo_f_diff.conj().T.dot(evo_f_diff))). if np.isnan(self.fid_err):; self.fid_err = np.Inf. if dyn.stats is not None:; dyn.stats.num_fidelity_computes += 1. self.fidelity_current = True; if self.log_level <= logging.DEBUG:; logger.debug(""Fidelity error: {}"".format(self.fid_err)). return self.fid_err. [docs] def get_fid_err_gradient(self):; """"""; Returns the normalised gradient of the fidelity error; in a (nTimeslots x n_ctrls) array; The gradients are cached in case they are requested; mutliple times between control updates; (although this is not typically found to happen); """"""; if not self.fid_err_grad_current:; dyn = self.parent; self.fid_err_grad = self.compute_fid_err_grad(); self.fid_err_grad_current = True; if dyn.stats is not None:; dyn.stats.num_grad_computes += 1. self.grad_norm = np.sqrt(np.sum(self.fid_err_grad**2)); if self.log_level <= logging.DEBUG_INTENSE:; logger.log(logging.DEBUG_INTENSE, ""fidelity error gradients:\n""; ""{}"".format(self.fid_err_grad)). if self.log_level <= logging.DEBUG:; logger.debug(""Gradient norm: ""; ""{} "".format(self.grad_norm)). return self.fid_err_grad. [docs] def compute_fid_err_grad(self):; """"""; Calculate exact gradient of the fidelity error function; wrt to each timeslot control amplitudes.; Uses the trace difference norm fidelity; These are returned as a (nTimeslots x n_ctrls) array; """"""; dyn = self.parent; n_ctrls = dyn.num_ctrls; n_ts = dyn.num_tslots. # create n_ts x n_ctrls zero a",MatchSource.WIKI,docs/4.2/modules/qutip/control/fidcomp.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/control/fidcomp.html
https://qutip.org/docs/4.2/modules/qutip/control/fidcomp.html:24436,Deployability,update,updated,24436,"xt = 'TDAPPROX'; self.uses_onwd_evo = True; self.scale_factor = None; self.epsilon = 0.001; self.apply_params(). [docs] def compute_fid_err_grad(self):; """"""; Calculates gradient of function wrt to each timeslot; control amplitudes. Note these gradients are not normalised; They are calulated; These are returned as a (nTimeslots x n_ctrls) array; """"""; dyn = self.parent; prop_comp = dyn.prop_computer; n_ctrls = dyn.num_ctrls; n_ts = dyn.num_tslots. if self.log_level >= logging.DEBUG:; logger.debug(""Computing fidelity error gradient""); # create n_ts x n_ctrls zero array for grad start point; grad = np.zeros([n_ts, n_ctrls]). dyn.tslot_computer.flag_all_calc_now(); dyn.compute_evolution(); curr_fid_err = self.get_fid_err(). # loop through all ctrl timeslots calculating gradients; time_st = timeit.default_timer(). for j in range(n_ctrls):; for k in range(n_ts):; fwd_evo = dyn._fwd_evo[k]; prop_eps = prop_comp._compute_diff_prop(k, j, self.epsilon); if dyn.oper_dtype == Qobj:; evo_final_eps = fwd_evo*prop_eps; if k+1 < n_ts:; evo_final_eps = evo_final_eps*dyn._onwd_evo[k+1]; evo_f_diff_eps = dyn._target - evo_final_eps; # Note that the value should have not imagnary part, so; # using np.real, just avoids the complex casting warning; fid_err_eps = self.scale_factor*np.real(; (evo_f_diff_eps.dag()*evo_f_diff_eps).tr()); else:; evo_final_eps = fwd_evo.dot(prop_eps); if k+1 < n_ts:; evo_final_eps = evo_final_eps.dot(dyn._onwd_evo[k+1]); evo_f_diff_eps = dyn._target - evo_final_eps; fid_err_eps = self.scale_factor*np.real(_trace(; evo_f_diff_eps.conj().T.dot(evo_f_diff_eps))). g = (fid_err_eps - curr_fid_err)/self.epsilon; if np.isnan(g):; g = np.Inf. grad[k, j] = g. if dyn.stats is not None:; dyn.stats.wall_time_gradient_compute += \; timeit.default_timer() - time_st. return grad. Â© Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, and A.L. Grimsmo.; Last updated on Jan 17, 2018. . Built with Sphinx using a theme provided by Read the Docs. . ",MatchSource.WIKI,docs/4.2/modules/qutip/control/fidcomp.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/control/fidcomp.html
https://qutip.org/docs/4.2/modules/qutip/control/fidcomp.html:2531,Energy Efficiency,efficient,efficient,2531,"TORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,; # SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT; # LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,; # DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY; # THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT; # (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE; # OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.; ###############################################################################. # @author: Alexander Pitchford; # @email1: agp1@aber.ac.uk; # @email2: alex.pitchford@gmail.com; # @organization: Aberystwyth University; # @supervisor: Daniel Burgarth. """"""; Fidelity Computer. These classes calculate the fidelity error - function to be minimised; and fidelity error gradient, which is used to direct the optimisation. They may calculate the fidelity as an intermediary step, as in some case; e.g. unitary dynamics, this is more efficient. The idea is that different methods for computing the fidelity can be tried; and compared using simple configuration switches. Note the methods in these classes were inspired by:; DYNAMO - Dynamic Framework for Quantum Optimal Control; See Machnes et.al., arXiv.1011.4874; The unitary dynamics fidelity is taken directly frm DYNAMO; The other fidelity measures are extensions, and the sources are given; in the class descriptions.; """""". import os; import warnings; import numpy as np; import scipy.sparse as sp; # import scipy.linalg as la; import timeit; # QuTiP; from qutip import Qobj; # QuTiP logging; import qutip.logging_utils as logging; logger = logging.get_logger(); # QuTiP control modules; import qutip.control.errors as errors. warnings.simplefilter('always', DeprecationWarning) #turn off filter; def _attrib_deprecation(message, stacklevel=3):; """"""; Issue deprecation warning; Using stacklevel=3 will ensure message refers the function; calling with the deprecated ",MatchSource.WIKI,docs/4.2/modules/qutip/control/fidcomp.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/control/fidcomp.html
https://qutip.org/docs/4.2/modules/qutip/control/fidcomp.html:3375,Integrability,message,message,3375,"n. They may calculate the fidelity as an intermediary step, as in some case; e.g. unitary dynamics, this is more efficient. The idea is that different methods for computing the fidelity can be tried; and compared using simple configuration switches. Note the methods in these classes were inspired by:; DYNAMO - Dynamic Framework for Quantum Optimal Control; See Machnes et.al., arXiv.1011.4874; The unitary dynamics fidelity is taken directly frm DYNAMO; The other fidelity measures are extensions, and the sources are given; in the class descriptions.; """""". import os; import warnings; import numpy as np; import scipy.sparse as sp; # import scipy.linalg as la; import timeit; # QuTiP; from qutip import Qobj; # QuTiP logging; import qutip.logging_utils as logging; logger = logging.get_logger(); # QuTiP control modules; import qutip.control.errors as errors. warnings.simplefilter('always', DeprecationWarning) #turn off filter; def _attrib_deprecation(message, stacklevel=3):; """"""; Issue deprecation warning; Using stacklevel=3 will ensure message refers the function; calling with the deprecated parameter,; """"""; warnings.warn(message, DeprecationWarning, stacklevel=stacklevel). def _func_deprecation(message, stacklevel=3):; """"""; Issue deprecation warning; Using stacklevel=3 will ensure message refers the function; calling with the deprecated parameter,; """"""; warnings.warn(message, DeprecationWarning, stacklevel=stacklevel); ; def _trace(A):; """"""wrapper for calculating the trace""""""; # input is an operator (Qobj, array, sparse etc), so; if isinstance(A, Qobj):; return A.tr(); elif isinstance(A, np.ndarray):; return np.trace(A); else:; #Assume A some sparse matrix; return np.sum(A.diagonal()). [docs]class FidelityComputer(object):; """"""; Base class for all Fidelity Computers.; This cannot be used directly. See subclass descriptions and choose; one appropriate for the application; Note: this must be instantiated with a Dynamics object, that is the; container for the data that the m",MatchSource.WIKI,docs/4.2/modules/qutip/control/fidcomp.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/control/fidcomp.html
https://qutip.org/docs/4.2/modules/qutip/control/fidcomp.html:3463,Integrability,message,message,3463,"n. They may calculate the fidelity as an intermediary step, as in some case; e.g. unitary dynamics, this is more efficient. The idea is that different methods for computing the fidelity can be tried; and compared using simple configuration switches. Note the methods in these classes were inspired by:; DYNAMO - Dynamic Framework for Quantum Optimal Control; See Machnes et.al., arXiv.1011.4874; The unitary dynamics fidelity is taken directly frm DYNAMO; The other fidelity measures are extensions, and the sources are given; in the class descriptions.; """""". import os; import warnings; import numpy as np; import scipy.sparse as sp; # import scipy.linalg as la; import timeit; # QuTiP; from qutip import Qobj; # QuTiP logging; import qutip.logging_utils as logging; logger = logging.get_logger(); # QuTiP control modules; import qutip.control.errors as errors. warnings.simplefilter('always', DeprecationWarning) #turn off filter; def _attrib_deprecation(message, stacklevel=3):; """"""; Issue deprecation warning; Using stacklevel=3 will ensure message refers the function; calling with the deprecated parameter,; """"""; warnings.warn(message, DeprecationWarning, stacklevel=stacklevel). def _func_deprecation(message, stacklevel=3):; """"""; Issue deprecation warning; Using stacklevel=3 will ensure message refers the function; calling with the deprecated parameter,; """"""; warnings.warn(message, DeprecationWarning, stacklevel=stacklevel); ; def _trace(A):; """"""wrapper for calculating the trace""""""; # input is an operator (Qobj, array, sparse etc), so; if isinstance(A, Qobj):; return A.tr(); elif isinstance(A, np.ndarray):; return np.trace(A); else:; #Assume A some sparse matrix; return np.sum(A.diagonal()). [docs]class FidelityComputer(object):; """"""; Base class for all Fidelity Computers.; This cannot be used directly. See subclass descriptions and choose; one appropriate for the application; Note: this must be instantiated with a Dynamics object, that is the; container for the data that the m",MatchSource.WIKI,docs/4.2/modules/qutip/control/fidcomp.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/control/fidcomp.html
https://qutip.org/docs/4.2/modules/qutip/control/fidcomp.html:3551,Integrability,message,message,3551,"ds for computing the fidelity can be tried; and compared using simple configuration switches. Note the methods in these classes were inspired by:; DYNAMO - Dynamic Framework for Quantum Optimal Control; See Machnes et.al., arXiv.1011.4874; The unitary dynamics fidelity is taken directly frm DYNAMO; The other fidelity measures are extensions, and the sources are given; in the class descriptions.; """""". import os; import warnings; import numpy as np; import scipy.sparse as sp; # import scipy.linalg as la; import timeit; # QuTiP; from qutip import Qobj; # QuTiP logging; import qutip.logging_utils as logging; logger = logging.get_logger(); # QuTiP control modules; import qutip.control.errors as errors. warnings.simplefilter('always', DeprecationWarning) #turn off filter; def _attrib_deprecation(message, stacklevel=3):; """"""; Issue deprecation warning; Using stacklevel=3 will ensure message refers the function; calling with the deprecated parameter,; """"""; warnings.warn(message, DeprecationWarning, stacklevel=stacklevel). def _func_deprecation(message, stacklevel=3):; """"""; Issue deprecation warning; Using stacklevel=3 will ensure message refers the function; calling with the deprecated parameter,; """"""; warnings.warn(message, DeprecationWarning, stacklevel=stacklevel); ; def _trace(A):; """"""wrapper for calculating the trace""""""; # input is an operator (Qobj, array, sparse etc), so; if isinstance(A, Qobj):; return A.tr(); elif isinstance(A, np.ndarray):; return np.trace(A); else:; #Assume A some sparse matrix; return np.sum(A.diagonal()). [docs]class FidelityComputer(object):; """"""; Base class for all Fidelity Computers.; This cannot be used directly. See subclass descriptions and choose; one appropriate for the application; Note: this must be instantiated with a Dynamics object, that is the; container for the data that the methods operate on. Attributes; ----------; log_level : integer; level of messaging output from the logger.; Options are attributes of qutip.logging_utils,; i",MatchSource.WIKI,docs/4.2/modules/qutip/control/fidcomp.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/control/fidcomp.html
https://qutip.org/docs/4.2/modules/qutip/control/fidcomp.html:3626,Integrability,message,message,3626,"s were inspired by:; DYNAMO - Dynamic Framework for Quantum Optimal Control; See Machnes et.al., arXiv.1011.4874; The unitary dynamics fidelity is taken directly frm DYNAMO; The other fidelity measures are extensions, and the sources are given; in the class descriptions.; """""". import os; import warnings; import numpy as np; import scipy.sparse as sp; # import scipy.linalg as la; import timeit; # QuTiP; from qutip import Qobj; # QuTiP logging; import qutip.logging_utils as logging; logger = logging.get_logger(); # QuTiP control modules; import qutip.control.errors as errors. warnings.simplefilter('always', DeprecationWarning) #turn off filter; def _attrib_deprecation(message, stacklevel=3):; """"""; Issue deprecation warning; Using stacklevel=3 will ensure message refers the function; calling with the deprecated parameter,; """"""; warnings.warn(message, DeprecationWarning, stacklevel=stacklevel). def _func_deprecation(message, stacklevel=3):; """"""; Issue deprecation warning; Using stacklevel=3 will ensure message refers the function; calling with the deprecated parameter,; """"""; warnings.warn(message, DeprecationWarning, stacklevel=stacklevel); ; def _trace(A):; """"""wrapper for calculating the trace""""""; # input is an operator (Qobj, array, sparse etc), so; if isinstance(A, Qobj):; return A.tr(); elif isinstance(A, np.ndarray):; return np.trace(A); else:; #Assume A some sparse matrix; return np.sum(A.diagonal()). [docs]class FidelityComputer(object):; """"""; Base class for all Fidelity Computers.; This cannot be used directly. See subclass descriptions and choose; one appropriate for the application; Note: this must be instantiated with a Dynamics object, that is the; container for the data that the methods operate on. Attributes; ----------; log_level : integer; level of messaging output from the logger.; Options are attributes of qutip.logging_utils,; in decreasing levels of messaging, are:; DEBUG_INTENSE, DEBUG_VERBOSE, DEBUG, INFO, WARN, ERROR, CRITICAL; Anything WARN or ab",MatchSource.WIKI,docs/4.2/modules/qutip/control/fidcomp.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/control/fidcomp.html
https://qutip.org/docs/4.2/modules/qutip/control/fidcomp.html:3714,Integrability,message,message,3714,"s were inspired by:; DYNAMO - Dynamic Framework for Quantum Optimal Control; See Machnes et.al., arXiv.1011.4874; The unitary dynamics fidelity is taken directly frm DYNAMO; The other fidelity measures are extensions, and the sources are given; in the class descriptions.; """""". import os; import warnings; import numpy as np; import scipy.sparse as sp; # import scipy.linalg as la; import timeit; # QuTiP; from qutip import Qobj; # QuTiP logging; import qutip.logging_utils as logging; logger = logging.get_logger(); # QuTiP control modules; import qutip.control.errors as errors. warnings.simplefilter('always', DeprecationWarning) #turn off filter; def _attrib_deprecation(message, stacklevel=3):; """"""; Issue deprecation warning; Using stacklevel=3 will ensure message refers the function; calling with the deprecated parameter,; """"""; warnings.warn(message, DeprecationWarning, stacklevel=stacklevel). def _func_deprecation(message, stacklevel=3):; """"""; Issue deprecation warning; Using stacklevel=3 will ensure message refers the function; calling with the deprecated parameter,; """"""; warnings.warn(message, DeprecationWarning, stacklevel=stacklevel); ; def _trace(A):; """"""wrapper for calculating the trace""""""; # input is an operator (Qobj, array, sparse etc), so; if isinstance(A, Qobj):; return A.tr(); elif isinstance(A, np.ndarray):; return np.trace(A); else:; #Assume A some sparse matrix; return np.sum(A.diagonal()). [docs]class FidelityComputer(object):; """"""; Base class for all Fidelity Computers.; This cannot be used directly. See subclass descriptions and choose; one appropriate for the application; Note: this must be instantiated with a Dynamics object, that is the; container for the data that the methods operate on. Attributes; ----------; log_level : integer; level of messaging output from the logger.; Options are attributes of qutip.logging_utils,; in decreasing levels of messaging, are:; DEBUG_INTENSE, DEBUG_VERBOSE, DEBUG, INFO, WARN, ERROR, CRITICAL; Anything WARN or ab",MatchSource.WIKI,docs/4.2/modules/qutip/control/fidcomp.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/control/fidcomp.html
https://qutip.org/docs/4.2/modules/qutip/control/fidcomp.html:3802,Integrability,message,message,3802,"es are extensions, and the sources are given; in the class descriptions.; """""". import os; import warnings; import numpy as np; import scipy.sparse as sp; # import scipy.linalg as la; import timeit; # QuTiP; from qutip import Qobj; # QuTiP logging; import qutip.logging_utils as logging; logger = logging.get_logger(); # QuTiP control modules; import qutip.control.errors as errors. warnings.simplefilter('always', DeprecationWarning) #turn off filter; def _attrib_deprecation(message, stacklevel=3):; """"""; Issue deprecation warning; Using stacklevel=3 will ensure message refers the function; calling with the deprecated parameter,; """"""; warnings.warn(message, DeprecationWarning, stacklevel=stacklevel). def _func_deprecation(message, stacklevel=3):; """"""; Issue deprecation warning; Using stacklevel=3 will ensure message refers the function; calling with the deprecated parameter,; """"""; warnings.warn(message, DeprecationWarning, stacklevel=stacklevel); ; def _trace(A):; """"""wrapper for calculating the trace""""""; # input is an operator (Qobj, array, sparse etc), so; if isinstance(A, Qobj):; return A.tr(); elif isinstance(A, np.ndarray):; return np.trace(A); else:; #Assume A some sparse matrix; return np.sum(A.diagonal()). [docs]class FidelityComputer(object):; """"""; Base class for all Fidelity Computers.; This cannot be used directly. See subclass descriptions and choose; one appropriate for the application; Note: this must be instantiated with a Dynamics object, that is the; container for the data that the methods operate on. Attributes; ----------; log_level : integer; level of messaging output from the logger.; Options are attributes of qutip.logging_utils,; in decreasing levels of messaging, are:; DEBUG_INTENSE, DEBUG_VERBOSE, DEBUG, INFO, WARN, ERROR, CRITICAL; Anything WARN or above is effectively 'quiet' execution,; assuming everything runs as expected.; The default NOTSET implies that the level will be taken from; the QuTiP settings file, which by default is WARN. dimension",MatchSource.WIKI,docs/4.2/modules/qutip/control/fidcomp.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/control/fidcomp.html
https://qutip.org/docs/4.2/modules/qutip/control/fidcomp.html:3876,Integrability,wrap,wrapper,3876,"es are extensions, and the sources are given; in the class descriptions.; """""". import os; import warnings; import numpy as np; import scipy.sparse as sp; # import scipy.linalg as la; import timeit; # QuTiP; from qutip import Qobj; # QuTiP logging; import qutip.logging_utils as logging; logger = logging.get_logger(); # QuTiP control modules; import qutip.control.errors as errors. warnings.simplefilter('always', DeprecationWarning) #turn off filter; def _attrib_deprecation(message, stacklevel=3):; """"""; Issue deprecation warning; Using stacklevel=3 will ensure message refers the function; calling with the deprecated parameter,; """"""; warnings.warn(message, DeprecationWarning, stacklevel=stacklevel). def _func_deprecation(message, stacklevel=3):; """"""; Issue deprecation warning; Using stacklevel=3 will ensure message refers the function; calling with the deprecated parameter,; """"""; warnings.warn(message, DeprecationWarning, stacklevel=stacklevel); ; def _trace(A):; """"""wrapper for calculating the trace""""""; # input is an operator (Qobj, array, sparse etc), so; if isinstance(A, Qobj):; return A.tr(); elif isinstance(A, np.ndarray):; return np.trace(A); else:; #Assume A some sparse matrix; return np.sum(A.diagonal()). [docs]class FidelityComputer(object):; """"""; Base class for all Fidelity Computers.; This cannot be used directly. See subclass descriptions and choose; one appropriate for the application; Note: this must be instantiated with a Dynamics object, that is the; container for the data that the methods operate on. Attributes; ----------; log_level : integer; level of messaging output from the logger.; Options are attributes of qutip.logging_utils,; in decreasing levels of messaging, are:; DEBUG_INTENSE, DEBUG_VERBOSE, DEBUG, INFO, WARN, ERROR, CRITICAL; Anything WARN or above is effectively 'quiet' execution,; assuming everything runs as expected.; The default NOTSET implies that the level will be taken from; the QuTiP settings file, which by default is WARN. dimension",MatchSource.WIKI,docs/4.2/modules/qutip/control/fidcomp.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/control/fidcomp.html
https://qutip.org/docs/4.2/modules/qutip/control/fidcomp.html:2644,Modifiability,config,configuration,2644,"QUENTIAL DAMAGES (INCLUDING, BUT NOT; # LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,; # DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY; # THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT; # (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE; # OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.; ###############################################################################. # @author: Alexander Pitchford; # @email1: agp1@aber.ac.uk; # @email2: alex.pitchford@gmail.com; # @organization: Aberystwyth University; # @supervisor: Daniel Burgarth. """"""; Fidelity Computer. These classes calculate the fidelity error - function to be minimised; and fidelity error gradient, which is used to direct the optimisation. They may calculate the fidelity as an intermediary step, as in some case; e.g. unitary dynamics, this is more efficient. The idea is that different methods for computing the fidelity can be tried; and compared using simple configuration switches. Note the methods in these classes were inspired by:; DYNAMO - Dynamic Framework for Quantum Optimal Control; See Machnes et.al., arXiv.1011.4874; The unitary dynamics fidelity is taken directly frm DYNAMO; The other fidelity measures are extensions, and the sources are given; in the class descriptions.; """""". import os; import warnings; import numpy as np; import scipy.sparse as sp; # import scipy.linalg as la; import timeit; # QuTiP; from qutip import Qobj; # QuTiP logging; import qutip.logging_utils as logging; logger = logging.get_logger(); # QuTiP control modules; import qutip.control.errors as errors. warnings.simplefilter('always', DeprecationWarning) #turn off filter; def _attrib_deprecation(message, stacklevel=3):; """"""; Issue deprecation warning; Using stacklevel=3 will ensure message refers the function; calling with the deprecated parameter,; """"""; warnings.warn(message, DeprecationWarning, stacklevel=stacklevel). ",MatchSource.WIKI,docs/4.2/modules/qutip/control/fidcomp.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/control/fidcomp.html
https://qutip.org/docs/4.2/modules/qutip/control/fidcomp.html:6269,Modifiability,config,configuration,6269,"Computer. uses_onto_evo : boolean; flag to specify whether the onto_evo evolution operator; (see Dynamics) is used by the FidelityComputer. fid_err : float; Last computed value of the fidelity error. fidelity : float; Last computed value of the normalised fidelity. fidelity_current : boolean; flag to specify whether the fidelity / fid_err are based on the; current amplitude values. Set False when amplitudes change. fid_err_grad: array[num_tslot, num_ctrls] of float; Last computed values for the fidelity error gradients wrt the; control in the timeslot. grad_norm : float; Last computed value for the norm of the fidelity error gradients; (sqrt of the sum of the squares). fid_err_grad_current : boolean; flag to specify whether the fidelity / fid_err are based on the; current amplitude values. Set False when amplitudes change; """"""; def __init__(self, dynamics, params=None):; self.parent = dynamics; self.params = params; self.reset(). [docs] def reset(self):; """"""; reset any configuration data and; clear any temporarily held status data; """"""; self.log_level = self.parent.log_level; self.id_text = 'FID_COMP_BASE'; self.dimensional_norm = 1.0; self.fid_norm_func = None; self.grad_norm_func = None; self.uses_onwd_evo = False; self.uses_onto_evo = False; self.apply_params(); self.clear(). [docs] def clear(self):; """"""; clear any temporarily held status data; """"""; self.fid_err = None; self.fidelity = None; self.fid_err_grad = None; self.grad_norm = np.inf; self.fidelity_current = False; self.fid_err_grad_current = False; self.grad_norm = 0.0. [docs] def apply_params(self, params=None):; """"""; Set object attributes based on the dictionary (if any) passed in the; instantiation, or passed as a parameter; This is called during the instantiation automatically.; The key value pairs are the attribute name and value; Note: attributes are created if they do not exist already,; and are overwritten if they do.; """"""; if not params:; params = self.params. if isinstance(params, dict):; self.pa",MatchSource.WIKI,docs/4.2/modules/qutip/control/fidcomp.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/control/fidcomp.html
https://qutip.org/docs/4.2/modules/qutip/control/fidcomp.html:7657,Modifiability,config,configuration,7657,"self.fid_err = None; self.fidelity = None; self.fid_err_grad = None; self.grad_norm = np.inf; self.fidelity_current = False; self.fid_err_grad_current = False; self.grad_norm = 0.0. [docs] def apply_params(self, params=None):; """"""; Set object attributes based on the dictionary (if any) passed in the; instantiation, or passed as a parameter; This is called during the instantiation automatically.; The key value pairs are the attribute name and value; Note: attributes are created if they do not exist already,; and are overwritten if they do.; """"""; if not params:; params = self.params. if isinstance(params, dict):; self.params = params; for key in params:; setattr(self, key, params[key]). @property; def log_level(self):; return logger.level ; ; @log_level.setter; def log_level(self, lvl):; """"""; Set the log_level attribute and set the level of the logger; that is call logger.setLevel(lvl); """"""; logger.setLevel(lvl). [docs] def init_comp(self):; """"""; initialises the computer based on the configuration of the Dynamics; """"""; # optionally implemented in subclass; pass. [docs] def get_fid_err(self):; """"""; returns the absolute distance from the maximum achievable fidelity; """"""; # must be implemented by subclass; raise errors.UsageError(; ""No method defined for getting fidelity error.""; "" Suspect base class was used where sub class should have been""). [docs] def get_fid_err_gradient(self):; """"""; Returns the normalised gradient of the fidelity error; in a (nTimeslots x n_ctrls) array wrt the timeslot control amplitude; """"""; # must be implemented by subclass; raise errors.UsageError(""No method defined for getting fidelity""; "" error gradient. Suspect base class was""; "" used where sub class should have been""). [docs] def flag_system_changed(self):; """"""; Flag fidelity and gradients as needing recalculation; """"""; self.fidelity_current = False; # Flag gradient as needing recalculating; self.fid_err_grad_current = False. @property; def uses_evo_t2end(self):; _attrib_deprecation(; ""'use",MatchSource.WIKI,docs/4.2/modules/qutip/control/fidcomp.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/control/fidcomp.html
https://qutip.org/docs/4.2/modules/qutip/control/fidcomp.html:11287,Modifiability,config,configuration,11287," Phase options are; SU - global phase important; PSU - global phase is not important; """"""; _func_deprecation(""'set_phase_option' is deprecated. ""; ""Use phase_option property""); self._init_phase_option(phase_option); ; @property; def phase_option(self):; return self._phase_option; ; @phase_option.setter; def phase_option(self, value):; """"""; # Phase options are; # SU - global phase important; # PSU - global phase is not important; """"""; self._init_phase_option(value). def _init_phase_option(self, value):; self._phase_option = value; if value == 'PSU':; self.fid_norm_func = self.normalize_PSU; self.grad_norm_func = self.normalize_gradient_PSU; elif value == 'SU':; self.fid_norm_func = self.normalize_SU; self.grad_norm_func = self.normalize_gradient_SU; elif value is None:; raise errors.UsageError(""phase_option cannot be set to None""; "" for this FidelityComputer.""); else:; raise errors.UsageError(; ""No option for phase_option '{}'"".format(value)); ; [docs] def init_comp(self):; """"""; Check configuration and initialise the normalisation; """"""; if self.fid_norm_func is None or self.grad_norm_func is None:; raise errors.UsageError(""The phase_option must be be set""; ""for this fidelity computer""); self.init_normalization(). [docs] def flag_system_changed(self):; """"""; Flag fidelity and gradients as needing recalculation; """"""; FidelityComputer.flag_system_changed(self); # Flag the fidelity (prenormalisation) value as needing calculation; self.fidelity_prenorm_current = False. [docs] def init_normalization(self):; """"""; Calc norm of <Ufinal | Ufinal> to scale subsequent norms; When considering unitary time evolution operators, this basically; results in calculating the trace of the identity matrix; and is hence equal to the size of the target matrix; There may be situations where this is not the case, and hence it; is not assumed to be so.; The normalisation function called should be set to either the; PSU - global phase ignored; SU - global phase respected; """"""; dyn = self.parent; ",MatchSource.WIKI,docs/4.2/modules/qutip/control/fidcomp.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/control/fidcomp.html
https://qutip.org/docs/4.2/modules/qutip/control/fidcomp.html:13993,Modifiability,config,config,13993,"""""""; grad_normalized = np.real(grad) / self.dimensional_norm. return grad_normalized. [docs] def normalize_PSU(self, A):; """""". """"""; try:; if A.shape[0] == A.shape[1]:; # input is an operator (Qobj, array, sparse etc), so; norm = _trace(A); else:; raise TypeError(""Cannot compute trace (not square)""); except:; # assume input is already scalar and hence assumed; # to be the prenormalised scalar value, e.g. fidelity; norm = A; return np.abs(norm) / self.dimensional_norm. [docs] def normalize_gradient_PSU(self, grad):; """"""; Normalise the gradient matrix passed as grad; This PSU version is independent of global phase; """"""; fid_pn = self.get_fidelity_prenorm(); grad_normalized = np.real(grad * np.exp(-1j * np.angle(fid_pn)) /; self.dimensional_norm); return grad_normalized. [docs] def get_fid_err(self):; """"""; Gets the absolute error in the fidelity; """"""; return np.abs(1 - self.get_fidelity()). [docs] def get_fidelity(self):; """"""; Gets the appropriately normalised fidelity value; The normalisation is determined by the fid_norm_func pointer; which should be set in the config; """"""; if not self.fidelity_current:; self.fidelity = \; self.fid_norm_func(self.get_fidelity_prenorm()); self.fidelity_current = True; if self.log_level <= logging.DEBUG:; logger.debug(""Fidelity (normalised): {}"".format(self.fidelity)). return self.fidelity. [docs] def get_fidelity_prenorm(self):; """"""; Gets the current fidelity value prior to normalisation; Note the gradient function uses this value; The value is cached, because it is used in the gradient calculation; """"""; if not self.fidelity_prenorm_current:; dyn = self.parent; k = dyn.tslot_computer._get_timeslot_for_fidelity_calc(); dyn.compute_evolution(); if dyn.oper_dtype == Qobj:; f = (dyn._onto_evo[k]*dyn._fwd_evo[k]).tr(); else:; f = _trace(dyn._onto_evo[k].dot(dyn._fwd_evo[k])); self.fidelity_prenorm = f; self.fidelity_prenorm_current = True; if dyn.stats is not None:; dyn.stats.num_fidelity_computes += 1; if self.log_level <= logging.DEBUG:; ",MatchSource.WIKI,docs/4.2/modules/qutip/control/fidcomp.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/control/fidcomp.html
https://qutip.org/docs/4.2/modules/qutip/control/fidcomp.html:18576,Modifiability,config,configuration,18576,"e a distance measure for dynamics described by matrices; Note the gradient calculation is taken from:; 'Robust quantum gates for open systems via optimal control:; Markovian versus non-Markovian dynamics'; Frederik F Floether, Pierre de Fouquieres, and Sophie G Schirmer. Attributes; ----------; scale_factor : float; The fidelity error calculated is of some arbitary scale. This; factor can be used to scale the fidelity error such that it may; represent some physical measure; If None is given then it is caculated as 1/2N, where N; is the dimension of the drift, when the Dynamics are initialised.; """""". def reset(self):; FidelityComputer.reset(self); self.id_text = 'TRACEDIFF'; self.scale_factor = None; self.uses_onwd_evo = True; if not self.parent.prop_computer.grad_exact:; raise errors.UsageError(; ""This FidelityComputer can only be""; "" used with an exact gradient PropagatorComputer.""); self.apply_params(). [docs] def init_comp(self):; """"""; initialises the computer based on the configuration of the Dynamics; Calculates the scale_factor is not already set; """"""; if self.scale_factor is None:; self.scale_factor = 1.0 / (2.0*self.parent.get_drift_dim()); if self.log_level <= logging.DEBUG:; logger.debug(""Scale factor calculated as {}"".format(; self.scale_factor)). [docs] def get_fid_err(self):; """"""; Gets the absolute error in the fidelity; """"""; if not self.fidelity_current:; dyn = self.parent; dyn.compute_evolution(); n_ts = dyn.num_tslots; evo_final = dyn._fwd_evo[n_ts]; evo_f_diff = dyn._target - evo_final; if self.log_level <= logging.DEBUG_VERBOSE:; logger.log(logging.DEBUG_VERBOSE, ""Calculating TraceDiff ""; ""fidelity...\n Target:\n{}\n Evo final:\n{}\n""; ""Evo final diff:\n{}"".format(dyn._target, evo_final,; evo_f_diff)). # Calculate the fidelity error using the trace difference norm; # Note that the value should have not imagnary part, so using; # np.real, just avoids the complex casting warning; if dyn.oper_dtype == Qobj:; self.fid_err = self.scale_factor*np.real(; (",MatchSource.WIKI,docs/4.2/modules/qutip/control/fidcomp.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/control/fidcomp.html
https://qutip.org/docs/4.2/modules/qutip/control/fidcomp.html:14417,Performance,cache,cached,14417,"ensional_norm. [docs] def normalize_gradient_PSU(self, grad):; """"""; Normalise the gradient matrix passed as grad; This PSU version is independent of global phase; """"""; fid_pn = self.get_fidelity_prenorm(); grad_normalized = np.real(grad * np.exp(-1j * np.angle(fid_pn)) /; self.dimensional_norm); return grad_normalized. [docs] def get_fid_err(self):; """"""; Gets the absolute error in the fidelity; """"""; return np.abs(1 - self.get_fidelity()). [docs] def get_fidelity(self):; """"""; Gets the appropriately normalised fidelity value; The normalisation is determined by the fid_norm_func pointer; which should be set in the config; """"""; if not self.fidelity_current:; self.fidelity = \; self.fid_norm_func(self.get_fidelity_prenorm()); self.fidelity_current = True; if self.log_level <= logging.DEBUG:; logger.debug(""Fidelity (normalised): {}"".format(self.fidelity)). return self.fidelity. [docs] def get_fidelity_prenorm(self):; """"""; Gets the current fidelity value prior to normalisation; Note the gradient function uses this value; The value is cached, because it is used in the gradient calculation; """"""; if not self.fidelity_prenorm_current:; dyn = self.parent; k = dyn.tslot_computer._get_timeslot_for_fidelity_calc(); dyn.compute_evolution(); if dyn.oper_dtype == Qobj:; f = (dyn._onto_evo[k]*dyn._fwd_evo[k]).tr(); else:; f = _trace(dyn._onto_evo[k].dot(dyn._fwd_evo[k])); self.fidelity_prenorm = f; self.fidelity_prenorm_current = True; if dyn.stats is not None:; dyn.stats.num_fidelity_computes += 1; if self.log_level <= logging.DEBUG:; logger.debug(""Fidelity (pre normalisation): {}"".format(; self.fidelity_prenorm)); return self.fidelity_prenorm. [docs] def get_fid_err_gradient(self):; """"""; Returns the normalised gradient of the fidelity error; in a (nTimeslots x n_ctrls) array; The gradients are cached in case they are requested; mutliple times between control updates; (although this is not typically found to happen); """"""; if not self.fid_err_grad_current:; dyn = self.parent; grad_pre",MatchSource.WIKI,docs/4.2/modules/qutip/control/fidcomp.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/control/fidcomp.html
https://qutip.org/docs/4.2/modules/qutip/control/fidcomp.html:15182,Performance,cache,cached,15182,"er.debug(""Fidelity (normalised): {}"".format(self.fidelity)). return self.fidelity. [docs] def get_fidelity_prenorm(self):; """"""; Gets the current fidelity value prior to normalisation; Note the gradient function uses this value; The value is cached, because it is used in the gradient calculation; """"""; if not self.fidelity_prenorm_current:; dyn = self.parent; k = dyn.tslot_computer._get_timeslot_for_fidelity_calc(); dyn.compute_evolution(); if dyn.oper_dtype == Qobj:; f = (dyn._onto_evo[k]*dyn._fwd_evo[k]).tr(); else:; f = _trace(dyn._onto_evo[k].dot(dyn._fwd_evo[k])); self.fidelity_prenorm = f; self.fidelity_prenorm_current = True; if dyn.stats is not None:; dyn.stats.num_fidelity_computes += 1; if self.log_level <= logging.DEBUG:; logger.debug(""Fidelity (pre normalisation): {}"".format(; self.fidelity_prenorm)); return self.fidelity_prenorm. [docs] def get_fid_err_gradient(self):; """"""; Returns the normalised gradient of the fidelity error; in a (nTimeslots x n_ctrls) array; The gradients are cached in case they are requested; mutliple times between control updates; (although this is not typically found to happen); """"""; if not self.fid_err_grad_current:; dyn = self.parent; grad_prenorm = self.compute_fid_grad(); if self.log_level <= logging.DEBUG_INTENSE:; logger.log(logging.DEBUG_INTENSE, ""pre-normalised fidelity ""; ""gradients:\n{}"".format(grad_prenorm)); # AJGP: Note this check should not be necessary if dynamics are; # unitary. However, if they are not then this gradient; # can still be used, however the interpretation is dubious; if self.get_fidelity() >= 1:; self.fid_err_grad = self.grad_norm_func(grad_prenorm); else:; self.fid_err_grad = -self.grad_norm_func(grad_prenorm). self.fid_err_grad_current = True; if dyn.stats is not None:; dyn.stats.num_grad_computes += 1. self.grad_norm = np.sqrt(np.sum(self.fid_err_grad**2)); if self.log_level <= logging.DEBUG_INTENSE:; logger.log(logging.DEBUG_INTENSE, ""Normalised fidelity error ""; ""gradients:\n{}"".format(self.fid_e",MatchSource.WIKI,docs/4.2/modules/qutip/control/fidcomp.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/control/fidcomp.html
https://qutip.org/docs/4.2/modules/qutip/control/fidcomp.html:20132,Performance,cache,cached,20132,"level <= logging.DEBUG_VERBOSE:; logger.log(logging.DEBUG_VERBOSE, ""Calculating TraceDiff ""; ""fidelity...\n Target:\n{}\n Evo final:\n{}\n""; ""Evo final diff:\n{}"".format(dyn._target, evo_final,; evo_f_diff)). # Calculate the fidelity error using the trace difference norm; # Note that the value should have not imagnary part, so using; # np.real, just avoids the complex casting warning; if dyn.oper_dtype == Qobj:; self.fid_err = self.scale_factor*np.real(; (evo_f_diff.dag()*evo_f_diff).tr()); else:; self.fid_err = self.scale_factor*np.real(_trace(; evo_f_diff.conj().T.dot(evo_f_diff))). if np.isnan(self.fid_err):; self.fid_err = np.Inf. if dyn.stats is not None:; dyn.stats.num_fidelity_computes += 1. self.fidelity_current = True; if self.log_level <= logging.DEBUG:; logger.debug(""Fidelity error: {}"".format(self.fid_err)). return self.fid_err. [docs] def get_fid_err_gradient(self):; """"""; Returns the normalised gradient of the fidelity error; in a (nTimeslots x n_ctrls) array; The gradients are cached in case they are requested; mutliple times between control updates; (although this is not typically found to happen); """"""; if not self.fid_err_grad_current:; dyn = self.parent; self.fid_err_grad = self.compute_fid_err_grad(); self.fid_err_grad_current = True; if dyn.stats is not None:; dyn.stats.num_grad_computes += 1. self.grad_norm = np.sqrt(np.sum(self.fid_err_grad**2)); if self.log_level <= logging.DEBUG_INTENSE:; logger.log(logging.DEBUG_INTENSE, ""fidelity error gradients:\n""; ""{}"".format(self.fid_err_grad)). if self.log_level <= logging.DEBUG:; logger.debug(""Gradient norm: ""; ""{} "".format(self.grad_norm)). return self.fid_err_grad. [docs] def compute_fid_err_grad(self):; """"""; Calculate exact gradient of the fidelity error function; wrt to each timeslot control amplitudes.; Uses the trace difference norm fidelity; These are returned as a (nTimeslots x n_ctrls) array; """"""; dyn = self.parent; n_ctrls = dyn.num_ctrls; n_ts = dyn.num_tslots. # create n_ts x n_ctrls zero a",MatchSource.WIKI,docs/4.2/modules/qutip/control/fidcomp.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/control/fidcomp.html
https://qutip.org/docs/4.2/modules/qutip/control/fidcomp.html:19478,Safety,avoid,avoids,19478,"params(). [docs] def init_comp(self):; """"""; initialises the computer based on the configuration of the Dynamics; Calculates the scale_factor is not already set; """"""; if self.scale_factor is None:; self.scale_factor = 1.0 / (2.0*self.parent.get_drift_dim()); if self.log_level <= logging.DEBUG:; logger.debug(""Scale factor calculated as {}"".format(; self.scale_factor)). [docs] def get_fid_err(self):; """"""; Gets the absolute error in the fidelity; """"""; if not self.fidelity_current:; dyn = self.parent; dyn.compute_evolution(); n_ts = dyn.num_tslots; evo_final = dyn._fwd_evo[n_ts]; evo_f_diff = dyn._target - evo_final; if self.log_level <= logging.DEBUG_VERBOSE:; logger.log(logging.DEBUG_VERBOSE, ""Calculating TraceDiff ""; ""fidelity...\n Target:\n{}\n Evo final:\n{}\n""; ""Evo final diff:\n{}"".format(dyn._target, evo_final,; evo_f_diff)). # Calculate the fidelity error using the trace difference norm; # Note that the value should have not imagnary part, so using; # np.real, just avoids the complex casting warning; if dyn.oper_dtype == Qobj:; self.fid_err = self.scale_factor*np.real(; (evo_f_diff.dag()*evo_f_diff).tr()); else:; self.fid_err = self.scale_factor*np.real(_trace(; evo_f_diff.conj().T.dot(evo_f_diff))). if np.isnan(self.fid_err):; self.fid_err = np.Inf. if dyn.stats is not None:; dyn.stats.num_fidelity_computes += 1. self.fidelity_current = True; if self.log_level <= logging.DEBUG:; logger.debug(""Fidelity error: {}"".format(self.fid_err)). return self.fid_err. [docs] def get_fid_err_gradient(self):; """"""; Returns the normalised gradient of the fidelity error; in a (nTimeslots x n_ctrls) array; The gradients are cached in case they are requested; mutliple times between control updates; (although this is not typically found to happen); """"""; if not self.fid_err_grad_current:; dyn = self.parent; self.fid_err_grad = self.compute_fid_err_grad(); self.fid_err_grad_current = True; if dyn.stats is not None:; dyn.stats.num_grad_computes += 1. self.grad_norm = np.sqrt(np.sum(se",MatchSource.WIKI,docs/4.2/modules/qutip/control/fidcomp.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/control/fidcomp.html
https://qutip.org/docs/4.2/modules/qutip/control/fidcomp.html:21697,Safety,avoid,avoids,21697,"ent norm: ""; ""{} "".format(self.grad_norm)). return self.fid_err_grad. [docs] def compute_fid_err_grad(self):; """"""; Calculate exact gradient of the fidelity error function; wrt to each timeslot control amplitudes.; Uses the trace difference norm fidelity; These are returned as a (nTimeslots x n_ctrls) array; """"""; dyn = self.parent; n_ctrls = dyn.num_ctrls; n_ts = dyn.num_tslots. # create n_ts x n_ctrls zero array for grad start point; grad = np.zeros([n_ts, n_ctrls]). dyn.tslot_computer.flag_all_calc_now(); dyn.compute_evolution(). # loop through all ctrl timeslots calculating gradients; time_st = timeit.default_timer(). evo_final = dyn._fwd_evo[n_ts]; evo_f_diff = dyn._target - evo_final; for j in range(n_ctrls):; for k in range(n_ts):; fwd_evo = dyn._fwd_evo[k]; if dyn.oper_dtype == Qobj:; evo_grad = dyn._get_prop_grad(k, j)*fwd_evo; if k+1 < n_ts:; evo_grad = dyn._onwd_evo[k+1]*evo_grad; # Note that the value should have not imagnary part, so; # using np.real, just avoids the complex casting warning; g = -2*self.scale_factor*np.real(; (evo_f_diff.dag()*evo_grad).tr()); else:; evo_grad = dyn._get_prop_grad(k, j).dot(fwd_evo); if k+1 < n_ts:; evo_grad = dyn._onwd_evo[k+1].dot(evo_grad); g = -2*self.scale_factor*np.real(_trace(; evo_f_diff.conj().T.dot(evo_grad))); if np.isnan(g):; g = np.Inf. grad[k, j] = g; if dyn.stats is not None:; dyn.stats.wall_time_gradient_compute += \; timeit.default_timer() - time_st; return grad. [docs]class FidCompTraceDiffApprox(FidCompTraceDiff):; """"""; As FidCompTraceDiff, except uses the finite difference method to; compute approximate gradients. Attributes; ----------; epsilon : float; control amplitude offset to use when approximating the gradient wrt; a timeslot control amplitude; ; """"""; def reset(self):; FidelityComputer.reset(self); self.id_text = 'TDAPPROX'; self.uses_onwd_evo = True; self.scale_factor = None; self.epsilon = 0.001; self.apply_params(). [docs] def compute_fid_err_grad(self):; """"""; Calculates gradient of function wr",MatchSource.WIKI,docs/4.2/modules/qutip/control/fidcomp.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/control/fidcomp.html
https://qutip.org/docs/4.2/modules/qutip/control/fidcomp.html:23734,Safety,avoid,avoids,23734,"xt = 'TDAPPROX'; self.uses_onwd_evo = True; self.scale_factor = None; self.epsilon = 0.001; self.apply_params(). [docs] def compute_fid_err_grad(self):; """"""; Calculates gradient of function wrt to each timeslot; control amplitudes. Note these gradients are not normalised; They are calulated; These are returned as a (nTimeslots x n_ctrls) array; """"""; dyn = self.parent; prop_comp = dyn.prop_computer; n_ctrls = dyn.num_ctrls; n_ts = dyn.num_tslots. if self.log_level >= logging.DEBUG:; logger.debug(""Computing fidelity error gradient""); # create n_ts x n_ctrls zero array for grad start point; grad = np.zeros([n_ts, n_ctrls]). dyn.tslot_computer.flag_all_calc_now(); dyn.compute_evolution(); curr_fid_err = self.get_fid_err(). # loop through all ctrl timeslots calculating gradients; time_st = timeit.default_timer(). for j in range(n_ctrls):; for k in range(n_ts):; fwd_evo = dyn._fwd_evo[k]; prop_eps = prop_comp._compute_diff_prop(k, j, self.epsilon); if dyn.oper_dtype == Qobj:; evo_final_eps = fwd_evo*prop_eps; if k+1 < n_ts:; evo_final_eps = evo_final_eps*dyn._onwd_evo[k+1]; evo_f_diff_eps = dyn._target - evo_final_eps; # Note that the value should have not imagnary part, so; # using np.real, just avoids the complex casting warning; fid_err_eps = self.scale_factor*np.real(; (evo_f_diff_eps.dag()*evo_f_diff_eps).tr()); else:; evo_final_eps = fwd_evo.dot(prop_eps); if k+1 < n_ts:; evo_final_eps = evo_final_eps.dot(dyn._onwd_evo[k+1]); evo_f_diff_eps = dyn._target - evo_final_eps; fid_err_eps = self.scale_factor*np.real(_trace(; evo_f_diff_eps.conj().T.dot(evo_f_diff_eps))). g = (fid_err_eps - curr_fid_err)/self.epsilon; if np.isnan(g):; g = np.Inf. grad[k, j] = g. if dyn.stats is not None:; dyn.stats.wall_time_gradient_compute += \; timeit.default_timer() - time_st. return grad. Â© Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, and A.L. Grimsmo.; Last updated on Jan 17, 2018. . Built with Sphinx using a theme provided by Read the Docs. . ",MatchSource.WIKI,docs/4.2/modules/qutip/control/fidcomp.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/control/fidcomp.html
https://qutip.org/docs/4.2/modules/qutip/control/fidcomp.html:3138,Testability,log,logging,3138,"d; # @email1: agp1@aber.ac.uk; # @email2: alex.pitchford@gmail.com; # @organization: Aberystwyth University; # @supervisor: Daniel Burgarth. """"""; Fidelity Computer. These classes calculate the fidelity error - function to be minimised; and fidelity error gradient, which is used to direct the optimisation. They may calculate the fidelity as an intermediary step, as in some case; e.g. unitary dynamics, this is more efficient. The idea is that different methods for computing the fidelity can be tried; and compared using simple configuration switches. Note the methods in these classes were inspired by:; DYNAMO - Dynamic Framework for Quantum Optimal Control; See Machnes et.al., arXiv.1011.4874; The unitary dynamics fidelity is taken directly frm DYNAMO; The other fidelity measures are extensions, and the sources are given; in the class descriptions.; """""". import os; import warnings; import numpy as np; import scipy.sparse as sp; # import scipy.linalg as la; import timeit; # QuTiP; from qutip import Qobj; # QuTiP logging; import qutip.logging_utils as logging; logger = logging.get_logger(); # QuTiP control modules; import qutip.control.errors as errors. warnings.simplefilter('always', DeprecationWarning) #turn off filter; def _attrib_deprecation(message, stacklevel=3):; """"""; Issue deprecation warning; Using stacklevel=3 will ensure message refers the function; calling with the deprecated parameter,; """"""; warnings.warn(message, DeprecationWarning, stacklevel=stacklevel). def _func_deprecation(message, stacklevel=3):; """"""; Issue deprecation warning; Using stacklevel=3 will ensure message refers the function; calling with the deprecated parameter,; """"""; warnings.warn(message, DeprecationWarning, stacklevel=stacklevel); ; def _trace(A):; """"""wrapper for calculating the trace""""""; # input is an operator (Qobj, array, sparse etc), so; if isinstance(A, Qobj):; return A.tr(); elif isinstance(A, np.ndarray):; return np.trace(A); else:; #Assume A some sparse matrix; return np.sum(A.",MatchSource.WIKI,docs/4.2/modules/qutip/control/fidcomp.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/control/fidcomp.html
https://qutip.org/docs/4.2/modules/qutip/control/fidcomp.html:3177,Testability,log,logging,3177," # @organization: Aberystwyth University; # @supervisor: Daniel Burgarth. """"""; Fidelity Computer. These classes calculate the fidelity error - function to be minimised; and fidelity error gradient, which is used to direct the optimisation. They may calculate the fidelity as an intermediary step, as in some case; e.g. unitary dynamics, this is more efficient. The idea is that different methods for computing the fidelity can be tried; and compared using simple configuration switches. Note the methods in these classes were inspired by:; DYNAMO - Dynamic Framework for Quantum Optimal Control; See Machnes et.al., arXiv.1011.4874; The unitary dynamics fidelity is taken directly frm DYNAMO; The other fidelity measures are extensions, and the sources are given; in the class descriptions.; """""". import os; import warnings; import numpy as np; import scipy.sparse as sp; # import scipy.linalg as la; import timeit; # QuTiP; from qutip import Qobj; # QuTiP logging; import qutip.logging_utils as logging; logger = logging.get_logger(); # QuTiP control modules; import qutip.control.errors as errors. warnings.simplefilter('always', DeprecationWarning) #turn off filter; def _attrib_deprecation(message, stacklevel=3):; """"""; Issue deprecation warning; Using stacklevel=3 will ensure message refers the function; calling with the deprecated parameter,; """"""; warnings.warn(message, DeprecationWarning, stacklevel=stacklevel). def _func_deprecation(message, stacklevel=3):; """"""; Issue deprecation warning; Using stacklevel=3 will ensure message refers the function; calling with the deprecated parameter,; """"""; warnings.warn(message, DeprecationWarning, stacklevel=stacklevel); ; def _trace(A):; """"""wrapper for calculating the trace""""""; # input is an operator (Qobj, array, sparse etc), so; if isinstance(A, Qobj):; return A.tr(); elif isinstance(A, np.ndarray):; return np.trace(A); else:; #Assume A some sparse matrix; return np.sum(A.diagonal()). [docs]class FidelityComputer(object):; """"""; Base class ",MatchSource.WIKI,docs/4.2/modules/qutip/control/fidcomp.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/control/fidcomp.html
https://qutip.org/docs/4.2/modules/qutip/control/fidcomp.html:3186,Testability,log,logger,3186," # @organization: Aberystwyth University; # @supervisor: Daniel Burgarth. """"""; Fidelity Computer. These classes calculate the fidelity error - function to be minimised; and fidelity error gradient, which is used to direct the optimisation. They may calculate the fidelity as an intermediary step, as in some case; e.g. unitary dynamics, this is more efficient. The idea is that different methods for computing the fidelity can be tried; and compared using simple configuration switches. Note the methods in these classes were inspired by:; DYNAMO - Dynamic Framework for Quantum Optimal Control; See Machnes et.al., arXiv.1011.4874; The unitary dynamics fidelity is taken directly frm DYNAMO; The other fidelity measures are extensions, and the sources are given; in the class descriptions.; """""". import os; import warnings; import numpy as np; import scipy.sparse as sp; # import scipy.linalg as la; import timeit; # QuTiP; from qutip import Qobj; # QuTiP logging; import qutip.logging_utils as logging; logger = logging.get_logger(); # QuTiP control modules; import qutip.control.errors as errors. warnings.simplefilter('always', DeprecationWarning) #turn off filter; def _attrib_deprecation(message, stacklevel=3):; """"""; Issue deprecation warning; Using stacklevel=3 will ensure message refers the function; calling with the deprecated parameter,; """"""; warnings.warn(message, DeprecationWarning, stacklevel=stacklevel). def _func_deprecation(message, stacklevel=3):; """"""; Issue deprecation warning; Using stacklevel=3 will ensure message refers the function; calling with the deprecated parameter,; """"""; warnings.warn(message, DeprecationWarning, stacklevel=stacklevel); ; def _trace(A):; """"""wrapper for calculating the trace""""""; # input is an operator (Qobj, array, sparse etc), so; if isinstance(A, Qobj):; return A.tr(); elif isinstance(A, np.ndarray):; return np.trace(A); else:; #Assume A some sparse matrix; return np.sum(A.diagonal()). [docs]class FidelityComputer(object):; """"""; Base class ",MatchSource.WIKI,docs/4.2/modules/qutip/control/fidcomp.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/control/fidcomp.html
https://qutip.org/docs/4.2/modules/qutip/control/fidcomp.html:3195,Testability,log,logging,3195," # @organization: Aberystwyth University; # @supervisor: Daniel Burgarth. """"""; Fidelity Computer. These classes calculate the fidelity error - function to be minimised; and fidelity error gradient, which is used to direct the optimisation. They may calculate the fidelity as an intermediary step, as in some case; e.g. unitary dynamics, this is more efficient. The idea is that different methods for computing the fidelity can be tried; and compared using simple configuration switches. Note the methods in these classes were inspired by:; DYNAMO - Dynamic Framework for Quantum Optimal Control; See Machnes et.al., arXiv.1011.4874; The unitary dynamics fidelity is taken directly frm DYNAMO; The other fidelity measures are extensions, and the sources are given; in the class descriptions.; """""". import os; import warnings; import numpy as np; import scipy.sparse as sp; # import scipy.linalg as la; import timeit; # QuTiP; from qutip import Qobj; # QuTiP logging; import qutip.logging_utils as logging; logger = logging.get_logger(); # QuTiP control modules; import qutip.control.errors as errors. warnings.simplefilter('always', DeprecationWarning) #turn off filter; def _attrib_deprecation(message, stacklevel=3):; """"""; Issue deprecation warning; Using stacklevel=3 will ensure message refers the function; calling with the deprecated parameter,; """"""; warnings.warn(message, DeprecationWarning, stacklevel=stacklevel). def _func_deprecation(message, stacklevel=3):; """"""; Issue deprecation warning; Using stacklevel=3 will ensure message refers the function; calling with the deprecated parameter,; """"""; warnings.warn(message, DeprecationWarning, stacklevel=stacklevel); ; def _trace(A):; """"""wrapper for calculating the trace""""""; # input is an operator (Qobj, array, sparse etc), so; if isinstance(A, Qobj):; return A.tr(); elif isinstance(A, np.ndarray):; return np.trace(A); else:; #Assume A some sparse matrix; return np.sum(A.diagonal()). [docs]class FidelityComputer(object):; """"""; Base class ",MatchSource.WIKI,docs/4.2/modules/qutip/control/fidcomp.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/control/fidcomp.html
https://qutip.org/docs/4.2/modules/qutip/control/fidcomp.html:4517,Testability,log,logger,4517,"e function; calling with the deprecated parameter,; """"""; warnings.warn(message, DeprecationWarning, stacklevel=stacklevel). def _func_deprecation(message, stacklevel=3):; """"""; Issue deprecation warning; Using stacklevel=3 will ensure message refers the function; calling with the deprecated parameter,; """"""; warnings.warn(message, DeprecationWarning, stacklevel=stacklevel); ; def _trace(A):; """"""wrapper for calculating the trace""""""; # input is an operator (Qobj, array, sparse etc), so; if isinstance(A, Qobj):; return A.tr(); elif isinstance(A, np.ndarray):; return np.trace(A); else:; #Assume A some sparse matrix; return np.sum(A.diagonal()). [docs]class FidelityComputer(object):; """"""; Base class for all Fidelity Computers.; This cannot be used directly. See subclass descriptions and choose; one appropriate for the application; Note: this must be instantiated with a Dynamics object, that is the; container for the data that the methods operate on. Attributes; ----------; log_level : integer; level of messaging output from the logger.; Options are attributes of qutip.logging_utils,; in decreasing levels of messaging, are:; DEBUG_INTENSE, DEBUG_VERBOSE, DEBUG, INFO, WARN, ERROR, CRITICAL; Anything WARN or above is effectively 'quiet' execution,; assuming everything runs as expected.; The default NOTSET implies that the level will be taken from; the QuTiP settings file, which by default is WARN. dimensional_norm : float; Normalisation constant. fid_norm_func : function; Used to normalise the fidelity; See SU and PSU options for the unitary dynamics. grad_norm_func : function; Used to normalise the fidelity gradient; See SU and PSU options for the unitary dynamics. uses_onwd_evo : boolean; flag to specify whether the onwd_evo evolution operator; (see Dynamics) is used by the FidelityComputer. uses_onto_evo : boolean; flag to specify whether the onto_evo evolution operator; (see Dynamics) is used by the FidelityComputer. fid_err : float; Last computed value of the fidelity er",MatchSource.WIKI,docs/4.2/modules/qutip/control/fidcomp.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/control/fidcomp.html
https://qutip.org/docs/4.2/modules/qutip/control/fidcomp.html:7394,Testability,log,logger,7394," self.id_text = 'FID_COMP_BASE'; self.dimensional_norm = 1.0; self.fid_norm_func = None; self.grad_norm_func = None; self.uses_onwd_evo = False; self.uses_onto_evo = False; self.apply_params(); self.clear(). [docs] def clear(self):; """"""; clear any temporarily held status data; """"""; self.fid_err = None; self.fidelity = None; self.fid_err_grad = None; self.grad_norm = np.inf; self.fidelity_current = False; self.fid_err_grad_current = False; self.grad_norm = 0.0. [docs] def apply_params(self, params=None):; """"""; Set object attributes based on the dictionary (if any) passed in the; instantiation, or passed as a parameter; This is called during the instantiation automatically.; The key value pairs are the attribute name and value; Note: attributes are created if they do not exist already,; and are overwritten if they do.; """"""; if not params:; params = self.params. if isinstance(params, dict):; self.params = params; for key in params:; setattr(self, key, params[key]). @property; def log_level(self):; return logger.level ; ; @log_level.setter; def log_level(self, lvl):; """"""; Set the log_level attribute and set the level of the logger; that is call logger.setLevel(lvl); """"""; logger.setLevel(lvl). [docs] def init_comp(self):; """"""; initialises the computer based on the configuration of the Dynamics; """"""; # optionally implemented in subclass; pass. [docs] def get_fid_err(self):; """"""; returns the absolute distance from the maximum achievable fidelity; """"""; # must be implemented by subclass; raise errors.UsageError(; ""No method defined for getting fidelity error.""; "" Suspect base class was used where sub class should have been""). [docs] def get_fid_err_gradient(self):; """"""; Returns the normalised gradient of the fidelity error; in a (nTimeslots x n_ctrls) array wrt the timeslot control amplitude; """"""; # must be implemented by subclass; raise errors.UsageError(""No method defined for getting fidelity""; "" error gradient. Suspect base class was""; "" used where sub class should have b",MatchSource.WIKI,docs/4.2/modules/qutip/control/fidcomp.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/control/fidcomp.html
https://qutip.org/docs/4.2/modules/qutip/control/fidcomp.html:7515,Testability,log,logger,7515,"unc = None; self.uses_onwd_evo = False; self.uses_onto_evo = False; self.apply_params(); self.clear(). [docs] def clear(self):; """"""; clear any temporarily held status data; """"""; self.fid_err = None; self.fidelity = None; self.fid_err_grad = None; self.grad_norm = np.inf; self.fidelity_current = False; self.fid_err_grad_current = False; self.grad_norm = 0.0. [docs] def apply_params(self, params=None):; """"""; Set object attributes based on the dictionary (if any) passed in the; instantiation, or passed as a parameter; This is called during the instantiation automatically.; The key value pairs are the attribute name and value; Note: attributes are created if they do not exist already,; and are overwritten if they do.; """"""; if not params:; params = self.params. if isinstance(params, dict):; self.params = params; for key in params:; setattr(self, key, params[key]). @property; def log_level(self):; return logger.level ; ; @log_level.setter; def log_level(self, lvl):; """"""; Set the log_level attribute and set the level of the logger; that is call logger.setLevel(lvl); """"""; logger.setLevel(lvl). [docs] def init_comp(self):; """"""; initialises the computer based on the configuration of the Dynamics; """"""; # optionally implemented in subclass; pass. [docs] def get_fid_err(self):; """"""; returns the absolute distance from the maximum achievable fidelity; """"""; # must be implemented by subclass; raise errors.UsageError(; ""No method defined for getting fidelity error.""; "" Suspect base class was used where sub class should have been""). [docs] def get_fid_err_gradient(self):; """"""; Returns the normalised gradient of the fidelity error; in a (nTimeslots x n_ctrls) array wrt the timeslot control amplitude; """"""; # must be implemented by subclass; raise errors.UsageError(""No method defined for getting fidelity""; "" error gradient. Suspect base class was""; "" used where sub class should have been""). [docs] def flag_system_changed(self):; """"""; Flag fidelity and gradients as needing recalculation; """,MatchSource.WIKI,docs/4.2/modules/qutip/control/fidcomp.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/control/fidcomp.html
https://qutip.org/docs/4.2/modules/qutip/control/fidcomp.html:7536,Testability,log,logger,7536,"unc = None; self.uses_onwd_evo = False; self.uses_onto_evo = False; self.apply_params(); self.clear(). [docs] def clear(self):; """"""; clear any temporarily held status data; """"""; self.fid_err = None; self.fidelity = None; self.fid_err_grad = None; self.grad_norm = np.inf; self.fidelity_current = False; self.fid_err_grad_current = False; self.grad_norm = 0.0. [docs] def apply_params(self, params=None):; """"""; Set object attributes based on the dictionary (if any) passed in the; instantiation, or passed as a parameter; This is called during the instantiation automatically.; The key value pairs are the attribute name and value; Note: attributes are created if they do not exist already,; and are overwritten if they do.; """"""; if not params:; params = self.params. if isinstance(params, dict):; self.params = params; for key in params:; setattr(self, key, params[key]). @property; def log_level(self):; return logger.level ; ; @log_level.setter; def log_level(self, lvl):; """"""; Set the log_level attribute and set the level of the logger; that is call logger.setLevel(lvl); """"""; logger.setLevel(lvl). [docs] def init_comp(self):; """"""; initialises the computer based on the configuration of the Dynamics; """"""; # optionally implemented in subclass; pass. [docs] def get_fid_err(self):; """"""; returns the absolute distance from the maximum achievable fidelity; """"""; # must be implemented by subclass; raise errors.UsageError(; ""No method defined for getting fidelity error.""; "" Suspect base class was used where sub class should have been""). [docs] def get_fid_err_gradient(self):; """"""; Returns the normalised gradient of the fidelity error; in a (nTimeslots x n_ctrls) array wrt the timeslot control amplitude; """"""; # must be implemented by subclass; raise errors.UsageError(""No method defined for getting fidelity""; "" error gradient. Suspect base class was""; "" used where sub class should have been""). [docs] def flag_system_changed(self):; """"""; Flag fidelity and gradients as needing recalculation; """,MatchSource.WIKI,docs/4.2/modules/qutip/control/fidcomp.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/control/fidcomp.html
https://qutip.org/docs/4.2/modules/qutip/control/fidcomp.html:7563,Testability,log,logger,7563,"pply_params(); self.clear(). [docs] def clear(self):; """"""; clear any temporarily held status data; """"""; self.fid_err = None; self.fidelity = None; self.fid_err_grad = None; self.grad_norm = np.inf; self.fidelity_current = False; self.fid_err_grad_current = False; self.grad_norm = 0.0. [docs] def apply_params(self, params=None):; """"""; Set object attributes based on the dictionary (if any) passed in the; instantiation, or passed as a parameter; This is called during the instantiation automatically.; The key value pairs are the attribute name and value; Note: attributes are created if they do not exist already,; and are overwritten if they do.; """"""; if not params:; params = self.params. if isinstance(params, dict):; self.params = params; for key in params:; setattr(self, key, params[key]). @property; def log_level(self):; return logger.level ; ; @log_level.setter; def log_level(self, lvl):; """"""; Set the log_level attribute and set the level of the logger; that is call logger.setLevel(lvl); """"""; logger.setLevel(lvl). [docs] def init_comp(self):; """"""; initialises the computer based on the configuration of the Dynamics; """"""; # optionally implemented in subclass; pass. [docs] def get_fid_err(self):; """"""; returns the absolute distance from the maximum achievable fidelity; """"""; # must be implemented by subclass; raise errors.UsageError(; ""No method defined for getting fidelity error.""; "" Suspect base class was used where sub class should have been""). [docs] def get_fid_err_gradient(self):; """"""; Returns the normalised gradient of the fidelity error; in a (nTimeslots x n_ctrls) array wrt the timeslot control amplitude; """"""; # must be implemented by subclass; raise errors.UsageError(""No method defined for getting fidelity""; "" error gradient. Suspect base class was""; "" used where sub class should have been""). [docs] def flag_system_changed(self):; """"""; Flag fidelity and gradients as needing recalculation; """"""; self.fidelity_current = False; # Flag gradient as needing recalculatin",MatchSource.WIKI,docs/4.2/modules/qutip/control/fidcomp.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/control/fidcomp.html
https://qutip.org/docs/4.2/modules/qutip/control/fidcomp.html:14156,Testability,log,logging,14156,"A); else:; raise TypeError(""Cannot compute trace (not square)""); except:; # assume input is already scalar and hence assumed; # to be the prenormalised scalar value, e.g. fidelity; norm = A; return np.abs(norm) / self.dimensional_norm. [docs] def normalize_gradient_PSU(self, grad):; """"""; Normalise the gradient matrix passed as grad; This PSU version is independent of global phase; """"""; fid_pn = self.get_fidelity_prenorm(); grad_normalized = np.real(grad * np.exp(-1j * np.angle(fid_pn)) /; self.dimensional_norm); return grad_normalized. [docs] def get_fid_err(self):; """"""; Gets the absolute error in the fidelity; """"""; return np.abs(1 - self.get_fidelity()). [docs] def get_fidelity(self):; """"""; Gets the appropriately normalised fidelity value; The normalisation is determined by the fid_norm_func pointer; which should be set in the config; """"""; if not self.fidelity_current:; self.fidelity = \; self.fid_norm_func(self.get_fidelity_prenorm()); self.fidelity_current = True; if self.log_level <= logging.DEBUG:; logger.debug(""Fidelity (normalised): {}"".format(self.fidelity)). return self.fidelity. [docs] def get_fidelity_prenorm(self):; """"""; Gets the current fidelity value prior to normalisation; Note the gradient function uses this value; The value is cached, because it is used in the gradient calculation; """"""; if not self.fidelity_prenorm_current:; dyn = self.parent; k = dyn.tslot_computer._get_timeslot_for_fidelity_calc(); dyn.compute_evolution(); if dyn.oper_dtype == Qobj:; f = (dyn._onto_evo[k]*dyn._fwd_evo[k]).tr(); else:; f = _trace(dyn._onto_evo[k].dot(dyn._fwd_evo[k])); self.fidelity_prenorm = f; self.fidelity_prenorm_current = True; if dyn.stats is not None:; dyn.stats.num_fidelity_computes += 1; if self.log_level <= logging.DEBUG:; logger.debug(""Fidelity (pre normalisation): {}"".format(; self.fidelity_prenorm)); return self.fidelity_prenorm. [docs] def get_fid_err_gradient(self):; """"""; Returns the normalised gradient of the fidelity error; in a (nTimeslots x n_ctrl",MatchSource.WIKI,docs/4.2/modules/qutip/control/fidcomp.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/control/fidcomp.html
https://qutip.org/docs/4.2/modules/qutip/control/fidcomp.html:14172,Testability,log,logger,14172,"ypeError(""Cannot compute trace (not square)""); except:; # assume input is already scalar and hence assumed; # to be the prenormalised scalar value, e.g. fidelity; norm = A; return np.abs(norm) / self.dimensional_norm. [docs] def normalize_gradient_PSU(self, grad):; """"""; Normalise the gradient matrix passed as grad; This PSU version is independent of global phase; """"""; fid_pn = self.get_fidelity_prenorm(); grad_normalized = np.real(grad * np.exp(-1j * np.angle(fid_pn)) /; self.dimensional_norm); return grad_normalized. [docs] def get_fid_err(self):; """"""; Gets the absolute error in the fidelity; """"""; return np.abs(1 - self.get_fidelity()). [docs] def get_fidelity(self):; """"""; Gets the appropriately normalised fidelity value; The normalisation is determined by the fid_norm_func pointer; which should be set in the config; """"""; if not self.fidelity_current:; self.fidelity = \; self.fid_norm_func(self.get_fidelity_prenorm()); self.fidelity_current = True; if self.log_level <= logging.DEBUG:; logger.debug(""Fidelity (normalised): {}"".format(self.fidelity)). return self.fidelity. [docs] def get_fidelity_prenorm(self):; """"""; Gets the current fidelity value prior to normalisation; Note the gradient function uses this value; The value is cached, because it is used in the gradient calculation; """"""; if not self.fidelity_prenorm_current:; dyn = self.parent; k = dyn.tslot_computer._get_timeslot_for_fidelity_calc(); dyn.compute_evolution(); if dyn.oper_dtype == Qobj:; f = (dyn._onto_evo[k]*dyn._fwd_evo[k]).tr(); else:; f = _trace(dyn._onto_evo[k].dot(dyn._fwd_evo[k])); self.fidelity_prenorm = f; self.fidelity_prenorm_current = True; if dyn.stats is not None:; dyn.stats.num_fidelity_computes += 1; if self.log_level <= logging.DEBUG:; logger.debug(""Fidelity (pre normalisation): {}"".format(; self.fidelity_prenorm)); return self.fidelity_prenorm. [docs] def get_fid_err_gradient(self):; """"""; Returns the normalised gradient of the fidelity error; in a (nTimeslots x n_ctrls) array; The grad",MatchSource.WIKI,docs/4.2/modules/qutip/control/fidcomp.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/control/fidcomp.html
https://qutip.org/docs/4.2/modules/qutip/control/fidcomp.html:14901,Testability,log,logging,14901,"alue; The normalisation is determined by the fid_norm_func pointer; which should be set in the config; """"""; if not self.fidelity_current:; self.fidelity = \; self.fid_norm_func(self.get_fidelity_prenorm()); self.fidelity_current = True; if self.log_level <= logging.DEBUG:; logger.debug(""Fidelity (normalised): {}"".format(self.fidelity)). return self.fidelity. [docs] def get_fidelity_prenorm(self):; """"""; Gets the current fidelity value prior to normalisation; Note the gradient function uses this value; The value is cached, because it is used in the gradient calculation; """"""; if not self.fidelity_prenorm_current:; dyn = self.parent; k = dyn.tslot_computer._get_timeslot_for_fidelity_calc(); dyn.compute_evolution(); if dyn.oper_dtype == Qobj:; f = (dyn._onto_evo[k]*dyn._fwd_evo[k]).tr(); else:; f = _trace(dyn._onto_evo[k].dot(dyn._fwd_evo[k])); self.fidelity_prenorm = f; self.fidelity_prenorm_current = True; if dyn.stats is not None:; dyn.stats.num_fidelity_computes += 1; if self.log_level <= logging.DEBUG:; logger.debug(""Fidelity (pre normalisation): {}"".format(; self.fidelity_prenorm)); return self.fidelity_prenorm. [docs] def get_fid_err_gradient(self):; """"""; Returns the normalised gradient of the fidelity error; in a (nTimeslots x n_ctrls) array; The gradients are cached in case they are requested; mutliple times between control updates; (although this is not typically found to happen); """"""; if not self.fid_err_grad_current:; dyn = self.parent; grad_prenorm = self.compute_fid_grad(); if self.log_level <= logging.DEBUG_INTENSE:; logger.log(logging.DEBUG_INTENSE, ""pre-normalised fidelity ""; ""gradients:\n{}"".format(grad_prenorm)); # AJGP: Note this check should not be necessary if dynamics are; # unitary. However, if they are not then this gradient; # can still be used, however the interpretation is dubious; if self.get_fidelity() >= 1:; self.fid_err_grad = self.grad_norm_func(grad_prenorm); else:; self.fid_err_grad = -self.grad_norm_func(grad_prenorm). self.fid_err_grad",MatchSource.WIKI,docs/4.2/modules/qutip/control/fidcomp.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/control/fidcomp.html
https://qutip.org/docs/4.2/modules/qutip/control/fidcomp.html:14917,Testability,log,logger,14917,"ation is determined by the fid_norm_func pointer; which should be set in the config; """"""; if not self.fidelity_current:; self.fidelity = \; self.fid_norm_func(self.get_fidelity_prenorm()); self.fidelity_current = True; if self.log_level <= logging.DEBUG:; logger.debug(""Fidelity (normalised): {}"".format(self.fidelity)). return self.fidelity. [docs] def get_fidelity_prenorm(self):; """"""; Gets the current fidelity value prior to normalisation; Note the gradient function uses this value; The value is cached, because it is used in the gradient calculation; """"""; if not self.fidelity_prenorm_current:; dyn = self.parent; k = dyn.tslot_computer._get_timeslot_for_fidelity_calc(); dyn.compute_evolution(); if dyn.oper_dtype == Qobj:; f = (dyn._onto_evo[k]*dyn._fwd_evo[k]).tr(); else:; f = _trace(dyn._onto_evo[k].dot(dyn._fwd_evo[k])); self.fidelity_prenorm = f; self.fidelity_prenorm_current = True; if dyn.stats is not None:; dyn.stats.num_fidelity_computes += 1; if self.log_level <= logging.DEBUG:; logger.debug(""Fidelity (pre normalisation): {}"".format(; self.fidelity_prenorm)); return self.fidelity_prenorm. [docs] def get_fid_err_gradient(self):; """"""; Returns the normalised gradient of the fidelity error; in a (nTimeslots x n_ctrls) array; The gradients are cached in case they are requested; mutliple times between control updates; (although this is not typically found to happen); """"""; if not self.fid_err_grad_current:; dyn = self.parent; grad_prenorm = self.compute_fid_grad(); if self.log_level <= logging.DEBUG_INTENSE:; logger.log(logging.DEBUG_INTENSE, ""pre-normalised fidelity ""; ""gradients:\n{}"".format(grad_prenorm)); # AJGP: Note this check should not be necessary if dynamics are; # unitary. However, if they are not then this gradient; # can still be used, however the interpretation is dubious; if self.get_fidelity() >= 1:; self.fid_err_grad = self.grad_norm_func(grad_prenorm); else:; self.fid_err_grad = -self.grad_norm_func(grad_prenorm). self.fid_err_grad_current = True; i",MatchSource.WIKI,docs/4.2/modules/qutip/control/fidcomp.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/control/fidcomp.html
https://qutip.org/docs/4.2/modules/qutip/control/fidcomp.html:15427,Testability,log,logging,15427," because it is used in the gradient calculation; """"""; if not self.fidelity_prenorm_current:; dyn = self.parent; k = dyn.tslot_computer._get_timeslot_for_fidelity_calc(); dyn.compute_evolution(); if dyn.oper_dtype == Qobj:; f = (dyn._onto_evo[k]*dyn._fwd_evo[k]).tr(); else:; f = _trace(dyn._onto_evo[k].dot(dyn._fwd_evo[k])); self.fidelity_prenorm = f; self.fidelity_prenorm_current = True; if dyn.stats is not None:; dyn.stats.num_fidelity_computes += 1; if self.log_level <= logging.DEBUG:; logger.debug(""Fidelity (pre normalisation): {}"".format(; self.fidelity_prenorm)); return self.fidelity_prenorm. [docs] def get_fid_err_gradient(self):; """"""; Returns the normalised gradient of the fidelity error; in a (nTimeslots x n_ctrls) array; The gradients are cached in case they are requested; mutliple times between control updates; (although this is not typically found to happen); """"""; if not self.fid_err_grad_current:; dyn = self.parent; grad_prenorm = self.compute_fid_grad(); if self.log_level <= logging.DEBUG_INTENSE:; logger.log(logging.DEBUG_INTENSE, ""pre-normalised fidelity ""; ""gradients:\n{}"".format(grad_prenorm)); # AJGP: Note this check should not be necessary if dynamics are; # unitary. However, if they are not then this gradient; # can still be used, however the interpretation is dubious; if self.get_fidelity() >= 1:; self.fid_err_grad = self.grad_norm_func(grad_prenorm); else:; self.fid_err_grad = -self.grad_norm_func(grad_prenorm). self.fid_err_grad_current = True; if dyn.stats is not None:; dyn.stats.num_grad_computes += 1. self.grad_norm = np.sqrt(np.sum(self.fid_err_grad**2)); if self.log_level <= logging.DEBUG_INTENSE:; logger.log(logging.DEBUG_INTENSE, ""Normalised fidelity error ""; ""gradients:\n{}"".format(self.fid_err_grad)). if self.log_level <= logging.DEBUG:; logger.debug(""Gradient (sum sq norm): ""; ""{} "".format(self.grad_norm)). return self.fid_err_grad. [docs] def compute_fid_grad(self):; """"""; Calculates exact gradient of function wrt to each timeslot; co",MatchSource.WIKI,docs/4.2/modules/qutip/control/fidcomp.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/control/fidcomp.html
https://qutip.org/docs/4.2/modules/qutip/control/fidcomp.html:15451,Testability,log,logger,15451," the gradient calculation; """"""; if not self.fidelity_prenorm_current:; dyn = self.parent; k = dyn.tslot_computer._get_timeslot_for_fidelity_calc(); dyn.compute_evolution(); if dyn.oper_dtype == Qobj:; f = (dyn._onto_evo[k]*dyn._fwd_evo[k]).tr(); else:; f = _trace(dyn._onto_evo[k].dot(dyn._fwd_evo[k])); self.fidelity_prenorm = f; self.fidelity_prenorm_current = True; if dyn.stats is not None:; dyn.stats.num_fidelity_computes += 1; if self.log_level <= logging.DEBUG:; logger.debug(""Fidelity (pre normalisation): {}"".format(; self.fidelity_prenorm)); return self.fidelity_prenorm. [docs] def get_fid_err_gradient(self):; """"""; Returns the normalised gradient of the fidelity error; in a (nTimeslots x n_ctrls) array; The gradients are cached in case they are requested; mutliple times between control updates; (although this is not typically found to happen); """"""; if not self.fid_err_grad_current:; dyn = self.parent; grad_prenorm = self.compute_fid_grad(); if self.log_level <= logging.DEBUG_INTENSE:; logger.log(logging.DEBUG_INTENSE, ""pre-normalised fidelity ""; ""gradients:\n{}"".format(grad_prenorm)); # AJGP: Note this check should not be necessary if dynamics are; # unitary. However, if they are not then this gradient; # can still be used, however the interpretation is dubious; if self.get_fidelity() >= 1:; self.fid_err_grad = self.grad_norm_func(grad_prenorm); else:; self.fid_err_grad = -self.grad_norm_func(grad_prenorm). self.fid_err_grad_current = True; if dyn.stats is not None:; dyn.stats.num_grad_computes += 1. self.grad_norm = np.sqrt(np.sum(self.fid_err_grad**2)); if self.log_level <= logging.DEBUG_INTENSE:; logger.log(logging.DEBUG_INTENSE, ""Normalised fidelity error ""; ""gradients:\n{}"".format(self.fid_err_grad)). if self.log_level <= logging.DEBUG:; logger.debug(""Gradient (sum sq norm): ""; ""{} "".format(self.grad_norm)). return self.fid_err_grad. [docs] def compute_fid_grad(self):; """"""; Calculates exact gradient of function wrt to each timeslot; control amplitudes. Note",MatchSource.WIKI,docs/4.2/modules/qutip/control/fidcomp.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/control/fidcomp.html
https://qutip.org/docs/4.2/modules/qutip/control/fidcomp.html:15458,Testability,log,log,15458,"ulation; """"""; if not self.fidelity_prenorm_current:; dyn = self.parent; k = dyn.tslot_computer._get_timeslot_for_fidelity_calc(); dyn.compute_evolution(); if dyn.oper_dtype == Qobj:; f = (dyn._onto_evo[k]*dyn._fwd_evo[k]).tr(); else:; f = _trace(dyn._onto_evo[k].dot(dyn._fwd_evo[k])); self.fidelity_prenorm = f; self.fidelity_prenorm_current = True; if dyn.stats is not None:; dyn.stats.num_fidelity_computes += 1; if self.log_level <= logging.DEBUG:; logger.debug(""Fidelity (pre normalisation): {}"".format(; self.fidelity_prenorm)); return self.fidelity_prenorm. [docs] def get_fid_err_gradient(self):; """"""; Returns the normalised gradient of the fidelity error; in a (nTimeslots x n_ctrls) array; The gradients are cached in case they are requested; mutliple times between control updates; (although this is not typically found to happen); """"""; if not self.fid_err_grad_current:; dyn = self.parent; grad_prenorm = self.compute_fid_grad(); if self.log_level <= logging.DEBUG_INTENSE:; logger.log(logging.DEBUG_INTENSE, ""pre-normalised fidelity ""; ""gradients:\n{}"".format(grad_prenorm)); # AJGP: Note this check should not be necessary if dynamics are; # unitary. However, if they are not then this gradient; # can still be used, however the interpretation is dubious; if self.get_fidelity() >= 1:; self.fid_err_grad = self.grad_norm_func(grad_prenorm); else:; self.fid_err_grad = -self.grad_norm_func(grad_prenorm). self.fid_err_grad_current = True; if dyn.stats is not None:; dyn.stats.num_grad_computes += 1. self.grad_norm = np.sqrt(np.sum(self.fid_err_grad**2)); if self.log_level <= logging.DEBUG_INTENSE:; logger.log(logging.DEBUG_INTENSE, ""Normalised fidelity error ""; ""gradients:\n{}"".format(self.fid_err_grad)). if self.log_level <= logging.DEBUG:; logger.debug(""Gradient (sum sq norm): ""; ""{} "".format(self.grad_norm)). return self.fid_err_grad. [docs] def compute_fid_grad(self):; """"""; Calculates exact gradient of function wrt to each timeslot; control amplitudes. Note these gradients ",MatchSource.WIKI,docs/4.2/modules/qutip/control/fidcomp.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/control/fidcomp.html
https://qutip.org/docs/4.2/modules/qutip/control/fidcomp.html:15462,Testability,log,logging,15462,"ulation; """"""; if not self.fidelity_prenorm_current:; dyn = self.parent; k = dyn.tslot_computer._get_timeslot_for_fidelity_calc(); dyn.compute_evolution(); if dyn.oper_dtype == Qobj:; f = (dyn._onto_evo[k]*dyn._fwd_evo[k]).tr(); else:; f = _trace(dyn._onto_evo[k].dot(dyn._fwd_evo[k])); self.fidelity_prenorm = f; self.fidelity_prenorm_current = True; if dyn.stats is not None:; dyn.stats.num_fidelity_computes += 1; if self.log_level <= logging.DEBUG:; logger.debug(""Fidelity (pre normalisation): {}"".format(; self.fidelity_prenorm)); return self.fidelity_prenorm. [docs] def get_fid_err_gradient(self):; """"""; Returns the normalised gradient of the fidelity error; in a (nTimeslots x n_ctrls) array; The gradients are cached in case they are requested; mutliple times between control updates; (although this is not typically found to happen); """"""; if not self.fid_err_grad_current:; dyn = self.parent; grad_prenorm = self.compute_fid_grad(); if self.log_level <= logging.DEBUG_INTENSE:; logger.log(logging.DEBUG_INTENSE, ""pre-normalised fidelity ""; ""gradients:\n{}"".format(grad_prenorm)); # AJGP: Note this check should not be necessary if dynamics are; # unitary. However, if they are not then this gradient; # can still be used, however the interpretation is dubious; if self.get_fidelity() >= 1:; self.fid_err_grad = self.grad_norm_func(grad_prenorm); else:; self.fid_err_grad = -self.grad_norm_func(grad_prenorm). self.fid_err_grad_current = True; if dyn.stats is not None:; dyn.stats.num_grad_computes += 1. self.grad_norm = np.sqrt(np.sum(self.fid_err_grad**2)); if self.log_level <= logging.DEBUG_INTENSE:; logger.log(logging.DEBUG_INTENSE, ""Normalised fidelity error ""; ""gradients:\n{}"".format(self.fid_err_grad)). if self.log_level <= logging.DEBUG:; logger.debug(""Gradient (sum sq norm): ""; ""{} "".format(self.grad_norm)). return self.fid_err_grad. [docs] def compute_fid_grad(self):; """"""; Calculates exact gradient of function wrt to each timeslot; control amplitudes. Note these gradients ",MatchSource.WIKI,docs/4.2/modules/qutip/control/fidcomp.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/control/fidcomp.html
https://qutip.org/docs/4.2/modules/qutip/control/fidcomp.html:16054,Testability,log,logging,16054,"_gradient(self):; """"""; Returns the normalised gradient of the fidelity error; in a (nTimeslots x n_ctrls) array; The gradients are cached in case they are requested; mutliple times between control updates; (although this is not typically found to happen); """"""; if not self.fid_err_grad_current:; dyn = self.parent; grad_prenorm = self.compute_fid_grad(); if self.log_level <= logging.DEBUG_INTENSE:; logger.log(logging.DEBUG_INTENSE, ""pre-normalised fidelity ""; ""gradients:\n{}"".format(grad_prenorm)); # AJGP: Note this check should not be necessary if dynamics are; # unitary. However, if they are not then this gradient; # can still be used, however the interpretation is dubious; if self.get_fidelity() >= 1:; self.fid_err_grad = self.grad_norm_func(grad_prenorm); else:; self.fid_err_grad = -self.grad_norm_func(grad_prenorm). self.fid_err_grad_current = True; if dyn.stats is not None:; dyn.stats.num_grad_computes += 1. self.grad_norm = np.sqrt(np.sum(self.fid_err_grad**2)); if self.log_level <= logging.DEBUG_INTENSE:; logger.log(logging.DEBUG_INTENSE, ""Normalised fidelity error ""; ""gradients:\n{}"".format(self.fid_err_grad)). if self.log_level <= logging.DEBUG:; logger.debug(""Gradient (sum sq norm): ""; ""{} "".format(self.grad_norm)). return self.fid_err_grad. [docs] def compute_fid_grad(self):; """"""; Calculates exact gradient of function wrt to each timeslot; control amplitudes. Note these gradients are not normalised; These are returned as a (nTimeslots x n_ctrls) array; """"""; dyn = self.parent; n_ctrls = dyn.num_ctrls; n_ts = dyn.num_tslots. # create n_ts x n_ctrls zero array for grad start point; grad = np.zeros([n_ts, n_ctrls], dtype=complex). dyn.tslot_computer.flag_all_calc_now(); dyn.compute_evolution(). # loop through all ctrl timeslots calculating gradients; time_st = timeit.default_timer(); for j in range(n_ctrls):; for k in range(n_ts):; fwd_evo = dyn._fwd_evo[k] ; onto_evo = dyn._onto_evo[k+1]; if dyn.oper_dtype == Qobj:; g = (onto_evo*dyn._get_prop_grad(k, j)*fwd_e",MatchSource.WIKI,docs/4.2/modules/qutip/control/fidcomp.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/control/fidcomp.html
https://qutip.org/docs/4.2/modules/qutip/control/fidcomp.html:16078,Testability,log,logger,16078," Returns the normalised gradient of the fidelity error; in a (nTimeslots x n_ctrls) array; The gradients are cached in case they are requested; mutliple times between control updates; (although this is not typically found to happen); """"""; if not self.fid_err_grad_current:; dyn = self.parent; grad_prenorm = self.compute_fid_grad(); if self.log_level <= logging.DEBUG_INTENSE:; logger.log(logging.DEBUG_INTENSE, ""pre-normalised fidelity ""; ""gradients:\n{}"".format(grad_prenorm)); # AJGP: Note this check should not be necessary if dynamics are; # unitary. However, if they are not then this gradient; # can still be used, however the interpretation is dubious; if self.get_fidelity() >= 1:; self.fid_err_grad = self.grad_norm_func(grad_prenorm); else:; self.fid_err_grad = -self.grad_norm_func(grad_prenorm). self.fid_err_grad_current = True; if dyn.stats is not None:; dyn.stats.num_grad_computes += 1. self.grad_norm = np.sqrt(np.sum(self.fid_err_grad**2)); if self.log_level <= logging.DEBUG_INTENSE:; logger.log(logging.DEBUG_INTENSE, ""Normalised fidelity error ""; ""gradients:\n{}"".format(self.fid_err_grad)). if self.log_level <= logging.DEBUG:; logger.debug(""Gradient (sum sq norm): ""; ""{} "".format(self.grad_norm)). return self.fid_err_grad. [docs] def compute_fid_grad(self):; """"""; Calculates exact gradient of function wrt to each timeslot; control amplitudes. Note these gradients are not normalised; These are returned as a (nTimeslots x n_ctrls) array; """"""; dyn = self.parent; n_ctrls = dyn.num_ctrls; n_ts = dyn.num_tslots. # create n_ts x n_ctrls zero array for grad start point; grad = np.zeros([n_ts, n_ctrls], dtype=complex). dyn.tslot_computer.flag_all_calc_now(); dyn.compute_evolution(). # loop through all ctrl timeslots calculating gradients; time_st = timeit.default_timer(); for j in range(n_ctrls):; for k in range(n_ts):; fwd_evo = dyn._fwd_evo[k] ; onto_evo = dyn._onto_evo[k+1]; if dyn.oper_dtype == Qobj:; g = (onto_evo*dyn._get_prop_grad(k, j)*fwd_evo).tr(); else:; g = _",MatchSource.WIKI,docs/4.2/modules/qutip/control/fidcomp.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/control/fidcomp.html
https://qutip.org/docs/4.2/modules/qutip/control/fidcomp.html:16085,Testability,log,log,16085,"lised gradient of the fidelity error; in a (nTimeslots x n_ctrls) array; The gradients are cached in case they are requested; mutliple times between control updates; (although this is not typically found to happen); """"""; if not self.fid_err_grad_current:; dyn = self.parent; grad_prenorm = self.compute_fid_grad(); if self.log_level <= logging.DEBUG_INTENSE:; logger.log(logging.DEBUG_INTENSE, ""pre-normalised fidelity ""; ""gradients:\n{}"".format(grad_prenorm)); # AJGP: Note this check should not be necessary if dynamics are; # unitary. However, if they are not then this gradient; # can still be used, however the interpretation is dubious; if self.get_fidelity() >= 1:; self.fid_err_grad = self.grad_norm_func(grad_prenorm); else:; self.fid_err_grad = -self.grad_norm_func(grad_prenorm). self.fid_err_grad_current = True; if dyn.stats is not None:; dyn.stats.num_grad_computes += 1. self.grad_norm = np.sqrt(np.sum(self.fid_err_grad**2)); if self.log_level <= logging.DEBUG_INTENSE:; logger.log(logging.DEBUG_INTENSE, ""Normalised fidelity error ""; ""gradients:\n{}"".format(self.fid_err_grad)). if self.log_level <= logging.DEBUG:; logger.debug(""Gradient (sum sq norm): ""; ""{} "".format(self.grad_norm)). return self.fid_err_grad. [docs] def compute_fid_grad(self):; """"""; Calculates exact gradient of function wrt to each timeslot; control amplitudes. Note these gradients are not normalised; These are returned as a (nTimeslots x n_ctrls) array; """"""; dyn = self.parent; n_ctrls = dyn.num_ctrls; n_ts = dyn.num_tslots. # create n_ts x n_ctrls zero array for grad start point; grad = np.zeros([n_ts, n_ctrls], dtype=complex). dyn.tslot_computer.flag_all_calc_now(); dyn.compute_evolution(). # loop through all ctrl timeslots calculating gradients; time_st = timeit.default_timer(); for j in range(n_ctrls):; for k in range(n_ts):; fwd_evo = dyn._fwd_evo[k] ; onto_evo = dyn._onto_evo[k+1]; if dyn.oper_dtype == Qobj:; g = (onto_evo*dyn._get_prop_grad(k, j)*fwd_evo).tr(); else:; g = _trace(onto_evo.do",MatchSource.WIKI,docs/4.2/modules/qutip/control/fidcomp.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/control/fidcomp.html
https://qutip.org/docs/4.2/modules/qutip/control/fidcomp.html:16089,Testability,log,logging,16089,"lised gradient of the fidelity error; in a (nTimeslots x n_ctrls) array; The gradients are cached in case they are requested; mutliple times between control updates; (although this is not typically found to happen); """"""; if not self.fid_err_grad_current:; dyn = self.parent; grad_prenorm = self.compute_fid_grad(); if self.log_level <= logging.DEBUG_INTENSE:; logger.log(logging.DEBUG_INTENSE, ""pre-normalised fidelity ""; ""gradients:\n{}"".format(grad_prenorm)); # AJGP: Note this check should not be necessary if dynamics are; # unitary. However, if they are not then this gradient; # can still be used, however the interpretation is dubious; if self.get_fidelity() >= 1:; self.fid_err_grad = self.grad_norm_func(grad_prenorm); else:; self.fid_err_grad = -self.grad_norm_func(grad_prenorm). self.fid_err_grad_current = True; if dyn.stats is not None:; dyn.stats.num_grad_computes += 1. self.grad_norm = np.sqrt(np.sum(self.fid_err_grad**2)); if self.log_level <= logging.DEBUG_INTENSE:; logger.log(logging.DEBUG_INTENSE, ""Normalised fidelity error ""; ""gradients:\n{}"".format(self.fid_err_grad)). if self.log_level <= logging.DEBUG:; logger.debug(""Gradient (sum sq norm): ""; ""{} "".format(self.grad_norm)). return self.fid_err_grad. [docs] def compute_fid_grad(self):; """"""; Calculates exact gradient of function wrt to each timeslot; control amplitudes. Note these gradients are not normalised; These are returned as a (nTimeslots x n_ctrls) array; """"""; dyn = self.parent; n_ctrls = dyn.num_ctrls; n_ts = dyn.num_tslots. # create n_ts x n_ctrls zero array for grad start point; grad = np.zeros([n_ts, n_ctrls], dtype=complex). dyn.tslot_computer.flag_all_calc_now(); dyn.compute_evolution(). # loop through all ctrl timeslots calculating gradients; time_st = timeit.default_timer(); for j in range(n_ctrls):; for k in range(n_ts):; fwd_evo = dyn._fwd_evo[k] ; onto_evo = dyn._onto_evo[k+1]; if dyn.oper_dtype == Qobj:; g = (onto_evo*dyn._get_prop_grad(k, j)*fwd_evo).tr(); else:; g = _trace(onto_evo.do",MatchSource.WIKI,docs/4.2/modules/qutip/control/fidcomp.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/control/fidcomp.html
https://qutip.org/docs/4.2/modules/qutip/control/fidcomp.html:16208,Testability,log,logging,16208," requested; mutliple times between control updates; (although this is not typically found to happen); """"""; if not self.fid_err_grad_current:; dyn = self.parent; grad_prenorm = self.compute_fid_grad(); if self.log_level <= logging.DEBUG_INTENSE:; logger.log(logging.DEBUG_INTENSE, ""pre-normalised fidelity ""; ""gradients:\n{}"".format(grad_prenorm)); # AJGP: Note this check should not be necessary if dynamics are; # unitary. However, if they are not then this gradient; # can still be used, however the interpretation is dubious; if self.get_fidelity() >= 1:; self.fid_err_grad = self.grad_norm_func(grad_prenorm); else:; self.fid_err_grad = -self.grad_norm_func(grad_prenorm). self.fid_err_grad_current = True; if dyn.stats is not None:; dyn.stats.num_grad_computes += 1. self.grad_norm = np.sqrt(np.sum(self.fid_err_grad**2)); if self.log_level <= logging.DEBUG_INTENSE:; logger.log(logging.DEBUG_INTENSE, ""Normalised fidelity error ""; ""gradients:\n{}"".format(self.fid_err_grad)). if self.log_level <= logging.DEBUG:; logger.debug(""Gradient (sum sq norm): ""; ""{} "".format(self.grad_norm)). return self.fid_err_grad. [docs] def compute_fid_grad(self):; """"""; Calculates exact gradient of function wrt to each timeslot; control amplitudes. Note these gradients are not normalised; These are returned as a (nTimeslots x n_ctrls) array; """"""; dyn = self.parent; n_ctrls = dyn.num_ctrls; n_ts = dyn.num_tslots. # create n_ts x n_ctrls zero array for grad start point; grad = np.zeros([n_ts, n_ctrls], dtype=complex). dyn.tslot_computer.flag_all_calc_now(); dyn.compute_evolution(). # loop through all ctrl timeslots calculating gradients; time_st = timeit.default_timer(); for j in range(n_ctrls):; for k in range(n_ts):; fwd_evo = dyn._fwd_evo[k] ; onto_evo = dyn._onto_evo[k+1]; if dyn.oper_dtype == Qobj:; g = (onto_evo*dyn._get_prop_grad(k, j)*fwd_evo).tr(); else:; g = _trace(onto_evo.dot(; dyn._get_prop_grad(k, j)).dot(fwd_evo)); grad[k, j] = g; if dyn.stats is not None:; dyn.stats.wall_time_gradien",MatchSource.WIKI,docs/4.2/modules/qutip/control/fidcomp.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/control/fidcomp.html
https://qutip.org/docs/4.2/modules/qutip/control/fidcomp.html:16224,Testability,log,logger,16224,"le times between control updates; (although this is not typically found to happen); """"""; if not self.fid_err_grad_current:; dyn = self.parent; grad_prenorm = self.compute_fid_grad(); if self.log_level <= logging.DEBUG_INTENSE:; logger.log(logging.DEBUG_INTENSE, ""pre-normalised fidelity ""; ""gradients:\n{}"".format(grad_prenorm)); # AJGP: Note this check should not be necessary if dynamics are; # unitary. However, if they are not then this gradient; # can still be used, however the interpretation is dubious; if self.get_fidelity() >= 1:; self.fid_err_grad = self.grad_norm_func(grad_prenorm); else:; self.fid_err_grad = -self.grad_norm_func(grad_prenorm). self.fid_err_grad_current = True; if dyn.stats is not None:; dyn.stats.num_grad_computes += 1. self.grad_norm = np.sqrt(np.sum(self.fid_err_grad**2)); if self.log_level <= logging.DEBUG_INTENSE:; logger.log(logging.DEBUG_INTENSE, ""Normalised fidelity error ""; ""gradients:\n{}"".format(self.fid_err_grad)). if self.log_level <= logging.DEBUG:; logger.debug(""Gradient (sum sq norm): ""; ""{} "".format(self.grad_norm)). return self.fid_err_grad. [docs] def compute_fid_grad(self):; """"""; Calculates exact gradient of function wrt to each timeslot; control amplitudes. Note these gradients are not normalised; These are returned as a (nTimeslots x n_ctrls) array; """"""; dyn = self.parent; n_ctrls = dyn.num_ctrls; n_ts = dyn.num_tslots. # create n_ts x n_ctrls zero array for grad start point; grad = np.zeros([n_ts, n_ctrls], dtype=complex). dyn.tslot_computer.flag_all_calc_now(); dyn.compute_evolution(). # loop through all ctrl timeslots calculating gradients; time_st = timeit.default_timer(); for j in range(n_ctrls):; for k in range(n_ts):; fwd_evo = dyn._fwd_evo[k] ; onto_evo = dyn._onto_evo[k+1]; if dyn.oper_dtype == Qobj:; g = (onto_evo*dyn._get_prop_grad(k, j)*fwd_evo).tr(); else:; g = _trace(onto_evo.dot(; dyn._get_prop_grad(k, j)).dot(fwd_evo)); grad[k, j] = g; if dyn.stats is not None:; dyn.stats.wall_time_gradient_compute += \; ti",MatchSource.WIKI,docs/4.2/modules/qutip/control/fidcomp.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/control/fidcomp.html
https://qutip.org/docs/4.2/modules/qutip/control/fidcomp.html:18773,Testability,log,logging,18773,"Markovian dynamics'; Frederik F Floether, Pierre de Fouquieres, and Sophie G Schirmer. Attributes; ----------; scale_factor : float; The fidelity error calculated is of some arbitary scale. This; factor can be used to scale the fidelity error such that it may; represent some physical measure; If None is given then it is caculated as 1/2N, where N; is the dimension of the drift, when the Dynamics are initialised.; """""". def reset(self):; FidelityComputer.reset(self); self.id_text = 'TRACEDIFF'; self.scale_factor = None; self.uses_onwd_evo = True; if not self.parent.prop_computer.grad_exact:; raise errors.UsageError(; ""This FidelityComputer can only be""; "" used with an exact gradient PropagatorComputer.""); self.apply_params(). [docs] def init_comp(self):; """"""; initialises the computer based on the configuration of the Dynamics; Calculates the scale_factor is not already set; """"""; if self.scale_factor is None:; self.scale_factor = 1.0 / (2.0*self.parent.get_drift_dim()); if self.log_level <= logging.DEBUG:; logger.debug(""Scale factor calculated as {}"".format(; self.scale_factor)). [docs] def get_fid_err(self):; """"""; Gets the absolute error in the fidelity; """"""; if not self.fidelity_current:; dyn = self.parent; dyn.compute_evolution(); n_ts = dyn.num_tslots; evo_final = dyn._fwd_evo[n_ts]; evo_f_diff = dyn._target - evo_final; if self.log_level <= logging.DEBUG_VERBOSE:; logger.log(logging.DEBUG_VERBOSE, ""Calculating TraceDiff ""; ""fidelity...\n Target:\n{}\n Evo final:\n{}\n""; ""Evo final diff:\n{}"".format(dyn._target, evo_final,; evo_f_diff)). # Calculate the fidelity error using the trace difference norm; # Note that the value should have not imagnary part, so using; # np.real, just avoids the complex casting warning; if dyn.oper_dtype == Qobj:; self.fid_err = self.scale_factor*np.real(; (evo_f_diff.dag()*evo_f_diff).tr()); else:; self.fid_err = self.scale_factor*np.real(_trace(; evo_f_diff.conj().T.dot(evo_f_diff))). if np.isnan(self.fid_err):; self.fid_err = np.Inf. if",MatchSource.WIKI,docs/4.2/modules/qutip/control/fidcomp.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/control/fidcomp.html
https://qutip.org/docs/4.2/modules/qutip/control/fidcomp.html:18789,Testability,log,logger,18789,"'; Frederik F Floether, Pierre de Fouquieres, and Sophie G Schirmer. Attributes; ----------; scale_factor : float; The fidelity error calculated is of some arbitary scale. This; factor can be used to scale the fidelity error such that it may; represent some physical measure; If None is given then it is caculated as 1/2N, where N; is the dimension of the drift, when the Dynamics are initialised.; """""". def reset(self):; FidelityComputer.reset(self); self.id_text = 'TRACEDIFF'; self.scale_factor = None; self.uses_onwd_evo = True; if not self.parent.prop_computer.grad_exact:; raise errors.UsageError(; ""This FidelityComputer can only be""; "" used with an exact gradient PropagatorComputer.""); self.apply_params(). [docs] def init_comp(self):; """"""; initialises the computer based on the configuration of the Dynamics; Calculates the scale_factor is not already set; """"""; if self.scale_factor is None:; self.scale_factor = 1.0 / (2.0*self.parent.get_drift_dim()); if self.log_level <= logging.DEBUG:; logger.debug(""Scale factor calculated as {}"".format(; self.scale_factor)). [docs] def get_fid_err(self):; """"""; Gets the absolute error in the fidelity; """"""; if not self.fidelity_current:; dyn = self.parent; dyn.compute_evolution(); n_ts = dyn.num_tslots; evo_final = dyn._fwd_evo[n_ts]; evo_f_diff = dyn._target - evo_final; if self.log_level <= logging.DEBUG_VERBOSE:; logger.log(logging.DEBUG_VERBOSE, ""Calculating TraceDiff ""; ""fidelity...\n Target:\n{}\n Evo final:\n{}\n""; ""Evo final diff:\n{}"".format(dyn._target, evo_final,; evo_f_diff)). # Calculate the fidelity error using the trace difference norm; # Note that the value should have not imagnary part, so using; # np.real, just avoids the complex casting warning; if dyn.oper_dtype == Qobj:; self.fid_err = self.scale_factor*np.real(; (evo_f_diff.dag()*evo_f_diff).tr()); else:; self.fid_err = self.scale_factor*np.real(_trace(; evo_f_diff.conj().T.dot(evo_f_diff))). if np.isnan(self.fid_err):; self.fid_err = np.Inf. if dyn.stats is not ",MatchSource.WIKI,docs/4.2/modules/qutip/control/fidcomp.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/control/fidcomp.html
https://qutip.org/docs/4.2/modules/qutip/control/fidcomp.html:19135,Testability,log,logging,19135,"sion of the drift, when the Dynamics are initialised.; """""". def reset(self):; FidelityComputer.reset(self); self.id_text = 'TRACEDIFF'; self.scale_factor = None; self.uses_onwd_evo = True; if not self.parent.prop_computer.grad_exact:; raise errors.UsageError(; ""This FidelityComputer can only be""; "" used with an exact gradient PropagatorComputer.""); self.apply_params(). [docs] def init_comp(self):; """"""; initialises the computer based on the configuration of the Dynamics; Calculates the scale_factor is not already set; """"""; if self.scale_factor is None:; self.scale_factor = 1.0 / (2.0*self.parent.get_drift_dim()); if self.log_level <= logging.DEBUG:; logger.debug(""Scale factor calculated as {}"".format(; self.scale_factor)). [docs] def get_fid_err(self):; """"""; Gets the absolute error in the fidelity; """"""; if not self.fidelity_current:; dyn = self.parent; dyn.compute_evolution(); n_ts = dyn.num_tslots; evo_final = dyn._fwd_evo[n_ts]; evo_f_diff = dyn._target - evo_final; if self.log_level <= logging.DEBUG_VERBOSE:; logger.log(logging.DEBUG_VERBOSE, ""Calculating TraceDiff ""; ""fidelity...\n Target:\n{}\n Evo final:\n{}\n""; ""Evo final diff:\n{}"".format(dyn._target, evo_final,; evo_f_diff)). # Calculate the fidelity error using the trace difference norm; # Note that the value should have not imagnary part, so using; # np.real, just avoids the complex casting warning; if dyn.oper_dtype == Qobj:; self.fid_err = self.scale_factor*np.real(; (evo_f_diff.dag()*evo_f_diff).tr()); else:; self.fid_err = self.scale_factor*np.real(_trace(; evo_f_diff.conj().T.dot(evo_f_diff))). if np.isnan(self.fid_err):; self.fid_err = np.Inf. if dyn.stats is not None:; dyn.stats.num_fidelity_computes += 1. self.fidelity_current = True; if self.log_level <= logging.DEBUG:; logger.debug(""Fidelity error: {}"".format(self.fid_err)). return self.fid_err. [docs] def get_fid_err_gradient(self):; """"""; Returns the normalised gradient of the fidelity error; in a (nTimeslots x n_ctrls) array; The gradients are c",MatchSource.WIKI,docs/4.2/modules/qutip/control/fidcomp.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/control/fidcomp.html
https://qutip.org/docs/4.2/modules/qutip/control/fidcomp.html:19159,Testability,log,logger,19159,"n the Dynamics are initialised.; """""". def reset(self):; FidelityComputer.reset(self); self.id_text = 'TRACEDIFF'; self.scale_factor = None; self.uses_onwd_evo = True; if not self.parent.prop_computer.grad_exact:; raise errors.UsageError(; ""This FidelityComputer can only be""; "" used with an exact gradient PropagatorComputer.""); self.apply_params(). [docs] def init_comp(self):; """"""; initialises the computer based on the configuration of the Dynamics; Calculates the scale_factor is not already set; """"""; if self.scale_factor is None:; self.scale_factor = 1.0 / (2.0*self.parent.get_drift_dim()); if self.log_level <= logging.DEBUG:; logger.debug(""Scale factor calculated as {}"".format(; self.scale_factor)). [docs] def get_fid_err(self):; """"""; Gets the absolute error in the fidelity; """"""; if not self.fidelity_current:; dyn = self.parent; dyn.compute_evolution(); n_ts = dyn.num_tslots; evo_final = dyn._fwd_evo[n_ts]; evo_f_diff = dyn._target - evo_final; if self.log_level <= logging.DEBUG_VERBOSE:; logger.log(logging.DEBUG_VERBOSE, ""Calculating TraceDiff ""; ""fidelity...\n Target:\n{}\n Evo final:\n{}\n""; ""Evo final diff:\n{}"".format(dyn._target, evo_final,; evo_f_diff)). # Calculate the fidelity error using the trace difference norm; # Note that the value should have not imagnary part, so using; # np.real, just avoids the complex casting warning; if dyn.oper_dtype == Qobj:; self.fid_err = self.scale_factor*np.real(; (evo_f_diff.dag()*evo_f_diff).tr()); else:; self.fid_err = self.scale_factor*np.real(_trace(; evo_f_diff.conj().T.dot(evo_f_diff))). if np.isnan(self.fid_err):; self.fid_err = np.Inf. if dyn.stats is not None:; dyn.stats.num_fidelity_computes += 1. self.fidelity_current = True; if self.log_level <= logging.DEBUG:; logger.debug(""Fidelity error: {}"".format(self.fid_err)). return self.fid_err. [docs] def get_fid_err_gradient(self):; """"""; Returns the normalised gradient of the fidelity error; in a (nTimeslots x n_ctrls) array; The gradients are cached in case they are",MatchSource.WIKI,docs/4.2/modules/qutip/control/fidcomp.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/control/fidcomp.html
https://qutip.org/docs/4.2/modules/qutip/control/fidcomp.html:19166,Testability,log,log,19166," initialised.; """""". def reset(self):; FidelityComputer.reset(self); self.id_text = 'TRACEDIFF'; self.scale_factor = None; self.uses_onwd_evo = True; if not self.parent.prop_computer.grad_exact:; raise errors.UsageError(; ""This FidelityComputer can only be""; "" used with an exact gradient PropagatorComputer.""); self.apply_params(). [docs] def init_comp(self):; """"""; initialises the computer based on the configuration of the Dynamics; Calculates the scale_factor is not already set; """"""; if self.scale_factor is None:; self.scale_factor = 1.0 / (2.0*self.parent.get_drift_dim()); if self.log_level <= logging.DEBUG:; logger.debug(""Scale factor calculated as {}"".format(; self.scale_factor)). [docs] def get_fid_err(self):; """"""; Gets the absolute error in the fidelity; """"""; if not self.fidelity_current:; dyn = self.parent; dyn.compute_evolution(); n_ts = dyn.num_tslots; evo_final = dyn._fwd_evo[n_ts]; evo_f_diff = dyn._target - evo_final; if self.log_level <= logging.DEBUG_VERBOSE:; logger.log(logging.DEBUG_VERBOSE, ""Calculating TraceDiff ""; ""fidelity...\n Target:\n{}\n Evo final:\n{}\n""; ""Evo final diff:\n{}"".format(dyn._target, evo_final,; evo_f_diff)). # Calculate the fidelity error using the trace difference norm; # Note that the value should have not imagnary part, so using; # np.real, just avoids the complex casting warning; if dyn.oper_dtype == Qobj:; self.fid_err = self.scale_factor*np.real(; (evo_f_diff.dag()*evo_f_diff).tr()); else:; self.fid_err = self.scale_factor*np.real(_trace(; evo_f_diff.conj().T.dot(evo_f_diff))). if np.isnan(self.fid_err):; self.fid_err = np.Inf. if dyn.stats is not None:; dyn.stats.num_fidelity_computes += 1. self.fidelity_current = True; if self.log_level <= logging.DEBUG:; logger.debug(""Fidelity error: {}"".format(self.fid_err)). return self.fid_err. [docs] def get_fid_err_gradient(self):; """"""; Returns the normalised gradient of the fidelity error; in a (nTimeslots x n_ctrls) array; The gradients are cached in case they are requested; mutli",MatchSource.WIKI,docs/4.2/modules/qutip/control/fidcomp.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/control/fidcomp.html
https://qutip.org/docs/4.2/modules/qutip/control/fidcomp.html:19170,Testability,log,logging,19170," initialised.; """""". def reset(self):; FidelityComputer.reset(self); self.id_text = 'TRACEDIFF'; self.scale_factor = None; self.uses_onwd_evo = True; if not self.parent.prop_computer.grad_exact:; raise errors.UsageError(; ""This FidelityComputer can only be""; "" used with an exact gradient PropagatorComputer.""); self.apply_params(). [docs] def init_comp(self):; """"""; initialises the computer based on the configuration of the Dynamics; Calculates the scale_factor is not already set; """"""; if self.scale_factor is None:; self.scale_factor = 1.0 / (2.0*self.parent.get_drift_dim()); if self.log_level <= logging.DEBUG:; logger.debug(""Scale factor calculated as {}"".format(; self.scale_factor)). [docs] def get_fid_err(self):; """"""; Gets the absolute error in the fidelity; """"""; if not self.fidelity_current:; dyn = self.parent; dyn.compute_evolution(); n_ts = dyn.num_tslots; evo_final = dyn._fwd_evo[n_ts]; evo_f_diff = dyn._target - evo_final; if self.log_level <= logging.DEBUG_VERBOSE:; logger.log(logging.DEBUG_VERBOSE, ""Calculating TraceDiff ""; ""fidelity...\n Target:\n{}\n Evo final:\n{}\n""; ""Evo final diff:\n{}"".format(dyn._target, evo_final,; evo_f_diff)). # Calculate the fidelity error using the trace difference norm; # Note that the value should have not imagnary part, so using; # np.real, just avoids the complex casting warning; if dyn.oper_dtype == Qobj:; self.fid_err = self.scale_factor*np.real(; (evo_f_diff.dag()*evo_f_diff).tr()); else:; self.fid_err = self.scale_factor*np.real(_trace(; evo_f_diff.conj().T.dot(evo_f_diff))). if np.isnan(self.fid_err):; self.fid_err = np.Inf. if dyn.stats is not None:; dyn.stats.num_fidelity_computes += 1. self.fidelity_current = True; if self.log_level <= logging.DEBUG:; logger.debug(""Fidelity error: {}"".format(self.fid_err)). return self.fid_err. [docs] def get_fid_err_gradient(self):; """"""; Returns the normalised gradient of the fidelity error; in a (nTimeslots x n_ctrls) array; The gradients are cached in case they are requested; mutli",MatchSource.WIKI,docs/4.2/modules/qutip/control/fidcomp.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/control/fidcomp.html
https://qutip.org/docs/4.2/modules/qutip/control/fidcomp.html:19885,Testability,log,logging,19885,"_err(self):; """"""; Gets the absolute error in the fidelity; """"""; if not self.fidelity_current:; dyn = self.parent; dyn.compute_evolution(); n_ts = dyn.num_tslots; evo_final = dyn._fwd_evo[n_ts]; evo_f_diff = dyn._target - evo_final; if self.log_level <= logging.DEBUG_VERBOSE:; logger.log(logging.DEBUG_VERBOSE, ""Calculating TraceDiff ""; ""fidelity...\n Target:\n{}\n Evo final:\n{}\n""; ""Evo final diff:\n{}"".format(dyn._target, evo_final,; evo_f_diff)). # Calculate the fidelity error using the trace difference norm; # Note that the value should have not imagnary part, so using; # np.real, just avoids the complex casting warning; if dyn.oper_dtype == Qobj:; self.fid_err = self.scale_factor*np.real(; (evo_f_diff.dag()*evo_f_diff).tr()); else:; self.fid_err = self.scale_factor*np.real(_trace(; evo_f_diff.conj().T.dot(evo_f_diff))). if np.isnan(self.fid_err):; self.fid_err = np.Inf. if dyn.stats is not None:; dyn.stats.num_fidelity_computes += 1. self.fidelity_current = True; if self.log_level <= logging.DEBUG:; logger.debug(""Fidelity error: {}"".format(self.fid_err)). return self.fid_err. [docs] def get_fid_err_gradient(self):; """"""; Returns the normalised gradient of the fidelity error; in a (nTimeslots x n_ctrls) array; The gradients are cached in case they are requested; mutliple times between control updates; (although this is not typically found to happen); """"""; if not self.fid_err_grad_current:; dyn = self.parent; self.fid_err_grad = self.compute_fid_err_grad(); self.fid_err_grad_current = True; if dyn.stats is not None:; dyn.stats.num_grad_computes += 1. self.grad_norm = np.sqrt(np.sum(self.fid_err_grad**2)); if self.log_level <= logging.DEBUG_INTENSE:; logger.log(logging.DEBUG_INTENSE, ""fidelity error gradients:\n""; ""{}"".format(self.fid_err_grad)). if self.log_level <= logging.DEBUG:; logger.debug(""Gradient norm: ""; ""{} "".format(self.grad_norm)). return self.fid_err_grad. [docs] def compute_fid_err_grad(self):; """"""; Calculate exact gradient of the fidelity error functi",MatchSource.WIKI,docs/4.2/modules/qutip/control/fidcomp.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/control/fidcomp.html
https://qutip.org/docs/4.2/modules/qutip/control/fidcomp.html:19901,Testability,log,logger,19901,"Gets the absolute error in the fidelity; """"""; if not self.fidelity_current:; dyn = self.parent; dyn.compute_evolution(); n_ts = dyn.num_tslots; evo_final = dyn._fwd_evo[n_ts]; evo_f_diff = dyn._target - evo_final; if self.log_level <= logging.DEBUG_VERBOSE:; logger.log(logging.DEBUG_VERBOSE, ""Calculating TraceDiff ""; ""fidelity...\n Target:\n{}\n Evo final:\n{}\n""; ""Evo final diff:\n{}"".format(dyn._target, evo_final,; evo_f_diff)). # Calculate the fidelity error using the trace difference norm; # Note that the value should have not imagnary part, so using; # np.real, just avoids the complex casting warning; if dyn.oper_dtype == Qobj:; self.fid_err = self.scale_factor*np.real(; (evo_f_diff.dag()*evo_f_diff).tr()); else:; self.fid_err = self.scale_factor*np.real(_trace(; evo_f_diff.conj().T.dot(evo_f_diff))). if np.isnan(self.fid_err):; self.fid_err = np.Inf. if dyn.stats is not None:; dyn.stats.num_fidelity_computes += 1. self.fidelity_current = True; if self.log_level <= logging.DEBUG:; logger.debug(""Fidelity error: {}"".format(self.fid_err)). return self.fid_err. [docs] def get_fid_err_gradient(self):; """"""; Returns the normalised gradient of the fidelity error; in a (nTimeslots x n_ctrls) array; The gradients are cached in case they are requested; mutliple times between control updates; (although this is not typically found to happen); """"""; if not self.fid_err_grad_current:; dyn = self.parent; self.fid_err_grad = self.compute_fid_err_grad(); self.fid_err_grad_current = True; if dyn.stats is not None:; dyn.stats.num_grad_computes += 1. self.grad_norm = np.sqrt(np.sum(self.fid_err_grad**2)); if self.log_level <= logging.DEBUG_INTENSE:; logger.log(logging.DEBUG_INTENSE, ""fidelity error gradients:\n""; ""{}"".format(self.fid_err_grad)). if self.log_level <= logging.DEBUG:; logger.debug(""Gradient norm: ""; ""{} "".format(self.grad_norm)). return self.fid_err_grad. [docs] def compute_fid_err_grad(self):; """"""; Calculate exact gradient of the fidelity error function; wrt to each ti",MatchSource.WIKI,docs/4.2/modules/qutip/control/fidcomp.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/control/fidcomp.html
https://qutip.org/docs/4.2/modules/qutip/control/fidcomp.html:20537,Testability,log,logging,20537," Qobj:; self.fid_err = self.scale_factor*np.real(; (evo_f_diff.dag()*evo_f_diff).tr()); else:; self.fid_err = self.scale_factor*np.real(_trace(; evo_f_diff.conj().T.dot(evo_f_diff))). if np.isnan(self.fid_err):; self.fid_err = np.Inf. if dyn.stats is not None:; dyn.stats.num_fidelity_computes += 1. self.fidelity_current = True; if self.log_level <= logging.DEBUG:; logger.debug(""Fidelity error: {}"".format(self.fid_err)). return self.fid_err. [docs] def get_fid_err_gradient(self):; """"""; Returns the normalised gradient of the fidelity error; in a (nTimeslots x n_ctrls) array; The gradients are cached in case they are requested; mutliple times between control updates; (although this is not typically found to happen); """"""; if not self.fid_err_grad_current:; dyn = self.parent; self.fid_err_grad = self.compute_fid_err_grad(); self.fid_err_grad_current = True; if dyn.stats is not None:; dyn.stats.num_grad_computes += 1. self.grad_norm = np.sqrt(np.sum(self.fid_err_grad**2)); if self.log_level <= logging.DEBUG_INTENSE:; logger.log(logging.DEBUG_INTENSE, ""fidelity error gradients:\n""; ""{}"".format(self.fid_err_grad)). if self.log_level <= logging.DEBUG:; logger.debug(""Gradient norm: ""; ""{} "".format(self.grad_norm)). return self.fid_err_grad. [docs] def compute_fid_err_grad(self):; """"""; Calculate exact gradient of the fidelity error function; wrt to each timeslot control amplitudes.; Uses the trace difference norm fidelity; These are returned as a (nTimeslots x n_ctrls) array; """"""; dyn = self.parent; n_ctrls = dyn.num_ctrls; n_ts = dyn.num_tslots. # create n_ts x n_ctrls zero array for grad start point; grad = np.zeros([n_ts, n_ctrls]). dyn.tslot_computer.flag_all_calc_now(); dyn.compute_evolution(). # loop through all ctrl timeslots calculating gradients; time_st = timeit.default_timer(). evo_final = dyn._fwd_evo[n_ts]; evo_f_diff = dyn._target - evo_final; for j in range(n_ctrls):; for k in range(n_ts):; fwd_evo = dyn._fwd_evo[k]; if dyn.oper_dtype == Qobj:; evo_grad = dyn._ge",MatchSource.WIKI,docs/4.2/modules/qutip/control/fidcomp.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/control/fidcomp.html
https://qutip.org/docs/4.2/modules/qutip/control/fidcomp.html:20561,Testability,log,logger,20561," self.scale_factor*np.real(; (evo_f_diff.dag()*evo_f_diff).tr()); else:; self.fid_err = self.scale_factor*np.real(_trace(; evo_f_diff.conj().T.dot(evo_f_diff))). if np.isnan(self.fid_err):; self.fid_err = np.Inf. if dyn.stats is not None:; dyn.stats.num_fidelity_computes += 1. self.fidelity_current = True; if self.log_level <= logging.DEBUG:; logger.debug(""Fidelity error: {}"".format(self.fid_err)). return self.fid_err. [docs] def get_fid_err_gradient(self):; """"""; Returns the normalised gradient of the fidelity error; in a (nTimeslots x n_ctrls) array; The gradients are cached in case they are requested; mutliple times between control updates; (although this is not typically found to happen); """"""; if not self.fid_err_grad_current:; dyn = self.parent; self.fid_err_grad = self.compute_fid_err_grad(); self.fid_err_grad_current = True; if dyn.stats is not None:; dyn.stats.num_grad_computes += 1. self.grad_norm = np.sqrt(np.sum(self.fid_err_grad**2)); if self.log_level <= logging.DEBUG_INTENSE:; logger.log(logging.DEBUG_INTENSE, ""fidelity error gradients:\n""; ""{}"".format(self.fid_err_grad)). if self.log_level <= logging.DEBUG:; logger.debug(""Gradient norm: ""; ""{} "".format(self.grad_norm)). return self.fid_err_grad. [docs] def compute_fid_err_grad(self):; """"""; Calculate exact gradient of the fidelity error function; wrt to each timeslot control amplitudes.; Uses the trace difference norm fidelity; These are returned as a (nTimeslots x n_ctrls) array; """"""; dyn = self.parent; n_ctrls = dyn.num_ctrls; n_ts = dyn.num_tslots. # create n_ts x n_ctrls zero array for grad start point; grad = np.zeros([n_ts, n_ctrls]). dyn.tslot_computer.flag_all_calc_now(); dyn.compute_evolution(). # loop through all ctrl timeslots calculating gradients; time_st = timeit.default_timer(). evo_final = dyn._fwd_evo[n_ts]; evo_f_diff = dyn._target - evo_final; for j in range(n_ctrls):; for k in range(n_ts):; fwd_evo = dyn._fwd_evo[k]; if dyn.oper_dtype == Qobj:; evo_grad = dyn._get_prop_grad(k, j)*fwd_",MatchSource.WIKI,docs/4.2/modules/qutip/control/fidcomp.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/control/fidcomp.html
https://qutip.org/docs/4.2/modules/qutip/control/fidcomp.html:20568,Testability,log,log,20568,"*np.real(; (evo_f_diff.dag()*evo_f_diff).tr()); else:; self.fid_err = self.scale_factor*np.real(_trace(; evo_f_diff.conj().T.dot(evo_f_diff))). if np.isnan(self.fid_err):; self.fid_err = np.Inf. if dyn.stats is not None:; dyn.stats.num_fidelity_computes += 1. self.fidelity_current = True; if self.log_level <= logging.DEBUG:; logger.debug(""Fidelity error: {}"".format(self.fid_err)). return self.fid_err. [docs] def get_fid_err_gradient(self):; """"""; Returns the normalised gradient of the fidelity error; in a (nTimeslots x n_ctrls) array; The gradients are cached in case they are requested; mutliple times between control updates; (although this is not typically found to happen); """"""; if not self.fid_err_grad_current:; dyn = self.parent; self.fid_err_grad = self.compute_fid_err_grad(); self.fid_err_grad_current = True; if dyn.stats is not None:; dyn.stats.num_grad_computes += 1. self.grad_norm = np.sqrt(np.sum(self.fid_err_grad**2)); if self.log_level <= logging.DEBUG_INTENSE:; logger.log(logging.DEBUG_INTENSE, ""fidelity error gradients:\n""; ""{}"".format(self.fid_err_grad)). if self.log_level <= logging.DEBUG:; logger.debug(""Gradient norm: ""; ""{} "".format(self.grad_norm)). return self.fid_err_grad. [docs] def compute_fid_err_grad(self):; """"""; Calculate exact gradient of the fidelity error function; wrt to each timeslot control amplitudes.; Uses the trace difference norm fidelity; These are returned as a (nTimeslots x n_ctrls) array; """"""; dyn = self.parent; n_ctrls = dyn.num_ctrls; n_ts = dyn.num_tslots. # create n_ts x n_ctrls zero array for grad start point; grad = np.zeros([n_ts, n_ctrls]). dyn.tslot_computer.flag_all_calc_now(); dyn.compute_evolution(). # loop through all ctrl timeslots calculating gradients; time_st = timeit.default_timer(). evo_final = dyn._fwd_evo[n_ts]; evo_f_diff = dyn._target - evo_final; for j in range(n_ctrls):; for k in range(n_ts):; fwd_evo = dyn._fwd_evo[k]; if dyn.oper_dtype == Qobj:; evo_grad = dyn._get_prop_grad(k, j)*fwd_evo; if k+1 < n_t",MatchSource.WIKI,docs/4.2/modules/qutip/control/fidcomp.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/control/fidcomp.html
https://qutip.org/docs/4.2/modules/qutip/control/fidcomp.html:20572,Testability,log,logging,20572,"*np.real(; (evo_f_diff.dag()*evo_f_diff).tr()); else:; self.fid_err = self.scale_factor*np.real(_trace(; evo_f_diff.conj().T.dot(evo_f_diff))). if np.isnan(self.fid_err):; self.fid_err = np.Inf. if dyn.stats is not None:; dyn.stats.num_fidelity_computes += 1. self.fidelity_current = True; if self.log_level <= logging.DEBUG:; logger.debug(""Fidelity error: {}"".format(self.fid_err)). return self.fid_err. [docs] def get_fid_err_gradient(self):; """"""; Returns the normalised gradient of the fidelity error; in a (nTimeslots x n_ctrls) array; The gradients are cached in case they are requested; mutliple times between control updates; (although this is not typically found to happen); """"""; if not self.fid_err_grad_current:; dyn = self.parent; self.fid_err_grad = self.compute_fid_err_grad(); self.fid_err_grad_current = True; if dyn.stats is not None:; dyn.stats.num_grad_computes += 1. self.grad_norm = np.sqrt(np.sum(self.fid_err_grad**2)); if self.log_level <= logging.DEBUG_INTENSE:; logger.log(logging.DEBUG_INTENSE, ""fidelity error gradients:\n""; ""{}"".format(self.fid_err_grad)). if self.log_level <= logging.DEBUG:; logger.debug(""Gradient norm: ""; ""{} "".format(self.grad_norm)). return self.fid_err_grad. [docs] def compute_fid_err_grad(self):; """"""; Calculate exact gradient of the fidelity error function; wrt to each timeslot control amplitudes.; Uses the trace difference norm fidelity; These are returned as a (nTimeslots x n_ctrls) array; """"""; dyn = self.parent; n_ctrls = dyn.num_ctrls; n_ts = dyn.num_tslots. # create n_ts x n_ctrls zero array for grad start point; grad = np.zeros([n_ts, n_ctrls]). dyn.tslot_computer.flag_all_calc_now(); dyn.compute_evolution(). # loop through all ctrl timeslots calculating gradients; time_st = timeit.default_timer(). evo_final = dyn._fwd_evo[n_ts]; evo_f_diff = dyn._target - evo_final; for j in range(n_ctrls):; for k in range(n_ts):; fwd_evo = dyn._fwd_evo[k]; if dyn.oper_dtype == Qobj:; evo_grad = dyn._get_prop_grad(k, j)*fwd_evo; if k+1 < n_t",MatchSource.WIKI,docs/4.2/modules/qutip/control/fidcomp.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/control/fidcomp.html
https://qutip.org/docs/4.2/modules/qutip/control/fidcomp.html:20680,Testability,log,logging,20680,"; evo_f_diff.conj().T.dot(evo_f_diff))). if np.isnan(self.fid_err):; self.fid_err = np.Inf. if dyn.stats is not None:; dyn.stats.num_fidelity_computes += 1. self.fidelity_current = True; if self.log_level <= logging.DEBUG:; logger.debug(""Fidelity error: {}"".format(self.fid_err)). return self.fid_err. [docs] def get_fid_err_gradient(self):; """"""; Returns the normalised gradient of the fidelity error; in a (nTimeslots x n_ctrls) array; The gradients are cached in case they are requested; mutliple times between control updates; (although this is not typically found to happen); """"""; if not self.fid_err_grad_current:; dyn = self.parent; self.fid_err_grad = self.compute_fid_err_grad(); self.fid_err_grad_current = True; if dyn.stats is not None:; dyn.stats.num_grad_computes += 1. self.grad_norm = np.sqrt(np.sum(self.fid_err_grad**2)); if self.log_level <= logging.DEBUG_INTENSE:; logger.log(logging.DEBUG_INTENSE, ""fidelity error gradients:\n""; ""{}"".format(self.fid_err_grad)). if self.log_level <= logging.DEBUG:; logger.debug(""Gradient norm: ""; ""{} "".format(self.grad_norm)). return self.fid_err_grad. [docs] def compute_fid_err_grad(self):; """"""; Calculate exact gradient of the fidelity error function; wrt to each timeslot control amplitudes.; Uses the trace difference norm fidelity; These are returned as a (nTimeslots x n_ctrls) array; """"""; dyn = self.parent; n_ctrls = dyn.num_ctrls; n_ts = dyn.num_tslots. # create n_ts x n_ctrls zero array for grad start point; grad = np.zeros([n_ts, n_ctrls]). dyn.tslot_computer.flag_all_calc_now(); dyn.compute_evolution(). # loop through all ctrl timeslots calculating gradients; time_st = timeit.default_timer(). evo_final = dyn._fwd_evo[n_ts]; evo_f_diff = dyn._target - evo_final; for j in range(n_ctrls):; for k in range(n_ts):; fwd_evo = dyn._fwd_evo[k]; if dyn.oper_dtype == Qobj:; evo_grad = dyn._get_prop_grad(k, j)*fwd_evo; if k+1 < n_ts:; evo_grad = dyn._onwd_evo[k+1]*evo_grad; # Note that the value should have not imagnary part, so; # u",MatchSource.WIKI,docs/4.2/modules/qutip/control/fidcomp.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/control/fidcomp.html
https://qutip.org/docs/4.2/modules/qutip/control/fidcomp.html:20696,Testability,log,logger,20696,").T.dot(evo_f_diff))). if np.isnan(self.fid_err):; self.fid_err = np.Inf. if dyn.stats is not None:; dyn.stats.num_fidelity_computes += 1. self.fidelity_current = True; if self.log_level <= logging.DEBUG:; logger.debug(""Fidelity error: {}"".format(self.fid_err)). return self.fid_err. [docs] def get_fid_err_gradient(self):; """"""; Returns the normalised gradient of the fidelity error; in a (nTimeslots x n_ctrls) array; The gradients are cached in case they are requested; mutliple times between control updates; (although this is not typically found to happen); """"""; if not self.fid_err_grad_current:; dyn = self.parent; self.fid_err_grad = self.compute_fid_err_grad(); self.fid_err_grad_current = True; if dyn.stats is not None:; dyn.stats.num_grad_computes += 1. self.grad_norm = np.sqrt(np.sum(self.fid_err_grad**2)); if self.log_level <= logging.DEBUG_INTENSE:; logger.log(logging.DEBUG_INTENSE, ""fidelity error gradients:\n""; ""{}"".format(self.fid_err_grad)). if self.log_level <= logging.DEBUG:; logger.debug(""Gradient norm: ""; ""{} "".format(self.grad_norm)). return self.fid_err_grad. [docs] def compute_fid_err_grad(self):; """"""; Calculate exact gradient of the fidelity error function; wrt to each timeslot control amplitudes.; Uses the trace difference norm fidelity; These are returned as a (nTimeslots x n_ctrls) array; """"""; dyn = self.parent; n_ctrls = dyn.num_ctrls; n_ts = dyn.num_tslots. # create n_ts x n_ctrls zero array for grad start point; grad = np.zeros([n_ts, n_ctrls]). dyn.tslot_computer.flag_all_calc_now(); dyn.compute_evolution(). # loop through all ctrl timeslots calculating gradients; time_st = timeit.default_timer(). evo_final = dyn._fwd_evo[n_ts]; evo_f_diff = dyn._target - evo_final; for j in range(n_ctrls):; for k in range(n_ts):; fwd_evo = dyn._fwd_evo[k]; if dyn.oper_dtype == Qobj:; evo_grad = dyn._get_prop_grad(k, j)*fwd_evo; if k+1 < n_ts:; evo_grad = dyn._onwd_evo[k+1]*evo_grad; # Note that the value should have not imagnary part, so; # using np.real, just",MatchSource.WIKI,docs/4.2/modules/qutip/control/fidcomp.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/control/fidcomp.html
https://qutip.org/docs/4.2/modules/qutip/control/fidcomp.html:22995,Testability,log,logging,22995,"rad))); if np.isnan(g):; g = np.Inf. grad[k, j] = g; if dyn.stats is not None:; dyn.stats.wall_time_gradient_compute += \; timeit.default_timer() - time_st; return grad. [docs]class FidCompTraceDiffApprox(FidCompTraceDiff):; """"""; As FidCompTraceDiff, except uses the finite difference method to; compute approximate gradients. Attributes; ----------; epsilon : float; control amplitude offset to use when approximating the gradient wrt; a timeslot control amplitude; ; """"""; def reset(self):; FidelityComputer.reset(self); self.id_text = 'TDAPPROX'; self.uses_onwd_evo = True; self.scale_factor = None; self.epsilon = 0.001; self.apply_params(). [docs] def compute_fid_err_grad(self):; """"""; Calculates gradient of function wrt to each timeslot; control amplitudes. Note these gradients are not normalised; They are calulated; These are returned as a (nTimeslots x n_ctrls) array; """"""; dyn = self.parent; prop_comp = dyn.prop_computer; n_ctrls = dyn.num_ctrls; n_ts = dyn.num_tslots. if self.log_level >= logging.DEBUG:; logger.debug(""Computing fidelity error gradient""); # create n_ts x n_ctrls zero array for grad start point; grad = np.zeros([n_ts, n_ctrls]). dyn.tslot_computer.flag_all_calc_now(); dyn.compute_evolution(); curr_fid_err = self.get_fid_err(). # loop through all ctrl timeslots calculating gradients; time_st = timeit.default_timer(). for j in range(n_ctrls):; for k in range(n_ts):; fwd_evo = dyn._fwd_evo[k]; prop_eps = prop_comp._compute_diff_prop(k, j, self.epsilon); if dyn.oper_dtype == Qobj:; evo_final_eps = fwd_evo*prop_eps; if k+1 < n_ts:; evo_final_eps = evo_final_eps*dyn._onwd_evo[k+1]; evo_f_diff_eps = dyn._target - evo_final_eps; # Note that the value should have not imagnary part, so; # using np.real, just avoids the complex casting warning; fid_err_eps = self.scale_factor*np.real(; (evo_f_diff_eps.dag()*evo_f_diff_eps).tr()); else:; evo_final_eps = fwd_evo.dot(prop_eps); if k+1 < n_ts:; evo_final_eps = evo_final_eps.dot(dyn._onwd_evo[k+1]); evo_f_diff_eps = dy",MatchSource.WIKI,docs/4.2/modules/qutip/control/fidcomp.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/control/fidcomp.html
https://qutip.org/docs/4.2/modules/qutip/control/fidcomp.html:23011,Testability,log,logger,23011,"n(g):; g = np.Inf. grad[k, j] = g; if dyn.stats is not None:; dyn.stats.wall_time_gradient_compute += \; timeit.default_timer() - time_st; return grad. [docs]class FidCompTraceDiffApprox(FidCompTraceDiff):; """"""; As FidCompTraceDiff, except uses the finite difference method to; compute approximate gradients. Attributes; ----------; epsilon : float; control amplitude offset to use when approximating the gradient wrt; a timeslot control amplitude; ; """"""; def reset(self):; FidelityComputer.reset(self); self.id_text = 'TDAPPROX'; self.uses_onwd_evo = True; self.scale_factor = None; self.epsilon = 0.001; self.apply_params(). [docs] def compute_fid_err_grad(self):; """"""; Calculates gradient of function wrt to each timeslot; control amplitudes. Note these gradients are not normalised; They are calulated; These are returned as a (nTimeslots x n_ctrls) array; """"""; dyn = self.parent; prop_comp = dyn.prop_computer; n_ctrls = dyn.num_ctrls; n_ts = dyn.num_tslots. if self.log_level >= logging.DEBUG:; logger.debug(""Computing fidelity error gradient""); # create n_ts x n_ctrls zero array for grad start point; grad = np.zeros([n_ts, n_ctrls]). dyn.tslot_computer.flag_all_calc_now(); dyn.compute_evolution(); curr_fid_err = self.get_fid_err(). # loop through all ctrl timeslots calculating gradients; time_st = timeit.default_timer(). for j in range(n_ctrls):; for k in range(n_ts):; fwd_evo = dyn._fwd_evo[k]; prop_eps = prop_comp._compute_diff_prop(k, j, self.epsilon); if dyn.oper_dtype == Qobj:; evo_final_eps = fwd_evo*prop_eps; if k+1 < n_ts:; evo_final_eps = evo_final_eps*dyn._onwd_evo[k+1]; evo_f_diff_eps = dyn._target - evo_final_eps; # Note that the value should have not imagnary part, so; # using np.real, just avoids the complex casting warning; fid_err_eps = self.scale_factor*np.real(; (evo_f_diff_eps.dag()*evo_f_diff_eps).tr()); else:; evo_final_eps = fwd_evo.dot(prop_eps); if k+1 < n_ts:; evo_final_eps = evo_final_eps.dot(dyn._onwd_evo[k+1]); evo_f_diff_eps = dyn._target - evo_fi",MatchSource.WIKI,docs/4.2/modules/qutip/control/fidcomp.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/control/fidcomp.html
https://qutip.org/docs/4.2/modules/qutip/control/fidcomp.html:2637,Usability,simpl,simple,2637,"QUENTIAL DAMAGES (INCLUDING, BUT NOT; # LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,; # DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY; # THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT; # (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE; # OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.; ###############################################################################. # @author: Alexander Pitchford; # @email1: agp1@aber.ac.uk; # @email2: alex.pitchford@gmail.com; # @organization: Aberystwyth University; # @supervisor: Daniel Burgarth. """"""; Fidelity Computer. These classes calculate the fidelity error - function to be minimised; and fidelity error gradient, which is used to direct the optimisation. They may calculate the fidelity as an intermediary step, as in some case; e.g. unitary dynamics, this is more efficient. The idea is that different methods for computing the fidelity can be tried; and compared using simple configuration switches. Note the methods in these classes were inspired by:; DYNAMO - Dynamic Framework for Quantum Optimal Control; See Machnes et.al., arXiv.1011.4874; The unitary dynamics fidelity is taken directly frm DYNAMO; The other fidelity measures are extensions, and the sources are given; in the class descriptions.; """""". import os; import warnings; import numpy as np; import scipy.sparse as sp; # import scipy.linalg as la; import timeit; # QuTiP; from qutip import Qobj; # QuTiP logging; import qutip.logging_utils as logging; logger = logging.get_logger(); # QuTiP control modules; import qutip.control.errors as errors. warnings.simplefilter('always', DeprecationWarning) #turn off filter; def _attrib_deprecation(message, stacklevel=3):; """"""; Issue deprecation warning; Using stacklevel=3 will ensure message refers the function; calling with the deprecated parameter,; """"""; warnings.warn(message, DeprecationWarning, stacklevel=stacklevel). ",MatchSource.WIKI,docs/4.2/modules/qutip/control/fidcomp.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/control/fidcomp.html
https://qutip.org/docs/4.2/modules/qutip/control/fidcomp.html:3290,Usability,simpl,simplefilter,3290,"n. They may calculate the fidelity as an intermediary step, as in some case; e.g. unitary dynamics, this is more efficient. The idea is that different methods for computing the fidelity can be tried; and compared using simple configuration switches. Note the methods in these classes were inspired by:; DYNAMO - Dynamic Framework for Quantum Optimal Control; See Machnes et.al., arXiv.1011.4874; The unitary dynamics fidelity is taken directly frm DYNAMO; The other fidelity measures are extensions, and the sources are given; in the class descriptions.; """""". import os; import warnings; import numpy as np; import scipy.sparse as sp; # import scipy.linalg as la; import timeit; # QuTiP; from qutip import Qobj; # QuTiP logging; import qutip.logging_utils as logging; logger = logging.get_logger(); # QuTiP control modules; import qutip.control.errors as errors. warnings.simplefilter('always', DeprecationWarning) #turn off filter; def _attrib_deprecation(message, stacklevel=3):; """"""; Issue deprecation warning; Using stacklevel=3 will ensure message refers the function; calling with the deprecated parameter,; """"""; warnings.warn(message, DeprecationWarning, stacklevel=stacklevel). def _func_deprecation(message, stacklevel=3):; """"""; Issue deprecation warning; Using stacklevel=3 will ensure message refers the function; calling with the deprecated parameter,; """"""; warnings.warn(message, DeprecationWarning, stacklevel=stacklevel); ; def _trace(A):; """"""wrapper for calculating the trace""""""; # input is an operator (Qobj, array, sparse etc), so; if isinstance(A, Qobj):; return A.tr(); elif isinstance(A, np.ndarray):; return np.trace(A); else:; #Assume A some sparse matrix; return np.sum(A.diagonal()). [docs]class FidelityComputer(object):; """"""; Base class for all Fidelity Computers.; This cannot be used directly. See subclass descriptions and choose; one appropriate for the application; Note: this must be instantiated with a Dynamics object, that is the; container for the data that the m",MatchSource.WIKI,docs/4.2/modules/qutip/control/fidcomp.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/control/fidcomp.html
https://qutip.org/docs/4.2/modules/qutip/control/fidcomp.html:6293,Usability,clear,clear,6293,"Computer. uses_onto_evo : boolean; flag to specify whether the onto_evo evolution operator; (see Dynamics) is used by the FidelityComputer. fid_err : float; Last computed value of the fidelity error. fidelity : float; Last computed value of the normalised fidelity. fidelity_current : boolean; flag to specify whether the fidelity / fid_err are based on the; current amplitude values. Set False when amplitudes change. fid_err_grad: array[num_tslot, num_ctrls] of float; Last computed values for the fidelity error gradients wrt the; control in the timeslot. grad_norm : float; Last computed value for the norm of the fidelity error gradients; (sqrt of the sum of the squares). fid_err_grad_current : boolean; flag to specify whether the fidelity / fid_err are based on the; current amplitude values. Set False when amplitudes change; """"""; def __init__(self, dynamics, params=None):; self.parent = dynamics; self.params = params; self.reset(). [docs] def reset(self):; """"""; reset any configuration data and; clear any temporarily held status data; """"""; self.log_level = self.parent.log_level; self.id_text = 'FID_COMP_BASE'; self.dimensional_norm = 1.0; self.fid_norm_func = None; self.grad_norm_func = None; self.uses_onwd_evo = False; self.uses_onto_evo = False; self.apply_params(); self.clear(). [docs] def clear(self):; """"""; clear any temporarily held status data; """"""; self.fid_err = None; self.fidelity = None; self.fid_err_grad = None; self.grad_norm = np.inf; self.fidelity_current = False; self.fid_err_grad_current = False; self.grad_norm = 0.0. [docs] def apply_params(self, params=None):; """"""; Set object attributes based on the dictionary (if any) passed in the; instantiation, or passed as a parameter; This is called during the instantiation automatically.; The key value pairs are the attribute name and value; Note: attributes are created if they do not exist already,; and are overwritten if they do.; """"""; if not params:; params = self.params. if isinstance(params, dict):; self.pa",MatchSource.WIKI,docs/4.2/modules/qutip/control/fidcomp.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/control/fidcomp.html
https://qutip.org/docs/4.2/modules/qutip/control/fidcomp.html:6576,Usability,clear,clear,6576,"lag to specify whether the fidelity / fid_err are based on the; current amplitude values. Set False when amplitudes change. fid_err_grad: array[num_tslot, num_ctrls] of float; Last computed values for the fidelity error gradients wrt the; control in the timeslot. grad_norm : float; Last computed value for the norm of the fidelity error gradients; (sqrt of the sum of the squares). fid_err_grad_current : boolean; flag to specify whether the fidelity / fid_err are based on the; current amplitude values. Set False when amplitudes change; """"""; def __init__(self, dynamics, params=None):; self.parent = dynamics; self.params = params; self.reset(). [docs] def reset(self):; """"""; reset any configuration data and; clear any temporarily held status data; """"""; self.log_level = self.parent.log_level; self.id_text = 'FID_COMP_BASE'; self.dimensional_norm = 1.0; self.fid_norm_func = None; self.grad_norm_func = None; self.uses_onwd_evo = False; self.uses_onto_evo = False; self.apply_params(); self.clear(). [docs] def clear(self):; """"""; clear any temporarily held status data; """"""; self.fid_err = None; self.fidelity = None; self.fid_err_grad = None; self.grad_norm = np.inf; self.fidelity_current = False; self.fid_err_grad_current = False; self.grad_norm = 0.0. [docs] def apply_params(self, params=None):; """"""; Set object attributes based on the dictionary (if any) passed in the; instantiation, or passed as a parameter; This is called during the instantiation automatically.; The key value pairs are the attribute name and value; Note: attributes are created if they do not exist already,; and are overwritten if they do.; """"""; if not params:; params = self.params. if isinstance(params, dict):; self.params = params; for key in params:; setattr(self, key, params[key]). @property; def log_level(self):; return logger.level ; ; @log_level.setter; def log_level(self, lvl):; """"""; Set the log_level attribute and set the level of the logger; that is call logger.setLevel(lvl); """"""; logger.setLevel(l",MatchSource.WIKI,docs/4.2/modules/qutip/control/fidcomp.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/control/fidcomp.html
https://qutip.org/docs/4.2/modules/qutip/control/fidcomp.html:6596,Usability,clear,clear,6596,"r are based on the; current amplitude values. Set False when amplitudes change. fid_err_grad: array[num_tslot, num_ctrls] of float; Last computed values for the fidelity error gradients wrt the; control in the timeslot. grad_norm : float; Last computed value for the norm of the fidelity error gradients; (sqrt of the sum of the squares). fid_err_grad_current : boolean; flag to specify whether the fidelity / fid_err are based on the; current amplitude values. Set False when amplitudes change; """"""; def __init__(self, dynamics, params=None):; self.parent = dynamics; self.params = params; self.reset(). [docs] def reset(self):; """"""; reset any configuration data and; clear any temporarily held status data; """"""; self.log_level = self.parent.log_level; self.id_text = 'FID_COMP_BASE'; self.dimensional_norm = 1.0; self.fid_norm_func = None; self.grad_norm_func = None; self.uses_onwd_evo = False; self.uses_onto_evo = False; self.apply_params(); self.clear(). [docs] def clear(self):; """"""; clear any temporarily held status data; """"""; self.fid_err = None; self.fidelity = None; self.fid_err_grad = None; self.grad_norm = np.inf; self.fidelity_current = False; self.fid_err_grad_current = False; self.grad_norm = 0.0. [docs] def apply_params(self, params=None):; """"""; Set object attributes based on the dictionary (if any) passed in the; instantiation, or passed as a parameter; This is called during the instantiation automatically.; The key value pairs are the attribute name and value; Note: attributes are created if they do not exist already,; and are overwritten if they do.; """"""; if not params:; params = self.params. if isinstance(params, dict):; self.params = params; for key in params:; setattr(self, key, params[key]). @property; def log_level(self):; return logger.level ; ; @log_level.setter; def log_level(self, lvl):; """"""; Set the log_level attribute and set the level of the logger; that is call logger.setLevel(lvl); """"""; logger.setLevel(lvl). [docs] def init_comp(self):; """"""; initia",MatchSource.WIKI,docs/4.2/modules/qutip/control/fidcomp.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/control/fidcomp.html
https://qutip.org/docs/4.2/modules/qutip/control/fidcomp.html:6615,Usability,clear,clear,6615,"r are based on the; current amplitude values. Set False when amplitudes change. fid_err_grad: array[num_tslot, num_ctrls] of float; Last computed values for the fidelity error gradients wrt the; control in the timeslot. grad_norm : float; Last computed value for the norm of the fidelity error gradients; (sqrt of the sum of the squares). fid_err_grad_current : boolean; flag to specify whether the fidelity / fid_err are based on the; current amplitude values. Set False when amplitudes change; """"""; def __init__(self, dynamics, params=None):; self.parent = dynamics; self.params = params; self.reset(). [docs] def reset(self):; """"""; reset any configuration data and; clear any temporarily held status data; """"""; self.log_level = self.parent.log_level; self.id_text = 'FID_COMP_BASE'; self.dimensional_norm = 1.0; self.fid_norm_func = None; self.grad_norm_func = None; self.uses_onwd_evo = False; self.uses_onto_evo = False; self.apply_params(); self.clear(). [docs] def clear(self):; """"""; clear any temporarily held status data; """"""; self.fid_err = None; self.fidelity = None; self.fid_err_grad = None; self.grad_norm = np.inf; self.fidelity_current = False; self.fid_err_grad_current = False; self.grad_norm = 0.0. [docs] def apply_params(self, params=None):; """"""; Set object attributes based on the dictionary (if any) passed in the; instantiation, or passed as a parameter; This is called during the instantiation automatically.; The key value pairs are the attribute name and value; Note: attributes are created if they do not exist already,; and are overwritten if they do.; """"""; if not params:; params = self.params. if isinstance(params, dict):; self.params = params; for key in params:; setattr(self, key, params[key]). @property; def log_level(self):; return logger.level ; ; @log_level.setter; def log_level(self, lvl):; """"""; Set the log_level attribute and set the level of the logger; that is call logger.setLevel(lvl); """"""; logger.setLevel(lvl). [docs] def init_comp(self):; """"""; initia",MatchSource.WIKI,docs/4.2/modules/qutip/control/fidcomp.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/control/fidcomp.html
https://qutip.org/docs/4.2/modules/qutip/control/fidcomp.html:10085,Usability,clear,clear,10085,"self, value):; _attrib_deprecation(; ""'uses_evo_t2targ' has been replaced by 'uses_onto_evo'""); self.uses_onto_evo = value. [docs]class FidCompUnitary(FidelityComputer):; """"""; Computes fidelity error and gradient assuming unitary dynamics, e.g.; closed qubit systems; Note fidelity and gradient calculations were taken from DYNAMO; (see file header). Attributes; ----------; phase_option : string; determines how global phase is treated in fidelity calculations:; PSU - global phase ignored; SU - global phase included. fidelity_prenorm : complex; Last computed value of the fidelity before it is normalised; It is stored to use in the gradient normalisation calculation. fidelity_prenorm_current : boolean; flag to specify whether fidelity_prenorm are based on the; current amplitude values. Set False when amplitudes change; """""". def reset(self):; FidelityComputer.reset(self); self.id_text = 'UNIT'; self.uses_onto_evo = True; self._init_phase_option('PSU'); self.apply_params(). def clear(self):; FidelityComputer.clear(self); self.fidelity_prenorm = None; self.fidelity_prenorm_current = False. [docs] def set_phase_option(self, phase_option=None):; """"""; Deprecated - use phase_option; Phase options are; SU - global phase important; PSU - global phase is not important; """"""; _func_deprecation(""'set_phase_option' is deprecated. ""; ""Use phase_option property""); self._init_phase_option(phase_option); ; @property; def phase_option(self):; return self._phase_option; ; @phase_option.setter; def phase_option(self, value):; """"""; # Phase options are; # SU - global phase important; # PSU - global phase is not important; """"""; self._init_phase_option(value). def _init_phase_option(self, value):; self._phase_option = value; if value == 'PSU':; self.fid_norm_func = self.normalize_PSU; self.grad_norm_func = self.normalize_gradient_PSU; elif value == 'SU':; self.fid_norm_func = self.normalize_SU; self.grad_norm_func = self.normalize_gradient_SU; elif value is None:; raise errors.UsageError(""phase",MatchSource.WIKI,docs/4.2/modules/qutip/control/fidcomp.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/control/fidcomp.html
https://qutip.org/docs/4.2/modules/qutip/control/fidcomp.html:10116,Usability,clear,clear,10116,"ecation(; ""'uses_evo_t2targ' has been replaced by 'uses_onto_evo'""); self.uses_onto_evo = value. [docs]class FidCompUnitary(FidelityComputer):; """"""; Computes fidelity error and gradient assuming unitary dynamics, e.g.; closed qubit systems; Note fidelity and gradient calculations were taken from DYNAMO; (see file header). Attributes; ----------; phase_option : string; determines how global phase is treated in fidelity calculations:; PSU - global phase ignored; SU - global phase included. fidelity_prenorm : complex; Last computed value of the fidelity before it is normalised; It is stored to use in the gradient normalisation calculation. fidelity_prenorm_current : boolean; flag to specify whether fidelity_prenorm are based on the; current amplitude values. Set False when amplitudes change; """""". def reset(self):; FidelityComputer.reset(self); self.id_text = 'UNIT'; self.uses_onto_evo = True; self._init_phase_option('PSU'); self.apply_params(). def clear(self):; FidelityComputer.clear(self); self.fidelity_prenorm = None; self.fidelity_prenorm_current = False. [docs] def set_phase_option(self, phase_option=None):; """"""; Deprecated - use phase_option; Phase options are; SU - global phase important; PSU - global phase is not important; """"""; _func_deprecation(""'set_phase_option' is deprecated. ""; ""Use phase_option property""); self._init_phase_option(phase_option); ; @property; def phase_option(self):; return self._phase_option; ; @phase_option.setter; def phase_option(self, value):; """"""; # Phase options are; # SU - global phase important; # PSU - global phase is not important; """"""; self._init_phase_option(value). def _init_phase_option(self, value):; self._phase_option = value; if value == 'PSU':; self.fid_norm_func = self.normalize_PSU; self.grad_norm_func = self.normalize_gradient_PSU; elif value == 'SU':; self.fid_norm_func = self.normalize_SU; self.grad_norm_func = self.normalize_gradient_SU; elif value is None:; raise errors.UsageError(""phase_option cannot be set to No",MatchSource.WIKI,docs/4.2/modules/qutip/control/fidcomp.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/control/fidcomp.html
https://qutip.org/docs/4.2/modules/qutip/control/optimizer.html:2643,Availability,error,error,2643,"OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT; # LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,; # DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY; # THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT; # (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE; # OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.; ###############################################################################. # @author: Alexander Pitchford; # @email1: agp1@aber.ac.uk; # @email2: alex.pitchford@gmail.com; # @organization: Aberystwyth University; # @supervisor: Daniel Burgarth. """"""; Classes here are expected to implement a run_optimization function; that will use some method for optimising the control pulse, as defined; by the control amplitudes. The system that the pulse acts upon are defined; by the Dynamics object that must be passed in the instantiation. The methods are typically N dimensional function optimisers that; find the minima of a fidelity error function. Note the number of variables; for the fidelity function is the number of control timeslots,; i.e. n_ctrls x Ntimeslots; The methods will call functions on the Dynamics.fid_computer object,; one or many times per interation,; to get the fidelity error and gradient wrt to the amplitudes.; The optimisation will stop when one of the termination conditions are met,; for example: the fidelity aim has be reached, a local minima has been found,; the maximum time allowed has been exceeded. These function optimisation methods are so far from SciPy.optimize; The two methods implemented are:; ; BFGS - BroydenâFletcherâGoldfarbâShanno algorithm; ; This a quasi second order Newton method. It uses successive calls to; the gradient function to make an estimation of the curvature (Hessian); and hence direct its search for the function minima; The SciPy implementation is pure Python and hance is execution speed is; not high; use subclass: Optimize",MatchSource.WIKI,docs/4.2/modules/qutip/control/optimizer.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/control/optimizer.html
https://qutip.org/docs/4.2/modules/qutip/control/optimizer.html:2904,Availability,error,error,2904,"CE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE; # OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.; ###############################################################################. # @author: Alexander Pitchford; # @email1: agp1@aber.ac.uk; # @email2: alex.pitchford@gmail.com; # @organization: Aberystwyth University; # @supervisor: Daniel Burgarth. """"""; Classes here are expected to implement a run_optimization function; that will use some method for optimising the control pulse, as defined; by the control amplitudes. The system that the pulse acts upon are defined; by the Dynamics object that must be passed in the instantiation. The methods are typically N dimensional function optimisers that; find the minima of a fidelity error function. Note the number of variables; for the fidelity function is the number of control timeslots,; i.e. n_ctrls x Ntimeslots; The methods will call functions on the Dynamics.fid_computer object,; one or many times per interation,; to get the fidelity error and gradient wrt to the amplitudes.; The optimisation will stop when one of the termination conditions are met,; for example: the fidelity aim has be reached, a local minima has been found,; the maximum time allowed has been exceeded. These function optimisation methods are so far from SciPy.optimize; The two methods implemented are:; ; BFGS - BroydenâFletcherâGoldfarbâShanno algorithm; ; This a quasi second order Newton method. It uses successive calls to; the gradient function to make an estimation of the curvature (Hessian); and hence direct its search for the function minima; The SciPy implementation is pure Python and hance is execution speed is; not high; use subclass: OptimizerBFGS. L-BFGS-B - Bounded, limited memory BFGS; ; This a version of the BFGS method where the Hessian approximation is; only based on a set of the most recent gradient calls. It generally; performs better where the are a large number of variables; The SciPy implementation of L-BFGS-B",MatchSource.WIKI,docs/4.2/modules/qutip/control/optimizer.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/control/optimizer.html
https://qutip.org/docs/4.2/modules/qutip/control/optimizer.html:4208,Availability,error,error,4208,"m SciPy.optimize; The two methods implemented are:; ; BFGS - BroydenâFletcherâGoldfarbâShanno algorithm; ; This a quasi second order Newton method. It uses successive calls to; the gradient function to make an estimation of the curvature (Hessian); and hence direct its search for the function minima; The SciPy implementation is pure Python and hance is execution speed is; not high; use subclass: OptimizerBFGS. L-BFGS-B - Bounded, limited memory BFGS; ; This a version of the BFGS method where the Hessian approximation is; only based on a set of the most recent gradient calls. It generally; performs better where the are a large number of variables; The SciPy implementation of L-BFGS-B is wrapper around a well; established and actively maintained implementation in Fortran; Its is therefore very fast.; # See SciPy documentation for credit and details on the; # scipy.optimize.fmin_l_bfgs_b function; use subclass: OptimizerLBFGSB. The baseclass Optimizer implements the function wrappers to the; fidelity error, gradient, and iteration callback functions.; These are called from the within the SciPy optimisation functions.; The subclasses implement the algorithm specific pulse optimisation function.; """""". import os; import numpy as np; import timeit; import scipy.optimize as spopt; import copy; import collections; # QuTiP; from qutip import Qobj; import qutip.logging_utils as logging; logger = logging.get_logger(); # QuTiP control modules; import qutip.control.optimresult as optimresult; import qutip.control.termcond as termcond; import qutip.control.errors as errors; import qutip.control.dynamics as dynamics; import qutip.control.pulsegen as pulsegen; import qutip.control.dump as qtrldump. def _is_string(var):; try:; if isinstance(var, basestring):; return True; except NameError:; try:; if isinstance(var, str):; return True; except:; return False; except:; return False. return False. [docs]class Optimizer(object):; """"""; Base class for all control pulse optimisers. This class",MatchSource.WIKI,docs/4.2/modules/qutip/control/optimizer.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/control/optimizer.html
https://qutip.org/docs/4.2/modules/qutip/control/optimizer.html:4763,Availability,error,errors,4763,"t generally; performs better where the are a large number of variables; The SciPy implementation of L-BFGS-B is wrapper around a well; established and actively maintained implementation in Fortran; Its is therefore very fast.; # See SciPy documentation for credit and details on the; # scipy.optimize.fmin_l_bfgs_b function; use subclass: OptimizerLBFGSB. The baseclass Optimizer implements the function wrappers to the; fidelity error, gradient, and iteration callback functions.; These are called from the within the SciPy optimisation functions.; The subclasses implement the algorithm specific pulse optimisation function.; """""". import os; import numpy as np; import timeit; import scipy.optimize as spopt; import copy; import collections; # QuTiP; from qutip import Qobj; import qutip.logging_utils as logging; logger = logging.get_logger(); # QuTiP control modules; import qutip.control.optimresult as optimresult; import qutip.control.termcond as termcond; import qutip.control.errors as errors; import qutip.control.dynamics as dynamics; import qutip.control.pulsegen as pulsegen; import qutip.control.dump as qtrldump. def _is_string(var):; try:; if isinstance(var, basestring):; return True; except NameError:; try:; if isinstance(var, str):; return True; except:; return False; except:; return False. return False. [docs]class Optimizer(object):; """"""; Base class for all control pulse optimisers. This class should not be; instantiated, use its subclasses; This class implements the fidelity, gradient and interation callback; functions.; All subclass objects must be initialised with a; ; OptimConfig instance - various configuration options; Dynamics instance - describes the dynamics of the (quantum) system; to be control optimised. Attributes; ----------; log_level : integer; level of messaging output from the logger.; Options are attributes of qutip.logging_utils,; in decreasing levels of messaging, are:; DEBUG_INTENSE, DEBUG_VERBOSE, DEBUG, INFO, WARN, ERROR, CRITICAL; Anything ",MatchSource.WIKI,docs/4.2/modules/qutip/control/optimizer.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/control/optimizer.html
https://qutip.org/docs/4.2/modules/qutip/control/optimizer.html:4773,Availability,error,errors,4773,"t generally; performs better where the are a large number of variables; The SciPy implementation of L-BFGS-B is wrapper around a well; established and actively maintained implementation in Fortran; Its is therefore very fast.; # See SciPy documentation for credit and details on the; # scipy.optimize.fmin_l_bfgs_b function; use subclass: OptimizerLBFGSB. The baseclass Optimizer implements the function wrappers to the; fidelity error, gradient, and iteration callback functions.; These are called from the within the SciPy optimisation functions.; The subclasses implement the algorithm specific pulse optimisation function.; """""". import os; import numpy as np; import timeit; import scipy.optimize as spopt; import copy; import collections; # QuTiP; from qutip import Qobj; import qutip.logging_utils as logging; logger = logging.get_logger(); # QuTiP control modules; import qutip.control.optimresult as optimresult; import qutip.control.termcond as termcond; import qutip.control.errors as errors; import qutip.control.dynamics as dynamics; import qutip.control.pulsegen as pulsegen; import qutip.control.dump as qtrldump. def _is_string(var):; try:; if isinstance(var, basestring):; return True; except NameError:; try:; if isinstance(var, str):; return True; except:; return False; except:; return False. return False. [docs]class Optimizer(object):; """"""; Base class for all control pulse optimisers. This class should not be; instantiated, use its subclasses; This class implements the fidelity, gradient and interation callback; functions.; All subclass objects must be initialised with a; ; OptimConfig instance - various configuration options; Dynamics instance - describes the dynamics of the (quantum) system; to be control optimised. Attributes; ----------; log_level : integer; level of messaging output from the logger.; Options are attributes of qutip.logging_utils,; in decreasing levels of messaging, are:; DEBUG_INTENSE, DEBUG_VERBOSE, DEBUG, INFO, WARN, ERROR, CRITICAL; Anything ",MatchSource.WIKI,docs/4.2/modules/qutip/control/optimizer.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/control/optimizer.html
https://qutip.org/docs/4.2/modules/qutip/control/optimizer.html:6634,Availability,error,error,6634,"rom the logger.; Options are attributes of qutip.logging_utils,; in decreasing levels of messaging, are:; DEBUG_INTENSE, DEBUG_VERBOSE, DEBUG, INFO, WARN, ERROR, CRITICAL; Anything WARN or above is effectively 'quiet' execution,; assuming everything runs as expected.; The default NOTSET implies that the level will be taken from; the QuTiP settings file, which by default is WARN. params: Dictionary; The key value pairs are the attribute name and value; Note: attributes are created if they do not exist already,; and are overwritten if they do. alg : string; Algorithm to use in pulse optimisation.; Options are:; 'GRAPE' (default) - GRadient Ascent Pulse Engineering; 'CRAB' - Chopped RAndom Basis. alg_params : Dictionary; options that are specific to the pulse optim algorithm; that is GRAPE or CRAB. disp_conv_msg : bool; Set true to display a convergence message; (for scipy.optimize.minimize methods anyway). optim_method : string; a scipy.optimize.minimize method that will be used to optimise; the pulse for minimum fidelity error. method_params : Dictionary; Options for the optim_method.; Note that where there is an equivalent attribute of this instance; or the termination_conditions (for example maxiter); it will override an value in these options. approx_grad : bool; If set True then the method will approximate the gradient itself; (if it has requirement and facility for this); This will mean that the fid_err_grad_wrapper will not get called; Note it should be left False when using the Dynamics; to calculate approximate gradients; Note it is set True automatically when the alg is CRAB. amp_lbound : float or list of floats; lower boundaries for the control amplitudes; Can be a scalar value applied to all controls; or a list of bounds for each control. amp_ubound : float or list of floats; upper boundaries for the control amplitudes; Can be a scalar value applied to all controls; or a list of bounds for each control. bounds : List of floats; Bounds for the parameters.; ",MatchSource.WIKI,docs/4.2/modules/qutip/control/optimizer.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/control/optimizer.html
https://qutip.org/docs/4.2/modules/qutip/control/optimizer.html:13203,Availability,error,errors,13203,"elf.dump.level = lvl; @property; def dump_dir(self):; if self.dump:; return self.dump.dump_dir; else:; return None. @dump_dir.setter; def dump_dir(self, value):; if not self.dump:; self.dumping = 'SUMMARY'; self.dump.dump_dir = value. def _create_result(self):; """"""; create the result object; and set the initial_amps attribute as the current amplitudes; """"""; result = optimresult.OptimResult(); result.initial_fid_err = self.dynamics.fid_computer.get_fid_err(); result.initial_amps = self.dynamics.ctrl_amps.copy(); result.time = self.dynamics.time; result.optimizer = self; return result. [docs] def init_optim(self, term_conds):; """"""; Check optimiser attribute status and passed parameters before; running the optimisation.; This is called by run_optimization, but could called independently; to check the configuration.; """"""; if term_conds is not None:; self.termination_conditions = term_conds; term_conds = self.termination_conditions. if not isinstance(term_conds, termcond.TerminationConditions):; raise errors.UsageError(""No termination conditions for the ""; ""optimisation function""). if not isinstance(self.dynamics, dynamics.Dynamics):; raise errors.UsageError(""No dynamics object attribute set""); self.dynamics.check_ctrls_initialized(). self.apply_method_params(). if term_conds.fid_err_targ is None and term_conds.fid_goal is None:; raise errors.UsageError(""Either the goal or the fidelity ""; ""error tolerance must be set""). if term_conds.fid_err_targ is None:; term_conds.fid_err_targ = np.abs(1 - term_conds.fid_goal). if term_conds.fid_goal is None:; term_conds.fid_goal = 1 - term_conds.fid_err_targ. if self.alg == 'CRAB':; self.approx_grad = True. if self.stats is not None:; self.stats.clear(). if self.dump_to_file:; if self.dump is None:; self.dumping = 'SUMMARY'; self.dump.write_to_file = True; self.dump.create_dump_dir(); logger.info(""Optimiser dump will be written to:\n{}"".format(; self.dump.dump_dir)). if self.dump:; self.iter_summary = OptimIterSummary(); else:; self.",MatchSource.WIKI,docs/4.2/modules/qutip/control/optimizer.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/control/optimizer.html
https://qutip.org/docs/4.2/modules/qutip/control/optimizer.html:13345,Availability,error,errors,13345,"elf, value):; if not self.dump:; self.dumping = 'SUMMARY'; self.dump.dump_dir = value. def _create_result(self):; """"""; create the result object; and set the initial_amps attribute as the current amplitudes; """"""; result = optimresult.OptimResult(); result.initial_fid_err = self.dynamics.fid_computer.get_fid_err(); result.initial_amps = self.dynamics.ctrl_amps.copy(); result.time = self.dynamics.time; result.optimizer = self; return result. [docs] def init_optim(self, term_conds):; """"""; Check optimiser attribute status and passed parameters before; running the optimisation.; This is called by run_optimization, but could called independently; to check the configuration.; """"""; if term_conds is not None:; self.termination_conditions = term_conds; term_conds = self.termination_conditions. if not isinstance(term_conds, termcond.TerminationConditions):; raise errors.UsageError(""No termination conditions for the ""; ""optimisation function""). if not isinstance(self.dynamics, dynamics.Dynamics):; raise errors.UsageError(""No dynamics object attribute set""); self.dynamics.check_ctrls_initialized(). self.apply_method_params(). if term_conds.fid_err_targ is None and term_conds.fid_goal is None:; raise errors.UsageError(""Either the goal or the fidelity ""; ""error tolerance must be set""). if term_conds.fid_err_targ is None:; term_conds.fid_err_targ = np.abs(1 - term_conds.fid_goal). if term_conds.fid_goal is None:; term_conds.fid_goal = 1 - term_conds.fid_err_targ. if self.alg == 'CRAB':; self.approx_grad = True. if self.stats is not None:; self.stats.clear(). if self.dump_to_file:; if self.dump is None:; self.dumping = 'SUMMARY'; self.dump.write_to_file = True; self.dump.create_dump_dir(); logger.info(""Optimiser dump will be written to:\n{}"".format(; self.dump.dump_dir)). if self.dump:; self.iter_summary = OptimIterSummary(); else:; self.iter_summary = None. self.num_iter = 0; self.num_fid_func_calls = 0; self.num_grad_func_calls = 0; self.iteration_steps = None. def _build_method_opt",MatchSource.WIKI,docs/4.2/modules/qutip/control/optimizer.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/control/optimizer.html
https://qutip.org/docs/4.2/modules/qutip/control/optimizer.html:13544,Availability,error,errors,13544,"mplitudes; """"""; result = optimresult.OptimResult(); result.initial_fid_err = self.dynamics.fid_computer.get_fid_err(); result.initial_amps = self.dynamics.ctrl_amps.copy(); result.time = self.dynamics.time; result.optimizer = self; return result. [docs] def init_optim(self, term_conds):; """"""; Check optimiser attribute status and passed parameters before; running the optimisation.; This is called by run_optimization, but could called independently; to check the configuration.; """"""; if term_conds is not None:; self.termination_conditions = term_conds; term_conds = self.termination_conditions. if not isinstance(term_conds, termcond.TerminationConditions):; raise errors.UsageError(""No termination conditions for the ""; ""optimisation function""). if not isinstance(self.dynamics, dynamics.Dynamics):; raise errors.UsageError(""No dynamics object attribute set""); self.dynamics.check_ctrls_initialized(). self.apply_method_params(). if term_conds.fid_err_targ is None and term_conds.fid_goal is None:; raise errors.UsageError(""Either the goal or the fidelity ""; ""error tolerance must be set""). if term_conds.fid_err_targ is None:; term_conds.fid_err_targ = np.abs(1 - term_conds.fid_goal). if term_conds.fid_goal is None:; term_conds.fid_goal = 1 - term_conds.fid_err_targ. if self.alg == 'CRAB':; self.approx_grad = True. if self.stats is not None:; self.stats.clear(). if self.dump_to_file:; if self.dump is None:; self.dumping = 'SUMMARY'; self.dump.write_to_file = True; self.dump.create_dump_dir(); logger.info(""Optimiser dump will be written to:\n{}"".format(; self.dump.dump_dir)). if self.dump:; self.iter_summary = OptimIterSummary(); else:; self.iter_summary = None. self.num_iter = 0; self.num_fid_func_calls = 0; self.num_grad_func_calls = 0; self.iteration_steps = None. def _build_method_options(self):; """"""; Creates the method_options dictionary for the scipy.optimize.minimize; function based on the attributes of this object and the; termination_conditions; It assumes that apply_met",MatchSource.WIKI,docs/4.2/modules/qutip/control/optimizer.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/control/optimizer.html
https://qutip.org/docs/4.2/modules/qutip/control/optimizer.html:13599,Availability,error,error,13599,"ult.initial_fid_err = self.dynamics.fid_computer.get_fid_err(); result.initial_amps = self.dynamics.ctrl_amps.copy(); result.time = self.dynamics.time; result.optimizer = self; return result. [docs] def init_optim(self, term_conds):; """"""; Check optimiser attribute status and passed parameters before; running the optimisation.; This is called by run_optimization, but could called independently; to check the configuration.; """"""; if term_conds is not None:; self.termination_conditions = term_conds; term_conds = self.termination_conditions. if not isinstance(term_conds, termcond.TerminationConditions):; raise errors.UsageError(""No termination conditions for the ""; ""optimisation function""). if not isinstance(self.dynamics, dynamics.Dynamics):; raise errors.UsageError(""No dynamics object attribute set""); self.dynamics.check_ctrls_initialized(). self.apply_method_params(). if term_conds.fid_err_targ is None and term_conds.fid_goal is None:; raise errors.UsageError(""Either the goal or the fidelity ""; ""error tolerance must be set""). if term_conds.fid_err_targ is None:; term_conds.fid_err_targ = np.abs(1 - term_conds.fid_goal). if term_conds.fid_goal is None:; term_conds.fid_goal = 1 - term_conds.fid_err_targ. if self.alg == 'CRAB':; self.approx_grad = True. if self.stats is not None:; self.stats.clear(). if self.dump_to_file:; if self.dump is None:; self.dumping = 'SUMMARY'; self.dump.write_to_file = True; self.dump.create_dump_dir(); logger.info(""Optimiser dump will be written to:\n{}"".format(; self.dump.dump_dir)). if self.dump:; self.iter_summary = OptimIterSummary(); else:; self.iter_summary = None. self.num_iter = 0; self.num_fid_func_calls = 0; self.num_grad_func_calls = 0; self.iteration_steps = None. def _build_method_options(self):; """"""; Creates the method_options dictionary for the scipy.optimize.minimize; function based on the attributes of this object and the; termination_conditions; It assumes that apply_method_params has already been run and; hence the method_o",MatchSource.WIKI,docs/4.2/modules/qutip/control/optimizer.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/control/optimizer.html
https://qutip.org/docs/4.2/modules/qutip/control/optimizer.html:13605,Availability,toler,tolerance,13605,"ult.initial_fid_err = self.dynamics.fid_computer.get_fid_err(); result.initial_amps = self.dynamics.ctrl_amps.copy(); result.time = self.dynamics.time; result.optimizer = self; return result. [docs] def init_optim(self, term_conds):; """"""; Check optimiser attribute status and passed parameters before; running the optimisation.; This is called by run_optimization, but could called independently; to check the configuration.; """"""; if term_conds is not None:; self.termination_conditions = term_conds; term_conds = self.termination_conditions. if not isinstance(term_conds, termcond.TerminationConditions):; raise errors.UsageError(""No termination conditions for the ""; ""optimisation function""). if not isinstance(self.dynamics, dynamics.Dynamics):; raise errors.UsageError(""No dynamics object attribute set""); self.dynamics.check_ctrls_initialized(). self.apply_method_params(). if term_conds.fid_err_targ is None and term_conds.fid_goal is None:; raise errors.UsageError(""Either the goal or the fidelity ""; ""error tolerance must be set""). if term_conds.fid_err_targ is None:; term_conds.fid_err_targ = np.abs(1 - term_conds.fid_goal). if term_conds.fid_goal is None:; term_conds.fid_goal = 1 - term_conds.fid_err_targ. if self.alg == 'CRAB':; self.approx_grad = True. if self.stats is not None:; self.stats.clear(). if self.dump_to_file:; if self.dump is None:; self.dumping = 'SUMMARY'; self.dump.write_to_file = True; self.dump.create_dump_dir(); logger.info(""Optimiser dump will be written to:\n{}"".format(; self.dump.dump_dir)). if self.dump:; self.iter_summary = OptimIterSummary(); else:; self.iter_summary = None. self.num_iter = 0; self.num_fid_func_calls = 0; self.num_grad_func_calls = 0; self.iteration_steps = None. def _build_method_options(self):; """"""; Creates the method_options dictionary for the scipy.optimize.minimize; function based on the attributes of this object and the; termination_conditions; It assumes that apply_method_params has already been run and; hence the method_o",MatchSource.WIKI,docs/4.2/modules/qutip/control/optimizer.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/control/optimizer.html
https://qutip.org/docs/4.2/modules/qutip/control/optimizer.html:17044,Availability,error,error,17044,"; if hasattr(self.termination_conditions, key):; setattr(self.termination_conditions, key, val); else:; unused_params[key] = val. if len(unused_params) > 0:; if not isinstance(self.method_options, dict):; self.method_options = unused_params; else:; self.method_options.update(unused_params). def _build_bounds_list(self):; cfg = self.config; dyn = self.dynamics; n_ctrls = dyn.num_ctrls; self.bounds = []; for t in range(dyn.num_tslots):; for c in range(n_ctrls):; if isinstance(self.amp_lbound, list):; lb = self.amp_lbound[c]; else:; lb = self.amp_lbound; if isinstance(self.amp_ubound, list):; ub = self.amp_ubound[c]; else:; ub = self.amp_ubound. if not lb is None and np.isinf(lb):; lb = None; if not ub is None and np.isinf(ub):; ub = None. self.bounds.append((lb, ub)). [docs] def run_optimization(self, term_conds=None):; """"""; This default function optimisation method is a wrapper to the; scipy.optimize.minimize function. It will attempt to minimise the fidelity error with respect to some; parameters, which are determined by _get_optim_var_vals (see below). The optimisation end when one of the passed termination conditions; has been met, e.g. target achieved, wall time, or; function call or iteration count exceeded. Note these; conditions include gradient minimum met (local minima) for; methods that use a gradient. The function minimisation method is taken from the optim_method; attribute. Note that not all of these methods have been tested.; Note that some of these use a gradient and some do not.; See the scipy documentation for details. Options specific to the; method can be passed setting the method_params attribute. If the parameter term_conds=None, then the termination_conditions; attribute must already be set. It will be overwritten if the; parameter is not None. The result is returned in an OptimResult object, which includes; the final fidelity, time evolution, reason for termination etc; ; """"""; self.init_optim(term_conds); term_conds = self.termination_condition",MatchSource.WIKI,docs/4.2/modules/qutip/control/optimizer.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/control/optimizer.html
https://qutip.org/docs/4.2/modules/qutip/control/optimizer.html:19412,Availability,error,errors,19412,"bounds_list(). self._build_method_options(). result = self._create_result(). if self.approx_grad:; jac=None; else:; jac=self.fid_err_grad_wrapper. if self.log_level <= logging.INFO:; msg = (""Optimising pulse(s) using {} with ""; ""minimise '{}' method"").format(self.alg, self.method); if self.approx_grad:; msg += "" (approx grad)""; logger.info(msg). try:; opt_res = spopt.minimize(; self.fid_err_func_wrapper, self.optim_var_vals,; method=self.method,; jac=jac,; bounds=self.bounds,; options=self.method_options,; callback=self.iter_step_callback_func). amps = self._get_ctrl_amps(opt_res.x); dyn.update_ctrl_amps(amps); result.termination_reason = opt_res.message; # Note the iterations are counted in this object as well; # so there are compared here for interest sake only; if self.num_iter != opt_res.nit:; logger.info(""The number of iterations counted {} ""; "" does not match the number reported {} ""; ""by {}"".format(self.num_iter, opt_res.nit,; self.method)); result.num_iter = opt_res.nit. except errors.OptimizationTerminate as except_term:; self._interpret_term_exception(except_term, result). end_time = timeit.default_timer(); self._add_common_result_attribs(result, st_time, end_time). return result. def _get_optim_var_vals(self):; """"""; Generate the 1d array that holds the current variable values; of the function to be optimised; By default (as used in GRAPE) these are the control amplitudes; in each timeslot; """"""; return self.dynamics.ctrl_amps.reshape([-1]). def _get_ctrl_amps(self, optim_var_vals):; """"""; Get the control amplitudes from the current variable values; of the function to be optimised.; that is the 1d array that is passed from the optimisation method; Note for GRAPE these are the function optimiser parameters; (and this is the default); ; Returns; -------; float array[dynamics.num_tslots, dynamics.num_ctrls]; """"""; amps = optim_var_vals.reshape(self.dynamics.ctrl_amps.shape). return amps. [docs] def fid_err_func_wrapper(self, *args):; """"""; Get the fidelity error a",MatchSource.WIKI,docs/4.2/modules/qutip/control/optimizer.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/control/optimizer.html
https://qutip.org/docs/4.2/modules/qutip/control/optimizer.html:20405,Availability,error,error,20405,"cept errors.OptimizationTerminate as except_term:; self._interpret_term_exception(except_term, result). end_time = timeit.default_timer(); self._add_common_result_attribs(result, st_time, end_time). return result. def _get_optim_var_vals(self):; """"""; Generate the 1d array that holds the current variable values; of the function to be optimised; By default (as used in GRAPE) these are the control amplitudes; in each timeslot; """"""; return self.dynamics.ctrl_amps.reshape([-1]). def _get_ctrl_amps(self, optim_var_vals):; """"""; Get the control amplitudes from the current variable values; of the function to be optimised.; that is the 1d array that is passed from the optimisation method; Note for GRAPE these are the function optimiser parameters; (and this is the default); ; Returns; -------; float array[dynamics.num_tslots, dynamics.num_ctrls]; """"""; amps = optim_var_vals.reshape(self.dynamics.ctrl_amps.shape). return amps. [docs] def fid_err_func_wrapper(self, *args):; """"""; Get the fidelity error achieved using the ctrl amplitudes passed; in as the first argument. This is called by generic optimisation algorithm as the; func to the minimised. The argument is the current; variable values, i.e. control amplitudes, passed as; a flat array. Hence these are reshaped as [nTimeslots, n_ctrls]; and then used to update the stored ctrl values (if they have changed). The error is checked against the target, and the optimisation is; terminated if the target has been achieved.; """"""; self.num_fid_func_calls += 1; # *** update stats ***; if self.stats is not None:; self.stats.num_fidelity_func_calls = self.num_fid_func_calls; if self.log_level <= logging.DEBUG:; logger.debug(""fidelity error call {}"".format(; self.stats.num_fidelity_func_calls)). amps = self._get_ctrl_amps(args[0].copy()); self.dynamics.update_ctrl_amps(amps). tc = self.termination_conditions; err = self.dynamics.fid_computer.get_fid_err(). if self.iter_summary:; self.iter_summary.fid_func_call_num = self.num_fid_func_call",MatchSource.WIKI,docs/4.2/modules/qutip/control/optimizer.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/control/optimizer.html
https://qutip.org/docs/4.2/modules/qutip/control/optimizer.html:20782,Availability,error,error,20782,"t; """"""; return self.dynamics.ctrl_amps.reshape([-1]). def _get_ctrl_amps(self, optim_var_vals):; """"""; Get the control amplitudes from the current variable values; of the function to be optimised.; that is the 1d array that is passed from the optimisation method; Note for GRAPE these are the function optimiser parameters; (and this is the default); ; Returns; -------; float array[dynamics.num_tslots, dynamics.num_ctrls]; """"""; amps = optim_var_vals.reshape(self.dynamics.ctrl_amps.shape). return amps. [docs] def fid_err_func_wrapper(self, *args):; """"""; Get the fidelity error achieved using the ctrl amplitudes passed; in as the first argument. This is called by generic optimisation algorithm as the; func to the minimised. The argument is the current; variable values, i.e. control amplitudes, passed as; a flat array. Hence these are reshaped as [nTimeslots, n_ctrls]; and then used to update the stored ctrl values (if they have changed). The error is checked against the target, and the optimisation is; terminated if the target has been achieved.; """"""; self.num_fid_func_calls += 1; # *** update stats ***; if self.stats is not None:; self.stats.num_fidelity_func_calls = self.num_fid_func_calls; if self.log_level <= logging.DEBUG:; logger.debug(""fidelity error call {}"".format(; self.stats.num_fidelity_func_calls)). amps = self._get_ctrl_amps(args[0].copy()); self.dynamics.update_ctrl_amps(amps). tc = self.termination_conditions; err = self.dynamics.fid_computer.get_fid_err(). if self.iter_summary:; self.iter_summary.fid_func_call_num = self.num_fid_func_calls; self.iter_summary.fid_err = err. if self.dump and self.dump.dump_fid_err:; self.dump.update_fid_err_log(err). if err <= tc.fid_err_targ:; raise errors.GoalAchievedTerminate(err). if self.num_fid_func_calls > tc.max_fid_func_calls:; raise errors.MaxFidFuncCallTerminate(). return err. [docs] def fid_err_grad_wrapper(self, *args):; """"""; Get the gradient of the fidelity error with respect to all of the; variables, i.e. the",MatchSource.WIKI,docs/4.2/modules/qutip/control/optimizer.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/control/optimizer.html
https://qutip.org/docs/4.2/modules/qutip/control/optimizer.html:21098,Availability,error,error,21098,"te for GRAPE these are the function optimiser parameters; (and this is the default); ; Returns; -------; float array[dynamics.num_tslots, dynamics.num_ctrls]; """"""; amps = optim_var_vals.reshape(self.dynamics.ctrl_amps.shape). return amps. [docs] def fid_err_func_wrapper(self, *args):; """"""; Get the fidelity error achieved using the ctrl amplitudes passed; in as the first argument. This is called by generic optimisation algorithm as the; func to the minimised. The argument is the current; variable values, i.e. control amplitudes, passed as; a flat array. Hence these are reshaped as [nTimeslots, n_ctrls]; and then used to update the stored ctrl values (if they have changed). The error is checked against the target, and the optimisation is; terminated if the target has been achieved.; """"""; self.num_fid_func_calls += 1; # *** update stats ***; if self.stats is not None:; self.stats.num_fidelity_func_calls = self.num_fid_func_calls; if self.log_level <= logging.DEBUG:; logger.debug(""fidelity error call {}"".format(; self.stats.num_fidelity_func_calls)). amps = self._get_ctrl_amps(args[0].copy()); self.dynamics.update_ctrl_amps(amps). tc = self.termination_conditions; err = self.dynamics.fid_computer.get_fid_err(). if self.iter_summary:; self.iter_summary.fid_func_call_num = self.num_fid_func_calls; self.iter_summary.fid_err = err. if self.dump and self.dump.dump_fid_err:; self.dump.update_fid_err_log(err). if err <= tc.fid_err_targ:; raise errors.GoalAchievedTerminate(err). if self.num_fid_func_calls > tc.max_fid_func_calls:; raise errors.MaxFidFuncCallTerminate(). return err. [docs] def fid_err_grad_wrapper(self, *args):; """"""; Get the gradient of the fidelity error with respect to all of the; variables, i.e. the ctrl amplidutes in each timeslot. This is called by generic optimisation algorithm as the gradients of; func to the minimised wrt the variables. The argument is the current; variable values, i.e. control amplitudes, passed as; a flat array. Hence these are reshaped",MatchSource.WIKI,docs/4.2/modules/qutip/control/optimizer.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/control/optimizer.html
https://qutip.org/docs/4.2/modules/qutip/control/optimizer.html:21554,Availability,error,errors,21554,"e minimised. The argument is the current; variable values, i.e. control amplitudes, passed as; a flat array. Hence these are reshaped as [nTimeslots, n_ctrls]; and then used to update the stored ctrl values (if they have changed). The error is checked against the target, and the optimisation is; terminated if the target has been achieved.; """"""; self.num_fid_func_calls += 1; # *** update stats ***; if self.stats is not None:; self.stats.num_fidelity_func_calls = self.num_fid_func_calls; if self.log_level <= logging.DEBUG:; logger.debug(""fidelity error call {}"".format(; self.stats.num_fidelity_func_calls)). amps = self._get_ctrl_amps(args[0].copy()); self.dynamics.update_ctrl_amps(amps). tc = self.termination_conditions; err = self.dynamics.fid_computer.get_fid_err(). if self.iter_summary:; self.iter_summary.fid_func_call_num = self.num_fid_func_calls; self.iter_summary.fid_err = err. if self.dump and self.dump.dump_fid_err:; self.dump.update_fid_err_log(err). if err <= tc.fid_err_targ:; raise errors.GoalAchievedTerminate(err). if self.num_fid_func_calls > tc.max_fid_func_calls:; raise errors.MaxFidFuncCallTerminate(). return err. [docs] def fid_err_grad_wrapper(self, *args):; """"""; Get the gradient of the fidelity error with respect to all of the; variables, i.e. the ctrl amplidutes in each timeslot. This is called by generic optimisation algorithm as the gradients of; func to the minimised wrt the variables. The argument is the current; variable values, i.e. control amplitudes, passed as; a flat array. Hence these are reshaped as [nTimeslots, n_ctrls]; and then used to update the stored ctrl values (if they have changed). Although the optimisation algorithms have a check within them for; function convergence, i.e. local minima, the sum of the squares; of the normalised gradient is checked explicitly, and the; optimisation is terminated if this is below the min_gradient_norm; condition; """"""; # *** update stats ***; self.num_grad_func_calls += 1; if self.stats is not N",MatchSource.WIKI,docs/4.2/modules/qutip/control/optimizer.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/control/optimizer.html
https://qutip.org/docs/4.2/modules/qutip/control/optimizer.html:21648,Availability,error,errors,21648,"as; a flat array. Hence these are reshaped as [nTimeslots, n_ctrls]; and then used to update the stored ctrl values (if they have changed). The error is checked against the target, and the optimisation is; terminated if the target has been achieved.; """"""; self.num_fid_func_calls += 1; # *** update stats ***; if self.stats is not None:; self.stats.num_fidelity_func_calls = self.num_fid_func_calls; if self.log_level <= logging.DEBUG:; logger.debug(""fidelity error call {}"".format(; self.stats.num_fidelity_func_calls)). amps = self._get_ctrl_amps(args[0].copy()); self.dynamics.update_ctrl_amps(amps). tc = self.termination_conditions; err = self.dynamics.fid_computer.get_fid_err(). if self.iter_summary:; self.iter_summary.fid_func_call_num = self.num_fid_func_calls; self.iter_summary.fid_err = err. if self.dump and self.dump.dump_fid_err:; self.dump.update_fid_err_log(err). if err <= tc.fid_err_targ:; raise errors.GoalAchievedTerminate(err). if self.num_fid_func_calls > tc.max_fid_func_calls:; raise errors.MaxFidFuncCallTerminate(). return err. [docs] def fid_err_grad_wrapper(self, *args):; """"""; Get the gradient of the fidelity error with respect to all of the; variables, i.e. the ctrl amplidutes in each timeslot. This is called by generic optimisation algorithm as the gradients of; func to the minimised wrt the variables. The argument is the current; variable values, i.e. control amplitudes, passed as; a flat array. Hence these are reshaped as [nTimeslots, n_ctrls]; and then used to update the stored ctrl values (if they have changed). Although the optimisation algorithms have a check within them for; function convergence, i.e. local minima, the sum of the squares; of the normalised gradient is checked explicitly, and the; optimisation is terminated if this is below the min_gradient_norm; condition; """"""; # *** update stats ***; self.num_grad_func_calls += 1; if self.stats is not None:; self.stats.num_grad_func_calls = self.num_grad_func_calls; if self.log_level <= loggi",MatchSource.WIKI,docs/4.2/modules/qutip/control/optimizer.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/control/optimizer.html
https://qutip.org/docs/4.2/modules/qutip/control/optimizer.html:21779,Availability,error,error,21779,"hey have changed). The error is checked against the target, and the optimisation is; terminated if the target has been achieved.; """"""; self.num_fid_func_calls += 1; # *** update stats ***; if self.stats is not None:; self.stats.num_fidelity_func_calls = self.num_fid_func_calls; if self.log_level <= logging.DEBUG:; logger.debug(""fidelity error call {}"".format(; self.stats.num_fidelity_func_calls)). amps = self._get_ctrl_amps(args[0].copy()); self.dynamics.update_ctrl_amps(amps). tc = self.termination_conditions; err = self.dynamics.fid_computer.get_fid_err(). if self.iter_summary:; self.iter_summary.fid_func_call_num = self.num_fid_func_calls; self.iter_summary.fid_err = err. if self.dump and self.dump.dump_fid_err:; self.dump.update_fid_err_log(err). if err <= tc.fid_err_targ:; raise errors.GoalAchievedTerminate(err). if self.num_fid_func_calls > tc.max_fid_func_calls:; raise errors.MaxFidFuncCallTerminate(). return err. [docs] def fid_err_grad_wrapper(self, *args):; """"""; Get the gradient of the fidelity error with respect to all of the; variables, i.e. the ctrl amplidutes in each timeslot. This is called by generic optimisation algorithm as the gradients of; func to the minimised wrt the variables. The argument is the current; variable values, i.e. control amplitudes, passed as; a flat array. Hence these are reshaped as [nTimeslots, n_ctrls]; and then used to update the stored ctrl values (if they have changed). Although the optimisation algorithms have a check within them for; function convergence, i.e. local minima, the sum of the squares; of the normalised gradient is checked explicitly, and the; optimisation is terminated if this is below the min_gradient_norm; condition; """"""; # *** update stats ***; self.num_grad_func_calls += 1; if self.stats is not None:; self.stats.num_grad_func_calls = self.num_grad_func_calls; if self.log_level <= logging.DEBUG:; logger.debug(""gradient call {}"".format(; self.stats.num_grad_func_calls)); amps = self._get_ctrl_amps(args[0].c",MatchSource.WIKI,docs/4.2/modules/qutip/control/optimizer.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/control/optimizer.html
https://qutip.org/docs/4.2/modules/qutip/control/optimizer.html:23375,Availability,error,errors,23375," explicitly, and the; optimisation is terminated if this is below the min_gradient_norm; condition; """"""; # *** update stats ***; self.num_grad_func_calls += 1; if self.stats is not None:; self.stats.num_grad_func_calls = self.num_grad_func_calls; if self.log_level <= logging.DEBUG:; logger.debug(""gradient call {}"".format(; self.stats.num_grad_func_calls)); amps = self._get_ctrl_amps(args[0].copy()); self.dynamics.update_ctrl_amps(amps); fid_comp = self.dynamics.fid_computer; # gradient_norm_func is a pointer to the function set in the config; # that returns the normalised gradients; grad = fid_comp.get_fid_err_gradient(). if self.iter_summary:; self.iter_summary.grad_func_call_num = self.num_grad_func_calls; self.iter_summary.grad_norm = fid_comp.grad_norm. if self.dump:; if self.dump.dump_grad_norm:; self.dump.update_grad_norm_log(fid_comp.grad_norm). if self.dump.dump_grad:; self.dump.update_grad_log(grad). tc = self.termination_conditions; if fid_comp.grad_norm < tc.min_gradient_norm:; raise errors.GradMinReachedTerminate(fid_comp.grad_norm); return grad.flatten(). [docs] def iter_step_callback_func(self, *args):; """"""; Check the elapsed wall time for the optimisation run so far.; Terminate if this has exceeded the maximum allowed time; """"""; self.num_iter += 1. if self.log_level <= logging.DEBUG:; logger.debug(""Iteration callback {}"".format(self.num_iter)). wall_time = timeit.default_timer() - self.wall_time_optimize_start. if self.iter_summary:; self.iter_summary.iter_num = self.num_iter; self.iter_summary.wall_time = wall_time. if self.dump and self.dump.dump_summary:; self.dump.add_iter_summary(). tc = self.termination_conditions. if wall_time > tc.max_wall_time:; raise errors.MaxWallTimeTerminate(). # *** update stats ***; if self.stats is not None:; self.stats.num_iter = self.num_iter. def _interpret_term_exception(self, except_term, result):; """"""; Update the result object based on the exception that occurred; during the optimisation; """"""; result.termination_r",MatchSource.WIKI,docs/4.2/modules/qutip/control/optimizer.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/control/optimizer.html
https://qutip.org/docs/4.2/modules/qutip/control/optimizer.html:24069,Availability,error,errors,24069,".num_grad_func_calls; self.iter_summary.grad_norm = fid_comp.grad_norm. if self.dump:; if self.dump.dump_grad_norm:; self.dump.update_grad_norm_log(fid_comp.grad_norm). if self.dump.dump_grad:; self.dump.update_grad_log(grad). tc = self.termination_conditions; if fid_comp.grad_norm < tc.min_gradient_norm:; raise errors.GradMinReachedTerminate(fid_comp.grad_norm); return grad.flatten(). [docs] def iter_step_callback_func(self, *args):; """"""; Check the elapsed wall time for the optimisation run so far.; Terminate if this has exceeded the maximum allowed time; """"""; self.num_iter += 1. if self.log_level <= logging.DEBUG:; logger.debug(""Iteration callback {}"".format(self.num_iter)). wall_time = timeit.default_timer() - self.wall_time_optimize_start. if self.iter_summary:; self.iter_summary.iter_num = self.num_iter; self.iter_summary.wall_time = wall_time. if self.dump and self.dump.dump_summary:; self.dump.add_iter_summary(). tc = self.termination_conditions. if wall_time > tc.max_wall_time:; raise errors.MaxWallTimeTerminate(). # *** update stats ***; if self.stats is not None:; self.stats.num_iter = self.num_iter. def _interpret_term_exception(self, except_term, result):; """"""; Update the result object based on the exception that occurred; during the optimisation; """"""; result.termination_reason = except_term.reason; if isinstance(except_term, errors.GoalAchievedTerminate):; result.goal_achieved = True; elif isinstance(except_term, errors.MaxWallTimeTerminate):; result.wall_time_limit_exceeded = True; elif isinstance(except_term, errors.GradMinReachedTerminate):; result.grad_norm_min_reached = True; elif isinstance(except_term, errors.MaxFidFuncCallTerminate):; result.max_fid_func_exceeded = True. def _add_common_result_attribs(self, result, st_time, end_time):; """"""; Update the result object attributes which are common to all; optimisers and outcomes; """"""; dyn = self.dynamics; result.num_iter = self.num_iter; result.num_fid_func_calls = self.num_fid_func_calls; result.wall",MatchSource.WIKI,docs/4.2/modules/qutip/control/optimizer.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/control/optimizer.html
https://qutip.org/docs/4.2/modules/qutip/control/optimizer.html:24421,Availability,error,errors,24421,"id_comp.grad_norm); return grad.flatten(). [docs] def iter_step_callback_func(self, *args):; """"""; Check the elapsed wall time for the optimisation run so far.; Terminate if this has exceeded the maximum allowed time; """"""; self.num_iter += 1. if self.log_level <= logging.DEBUG:; logger.debug(""Iteration callback {}"".format(self.num_iter)). wall_time = timeit.default_timer() - self.wall_time_optimize_start. if self.iter_summary:; self.iter_summary.iter_num = self.num_iter; self.iter_summary.wall_time = wall_time. if self.dump and self.dump.dump_summary:; self.dump.add_iter_summary(). tc = self.termination_conditions. if wall_time > tc.max_wall_time:; raise errors.MaxWallTimeTerminate(). # *** update stats ***; if self.stats is not None:; self.stats.num_iter = self.num_iter. def _interpret_term_exception(self, except_term, result):; """"""; Update the result object based on the exception that occurred; during the optimisation; """"""; result.termination_reason = except_term.reason; if isinstance(except_term, errors.GoalAchievedTerminate):; result.goal_achieved = True; elif isinstance(except_term, errors.MaxWallTimeTerminate):; result.wall_time_limit_exceeded = True; elif isinstance(except_term, errors.GradMinReachedTerminate):; result.grad_norm_min_reached = True; elif isinstance(except_term, errors.MaxFidFuncCallTerminate):; result.max_fid_func_exceeded = True. def _add_common_result_attribs(self, result, st_time, end_time):; """"""; Update the result object attributes which are common to all; optimisers and outcomes; """"""; dyn = self.dynamics; result.num_iter = self.num_iter; result.num_fid_func_calls = self.num_fid_func_calls; result.wall_time = end_time - st_time; result.fid_err = dyn.fid_computer.get_fid_err(); result.grad_norm_final = dyn.fid_computer.grad_norm; result.final_amps = dyn.ctrl_amps; final_evo = dyn.full_evo; if isinstance(final_evo, Qobj):; result.evo_full_final = final_evo; else:; result.evo_full_final = Qobj(final_evo, dims=dyn.sys_dims); # *** update stats ",MatchSource.WIKI,docs/4.2/modules/qutip/control/optimizer.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/control/optimizer.html
https://qutip.org/docs/4.2/modules/qutip/control/optimizer.html:24511,Availability,error,errors,24511,", *args):; """"""; Check the elapsed wall time for the optimisation run so far.; Terminate if this has exceeded the maximum allowed time; """"""; self.num_iter += 1. if self.log_level <= logging.DEBUG:; logger.debug(""Iteration callback {}"".format(self.num_iter)). wall_time = timeit.default_timer() - self.wall_time_optimize_start. if self.iter_summary:; self.iter_summary.iter_num = self.num_iter; self.iter_summary.wall_time = wall_time. if self.dump and self.dump.dump_summary:; self.dump.add_iter_summary(). tc = self.termination_conditions. if wall_time > tc.max_wall_time:; raise errors.MaxWallTimeTerminate(). # *** update stats ***; if self.stats is not None:; self.stats.num_iter = self.num_iter. def _interpret_term_exception(self, except_term, result):; """"""; Update the result object based on the exception that occurred; during the optimisation; """"""; result.termination_reason = except_term.reason; if isinstance(except_term, errors.GoalAchievedTerminate):; result.goal_achieved = True; elif isinstance(except_term, errors.MaxWallTimeTerminate):; result.wall_time_limit_exceeded = True; elif isinstance(except_term, errors.GradMinReachedTerminate):; result.grad_norm_min_reached = True; elif isinstance(except_term, errors.MaxFidFuncCallTerminate):; result.max_fid_func_exceeded = True. def _add_common_result_attribs(self, result, st_time, end_time):; """"""; Update the result object attributes which are common to all; optimisers and outcomes; """"""; dyn = self.dynamics; result.num_iter = self.num_iter; result.num_fid_func_calls = self.num_fid_func_calls; result.wall_time = end_time - st_time; result.fid_err = dyn.fid_computer.get_fid_err(); result.grad_norm_final = dyn.fid_computer.grad_norm; result.final_amps = dyn.ctrl_amps; final_evo = dyn.full_evo; if isinstance(final_evo, Qobj):; result.evo_full_final = final_evo; else:; result.evo_full_final = Qobj(final_evo, dims=dyn.sys_dims); # *** update stats ***; if self.stats is not None:; self.stats.wall_time_optim_end = end_time; self.s",MatchSource.WIKI,docs/4.2/modules/qutip/control/optimizer.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/control/optimizer.html
https://qutip.org/docs/4.2/modules/qutip/control/optimizer.html:24611,Availability,error,errors,24611,"s has exceeded the maximum allowed time; """"""; self.num_iter += 1. if self.log_level <= logging.DEBUG:; logger.debug(""Iteration callback {}"".format(self.num_iter)). wall_time = timeit.default_timer() - self.wall_time_optimize_start. if self.iter_summary:; self.iter_summary.iter_num = self.num_iter; self.iter_summary.wall_time = wall_time. if self.dump and self.dump.dump_summary:; self.dump.add_iter_summary(). tc = self.termination_conditions. if wall_time > tc.max_wall_time:; raise errors.MaxWallTimeTerminate(). # *** update stats ***; if self.stats is not None:; self.stats.num_iter = self.num_iter. def _interpret_term_exception(self, except_term, result):; """"""; Update the result object based on the exception that occurred; during the optimisation; """"""; result.termination_reason = except_term.reason; if isinstance(except_term, errors.GoalAchievedTerminate):; result.goal_achieved = True; elif isinstance(except_term, errors.MaxWallTimeTerminate):; result.wall_time_limit_exceeded = True; elif isinstance(except_term, errors.GradMinReachedTerminate):; result.grad_norm_min_reached = True; elif isinstance(except_term, errors.MaxFidFuncCallTerminate):; result.max_fid_func_exceeded = True. def _add_common_result_attribs(self, result, st_time, end_time):; """"""; Update the result object attributes which are common to all; optimisers and outcomes; """"""; dyn = self.dynamics; result.num_iter = self.num_iter; result.num_fid_func_calls = self.num_fid_func_calls; result.wall_time = end_time - st_time; result.fid_err = dyn.fid_computer.get_fid_err(); result.grad_norm_final = dyn.fid_computer.grad_norm; result.final_amps = dyn.ctrl_amps; final_evo = dyn.full_evo; if isinstance(final_evo, Qobj):; result.evo_full_final = final_evo; else:; result.evo_full_final = Qobj(final_evo, dims=dyn.sys_dims); # *** update stats ***; if self.stats is not None:; self.stats.wall_time_optim_end = end_time; self.stats.calculate(); result.stats = copy.copy(self.stats). [docs]class OptimizerBFGS(Optimizer):; ",MatchSource.WIKI,docs/4.2/modules/qutip/control/optimizer.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/control/optimizer.html
https://qutip.org/docs/4.2/modules/qutip/control/optimizer.html:24711,Availability,error,errors,24711," logger.debug(""Iteration callback {}"".format(self.num_iter)). wall_time = timeit.default_timer() - self.wall_time_optimize_start. if self.iter_summary:; self.iter_summary.iter_num = self.num_iter; self.iter_summary.wall_time = wall_time. if self.dump and self.dump.dump_summary:; self.dump.add_iter_summary(). tc = self.termination_conditions. if wall_time > tc.max_wall_time:; raise errors.MaxWallTimeTerminate(). # *** update stats ***; if self.stats is not None:; self.stats.num_iter = self.num_iter. def _interpret_term_exception(self, except_term, result):; """"""; Update the result object based on the exception that occurred; during the optimisation; """"""; result.termination_reason = except_term.reason; if isinstance(except_term, errors.GoalAchievedTerminate):; result.goal_achieved = True; elif isinstance(except_term, errors.MaxWallTimeTerminate):; result.wall_time_limit_exceeded = True; elif isinstance(except_term, errors.GradMinReachedTerminate):; result.grad_norm_min_reached = True; elif isinstance(except_term, errors.MaxFidFuncCallTerminate):; result.max_fid_func_exceeded = True. def _add_common_result_attribs(self, result, st_time, end_time):; """"""; Update the result object attributes which are common to all; optimisers and outcomes; """"""; dyn = self.dynamics; result.num_iter = self.num_iter; result.num_fid_func_calls = self.num_fid_func_calls; result.wall_time = end_time - st_time; result.fid_err = dyn.fid_computer.get_fid_err(); result.grad_norm_final = dyn.fid_computer.grad_norm; result.final_amps = dyn.ctrl_amps; final_evo = dyn.full_evo; if isinstance(final_evo, Qobj):; result.evo_full_final = final_evo; else:; result.evo_full_final = Qobj(final_evo, dims=dyn.sys_dims); # *** update stats ***; if self.stats is not None:; self.stats.wall_time_optim_end = end_time; self.stats.calculate(); result.stats = copy.copy(self.stats). [docs]class OptimizerBFGS(Optimizer):; """"""; Implements the run_optimization method using the BFGS algorithm; """"""; def reset(self):; Optimize",MatchSource.WIKI,docs/4.2/modules/qutip/control/optimizer.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/control/optimizer.html
https://qutip.org/docs/4.2/modules/qutip/control/optimizer.html:25844,Availability,error,error,25844," the result object attributes which are common to all; optimisers and outcomes; """"""; dyn = self.dynamics; result.num_iter = self.num_iter; result.num_fid_func_calls = self.num_fid_func_calls; result.wall_time = end_time - st_time; result.fid_err = dyn.fid_computer.get_fid_err(); result.grad_norm_final = dyn.fid_computer.grad_norm; result.final_amps = dyn.ctrl_amps; final_evo = dyn.full_evo; if isinstance(final_evo, Qobj):; result.evo_full_final = final_evo; else:; result.evo_full_final = Qobj(final_evo, dims=dyn.sys_dims); # *** update stats ***; if self.stats is not None:; self.stats.wall_time_optim_end = end_time; self.stats.calculate(); result.stats = copy.copy(self.stats). [docs]class OptimizerBFGS(Optimizer):; """"""; Implements the run_optimization method using the BFGS algorithm; """"""; def reset(self):; Optimizer.reset(self); self.id_text = 'BFGS'. [docs] def run_optimization(self, term_conds=None):; """"""; Optimise the control pulse amplitudes to minimise the fidelity error; using the BFGS (BroydenâFletcherâGoldfarbâShanno) algorithm; The optimisation end when one of the passed termination conditions; has been met, e.g. target achieved, gradient minimum met; (local minima), wall time / iteration count exceeded. Essentially this is wrapper to the:; scipy.optimize.fmin_bfgs; function. If the parameter term_conds=None, then the termination_conditions; attribute must already be set. It will be overwritten if the; parameter is not None. The result is returned in an OptimResult object, which includes; the final fidelity, time evolution, reason for termination etc; """"""; self.init_optim(term_conds); term_conds = self.termination_conditions; dyn = self.dynamics; self.optim_var_vals = self._get_optim_var_vals(); self._build_method_options(). st_time = timeit.default_timer(); self.wall_time_optimize_start = st_time. if self.stats is not None:; self.stats.wall_time_optim_start = st_time; self.stats.wall_time_optim_end = 0.0; self.stats.num_iter = 1. if self.approx_grad:; fpri",MatchSource.WIKI,docs/4.2/modules/qutip/control/optimizer.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/control/optimizer.html
https://qutip.org/docs/4.2/modules/qutip/control/optimizer.html:27764,Availability,error,errors,27764,"_time; self.stats.wall_time_optim_end = 0.0; self.stats.num_iter = 1. if self.approx_grad:; fprime = None; else:; fprime = self.fid_err_grad_wrapper. if self.log_level <= logging.INFO:; msg = (""Optimising pulse(s) using {} with ""; ""'fmin_bfgs' method"").format(self.alg); if self.approx_grad:; msg += "" (approx grad)""; logger.info(msg). result = self._create_result(); try:; optim_var_vals, cost, grad, invHess, nFCalls, nGCalls, warn = \; spopt.fmin_bfgs(self.fid_err_func_wrapper,; self.optim_var_vals,; fprime=fprime,; # approx_grad=self.approx_grad,; callback=self.iter_step_callback_func,; gtol=term_conds.min_gradient_norm,; maxiter=term_conds.max_iterations,; full_output=True, disp=True). amps = self._get_ctrl_amps(optim_var_vals); dyn.update_ctrl_amps(amps); if warn == 1:; result.max_iter_exceeded = True; result.termination_reason = ""Iteration count limit reached""; elif warn == 2:; result.grad_norm_min_reached = True; result.termination_reason = ""Gradient normal minimum reached"". except errors.OptimizationTerminate as except_term:; self._interpret_term_exception(except_term, result). end_time = timeit.default_timer(); self._add_common_result_attribs(result, st_time, end_time). return result. [docs]class OptimizerLBFGSB(Optimizer):; """"""; Implements the run_optimization method using the L-BFGS-B algorithm. Attributes; ----------; max_metric_corr : integer; The maximum number of variable metric corrections used to define; the limited memory matrix. That is the number of previous; gradient values that are used to approximate the Hessian; see the scipy.optimize.fmin_l_bfgs_b documentation for description; of m argument. """""". def reset(self):; Optimizer.reset(self); self.id_text = 'LBFGSB'; self.max_metric_corr = 10; self.msg_level = None. [docs] def init_optim(self, term_conds):; """"""; Check optimiser attribute status and passed parameters before; running the optimisation.; This is called by run_optimization, but could called independently; to check the configuration.; """""";",MatchSource.WIKI,docs/4.2/modules/qutip/control/optimizer.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/control/optimizer.html
https://qutip.org/docs/4.2/modules/qutip/control/optimizer.html:29531,Availability,error,error,29531," term_conds):; """"""; Check optimiser attribute status and passed parameters before; running the optimisation.; This is called by run_optimization, but could called independently; to check the configuration.; """"""; if term_conds is None:; term_conds = self.termination_conditions. # AJGP 2015-04-21:; # These (copying from config) are here for backward compatibility; if hasattr(self.config, 'max_metric_corr'):; if self.config.max_metric_corr:; self.max_metric_corr = self.config.max_metric_corr; if hasattr(self.config, 'accuracy_factor'):; if self.config.accuracy_factor:; term_conds.accuracy_factor = \; self.config.accuracy_factor. Optimizer.init_optim(self, term_conds). if not isinstance(self.msg_level, int):; if self.log_level < logging.DEBUG:; self.msg_level = 2; elif self.log_level <= logging.DEBUG:; self.msg_level = 1; else:; self.msg_level = 0. [docs] def run_optimization(self, term_conds=None):; """"""; Optimise the control pulse amplitudes to minimise the fidelity error; using the L-BFGS-B algorithm, which is the constrained; (bounded amplitude values), limited memory, version of the; BroydenâFletcherâGoldfarbâShanno algorithm. The optimisation end when one of the passed termination conditions; has been met, e.g. target achieved, gradient minimum met; (local minima), wall time / iteration count exceeded. Essentially this is wrapper to the:; scipy.optimize.fmin_l_bfgs_b function; This in turn is a warpper for well established implementation of; the L-BFGS-B algorithm written in Fortran, which is therefore; very fast. See SciPy documentation for credit and details on; this function. If the parameter term_conds=None, then the termination_conditions; attribute must already be set. It will be overwritten if the; parameter is not None. The result is returned in an OptimResult object, which includes; the final fidelity, time evolution, reason for termination etc; ; """"""; self.init_optim(term_conds); term_conds = self.termination_conditions; dyn = self.dynamics; cfg = self.co",MatchSource.WIKI,docs/4.2/modules/qutip/control/optimizer.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/control/optimizer.html
https://qutip.org/docs/4.2/modules/qutip/control/optimizer.html:32516,Availability,error,errors,32516,"; m = 10. if self.log_level <= logging.INFO:; msg = (""Optimising pulse(s) using {} with ""; ""'fmin_l_bfgs_b' method"").format(self.alg); if self.approx_grad:; msg += "" (approx grad)""; logger.info(msg); try:; optim_var_vals, fid, res_dict = spopt.fmin_l_bfgs_b(; self.fid_err_func_wrapper, self.optim_var_vals,; fprime=fprime,; approx_grad=self.approx_grad,; callback=self.iter_step_callback_func,; bounds=self.bounds, m=m, factr=factr,; pgtol=term_conds.min_gradient_norm,; disp=self.msg_level,; maxfun=term_conds.max_fid_func_calls,; maxiter=term_conds.max_iterations). amps = self._get_ctrl_amps(optim_var_vals); dyn.update_ctrl_amps(amps); warn = res_dict['warnflag']; if warn == 0:; result.grad_norm_min_reached = True; result.termination_reason = ""function converged""; elif warn == 1:; result.max_iter_exceeded = True; result.termination_reason = (""Iteration or fidelity ""; ""function call limit reached""); elif warn == 2:; result.termination_reason = res_dict['task']. result.num_iter = res_dict['nit']; except errors.OptimizationTerminate as except_term:; self._interpret_term_exception(except_term, result). end_time = timeit.default_timer(); self._add_common_result_attribs(result, st_time, end_time). return result. [docs]class OptimizerCrab(Optimizer):; """"""; Optimises the pulse using the CRAB algorithm [1].; It uses the scipy.optimize.minimize function with the method specified; by the optim_method attribute. See Optimizer.run_optimization for details; It minimises the fidelity error function with respect to the CRAB; basis function coefficients. AJGP ToDo: Add citation here; """""". def reset(self):; Optimizer.reset(self); self.id_text = 'CRAB'; self.num_optim_vars = 0. [docs] def init_optim(self, term_conds):; """"""; Check optimiser attribute status and passed parameters before; running the optimisation.; This is called by run_optimization, but could called independently; to check the configuration.; """"""; Optimizer.init_optim(self, term_conds); dyn = self.dynamics. self.num_optim_",MatchSource.WIKI,docs/4.2/modules/qutip/control/optimizer.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/control/optimizer.html
https://qutip.org/docs/4.2/modules/qutip/control/optimizer.html:32993,Availability,error,error,32993,"fun=term_conds.max_fid_func_calls,; maxiter=term_conds.max_iterations). amps = self._get_ctrl_amps(optim_var_vals); dyn.update_ctrl_amps(amps); warn = res_dict['warnflag']; if warn == 0:; result.grad_norm_min_reached = True; result.termination_reason = ""function converged""; elif warn == 1:; result.max_iter_exceeded = True; result.termination_reason = (""Iteration or fidelity ""; ""function call limit reached""); elif warn == 2:; result.termination_reason = res_dict['task']. result.num_iter = res_dict['nit']; except errors.OptimizationTerminate as except_term:; self._interpret_term_exception(except_term, result). end_time = timeit.default_timer(); self._add_common_result_attribs(result, st_time, end_time). return result. [docs]class OptimizerCrab(Optimizer):; """"""; Optimises the pulse using the CRAB algorithm [1].; It uses the scipy.optimize.minimize function with the method specified; by the optim_method attribute. See Optimizer.run_optimization for details; It minimises the fidelity error function with respect to the CRAB; basis function coefficients. AJGP ToDo: Add citation here; """""". def reset(self):; Optimizer.reset(self); self.id_text = 'CRAB'; self.num_optim_vars = 0. [docs] def init_optim(self, term_conds):; """"""; Check optimiser attribute status and passed parameters before; running the optimisation.; This is called by run_optimization, but could called independently; to check the configuration.; """"""; Optimizer.init_optim(self, term_conds); dyn = self.dynamics. self.num_optim_vars = 0; pulse_gen_valid = True; # check the pulse generators match the ctrls; # (in terms of number); # and count the number of parameters; if self.pulse_generator is None:; pulse_gen_valid = False; err_msg = ""pulse_generator attribute is None""; elif not isinstance(self.pulse_generator, collections.Iterable):; pulse_gen_valid = False; err_msg = ""pulse_generator is not iterable"". elif len(self.pulse_generator) != dyn.num_ctrls:; pulse_gen_valid = False; err_msg = (""the number of pulse generat",MatchSource.WIKI,docs/4.2/modules/qutip/control/optimizer.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/control/optimizer.html
https://qutip.org/docs/4.2/modules/qutip/control/optimizer.html:34419,Availability,error,errors,34419,"onfiguration.; """"""; Optimizer.init_optim(self, term_conds); dyn = self.dynamics. self.num_optim_vars = 0; pulse_gen_valid = True; # check the pulse generators match the ctrls; # (in terms of number); # and count the number of parameters; if self.pulse_generator is None:; pulse_gen_valid = False; err_msg = ""pulse_generator attribute is None""; elif not isinstance(self.pulse_generator, collections.Iterable):; pulse_gen_valid = False; err_msg = ""pulse_generator is not iterable"". elif len(self.pulse_generator) != dyn.num_ctrls:; pulse_gen_valid = False; err_msg = (""the number of pulse generators {} does not equal ""; ""the number of controls {}"".format(; len(self.pulse_generator), dyn.num_ctrls)). if pulse_gen_valid:; for p_gen in self.pulse_generator:; if not isinstance(p_gen, pulsegen.PulseGenCrab):; pulse_gen_valid = False; err_msg = (; ""pulse_generator contained object of type '{}'"".format(; p_gen.__class__.__name__)); break; self.num_optim_vars += p_gen.num_optim_vars. if not pulse_gen_valid:; raise errors.UsageError(; ""The pulse_generator attribute must be set to a list of ""; ""PulseGenCrab - one for each control. Here "" + err_msg). def _build_bounds_list(self):; """"""; No bounds necessary here, as the bounds for the CRAB parameters; do not have much physical meaning.; This needs to override the default method, otherwise the shape; will be wrong; """"""; return None. def _get_optim_var_vals(self):; """"""; Generate the 1d array that holds the current variable values; of the function to be optimised; For CRAB these are the basis coefficients; ; Returns; -------; ndarray (1d) of float; ; """"""; pvals = []; for pgen in self.pulse_generator:; pvals.extend(pgen.get_optim_var_vals()). return np.array(pvals). def _get_ctrl_amps(self, optim_var_vals):; """"""; Get the control amplitudes from the current variable values; of the function to be optimised.; that is the 1d array that is passed from the optimisation method; For CRAB the amplitudes will need to calculated by expanding the; series",MatchSource.WIKI,docs/4.2/modules/qutip/control/optimizer.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/control/optimizer.html
https://qutip.org/docs/4.2/modules/qutip/control/optimizer.html:36376,Availability,error,error,36376,"the; series. Returns; -------; float array[dynamics.num_tslots, dynamics.num_ctrls]; """"""; dyn = self.dynamics. if self.log_level <= logging.DEBUG:; changed_params = self.optim_var_vals != optim_var_vals; logger.debug(; ""{} out of {} optimisation parameters changed"".format(; changed_params.sum(), len(optim_var_vals))). amps = np.empty([dyn.num_tslots, dyn.num_ctrls]); j = 0; param_idx_st = 0; for p_gen in self.pulse_generator:; param_idx_end = param_idx_st + p_gen.num_optim_vars; pg_pvals = optim_var_vals[param_idx_st:param_idx_end]; p_gen.set_optim_var_vals(pg_pvals); amps[:, j] = p_gen.gen_pulse(); param_idx_st = param_idx_end; j += 1. #print(""param_idx_end={}"".format(param_idx_end)); self.optim_var_vals = optim_var_vals; return amps. [docs]class OptimizerCrabFmin(OptimizerCrab):; """"""; Optimises the pulse using the CRAB algorithm [1, 2].; It uses the scipy.optimize.fmin function which is effectively a wrapper; for the Nelder-mead method.; It minimises the fidelity error function with respect to the CRAB; basis function coefficients.; This is the default Optimizer for CRAB. Notes; -----; [1] P. Doria, T. Calarco & S. Montangero. Phys. Rev. Lett. 106,; 190501 (2011).; [2] T. Caneva, T. Calarco, & S. Montangero. Phys. Rev. A 84, 022326 (2011).; """""". def reset(self):; OptimizerCrab.reset(self); self.id_text = 'CRAB_FMIN'; self.xtol = 1e-4; self.ftol = 1e-4. [docs] def run_optimization(self, term_conds=None):; """"""; This function optimisation method is a wrapper to the; scipy.optimize.fmin function. It will attempt to minimise the fidelity error with respect to some; parameters, which are determined by _get_optim_var_vals which; in the case of CRAB are the basis function coefficients. The optimisation end when one of the passed termination conditions; has been met, e.g. target achieved, wall time, or; function call or iteration count exceeded. Specifically to the fmin; method, the optimisation will stop when change parameter values; is less than xtol or the change in func",MatchSource.WIKI,docs/4.2/modules/qutip/control/optimizer.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/control/optimizer.html
https://qutip.org/docs/4.2/modules/qutip/control/optimizer.html:36957,Availability,error,error,36957,"idx_st = param_idx_end; j += 1. #print(""param_idx_end={}"".format(param_idx_end)); self.optim_var_vals = optim_var_vals; return amps. [docs]class OptimizerCrabFmin(OptimizerCrab):; """"""; Optimises the pulse using the CRAB algorithm [1, 2].; It uses the scipy.optimize.fmin function which is effectively a wrapper; for the Nelder-mead method.; It minimises the fidelity error function with respect to the CRAB; basis function coefficients.; This is the default Optimizer for CRAB. Notes; -----; [1] P. Doria, T. Calarco & S. Montangero. Phys. Rev. Lett. 106,; 190501 (2011).; [2] T. Caneva, T. Calarco, & S. Montangero. Phys. Rev. A 84, 022326 (2011).; """""". def reset(self):; OptimizerCrab.reset(self); self.id_text = 'CRAB_FMIN'; self.xtol = 1e-4; self.ftol = 1e-4. [docs] def run_optimization(self, term_conds=None):; """"""; This function optimisation method is a wrapper to the; scipy.optimize.fmin function. It will attempt to minimise the fidelity error with respect to some; parameters, which are determined by _get_optim_var_vals which; in the case of CRAB are the basis function coefficients. The optimisation end when one of the passed termination conditions; has been met, e.g. target achieved, wall time, or; function call or iteration count exceeded. Specifically to the fmin; method, the optimisation will stop when change parameter values; is less than xtol or the change in function value is below ftol. If the parameter term_conds=None, then the termination_conditions; attribute must already be set. It will be overwritten if the; parameter is not None. The result is returned in an OptimResult object, which includes; the final fidelity, time evolution, reason for termination etc; """"""; self.init_optim(term_conds); term_conds = self.termination_conditions; dyn = self.dynamics; cfg = self.config; self.optim_var_vals = self._get_optim_var_vals(); self._build_method_options(). #print(""Initial values:\n{}"".format(self.optim_var_vals)); st_time = timeit.default_timer(); self.wall_time_op",MatchSource.WIKI,docs/4.2/modules/qutip/control/optimizer.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/control/optimizer.html
https://qutip.org/docs/4.2/modules/qutip/control/optimizer.html:39243,Availability,toler,tolerance,39243,"ogger.info(""Optimising pulse(s) using {} with ""; ""'fmin' (Nelder-Mead) method"".format(self.alg)). try:; ret = spopt.fmin(; self.fid_err_func_wrapper, self.optim_var_vals,; xtol=self.xtol, ftol=self.ftol,; maxiter=term_conds.max_iterations,; maxfun=term_conds.max_fid_func_calls,; full_output=True, disp=self.disp_conv_msg,; retall=self.record_iteration_steps,; callback=self.iter_step_callback_func). final_param_vals = ret[0]; num_iter = ret[2]; warn_flag = ret[4]; if self.record_iteration_steps:; self.iteration_steps = ret[5]; amps = self._get_ctrl_amps(final_param_vals); dyn.update_ctrl_amps(amps). # Note the iterations are counted in this object as well; # so there are compared here for interest sake only; if self.num_iter != num_iter:; logger.info(""The number of iterations counted {} ""; "" does not match the number reported {} ""; ""by {}"".format(self.num_iter, num_iter,; self.method)); result.num_iter = num_iter; if warn_flag == 0:; result.termination_reason = \; ""Function converged (within tolerance)""; elif warn_flag == 1:; result.termination_reason = \; ""Maximum number of function evaluations reached""; result.max_fid_func_exceeded = True; elif warn_flag == 2:; result.termination_reason = \; ""Maximum number of iterations reached""; result.max_iter_exceeded = True; else:; result.termination_reason = \; ""Unknown (warn_flag={})"".format(warn_flag). except errors.OptimizationTerminate as except_term:; self._interpret_term_exception(except_term, result). end_time = timeit.default_timer(); self._add_common_result_attribs(result, st_time, end_time). return result. [docs]class OptimIterSummary(qtrldump.DumpSummaryItem):; """"""A summary of the most recent iteration of the pulse optimisation. Attributes; ----------; iter_num : int; Iteration number of the pulse optimisation. fid_func_call_num : int; Fidelity function call number of the pulse optimisation. grad_func_call_num : int; Gradient function call number of the pulse optimisation. fid_err : float; Fidelity error. grad_norm ",MatchSource.WIKI,docs/4.2/modules/qutip/control/optimizer.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/control/optimizer.html
https://qutip.org/docs/4.2/modules/qutip/control/optimizer.html:39611,Availability,error,errors,39611,"lf.iter_step_callback_func). final_param_vals = ret[0]; num_iter = ret[2]; warn_flag = ret[4]; if self.record_iteration_steps:; self.iteration_steps = ret[5]; amps = self._get_ctrl_amps(final_param_vals); dyn.update_ctrl_amps(amps). # Note the iterations are counted in this object as well; # so there are compared here for interest sake only; if self.num_iter != num_iter:; logger.info(""The number of iterations counted {} ""; "" does not match the number reported {} ""; ""by {}"".format(self.num_iter, num_iter,; self.method)); result.num_iter = num_iter; if warn_flag == 0:; result.termination_reason = \; ""Function converged (within tolerance)""; elif warn_flag == 1:; result.termination_reason = \; ""Maximum number of function evaluations reached""; result.max_fid_func_exceeded = True; elif warn_flag == 2:; result.termination_reason = \; ""Maximum number of iterations reached""; result.max_iter_exceeded = True; else:; result.termination_reason = \; ""Unknown (warn_flag={})"".format(warn_flag). except errors.OptimizationTerminate as except_term:; self._interpret_term_exception(except_term, result). end_time = timeit.default_timer(); self._add_common_result_attribs(result, st_time, end_time). return result. [docs]class OptimIterSummary(qtrldump.DumpSummaryItem):; """"""A summary of the most recent iteration of the pulse optimisation. Attributes; ----------; iter_num : int; Iteration number of the pulse optimisation. fid_func_call_num : int; Fidelity function call number of the pulse optimisation. grad_func_call_num : int; Gradient function call number of the pulse optimisation. fid_err : float; Fidelity error. grad_norm : float; fidelity gradient (wrt the control parameters) vector norm; that is the magnitude of the gradient. wall_time : float; Time spent computing the pulse optimisation so far; (in seconds of elapsed time); """"""; # Note there is some duplication here with Optimizer attributes; # this exists solely to be copied into the summary dump; min_col_width = 11; summary_property_",MatchSource.WIKI,docs/4.2/modules/qutip/control/optimizer.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/control/optimizer.html
https://qutip.org/docs/4.2/modules/qutip/control/optimizer.html:40221,Availability,error,error,40221,"= \; ""Function converged (within tolerance)""; elif warn_flag == 1:; result.termination_reason = \; ""Maximum number of function evaluations reached""; result.max_fid_func_exceeded = True; elif warn_flag == 2:; result.termination_reason = \; ""Maximum number of iterations reached""; result.max_iter_exceeded = True; else:; result.termination_reason = \; ""Unknown (warn_flag={})"".format(warn_flag). except errors.OptimizationTerminate as except_term:; self._interpret_term_exception(except_term, result). end_time = timeit.default_timer(); self._add_common_result_attribs(result, st_time, end_time). return result. [docs]class OptimIterSummary(qtrldump.DumpSummaryItem):; """"""A summary of the most recent iteration of the pulse optimisation. Attributes; ----------; iter_num : int; Iteration number of the pulse optimisation. fid_func_call_num : int; Fidelity function call number of the pulse optimisation. grad_func_call_num : int; Gradient function call number of the pulse optimisation. fid_err : float; Fidelity error. grad_norm : float; fidelity gradient (wrt the control parameters) vector norm; that is the magnitude of the gradient. wall_time : float; Time spent computing the pulse optimisation so far; (in seconds of elapsed time); """"""; # Note there is some duplication here with Optimizer attributes; # this exists solely to be copied into the summary dump; min_col_width = 11; summary_property_names = (; ""idx"", ""iter_num"", ""fid_func_call_num"", ""grad_func_call_num"",; ""fid_err"", ""grad_norm"", ""wall_time""; ). summary_property_fmt_type = (; 'd', 'd', 'd', 'd',; 'g', 'g', 'g'; ). summary_property_fmt_prec = (; 0, 0, 0, 0,; 4, 4, 2; ). def __init__(self):; self.reset(). def reset(self):; qtrldump.DumpSummaryItem.reset(self); self.iter_num = None; self.fid_func_call_num = None; self.grad_func_call_num = None; self.fid_err = None; self.grad_norm = None; self.wall_time = 0.0. Â© Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, and A.L. Grimsmo.; Last updated",MatchSource.WIKI,docs/4.2/modules/qutip/control/optimizer.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/control/optimizer.html
https://qutip.org/docs/4.2/modules/qutip/control/optimizer.html:5410,Deployability,configurat,configuration,5410,"ort numpy as np; import timeit; import scipy.optimize as spopt; import copy; import collections; # QuTiP; from qutip import Qobj; import qutip.logging_utils as logging; logger = logging.get_logger(); # QuTiP control modules; import qutip.control.optimresult as optimresult; import qutip.control.termcond as termcond; import qutip.control.errors as errors; import qutip.control.dynamics as dynamics; import qutip.control.pulsegen as pulsegen; import qutip.control.dump as qtrldump. def _is_string(var):; try:; if isinstance(var, basestring):; return True; except NameError:; try:; if isinstance(var, str):; return True; except:; return False; except:; return False. return False. [docs]class Optimizer(object):; """"""; Base class for all control pulse optimisers. This class should not be; instantiated, use its subclasses; This class implements the fidelity, gradient and interation callback; functions.; All subclass objects must be initialised with a; ; OptimConfig instance - various configuration options; Dynamics instance - describes the dynamics of the (quantum) system; to be control optimised. Attributes; ----------; log_level : integer; level of messaging output from the logger.; Options are attributes of qutip.logging_utils,; in decreasing levels of messaging, are:; DEBUG_INTENSE, DEBUG_VERBOSE, DEBUG, INFO, WARN, ERROR, CRITICAL; Anything WARN or above is effectively 'quiet' execution,; assuming everything runs as expected.; The default NOTSET implies that the level will be taken from; the QuTiP settings file, which by default is WARN. params: Dictionary; The key value pairs are the attribute name and value; Note: attributes are created if they do not exist already,; and are overwritten if they do. alg : string; Algorithm to use in pulse optimisation.; Options are:; 'GRAPE' (default) - GRadient Ascent Pulse Engineering; 'CRAB' - Chopped RAndom Basis. alg_params : Dictionary; options that are specific to the pulse optim algorithm; that is GRAPE or CRAB. disp_conv_msg : bool;",MatchSource.WIKI,docs/4.2/modules/qutip/control/optimizer.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/control/optimizer.html
https://qutip.org/docs/4.2/modules/qutip/control/optimizer.html:8051,Deployability,configurat,configuration,8051,"lled; Note it should be left False when using the Dynamics; to calculate approximate gradients; Note it is set True automatically when the alg is CRAB. amp_lbound : float or list of floats; lower boundaries for the control amplitudes; Can be a scalar value applied to all controls; or a list of bounds for each control. amp_ubound : float or list of floats; upper boundaries for the control amplitudes; Can be a scalar value applied to all controls; or a list of bounds for each control. bounds : List of floats; Bounds for the parameters.; If not set before the run_optimization call then the list; is built automatically based on the amp_lbound and amp_ubound; attributes.; Setting this attribute directly allows specific bounds to be set; for individual parameters.; Note: Only some methods use bounds. dynamics : Dynamics (subclass instance); describes the dynamics of the (quantum) system to be control optimised; (see Dynamics classes for details). config : OptimConfig instance; various configuration options; (see OptimConfig for details). termination_conditions : TerminationCondition instance; attributes determine when the optimisation will end. pulse_generator : PulseGen (subclass instance); (can be) used to create initial pulses; not used by the class, but set by pulseoptim.create_pulse_optimizer. stats : Stats; attributes of which give performance stats for the optimisation; set to None to reduce overhead of calculating stats.; Note it is (usually) shared with the Dynamics instance. dump : :class:`dump.OptimDump`; Container for data dumped during the optimisation.; Can be set by specifying the dumping level or set directly.; Note this is mainly intended for user and a development debugging; but could be used for status information during a long optimisation. dumping : string; level of data dumping: NONE, SUMMARY, FULL or CUSTOM; See property docstring for details. dump_to_file : bool; If set True then data will be dumped to file during the optimisation; dumping will be s",MatchSource.WIKI,docs/4.2/modules/qutip/control/optimizer.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/control/optimizer.html
https://qutip.org/docs/4.2/modules/qutip/control/optimizer.html:13000,Deployability,configurat,configuration,13000,"ue):; raise TypeError(""Value must be string value""); lvl = value.upper(); if lvl == 'NONE':; self.dump = None; else:; if not isinstance(self.dump, qtrldump.OptimDump):; self.dump = qtrldump.OptimDump(self, level=lvl); else:; self.dump.level = lvl; @property; def dump_dir(self):; if self.dump:; return self.dump.dump_dir; else:; return None. @dump_dir.setter; def dump_dir(self, value):; if not self.dump:; self.dumping = 'SUMMARY'; self.dump.dump_dir = value. def _create_result(self):; """"""; create the result object; and set the initial_amps attribute as the current amplitudes; """"""; result = optimresult.OptimResult(); result.initial_fid_err = self.dynamics.fid_computer.get_fid_err(); result.initial_amps = self.dynamics.ctrl_amps.copy(); result.time = self.dynamics.time; result.optimizer = self; return result. [docs] def init_optim(self, term_conds):; """"""; Check optimiser attribute status and passed parameters before; running the optimisation.; This is called by run_optimization, but could called independently; to check the configuration.; """"""; if term_conds is not None:; self.termination_conditions = term_conds; term_conds = self.termination_conditions. if not isinstance(term_conds, termcond.TerminationConditions):; raise errors.UsageError(""No termination conditions for the ""; ""optimisation function""). if not isinstance(self.dynamics, dynamics.Dynamics):; raise errors.UsageError(""No dynamics object attribute set""); self.dynamics.check_ctrls_initialized(). self.apply_method_params(). if term_conds.fid_err_targ is None and term_conds.fid_goal is None:; raise errors.UsageError(""Either the goal or the fidelity ""; ""error tolerance must be set""). if term_conds.fid_err_targ is None:; term_conds.fid_err_targ = np.abs(1 - term_conds.fid_goal). if term_conds.fid_goal is None:; term_conds.fid_goal = 1 - term_conds.fid_err_targ. if self.alg == 'CRAB':; self.approx_grad = True. if self.stats is not None:; self.stats.clear(). if self.dump_to_file:; if self.dump is None:; self.dumping ",MatchSource.WIKI,docs/4.2/modules/qutip/control/optimizer.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/control/optimizer.html
https://qutip.org/docs/4.2/modules/qutip/control/optimizer.html:16340,Deployability,update,update,16340,"_gradient_norm > 0 and not 'gtol' in mo:; mo['gtol'] = tc.min_gradient_norm; if not 'disp' in mo:; mo['disp'] = self.disp_conv_msg. return mo. [docs] def apply_method_params(self, params=None):; """"""; Loops through all the method_params; (either passed here or the method_params attribute); If the name matches an attribute of this object or the; termination conditions object, then the value of this attribute; is set. Otherwise it is assumed to a method_option for the; scipy.optimize.minimize function; """"""; if not params:; params = self.method_params. if isinstance(params, dict):; self.method_params = params; unused_params = {}; for key in params:; val = params[key]; if hasattr(self, key):; setattr(self, key, val); if hasattr(self.termination_conditions, key):; setattr(self.termination_conditions, key, val); else:; unused_params[key] = val. if len(unused_params) > 0:; if not isinstance(self.method_options, dict):; self.method_options = unused_params; else:; self.method_options.update(unused_params). def _build_bounds_list(self):; cfg = self.config; dyn = self.dynamics; n_ctrls = dyn.num_ctrls; self.bounds = []; for t in range(dyn.num_tslots):; for c in range(n_ctrls):; if isinstance(self.amp_lbound, list):; lb = self.amp_lbound[c]; else:; lb = self.amp_lbound; if isinstance(self.amp_ubound, list):; ub = self.amp_ubound[c]; else:; ub = self.amp_ubound. if not lb is None and np.isinf(lb):; lb = None; if not ub is None and np.isinf(ub):; ub = None. self.bounds.append((lb, ub)). [docs] def run_optimization(self, term_conds=None):; """"""; This default function optimisation method is a wrapper to the; scipy.optimize.minimize function. It will attempt to minimise the fidelity error with respect to some; parameters, which are determined by _get_optim_var_vals (see below). The optimisation end when one of the passed termination conditions; has been met, e.g. target achieved, wall time, or; function call or iteration count exceeded. Note these; conditions include gradient minimum ",MatchSource.WIKI,docs/4.2/modules/qutip/control/optimizer.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/control/optimizer.html
https://qutip.org/docs/4.2/modules/qutip/control/optimizer.html:20724,Deployability,update,update,20724,"es; of the function to be optimised; By default (as used in GRAPE) these are the control amplitudes; in each timeslot; """"""; return self.dynamics.ctrl_amps.reshape([-1]). def _get_ctrl_amps(self, optim_var_vals):; """"""; Get the control amplitudes from the current variable values; of the function to be optimised.; that is the 1d array that is passed from the optimisation method; Note for GRAPE these are the function optimiser parameters; (and this is the default); ; Returns; -------; float array[dynamics.num_tslots, dynamics.num_ctrls]; """"""; amps = optim_var_vals.reshape(self.dynamics.ctrl_amps.shape). return amps. [docs] def fid_err_func_wrapper(self, *args):; """"""; Get the fidelity error achieved using the ctrl amplitudes passed; in as the first argument. This is called by generic optimisation algorithm as the; func to the minimised. The argument is the current; variable values, i.e. control amplitudes, passed as; a flat array. Hence these are reshaped as [nTimeslots, n_ctrls]; and then used to update the stored ctrl values (if they have changed). The error is checked against the target, and the optimisation is; terminated if the target has been achieved.; """"""; self.num_fid_func_calls += 1; # *** update stats ***; if self.stats is not None:; self.stats.num_fidelity_func_calls = self.num_fid_func_calls; if self.log_level <= logging.DEBUG:; logger.debug(""fidelity error call {}"".format(; self.stats.num_fidelity_func_calls)). amps = self._get_ctrl_amps(args[0].copy()); self.dynamics.update_ctrl_amps(amps). tc = self.termination_conditions; err = self.dynamics.fid_computer.get_fid_err(). if self.iter_summary:; self.iter_summary.fid_func_call_num = self.num_fid_func_calls; self.iter_summary.fid_err = err. if self.dump and self.dump.dump_fid_err:; self.dump.update_fid_err_log(err). if err <= tc.fid_err_targ:; raise errors.GoalAchievedTerminate(err). if self.num_fid_func_calls > tc.max_fid_func_calls:; raise errors.MaxFidFuncCallTerminate(). return err. [docs] def fid_err_gra",MatchSource.WIKI,docs/4.2/modules/qutip/control/optimizer.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/control/optimizer.html
https://qutip.org/docs/4.2/modules/qutip/control/optimizer.html:20930,Deployability,update,update,20930,"; """"""; Get the control amplitudes from the current variable values; of the function to be optimised.; that is the 1d array that is passed from the optimisation method; Note for GRAPE these are the function optimiser parameters; (and this is the default); ; Returns; -------; float array[dynamics.num_tslots, dynamics.num_ctrls]; """"""; amps = optim_var_vals.reshape(self.dynamics.ctrl_amps.shape). return amps. [docs] def fid_err_func_wrapper(self, *args):; """"""; Get the fidelity error achieved using the ctrl amplitudes passed; in as the first argument. This is called by generic optimisation algorithm as the; func to the minimised. The argument is the current; variable values, i.e. control amplitudes, passed as; a flat array. Hence these are reshaped as [nTimeslots, n_ctrls]; and then used to update the stored ctrl values (if they have changed). The error is checked against the target, and the optimisation is; terminated if the target has been achieved.; """"""; self.num_fid_func_calls += 1; # *** update stats ***; if self.stats is not None:; self.stats.num_fidelity_func_calls = self.num_fid_func_calls; if self.log_level <= logging.DEBUG:; logger.debug(""fidelity error call {}"".format(; self.stats.num_fidelity_func_calls)). amps = self._get_ctrl_amps(args[0].copy()); self.dynamics.update_ctrl_amps(amps). tc = self.termination_conditions; err = self.dynamics.fid_computer.get_fid_err(). if self.iter_summary:; self.iter_summary.fid_func_call_num = self.num_fid_func_calls; self.iter_summary.fid_err = err. if self.dump and self.dump.dump_fid_err:; self.dump.update_fid_err_log(err). if err <= tc.fid_err_targ:; raise errors.GoalAchievedTerminate(err). if self.num_fid_func_calls > tc.max_fid_func_calls:; raise errors.MaxFidFuncCallTerminate(). return err. [docs] def fid_err_grad_wrapper(self, *args):; """"""; Get the gradient of the fidelity error with respect to all of the; variables, i.e. the ctrl amplidutes in each timeslot. This is called by generic optimisation algorithm as the gradi",MatchSource.WIKI,docs/4.2/modules/qutip/control/optimizer.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/control/optimizer.html
https://qutip.org/docs/4.2/modules/qutip/control/optimizer.html:22142,Deployability,update,update,22142,"um_fidelity_func_calls)). amps = self._get_ctrl_amps(args[0].copy()); self.dynamics.update_ctrl_amps(amps). tc = self.termination_conditions; err = self.dynamics.fid_computer.get_fid_err(). if self.iter_summary:; self.iter_summary.fid_func_call_num = self.num_fid_func_calls; self.iter_summary.fid_err = err. if self.dump and self.dump.dump_fid_err:; self.dump.update_fid_err_log(err). if err <= tc.fid_err_targ:; raise errors.GoalAchievedTerminate(err). if self.num_fid_func_calls > tc.max_fid_func_calls:; raise errors.MaxFidFuncCallTerminate(). return err. [docs] def fid_err_grad_wrapper(self, *args):; """"""; Get the gradient of the fidelity error with respect to all of the; variables, i.e. the ctrl amplidutes in each timeslot. This is called by generic optimisation algorithm as the gradients of; func to the minimised wrt the variables. The argument is the current; variable values, i.e. control amplitudes, passed as; a flat array. Hence these are reshaped as [nTimeslots, n_ctrls]; and then used to update the stored ctrl values (if they have changed). Although the optimisation algorithms have a check within them for; function convergence, i.e. local minima, the sum of the squares; of the normalised gradient is checked explicitly, and the; optimisation is terminated if this is below the min_gradient_norm; condition; """"""; # *** update stats ***; self.num_grad_func_calls += 1; if self.stats is not None:; self.stats.num_grad_func_calls = self.num_grad_func_calls; if self.log_level <= logging.DEBUG:; logger.debug(""gradient call {}"".format(; self.stats.num_grad_func_calls)); amps = self._get_ctrl_amps(args[0].copy()); self.dynamics.update_ctrl_amps(amps); fid_comp = self.dynamics.fid_computer; # gradient_norm_func is a pointer to the function set in the config; # that returns the normalised gradients; grad = fid_comp.get_fid_err_gradient(). if self.iter_summary:; self.iter_summary.grad_func_call_num = self.num_grad_func_calls; self.iter_summary.grad_norm = fid_comp.grad_norm. i",MatchSource.WIKI,docs/4.2/modules/qutip/control/optimizer.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/control/optimizer.html
https://qutip.org/docs/4.2/modules/qutip/control/optimizer.html:22476,Deployability,update,update,22476,"fid_func_calls; self.iter_summary.fid_err = err. if self.dump and self.dump.dump_fid_err:; self.dump.update_fid_err_log(err). if err <= tc.fid_err_targ:; raise errors.GoalAchievedTerminate(err). if self.num_fid_func_calls > tc.max_fid_func_calls:; raise errors.MaxFidFuncCallTerminate(). return err. [docs] def fid_err_grad_wrapper(self, *args):; """"""; Get the gradient of the fidelity error with respect to all of the; variables, i.e. the ctrl amplidutes in each timeslot. This is called by generic optimisation algorithm as the gradients of; func to the minimised wrt the variables. The argument is the current; variable values, i.e. control amplitudes, passed as; a flat array. Hence these are reshaped as [nTimeslots, n_ctrls]; and then used to update the stored ctrl values (if they have changed). Although the optimisation algorithms have a check within them for; function convergence, i.e. local minima, the sum of the squares; of the normalised gradient is checked explicitly, and the; optimisation is terminated if this is below the min_gradient_norm; condition; """"""; # *** update stats ***; self.num_grad_func_calls += 1; if self.stats is not None:; self.stats.num_grad_func_calls = self.num_grad_func_calls; if self.log_level <= logging.DEBUG:; logger.debug(""gradient call {}"".format(; self.stats.num_grad_func_calls)); amps = self._get_ctrl_amps(args[0].copy()); self.dynamics.update_ctrl_amps(amps); fid_comp = self.dynamics.fid_computer; # gradient_norm_func is a pointer to the function set in the config; # that returns the normalised gradients; grad = fid_comp.get_fid_err_gradient(). if self.iter_summary:; self.iter_summary.grad_func_call_num = self.num_grad_func_calls; self.iter_summary.grad_norm = fid_comp.grad_norm. if self.dump:; if self.dump.dump_grad_norm:; self.dump.update_grad_norm_log(fid_comp.grad_norm). if self.dump.dump_grad:; self.dump.update_grad_log(grad). tc = self.termination_conditions; if fid_comp.grad_norm < tc.min_gradient_norm:; raise errors.GradMinReach",MatchSource.WIKI,docs/4.2/modules/qutip/control/optimizer.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/control/optimizer.html
https://qutip.org/docs/4.2/modules/qutip/control/optimizer.html:24106,Deployability,update,update,24106,"d_comp.grad_norm. if self.dump:; if self.dump.dump_grad_norm:; self.dump.update_grad_norm_log(fid_comp.grad_norm). if self.dump.dump_grad:; self.dump.update_grad_log(grad). tc = self.termination_conditions; if fid_comp.grad_norm < tc.min_gradient_norm:; raise errors.GradMinReachedTerminate(fid_comp.grad_norm); return grad.flatten(). [docs] def iter_step_callback_func(self, *args):; """"""; Check the elapsed wall time for the optimisation run so far.; Terminate if this has exceeded the maximum allowed time; """"""; self.num_iter += 1. if self.log_level <= logging.DEBUG:; logger.debug(""Iteration callback {}"".format(self.num_iter)). wall_time = timeit.default_timer() - self.wall_time_optimize_start. if self.iter_summary:; self.iter_summary.iter_num = self.num_iter; self.iter_summary.wall_time = wall_time. if self.dump and self.dump.dump_summary:; self.dump.add_iter_summary(). tc = self.termination_conditions. if wall_time > tc.max_wall_time:; raise errors.MaxWallTimeTerminate(). # *** update stats ***; if self.stats is not None:; self.stats.num_iter = self.num_iter. def _interpret_term_exception(self, except_term, result):; """"""; Update the result object based on the exception that occurred; during the optimisation; """"""; result.termination_reason = except_term.reason; if isinstance(except_term, errors.GoalAchievedTerminate):; result.goal_achieved = True; elif isinstance(except_term, errors.MaxWallTimeTerminate):; result.wall_time_limit_exceeded = True; elif isinstance(except_term, errors.GradMinReachedTerminate):; result.grad_norm_min_reached = True; elif isinstance(except_term, errors.MaxFidFuncCallTerminate):; result.max_fid_func_exceeded = True. def _add_common_result_attribs(self, result, st_time, end_time):; """"""; Update the result object attributes which are common to all; optimisers and outcomes; """"""; dyn = self.dynamics; result.num_iter = self.num_iter; result.num_fid_func_calls = self.num_fid_func_calls; result.wall_time = end_time - st_time; result.fid_err = dyn.fid_c",MatchSource.WIKI,docs/4.2/modules/qutip/control/optimizer.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/control/optimizer.html
https://qutip.org/docs/4.2/modules/qutip/control/optimizer.html:25394,Deployability,update,update,25394,"sinstance(except_term, errors.GoalAchievedTerminate):; result.goal_achieved = True; elif isinstance(except_term, errors.MaxWallTimeTerminate):; result.wall_time_limit_exceeded = True; elif isinstance(except_term, errors.GradMinReachedTerminate):; result.grad_norm_min_reached = True; elif isinstance(except_term, errors.MaxFidFuncCallTerminate):; result.max_fid_func_exceeded = True. def _add_common_result_attribs(self, result, st_time, end_time):; """"""; Update the result object attributes which are common to all; optimisers and outcomes; """"""; dyn = self.dynamics; result.num_iter = self.num_iter; result.num_fid_func_calls = self.num_fid_func_calls; result.wall_time = end_time - st_time; result.fid_err = dyn.fid_computer.get_fid_err(); result.grad_norm_final = dyn.fid_computer.grad_norm; result.final_amps = dyn.ctrl_amps; final_evo = dyn.full_evo; if isinstance(final_evo, Qobj):; result.evo_full_final = final_evo; else:; result.evo_full_final = Qobj(final_evo, dims=dyn.sys_dims); # *** update stats ***; if self.stats is not None:; self.stats.wall_time_optim_end = end_time; self.stats.calculate(); result.stats = copy.copy(self.stats). [docs]class OptimizerBFGS(Optimizer):; """"""; Implements the run_optimization method using the BFGS algorithm; """"""; def reset(self):; Optimizer.reset(self); self.id_text = 'BFGS'. [docs] def run_optimization(self, term_conds=None):; """"""; Optimise the control pulse amplitudes to minimise the fidelity error; using the BFGS (BroydenâFletcherâGoldfarbâShanno) algorithm; The optimisation end when one of the passed termination conditions; has been met, e.g. target achieved, gradient minimum met; (local minima), wall time / iteration count exceeded. Essentially this is wrapper to the:; scipy.optimize.fmin_bfgs; function. If the parameter term_conds=None, then the termination_conditions; attribute must already be set. It will be overwritten if the; parameter is not None. The result is returned in an OptimResult object, which includes; the final fidelit",MatchSource.WIKI,docs/4.2/modules/qutip/control/optimizer.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/control/optimizer.html
https://qutip.org/docs/4.2/modules/qutip/control/optimizer.html:28744,Deployability,configurat,configuration,28744,"ion_reason = ""Gradient normal minimum reached"". except errors.OptimizationTerminate as except_term:; self._interpret_term_exception(except_term, result). end_time = timeit.default_timer(); self._add_common_result_attribs(result, st_time, end_time). return result. [docs]class OptimizerLBFGSB(Optimizer):; """"""; Implements the run_optimization method using the L-BFGS-B algorithm. Attributes; ----------; max_metric_corr : integer; The maximum number of variable metric corrections used to define; the limited memory matrix. That is the number of previous; gradient values that are used to approximate the Hessian; see the scipy.optimize.fmin_l_bfgs_b documentation for description; of m argument. """""". def reset(self):; Optimizer.reset(self); self.id_text = 'LBFGSB'; self.max_metric_corr = 10; self.msg_level = None. [docs] def init_optim(self, term_conds):; """"""; Check optimiser attribute status and passed parameters before; running the optimisation.; This is called by run_optimization, but could called independently; to check the configuration.; """"""; if term_conds is None:; term_conds = self.termination_conditions. # AJGP 2015-04-21:; # These (copying from config) are here for backward compatibility; if hasattr(self.config, 'max_metric_corr'):; if self.config.max_metric_corr:; self.max_metric_corr = self.config.max_metric_corr; if hasattr(self.config, 'accuracy_factor'):; if self.config.accuracy_factor:; term_conds.accuracy_factor = \; self.config.accuracy_factor. Optimizer.init_optim(self, term_conds). if not isinstance(self.msg_level, int):; if self.log_level < logging.DEBUG:; self.msg_level = 2; elif self.log_level <= logging.DEBUG:; self.msg_level = 1; else:; self.msg_level = 0. [docs] def run_optimization(self, term_conds=None):; """"""; Optimise the control pulse amplitudes to minimise the fidelity error; using the L-BFGS-B algorithm, which is the constrained; (bounded amplitude values), limited memory, version of the; BroydenâFletcherâGoldfarbâShanno algorithm. The optimisa",MatchSource.WIKI,docs/4.2/modules/qutip/control/optimizer.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/control/optimizer.html
https://qutip.org/docs/4.2/modules/qutip/control/optimizer.html:33405,Deployability,configurat,configuration,33405,"elity ""; ""function call limit reached""); elif warn == 2:; result.termination_reason = res_dict['task']. result.num_iter = res_dict['nit']; except errors.OptimizationTerminate as except_term:; self._interpret_term_exception(except_term, result). end_time = timeit.default_timer(); self._add_common_result_attribs(result, st_time, end_time). return result. [docs]class OptimizerCrab(Optimizer):; """"""; Optimises the pulse using the CRAB algorithm [1].; It uses the scipy.optimize.minimize function with the method specified; by the optim_method attribute. See Optimizer.run_optimization for details; It minimises the fidelity error function with respect to the CRAB; basis function coefficients. AJGP ToDo: Add citation here; """""". def reset(self):; Optimizer.reset(self); self.id_text = 'CRAB'; self.num_optim_vars = 0. [docs] def init_optim(self, term_conds):; """"""; Check optimiser attribute status and passed parameters before; running the optimisation.; This is called by run_optimization, but could called independently; to check the configuration.; """"""; Optimizer.init_optim(self, term_conds); dyn = self.dynamics. self.num_optim_vars = 0; pulse_gen_valid = True; # check the pulse generators match the ctrls; # (in terms of number); # and count the number of parameters; if self.pulse_generator is None:; pulse_gen_valid = False; err_msg = ""pulse_generator attribute is None""; elif not isinstance(self.pulse_generator, collections.Iterable):; pulse_gen_valid = False; err_msg = ""pulse_generator is not iterable"". elif len(self.pulse_generator) != dyn.num_ctrls:; pulse_gen_valid = False; err_msg = (""the number of pulse generators {} does not equal ""; ""the number of controls {}"".format(; len(self.pulse_generator), dyn.num_ctrls)). if pulse_gen_valid:; for p_gen in self.pulse_generator:; if not isinstance(p_gen, pulsegen.PulseGenCrab):; pulse_gen_valid = False; err_msg = (; ""pulse_generator contained object of type '{}'"".format(; p_gen.__class__.__name__)); break; self.num_optim_vars += p_gen",MatchSource.WIKI,docs/4.2/modules/qutip/control/optimizer.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/control/optimizer.html
https://qutip.org/docs/4.2/modules/qutip/control/optimizer.html:41204,Deployability,update,updated,41204,"tion_reason = \; ""Maximum number of function evaluations reached""; result.max_fid_func_exceeded = True; elif warn_flag == 2:; result.termination_reason = \; ""Maximum number of iterations reached""; result.max_iter_exceeded = True; else:; result.termination_reason = \; ""Unknown (warn_flag={})"".format(warn_flag). except errors.OptimizationTerminate as except_term:; self._interpret_term_exception(except_term, result). end_time = timeit.default_timer(); self._add_common_result_attribs(result, st_time, end_time). return result. [docs]class OptimIterSummary(qtrldump.DumpSummaryItem):; """"""A summary of the most recent iteration of the pulse optimisation. Attributes; ----------; iter_num : int; Iteration number of the pulse optimisation. fid_func_call_num : int; Fidelity function call number of the pulse optimisation. grad_func_call_num : int; Gradient function call number of the pulse optimisation. fid_err : float; Fidelity error. grad_norm : float; fidelity gradient (wrt the control parameters) vector norm; that is the magnitude of the gradient. wall_time : float; Time spent computing the pulse optimisation so far; (in seconds of elapsed time); """"""; # Note there is some duplication here with Optimizer attributes; # this exists solely to be copied into the summary dump; min_col_width = 11; summary_property_names = (; ""idx"", ""iter_num"", ""fid_func_call_num"", ""grad_func_call_num"",; ""fid_err"", ""grad_norm"", ""wall_time""; ). summary_property_fmt_type = (; 'd', 'd', 'd', 'd',; 'g', 'g', 'g'; ). summary_property_fmt_prec = (; 0, 0, 0, 0,; 4, 4, 2; ). def __init__(self):; self.reset(). def reset(self):; qtrldump.DumpSummaryItem.reset(self); self.iter_num = None; self.fid_func_call_num = None; self.grad_func_call_num = None; self.fid_err = None; self.grad_norm = None; self.wall_time = 0.0. Â© Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, and A.L. Grimsmo.; Last updated on Jan 17, 2018. . Built with Sphinx using a theme provided by Read the Docs. . ",MatchSource.WIKI,docs/4.2/modules/qutip/control/optimizer.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/control/optimizer.html
https://qutip.org/docs/4.2/modules/qutip/control/optimizer.html:8466,Energy Efficiency,reduce,reduce,8466,"the control amplitudes; Can be a scalar value applied to all controls; or a list of bounds for each control. bounds : List of floats; Bounds for the parameters.; If not set before the run_optimization call then the list; is built automatically based on the amp_lbound and amp_ubound; attributes.; Setting this attribute directly allows specific bounds to be set; for individual parameters.; Note: Only some methods use bounds. dynamics : Dynamics (subclass instance); describes the dynamics of the (quantum) system to be control optimised; (see Dynamics classes for details). config : OptimConfig instance; various configuration options; (see OptimConfig for details). termination_conditions : TerminationCondition instance; attributes determine when the optimisation will end. pulse_generator : PulseGen (subclass instance); (can be) used to create initial pulses; not used by the class, but set by pulseoptim.create_pulse_optimizer. stats : Stats; attributes of which give performance stats for the optimisation; set to None to reduce overhead of calculating stats.; Note it is (usually) shared with the Dynamics instance. dump : :class:`dump.OptimDump`; Container for data dumped during the optimisation.; Can be set by specifying the dumping level or set directly.; Note this is mainly intended for user and a development debugging; but could be used for status information during a long optimisation. dumping : string; level of data dumping: NONE, SUMMARY, FULL or CUSTOM; See property docstring for details. dump_to_file : bool; If set True then data will be dumped to file during the optimisation; dumping will be set to SUMMARY during init_optim; if dump_to_file is True and dumping not set.; Default is False. dump_dir : string; Basically a link to dump.dump_dir. Exists so that it can be set through; optim_params.; If dump is None then will return None or will set dumping to SUMMARY; when setting a path. iter_summary : :class:`OptimIterSummary`; Summary of the most recent iteration.; Not",MatchSource.WIKI,docs/4.2/modules/qutip/control/optimizer.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/control/optimizer.html
https://qutip.org/docs/4.2/modules/qutip/control/optimizer.html:3890,Integrability,wrap,wrapper,3890,"t the fidelity error and gradient wrt to the amplitudes.; The optimisation will stop when one of the termination conditions are met,; for example: the fidelity aim has be reached, a local minima has been found,; the maximum time allowed has been exceeded. These function optimisation methods are so far from SciPy.optimize; The two methods implemented are:; ; BFGS - BroydenâFletcherâGoldfarbâShanno algorithm; ; This a quasi second order Newton method. It uses successive calls to; the gradient function to make an estimation of the curvature (Hessian); and hence direct its search for the function minima; The SciPy implementation is pure Python and hance is execution speed is; not high; use subclass: OptimizerBFGS. L-BFGS-B - Bounded, limited memory BFGS; ; This a version of the BFGS method where the Hessian approximation is; only based on a set of the most recent gradient calls. It generally; performs better where the are a large number of variables; The SciPy implementation of L-BFGS-B is wrapper around a well; established and actively maintained implementation in Fortran; Its is therefore very fast.; # See SciPy documentation for credit and details on the; # scipy.optimize.fmin_l_bfgs_b function; use subclass: OptimizerLBFGSB. The baseclass Optimizer implements the function wrappers to the; fidelity error, gradient, and iteration callback functions.; These are called from the within the SciPy optimisation functions.; The subclasses implement the algorithm specific pulse optimisation function.; """""". import os; import numpy as np; import timeit; import scipy.optimize as spopt; import copy; import collections; # QuTiP; from qutip import Qobj; import qutip.logging_utils as logging; logger = logging.get_logger(); # QuTiP control modules; import qutip.control.optimresult as optimresult; import qutip.control.termcond as termcond; import qutip.control.errors as errors; import qutip.control.dynamics as dynamics; import qutip.control.pulsegen as pulsegen; import qutip.control.du",MatchSource.WIKI,docs/4.2/modules/qutip/control/optimizer.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/control/optimizer.html
https://qutip.org/docs/4.2/modules/qutip/control/optimizer.html:4182,Integrability,wrap,wrappers,4182,"m SciPy.optimize; The two methods implemented are:; ; BFGS - BroydenâFletcherâGoldfarbâShanno algorithm; ; This a quasi second order Newton method. It uses successive calls to; the gradient function to make an estimation of the curvature (Hessian); and hence direct its search for the function minima; The SciPy implementation is pure Python and hance is execution speed is; not high; use subclass: OptimizerBFGS. L-BFGS-B - Bounded, limited memory BFGS; ; This a version of the BFGS method where the Hessian approximation is; only based on a set of the most recent gradient calls. It generally; performs better where the are a large number of variables; The SciPy implementation of L-BFGS-B is wrapper around a well; established and actively maintained implementation in Fortran; Its is therefore very fast.; # See SciPy documentation for credit and details on the; # scipy.optimize.fmin_l_bfgs_b function; use subclass: OptimizerLBFGSB. The baseclass Optimizer implements the function wrappers to the; fidelity error, gradient, and iteration callback functions.; These are called from the within the SciPy optimisation functions.; The subclasses implement the algorithm specific pulse optimisation function.; """""". import os; import numpy as np; import timeit; import scipy.optimize as spopt; import copy; import collections; # QuTiP; from qutip import Qobj; import qutip.logging_utils as logging; logger = logging.get_logger(); # QuTiP control modules; import qutip.control.optimresult as optimresult; import qutip.control.termcond as termcond; import qutip.control.errors as errors; import qutip.control.dynamics as dynamics; import qutip.control.pulsegen as pulsegen; import qutip.control.dump as qtrldump. def _is_string(var):; try:; if isinstance(var, basestring):; return True; except NameError:; try:; if isinstance(var, str):; return True; except:; return False; except:; return False. return False. [docs]class Optimizer(object):; """"""; Base class for all control pulse optimisers. This class",MatchSource.WIKI,docs/4.2/modules/qutip/control/optimizer.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/control/optimizer.html
https://qutip.org/docs/4.2/modules/qutip/control/optimizer.html:6461,Integrability,message,message,6461,"instance - describes the dynamics of the (quantum) system; to be control optimised. Attributes; ----------; log_level : integer; level of messaging output from the logger.; Options are attributes of qutip.logging_utils,; in decreasing levels of messaging, are:; DEBUG_INTENSE, DEBUG_VERBOSE, DEBUG, INFO, WARN, ERROR, CRITICAL; Anything WARN or above is effectively 'quiet' execution,; assuming everything runs as expected.; The default NOTSET implies that the level will be taken from; the QuTiP settings file, which by default is WARN. params: Dictionary; The key value pairs are the attribute name and value; Note: attributes are created if they do not exist already,; and are overwritten if they do. alg : string; Algorithm to use in pulse optimisation.; Options are:; 'GRAPE' (default) - GRadient Ascent Pulse Engineering; 'CRAB' - Chopped RAndom Basis. alg_params : Dictionary; options that are specific to the pulse optim algorithm; that is GRAPE or CRAB. disp_conv_msg : bool; Set true to display a convergence message; (for scipy.optimize.minimize methods anyway). optim_method : string; a scipy.optimize.minimize method that will be used to optimise; the pulse for minimum fidelity error. method_params : Dictionary; Options for the optim_method.; Note that where there is an equivalent attribute of this instance; or the termination_conditions (for example maxiter); it will override an value in these options. approx_grad : bool; If set True then the method will approximate the gradient itself; (if it has requirement and facility for this); This will mean that the fid_err_grad_wrapper will not get called; Note it should be left False when using the Dynamics; to calculate approximate gradients; Note it is set True automatically when the alg is CRAB. amp_lbound : float or list of floats; lower boundaries for the control amplitudes; Can be a scalar value applied to all controls; or a list of bounds for each control. amp_ubound : float or list of floats; upper boundaries for the con",MatchSource.WIKI,docs/4.2/modules/qutip/control/optimizer.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/control/optimizer.html
https://qutip.org/docs/4.2/modules/qutip/control/optimizer.html:16953,Integrability,wrap,wrapper,16953,"instance(params, dict):; self.method_params = params; unused_params = {}; for key in params:; val = params[key]; if hasattr(self, key):; setattr(self, key, val); if hasattr(self.termination_conditions, key):; setattr(self.termination_conditions, key, val); else:; unused_params[key] = val. if len(unused_params) > 0:; if not isinstance(self.method_options, dict):; self.method_options = unused_params; else:; self.method_options.update(unused_params). def _build_bounds_list(self):; cfg = self.config; dyn = self.dynamics; n_ctrls = dyn.num_ctrls; self.bounds = []; for t in range(dyn.num_tslots):; for c in range(n_ctrls):; if isinstance(self.amp_lbound, list):; lb = self.amp_lbound[c]; else:; lb = self.amp_lbound; if isinstance(self.amp_ubound, list):; ub = self.amp_ubound[c]; else:; ub = self.amp_ubound. if not lb is None and np.isinf(lb):; lb = None; if not ub is None and np.isinf(ub):; ub = None. self.bounds.append((lb, ub)). [docs] def run_optimization(self, term_conds=None):; """"""; This default function optimisation method is a wrapper to the; scipy.optimize.minimize function. It will attempt to minimise the fidelity error with respect to some; parameters, which are determined by _get_optim_var_vals (see below). The optimisation end when one of the passed termination conditions; has been met, e.g. target achieved, wall time, or; function call or iteration count exceeded. Note these; conditions include gradient minimum met (local minima) for; methods that use a gradient. The function minimisation method is taken from the optim_method; attribute. Note that not all of these methods have been tested.; Note that some of these use a gradient and some do not.; See the scipy documentation for details. Options specific to the; method can be passed setting the method_params attribute. If the parameter term_conds=None, then the termination_conditions; attribute must already be set. It will be overwritten if the; parameter is not None. The result is returned in an OptimResult obj",MatchSource.WIKI,docs/4.2/modules/qutip/control/optimizer.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/control/optimizer.html
https://qutip.org/docs/4.2/modules/qutip/control/optimizer.html:19066,Integrability,message,message,19066,"als = self._get_optim_var_vals(); st_time = timeit.default_timer(); self.wall_time_optimize_start = st_time. if self.stats is not None:; self.stats.wall_time_optim_start = st_time; self.stats.wall_time_optim_end = 0.0; self.stats.num_iter = 0. if self.bounds is None:; self._build_bounds_list(). self._build_method_options(). result = self._create_result(). if self.approx_grad:; jac=None; else:; jac=self.fid_err_grad_wrapper. if self.log_level <= logging.INFO:; msg = (""Optimising pulse(s) using {} with ""; ""minimise '{}' method"").format(self.alg, self.method); if self.approx_grad:; msg += "" (approx grad)""; logger.info(msg). try:; opt_res = spopt.minimize(; self.fid_err_func_wrapper, self.optim_var_vals,; method=self.method,; jac=jac,; bounds=self.bounds,; options=self.method_options,; callback=self.iter_step_callback_func). amps = self._get_ctrl_amps(opt_res.x); dyn.update_ctrl_amps(amps); result.termination_reason = opt_res.message; # Note the iterations are counted in this object as well; # so there are compared here for interest sake only; if self.num_iter != opt_res.nit:; logger.info(""The number of iterations counted {} ""; "" does not match the number reported {} ""; ""by {}"".format(self.num_iter, opt_res.nit,; self.method)); result.num_iter = opt_res.nit. except errors.OptimizationTerminate as except_term:; self._interpret_term_exception(except_term, result). end_time = timeit.default_timer(); self._add_common_result_attribs(result, st_time, end_time). return result. def _get_optim_var_vals(self):; """"""; Generate the 1d array that holds the current variable values; of the function to be optimised; By default (as used in GRAPE) these are the control amplitudes; in each timeslot; """"""; return self.dynamics.ctrl_amps.reshape([-1]). def _get_ctrl_amps(self, optim_var_vals):; """"""; Get the control amplitudes from the current variable values; of the function to be optimised.; that is the 1d array that is passed from the optimisation method; Note for GRAPE these are the functi",MatchSource.WIKI,docs/4.2/modules/qutip/control/optimizer.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/control/optimizer.html
https://qutip.org/docs/4.2/modules/qutip/control/optimizer.html:26112,Integrability,wrap,wrapper,26112,"d_computer.get_fid_err(); result.grad_norm_final = dyn.fid_computer.grad_norm; result.final_amps = dyn.ctrl_amps; final_evo = dyn.full_evo; if isinstance(final_evo, Qobj):; result.evo_full_final = final_evo; else:; result.evo_full_final = Qobj(final_evo, dims=dyn.sys_dims); # *** update stats ***; if self.stats is not None:; self.stats.wall_time_optim_end = end_time; self.stats.calculate(); result.stats = copy.copy(self.stats). [docs]class OptimizerBFGS(Optimizer):; """"""; Implements the run_optimization method using the BFGS algorithm; """"""; def reset(self):; Optimizer.reset(self); self.id_text = 'BFGS'. [docs] def run_optimization(self, term_conds=None):; """"""; Optimise the control pulse amplitudes to minimise the fidelity error; using the BFGS (BroydenâFletcherâGoldfarbâShanno) algorithm; The optimisation end when one of the passed termination conditions; has been met, e.g. target achieved, gradient minimum met; (local minima), wall time / iteration count exceeded. Essentially this is wrapper to the:; scipy.optimize.fmin_bfgs; function. If the parameter term_conds=None, then the termination_conditions; attribute must already be set. It will be overwritten if the; parameter is not None. The result is returned in an OptimResult object, which includes; the final fidelity, time evolution, reason for termination etc; """"""; self.init_optim(term_conds); term_conds = self.termination_conditions; dyn = self.dynamics; self.optim_var_vals = self._get_optim_var_vals(); self._build_method_options(). st_time = timeit.default_timer(); self.wall_time_optimize_start = st_time. if self.stats is not None:; self.stats.wall_time_optim_start = st_time; self.stats.wall_time_optim_end = 0.0; self.stats.num_iter = 1. if self.approx_grad:; fprime = None; else:; fprime = self.fid_err_grad_wrapper. if self.log_level <= logging.INFO:; msg = (""Optimising pulse(s) using {} with ""; ""'fmin_bfgs' method"").format(self.alg); if self.approx_grad:; msg += "" (approx grad)""; logger.info(msg). result = self.",MatchSource.WIKI,docs/4.2/modules/qutip/control/optimizer.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/control/optimizer.html
https://qutip.org/docs/4.2/modules/qutip/control/optimizer.html:29898,Integrability,wrap,wrapper,29898,"ard compatibility; if hasattr(self.config, 'max_metric_corr'):; if self.config.max_metric_corr:; self.max_metric_corr = self.config.max_metric_corr; if hasattr(self.config, 'accuracy_factor'):; if self.config.accuracy_factor:; term_conds.accuracy_factor = \; self.config.accuracy_factor. Optimizer.init_optim(self, term_conds). if not isinstance(self.msg_level, int):; if self.log_level < logging.DEBUG:; self.msg_level = 2; elif self.log_level <= logging.DEBUG:; self.msg_level = 1; else:; self.msg_level = 0. [docs] def run_optimization(self, term_conds=None):; """"""; Optimise the control pulse amplitudes to minimise the fidelity error; using the L-BFGS-B algorithm, which is the constrained; (bounded amplitude values), limited memory, version of the; BroydenâFletcherâGoldfarbâShanno algorithm. The optimisation end when one of the passed termination conditions; has been met, e.g. target achieved, gradient minimum met; (local minima), wall time / iteration count exceeded. Essentially this is wrapper to the:; scipy.optimize.fmin_l_bfgs_b function; This in turn is a warpper for well established implementation of; the L-BFGS-B algorithm written in Fortran, which is therefore; very fast. See SciPy documentation for credit and details on; this function. If the parameter term_conds=None, then the termination_conditions; attribute must already be set. It will be overwritten if the; parameter is not None. The result is returned in an OptimResult object, which includes; the final fidelity, time evolution, reason for termination etc; ; """"""; self.init_optim(term_conds); term_conds = self.termination_conditions; dyn = self.dynamics; cfg = self.config; self.optim_var_vals = self._get_optim_var_vals(); self._build_method_options(). st_time = timeit.default_timer(); self.wall_time_optimize_start = st_time. if self.stats is not None:; self.stats.wall_time_optim_start = st_time; self.stats.wall_time_optim_end = 0.0; self.stats.num_iter = 1. bounds = self._build_bounds_list(); result = self.",MatchSource.WIKI,docs/4.2/modules/qutip/control/optimizer.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/control/optimizer.html
https://qutip.org/docs/4.2/modules/qutip/control/optimizer.html:36312,Integrability,wrap,wrapper,36312,"he optimisation method; For CRAB the amplitudes will need to calculated by expanding the; series. Returns; -------; float array[dynamics.num_tslots, dynamics.num_ctrls]; """"""; dyn = self.dynamics. if self.log_level <= logging.DEBUG:; changed_params = self.optim_var_vals != optim_var_vals; logger.debug(; ""{} out of {} optimisation parameters changed"".format(; changed_params.sum(), len(optim_var_vals))). amps = np.empty([dyn.num_tslots, dyn.num_ctrls]); j = 0; param_idx_st = 0; for p_gen in self.pulse_generator:; param_idx_end = param_idx_st + p_gen.num_optim_vars; pg_pvals = optim_var_vals[param_idx_st:param_idx_end]; p_gen.set_optim_var_vals(pg_pvals); amps[:, j] = p_gen.gen_pulse(); param_idx_st = param_idx_end; j += 1. #print(""param_idx_end={}"".format(param_idx_end)); self.optim_var_vals = optim_var_vals; return amps. [docs]class OptimizerCrabFmin(OptimizerCrab):; """"""; Optimises the pulse using the CRAB algorithm [1, 2].; It uses the scipy.optimize.fmin function which is effectively a wrapper; for the Nelder-mead method.; It minimises the fidelity error function with respect to the CRAB; basis function coefficients.; This is the default Optimizer for CRAB. Notes; -----; [1] P. Doria, T. Calarco & S. Montangero. Phys. Rev. Lett. 106,; 190501 (2011).; [2] T. Caneva, T. Calarco, & S. Montangero. Phys. Rev. A 84, 022326 (2011).; """""". def reset(self):; OptimizerCrab.reset(self); self.id_text = 'CRAB_FMIN'; self.xtol = 1e-4; self.ftol = 1e-4. [docs] def run_optimization(self, term_conds=None):; """"""; This function optimisation method is a wrapper to the; scipy.optimize.fmin function. It will attempt to minimise the fidelity error with respect to some; parameters, which are determined by _get_optim_var_vals which; in the case of CRAB are the basis function coefficients. The optimisation end when one of the passed termination conditions; has been met, e.g. target achieved, wall time, or; function call or iteration count exceeded. Specifically to the fmin; method, the optimis",MatchSource.WIKI,docs/4.2/modules/qutip/control/optimizer.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/control/optimizer.html
https://qutip.org/docs/4.2/modules/qutip/control/optimizer.html:36870,Integrability,wrap,wrapper,36870,"_idx_end = param_idx_st + p_gen.num_optim_vars; pg_pvals = optim_var_vals[param_idx_st:param_idx_end]; p_gen.set_optim_var_vals(pg_pvals); amps[:, j] = p_gen.gen_pulse(); param_idx_st = param_idx_end; j += 1. #print(""param_idx_end={}"".format(param_idx_end)); self.optim_var_vals = optim_var_vals; return amps. [docs]class OptimizerCrabFmin(OptimizerCrab):; """"""; Optimises the pulse using the CRAB algorithm [1, 2].; It uses the scipy.optimize.fmin function which is effectively a wrapper; for the Nelder-mead method.; It minimises the fidelity error function with respect to the CRAB; basis function coefficients.; This is the default Optimizer for CRAB. Notes; -----; [1] P. Doria, T. Calarco & S. Montangero. Phys. Rev. Lett. 106,; 190501 (2011).; [2] T. Caneva, T. Calarco, & S. Montangero. Phys. Rev. A 84, 022326 (2011).; """""". def reset(self):; OptimizerCrab.reset(self); self.id_text = 'CRAB_FMIN'; self.xtol = 1e-4; self.ftol = 1e-4. [docs] def run_optimization(self, term_conds=None):; """"""; This function optimisation method is a wrapper to the; scipy.optimize.fmin function. It will attempt to minimise the fidelity error with respect to some; parameters, which are determined by _get_optim_var_vals which; in the case of CRAB are the basis function coefficients. The optimisation end when one of the passed termination conditions; has been met, e.g. target achieved, wall time, or; function call or iteration count exceeded. Specifically to the fmin; method, the optimisation will stop when change parameter values; is less than xtol or the change in function value is below ftol. If the parameter term_conds=None, then the termination_conditions; attribute must already be set. It will be overwritten if the; parameter is not None. The result is returned in an OptimResult object, which includes; the final fidelity, time evolution, reason for termination etc; """"""; self.init_optim(term_conds); term_conds = self.termination_conditions; dyn = self.dynamics; cfg = self.config; self.optim_v",MatchSource.WIKI,docs/4.2/modules/qutip/control/optimizer.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/control/optimizer.html
https://qutip.org/docs/4.2/modules/qutip/control/optimizer.html:2678,Modifiability,variab,variables,2678," LOSS OF USE,; # DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY; # THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT; # (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE; # OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.; ###############################################################################. # @author: Alexander Pitchford; # @email1: agp1@aber.ac.uk; # @email2: alex.pitchford@gmail.com; # @organization: Aberystwyth University; # @supervisor: Daniel Burgarth. """"""; Classes here are expected to implement a run_optimization function; that will use some method for optimising the control pulse, as defined; by the control amplitudes. The system that the pulse acts upon are defined; by the Dynamics object that must be passed in the instantiation. The methods are typically N dimensional function optimisers that; find the minima of a fidelity error function. Note the number of variables; for the fidelity function is the number of control timeslots,; i.e. n_ctrls x Ntimeslots; The methods will call functions on the Dynamics.fid_computer object,; one or many times per interation,; to get the fidelity error and gradient wrt to the amplitudes.; The optimisation will stop when one of the termination conditions are met,; for example: the fidelity aim has be reached, a local minima has been found,; the maximum time allowed has been exceeded. These function optimisation methods are so far from SciPy.optimize; The two methods implemented are:; ; BFGS - BroydenâFletcherâGoldfarbâShanno algorithm; ; This a quasi second order Newton method. It uses successive calls to; the gradient function to make an estimation of the curvature (Hessian); and hence direct its search for the function minima; The SciPy implementation is pure Python and hance is execution speed is; not high; use subclass: OptimizerBFGS. L-BFGS-B - Bounded, limited memory BFGS; ; This a version of the BFGS method where the Hessian ap",MatchSource.WIKI,docs/4.2/modules/qutip/control/optimizer.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/control/optimizer.html
https://qutip.org/docs/4.2/modules/qutip/control/optimizer.html:3839,Modifiability,variab,variables,3839,"t the fidelity error and gradient wrt to the amplitudes.; The optimisation will stop when one of the termination conditions are met,; for example: the fidelity aim has be reached, a local minima has been found,; the maximum time allowed has been exceeded. These function optimisation methods are so far from SciPy.optimize; The two methods implemented are:; ; BFGS - BroydenâFletcherâGoldfarbâShanno algorithm; ; This a quasi second order Newton method. It uses successive calls to; the gradient function to make an estimation of the curvature (Hessian); and hence direct its search for the function minima; The SciPy implementation is pure Python and hance is execution speed is; not high; use subclass: OptimizerBFGS. L-BFGS-B - Bounded, limited memory BFGS; ; This a version of the BFGS method where the Hessian approximation is; only based on a set of the most recent gradient calls. It generally; performs better where the are a large number of variables; The SciPy implementation of L-BFGS-B is wrapper around a well; established and actively maintained implementation in Fortran; Its is therefore very fast.; # See SciPy documentation for credit and details on the; # scipy.optimize.fmin_l_bfgs_b function; use subclass: OptimizerLBFGSB. The baseclass Optimizer implements the function wrappers to the; fidelity error, gradient, and iteration callback functions.; These are called from the within the SciPy optimisation functions.; The subclasses implement the algorithm specific pulse optimisation function.; """""". import os; import numpy as np; import timeit; import scipy.optimize as spopt; import copy; import collections; # QuTiP; from qutip import Qobj; import qutip.logging_utils as logging; logger = logging.get_logger(); # QuTiP control modules; import qutip.control.optimresult as optimresult; import qutip.control.termcond as termcond; import qutip.control.errors as errors; import qutip.control.dynamics as dynamics; import qutip.control.pulsegen as pulsegen; import qutip.control.du",MatchSource.WIKI,docs/4.2/modules/qutip/control/optimizer.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/control/optimizer.html
https://qutip.org/docs/4.2/modules/qutip/control/optimizer.html:5410,Modifiability,config,configuration,5410,"ort numpy as np; import timeit; import scipy.optimize as spopt; import copy; import collections; # QuTiP; from qutip import Qobj; import qutip.logging_utils as logging; logger = logging.get_logger(); # QuTiP control modules; import qutip.control.optimresult as optimresult; import qutip.control.termcond as termcond; import qutip.control.errors as errors; import qutip.control.dynamics as dynamics; import qutip.control.pulsegen as pulsegen; import qutip.control.dump as qtrldump. def _is_string(var):; try:; if isinstance(var, basestring):; return True; except NameError:; try:; if isinstance(var, str):; return True; except:; return False; except:; return False. return False. [docs]class Optimizer(object):; """"""; Base class for all control pulse optimisers. This class should not be; instantiated, use its subclasses; This class implements the fidelity, gradient and interation callback; functions.; All subclass objects must be initialised with a; ; OptimConfig instance - various configuration options; Dynamics instance - describes the dynamics of the (quantum) system; to be control optimised. Attributes; ----------; log_level : integer; level of messaging output from the logger.; Options are attributes of qutip.logging_utils,; in decreasing levels of messaging, are:; DEBUG_INTENSE, DEBUG_VERBOSE, DEBUG, INFO, WARN, ERROR, CRITICAL; Anything WARN or above is effectively 'quiet' execution,; assuming everything runs as expected.; The default NOTSET implies that the level will be taken from; the QuTiP settings file, which by default is WARN. params: Dictionary; The key value pairs are the attribute name and value; Note: attributes are created if they do not exist already,; and are overwritten if they do. alg : string; Algorithm to use in pulse optimisation.; Options are:; 'GRAPE' (default) - GRadient Ascent Pulse Engineering; 'CRAB' - Chopped RAndom Basis. alg_params : Dictionary; options that are specific to the pulse optim algorithm; that is GRAPE or CRAB. disp_conv_msg : bool;",MatchSource.WIKI,docs/4.2/modules/qutip/control/optimizer.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/control/optimizer.html
https://qutip.org/docs/4.2/modules/qutip/control/optimizer.html:8012,Modifiability,config,config,8012,"lled; Note it should be left False when using the Dynamics; to calculate approximate gradients; Note it is set True automatically when the alg is CRAB. amp_lbound : float or list of floats; lower boundaries for the control amplitudes; Can be a scalar value applied to all controls; or a list of bounds for each control. amp_ubound : float or list of floats; upper boundaries for the control amplitudes; Can be a scalar value applied to all controls; or a list of bounds for each control. bounds : List of floats; Bounds for the parameters.; If not set before the run_optimization call then the list; is built automatically based on the amp_lbound and amp_ubound; attributes.; Setting this attribute directly allows specific bounds to be set; for individual parameters.; Note: Only some methods use bounds. dynamics : Dynamics (subclass instance); describes the dynamics of the (quantum) system to be control optimised; (see Dynamics classes for details). config : OptimConfig instance; various configuration options; (see OptimConfig for details). termination_conditions : TerminationCondition instance; attributes determine when the optimisation will end. pulse_generator : PulseGen (subclass instance); (can be) used to create initial pulses; not used by the class, but set by pulseoptim.create_pulse_optimizer. stats : Stats; attributes of which give performance stats for the optimisation; set to None to reduce overhead of calculating stats.; Note it is (usually) shared with the Dynamics instance. dump : :class:`dump.OptimDump`; Container for data dumped during the optimisation.; Can be set by specifying the dumping level or set directly.; Note this is mainly intended for user and a development debugging; but could be used for status information during a long optimisation. dumping : string; level of data dumping: NONE, SUMMARY, FULL or CUSTOM; See property docstring for details. dump_to_file : bool; If set True then data will be dumped to file during the optimisation; dumping will be s",MatchSource.WIKI,docs/4.2/modules/qutip/control/optimizer.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/control/optimizer.html
https://qutip.org/docs/4.2/modules/qutip/control/optimizer.html:8051,Modifiability,config,configuration,8051,"lled; Note it should be left False when using the Dynamics; to calculate approximate gradients; Note it is set True automatically when the alg is CRAB. amp_lbound : float or list of floats; lower boundaries for the control amplitudes; Can be a scalar value applied to all controls; or a list of bounds for each control. amp_ubound : float or list of floats; upper boundaries for the control amplitudes; Can be a scalar value applied to all controls; or a list of bounds for each control. bounds : List of floats; Bounds for the parameters.; If not set before the run_optimization call then the list; is built automatically based on the amp_lbound and amp_ubound; attributes.; Setting this attribute directly allows specific bounds to be set; for individual parameters.; Note: Only some methods use bounds. dynamics : Dynamics (subclass instance); describes the dynamics of the (quantum) system to be control optimised; (see Dynamics classes for details). config : OptimConfig instance; various configuration options; (see OptimConfig for details). termination_conditions : TerminationCondition instance; attributes determine when the optimisation will end. pulse_generator : PulseGen (subclass instance); (can be) used to create initial pulses; not used by the class, but set by pulseoptim.create_pulse_optimizer. stats : Stats; attributes of which give performance stats for the optimisation; set to None to reduce overhead of calculating stats.; Note it is (usually) shared with the Dynamics instance. dump : :class:`dump.OptimDump`; Container for data dumped during the optimisation.; Can be set by specifying the dumping level or set directly.; Note this is mainly intended for user and a development debugging; but could be used for status information during a long optimisation. dumping : string; level of data dumping: NONE, SUMMARY, FULL or CUSTOM; See property docstring for details. dump_to_file : bool; If set True then data will be dumped to file during the optimisation; dumping will be s",MatchSource.WIKI,docs/4.2/modules/qutip/control/optimizer.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/control/optimizer.html
https://qutip.org/docs/4.2/modules/qutip/control/optimizer.html:9501,Modifiability,config,config,9501,"te it is (usually) shared with the Dynamics instance. dump : :class:`dump.OptimDump`; Container for data dumped during the optimisation.; Can be set by specifying the dumping level or set directly.; Note this is mainly intended for user and a development debugging; but could be used for status information during a long optimisation. dumping : string; level of data dumping: NONE, SUMMARY, FULL or CUSTOM; See property docstring for details. dump_to_file : bool; If set True then data will be dumped to file during the optimisation; dumping will be set to SUMMARY during init_optim; if dump_to_file is True and dumping not set.; Default is False. dump_dir : string; Basically a link to dump.dump_dir. Exists so that it can be set through; optim_params.; If dump is None then will return None or will set dumping to SUMMARY; when setting a path. iter_summary : :class:`OptimIterSummary`; Summary of the most recent iteration.; Note this is only set if dummping is on; ; """""". def __init__(self, config, dyn, params=None):; self.dynamics = dyn; self.config = config; self.params = params; self.reset(); dyn.parent = self. def reset(self):; self.log_level = self.config.log_level; self.id_text = 'OPTIM'; self.termination_conditions = None; self.pulse_generator = None; self.disp_conv_msg = False; self.iteration_steps = None; self.record_iteration_steps=False; self.alg = 'GRAPE'; self.alg_params = None; self.method = 'l_bfgs_b'; self.method_params = None; self.method_options = None; self.approx_grad = False; self.amp_lbound = None; self.amp_ubound = None; self.bounds = None; self.num_iter = 0; self.num_fid_func_calls = 0; self.num_grad_func_calls = 0; self.stats = None; self.wall_time_optim_start = 0.0. self.dump_to_file = False; self.dump = None; self.iter_summary = None. # AJGP 2015-04-21:; # These (copying from config) are here for backward compatibility; if hasattr(self.config, 'amp_lbound'):; if self.config.amp_lbound:; self.amp_lbound = self.config.amp_lbound; if hasattr(self.config, ",MatchSource.WIKI,docs/4.2/modules/qutip/control/optimizer.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/control/optimizer.html
https://qutip.org/docs/4.2/modules/qutip/control/optimizer.html:9555,Modifiability,config,config,9555,": :class:`dump.OptimDump`; Container for data dumped during the optimisation.; Can be set by specifying the dumping level or set directly.; Note this is mainly intended for user and a development debugging; but could be used for status information during a long optimisation. dumping : string; level of data dumping: NONE, SUMMARY, FULL or CUSTOM; See property docstring for details. dump_to_file : bool; If set True then data will be dumped to file during the optimisation; dumping will be set to SUMMARY during init_optim; if dump_to_file is True and dumping not set.; Default is False. dump_dir : string; Basically a link to dump.dump_dir. Exists so that it can be set through; optim_params.; If dump is None then will return None or will set dumping to SUMMARY; when setting a path. iter_summary : :class:`OptimIterSummary`; Summary of the most recent iteration.; Note this is only set if dummping is on; ; """""". def __init__(self, config, dyn, params=None):; self.dynamics = dyn; self.config = config; self.params = params; self.reset(); dyn.parent = self. def reset(self):; self.log_level = self.config.log_level; self.id_text = 'OPTIM'; self.termination_conditions = None; self.pulse_generator = None; self.disp_conv_msg = False; self.iteration_steps = None; self.record_iteration_steps=False; self.alg = 'GRAPE'; self.alg_params = None; self.method = 'l_bfgs_b'; self.method_params = None; self.method_options = None; self.approx_grad = False; self.amp_lbound = None; self.amp_ubound = None; self.bounds = None; self.num_iter = 0; self.num_fid_func_calls = 0; self.num_grad_func_calls = 0; self.stats = None; self.wall_time_optim_start = 0.0. self.dump_to_file = False; self.dump = None; self.iter_summary = None. # AJGP 2015-04-21:; # These (copying from config) are here for backward compatibility; if hasattr(self.config, 'amp_lbound'):; if self.config.amp_lbound:; self.amp_lbound = self.config.amp_lbound; if hasattr(self.config, 'amp_ubound'):; if self.config.amp_ubound:; self.amp_uboun",MatchSource.WIKI,docs/4.2/modules/qutip/control/optimizer.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/control/optimizer.html
https://qutip.org/docs/4.2/modules/qutip/control/optimizer.html:9564,Modifiability,config,config,9564,": :class:`dump.OptimDump`; Container for data dumped during the optimisation.; Can be set by specifying the dumping level or set directly.; Note this is mainly intended for user and a development debugging; but could be used for status information during a long optimisation. dumping : string; level of data dumping: NONE, SUMMARY, FULL or CUSTOM; See property docstring for details. dump_to_file : bool; If set True then data will be dumped to file during the optimisation; dumping will be set to SUMMARY during init_optim; if dump_to_file is True and dumping not set.; Default is False. dump_dir : string; Basically a link to dump.dump_dir. Exists so that it can be set through; optim_params.; If dump is None then will return None or will set dumping to SUMMARY; when setting a path. iter_summary : :class:`OptimIterSummary`; Summary of the most recent iteration.; Note this is only set if dummping is on; ; """""". def __init__(self, config, dyn, params=None):; self.dynamics = dyn; self.config = config; self.params = params; self.reset(); dyn.parent = self. def reset(self):; self.log_level = self.config.log_level; self.id_text = 'OPTIM'; self.termination_conditions = None; self.pulse_generator = None; self.disp_conv_msg = False; self.iteration_steps = None; self.record_iteration_steps=False; self.alg = 'GRAPE'; self.alg_params = None; self.method = 'l_bfgs_b'; self.method_params = None; self.method_options = None; self.approx_grad = False; self.amp_lbound = None; self.amp_ubound = None; self.bounds = None; self.num_iter = 0; self.num_fid_func_calls = 0; self.num_grad_func_calls = 0; self.stats = None; self.wall_time_optim_start = 0.0. self.dump_to_file = False; self.dump = None; self.iter_summary = None. # AJGP 2015-04-21:; # These (copying from config) are here for backward compatibility; if hasattr(self.config, 'amp_lbound'):; if self.config.amp_lbound:; self.amp_lbound = self.config.amp_lbound; if hasattr(self.config, 'amp_ubound'):; if self.config.amp_ubound:; self.amp_uboun",MatchSource.WIKI,docs/4.2/modules/qutip/control/optimizer.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/control/optimizer.html
https://qutip.org/docs/4.2/modules/qutip/control/optimizer.html:9667,Modifiability,config,config,9667,"the dumping level or set directly.; Note this is mainly intended for user and a development debugging; but could be used for status information during a long optimisation. dumping : string; level of data dumping: NONE, SUMMARY, FULL or CUSTOM; See property docstring for details. dump_to_file : bool; If set True then data will be dumped to file during the optimisation; dumping will be set to SUMMARY during init_optim; if dump_to_file is True and dumping not set.; Default is False. dump_dir : string; Basically a link to dump.dump_dir. Exists so that it can be set through; optim_params.; If dump is None then will return None or will set dumping to SUMMARY; when setting a path. iter_summary : :class:`OptimIterSummary`; Summary of the most recent iteration.; Note this is only set if dummping is on; ; """""". def __init__(self, config, dyn, params=None):; self.dynamics = dyn; self.config = config; self.params = params; self.reset(); dyn.parent = self. def reset(self):; self.log_level = self.config.log_level; self.id_text = 'OPTIM'; self.termination_conditions = None; self.pulse_generator = None; self.disp_conv_msg = False; self.iteration_steps = None; self.record_iteration_steps=False; self.alg = 'GRAPE'; self.alg_params = None; self.method = 'l_bfgs_b'; self.method_params = None; self.method_options = None; self.approx_grad = False; self.amp_lbound = None; self.amp_ubound = None; self.bounds = None; self.num_iter = 0; self.num_fid_func_calls = 0; self.num_grad_func_calls = 0; self.stats = None; self.wall_time_optim_start = 0.0. self.dump_to_file = False; self.dump = None; self.iter_summary = None. # AJGP 2015-04-21:; # These (copying from config) are here for backward compatibility; if hasattr(self.config, 'amp_lbound'):; if self.config.amp_lbound:; self.amp_lbound = self.config.amp_lbound; if hasattr(self.config, 'amp_ubound'):; if self.config.amp_ubound:; self.amp_ubound = self.config.amp_ubound. self.apply_params(). @property; def log_level(self):; return logger.level. @l",MatchSource.WIKI,docs/4.2/modules/qutip/control/optimizer.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/control/optimizer.html
https://qutip.org/docs/4.2/modules/qutip/control/optimizer.html:10329,Modifiability,config,config,10329,"etting a path. iter_summary : :class:`OptimIterSummary`; Summary of the most recent iteration.; Note this is only set if dummping is on; ; """""". def __init__(self, config, dyn, params=None):; self.dynamics = dyn; self.config = config; self.params = params; self.reset(); dyn.parent = self. def reset(self):; self.log_level = self.config.log_level; self.id_text = 'OPTIM'; self.termination_conditions = None; self.pulse_generator = None; self.disp_conv_msg = False; self.iteration_steps = None; self.record_iteration_steps=False; self.alg = 'GRAPE'; self.alg_params = None; self.method = 'l_bfgs_b'; self.method_params = None; self.method_options = None; self.approx_grad = False; self.amp_lbound = None; self.amp_ubound = None; self.bounds = None; self.num_iter = 0; self.num_fid_func_calls = 0; self.num_grad_func_calls = 0; self.stats = None; self.wall_time_optim_start = 0.0. self.dump_to_file = False; self.dump = None; self.iter_summary = None. # AJGP 2015-04-21:; # These (copying from config) are here for backward compatibility; if hasattr(self.config, 'amp_lbound'):; if self.config.amp_lbound:; self.amp_lbound = self.config.amp_lbound; if hasattr(self.config, 'amp_ubound'):; if self.config.amp_ubound:; self.amp_ubound = self.config.amp_ubound. self.apply_params(). @property; def log_level(self):; return logger.level. @log_level.setter; def log_level(self, lvl):; """"""; Set the log_level attribute and set the level of the logger; that is call logger.setLevel(lvl); """"""; logger.setLevel(lvl). [docs] def apply_params(self, params=None):; """"""; Set object attributes based on the dictionary (if any) passed in the; instantiation, or passed as a parameter; This is called during the instantiation automatically.; The key value pairs are the attribute name and value; Note: attributes are created if they do not exist already,; and are overwritten if they do.; """"""; if not params:; params = self.params. if isinstance(params, dict):; self.params = params; for key in params:; setattr(self, ke",MatchSource.WIKI,docs/4.2/modules/qutip/control/optimizer.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/control/optimizer.html
https://qutip.org/docs/4.2/modules/qutip/control/optimizer.html:10390,Modifiability,config,config,10390,"the most recent iteration.; Note this is only set if dummping is on; ; """""". def __init__(self, config, dyn, params=None):; self.dynamics = dyn; self.config = config; self.params = params; self.reset(); dyn.parent = self. def reset(self):; self.log_level = self.config.log_level; self.id_text = 'OPTIM'; self.termination_conditions = None; self.pulse_generator = None; self.disp_conv_msg = False; self.iteration_steps = None; self.record_iteration_steps=False; self.alg = 'GRAPE'; self.alg_params = None; self.method = 'l_bfgs_b'; self.method_params = None; self.method_options = None; self.approx_grad = False; self.amp_lbound = None; self.amp_ubound = None; self.bounds = None; self.num_iter = 0; self.num_fid_func_calls = 0; self.num_grad_func_calls = 0; self.stats = None; self.wall_time_optim_start = 0.0. self.dump_to_file = False; self.dump = None; self.iter_summary = None. # AJGP 2015-04-21:; # These (copying from config) are here for backward compatibility; if hasattr(self.config, 'amp_lbound'):; if self.config.amp_lbound:; self.amp_lbound = self.config.amp_lbound; if hasattr(self.config, 'amp_ubound'):; if self.config.amp_ubound:; self.amp_ubound = self.config.amp_ubound. self.apply_params(). @property; def log_level(self):; return logger.level. @log_level.setter; def log_level(self, lvl):; """"""; Set the log_level attribute and set the level of the logger; that is call logger.setLevel(lvl); """"""; logger.setLevel(lvl). [docs] def apply_params(self, params=None):; """"""; Set object attributes based on the dictionary (if any) passed in the; instantiation, or passed as a parameter; This is called during the instantiation automatically.; The key value pairs are the attribute name and value; Note: attributes are created if they do not exist already,; and are overwritten if they do.; """"""; if not params:; params = self.params. if isinstance(params, dict):; self.params = params; for key in params:; setattr(self, key, params[key]). @property; def dumping(self):; """"""; The level of da",MatchSource.WIKI,docs/4.2/modules/qutip/control/optimizer.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/control/optimizer.html
https://qutip.org/docs/4.2/modules/qutip/control/optimizer.html:10422,Modifiability,config,config,10422,"ration.; Note this is only set if dummping is on; ; """""". def __init__(self, config, dyn, params=None):; self.dynamics = dyn; self.config = config; self.params = params; self.reset(); dyn.parent = self. def reset(self):; self.log_level = self.config.log_level; self.id_text = 'OPTIM'; self.termination_conditions = None; self.pulse_generator = None; self.disp_conv_msg = False; self.iteration_steps = None; self.record_iteration_steps=False; self.alg = 'GRAPE'; self.alg_params = None; self.method = 'l_bfgs_b'; self.method_params = None; self.method_options = None; self.approx_grad = False; self.amp_lbound = None; self.amp_ubound = None; self.bounds = None; self.num_iter = 0; self.num_fid_func_calls = 0; self.num_grad_func_calls = 0; self.stats = None; self.wall_time_optim_start = 0.0. self.dump_to_file = False; self.dump = None; self.iter_summary = None. # AJGP 2015-04-21:; # These (copying from config) are here for backward compatibility; if hasattr(self.config, 'amp_lbound'):; if self.config.amp_lbound:; self.amp_lbound = self.config.amp_lbound; if hasattr(self.config, 'amp_ubound'):; if self.config.amp_ubound:; self.amp_ubound = self.config.amp_ubound. self.apply_params(). @property; def log_level(self):; return logger.level. @log_level.setter; def log_level(self, lvl):; """"""; Set the log_level attribute and set the level of the logger; that is call logger.setLevel(lvl); """"""; logger.setLevel(lvl). [docs] def apply_params(self, params=None):; """"""; Set object attributes based on the dictionary (if any) passed in the; instantiation, or passed as a parameter; This is called during the instantiation automatically.; The key value pairs are the attribute name and value; Note: attributes are created if they do not exist already,; and are overwritten if they do.; """"""; if not params:; params = self.params. if isinstance(params, dict):; self.params = params; for key in params:; setattr(self, key, params[key]). @property; def dumping(self):; """"""; The level of data dumping that will",MatchSource.WIKI,docs/4.2/modules/qutip/control/optimizer.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/control/optimizer.html
https://qutip.org/docs/4.2/modules/qutip/control/optimizer.html:10465,Modifiability,config,config,10465,"is on; ; """""". def __init__(self, config, dyn, params=None):; self.dynamics = dyn; self.config = config; self.params = params; self.reset(); dyn.parent = self. def reset(self):; self.log_level = self.config.log_level; self.id_text = 'OPTIM'; self.termination_conditions = None; self.pulse_generator = None; self.disp_conv_msg = False; self.iteration_steps = None; self.record_iteration_steps=False; self.alg = 'GRAPE'; self.alg_params = None; self.method = 'l_bfgs_b'; self.method_params = None; self.method_options = None; self.approx_grad = False; self.amp_lbound = None; self.amp_ubound = None; self.bounds = None; self.num_iter = 0; self.num_fid_func_calls = 0; self.num_grad_func_calls = 0; self.stats = None; self.wall_time_optim_start = 0.0. self.dump_to_file = False; self.dump = None; self.iter_summary = None. # AJGP 2015-04-21:; # These (copying from config) are here for backward compatibility; if hasattr(self.config, 'amp_lbound'):; if self.config.amp_lbound:; self.amp_lbound = self.config.amp_lbound; if hasattr(self.config, 'amp_ubound'):; if self.config.amp_ubound:; self.amp_ubound = self.config.amp_ubound. self.apply_params(). @property; def log_level(self):; return logger.level. @log_level.setter; def log_level(self, lvl):; """"""; Set the log_level attribute and set the level of the logger; that is call logger.setLevel(lvl); """"""; logger.setLevel(lvl). [docs] def apply_params(self, params=None):; """"""; Set object attributes based on the dictionary (if any) passed in the; instantiation, or passed as a parameter; This is called during the instantiation automatically.; The key value pairs are the attribute name and value; Note: attributes are created if they do not exist already,; and are overwritten if they do.; """"""; if not params:; params = self.params. if isinstance(params, dict):; self.params = params; for key in params:; setattr(self, key, params[key]). @property; def dumping(self):; """"""; The level of data dumping that will occur during the optimisation; - NONE : No",MatchSource.WIKI,docs/4.2/modules/qutip/control/optimizer.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/control/optimizer.html
https://qutip.org/docs/4.2/modules/qutip/control/optimizer.html:10500,Modifiability,config,config,10500,"rams=None):; self.dynamics = dyn; self.config = config; self.params = params; self.reset(); dyn.parent = self. def reset(self):; self.log_level = self.config.log_level; self.id_text = 'OPTIM'; self.termination_conditions = None; self.pulse_generator = None; self.disp_conv_msg = False; self.iteration_steps = None; self.record_iteration_steps=False; self.alg = 'GRAPE'; self.alg_params = None; self.method = 'l_bfgs_b'; self.method_params = None; self.method_options = None; self.approx_grad = False; self.amp_lbound = None; self.amp_ubound = None; self.bounds = None; self.num_iter = 0; self.num_fid_func_calls = 0; self.num_grad_func_calls = 0; self.stats = None; self.wall_time_optim_start = 0.0. self.dump_to_file = False; self.dump = None; self.iter_summary = None. # AJGP 2015-04-21:; # These (copying from config) are here for backward compatibility; if hasattr(self.config, 'amp_lbound'):; if self.config.amp_lbound:; self.amp_lbound = self.config.amp_lbound; if hasattr(self.config, 'amp_ubound'):; if self.config.amp_ubound:; self.amp_ubound = self.config.amp_ubound. self.apply_params(). @property; def log_level(self):; return logger.level. @log_level.setter; def log_level(self, lvl):; """"""; Set the log_level attribute and set the level of the logger; that is call logger.setLevel(lvl); """"""; logger.setLevel(lvl). [docs] def apply_params(self, params=None):; """"""; Set object attributes based on the dictionary (if any) passed in the; instantiation, or passed as a parameter; This is called during the instantiation automatically.; The key value pairs are the attribute name and value; Note: attributes are created if they do not exist already,; and are overwritten if they do.; """"""; if not params:; params = self.params. if isinstance(params, dict):; self.params = params; for key in params:; setattr(self, key, params[key]). @property; def dumping(self):; """"""; The level of data dumping that will occur during the optimisation; - NONE : No processing data dumped (Default); - SUMMARY : ",MatchSource.WIKI,docs/4.2/modules/qutip/control/optimizer.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/control/optimizer.html
https://qutip.org/docs/4.2/modules/qutip/control/optimizer.html:10532,Modifiability,config,config,10532,"ynamics = dyn; self.config = config; self.params = params; self.reset(); dyn.parent = self. def reset(self):; self.log_level = self.config.log_level; self.id_text = 'OPTIM'; self.termination_conditions = None; self.pulse_generator = None; self.disp_conv_msg = False; self.iteration_steps = None; self.record_iteration_steps=False; self.alg = 'GRAPE'; self.alg_params = None; self.method = 'l_bfgs_b'; self.method_params = None; self.method_options = None; self.approx_grad = False; self.amp_lbound = None; self.amp_ubound = None; self.bounds = None; self.num_iter = 0; self.num_fid_func_calls = 0; self.num_grad_func_calls = 0; self.stats = None; self.wall_time_optim_start = 0.0. self.dump_to_file = False; self.dump = None; self.iter_summary = None. # AJGP 2015-04-21:; # These (copying from config) are here for backward compatibility; if hasattr(self.config, 'amp_lbound'):; if self.config.amp_lbound:; self.amp_lbound = self.config.amp_lbound; if hasattr(self.config, 'amp_ubound'):; if self.config.amp_ubound:; self.amp_ubound = self.config.amp_ubound. self.apply_params(). @property; def log_level(self):; return logger.level. @log_level.setter; def log_level(self, lvl):; """"""; Set the log_level attribute and set the level of the logger; that is call logger.setLevel(lvl); """"""; logger.setLevel(lvl). [docs] def apply_params(self, params=None):; """"""; Set object attributes based on the dictionary (if any) passed in the; instantiation, or passed as a parameter; This is called during the instantiation automatically.; The key value pairs are the attribute name and value; Note: attributes are created if they do not exist already,; and are overwritten if they do.; """"""; if not params:; params = self.params. if isinstance(params, dict):; self.params = params; for key in params:; setattr(self, key, params[key]). @property; def dumping(self):; """"""; The level of data dumping that will occur during the optimisation; - NONE : No processing data dumped (Default); - SUMMARY : A summary at each it",MatchSource.WIKI,docs/4.2/modules/qutip/control/optimizer.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/control/optimizer.html
https://qutip.org/docs/4.2/modules/qutip/control/optimizer.html:10575,Modifiability,config,config,10575,"arams = params; self.reset(); dyn.parent = self. def reset(self):; self.log_level = self.config.log_level; self.id_text = 'OPTIM'; self.termination_conditions = None; self.pulse_generator = None; self.disp_conv_msg = False; self.iteration_steps = None; self.record_iteration_steps=False; self.alg = 'GRAPE'; self.alg_params = None; self.method = 'l_bfgs_b'; self.method_params = None; self.method_options = None; self.approx_grad = False; self.amp_lbound = None; self.amp_ubound = None; self.bounds = None; self.num_iter = 0; self.num_fid_func_calls = 0; self.num_grad_func_calls = 0; self.stats = None; self.wall_time_optim_start = 0.0. self.dump_to_file = False; self.dump = None; self.iter_summary = None. # AJGP 2015-04-21:; # These (copying from config) are here for backward compatibility; if hasattr(self.config, 'amp_lbound'):; if self.config.amp_lbound:; self.amp_lbound = self.config.amp_lbound; if hasattr(self.config, 'amp_ubound'):; if self.config.amp_ubound:; self.amp_ubound = self.config.amp_ubound. self.apply_params(). @property; def log_level(self):; return logger.level. @log_level.setter; def log_level(self, lvl):; """"""; Set the log_level attribute and set the level of the logger; that is call logger.setLevel(lvl); """"""; logger.setLevel(lvl). [docs] def apply_params(self, params=None):; """"""; Set object attributes based on the dictionary (if any) passed in the; instantiation, or passed as a parameter; This is called during the instantiation automatically.; The key value pairs are the attribute name and value; Note: attributes are created if they do not exist already,; and are overwritten if they do.; """"""; if not params:; params = self.params. if isinstance(params, dict):; self.params = params; for key in params:; setattr(self, key, params[key]). @property; def dumping(self):; """"""; The level of data dumping that will occur during the optimisation; - NONE : No processing data dumped (Default); - SUMMARY : A summary at each iteration will be recorded; - FULL : All logs",MatchSource.WIKI,docs/4.2/modules/qutip/control/optimizer.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/control/optimizer.html
https://qutip.org/docs/4.2/modules/qutip/control/optimizer.html:13000,Modifiability,config,configuration,13000,"ue):; raise TypeError(""Value must be string value""); lvl = value.upper(); if lvl == 'NONE':; self.dump = None; else:; if not isinstance(self.dump, qtrldump.OptimDump):; self.dump = qtrldump.OptimDump(self, level=lvl); else:; self.dump.level = lvl; @property; def dump_dir(self):; if self.dump:; return self.dump.dump_dir; else:; return None. @dump_dir.setter; def dump_dir(self, value):; if not self.dump:; self.dumping = 'SUMMARY'; self.dump.dump_dir = value. def _create_result(self):; """"""; create the result object; and set the initial_amps attribute as the current amplitudes; """"""; result = optimresult.OptimResult(); result.initial_fid_err = self.dynamics.fid_computer.get_fid_err(); result.initial_amps = self.dynamics.ctrl_amps.copy(); result.time = self.dynamics.time; result.optimizer = self; return result. [docs] def init_optim(self, term_conds):; """"""; Check optimiser attribute status and passed parameters before; running the optimisation.; This is called by run_optimization, but could called independently; to check the configuration.; """"""; if term_conds is not None:; self.termination_conditions = term_conds; term_conds = self.termination_conditions. if not isinstance(term_conds, termcond.TerminationConditions):; raise errors.UsageError(""No termination conditions for the ""; ""optimisation function""). if not isinstance(self.dynamics, dynamics.Dynamics):; raise errors.UsageError(""No dynamics object attribute set""); self.dynamics.check_ctrls_initialized(). self.apply_method_params(). if term_conds.fid_err_targ is None and term_conds.fid_goal is None:; raise errors.UsageError(""Either the goal or the fidelity ""; ""error tolerance must be set""). if term_conds.fid_err_targ is None:; term_conds.fid_err_targ = np.abs(1 - term_conds.fid_goal). if term_conds.fid_goal is None:; term_conds.fid_goal = 1 - term_conds.fid_err_targ. if self.alg == 'CRAB':; self.approx_grad = True. if self.stats is not None:; self.stats.clear(). if self.dump_to_file:; if self.dump is None:; self.dumping ",MatchSource.WIKI,docs/4.2/modules/qutip/control/optimizer.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/control/optimizer.html
https://qutip.org/docs/4.2/modules/qutip/control/optimizer.html:16405,Modifiability,config,config,16405,"radient_norm; if not 'disp' in mo:; mo['disp'] = self.disp_conv_msg. return mo. [docs] def apply_method_params(self, params=None):; """"""; Loops through all the method_params; (either passed here or the method_params attribute); If the name matches an attribute of this object or the; termination conditions object, then the value of this attribute; is set. Otherwise it is assumed to a method_option for the; scipy.optimize.minimize function; """"""; if not params:; params = self.method_params. if isinstance(params, dict):; self.method_params = params; unused_params = {}; for key in params:; val = params[key]; if hasattr(self, key):; setattr(self, key, val); if hasattr(self.termination_conditions, key):; setattr(self.termination_conditions, key, val); else:; unused_params[key] = val. if len(unused_params) > 0:; if not isinstance(self.method_options, dict):; self.method_options = unused_params; else:; self.method_options.update(unused_params). def _build_bounds_list(self):; cfg = self.config; dyn = self.dynamics; n_ctrls = dyn.num_ctrls; self.bounds = []; for t in range(dyn.num_tslots):; for c in range(n_ctrls):; if isinstance(self.amp_lbound, list):; lb = self.amp_lbound[c]; else:; lb = self.amp_lbound; if isinstance(self.amp_ubound, list):; ub = self.amp_ubound[c]; else:; ub = self.amp_ubound. if not lb is None and np.isinf(lb):; lb = None; if not ub is None and np.isinf(ub):; ub = None. self.bounds.append((lb, ub)). [docs] def run_optimization(self, term_conds=None):; """"""; This default function optimisation method is a wrapper to the; scipy.optimize.minimize function. It will attempt to minimise the fidelity error with respect to some; parameters, which are determined by _get_optim_var_vals (see below). The optimisation end when one of the passed termination conditions; has been met, e.g. target achieved, wall time, or; function call or iteration count exceeded. Note these; conditions include gradient minimum met (local minima) for; methods that use a gradient. The functio",MatchSource.WIKI,docs/4.2/modules/qutip/control/optimizer.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/control/optimizer.html
https://qutip.org/docs/4.2/modules/qutip/control/optimizer.html:18106,Modifiability,config,config,18106,"_optim_var_vals (see below). The optimisation end when one of the passed termination conditions; has been met, e.g. target achieved, wall time, or; function call or iteration count exceeded. Note these; conditions include gradient minimum met (local minima) for; methods that use a gradient. The function minimisation method is taken from the optim_method; attribute. Note that not all of these methods have been tested.; Note that some of these use a gradient and some do not.; See the scipy documentation for details. Options specific to the; method can be passed setting the method_params attribute. If the parameter term_conds=None, then the termination_conditions; attribute must already be set. It will be overwritten if the; parameter is not None. The result is returned in an OptimResult object, which includes; the final fidelity, time evolution, reason for termination etc; ; """"""; self.init_optim(term_conds); term_conds = self.termination_conditions; dyn = self.dynamics; cfg = self.config; self.optim_var_vals = self._get_optim_var_vals(); st_time = timeit.default_timer(); self.wall_time_optimize_start = st_time. if self.stats is not None:; self.stats.wall_time_optim_start = st_time; self.stats.wall_time_optim_end = 0.0; self.stats.num_iter = 0. if self.bounds is None:; self._build_bounds_list(). self._build_method_options(). result = self._create_result(). if self.approx_grad:; jac=None; else:; jac=self.fid_err_grad_wrapper. if self.log_level <= logging.INFO:; msg = (""Optimising pulse(s) using {} with ""; ""minimise '{}' method"").format(self.alg, self.method); if self.approx_grad:; msg += "" (approx grad)""; logger.info(msg). try:; opt_res = spopt.minimize(; self.fid_err_func_wrapper, self.optim_var_vals,; method=self.method,; jac=jac,; bounds=self.bounds,; options=self.method_options,; callback=self.iter_step_callback_func). amps = self._get_ctrl_amps(opt_res.x); dyn.update_ctrl_amps(amps); result.termination_reason = opt_res.message; # Note the iterations are counted in t",MatchSource.WIKI,docs/4.2/modules/qutip/control/optimizer.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/control/optimizer.html
https://qutip.org/docs/4.2/modules/qutip/control/optimizer.html:19703,Modifiability,variab,variable,19703,"d)""; logger.info(msg). try:; opt_res = spopt.minimize(; self.fid_err_func_wrapper, self.optim_var_vals,; method=self.method,; jac=jac,; bounds=self.bounds,; options=self.method_options,; callback=self.iter_step_callback_func). amps = self._get_ctrl_amps(opt_res.x); dyn.update_ctrl_amps(amps); result.termination_reason = opt_res.message; # Note the iterations are counted in this object as well; # so there are compared here for interest sake only; if self.num_iter != opt_res.nit:; logger.info(""The number of iterations counted {} ""; "" does not match the number reported {} ""; ""by {}"".format(self.num_iter, opt_res.nit,; self.method)); result.num_iter = opt_res.nit. except errors.OptimizationTerminate as except_term:; self._interpret_term_exception(except_term, result). end_time = timeit.default_timer(); self._add_common_result_attribs(result, st_time, end_time). return result. def _get_optim_var_vals(self):; """"""; Generate the 1d array that holds the current variable values; of the function to be optimised; By default (as used in GRAPE) these are the control amplitudes; in each timeslot; """"""; return self.dynamics.ctrl_amps.reshape([-1]). def _get_ctrl_amps(self, optim_var_vals):; """"""; Get the control amplitudes from the current variable values; of the function to be optimised.; that is the 1d array that is passed from the optimisation method; Note for GRAPE these are the function optimiser parameters; (and this is the default); ; Returns; -------; float array[dynamics.num_tslots, dynamics.num_ctrls]; """"""; amps = optim_var_vals.reshape(self.dynamics.ctrl_amps.shape). return amps. [docs] def fid_err_func_wrapper(self, *args):; """"""; Get the fidelity error achieved using the ctrl amplitudes passed; in as the first argument. This is called by generic optimisation algorithm as the; func to the minimised. The argument is the current; variable values, i.e. control amplitudes, passed as; a flat array. Hence these are reshaped as [nTimeslots, n_ctrls]; and then used to update the s",MatchSource.WIKI,docs/4.2/modules/qutip/control/optimizer.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/control/optimizer.html
https://qutip.org/docs/4.2/modules/qutip/control/optimizer.html:19978,Modifiability,variab,variable,19978,"func). amps = self._get_ctrl_amps(opt_res.x); dyn.update_ctrl_amps(amps); result.termination_reason = opt_res.message; # Note the iterations are counted in this object as well; # so there are compared here for interest sake only; if self.num_iter != opt_res.nit:; logger.info(""The number of iterations counted {} ""; "" does not match the number reported {} ""; ""by {}"".format(self.num_iter, opt_res.nit,; self.method)); result.num_iter = opt_res.nit. except errors.OptimizationTerminate as except_term:; self._interpret_term_exception(except_term, result). end_time = timeit.default_timer(); self._add_common_result_attribs(result, st_time, end_time). return result. def _get_optim_var_vals(self):; """"""; Generate the 1d array that holds the current variable values; of the function to be optimised; By default (as used in GRAPE) these are the control amplitudes; in each timeslot; """"""; return self.dynamics.ctrl_amps.reshape([-1]). def _get_ctrl_amps(self, optim_var_vals):; """"""; Get the control amplitudes from the current variable values; of the function to be optimised.; that is the 1d array that is passed from the optimisation method; Note for GRAPE these are the function optimiser parameters; (and this is the default); ; Returns; -------; float array[dynamics.num_tslots, dynamics.num_ctrls]; """"""; amps = optim_var_vals.reshape(self.dynamics.ctrl_amps.shape). return amps. [docs] def fid_err_func_wrapper(self, *args):; """"""; Get the fidelity error achieved using the ctrl amplitudes passed; in as the first argument. This is called by generic optimisation algorithm as the; func to the minimised. The argument is the current; variable values, i.e. control amplitudes, passed as; a flat array. Hence these are reshaped as [nTimeslots, n_ctrls]; and then used to update the stored ctrl values (if they have changed). The error is checked against the target, and the optimisation is; terminated if the target has been achieved.; """"""; self.num_fid_func_calls += 1; # *** update stats ***; if self.",MatchSource.WIKI,docs/4.2/modules/qutip/control/optimizer.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/control/optimizer.html
https://qutip.org/docs/4.2/modules/qutip/control/optimizer.html:20589,Modifiability,variab,variable,20589,"t, st_time, end_time). return result. def _get_optim_var_vals(self):; """"""; Generate the 1d array that holds the current variable values; of the function to be optimised; By default (as used in GRAPE) these are the control amplitudes; in each timeslot; """"""; return self.dynamics.ctrl_amps.reshape([-1]). def _get_ctrl_amps(self, optim_var_vals):; """"""; Get the control amplitudes from the current variable values; of the function to be optimised.; that is the 1d array that is passed from the optimisation method; Note for GRAPE these are the function optimiser parameters; (and this is the default); ; Returns; -------; float array[dynamics.num_tslots, dynamics.num_ctrls]; """"""; amps = optim_var_vals.reshape(self.dynamics.ctrl_amps.shape). return amps. [docs] def fid_err_func_wrapper(self, *args):; """"""; Get the fidelity error achieved using the ctrl amplitudes passed; in as the first argument. This is called by generic optimisation algorithm as the; func to the minimised. The argument is the current; variable values, i.e. control amplitudes, passed as; a flat array. Hence these are reshaped as [nTimeslots, n_ctrls]; and then used to update the stored ctrl values (if they have changed). The error is checked against the target, and the optimisation is; terminated if the target has been achieved.; """"""; self.num_fid_func_calls += 1; # *** update stats ***; if self.stats is not None:; self.stats.num_fidelity_func_calls = self.num_fid_func_calls; if self.log_level <= logging.DEBUG:; logger.debug(""fidelity error call {}"".format(; self.stats.num_fidelity_func_calls)). amps = self._get_ctrl_amps(args[0].copy()); self.dynamics.update_ctrl_amps(amps). tc = self.termination_conditions; err = self.dynamics.fid_computer.get_fid_err(). if self.iter_summary:; self.iter_summary.fid_func_call_num = self.num_fid_func_calls; self.iter_summary.fid_err = err. if self.dump and self.dump.dump_fid_err:; self.dump.update_fid_err_log(err). if err <= tc.fid_err_targ:; raise errors.GoalAchievedTerminate(e",MatchSource.WIKI,docs/4.2/modules/qutip/control/optimizer.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/control/optimizer.html
https://qutip.org/docs/4.2/modules/qutip/control/optimizer.html:21813,Modifiability,variab,variables,21813,"hey have changed). The error is checked against the target, and the optimisation is; terminated if the target has been achieved.; """"""; self.num_fid_func_calls += 1; # *** update stats ***; if self.stats is not None:; self.stats.num_fidelity_func_calls = self.num_fid_func_calls; if self.log_level <= logging.DEBUG:; logger.debug(""fidelity error call {}"".format(; self.stats.num_fidelity_func_calls)). amps = self._get_ctrl_amps(args[0].copy()); self.dynamics.update_ctrl_amps(amps). tc = self.termination_conditions; err = self.dynamics.fid_computer.get_fid_err(). if self.iter_summary:; self.iter_summary.fid_func_call_num = self.num_fid_func_calls; self.iter_summary.fid_err = err. if self.dump and self.dump.dump_fid_err:; self.dump.update_fid_err_log(err). if err <= tc.fid_err_targ:; raise errors.GoalAchievedTerminate(err). if self.num_fid_func_calls > tc.max_fid_func_calls:; raise errors.MaxFidFuncCallTerminate(). return err. [docs] def fid_err_grad_wrapper(self, *args):; """"""; Get the gradient of the fidelity error with respect to all of the; variables, i.e. the ctrl amplidutes in each timeslot. This is called by generic optimisation algorithm as the gradients of; func to the minimised wrt the variables. The argument is the current; variable values, i.e. control amplitudes, passed as; a flat array. Hence these are reshaped as [nTimeslots, n_ctrls]; and then used to update the stored ctrl values (if they have changed). Although the optimisation algorithms have a check within them for; function convergence, i.e. local minima, the sum of the squares; of the normalised gradient is checked explicitly, and the; optimisation is terminated if this is below the min_gradient_norm; condition; """"""; # *** update stats ***; self.num_grad_func_calls += 1; if self.stats is not None:; self.stats.num_grad_func_calls = self.num_grad_func_calls; if self.log_level <= logging.DEBUG:; logger.debug(""gradient call {}"".format(; self.stats.num_grad_func_calls)); amps = self._get_ctrl_amps(args[0].c",MatchSource.WIKI,docs/4.2/modules/qutip/control/optimizer.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/control/optimizer.html
https://qutip.org/docs/4.2/modules/qutip/control/optimizer.html:21967,Modifiability,variab,variables,21967,"1; # *** update stats ***; if self.stats is not None:; self.stats.num_fidelity_func_calls = self.num_fid_func_calls; if self.log_level <= logging.DEBUG:; logger.debug(""fidelity error call {}"".format(; self.stats.num_fidelity_func_calls)). amps = self._get_ctrl_amps(args[0].copy()); self.dynamics.update_ctrl_amps(amps). tc = self.termination_conditions; err = self.dynamics.fid_computer.get_fid_err(). if self.iter_summary:; self.iter_summary.fid_func_call_num = self.num_fid_func_calls; self.iter_summary.fid_err = err. if self.dump and self.dump.dump_fid_err:; self.dump.update_fid_err_log(err). if err <= tc.fid_err_targ:; raise errors.GoalAchievedTerminate(err). if self.num_fid_func_calls > tc.max_fid_func_calls:; raise errors.MaxFidFuncCallTerminate(). return err. [docs] def fid_err_grad_wrapper(self, *args):; """"""; Get the gradient of the fidelity error with respect to all of the; variables, i.e. the ctrl amplidutes in each timeslot. This is called by generic optimisation algorithm as the gradients of; func to the minimised wrt the variables. The argument is the current; variable values, i.e. control amplitudes, passed as; a flat array. Hence these are reshaped as [nTimeslots, n_ctrls]; and then used to update the stored ctrl values (if they have changed). Although the optimisation algorithms have a check within them for; function convergence, i.e. local minima, the sum of the squares; of the normalised gradient is checked explicitly, and the; optimisation is terminated if this is below the min_gradient_norm; condition; """"""; # *** update stats ***; self.num_grad_func_calls += 1; if self.stats is not None:; self.stats.num_grad_func_calls = self.num_grad_func_calls; if self.log_level <= logging.DEBUG:; logger.debug(""gradient call {}"".format(; self.stats.num_grad_func_calls)); amps = self._get_ctrl_amps(args[0].copy()); self.dynamics.update_ctrl_amps(amps); fid_comp = self.dynamics.fid_computer; # gradient_norm_func is a pointer to the function set in the config; # that r",MatchSource.WIKI,docs/4.2/modules/qutip/control/optimizer.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/control/optimizer.html
https://qutip.org/docs/4.2/modules/qutip/control/optimizer.html:22007,Modifiability,variab,variable,22007,"unc_calls = self.num_fid_func_calls; if self.log_level <= logging.DEBUG:; logger.debug(""fidelity error call {}"".format(; self.stats.num_fidelity_func_calls)). amps = self._get_ctrl_amps(args[0].copy()); self.dynamics.update_ctrl_amps(amps). tc = self.termination_conditions; err = self.dynamics.fid_computer.get_fid_err(). if self.iter_summary:; self.iter_summary.fid_func_call_num = self.num_fid_func_calls; self.iter_summary.fid_err = err. if self.dump and self.dump.dump_fid_err:; self.dump.update_fid_err_log(err). if err <= tc.fid_err_targ:; raise errors.GoalAchievedTerminate(err). if self.num_fid_func_calls > tc.max_fid_func_calls:; raise errors.MaxFidFuncCallTerminate(). return err. [docs] def fid_err_grad_wrapper(self, *args):; """"""; Get the gradient of the fidelity error with respect to all of the; variables, i.e. the ctrl amplidutes in each timeslot. This is called by generic optimisation algorithm as the gradients of; func to the minimised wrt the variables. The argument is the current; variable values, i.e. control amplitudes, passed as; a flat array. Hence these are reshaped as [nTimeslots, n_ctrls]; and then used to update the stored ctrl values (if they have changed). Although the optimisation algorithms have a check within them for; function convergence, i.e. local minima, the sum of the squares; of the normalised gradient is checked explicitly, and the; optimisation is terminated if this is below the min_gradient_norm; condition; """"""; # *** update stats ***; self.num_grad_func_calls += 1; if self.stats is not None:; self.stats.num_grad_func_calls = self.num_grad_func_calls; if self.log_level <= logging.DEBUG:; logger.debug(""gradient call {}"".format(; self.stats.num_grad_func_calls)); amps = self._get_ctrl_amps(args[0].copy()); self.dynamics.update_ctrl_amps(amps); fid_comp = self.dynamics.fid_computer; # gradient_norm_func is a pointer to the function set in the config; # that returns the normalised gradients; grad = fid_comp.get_fid_err_gradient(). if self",MatchSource.WIKI,docs/4.2/modules/qutip/control/optimizer.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/control/optimizer.html
https://qutip.org/docs/4.2/modules/qutip/control/optimizer.html:22906,Modifiability,config,config,22906,"tion algorithm as the gradients of; func to the minimised wrt the variables. The argument is the current; variable values, i.e. control amplitudes, passed as; a flat array. Hence these are reshaped as [nTimeslots, n_ctrls]; and then used to update the stored ctrl values (if they have changed). Although the optimisation algorithms have a check within them for; function convergence, i.e. local minima, the sum of the squares; of the normalised gradient is checked explicitly, and the; optimisation is terminated if this is below the min_gradient_norm; condition; """"""; # *** update stats ***; self.num_grad_func_calls += 1; if self.stats is not None:; self.stats.num_grad_func_calls = self.num_grad_func_calls; if self.log_level <= logging.DEBUG:; logger.debug(""gradient call {}"".format(; self.stats.num_grad_func_calls)); amps = self._get_ctrl_amps(args[0].copy()); self.dynamics.update_ctrl_amps(amps); fid_comp = self.dynamics.fid_computer; # gradient_norm_func is a pointer to the function set in the config; # that returns the normalised gradients; grad = fid_comp.get_fid_err_gradient(). if self.iter_summary:; self.iter_summary.grad_func_call_num = self.num_grad_func_calls; self.iter_summary.grad_norm = fid_comp.grad_norm. if self.dump:; if self.dump.dump_grad_norm:; self.dump.update_grad_norm_log(fid_comp.grad_norm). if self.dump.dump_grad:; self.dump.update_grad_log(grad). tc = self.termination_conditions; if fid_comp.grad_norm < tc.min_gradient_norm:; raise errors.GradMinReachedTerminate(fid_comp.grad_norm); return grad.flatten(). [docs] def iter_step_callback_func(self, *args):; """"""; Check the elapsed wall time for the optimisation run so far.; Terminate if this has exceeded the maximum allowed time; """"""; self.num_iter += 1. if self.log_level <= logging.DEBUG:; logger.debug(""Iteration callback {}"".format(self.num_iter)). wall_time = timeit.default_timer() - self.wall_time_optimize_start. if self.iter_summary:; self.iter_summary.iter_num = self.num_iter; self.iter_summary.w",MatchSource.WIKI,docs/4.2/modules/qutip/control/optimizer.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/control/optimizer.html
https://qutip.org/docs/4.2/modules/qutip/control/optimizer.html:28161,Modifiability,variab,variable,28161,"grad, invHess, nFCalls, nGCalls, warn = \; spopt.fmin_bfgs(self.fid_err_func_wrapper,; self.optim_var_vals,; fprime=fprime,; # approx_grad=self.approx_grad,; callback=self.iter_step_callback_func,; gtol=term_conds.min_gradient_norm,; maxiter=term_conds.max_iterations,; full_output=True, disp=True). amps = self._get_ctrl_amps(optim_var_vals); dyn.update_ctrl_amps(amps); if warn == 1:; result.max_iter_exceeded = True; result.termination_reason = ""Iteration count limit reached""; elif warn == 2:; result.grad_norm_min_reached = True; result.termination_reason = ""Gradient normal minimum reached"". except errors.OptimizationTerminate as except_term:; self._interpret_term_exception(except_term, result). end_time = timeit.default_timer(); self._add_common_result_attribs(result, st_time, end_time). return result. [docs]class OptimizerLBFGSB(Optimizer):; """"""; Implements the run_optimization method using the L-BFGS-B algorithm. Attributes; ----------; max_metric_corr : integer; The maximum number of variable metric corrections used to define; the limited memory matrix. That is the number of previous; gradient values that are used to approximate the Hessian; see the scipy.optimize.fmin_l_bfgs_b documentation for description; of m argument. """""". def reset(self):; Optimizer.reset(self); self.id_text = 'LBFGSB'; self.max_metric_corr = 10; self.msg_level = None. [docs] def init_optim(self, term_conds):; """"""; Check optimiser attribute status and passed parameters before; running the optimisation.; This is called by run_optimization, but could called independently; to check the configuration.; """"""; if term_conds is None:; term_conds = self.termination_conditions. # AJGP 2015-04-21:; # These (copying from config) are here for backward compatibility; if hasattr(self.config, 'max_metric_corr'):; if self.config.max_metric_corr:; self.max_metric_corr = self.config.max_metric_corr; if hasattr(self.config, 'accuracy_factor'):; if self.config.accuracy_factor:; term_conds.accuracy_factor = \; s",MatchSource.WIKI,docs/4.2/modules/qutip/control/optimizer.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/control/optimizer.html
https://qutip.org/docs/4.2/modules/qutip/control/optimizer.html:28744,Modifiability,config,configuration,28744,"ion_reason = ""Gradient normal minimum reached"". except errors.OptimizationTerminate as except_term:; self._interpret_term_exception(except_term, result). end_time = timeit.default_timer(); self._add_common_result_attribs(result, st_time, end_time). return result. [docs]class OptimizerLBFGSB(Optimizer):; """"""; Implements the run_optimization method using the L-BFGS-B algorithm. Attributes; ----------; max_metric_corr : integer; The maximum number of variable metric corrections used to define; the limited memory matrix. That is the number of previous; gradient values that are used to approximate the Hessian; see the scipy.optimize.fmin_l_bfgs_b documentation for description; of m argument. """""". def reset(self):; Optimizer.reset(self); self.id_text = 'LBFGSB'; self.max_metric_corr = 10; self.msg_level = None. [docs] def init_optim(self, term_conds):; """"""; Check optimiser attribute status and passed parameters before; running the optimisation.; This is called by run_optimization, but could called independently; to check the configuration.; """"""; if term_conds is None:; term_conds = self.termination_conditions. # AJGP 2015-04-21:; # These (copying from config) are here for backward compatibility; if hasattr(self.config, 'max_metric_corr'):; if self.config.max_metric_corr:; self.max_metric_corr = self.config.max_metric_corr; if hasattr(self.config, 'accuracy_factor'):; if self.config.accuracy_factor:; term_conds.accuracy_factor = \; self.config.accuracy_factor. Optimizer.init_optim(self, term_conds). if not isinstance(self.msg_level, int):; if self.log_level < logging.DEBUG:; self.msg_level = 2; elif self.log_level <= logging.DEBUG:; self.msg_level = 1; else:; self.msg_level = 0. [docs] def run_optimization(self, term_conds=None):; """"""; Optimise the control pulse amplitudes to minimise the fidelity error; using the L-BFGS-B algorithm, which is the constrained; (bounded amplitude values), limited memory, version of the; BroydenâFletcherâGoldfarbâShanno algorithm. The optimisa",MatchSource.WIKI,docs/4.2/modules/qutip/control/optimizer.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/control/optimizer.html
https://qutip.org/docs/4.2/modules/qutip/control/optimizer.html:28873,Modifiability,config,config,28873,"efault_timer(); self._add_common_result_attribs(result, st_time, end_time). return result. [docs]class OptimizerLBFGSB(Optimizer):; """"""; Implements the run_optimization method using the L-BFGS-B algorithm. Attributes; ----------; max_metric_corr : integer; The maximum number of variable metric corrections used to define; the limited memory matrix. That is the number of previous; gradient values that are used to approximate the Hessian; see the scipy.optimize.fmin_l_bfgs_b documentation for description; of m argument. """""". def reset(self):; Optimizer.reset(self); self.id_text = 'LBFGSB'; self.max_metric_corr = 10; self.msg_level = None. [docs] def init_optim(self, term_conds):; """"""; Check optimiser attribute status and passed parameters before; running the optimisation.; This is called by run_optimization, but could called independently; to check the configuration.; """"""; if term_conds is None:; term_conds = self.termination_conditions. # AJGP 2015-04-21:; # These (copying from config) are here for backward compatibility; if hasattr(self.config, 'max_metric_corr'):; if self.config.max_metric_corr:; self.max_metric_corr = self.config.max_metric_corr; if hasattr(self.config, 'accuracy_factor'):; if self.config.accuracy_factor:; term_conds.accuracy_factor = \; self.config.accuracy_factor. Optimizer.init_optim(self, term_conds). if not isinstance(self.msg_level, int):; if self.log_level < logging.DEBUG:; self.msg_level = 2; elif self.log_level <= logging.DEBUG:; self.msg_level = 1; else:; self.msg_level = 0. [docs] def run_optimization(self, term_conds=None):; """"""; Optimise the control pulse amplitudes to minimise the fidelity error; using the L-BFGS-B algorithm, which is the constrained; (bounded amplitude values), limited memory, version of the; BroydenâFletcherâGoldfarbâShanno algorithm. The optimisation end when one of the passed termination conditions; has been met, e.g. target achieved, gradient minimum met; (local minima), wall time / iteration count exceeded. Esse",MatchSource.WIKI,docs/4.2/modules/qutip/control/optimizer.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/control/optimizer.html
https://qutip.org/docs/4.2/modules/qutip/control/optimizer.html:28934,Modifiability,config,config,28934,"ime). return result. [docs]class OptimizerLBFGSB(Optimizer):; """"""; Implements the run_optimization method using the L-BFGS-B algorithm. Attributes; ----------; max_metric_corr : integer; The maximum number of variable metric corrections used to define; the limited memory matrix. That is the number of previous; gradient values that are used to approximate the Hessian; see the scipy.optimize.fmin_l_bfgs_b documentation for description; of m argument. """""". def reset(self):; Optimizer.reset(self); self.id_text = 'LBFGSB'; self.max_metric_corr = 10; self.msg_level = None. [docs] def init_optim(self, term_conds):; """"""; Check optimiser attribute status and passed parameters before; running the optimisation.; This is called by run_optimization, but could called independently; to check the configuration.; """"""; if term_conds is None:; term_conds = self.termination_conditions. # AJGP 2015-04-21:; # These (copying from config) are here for backward compatibility; if hasattr(self.config, 'max_metric_corr'):; if self.config.max_metric_corr:; self.max_metric_corr = self.config.max_metric_corr; if hasattr(self.config, 'accuracy_factor'):; if self.config.accuracy_factor:; term_conds.accuracy_factor = \; self.config.accuracy_factor. Optimizer.init_optim(self, term_conds). if not isinstance(self.msg_level, int):; if self.log_level < logging.DEBUG:; self.msg_level = 2; elif self.log_level <= logging.DEBUG:; self.msg_level = 1; else:; self.msg_level = 0. [docs] def run_optimization(self, term_conds=None):; """"""; Optimise the control pulse amplitudes to minimise the fidelity error; using the L-BFGS-B algorithm, which is the constrained; (bounded amplitude values), limited memory, version of the; BroydenâFletcherâGoldfarbâShanno algorithm. The optimisation end when one of the passed termination conditions; has been met, e.g. target achieved, gradient minimum met; (local minima), wall time / iteration count exceeded. Essentially this is wrapper to the:; scipy.optimize.fmin_l_bfgs_b function;",MatchSource.WIKI,docs/4.2/modules/qutip/control/optimizer.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/control/optimizer.html
https://qutip.org/docs/4.2/modules/qutip/control/optimizer.html:28971,Modifiability,config,config,28971,"docs]class OptimizerLBFGSB(Optimizer):; """"""; Implements the run_optimization method using the L-BFGS-B algorithm. Attributes; ----------; max_metric_corr : integer; The maximum number of variable metric corrections used to define; the limited memory matrix. That is the number of previous; gradient values that are used to approximate the Hessian; see the scipy.optimize.fmin_l_bfgs_b documentation for description; of m argument. """""". def reset(self):; Optimizer.reset(self); self.id_text = 'LBFGSB'; self.max_metric_corr = 10; self.msg_level = None. [docs] def init_optim(self, term_conds):; """"""; Check optimiser attribute status and passed parameters before; running the optimisation.; This is called by run_optimization, but could called independently; to check the configuration.; """"""; if term_conds is None:; term_conds = self.termination_conditions. # AJGP 2015-04-21:; # These (copying from config) are here for backward compatibility; if hasattr(self.config, 'max_metric_corr'):; if self.config.max_metric_corr:; self.max_metric_corr = self.config.max_metric_corr; if hasattr(self.config, 'accuracy_factor'):; if self.config.accuracy_factor:; term_conds.accuracy_factor = \; self.config.accuracy_factor. Optimizer.init_optim(self, term_conds). if not isinstance(self.msg_level, int):; if self.log_level < logging.DEBUG:; self.msg_level = 2; elif self.log_level <= logging.DEBUG:; self.msg_level = 1; else:; self.msg_level = 0. [docs] def run_optimization(self, term_conds=None):; """"""; Optimise the control pulse amplitudes to minimise the fidelity error; using the L-BFGS-B algorithm, which is the constrained; (bounded amplitude values), limited memory, version of the; BroydenâFletcherâGoldfarbâShanno algorithm. The optimisation end when one of the passed termination conditions; has been met, e.g. target achieved, gradient minimum met; (local minima), wall time / iteration count exceeded. Essentially this is wrapper to the:; scipy.optimize.fmin_l_bfgs_b function; This in turn is a war",MatchSource.WIKI,docs/4.2/modules/qutip/control/optimizer.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/control/optimizer.html
https://qutip.org/docs/4.2/modules/qutip/control/optimizer.html:29024,Modifiability,config,config,29024,"ts the run_optimization method using the L-BFGS-B algorithm. Attributes; ----------; max_metric_corr : integer; The maximum number of variable metric corrections used to define; the limited memory matrix. That is the number of previous; gradient values that are used to approximate the Hessian; see the scipy.optimize.fmin_l_bfgs_b documentation for description; of m argument. """""". def reset(self):; Optimizer.reset(self); self.id_text = 'LBFGSB'; self.max_metric_corr = 10; self.msg_level = None. [docs] def init_optim(self, term_conds):; """"""; Check optimiser attribute status and passed parameters before; running the optimisation.; This is called by run_optimization, but could called independently; to check the configuration.; """"""; if term_conds is None:; term_conds = self.termination_conditions. # AJGP 2015-04-21:; # These (copying from config) are here for backward compatibility; if hasattr(self.config, 'max_metric_corr'):; if self.config.max_metric_corr:; self.max_metric_corr = self.config.max_metric_corr; if hasattr(self.config, 'accuracy_factor'):; if self.config.accuracy_factor:; term_conds.accuracy_factor = \; self.config.accuracy_factor. Optimizer.init_optim(self, term_conds). if not isinstance(self.msg_level, int):; if self.log_level < logging.DEBUG:; self.msg_level = 2; elif self.log_level <= logging.DEBUG:; self.msg_level = 1; else:; self.msg_level = 0. [docs] def run_optimization(self, term_conds=None):; """"""; Optimise the control pulse amplitudes to minimise the fidelity error; using the L-BFGS-B algorithm, which is the constrained; (bounded amplitude values), limited memory, version of the; BroydenâFletcherâGoldfarbâShanno algorithm. The optimisation end when one of the passed termination conditions; has been met, e.g. target achieved, gradient minimum met; (local minima), wall time / iteration count exceeded. Essentially this is wrapper to the:; scipy.optimize.fmin_l_bfgs_b function; This in turn is a warpper for well established implementation of; the L-BF",MatchSource.WIKI,docs/4.2/modules/qutip/control/optimizer.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/control/optimizer.html
https://qutip.org/docs/4.2/modules/qutip/control/optimizer.html:29064,Modifiability,config,config,29064,"ithm. Attributes; ----------; max_metric_corr : integer; The maximum number of variable metric corrections used to define; the limited memory matrix. That is the number of previous; gradient values that are used to approximate the Hessian; see the scipy.optimize.fmin_l_bfgs_b documentation for description; of m argument. """""". def reset(self):; Optimizer.reset(self); self.id_text = 'LBFGSB'; self.max_metric_corr = 10; self.msg_level = None. [docs] def init_optim(self, term_conds):; """"""; Check optimiser attribute status and passed parameters before; running the optimisation.; This is called by run_optimization, but could called independently; to check the configuration.; """"""; if term_conds is None:; term_conds = self.termination_conditions. # AJGP 2015-04-21:; # These (copying from config) are here for backward compatibility; if hasattr(self.config, 'max_metric_corr'):; if self.config.max_metric_corr:; self.max_metric_corr = self.config.max_metric_corr; if hasattr(self.config, 'accuracy_factor'):; if self.config.accuracy_factor:; term_conds.accuracy_factor = \; self.config.accuracy_factor. Optimizer.init_optim(self, term_conds). if not isinstance(self.msg_level, int):; if self.log_level < logging.DEBUG:; self.msg_level = 2; elif self.log_level <= logging.DEBUG:; self.msg_level = 1; else:; self.msg_level = 0. [docs] def run_optimization(self, term_conds=None):; """"""; Optimise the control pulse amplitudes to minimise the fidelity error; using the L-BFGS-B algorithm, which is the constrained; (bounded amplitude values), limited memory, version of the; BroydenâFletcherâGoldfarbâShanno algorithm. The optimisation end when one of the passed termination conditions; has been met, e.g. target achieved, gradient minimum met; (local minima), wall time / iteration count exceeded. Essentially this is wrapper to the:; scipy.optimize.fmin_l_bfgs_b function; This in turn is a warpper for well established implementation of; the L-BFGS-B algorithm written in Fortran, which is therefore; ",MatchSource.WIKI,docs/4.2/modules/qutip/control/optimizer.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/control/optimizer.html
https://qutip.org/docs/4.2/modules/qutip/control/optimizer.html:29101,Modifiability,config,config,29101,"------; max_metric_corr : integer; The maximum number of variable metric corrections used to define; the limited memory matrix. That is the number of previous; gradient values that are used to approximate the Hessian; see the scipy.optimize.fmin_l_bfgs_b documentation for description; of m argument. """""". def reset(self):; Optimizer.reset(self); self.id_text = 'LBFGSB'; self.max_metric_corr = 10; self.msg_level = None. [docs] def init_optim(self, term_conds):; """"""; Check optimiser attribute status and passed parameters before; running the optimisation.; This is called by run_optimization, but could called independently; to check the configuration.; """"""; if term_conds is None:; term_conds = self.termination_conditions. # AJGP 2015-04-21:; # These (copying from config) are here for backward compatibility; if hasattr(self.config, 'max_metric_corr'):; if self.config.max_metric_corr:; self.max_metric_corr = self.config.max_metric_corr; if hasattr(self.config, 'accuracy_factor'):; if self.config.accuracy_factor:; term_conds.accuracy_factor = \; self.config.accuracy_factor. Optimizer.init_optim(self, term_conds). if not isinstance(self.msg_level, int):; if self.log_level < logging.DEBUG:; self.msg_level = 2; elif self.log_level <= logging.DEBUG:; self.msg_level = 1; else:; self.msg_level = 0. [docs] def run_optimization(self, term_conds=None):; """"""; Optimise the control pulse amplitudes to minimise the fidelity error; using the L-BFGS-B algorithm, which is the constrained; (bounded amplitude values), limited memory, version of the; BroydenâFletcherâGoldfarbâShanno algorithm. The optimisation end when one of the passed termination conditions; has been met, e.g. target achieved, gradient minimum met; (local minima), wall time / iteration count exceeded. Essentially this is wrapper to the:; scipy.optimize.fmin_l_bfgs_b function; This in turn is a warpper for well established implementation of; the L-BFGS-B algorithm written in Fortran, which is therefore; very fast. See SciPy d",MatchSource.WIKI,docs/4.2/modules/qutip/control/optimizer.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/control/optimizer.html
https://qutip.org/docs/4.2/modules/qutip/control/optimizer.html:29163,Modifiability,config,config,29163,"ble metric corrections used to define; the limited memory matrix. That is the number of previous; gradient values that are used to approximate the Hessian; see the scipy.optimize.fmin_l_bfgs_b documentation for description; of m argument. """""". def reset(self):; Optimizer.reset(self); self.id_text = 'LBFGSB'; self.max_metric_corr = 10; self.msg_level = None. [docs] def init_optim(self, term_conds):; """"""; Check optimiser attribute status and passed parameters before; running the optimisation.; This is called by run_optimization, but could called independently; to check the configuration.; """"""; if term_conds is None:; term_conds = self.termination_conditions. # AJGP 2015-04-21:; # These (copying from config) are here for backward compatibility; if hasattr(self.config, 'max_metric_corr'):; if self.config.max_metric_corr:; self.max_metric_corr = self.config.max_metric_corr; if hasattr(self.config, 'accuracy_factor'):; if self.config.accuracy_factor:; term_conds.accuracy_factor = \; self.config.accuracy_factor. Optimizer.init_optim(self, term_conds). if not isinstance(self.msg_level, int):; if self.log_level < logging.DEBUG:; self.msg_level = 2; elif self.log_level <= logging.DEBUG:; self.msg_level = 1; else:; self.msg_level = 0. [docs] def run_optimization(self, term_conds=None):; """"""; Optimise the control pulse amplitudes to minimise the fidelity error; using the L-BFGS-B algorithm, which is the constrained; (bounded amplitude values), limited memory, version of the; BroydenâFletcherâGoldfarbâShanno algorithm. The optimisation end when one of the passed termination conditions; has been met, e.g. target achieved, gradient minimum met; (local minima), wall time / iteration count exceeded. Essentially this is wrapper to the:; scipy.optimize.fmin_l_bfgs_b function; This in turn is a warpper for well established implementation of; the L-BFGS-B algorithm written in Fortran, which is therefore; very fast. See SciPy documentation for credit and details on; this function. If the ",MatchSource.WIKI,docs/4.2/modules/qutip/control/optimizer.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/control/optimizer.html
https://qutip.org/docs/4.2/modules/qutip/control/optimizer.html:30551,Modifiability,config,config,30551,"algorithm, which is the constrained; (bounded amplitude values), limited memory, version of the; BroydenâFletcherâGoldfarbâShanno algorithm. The optimisation end when one of the passed termination conditions; has been met, e.g. target achieved, gradient minimum met; (local minima), wall time / iteration count exceeded. Essentially this is wrapper to the:; scipy.optimize.fmin_l_bfgs_b function; This in turn is a warpper for well established implementation of; the L-BFGS-B algorithm written in Fortran, which is therefore; very fast. See SciPy documentation for credit and details on; this function. If the parameter term_conds=None, then the termination_conditions; attribute must already be set. It will be overwritten if the; parameter is not None. The result is returned in an OptimResult object, which includes; the final fidelity, time evolution, reason for termination etc; ; """"""; self.init_optim(term_conds); term_conds = self.termination_conditions; dyn = self.dynamics; cfg = self.config; self.optim_var_vals = self._get_optim_var_vals(); self._build_method_options(). st_time = timeit.default_timer(); self.wall_time_optimize_start = st_time. if self.stats is not None:; self.stats.wall_time_optim_start = st_time; self.stats.wall_time_optim_end = 0.0; self.stats.num_iter = 1. bounds = self._build_bounds_list(); result = self._create_result(). if self.approx_grad:; fprime = None; else:; fprime = self.fid_err_grad_wrapper. if 'accuracy_factor' in self.method_options:; factr = self.method_options['accuracy_factor']; elif 'ftol' in self.method_options:; factr = self.method_options['ftol']; elif hasattr(term_conds, 'accuracy_factor'):; factr = term_conds.accuracy_factor; else:; factr = 1e7. if 'max_metric_corr' in self.method_options:; m = self.method_options['max_metric_corr']; elif 'maxcor' in self.method_options:; m = self.method_options['maxcor']; elif hasattr(self, 'max_metric_corr'):; m = self.max_metric_corr; else:; m = 10. if self.log_level <= logging.INFO:; msg = (""Op",MatchSource.WIKI,docs/4.2/modules/qutip/control/optimizer.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/control/optimizer.html
https://qutip.org/docs/4.2/modules/qutip/control/optimizer.html:33405,Modifiability,config,configuration,33405,"elity ""; ""function call limit reached""); elif warn == 2:; result.termination_reason = res_dict['task']. result.num_iter = res_dict['nit']; except errors.OptimizationTerminate as except_term:; self._interpret_term_exception(except_term, result). end_time = timeit.default_timer(); self._add_common_result_attribs(result, st_time, end_time). return result. [docs]class OptimizerCrab(Optimizer):; """"""; Optimises the pulse using the CRAB algorithm [1].; It uses the scipy.optimize.minimize function with the method specified; by the optim_method attribute. See Optimizer.run_optimization for details; It minimises the fidelity error function with respect to the CRAB; basis function coefficients. AJGP ToDo: Add citation here; """""". def reset(self):; Optimizer.reset(self); self.id_text = 'CRAB'; self.num_optim_vars = 0. [docs] def init_optim(self, term_conds):; """"""; Check optimiser attribute status and passed parameters before; running the optimisation.; This is called by run_optimization, but could called independently; to check the configuration.; """"""; Optimizer.init_optim(self, term_conds); dyn = self.dynamics. self.num_optim_vars = 0; pulse_gen_valid = True; # check the pulse generators match the ctrls; # (in terms of number); # and count the number of parameters; if self.pulse_generator is None:; pulse_gen_valid = False; err_msg = ""pulse_generator attribute is None""; elif not isinstance(self.pulse_generator, collections.Iterable):; pulse_gen_valid = False; err_msg = ""pulse_generator is not iterable"". elif len(self.pulse_generator) != dyn.num_ctrls:; pulse_gen_valid = False; err_msg = (""the number of pulse generators {} does not equal ""; ""the number of controls {}"".format(; len(self.pulse_generator), dyn.num_ctrls)). if pulse_gen_valid:; for p_gen in self.pulse_generator:; if not isinstance(p_gen, pulsegen.PulseGenCrab):; pulse_gen_valid = False; err_msg = (; ""pulse_generator contained object of type '{}'"".format(; p_gen.__class__.__name__)); break; self.num_optim_vars += p_gen",MatchSource.WIKI,docs/4.2/modules/qutip/control/optimizer.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/control/optimizer.html
https://qutip.org/docs/4.2/modules/qutip/control/optimizer.html:34871,Modifiability,variab,variable,34871,") != dyn.num_ctrls:; pulse_gen_valid = False; err_msg = (""the number of pulse generators {} does not equal ""; ""the number of controls {}"".format(; len(self.pulse_generator), dyn.num_ctrls)). if pulse_gen_valid:; for p_gen in self.pulse_generator:; if not isinstance(p_gen, pulsegen.PulseGenCrab):; pulse_gen_valid = False; err_msg = (; ""pulse_generator contained object of type '{}'"".format(; p_gen.__class__.__name__)); break; self.num_optim_vars += p_gen.num_optim_vars. if not pulse_gen_valid:; raise errors.UsageError(; ""The pulse_generator attribute must be set to a list of ""; ""PulseGenCrab - one for each control. Here "" + err_msg). def _build_bounds_list(self):; """"""; No bounds necessary here, as the bounds for the CRAB parameters; do not have much physical meaning.; This needs to override the default method, otherwise the shape; will be wrong; """"""; return None. def _get_optim_var_vals(self):; """"""; Generate the 1d array that holds the current variable values; of the function to be optimised; For CRAB these are the basis coefficients; ; Returns; -------; ndarray (1d) of float; ; """"""; pvals = []; for pgen in self.pulse_generator:; pvals.extend(pgen.get_optim_var_vals()). return np.array(pvals). def _get_ctrl_amps(self, optim_var_vals):; """"""; Get the control amplitudes from the current variable values; of the function to be optimised.; that is the 1d array that is passed from the optimisation method; For CRAB the amplitudes will need to calculated by expanding the; series. Returns; -------; float array[dynamics.num_tslots, dynamics.num_ctrls]; """"""; dyn = self.dynamics. if self.log_level <= logging.DEBUG:; changed_params = self.optim_var_vals != optim_var_vals; logger.debug(; ""{} out of {} optimisation parameters changed"".format(; changed_params.sum(), len(optim_var_vals))). amps = np.empty([dyn.num_tslots, dyn.num_ctrls]); j = 0; param_idx_st = 0; for p_gen in self.pulse_generator:; param_idx_end = param_idx_st + p_gen.num_optim_vars; pg_pvals = optim_var_vals[param_idx_",MatchSource.WIKI,docs/4.2/modules/qutip/control/optimizer.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/control/optimizer.html
https://qutip.org/docs/4.2/modules/qutip/control/optimizer.html:35067,Modifiability,extend,extend,35067,"lse_generator), dyn.num_ctrls)). if pulse_gen_valid:; for p_gen in self.pulse_generator:; if not isinstance(p_gen, pulsegen.PulseGenCrab):; pulse_gen_valid = False; err_msg = (; ""pulse_generator contained object of type '{}'"".format(; p_gen.__class__.__name__)); break; self.num_optim_vars += p_gen.num_optim_vars. if not pulse_gen_valid:; raise errors.UsageError(; ""The pulse_generator attribute must be set to a list of ""; ""PulseGenCrab - one for each control. Here "" + err_msg). def _build_bounds_list(self):; """"""; No bounds necessary here, as the bounds for the CRAB parameters; do not have much physical meaning.; This needs to override the default method, otherwise the shape; will be wrong; """"""; return None. def _get_optim_var_vals(self):; """"""; Generate the 1d array that holds the current variable values; of the function to be optimised; For CRAB these are the basis coefficients; ; Returns; -------; ndarray (1d) of float; ; """"""; pvals = []; for pgen in self.pulse_generator:; pvals.extend(pgen.get_optim_var_vals()). return np.array(pvals). def _get_ctrl_amps(self, optim_var_vals):; """"""; Get the control amplitudes from the current variable values; of the function to be optimised.; that is the 1d array that is passed from the optimisation method; For CRAB the amplitudes will need to calculated by expanding the; series. Returns; -------; float array[dynamics.num_tslots, dynamics.num_ctrls]; """"""; dyn = self.dynamics. if self.log_level <= logging.DEBUG:; changed_params = self.optim_var_vals != optim_var_vals; logger.debug(; ""{} out of {} optimisation parameters changed"".format(; changed_params.sum(), len(optim_var_vals))). amps = np.empty([dyn.num_tslots, dyn.num_ctrls]); j = 0; param_idx_st = 0; for p_gen in self.pulse_generator:; param_idx_end = param_idx_st + p_gen.num_optim_vars; pg_pvals = optim_var_vals[param_idx_st:param_idx_end]; p_gen.set_optim_var_vals(pg_pvals); amps[:, j] = p_gen.gen_pulse(); param_idx_st = param_idx_end; j += 1. #print(""param_idx_end={}"".format",MatchSource.WIKI,docs/4.2/modules/qutip/control/optimizer.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/control/optimizer.html
https://qutip.org/docs/4.2/modules/qutip/control/optimizer.html:35218,Modifiability,variab,variable,35218,".PulseGenCrab):; pulse_gen_valid = False; err_msg = (; ""pulse_generator contained object of type '{}'"".format(; p_gen.__class__.__name__)); break; self.num_optim_vars += p_gen.num_optim_vars. if not pulse_gen_valid:; raise errors.UsageError(; ""The pulse_generator attribute must be set to a list of ""; ""PulseGenCrab - one for each control. Here "" + err_msg). def _build_bounds_list(self):; """"""; No bounds necessary here, as the bounds for the CRAB parameters; do not have much physical meaning.; This needs to override the default method, otherwise the shape; will be wrong; """"""; return None. def _get_optim_var_vals(self):; """"""; Generate the 1d array that holds the current variable values; of the function to be optimised; For CRAB these are the basis coefficients; ; Returns; -------; ndarray (1d) of float; ; """"""; pvals = []; for pgen in self.pulse_generator:; pvals.extend(pgen.get_optim_var_vals()). return np.array(pvals). def _get_ctrl_amps(self, optim_var_vals):; """"""; Get the control amplitudes from the current variable values; of the function to be optimised.; that is the 1d array that is passed from the optimisation method; For CRAB the amplitudes will need to calculated by expanding the; series. Returns; -------; float array[dynamics.num_tslots, dynamics.num_ctrls]; """"""; dyn = self.dynamics. if self.log_level <= logging.DEBUG:; changed_params = self.optim_var_vals != optim_var_vals; logger.debug(; ""{} out of {} optimisation parameters changed"".format(; changed_params.sum(), len(optim_var_vals))). amps = np.empty([dyn.num_tslots, dyn.num_ctrls]); j = 0; param_idx_st = 0; for p_gen in self.pulse_generator:; param_idx_end = param_idx_st + p_gen.num_optim_vars; pg_pvals = optim_var_vals[param_idx_st:param_idx_end]; p_gen.set_optim_var_vals(pg_pvals); amps[:, j] = p_gen.gen_pulse(); param_idx_st = param_idx_end; j += 1. #print(""param_idx_end={}"".format(param_idx_end)); self.optim_var_vals = optim_var_vals; return amps. [docs]class OptimizerCrabFmin(OptimizerCrab):; """"""; Op",MatchSource.WIKI,docs/4.2/modules/qutip/control/optimizer.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/control/optimizer.html
https://qutip.org/docs/4.2/modules/qutip/control/optimizer.html:37812,Modifiability,config,config,37812,"None):; """"""; This function optimisation method is a wrapper to the; scipy.optimize.fmin function. It will attempt to minimise the fidelity error with respect to some; parameters, which are determined by _get_optim_var_vals which; in the case of CRAB are the basis function coefficients. The optimisation end when one of the passed termination conditions; has been met, e.g. target achieved, wall time, or; function call or iteration count exceeded. Specifically to the fmin; method, the optimisation will stop when change parameter values; is less than xtol or the change in function value is below ftol. If the parameter term_conds=None, then the termination_conditions; attribute must already be set. It will be overwritten if the; parameter is not None. The result is returned in an OptimResult object, which includes; the final fidelity, time evolution, reason for termination etc; """"""; self.init_optim(term_conds); term_conds = self.termination_conditions; dyn = self.dynamics; cfg = self.config; self.optim_var_vals = self._get_optim_var_vals(); self._build_method_options(). #print(""Initial values:\n{}"".format(self.optim_var_vals)); st_time = timeit.default_timer(); self.wall_time_optimize_start = st_time. if self.stats is not None:; self.stats.wall_time_optim_start = st_time; self.stats.wall_time_optim_end = 0.0; self.stats.num_iter = 1. result = self._create_result(). if self.log_level <= logging.INFO:; logger.info(""Optimising pulse(s) using {} with ""; ""'fmin' (Nelder-Mead) method"".format(self.alg)). try:; ret = spopt.fmin(; self.fid_err_func_wrapper, self.optim_var_vals,; xtol=self.xtol, ftol=self.ftol,; maxiter=term_conds.max_iterations,; maxfun=term_conds.max_fid_func_calls,; full_output=True, disp=self.disp_conv_msg,; retall=self.record_iteration_steps,; callback=self.iter_step_callback_func). final_param_vals = ret[0]; num_iter = ret[2]; warn_flag = ret[4]; if self.record_iteration_steps:; self.iteration_steps = ret[5]; amps = self._get_ctrl_amps(final_param_vals); dyn.",MatchSource.WIKI,docs/4.2/modules/qutip/control/optimizer.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/control/optimizer.html
https://qutip.org/docs/4.2/modules/qutip/control/optimizer.html:18,Performance,optimiz,optimizer,18,". . qutip.control.optimizer â QuTiP 4.2 Documentation. QuTiP: Quantum Toolbox in Python; . ; . 4.2; . Frontmatter; Installation; Users Guide; API documentation; Change Log; Developers; Bibliography. QuTiP: Quantum Toolbox in Python. Docs Â»; Module code Â»; qutip.control.optimizer. Source code for qutip.control.optimizer; # -*- coding: utf-8 -*-; # This file is part of QuTiP: Quantum Toolbox in Python.; #; # Copyright (c) 2014 and later, Alexander J G Pitchford; # All rights reserved.; #; # Redistribution and use in source and binary forms, with or without; # modification, are permitted provided that the following conditions are; # met:; #; # 1. Redistributions of source code must retain the above copyright notice,; # this list of conditions and the following disclaimer.; #; # 2. Redistributions in binary form must reproduce the above copyright; # notice, this list of conditions and the following disclaimer in the; # documentation and/or other materials provided with the distribution.; #; # 3. Neither the name of the QuTiP: Quantum Toolbox in Python nor the names; # of its contributors may be used to endorse or promote products derived; # from this software without specific prior written permission.; #; # THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS; # ""AS IS"" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT; # LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A; # PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT; # HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,; # SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT; # LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,; # DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY; # THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT; # (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE; # OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH ",MatchSource.WIKI,docs/4.2/modules/qutip/control/optimizer.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/control/optimizer.html
https://qutip.org/docs/4.2/modules/qutip/control/optimizer.html:270,Performance,optimiz,optimizer,270,". . qutip.control.optimizer â QuTiP 4.2 Documentation. QuTiP: Quantum Toolbox in Python; . ; . 4.2; . Frontmatter; Installation; Users Guide; API documentation; Change Log; Developers; Bibliography. QuTiP: Quantum Toolbox in Python. Docs Â»; Module code Â»; qutip.control.optimizer. Source code for qutip.control.optimizer; # -*- coding: utf-8 -*-; # This file is part of QuTiP: Quantum Toolbox in Python.; #; # Copyright (c) 2014 and later, Alexander J G Pitchford; # All rights reserved.; #; # Redistribution and use in source and binary forms, with or without; # modification, are permitted provided that the following conditions are; # met:; #; # 1. Redistributions of source code must retain the above copyright notice,; # this list of conditions and the following disclaimer.; #; # 2. Redistributions in binary form must reproduce the above copyright; # notice, this list of conditions and the following disclaimer in the; # documentation and/or other materials provided with the distribution.; #; # 3. Neither the name of the QuTiP: Quantum Toolbox in Python nor the names; # of its contributors may be used to endorse or promote products derived; # from this software without specific prior written permission.; #; # THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS; # ""AS IS"" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT; # LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A; # PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT; # HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,; # SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT; # LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,; # DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY; # THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT; # (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE; # OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH ",MatchSource.WIKI,docs/4.2/modules/qutip/control/optimizer.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/control/optimizer.html
https://qutip.org/docs/4.2/modules/qutip/control/optimizer.html:311,Performance,optimiz,optimizer,311,". . qutip.control.optimizer â QuTiP 4.2 Documentation. QuTiP: Quantum Toolbox in Python; . ; . 4.2; . Frontmatter; Installation; Users Guide; API documentation; Change Log; Developers; Bibliography. QuTiP: Quantum Toolbox in Python. Docs Â»; Module code Â»; qutip.control.optimizer. Source code for qutip.control.optimizer; # -*- coding: utf-8 -*-; # This file is part of QuTiP: Quantum Toolbox in Python.; #; # Copyright (c) 2014 and later, Alexander J G Pitchford; # All rights reserved.; #; # Redistribution and use in source and binary forms, with or without; # modification, are permitted provided that the following conditions are; # met:; #; # 1. Redistributions of source code must retain the above copyright notice,; # this list of conditions and the following disclaimer.; #; # 2. Redistributions in binary form must reproduce the above copyright; # notice, this list of conditions and the following disclaimer in the; # documentation and/or other materials provided with the distribution.; #; # 3. Neither the name of the QuTiP: Quantum Toolbox in Python nor the names; # of its contributors may be used to endorse or promote products derived; # from this software without specific prior written permission.; #; # THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS; # ""AS IS"" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT; # LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A; # PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT; # HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,; # SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT; # LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,; # DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY; # THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT; # (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE; # OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH ",MatchSource.WIKI,docs/4.2/modules/qutip/control/optimizer.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/control/optimizer.html
https://qutip.org/docs/4.2/modules/qutip/control/optimizer.html:3203,Performance,optimiz,optimize,3203,"s here are expected to implement a run_optimization function; that will use some method for optimising the control pulse, as defined; by the control amplitudes. The system that the pulse acts upon are defined; by the Dynamics object that must be passed in the instantiation. The methods are typically N dimensional function optimisers that; find the minima of a fidelity error function. Note the number of variables; for the fidelity function is the number of control timeslots,; i.e. n_ctrls x Ntimeslots; The methods will call functions on the Dynamics.fid_computer object,; one or many times per interation,; to get the fidelity error and gradient wrt to the amplitudes.; The optimisation will stop when one of the termination conditions are met,; for example: the fidelity aim has be reached, a local minima has been found,; the maximum time allowed has been exceeded. These function optimisation methods are so far from SciPy.optimize; The two methods implemented are:; ; BFGS - BroydenâFletcherâGoldfarbâShanno algorithm; ; This a quasi second order Newton method. It uses successive calls to; the gradient function to make an estimation of the curvature (Hessian); and hence direct its search for the function minima; The SciPy implementation is pure Python and hance is execution speed is; not high; use subclass: OptimizerBFGS. L-BFGS-B - Bounded, limited memory BFGS; ; This a version of the BFGS method where the Hessian approximation is; only based on a set of the most recent gradient calls. It generally; performs better where the are a large number of variables; The SciPy implementation of L-BFGS-B is wrapper around a well; established and actively maintained implementation in Fortran; Its is therefore very fast.; # See SciPy documentation for credit and details on the; # scipy.optimize.fmin_l_bfgs_b function; use subclass: OptimizerLBFGSB. The baseclass Optimizer implements the function wrappers to the; fidelity error, gradient, and iteration callback functions.; These are cal",MatchSource.WIKI,docs/4.2/modules/qutip/control/optimizer.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/control/optimizer.html
https://qutip.org/docs/4.2/modules/qutip/control/optimizer.html:3791,Performance,perform,performs,3791,"t the fidelity error and gradient wrt to the amplitudes.; The optimisation will stop when one of the termination conditions are met,; for example: the fidelity aim has be reached, a local minima has been found,; the maximum time allowed has been exceeded. These function optimisation methods are so far from SciPy.optimize; The two methods implemented are:; ; BFGS - BroydenâFletcherâGoldfarbâShanno algorithm; ; This a quasi second order Newton method. It uses successive calls to; the gradient function to make an estimation of the curvature (Hessian); and hence direct its search for the function minima; The SciPy implementation is pure Python and hance is execution speed is; not high; use subclass: OptimizerBFGS. L-BFGS-B - Bounded, limited memory BFGS; ; This a version of the BFGS method where the Hessian approximation is; only based on a set of the most recent gradient calls. It generally; performs better where the are a large number of variables; The SciPy implementation of L-BFGS-B is wrapper around a well; established and actively maintained implementation in Fortran; Its is therefore very fast.; # See SciPy documentation for credit and details on the; # scipy.optimize.fmin_l_bfgs_b function; use subclass: OptimizerLBFGSB. The baseclass Optimizer implements the function wrappers to the; fidelity error, gradient, and iteration callback functions.; These are called from the within the SciPy optimisation functions.; The subclasses implement the algorithm specific pulse optimisation function.; """""". import os; import numpy as np; import timeit; import scipy.optimize as spopt; import copy; import collections; # QuTiP; from qutip import Qobj; import qutip.logging_utils as logging; logger = logging.get_logger(); # QuTiP control modules; import qutip.control.optimresult as optimresult; import qutip.control.termcond as termcond; import qutip.control.errors as errors; import qutip.control.dynamics as dynamics; import qutip.control.pulsegen as pulsegen; import qutip.control.du",MatchSource.WIKI,docs/4.2/modules/qutip/control/optimizer.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/control/optimizer.html
https://qutip.org/docs/4.2/modules/qutip/control/optimizer.html:4070,Performance,optimiz,optimize,4070,"al minima has been found,; the maximum time allowed has been exceeded. These function optimisation methods are so far from SciPy.optimize; The two methods implemented are:; ; BFGS - BroydenâFletcherâGoldfarbâShanno algorithm; ; This a quasi second order Newton method. It uses successive calls to; the gradient function to make an estimation of the curvature (Hessian); and hence direct its search for the function minima; The SciPy implementation is pure Python and hance is execution speed is; not high; use subclass: OptimizerBFGS. L-BFGS-B - Bounded, limited memory BFGS; ; This a version of the BFGS method where the Hessian approximation is; only based on a set of the most recent gradient calls. It generally; performs better where the are a large number of variables; The SciPy implementation of L-BFGS-B is wrapper around a well; established and actively maintained implementation in Fortran; Its is therefore very fast.; # See SciPy documentation for credit and details on the; # scipy.optimize.fmin_l_bfgs_b function; use subclass: OptimizerLBFGSB. The baseclass Optimizer implements the function wrappers to the; fidelity error, gradient, and iteration callback functions.; These are called from the within the SciPy optimisation functions.; The subclasses implement the algorithm specific pulse optimisation function.; """""". import os; import numpy as np; import timeit; import scipy.optimize as spopt; import copy; import collections; # QuTiP; from qutip import Qobj; import qutip.logging_utils as logging; logger = logging.get_logger(); # QuTiP control modules; import qutip.control.optimresult as optimresult; import qutip.control.termcond as termcond; import qutip.control.errors as errors; import qutip.control.dynamics as dynamics; import qutip.control.pulsegen as pulsegen; import qutip.control.dump as qtrldump. def _is_string(var):; try:; if isinstance(var, basestring):; return True; except NameError:; try:; if isinstance(var, str):; return True; except:; return False; except:;",MatchSource.WIKI,docs/4.2/modules/qutip/control/optimizer.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/control/optimizer.html
https://qutip.org/docs/4.2/modules/qutip/control/optimizer.html:4470,Performance,optimiz,optimize,4470,"on is pure Python and hance is execution speed is; not high; use subclass: OptimizerBFGS. L-BFGS-B - Bounded, limited memory BFGS; ; This a version of the BFGS method where the Hessian approximation is; only based on a set of the most recent gradient calls. It generally; performs better where the are a large number of variables; The SciPy implementation of L-BFGS-B is wrapper around a well; established and actively maintained implementation in Fortran; Its is therefore very fast.; # See SciPy documentation for credit and details on the; # scipy.optimize.fmin_l_bfgs_b function; use subclass: OptimizerLBFGSB. The baseclass Optimizer implements the function wrappers to the; fidelity error, gradient, and iteration callback functions.; These are called from the within the SciPy optimisation functions.; The subclasses implement the algorithm specific pulse optimisation function.; """""". import os; import numpy as np; import timeit; import scipy.optimize as spopt; import copy; import collections; # QuTiP; from qutip import Qobj; import qutip.logging_utils as logging; logger = logging.get_logger(); # QuTiP control modules; import qutip.control.optimresult as optimresult; import qutip.control.termcond as termcond; import qutip.control.errors as errors; import qutip.control.dynamics as dynamics; import qutip.control.pulsegen as pulsegen; import qutip.control.dump as qtrldump. def _is_string(var):; try:; if isinstance(var, basestring):; return True; except NameError:; try:; if isinstance(var, str):; return True; except:; return False; except:; return False. return False. [docs]class Optimizer(object):; """"""; Base class for all control pulse optimisers. This class should not be; instantiated, use its subclasses; This class implements the fidelity, gradient and interation callback; functions.; All subclass objects must be initialised with a; ; OptimConfig instance - various configuration options; Dynamics instance - describes the dynamics of the (quantum) system; to be control opti",MatchSource.WIKI,docs/4.2/modules/qutip/control/optimizer.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/control/optimizer.html
https://qutip.org/docs/4.2/modules/qutip/control/optimizer.html:6481,Performance,optimiz,optimize,6481,"uantum) system; to be control optimised. Attributes; ----------; log_level : integer; level of messaging output from the logger.; Options are attributes of qutip.logging_utils,; in decreasing levels of messaging, are:; DEBUG_INTENSE, DEBUG_VERBOSE, DEBUG, INFO, WARN, ERROR, CRITICAL; Anything WARN or above is effectively 'quiet' execution,; assuming everything runs as expected.; The default NOTSET implies that the level will be taken from; the QuTiP settings file, which by default is WARN. params: Dictionary; The key value pairs are the attribute name and value; Note: attributes are created if they do not exist already,; and are overwritten if they do. alg : string; Algorithm to use in pulse optimisation.; Options are:; 'GRAPE' (default) - GRadient Ascent Pulse Engineering; 'CRAB' - Chopped RAndom Basis. alg_params : Dictionary; options that are specific to the pulse optim algorithm; that is GRAPE or CRAB. disp_conv_msg : bool; Set true to display a convergence message; (for scipy.optimize.minimize methods anyway). optim_method : string; a scipy.optimize.minimize method that will be used to optimise; the pulse for minimum fidelity error. method_params : Dictionary; Options for the optim_method.; Note that where there is an equivalent attribute of this instance; or the termination_conditions (for example maxiter); it will override an value in these options. approx_grad : bool; If set True then the method will approximate the gradient itself; (if it has requirement and facility for this); This will mean that the fid_err_grad_wrapper will not get called; Note it should be left False when using the Dynamics; to calculate approximate gradients; Note it is set True automatically when the alg is CRAB. amp_lbound : float or list of floats; lower boundaries for the control amplitudes; Can be a scalar value applied to all controls; or a list of bounds for each control. amp_ubound : float or list of floats; upper boundaries for the control amplitudes; Can be a scalar value appl",MatchSource.WIKI,docs/4.2/modules/qutip/control/optimizer.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/control/optimizer.html
https://qutip.org/docs/4.2/modules/qutip/control/optimizer.html:6547,Performance,optimiz,optimize,6547,"og_level : integer; level of messaging output from the logger.; Options are attributes of qutip.logging_utils,; in decreasing levels of messaging, are:; DEBUG_INTENSE, DEBUG_VERBOSE, DEBUG, INFO, WARN, ERROR, CRITICAL; Anything WARN or above is effectively 'quiet' execution,; assuming everything runs as expected.; The default NOTSET implies that the level will be taken from; the QuTiP settings file, which by default is WARN. params: Dictionary; The key value pairs are the attribute name and value; Note: attributes are created if they do not exist already,; and are overwritten if they do. alg : string; Algorithm to use in pulse optimisation.; Options are:; 'GRAPE' (default) - GRadient Ascent Pulse Engineering; 'CRAB' - Chopped RAndom Basis. alg_params : Dictionary; options that are specific to the pulse optim algorithm; that is GRAPE or CRAB. disp_conv_msg : bool; Set true to display a convergence message; (for scipy.optimize.minimize methods anyway). optim_method : string; a scipy.optimize.minimize method that will be used to optimise; the pulse for minimum fidelity error. method_params : Dictionary; Options for the optim_method.; Note that where there is an equivalent attribute of this instance; or the termination_conditions (for example maxiter); it will override an value in these options. approx_grad : bool; If set True then the method will approximate the gradient itself; (if it has requirement and facility for this); This will mean that the fid_err_grad_wrapper will not get called; Note it should be left False when using the Dynamics; to calculate approximate gradients; Note it is set True automatically when the alg is CRAB. amp_lbound : float or list of floats; lower boundaries for the control amplitudes; Can be a scalar value applied to all controls; or a list of bounds for each control. amp_ubound : float or list of floats; upper boundaries for the control amplitudes; Can be a scalar value applied to all controls; or a list of bounds for each control. bounds ",MatchSource.WIKI,docs/4.2/modules/qutip/control/optimizer.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/control/optimizer.html
https://qutip.org/docs/4.2/modules/qutip/control/optimizer.html:8411,Performance,perform,performance,8411,"the control amplitudes; Can be a scalar value applied to all controls; or a list of bounds for each control. bounds : List of floats; Bounds for the parameters.; If not set before the run_optimization call then the list; is built automatically based on the amp_lbound and amp_ubound; attributes.; Setting this attribute directly allows specific bounds to be set; for individual parameters.; Note: Only some methods use bounds. dynamics : Dynamics (subclass instance); describes the dynamics of the (quantum) system to be control optimised; (see Dynamics classes for details). config : OptimConfig instance; various configuration options; (see OptimConfig for details). termination_conditions : TerminationCondition instance; attributes determine when the optimisation will end. pulse_generator : PulseGen (subclass instance); (can be) used to create initial pulses; not used by the class, but set by pulseoptim.create_pulse_optimizer. stats : Stats; attributes of which give performance stats for the optimisation; set to None to reduce overhead of calculating stats.; Note it is (usually) shared with the Dynamics instance. dump : :class:`dump.OptimDump`; Container for data dumped during the optimisation.; Can be set by specifying the dumping level or set directly.; Note this is mainly intended for user and a development debugging; but could be used for status information during a long optimisation. dumping : string; level of data dumping: NONE, SUMMARY, FULL or CUSTOM; See property docstring for details. dump_to_file : bool; If set True then data will be dumped to file during the optimisation; dumping will be set to SUMMARY during init_optim; if dump_to_file is True and dumping not set.; Default is False. dump_dir : string; Basically a link to dump.dump_dir. Exists so that it can be set through; optim_params.; If dump is None then will return None or will set dumping to SUMMARY; when setting a path. iter_summary : :class:`OptimIterSummary`; Summary of the most recent iteration.; Not",MatchSource.WIKI,docs/4.2/modules/qutip/control/optimizer.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/control/optimizer.html
https://qutip.org/docs/4.2/modules/qutip/control/optimizer.html:12749,Performance,optimiz,optimizer,12749,"umped; """"""; if self.dump is None:; lvl = 'NONE'; else:; lvl = self.dump.level. return lvl. @dumping.setter; def dumping(self, value):; if value is None:; self.dump = None; else:; if not _is_string(value):; raise TypeError(""Value must be string value""); lvl = value.upper(); if lvl == 'NONE':; self.dump = None; else:; if not isinstance(self.dump, qtrldump.OptimDump):; self.dump = qtrldump.OptimDump(self, level=lvl); else:; self.dump.level = lvl; @property; def dump_dir(self):; if self.dump:; return self.dump.dump_dir; else:; return None. @dump_dir.setter; def dump_dir(self, value):; if not self.dump:; self.dumping = 'SUMMARY'; self.dump.dump_dir = value. def _create_result(self):; """"""; create the result object; and set the initial_amps attribute as the current amplitudes; """"""; result = optimresult.OptimResult(); result.initial_fid_err = self.dynamics.fid_computer.get_fid_err(); result.initial_amps = self.dynamics.ctrl_amps.copy(); result.time = self.dynamics.time; result.optimizer = self; return result. [docs] def init_optim(self, term_conds):; """"""; Check optimiser attribute status and passed parameters before; running the optimisation.; This is called by run_optimization, but could called independently; to check the configuration.; """"""; if term_conds is not None:; self.termination_conditions = term_conds; term_conds = self.termination_conditions. if not isinstance(term_conds, termcond.TerminationConditions):; raise errors.UsageError(""No termination conditions for the ""; ""optimisation function""). if not isinstance(self.dynamics, dynamics.Dynamics):; raise errors.UsageError(""No dynamics object attribute set""); self.dynamics.check_ctrls_initialized(). self.apply_method_params(). if term_conds.fid_err_targ is None and term_conds.fid_goal is None:; raise errors.UsageError(""Either the goal or the fidelity ""; ""error tolerance must be set""). if term_conds.fid_err_targ is None:; term_conds.fid_err_targ = np.abs(1 - term_conds.fid_goal). if term_conds.fid_goal is None:; term_c",MatchSource.WIKI,docs/4.2/modules/qutip/control/optimizer.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/control/optimizer.html
https://qutip.org/docs/4.2/modules/qutip/control/optimizer.html:14410,Performance,optimiz,optimize,14410,"check_ctrls_initialized(). self.apply_method_params(). if term_conds.fid_err_targ is None and term_conds.fid_goal is None:; raise errors.UsageError(""Either the goal or the fidelity ""; ""error tolerance must be set""). if term_conds.fid_err_targ is None:; term_conds.fid_err_targ = np.abs(1 - term_conds.fid_goal). if term_conds.fid_goal is None:; term_conds.fid_goal = 1 - term_conds.fid_err_targ. if self.alg == 'CRAB':; self.approx_grad = True. if self.stats is not None:; self.stats.clear(). if self.dump_to_file:; if self.dump is None:; self.dumping = 'SUMMARY'; self.dump.write_to_file = True; self.dump.create_dump_dir(); logger.info(""Optimiser dump will be written to:\n{}"".format(; self.dump.dump_dir)). if self.dump:; self.iter_summary = OptimIterSummary(); else:; self.iter_summary = None. self.num_iter = 0; self.num_fid_func_calls = 0; self.num_grad_func_calls = 0; self.iteration_steps = None. def _build_method_options(self):; """"""; Creates the method_options dictionary for the scipy.optimize.minimize; function based on the attributes of this object and the; termination_conditions; It assumes that apply_method_params has already been run and; hence the method_options attribute may already contain items.; These values will NOT be overridden; """"""; tc = self.termination_conditions; if self.method_options is None:; self.method_options = {}; mo = self.method_options. if 'max_metric_corr' in mo and not 'maxcor' in mo:; mo['maxcor'] = mo['max_metric_corr']; elif hasattr(self, 'max_metric_corr') and not 'maxcor' in mo:; mo['maxcor'] = self.max_metric_corr; if 'accuracy_factor' in mo and not 'ftol' in mo:; mo['ftol'] = mo['accuracy_factor']; elif hasattr(tc, 'accuracy_factor') and not 'ftol' in mo:; mo['ftol'] = tc.accuracy_factor; if tc.max_iterations > 0 and not 'maxiter' in mo:; mo['maxiter'] = tc.max_iterations; if tc.max_fid_func_calls > 0 and not 'maxfev' in mo:; mo['maxfev'] = tc.max_fid_func_calls; if tc.min_gradient_norm > 0 and not 'gtol' in mo:; mo['gtol'] = tc.min_gr",MatchSource.WIKI,docs/4.2/modules/qutip/control/optimizer.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/control/optimizer.html
https://qutip.org/docs/4.2/modules/qutip/control/optimizer.html:15828,Performance,optimiz,optimize,15828,"maxcor' in mo:; mo['maxcor'] = mo['max_metric_corr']; elif hasattr(self, 'max_metric_corr') and not 'maxcor' in mo:; mo['maxcor'] = self.max_metric_corr; if 'accuracy_factor' in mo and not 'ftol' in mo:; mo['ftol'] = mo['accuracy_factor']; elif hasattr(tc, 'accuracy_factor') and not 'ftol' in mo:; mo['ftol'] = tc.accuracy_factor; if tc.max_iterations > 0 and not 'maxiter' in mo:; mo['maxiter'] = tc.max_iterations; if tc.max_fid_func_calls > 0 and not 'maxfev' in mo:; mo['maxfev'] = tc.max_fid_func_calls; if tc.min_gradient_norm > 0 and not 'gtol' in mo:; mo['gtol'] = tc.min_gradient_norm; if not 'disp' in mo:; mo['disp'] = self.disp_conv_msg. return mo. [docs] def apply_method_params(self, params=None):; """"""; Loops through all the method_params; (either passed here or the method_params attribute); If the name matches an attribute of this object or the; termination conditions object, then the value of this attribute; is set. Otherwise it is assumed to a method_option for the; scipy.optimize.minimize function; """"""; if not params:; params = self.method_params. if isinstance(params, dict):; self.method_params = params; unused_params = {}; for key in params:; val = params[key]; if hasattr(self, key):; setattr(self, key, val); if hasattr(self.termination_conditions, key):; setattr(self.termination_conditions, key, val); else:; unused_params[key] = val. if len(unused_params) > 0:; if not isinstance(self.method_options, dict):; self.method_options = unused_params; else:; self.method_options.update(unused_params). def _build_bounds_list(self):; cfg = self.config; dyn = self.dynamics; n_ctrls = dyn.num_ctrls; self.bounds = []; for t in range(dyn.num_tslots):; for c in range(n_ctrls):; if isinstance(self.amp_lbound, list):; lb = self.amp_lbound[c]; else:; lb = self.amp_lbound; if isinstance(self.amp_ubound, list):; ub = self.amp_ubound[c]; else:; ub = self.amp_ubound. if not lb is None and np.isinf(lb):; lb = None; if not ub is None and np.isinf(ub):; ub = None. self.bounds.app",MatchSource.WIKI,docs/4.2/modules/qutip/control/optimizer.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/control/optimizer.html
https://qutip.org/docs/4.2/modules/qutip/control/optimizer.html:16975,Performance,optimiz,optimize,16975,"= {}; for key in params:; val = params[key]; if hasattr(self, key):; setattr(self, key, val); if hasattr(self.termination_conditions, key):; setattr(self.termination_conditions, key, val); else:; unused_params[key] = val. if len(unused_params) > 0:; if not isinstance(self.method_options, dict):; self.method_options = unused_params; else:; self.method_options.update(unused_params). def _build_bounds_list(self):; cfg = self.config; dyn = self.dynamics; n_ctrls = dyn.num_ctrls; self.bounds = []; for t in range(dyn.num_tslots):; for c in range(n_ctrls):; if isinstance(self.amp_lbound, list):; lb = self.amp_lbound[c]; else:; lb = self.amp_lbound; if isinstance(self.amp_ubound, list):; ub = self.amp_ubound[c]; else:; ub = self.amp_ubound. if not lb is None and np.isinf(lb):; lb = None; if not ub is None and np.isinf(ub):; ub = None. self.bounds.append((lb, ub)). [docs] def run_optimization(self, term_conds=None):; """"""; This default function optimisation method is a wrapper to the; scipy.optimize.minimize function. It will attempt to minimise the fidelity error with respect to some; parameters, which are determined by _get_optim_var_vals (see below). The optimisation end when one of the passed termination conditions; has been met, e.g. target achieved, wall time, or; function call or iteration count exceeded. Note these; conditions include gradient minimum met (local minima) for; methods that use a gradient. The function minimisation method is taken from the optim_method; attribute. Note that not all of these methods have been tested.; Note that some of these use a gradient and some do not.; See the scipy documentation for details. Options specific to the; method can be passed setting the method_params attribute. If the parameter term_conds=None, then the termination_conditions; attribute must already be set. It will be overwritten if the; parameter is not None. The result is returned in an OptimResult object, which includes; the final fidelity, time evolution, reason for t",MatchSource.WIKI,docs/4.2/modules/qutip/control/optimizer.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/control/optimizer.html
https://qutip.org/docs/4.2/modules/qutip/control/optimizer.html:26135,Performance,optimiz,optimize,26135,"result.grad_norm_final = dyn.fid_computer.grad_norm; result.final_amps = dyn.ctrl_amps; final_evo = dyn.full_evo; if isinstance(final_evo, Qobj):; result.evo_full_final = final_evo; else:; result.evo_full_final = Qobj(final_evo, dims=dyn.sys_dims); # *** update stats ***; if self.stats is not None:; self.stats.wall_time_optim_end = end_time; self.stats.calculate(); result.stats = copy.copy(self.stats). [docs]class OptimizerBFGS(Optimizer):; """"""; Implements the run_optimization method using the BFGS algorithm; """"""; def reset(self):; Optimizer.reset(self); self.id_text = 'BFGS'. [docs] def run_optimization(self, term_conds=None):; """"""; Optimise the control pulse amplitudes to minimise the fidelity error; using the BFGS (BroydenâFletcherâGoldfarbâShanno) algorithm; The optimisation end when one of the passed termination conditions; has been met, e.g. target achieved, gradient minimum met; (local minima), wall time / iteration count exceeded. Essentially this is wrapper to the:; scipy.optimize.fmin_bfgs; function. If the parameter term_conds=None, then the termination_conditions; attribute must already be set. It will be overwritten if the; parameter is not None. The result is returned in an OptimResult object, which includes; the final fidelity, time evolution, reason for termination etc; """"""; self.init_optim(term_conds); term_conds = self.termination_conditions; dyn = self.dynamics; self.optim_var_vals = self._get_optim_var_vals(); self._build_method_options(). st_time = timeit.default_timer(); self.wall_time_optimize_start = st_time. if self.stats is not None:; self.stats.wall_time_optim_start = st_time; self.stats.wall_time_optim_end = 0.0; self.stats.num_iter = 1. if self.approx_grad:; fprime = None; else:; fprime = self.fid_err_grad_wrapper. if self.log_level <= logging.INFO:; msg = (""Optimising pulse(s) using {} with ""; ""'fmin_bfgs' method"").format(self.alg); if self.approx_grad:; msg += "" (approx grad)""; logger.info(msg). result = self._create_result(); try:; opt",MatchSource.WIKI,docs/4.2/modules/qutip/control/optimizer.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/control/optimizer.html
https://qutip.org/docs/4.2/modules/qutip/control/optimizer.html:28336,Performance,optimiz,optimize,28336,"_callback_func,; gtol=term_conds.min_gradient_norm,; maxiter=term_conds.max_iterations,; full_output=True, disp=True). amps = self._get_ctrl_amps(optim_var_vals); dyn.update_ctrl_amps(amps); if warn == 1:; result.max_iter_exceeded = True; result.termination_reason = ""Iteration count limit reached""; elif warn == 2:; result.grad_norm_min_reached = True; result.termination_reason = ""Gradient normal minimum reached"". except errors.OptimizationTerminate as except_term:; self._interpret_term_exception(except_term, result). end_time = timeit.default_timer(); self._add_common_result_attribs(result, st_time, end_time). return result. [docs]class OptimizerLBFGSB(Optimizer):; """"""; Implements the run_optimization method using the L-BFGS-B algorithm. Attributes; ----------; max_metric_corr : integer; The maximum number of variable metric corrections used to define; the limited memory matrix. That is the number of previous; gradient values that are used to approximate the Hessian; see the scipy.optimize.fmin_l_bfgs_b documentation for description; of m argument. """""". def reset(self):; Optimizer.reset(self); self.id_text = 'LBFGSB'; self.max_metric_corr = 10; self.msg_level = None. [docs] def init_optim(self, term_conds):; """"""; Check optimiser attribute status and passed parameters before; running the optimisation.; This is called by run_optimization, but could called independently; to check the configuration.; """"""; if term_conds is None:; term_conds = self.termination_conditions. # AJGP 2015-04-21:; # These (copying from config) are here for backward compatibility; if hasattr(self.config, 'max_metric_corr'):; if self.config.max_metric_corr:; self.max_metric_corr = self.config.max_metric_corr; if hasattr(self.config, 'accuracy_factor'):; if self.config.accuracy_factor:; term_conds.accuracy_factor = \; self.config.accuracy_factor. Optimizer.init_optim(self, term_conds). if not isinstance(self.msg_level, int):; if self.log_level < logging.DEBUG:; self.msg_level = 2; elif self.log_lev",MatchSource.WIKI,docs/4.2/modules/qutip/control/optimizer.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/control/optimizer.html
https://qutip.org/docs/4.2/modules/qutip/control/optimizer.html:29921,Performance,optimiz,optimize,29921,"ttr(self.config, 'max_metric_corr'):; if self.config.max_metric_corr:; self.max_metric_corr = self.config.max_metric_corr; if hasattr(self.config, 'accuracy_factor'):; if self.config.accuracy_factor:; term_conds.accuracy_factor = \; self.config.accuracy_factor. Optimizer.init_optim(self, term_conds). if not isinstance(self.msg_level, int):; if self.log_level < logging.DEBUG:; self.msg_level = 2; elif self.log_level <= logging.DEBUG:; self.msg_level = 1; else:; self.msg_level = 0. [docs] def run_optimization(self, term_conds=None):; """"""; Optimise the control pulse amplitudes to minimise the fidelity error; using the L-BFGS-B algorithm, which is the constrained; (bounded amplitude values), limited memory, version of the; BroydenâFletcherâGoldfarbâShanno algorithm. The optimisation end when one of the passed termination conditions; has been met, e.g. target achieved, gradient minimum met; (local minima), wall time / iteration count exceeded. Essentially this is wrapper to the:; scipy.optimize.fmin_l_bfgs_b function; This in turn is a warpper for well established implementation of; the L-BFGS-B algorithm written in Fortran, which is therefore; very fast. See SciPy documentation for credit and details on; this function. If the parameter term_conds=None, then the termination_conditions; attribute must already be set. It will be overwritten if the; parameter is not None. The result is returned in an OptimResult object, which includes; the final fidelity, time evolution, reason for termination etc; ; """"""; self.init_optim(term_conds); term_conds = self.termination_conditions; dyn = self.dynamics; cfg = self.config; self.optim_var_vals = self._get_optim_var_vals(); self._build_method_options(). st_time = timeit.default_timer(); self.wall_time_optimize_start = st_time. if self.stats is not None:; self.stats.wall_time_optim_start = st_time; self.stats.wall_time_optim_end = 0.0; self.stats.num_iter = 1. bounds = self._build_bounds_list(); result = self._create_result(). if self.a",MatchSource.WIKI,docs/4.2/modules/qutip/control/optimizer.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/control/optimizer.html
https://qutip.org/docs/4.2/modules/qutip/control/optimizer.html:32838,Performance,optimiz,optimize,32838,"f.approx_grad,; callback=self.iter_step_callback_func,; bounds=self.bounds, m=m, factr=factr,; pgtol=term_conds.min_gradient_norm,; disp=self.msg_level,; maxfun=term_conds.max_fid_func_calls,; maxiter=term_conds.max_iterations). amps = self._get_ctrl_amps(optim_var_vals); dyn.update_ctrl_amps(amps); warn = res_dict['warnflag']; if warn == 0:; result.grad_norm_min_reached = True; result.termination_reason = ""function converged""; elif warn == 1:; result.max_iter_exceeded = True; result.termination_reason = (""Iteration or fidelity ""; ""function call limit reached""); elif warn == 2:; result.termination_reason = res_dict['task']. result.num_iter = res_dict['nit']; except errors.OptimizationTerminate as except_term:; self._interpret_term_exception(except_term, result). end_time = timeit.default_timer(); self._add_common_result_attribs(result, st_time, end_time). return result. [docs]class OptimizerCrab(Optimizer):; """"""; Optimises the pulse using the CRAB algorithm [1].; It uses the scipy.optimize.minimize function with the method specified; by the optim_method attribute. See Optimizer.run_optimization for details; It minimises the fidelity error function with respect to the CRAB; basis function coefficients. AJGP ToDo: Add citation here; """""". def reset(self):; Optimizer.reset(self); self.id_text = 'CRAB'; self.num_optim_vars = 0. [docs] def init_optim(self, term_conds):; """"""; Check optimiser attribute status and passed parameters before; running the optimisation.; This is called by run_optimization, but could called independently; to check the configuration.; """"""; Optimizer.init_optim(self, term_conds); dyn = self.dynamics. self.num_optim_vars = 0; pulse_gen_valid = True; # check the pulse generators match the ctrls; # (in terms of number); # and count the number of parameters; if self.pulse_generator is None:; pulse_gen_valid = False; err_msg = ""pulse_generator attribute is None""; elif not isinstance(self.pulse_generator, collections.Iterable):; pulse_gen_valid = False; er",MatchSource.WIKI,docs/4.2/modules/qutip/control/optimizer.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/control/optimizer.html
https://qutip.org/docs/4.2/modules/qutip/control/optimizer.html:36266,Performance,optimiz,optimize,36266,"hat is the 1d array that is passed from the optimisation method; For CRAB the amplitudes will need to calculated by expanding the; series. Returns; -------; float array[dynamics.num_tslots, dynamics.num_ctrls]; """"""; dyn = self.dynamics. if self.log_level <= logging.DEBUG:; changed_params = self.optim_var_vals != optim_var_vals; logger.debug(; ""{} out of {} optimisation parameters changed"".format(; changed_params.sum(), len(optim_var_vals))). amps = np.empty([dyn.num_tslots, dyn.num_ctrls]); j = 0; param_idx_st = 0; for p_gen in self.pulse_generator:; param_idx_end = param_idx_st + p_gen.num_optim_vars; pg_pvals = optim_var_vals[param_idx_st:param_idx_end]; p_gen.set_optim_var_vals(pg_pvals); amps[:, j] = p_gen.gen_pulse(); param_idx_st = param_idx_end; j += 1. #print(""param_idx_end={}"".format(param_idx_end)); self.optim_var_vals = optim_var_vals; return amps. [docs]class OptimizerCrabFmin(OptimizerCrab):; """"""; Optimises the pulse using the CRAB algorithm [1, 2].; It uses the scipy.optimize.fmin function which is effectively a wrapper; for the Nelder-mead method.; It minimises the fidelity error function with respect to the CRAB; basis function coefficients.; This is the default Optimizer for CRAB. Notes; -----; [1] P. Doria, T. Calarco & S. Montangero. Phys. Rev. Lett. 106,; 190501 (2011).; [2] T. Caneva, T. Calarco, & S. Montangero. Phys. Rev. A 84, 022326 (2011).; """""". def reset(self):; OptimizerCrab.reset(self); self.id_text = 'CRAB_FMIN'; self.xtol = 1e-4; self.ftol = 1e-4. [docs] def run_optimization(self, term_conds=None):; """"""; This function optimisation method is a wrapper to the; scipy.optimize.fmin function. It will attempt to minimise the fidelity error with respect to some; parameters, which are determined by _get_optim_var_vals which; in the case of CRAB are the basis function coefficients. The optimisation end when one of the passed termination conditions; has been met, e.g. target achieved, wall time, or; function call or iteration count exceeded. Spec",MatchSource.WIKI,docs/4.2/modules/qutip/control/optimizer.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/control/optimizer.html
https://qutip.org/docs/4.2/modules/qutip/control/optimizer.html:36892,Performance,optimiz,optimize,36892,"_var_vals[param_idx_st:param_idx_end]; p_gen.set_optim_var_vals(pg_pvals); amps[:, j] = p_gen.gen_pulse(); param_idx_st = param_idx_end; j += 1. #print(""param_idx_end={}"".format(param_idx_end)); self.optim_var_vals = optim_var_vals; return amps. [docs]class OptimizerCrabFmin(OptimizerCrab):; """"""; Optimises the pulse using the CRAB algorithm [1, 2].; It uses the scipy.optimize.fmin function which is effectively a wrapper; for the Nelder-mead method.; It minimises the fidelity error function with respect to the CRAB; basis function coefficients.; This is the default Optimizer for CRAB. Notes; -----; [1] P. Doria, T. Calarco & S. Montangero. Phys. Rev. Lett. 106,; 190501 (2011).; [2] T. Caneva, T. Calarco, & S. Montangero. Phys. Rev. A 84, 022326 (2011).; """""". def reset(self):; OptimizerCrab.reset(self); self.id_text = 'CRAB_FMIN'; self.xtol = 1e-4; self.ftol = 1e-4. [docs] def run_optimization(self, term_conds=None):; """"""; This function optimisation method is a wrapper to the; scipy.optimize.fmin function. It will attempt to minimise the fidelity error with respect to some; parameters, which are determined by _get_optim_var_vals which; in the case of CRAB are the basis function coefficients. The optimisation end when one of the passed termination conditions; has been met, e.g. target achieved, wall time, or; function call or iteration count exceeded. Specifically to the fmin; method, the optimisation will stop when change parameter values; is less than xtol or the change in function value is below ftol. If the parameter term_conds=None, then the termination_conditions; attribute must already be set. It will be overwritten if the; parameter is not None. The result is returned in an OptimResult object, which includes; the final fidelity, time evolution, reason for termination etc; """"""; self.init_optim(term_conds); term_conds = self.termination_conditions; dyn = self.dynamics; cfg = self.config; self.optim_var_vals = self._get_optim_var_vals(); self._build_method_options(",MatchSource.WIKI,docs/4.2/modules/qutip/control/optimizer.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/control/optimizer.html
https://qutip.org/docs/4.2/modules/qutip/control/optimizer.html:4585,Testability,log,logging,4585,"ass: OptimizerBFGS. L-BFGS-B - Bounded, limited memory BFGS; ; This a version of the BFGS method where the Hessian approximation is; only based on a set of the most recent gradient calls. It generally; performs better where the are a large number of variables; The SciPy implementation of L-BFGS-B is wrapper around a well; established and actively maintained implementation in Fortran; Its is therefore very fast.; # See SciPy documentation for credit and details on the; # scipy.optimize.fmin_l_bfgs_b function; use subclass: OptimizerLBFGSB. The baseclass Optimizer implements the function wrappers to the; fidelity error, gradient, and iteration callback functions.; These are called from the within the SciPy optimisation functions.; The subclasses implement the algorithm specific pulse optimisation function.; """""". import os; import numpy as np; import timeit; import scipy.optimize as spopt; import copy; import collections; # QuTiP; from qutip import Qobj; import qutip.logging_utils as logging; logger = logging.get_logger(); # QuTiP control modules; import qutip.control.optimresult as optimresult; import qutip.control.termcond as termcond; import qutip.control.errors as errors; import qutip.control.dynamics as dynamics; import qutip.control.pulsegen as pulsegen; import qutip.control.dump as qtrldump. def _is_string(var):; try:; if isinstance(var, basestring):; return True; except NameError:; try:; if isinstance(var, str):; return True; except:; return False; except:; return False. return False. [docs]class Optimizer(object):; """"""; Base class for all control pulse optimisers. This class should not be; instantiated, use its subclasses; This class implements the fidelity, gradient and interation callback; functions.; All subclass objects must be initialised with a; ; OptimConfig instance - various configuration options; Dynamics instance - describes the dynamics of the (quantum) system; to be control optimised. Attributes; ----------; log_level : integer; level of messaging ",MatchSource.WIKI,docs/4.2/modules/qutip/control/optimizer.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/control/optimizer.html
https://qutip.org/docs/4.2/modules/qutip/control/optimizer.html:4594,Testability,log,logger,4594,"ass: OptimizerBFGS. L-BFGS-B - Bounded, limited memory BFGS; ; This a version of the BFGS method where the Hessian approximation is; only based on a set of the most recent gradient calls. It generally; performs better where the are a large number of variables; The SciPy implementation of L-BFGS-B is wrapper around a well; established and actively maintained implementation in Fortran; Its is therefore very fast.; # See SciPy documentation for credit and details on the; # scipy.optimize.fmin_l_bfgs_b function; use subclass: OptimizerLBFGSB. The baseclass Optimizer implements the function wrappers to the; fidelity error, gradient, and iteration callback functions.; These are called from the within the SciPy optimisation functions.; The subclasses implement the algorithm specific pulse optimisation function.; """""". import os; import numpy as np; import timeit; import scipy.optimize as spopt; import copy; import collections; # QuTiP; from qutip import Qobj; import qutip.logging_utils as logging; logger = logging.get_logger(); # QuTiP control modules; import qutip.control.optimresult as optimresult; import qutip.control.termcond as termcond; import qutip.control.errors as errors; import qutip.control.dynamics as dynamics; import qutip.control.pulsegen as pulsegen; import qutip.control.dump as qtrldump. def _is_string(var):; try:; if isinstance(var, basestring):; return True; except NameError:; try:; if isinstance(var, str):; return True; except:; return False; except:; return False. return False. [docs]class Optimizer(object):; """"""; Base class for all control pulse optimisers. This class should not be; instantiated, use its subclasses; This class implements the fidelity, gradient and interation callback; functions.; All subclass objects must be initialised with a; ; OptimConfig instance - various configuration options; Dynamics instance - describes the dynamics of the (quantum) system; to be control optimised. Attributes; ----------; log_level : integer; level of messaging ",MatchSource.WIKI,docs/4.2/modules/qutip/control/optimizer.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/control/optimizer.html
https://qutip.org/docs/4.2/modules/qutip/control/optimizer.html:4603,Testability,log,logging,4603,"ass: OptimizerBFGS. L-BFGS-B - Bounded, limited memory BFGS; ; This a version of the BFGS method where the Hessian approximation is; only based on a set of the most recent gradient calls. It generally; performs better where the are a large number of variables; The SciPy implementation of L-BFGS-B is wrapper around a well; established and actively maintained implementation in Fortran; Its is therefore very fast.; # See SciPy documentation for credit and details on the; # scipy.optimize.fmin_l_bfgs_b function; use subclass: OptimizerLBFGSB. The baseclass Optimizer implements the function wrappers to the; fidelity error, gradient, and iteration callback functions.; These are called from the within the SciPy optimisation functions.; The subclasses implement the algorithm specific pulse optimisation function.; """""". import os; import numpy as np; import timeit; import scipy.optimize as spopt; import copy; import collections; # QuTiP; from qutip import Qobj; import qutip.logging_utils as logging; logger = logging.get_logger(); # QuTiP control modules; import qutip.control.optimresult as optimresult; import qutip.control.termcond as termcond; import qutip.control.errors as errors; import qutip.control.dynamics as dynamics; import qutip.control.pulsegen as pulsegen; import qutip.control.dump as qtrldump. def _is_string(var):; try:; if isinstance(var, basestring):; return True; except NameError:; try:; if isinstance(var, str):; return True; except:; return False; except:; return False. return False. [docs]class Optimizer(object):; """"""; Base class for all control pulse optimisers. This class should not be; instantiated, use its subclasses; This class implements the fidelity, gradient and interation callback; functions.; All subclass objects must be initialised with a; ; OptimConfig instance - various configuration options; Dynamics instance - describes the dynamics of the (quantum) system; to be control optimised. Attributes; ----------; log_level : integer; level of messaging ",MatchSource.WIKI,docs/4.2/modules/qutip/control/optimizer.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/control/optimizer.html
https://qutip.org/docs/4.2/modules/qutip/control/optimizer.html:5606,Testability,log,logger,5606,"ogging_utils as logging; logger = logging.get_logger(); # QuTiP control modules; import qutip.control.optimresult as optimresult; import qutip.control.termcond as termcond; import qutip.control.errors as errors; import qutip.control.dynamics as dynamics; import qutip.control.pulsegen as pulsegen; import qutip.control.dump as qtrldump. def _is_string(var):; try:; if isinstance(var, basestring):; return True; except NameError:; try:; if isinstance(var, str):; return True; except:; return False; except:; return False. return False. [docs]class Optimizer(object):; """"""; Base class for all control pulse optimisers. This class should not be; instantiated, use its subclasses; This class implements the fidelity, gradient and interation callback; functions.; All subclass objects must be initialised with a; ; OptimConfig instance - various configuration options; Dynamics instance - describes the dynamics of the (quantum) system; to be control optimised. Attributes; ----------; log_level : integer; level of messaging output from the logger.; Options are attributes of qutip.logging_utils,; in decreasing levels of messaging, are:; DEBUG_INTENSE, DEBUG_VERBOSE, DEBUG, INFO, WARN, ERROR, CRITICAL; Anything WARN or above is effectively 'quiet' execution,; assuming everything runs as expected.; The default NOTSET implies that the level will be taken from; the QuTiP settings file, which by default is WARN. params: Dictionary; The key value pairs are the attribute name and value; Note: attributes are created if they do not exist already,; and are overwritten if they do. alg : string; Algorithm to use in pulse optimisation.; Options are:; 'GRAPE' (default) - GRadient Ascent Pulse Engineering; 'CRAB' - Chopped RAndom Basis. alg_params : Dictionary; options that are specific to the pulse optim algorithm; that is GRAPE or CRAB. disp_conv_msg : bool; Set true to display a convergence message; (for scipy.optimize.minimize methods anyway). optim_method : string; a scipy.optimize.minimize meth",MatchSource.WIKI,docs/4.2/modules/qutip/control/optimizer.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/control/optimizer.html
https://qutip.org/docs/4.2/modules/qutip/control/optimizer.html:10655,Testability,log,logger,10655,"elf):; self.log_level = self.config.log_level; self.id_text = 'OPTIM'; self.termination_conditions = None; self.pulse_generator = None; self.disp_conv_msg = False; self.iteration_steps = None; self.record_iteration_steps=False; self.alg = 'GRAPE'; self.alg_params = None; self.method = 'l_bfgs_b'; self.method_params = None; self.method_options = None; self.approx_grad = False; self.amp_lbound = None; self.amp_ubound = None; self.bounds = None; self.num_iter = 0; self.num_fid_func_calls = 0; self.num_grad_func_calls = 0; self.stats = None; self.wall_time_optim_start = 0.0. self.dump_to_file = False; self.dump = None; self.iter_summary = None. # AJGP 2015-04-21:; # These (copying from config) are here for backward compatibility; if hasattr(self.config, 'amp_lbound'):; if self.config.amp_lbound:; self.amp_lbound = self.config.amp_lbound; if hasattr(self.config, 'amp_ubound'):; if self.config.amp_ubound:; self.amp_ubound = self.config.amp_ubound. self.apply_params(). @property; def log_level(self):; return logger.level. @log_level.setter; def log_level(self, lvl):; """"""; Set the log_level attribute and set the level of the logger; that is call logger.setLevel(lvl); """"""; logger.setLevel(lvl). [docs] def apply_params(self, params=None):; """"""; Set object attributes based on the dictionary (if any) passed in the; instantiation, or passed as a parameter; This is called during the instantiation automatically.; The key value pairs are the attribute name and value; Note: attributes are created if they do not exist already,; and are overwritten if they do.; """"""; if not params:; params = self.params. if isinstance(params, dict):; self.params = params; for key in params:; setattr(self, key, params[key]). @property; def dumping(self):; """"""; The level of data dumping that will occur during the optimisation; - NONE : No processing data dumped (Default); - SUMMARY : A summary at each iteration will be recorded; - FULL : All logs will be generated and dumped; - CUSTOM : Some customised l",MatchSource.WIKI,docs/4.2/modules/qutip/control/optimizer.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/control/optimizer.html
https://qutip.org/docs/4.2/modules/qutip/control/optimizer.html:10773,Testability,log,logger,10773,"one; self.pulse_generator = None; self.disp_conv_msg = False; self.iteration_steps = None; self.record_iteration_steps=False; self.alg = 'GRAPE'; self.alg_params = None; self.method = 'l_bfgs_b'; self.method_params = None; self.method_options = None; self.approx_grad = False; self.amp_lbound = None; self.amp_ubound = None; self.bounds = None; self.num_iter = 0; self.num_fid_func_calls = 0; self.num_grad_func_calls = 0; self.stats = None; self.wall_time_optim_start = 0.0. self.dump_to_file = False; self.dump = None; self.iter_summary = None. # AJGP 2015-04-21:; # These (copying from config) are here for backward compatibility; if hasattr(self.config, 'amp_lbound'):; if self.config.amp_lbound:; self.amp_lbound = self.config.amp_lbound; if hasattr(self.config, 'amp_ubound'):; if self.config.amp_ubound:; self.amp_ubound = self.config.amp_ubound. self.apply_params(). @property; def log_level(self):; return logger.level. @log_level.setter; def log_level(self, lvl):; """"""; Set the log_level attribute and set the level of the logger; that is call logger.setLevel(lvl); """"""; logger.setLevel(lvl). [docs] def apply_params(self, params=None):; """"""; Set object attributes based on the dictionary (if any) passed in the; instantiation, or passed as a parameter; This is called during the instantiation automatically.; The key value pairs are the attribute name and value; Note: attributes are created if they do not exist already,; and are overwritten if they do.; """"""; if not params:; params = self.params. if isinstance(params, dict):; self.params = params; for key in params:; setattr(self, key, params[key]). @property; def dumping(self):; """"""; The level of data dumping that will occur during the optimisation; - NONE : No processing data dumped (Default); - SUMMARY : A summary at each iteration will be recorded; - FULL : All logs will be generated and dumped; - CUSTOM : Some customised level of dumping; When first set to CUSTOM this is equivalent to SUMMARY. It is then up; to the user to ",MatchSource.WIKI,docs/4.2/modules/qutip/control/optimizer.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/control/optimizer.html
https://qutip.org/docs/4.2/modules/qutip/control/optimizer.html:10794,Testability,log,logger,10794,"one; self.pulse_generator = None; self.disp_conv_msg = False; self.iteration_steps = None; self.record_iteration_steps=False; self.alg = 'GRAPE'; self.alg_params = None; self.method = 'l_bfgs_b'; self.method_params = None; self.method_options = None; self.approx_grad = False; self.amp_lbound = None; self.amp_ubound = None; self.bounds = None; self.num_iter = 0; self.num_fid_func_calls = 0; self.num_grad_func_calls = 0; self.stats = None; self.wall_time_optim_start = 0.0. self.dump_to_file = False; self.dump = None; self.iter_summary = None. # AJGP 2015-04-21:; # These (copying from config) are here for backward compatibility; if hasattr(self.config, 'amp_lbound'):; if self.config.amp_lbound:; self.amp_lbound = self.config.amp_lbound; if hasattr(self.config, 'amp_ubound'):; if self.config.amp_ubound:; self.amp_ubound = self.config.amp_ubound. self.apply_params(). @property; def log_level(self):; return logger.level. @log_level.setter; def log_level(self, lvl):; """"""; Set the log_level attribute and set the level of the logger; that is call logger.setLevel(lvl); """"""; logger.setLevel(lvl). [docs] def apply_params(self, params=None):; """"""; Set object attributes based on the dictionary (if any) passed in the; instantiation, or passed as a parameter; This is called during the instantiation automatically.; The key value pairs are the attribute name and value; Note: attributes are created if they do not exist already,; and are overwritten if they do.; """"""; if not params:; params = self.params. if isinstance(params, dict):; self.params = params; for key in params:; setattr(self, key, params[key]). @property; def dumping(self):; """"""; The level of data dumping that will occur during the optimisation; - NONE : No processing data dumped (Default); - SUMMARY : A summary at each iteration will be recorded; - FULL : All logs will be generated and dumped; - CUSTOM : Some customised level of dumping; When first set to CUSTOM this is equivalent to SUMMARY. It is then up; to the user to ",MatchSource.WIKI,docs/4.2/modules/qutip/control/optimizer.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/control/optimizer.html
https://qutip.org/docs/4.2/modules/qutip/control/optimizer.html:10821,Testability,log,logger,10821,"on_steps = None; self.record_iteration_steps=False; self.alg = 'GRAPE'; self.alg_params = None; self.method = 'l_bfgs_b'; self.method_params = None; self.method_options = None; self.approx_grad = False; self.amp_lbound = None; self.amp_ubound = None; self.bounds = None; self.num_iter = 0; self.num_fid_func_calls = 0; self.num_grad_func_calls = 0; self.stats = None; self.wall_time_optim_start = 0.0. self.dump_to_file = False; self.dump = None; self.iter_summary = None. # AJGP 2015-04-21:; # These (copying from config) are here for backward compatibility; if hasattr(self.config, 'amp_lbound'):; if self.config.amp_lbound:; self.amp_lbound = self.config.amp_lbound; if hasattr(self.config, 'amp_ubound'):; if self.config.amp_ubound:; self.amp_ubound = self.config.amp_ubound. self.apply_params(). @property; def log_level(self):; return logger.level. @log_level.setter; def log_level(self, lvl):; """"""; Set the log_level attribute and set the level of the logger; that is call logger.setLevel(lvl); """"""; logger.setLevel(lvl). [docs] def apply_params(self, params=None):; """"""; Set object attributes based on the dictionary (if any) passed in the; instantiation, or passed as a parameter; This is called during the instantiation automatically.; The key value pairs are the attribute name and value; Note: attributes are created if they do not exist already,; and are overwritten if they do.; """"""; if not params:; params = self.params. if isinstance(params, dict):; self.params = params; for key in params:; setattr(self, key, params[key]). @property; def dumping(self):; """"""; The level of data dumping that will occur during the optimisation; - NONE : No processing data dumped (Default); - SUMMARY : A summary at each iteration will be recorded; - FULL : All logs will be generated and dumped; - CUSTOM : Some customised level of dumping; When first set to CUSTOM this is equivalent to SUMMARY. It is then up; to the user to specify which logs are dumped; """"""; if self.dump is None:; lvl = 'NONE'; e",MatchSource.WIKI,docs/4.2/modules/qutip/control/optimizer.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/control/optimizer.html
https://qutip.org/docs/4.2/modules/qutip/control/optimizer.html:11575,Testability,log,logs,11575,"config.amp_ubound:; self.amp_ubound = self.config.amp_ubound. self.apply_params(). @property; def log_level(self):; return logger.level. @log_level.setter; def log_level(self, lvl):; """"""; Set the log_level attribute and set the level of the logger; that is call logger.setLevel(lvl); """"""; logger.setLevel(lvl). [docs] def apply_params(self, params=None):; """"""; Set object attributes based on the dictionary (if any) passed in the; instantiation, or passed as a parameter; This is called during the instantiation automatically.; The key value pairs are the attribute name and value; Note: attributes are created if they do not exist already,; and are overwritten if they do.; """"""; if not params:; params = self.params. if isinstance(params, dict):; self.params = params; for key in params:; setattr(self, key, params[key]). @property; def dumping(self):; """"""; The level of data dumping that will occur during the optimisation; - NONE : No processing data dumped (Default); - SUMMARY : A summary at each iteration will be recorded; - FULL : All logs will be generated and dumped; - CUSTOM : Some customised level of dumping; When first set to CUSTOM this is equivalent to SUMMARY. It is then up; to the user to specify which logs are dumped; """"""; if self.dump is None:; lvl = 'NONE'; else:; lvl = self.dump.level. return lvl. @dumping.setter; def dumping(self, value):; if value is None:; self.dump = None; else:; if not _is_string(value):; raise TypeError(""Value must be string value""); lvl = value.upper(); if lvl == 'NONE':; self.dump = None; else:; if not isinstance(self.dump, qtrldump.OptimDump):; self.dump = qtrldump.OptimDump(self, level=lvl); else:; self.dump.level = lvl; @property; def dump_dir(self):; if self.dump:; return self.dump.dump_dir; else:; return None. @dump_dir.setter; def dump_dir(self, value):; if not self.dump:; self.dumping = 'SUMMARY'; self.dump.dump_dir = value. def _create_result(self):; """"""; create the result object; and set the initial_amps attribute as the curren",MatchSource.WIKI,docs/4.2/modules/qutip/control/optimizer.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/control/optimizer.html
https://qutip.org/docs/4.2/modules/qutip/control/optimizer.html:11755,Testability,log,logs,11755," and set the level of the logger; that is call logger.setLevel(lvl); """"""; logger.setLevel(lvl). [docs] def apply_params(self, params=None):; """"""; Set object attributes based on the dictionary (if any) passed in the; instantiation, or passed as a parameter; This is called during the instantiation automatically.; The key value pairs are the attribute name and value; Note: attributes are created if they do not exist already,; and are overwritten if they do.; """"""; if not params:; params = self.params. if isinstance(params, dict):; self.params = params; for key in params:; setattr(self, key, params[key]). @property; def dumping(self):; """"""; The level of data dumping that will occur during the optimisation; - NONE : No processing data dumped (Default); - SUMMARY : A summary at each iteration will be recorded; - FULL : All logs will be generated and dumped; - CUSTOM : Some customised level of dumping; When first set to CUSTOM this is equivalent to SUMMARY. It is then up; to the user to specify which logs are dumped; """"""; if self.dump is None:; lvl = 'NONE'; else:; lvl = self.dump.level. return lvl. @dumping.setter; def dumping(self, value):; if value is None:; self.dump = None; else:; if not _is_string(value):; raise TypeError(""Value must be string value""); lvl = value.upper(); if lvl == 'NONE':; self.dump = None; else:; if not isinstance(self.dump, qtrldump.OptimDump):; self.dump = qtrldump.OptimDump(self, level=lvl); else:; self.dump.level = lvl; @property; def dump_dir(self):; if self.dump:; return self.dump.dump_dir; else:; return None. @dump_dir.setter; def dump_dir(self, value):; if not self.dump:; self.dumping = 'SUMMARY'; self.dump.dump_dir = value. def _create_result(self):; """"""; create the result object; and set the initial_amps attribute as the current amplitudes; """"""; result = optimresult.OptimResult(); result.initial_fid_err = self.dynamics.fid_computer.get_fid_err(); result.initial_amps = self.dynamics.ctrl_amps.copy(); result.time = self.dynamics.time; result",MatchSource.WIKI,docs/4.2/modules/qutip/control/optimizer.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/control/optimizer.html
https://qutip.org/docs/4.2/modules/qutip/control/optimizer.html:14040,Testability,log,logger,14040," is not None:; self.termination_conditions = term_conds; term_conds = self.termination_conditions. if not isinstance(term_conds, termcond.TerminationConditions):; raise errors.UsageError(""No termination conditions for the ""; ""optimisation function""). if not isinstance(self.dynamics, dynamics.Dynamics):; raise errors.UsageError(""No dynamics object attribute set""); self.dynamics.check_ctrls_initialized(). self.apply_method_params(). if term_conds.fid_err_targ is None and term_conds.fid_goal is None:; raise errors.UsageError(""Either the goal or the fidelity ""; ""error tolerance must be set""). if term_conds.fid_err_targ is None:; term_conds.fid_err_targ = np.abs(1 - term_conds.fid_goal). if term_conds.fid_goal is None:; term_conds.fid_goal = 1 - term_conds.fid_err_targ. if self.alg == 'CRAB':; self.approx_grad = True. if self.stats is not None:; self.stats.clear(). if self.dump_to_file:; if self.dump is None:; self.dumping = 'SUMMARY'; self.dump.write_to_file = True; self.dump.create_dump_dir(); logger.info(""Optimiser dump will be written to:\n{}"".format(; self.dump.dump_dir)). if self.dump:; self.iter_summary = OptimIterSummary(); else:; self.iter_summary = None. self.num_iter = 0; self.num_fid_func_calls = 0; self.num_grad_func_calls = 0; self.iteration_steps = None. def _build_method_options(self):; """"""; Creates the method_options dictionary for the scipy.optimize.minimize; function based on the attributes of this object and the; termination_conditions; It assumes that apply_method_params has already been run and; hence the method_options attribute may already contain items.; These values will NOT be overridden; """"""; tc = self.termination_conditions; if self.method_options is None:; self.method_options = {}; mo = self.method_options. if 'max_metric_corr' in mo and not 'maxcor' in mo:; mo['maxcor'] = mo['max_metric_corr']; elif hasattr(self, 'max_metric_corr') and not 'maxcor' in mo:; mo['maxcor'] = self.max_metric_corr; if 'accuracy_factor' in mo and not 'ftol' in mo:",MatchSource.WIKI,docs/4.2/modules/qutip/control/optimizer.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/control/optimizer.html
https://qutip.org/docs/4.2/modules/qutip/control/optimizer.html:17525,Testability,test,tested,17525,"s):; for c in range(n_ctrls):; if isinstance(self.amp_lbound, list):; lb = self.amp_lbound[c]; else:; lb = self.amp_lbound; if isinstance(self.amp_ubound, list):; ub = self.amp_ubound[c]; else:; ub = self.amp_ubound. if not lb is None and np.isinf(lb):; lb = None; if not ub is None and np.isinf(ub):; ub = None. self.bounds.append((lb, ub)). [docs] def run_optimization(self, term_conds=None):; """"""; This default function optimisation method is a wrapper to the; scipy.optimize.minimize function. It will attempt to minimise the fidelity error with respect to some; parameters, which are determined by _get_optim_var_vals (see below). The optimisation end when one of the passed termination conditions; has been met, e.g. target achieved, wall time, or; function call or iteration count exceeded. Note these; conditions include gradient minimum met (local minima) for; methods that use a gradient. The function minimisation method is taken from the optim_method; attribute. Note that not all of these methods have been tested.; Note that some of these use a gradient and some do not.; See the scipy documentation for details. Options specific to the; method can be passed setting the method_params attribute. If the parameter term_conds=None, then the termination_conditions; attribute must already be set. It will be overwritten if the; parameter is not None. The result is returned in an OptimResult object, which includes; the final fidelity, time evolution, reason for termination etc; ; """"""; self.init_optim(term_conds); term_conds = self.termination_conditions; dyn = self.dynamics; cfg = self.config; self.optim_var_vals = self._get_optim_var_vals(); st_time = timeit.default_timer(); self.wall_time_optimize_start = st_time. if self.stats is not None:; self.stats.wall_time_optim_start = st_time; self.stats.wall_time_optim_end = 0.0; self.stats.num_iter = 0. if self.bounds is None:; self._build_bounds_list(). self._build_method_options(). result = self._create_result(). if self.approx_gra",MatchSource.WIKI,docs/4.2/modules/qutip/control/optimizer.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/control/optimizer.html
https://qutip.org/docs/4.2/modules/qutip/control/optimizer.html:18579,Testability,log,logging,18579," some do not.; See the scipy documentation for details. Options specific to the; method can be passed setting the method_params attribute. If the parameter term_conds=None, then the termination_conditions; attribute must already be set. It will be overwritten if the; parameter is not None. The result is returned in an OptimResult object, which includes; the final fidelity, time evolution, reason for termination etc; ; """"""; self.init_optim(term_conds); term_conds = self.termination_conditions; dyn = self.dynamics; cfg = self.config; self.optim_var_vals = self._get_optim_var_vals(); st_time = timeit.default_timer(); self.wall_time_optimize_start = st_time. if self.stats is not None:; self.stats.wall_time_optim_start = st_time; self.stats.wall_time_optim_end = 0.0; self.stats.num_iter = 0. if self.bounds is None:; self._build_bounds_list(). self._build_method_options(). result = self._create_result(). if self.approx_grad:; jac=None; else:; jac=self.fid_err_grad_wrapper. if self.log_level <= logging.INFO:; msg = (""Optimising pulse(s) using {} with ""; ""minimise '{}' method"").format(self.alg, self.method); if self.approx_grad:; msg += "" (approx grad)""; logger.info(msg). try:; opt_res = spopt.minimize(; self.fid_err_func_wrapper, self.optim_var_vals,; method=self.method,; jac=jac,; bounds=self.bounds,; options=self.method_options,; callback=self.iter_step_callback_func). amps = self._get_ctrl_amps(opt_res.x); dyn.update_ctrl_amps(amps); result.termination_reason = opt_res.message; # Note the iterations are counted in this object as well; # so there are compared here for interest sake only; if self.num_iter != opt_res.nit:; logger.info(""The number of iterations counted {} ""; "" does not match the number reported {} ""; ""by {}"".format(self.num_iter, opt_res.nit,; self.method)); result.num_iter = opt_res.nit. except errors.OptimizationTerminate as except_term:; self._interpret_term_exception(except_term, result). end_time = timeit.default_timer(); self._add_common_result_attribs",MatchSource.WIKI,docs/4.2/modules/qutip/control/optimizer.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/control/optimizer.html
https://qutip.org/docs/4.2/modules/qutip/control/optimizer.html:18741,Testability,log,logger,18741,"ameter term_conds=None, then the termination_conditions; attribute must already be set. It will be overwritten if the; parameter is not None. The result is returned in an OptimResult object, which includes; the final fidelity, time evolution, reason for termination etc; ; """"""; self.init_optim(term_conds); term_conds = self.termination_conditions; dyn = self.dynamics; cfg = self.config; self.optim_var_vals = self._get_optim_var_vals(); st_time = timeit.default_timer(); self.wall_time_optimize_start = st_time. if self.stats is not None:; self.stats.wall_time_optim_start = st_time; self.stats.wall_time_optim_end = 0.0; self.stats.num_iter = 0. if self.bounds is None:; self._build_bounds_list(). self._build_method_options(). result = self._create_result(). if self.approx_grad:; jac=None; else:; jac=self.fid_err_grad_wrapper. if self.log_level <= logging.INFO:; msg = (""Optimising pulse(s) using {} with ""; ""minimise '{}' method"").format(self.alg, self.method); if self.approx_grad:; msg += "" (approx grad)""; logger.info(msg). try:; opt_res = spopt.minimize(; self.fid_err_func_wrapper, self.optim_var_vals,; method=self.method,; jac=jac,; bounds=self.bounds,; options=self.method_options,; callback=self.iter_step_callback_func). amps = self._get_ctrl_amps(opt_res.x); dyn.update_ctrl_amps(amps); result.termination_reason = opt_res.message; # Note the iterations are counted in this object as well; # so there are compared here for interest sake only; if self.num_iter != opt_res.nit:; logger.info(""The number of iterations counted {} ""; "" does not match the number reported {} ""; ""by {}"".format(self.num_iter, opt_res.nit,; self.method)); result.num_iter = opt_res.nit. except errors.OptimizationTerminate as except_term:; self._interpret_term_exception(except_term, result). end_time = timeit.default_timer(); self._add_common_result_attribs(result, st_time, end_time). return result. def _get_optim_var_vals(self):; """"""; Generate the 1d array that holds the current variable values; of th",MatchSource.WIKI,docs/4.2/modules/qutip/control/optimizer.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/control/optimizer.html
https://qutip.org/docs/4.2/modules/qutip/control/optimizer.html:19220,Testability,log,logger,19220,"e_start = st_time. if self.stats is not None:; self.stats.wall_time_optim_start = st_time; self.stats.wall_time_optim_end = 0.0; self.stats.num_iter = 0. if self.bounds is None:; self._build_bounds_list(). self._build_method_options(). result = self._create_result(). if self.approx_grad:; jac=None; else:; jac=self.fid_err_grad_wrapper. if self.log_level <= logging.INFO:; msg = (""Optimising pulse(s) using {} with ""; ""minimise '{}' method"").format(self.alg, self.method); if self.approx_grad:; msg += "" (approx grad)""; logger.info(msg). try:; opt_res = spopt.minimize(; self.fid_err_func_wrapper, self.optim_var_vals,; method=self.method,; jac=jac,; bounds=self.bounds,; options=self.method_options,; callback=self.iter_step_callback_func). amps = self._get_ctrl_amps(opt_res.x); dyn.update_ctrl_amps(amps); result.termination_reason = opt_res.message; # Note the iterations are counted in this object as well; # so there are compared here for interest sake only; if self.num_iter != opt_res.nit:; logger.info(""The number of iterations counted {} ""; "" does not match the number reported {} ""; ""by {}"".format(self.num_iter, opt_res.nit,; self.method)); result.num_iter = opt_res.nit. except errors.OptimizationTerminate as except_term:; self._interpret_term_exception(except_term, result). end_time = timeit.default_timer(); self._add_common_result_attribs(result, st_time, end_time). return result. def _get_optim_var_vals(self):; """"""; Generate the 1d array that holds the current variable values; of the function to be optimised; By default (as used in GRAPE) these are the control amplitudes; in each timeslot; """"""; return self.dynamics.ctrl_amps.reshape([-1]). def _get_ctrl_amps(self, optim_var_vals):; """"""; Get the control amplitudes from the current variable values; of the function to be optimised.; that is the 1d array that is passed from the optimisation method; Note for GRAPE these are the function optimiser parameters; (and this is the default); ; Returns; -------; float array[dynamic",MatchSource.WIKI,docs/4.2/modules/qutip/control/optimizer.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/control/optimizer.html
https://qutip.org/docs/4.2/modules/qutip/control/optimizer.html:21059,Testability,log,logging,21059,"s passed from the optimisation method; Note for GRAPE these are the function optimiser parameters; (and this is the default); ; Returns; -------; float array[dynamics.num_tslots, dynamics.num_ctrls]; """"""; amps = optim_var_vals.reshape(self.dynamics.ctrl_amps.shape). return amps. [docs] def fid_err_func_wrapper(self, *args):; """"""; Get the fidelity error achieved using the ctrl amplitudes passed; in as the first argument. This is called by generic optimisation algorithm as the; func to the minimised. The argument is the current; variable values, i.e. control amplitudes, passed as; a flat array. Hence these are reshaped as [nTimeslots, n_ctrls]; and then used to update the stored ctrl values (if they have changed). The error is checked against the target, and the optimisation is; terminated if the target has been achieved.; """"""; self.num_fid_func_calls += 1; # *** update stats ***; if self.stats is not None:; self.stats.num_fidelity_func_calls = self.num_fid_func_calls; if self.log_level <= logging.DEBUG:; logger.debug(""fidelity error call {}"".format(; self.stats.num_fidelity_func_calls)). amps = self._get_ctrl_amps(args[0].copy()); self.dynamics.update_ctrl_amps(amps). tc = self.termination_conditions; err = self.dynamics.fid_computer.get_fid_err(). if self.iter_summary:; self.iter_summary.fid_func_call_num = self.num_fid_func_calls; self.iter_summary.fid_err = err. if self.dump and self.dump.dump_fid_err:; self.dump.update_fid_err_log(err). if err <= tc.fid_err_targ:; raise errors.GoalAchievedTerminate(err). if self.num_fid_func_calls > tc.max_fid_func_calls:; raise errors.MaxFidFuncCallTerminate(). return err. [docs] def fid_err_grad_wrapper(self, *args):; """"""; Get the gradient of the fidelity error with respect to all of the; variables, i.e. the ctrl amplidutes in each timeslot. This is called by generic optimisation algorithm as the gradients of; func to the minimised wrt the variables. The argument is the current; variable values, i.e. control amplitudes, passed a",MatchSource.WIKI,docs/4.2/modules/qutip/control/optimizer.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/control/optimizer.html
https://qutip.org/docs/4.2/modules/qutip/control/optimizer.html:21075,Testability,log,logger,21075,"optimisation method; Note for GRAPE these are the function optimiser parameters; (and this is the default); ; Returns; -------; float array[dynamics.num_tslots, dynamics.num_ctrls]; """"""; amps = optim_var_vals.reshape(self.dynamics.ctrl_amps.shape). return amps. [docs] def fid_err_func_wrapper(self, *args):; """"""; Get the fidelity error achieved using the ctrl amplitudes passed; in as the first argument. This is called by generic optimisation algorithm as the; func to the minimised. The argument is the current; variable values, i.e. control amplitudes, passed as; a flat array. Hence these are reshaped as [nTimeslots, n_ctrls]; and then used to update the stored ctrl values (if they have changed). The error is checked against the target, and the optimisation is; terminated if the target has been achieved.; """"""; self.num_fid_func_calls += 1; # *** update stats ***; if self.stats is not None:; self.stats.num_fidelity_func_calls = self.num_fid_func_calls; if self.log_level <= logging.DEBUG:; logger.debug(""fidelity error call {}"".format(; self.stats.num_fidelity_func_calls)). amps = self._get_ctrl_amps(args[0].copy()); self.dynamics.update_ctrl_amps(amps). tc = self.termination_conditions; err = self.dynamics.fid_computer.get_fid_err(). if self.iter_summary:; self.iter_summary.fid_func_call_num = self.num_fid_func_calls; self.iter_summary.fid_err = err. if self.dump and self.dump.dump_fid_err:; self.dump.update_fid_err_log(err). if err <= tc.fid_err_targ:; raise errors.GoalAchievedTerminate(err). if self.num_fid_func_calls > tc.max_fid_func_calls:; raise errors.MaxFidFuncCallTerminate(). return err. [docs] def fid_err_grad_wrapper(self, *args):; """"""; Get the gradient of the fidelity error with respect to all of the; variables, i.e. the ctrl amplidutes in each timeslot. This is called by generic optimisation algorithm as the gradients of; func to the minimised wrt the variables. The argument is the current; variable values, i.e. control amplitudes, passed as; a flat array. H",MatchSource.WIKI,docs/4.2/modules/qutip/control/optimizer.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/control/optimizer.html
https://qutip.org/docs/4.2/modules/qutip/control/optimizer.html:22633,Testability,log,logging,22633,"unc_calls:; raise errors.MaxFidFuncCallTerminate(). return err. [docs] def fid_err_grad_wrapper(self, *args):; """"""; Get the gradient of the fidelity error with respect to all of the; variables, i.e. the ctrl amplidutes in each timeslot. This is called by generic optimisation algorithm as the gradients of; func to the minimised wrt the variables. The argument is the current; variable values, i.e. control amplitudes, passed as; a flat array. Hence these are reshaped as [nTimeslots, n_ctrls]; and then used to update the stored ctrl values (if they have changed). Although the optimisation algorithms have a check within them for; function convergence, i.e. local minima, the sum of the squares; of the normalised gradient is checked explicitly, and the; optimisation is terminated if this is below the min_gradient_norm; condition; """"""; # *** update stats ***; self.num_grad_func_calls += 1; if self.stats is not None:; self.stats.num_grad_func_calls = self.num_grad_func_calls; if self.log_level <= logging.DEBUG:; logger.debug(""gradient call {}"".format(; self.stats.num_grad_func_calls)); amps = self._get_ctrl_amps(args[0].copy()); self.dynamics.update_ctrl_amps(amps); fid_comp = self.dynamics.fid_computer; # gradient_norm_func is a pointer to the function set in the config; # that returns the normalised gradients; grad = fid_comp.get_fid_err_gradient(). if self.iter_summary:; self.iter_summary.grad_func_call_num = self.num_grad_func_calls; self.iter_summary.grad_norm = fid_comp.grad_norm. if self.dump:; if self.dump.dump_grad_norm:; self.dump.update_grad_norm_log(fid_comp.grad_norm). if self.dump.dump_grad:; self.dump.update_grad_log(grad). tc = self.termination_conditions; if fid_comp.grad_norm < tc.min_gradient_norm:; raise errors.GradMinReachedTerminate(fid_comp.grad_norm); return grad.flatten(). [docs] def iter_step_callback_func(self, *args):; """"""; Check the elapsed wall time for the optimisation run so far.; Terminate if this has exceeded the maximum allowed time; """"""; se",MatchSource.WIKI,docs/4.2/modules/qutip/control/optimizer.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/control/optimizer.html
https://qutip.org/docs/4.2/modules/qutip/control/optimizer.html:22649,Testability,log,logger,22649,"errors.MaxFidFuncCallTerminate(). return err. [docs] def fid_err_grad_wrapper(self, *args):; """"""; Get the gradient of the fidelity error with respect to all of the; variables, i.e. the ctrl amplidutes in each timeslot. This is called by generic optimisation algorithm as the gradients of; func to the minimised wrt the variables. The argument is the current; variable values, i.e. control amplitudes, passed as; a flat array. Hence these are reshaped as [nTimeslots, n_ctrls]; and then used to update the stored ctrl values (if they have changed). Although the optimisation algorithms have a check within them for; function convergence, i.e. local minima, the sum of the squares; of the normalised gradient is checked explicitly, and the; optimisation is terminated if this is below the min_gradient_norm; condition; """"""; # *** update stats ***; self.num_grad_func_calls += 1; if self.stats is not None:; self.stats.num_grad_func_calls = self.num_grad_func_calls; if self.log_level <= logging.DEBUG:; logger.debug(""gradient call {}"".format(; self.stats.num_grad_func_calls)); amps = self._get_ctrl_amps(args[0].copy()); self.dynamics.update_ctrl_amps(amps); fid_comp = self.dynamics.fid_computer; # gradient_norm_func is a pointer to the function set in the config; # that returns the normalised gradients; grad = fid_comp.get_fid_err_gradient(). if self.iter_summary:; self.iter_summary.grad_func_call_num = self.num_grad_func_calls; self.iter_summary.grad_norm = fid_comp.grad_norm. if self.dump:; if self.dump.dump_grad_norm:; self.dump.update_grad_norm_log(fid_comp.grad_norm). if self.dump.dump_grad:; self.dump.update_grad_log(grad). tc = self.termination_conditions; if fid_comp.grad_norm < tc.min_gradient_norm:; raise errors.GradMinReachedTerminate(fid_comp.grad_norm); return grad.flatten(). [docs] def iter_step_callback_func(self, *args):; """"""; Check the elapsed wall time for the optimisation run so far.; Terminate if this has exceeded the maximum allowed time; """"""; self.num_iter += 1. ",MatchSource.WIKI,docs/4.2/modules/qutip/control/optimizer.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/control/optimizer.html
https://qutip.org/docs/4.2/modules/qutip/control/optimizer.html:23670,Testability,log,logging,23670,"ient call {}"".format(; self.stats.num_grad_func_calls)); amps = self._get_ctrl_amps(args[0].copy()); self.dynamics.update_ctrl_amps(amps); fid_comp = self.dynamics.fid_computer; # gradient_norm_func is a pointer to the function set in the config; # that returns the normalised gradients; grad = fid_comp.get_fid_err_gradient(). if self.iter_summary:; self.iter_summary.grad_func_call_num = self.num_grad_func_calls; self.iter_summary.grad_norm = fid_comp.grad_norm. if self.dump:; if self.dump.dump_grad_norm:; self.dump.update_grad_norm_log(fid_comp.grad_norm). if self.dump.dump_grad:; self.dump.update_grad_log(grad). tc = self.termination_conditions; if fid_comp.grad_norm < tc.min_gradient_norm:; raise errors.GradMinReachedTerminate(fid_comp.grad_norm); return grad.flatten(). [docs] def iter_step_callback_func(self, *args):; """"""; Check the elapsed wall time for the optimisation run so far.; Terminate if this has exceeded the maximum allowed time; """"""; self.num_iter += 1. if self.log_level <= logging.DEBUG:; logger.debug(""Iteration callback {}"".format(self.num_iter)). wall_time = timeit.default_timer() - self.wall_time_optimize_start. if self.iter_summary:; self.iter_summary.iter_num = self.num_iter; self.iter_summary.wall_time = wall_time. if self.dump and self.dump.dump_summary:; self.dump.add_iter_summary(). tc = self.termination_conditions. if wall_time > tc.max_wall_time:; raise errors.MaxWallTimeTerminate(). # *** update stats ***; if self.stats is not None:; self.stats.num_iter = self.num_iter. def _interpret_term_exception(self, except_term, result):; """"""; Update the result object based on the exception that occurred; during the optimisation; """"""; result.termination_reason = except_term.reason; if isinstance(except_term, errors.GoalAchievedTerminate):; result.goal_achieved = True; elif isinstance(except_term, errors.MaxWallTimeTerminate):; result.wall_time_limit_exceeded = True; elif isinstance(except_term, errors.GradMinReachedTerminate):; result.grad_norm_min_re",MatchSource.WIKI,docs/4.2/modules/qutip/control/optimizer.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/control/optimizer.html
https://qutip.org/docs/4.2/modules/qutip/control/optimizer.html:23686,Testability,log,logger,23686,"at(; self.stats.num_grad_func_calls)); amps = self._get_ctrl_amps(args[0].copy()); self.dynamics.update_ctrl_amps(amps); fid_comp = self.dynamics.fid_computer; # gradient_norm_func is a pointer to the function set in the config; # that returns the normalised gradients; grad = fid_comp.get_fid_err_gradient(). if self.iter_summary:; self.iter_summary.grad_func_call_num = self.num_grad_func_calls; self.iter_summary.grad_norm = fid_comp.grad_norm. if self.dump:; if self.dump.dump_grad_norm:; self.dump.update_grad_norm_log(fid_comp.grad_norm). if self.dump.dump_grad:; self.dump.update_grad_log(grad). tc = self.termination_conditions; if fid_comp.grad_norm < tc.min_gradient_norm:; raise errors.GradMinReachedTerminate(fid_comp.grad_norm); return grad.flatten(). [docs] def iter_step_callback_func(self, *args):; """"""; Check the elapsed wall time for the optimisation run so far.; Terminate if this has exceeded the maximum allowed time; """"""; self.num_iter += 1. if self.log_level <= logging.DEBUG:; logger.debug(""Iteration callback {}"".format(self.num_iter)). wall_time = timeit.default_timer() - self.wall_time_optimize_start. if self.iter_summary:; self.iter_summary.iter_num = self.num_iter; self.iter_summary.wall_time = wall_time. if self.dump and self.dump.dump_summary:; self.dump.add_iter_summary(). tc = self.termination_conditions. if wall_time > tc.max_wall_time:; raise errors.MaxWallTimeTerminate(). # *** update stats ***; if self.stats is not None:; self.stats.num_iter = self.num_iter. def _interpret_term_exception(self, except_term, result):; """"""; Update the result object based on the exception that occurred; during the optimisation; """"""; result.termination_reason = except_term.reason; if isinstance(except_term, errors.GoalAchievedTerminate):; result.goal_achieved = True; elif isinstance(except_term, errors.MaxWallTimeTerminate):; result.wall_time_limit_exceeded = True; elif isinstance(except_term, errors.GradMinReachedTerminate):; result.grad_norm_min_reached = True; elif",MatchSource.WIKI,docs/4.2/modules/qutip/control/optimizer.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/control/optimizer.html
https://qutip.org/docs/4.2/modules/qutip/control/optimizer.html:26934,Testability,log,logging,26934,"d when one of the passed termination conditions; has been met, e.g. target achieved, gradient minimum met; (local minima), wall time / iteration count exceeded. Essentially this is wrapper to the:; scipy.optimize.fmin_bfgs; function. If the parameter term_conds=None, then the termination_conditions; attribute must already be set. It will be overwritten if the; parameter is not None. The result is returned in an OptimResult object, which includes; the final fidelity, time evolution, reason for termination etc; """"""; self.init_optim(term_conds); term_conds = self.termination_conditions; dyn = self.dynamics; self.optim_var_vals = self._get_optim_var_vals(); self._build_method_options(). st_time = timeit.default_timer(); self.wall_time_optimize_start = st_time. if self.stats is not None:; self.stats.wall_time_optim_start = st_time; self.stats.wall_time_optim_end = 0.0; self.stats.num_iter = 1. if self.approx_grad:; fprime = None; else:; fprime = self.fid_err_grad_wrapper. if self.log_level <= logging.INFO:; msg = (""Optimising pulse(s) using {} with ""; ""'fmin_bfgs' method"").format(self.alg); if self.approx_grad:; msg += "" (approx grad)""; logger.info(msg). result = self._create_result(); try:; optim_var_vals, cost, grad, invHess, nFCalls, nGCalls, warn = \; spopt.fmin_bfgs(self.fid_err_func_wrapper,; self.optim_var_vals,; fprime=fprime,; # approx_grad=self.approx_grad,; callback=self.iter_step_callback_func,; gtol=term_conds.min_gradient_norm,; maxiter=term_conds.max_iterations,; full_output=True, disp=True). amps = self._get_ctrl_amps(optim_var_vals); dyn.update_ctrl_amps(amps); if warn == 1:; result.max_iter_exceeded = True; result.termination_reason = ""Iteration count limit reached""; elif warn == 2:; result.grad_norm_min_reached = True; result.termination_reason = ""Gradient normal minimum reached"". except errors.OptimizationTerminate as except_term:; self._interpret_term_exception(except_term, result). end_time = timeit.default_timer(); self._add_common_result_attribs(re",MatchSource.WIKI,docs/4.2/modules/qutip/control/optimizer.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/control/optimizer.html
https://qutip.org/docs/4.2/modules/qutip/control/optimizer.html:27081,Testability,log,logger,27081," iteration count exceeded. Essentially this is wrapper to the:; scipy.optimize.fmin_bfgs; function. If the parameter term_conds=None, then the termination_conditions; attribute must already be set. It will be overwritten if the; parameter is not None. The result is returned in an OptimResult object, which includes; the final fidelity, time evolution, reason for termination etc; """"""; self.init_optim(term_conds); term_conds = self.termination_conditions; dyn = self.dynamics; self.optim_var_vals = self._get_optim_var_vals(); self._build_method_options(). st_time = timeit.default_timer(); self.wall_time_optimize_start = st_time. if self.stats is not None:; self.stats.wall_time_optim_start = st_time; self.stats.wall_time_optim_end = 0.0; self.stats.num_iter = 1. if self.approx_grad:; fprime = None; else:; fprime = self.fid_err_grad_wrapper. if self.log_level <= logging.INFO:; msg = (""Optimising pulse(s) using {} with ""; ""'fmin_bfgs' method"").format(self.alg); if self.approx_grad:; msg += "" (approx grad)""; logger.info(msg). result = self._create_result(); try:; optim_var_vals, cost, grad, invHess, nFCalls, nGCalls, warn = \; spopt.fmin_bfgs(self.fid_err_func_wrapper,; self.optim_var_vals,; fprime=fprime,; # approx_grad=self.approx_grad,; callback=self.iter_step_callback_func,; gtol=term_conds.min_gradient_norm,; maxiter=term_conds.max_iterations,; full_output=True, disp=True). amps = self._get_ctrl_amps(optim_var_vals); dyn.update_ctrl_amps(amps); if warn == 1:; result.max_iter_exceeded = True; result.termination_reason = ""Iteration count limit reached""; elif warn == 2:; result.grad_norm_min_reached = True; result.termination_reason = ""Gradient normal minimum reached"". except errors.OptimizationTerminate as except_term:; self._interpret_term_exception(except_term, result). end_time = timeit.default_timer(); self._add_common_result_attribs(result, st_time, end_time). return result. [docs]class OptimizerLBFGSB(Optimizer):; """"""; Implements the run_optimization method using t",MatchSource.WIKI,docs/4.2/modules/qutip/control/optimizer.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/control/optimizer.html
https://qutip.org/docs/4.2/modules/qutip/control/optimizer.html:29288,Testability,log,logging,29288,"re used to approximate the Hessian; see the scipy.optimize.fmin_l_bfgs_b documentation for description; of m argument. """""". def reset(self):; Optimizer.reset(self); self.id_text = 'LBFGSB'; self.max_metric_corr = 10; self.msg_level = None. [docs] def init_optim(self, term_conds):; """"""; Check optimiser attribute status and passed parameters before; running the optimisation.; This is called by run_optimization, but could called independently; to check the configuration.; """"""; if term_conds is None:; term_conds = self.termination_conditions. # AJGP 2015-04-21:; # These (copying from config) are here for backward compatibility; if hasattr(self.config, 'max_metric_corr'):; if self.config.max_metric_corr:; self.max_metric_corr = self.config.max_metric_corr; if hasattr(self.config, 'accuracy_factor'):; if self.config.accuracy_factor:; term_conds.accuracy_factor = \; self.config.accuracy_factor. Optimizer.init_optim(self, term_conds). if not isinstance(self.msg_level, int):; if self.log_level < logging.DEBUG:; self.msg_level = 2; elif self.log_level <= logging.DEBUG:; self.msg_level = 1; else:; self.msg_level = 0. [docs] def run_optimization(self, term_conds=None):; """"""; Optimise the control pulse amplitudes to minimise the fidelity error; using the L-BFGS-B algorithm, which is the constrained; (bounded amplitude values), limited memory, version of the; BroydenâFletcherâGoldfarbâShanno algorithm. The optimisation end when one of the passed termination conditions; has been met, e.g. target achieved, gradient minimum met; (local minima), wall time / iteration count exceeded. Essentially this is wrapper to the:; scipy.optimize.fmin_l_bfgs_b function; This in turn is a warpper for well established implementation of; the L-BFGS-B algorithm written in Fortran, which is therefore; very fast. See SciPy documentation for credit and details on; this function. If the parameter term_conds=None, then the termination_conditions; attribute must already be set. It will be overwritten if th",MatchSource.WIKI,docs/4.2/modules/qutip/control/optimizer.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/control/optimizer.html
https://qutip.org/docs/4.2/modules/qutip/control/optimizer.html:29347,Testability,log,logging,29347,".fmin_l_bfgs_b documentation for description; of m argument. """""". def reset(self):; Optimizer.reset(self); self.id_text = 'LBFGSB'; self.max_metric_corr = 10; self.msg_level = None. [docs] def init_optim(self, term_conds):; """"""; Check optimiser attribute status and passed parameters before; running the optimisation.; This is called by run_optimization, but could called independently; to check the configuration.; """"""; if term_conds is None:; term_conds = self.termination_conditions. # AJGP 2015-04-21:; # These (copying from config) are here for backward compatibility; if hasattr(self.config, 'max_metric_corr'):; if self.config.max_metric_corr:; self.max_metric_corr = self.config.max_metric_corr; if hasattr(self.config, 'accuracy_factor'):; if self.config.accuracy_factor:; term_conds.accuracy_factor = \; self.config.accuracy_factor. Optimizer.init_optim(self, term_conds). if not isinstance(self.msg_level, int):; if self.log_level < logging.DEBUG:; self.msg_level = 2; elif self.log_level <= logging.DEBUG:; self.msg_level = 1; else:; self.msg_level = 0. [docs] def run_optimization(self, term_conds=None):; """"""; Optimise the control pulse amplitudes to minimise the fidelity error; using the L-BFGS-B algorithm, which is the constrained; (bounded amplitude values), limited memory, version of the; BroydenâFletcherâGoldfarbâShanno algorithm. The optimisation end when one of the passed termination conditions; has been met, e.g. target achieved, gradient minimum met; (local minima), wall time / iteration count exceeded. Essentially this is wrapper to the:; scipy.optimize.fmin_l_bfgs_b function; This in turn is a warpper for well established implementation of; the L-BFGS-B algorithm written in Fortran, which is therefore; very fast. See SciPy documentation for credit and details on; this function. If the parameter term_conds=None, then the termination_conditions; attribute must already be set. It will be overwritten if the; parameter is not None. The result is returned in an Opti",MatchSource.WIKI,docs/4.2/modules/qutip/control/optimizer.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/control/optimizer.html
https://qutip.org/docs/4.2/modules/qutip/control/optimizer.html:31533,Testability,log,logging,31533,"dynamics; cfg = self.config; self.optim_var_vals = self._get_optim_var_vals(); self._build_method_options(). st_time = timeit.default_timer(); self.wall_time_optimize_start = st_time. if self.stats is not None:; self.stats.wall_time_optim_start = st_time; self.stats.wall_time_optim_end = 0.0; self.stats.num_iter = 1. bounds = self._build_bounds_list(); result = self._create_result(). if self.approx_grad:; fprime = None; else:; fprime = self.fid_err_grad_wrapper. if 'accuracy_factor' in self.method_options:; factr = self.method_options['accuracy_factor']; elif 'ftol' in self.method_options:; factr = self.method_options['ftol']; elif hasattr(term_conds, 'accuracy_factor'):; factr = term_conds.accuracy_factor; else:; factr = 1e7. if 'max_metric_corr' in self.method_options:; m = self.method_options['max_metric_corr']; elif 'maxcor' in self.method_options:; m = self.method_options['maxcor']; elif hasattr(self, 'max_metric_corr'):; m = self.max_metric_corr; else:; m = 10. if self.log_level <= logging.INFO:; msg = (""Optimising pulse(s) using {} with ""; ""'fmin_l_bfgs_b' method"").format(self.alg); if self.approx_grad:; msg += "" (approx grad)""; logger.info(msg); try:; optim_var_vals, fid, res_dict = spopt.fmin_l_bfgs_b(; self.fid_err_func_wrapper, self.optim_var_vals,; fprime=fprime,; approx_grad=self.approx_grad,; callback=self.iter_step_callback_func,; bounds=self.bounds, m=m, factr=factr,; pgtol=term_conds.min_gradient_norm,; disp=self.msg_level,; maxfun=term_conds.max_fid_func_calls,; maxiter=term_conds.max_iterations). amps = self._get_ctrl_amps(optim_var_vals); dyn.update_ctrl_amps(amps); warn = res_dict['warnflag']; if warn == 0:; result.grad_norm_min_reached = True; result.termination_reason = ""function converged""; elif warn == 1:; result.max_iter_exceeded = True; result.termination_reason = (""Iteration or fidelity ""; ""function call limit reached""); elif warn == 2:; result.termination_reason = res_dict['task']. result.num_iter = res_dict['nit']; except errors.Optimiza",MatchSource.WIKI,docs/4.2/modules/qutip/control/optimizer.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/control/optimizer.html
https://qutip.org/docs/4.2/modules/qutip/control/optimizer.html:31684,Testability,log,logger,31684,"r(); self.wall_time_optimize_start = st_time. if self.stats is not None:; self.stats.wall_time_optim_start = st_time; self.stats.wall_time_optim_end = 0.0; self.stats.num_iter = 1. bounds = self._build_bounds_list(); result = self._create_result(). if self.approx_grad:; fprime = None; else:; fprime = self.fid_err_grad_wrapper. if 'accuracy_factor' in self.method_options:; factr = self.method_options['accuracy_factor']; elif 'ftol' in self.method_options:; factr = self.method_options['ftol']; elif hasattr(term_conds, 'accuracy_factor'):; factr = term_conds.accuracy_factor; else:; factr = 1e7. if 'max_metric_corr' in self.method_options:; m = self.method_options['max_metric_corr']; elif 'maxcor' in self.method_options:; m = self.method_options['maxcor']; elif hasattr(self, 'max_metric_corr'):; m = self.max_metric_corr; else:; m = 10. if self.log_level <= logging.INFO:; msg = (""Optimising pulse(s) using {} with ""; ""'fmin_l_bfgs_b' method"").format(self.alg); if self.approx_grad:; msg += "" (approx grad)""; logger.info(msg); try:; optim_var_vals, fid, res_dict = spopt.fmin_l_bfgs_b(; self.fid_err_func_wrapper, self.optim_var_vals,; fprime=fprime,; approx_grad=self.approx_grad,; callback=self.iter_step_callback_func,; bounds=self.bounds, m=m, factr=factr,; pgtol=term_conds.min_gradient_norm,; disp=self.msg_level,; maxfun=term_conds.max_fid_func_calls,; maxiter=term_conds.max_iterations). amps = self._get_ctrl_amps(optim_var_vals); dyn.update_ctrl_amps(amps); warn = res_dict['warnflag']; if warn == 0:; result.grad_norm_min_reached = True; result.termination_reason = ""function converged""; elif warn == 1:; result.max_iter_exceeded = True; result.termination_reason = (""Iteration or fidelity ""; ""function call limit reached""); elif warn == 2:; result.termination_reason = res_dict['task']. result.num_iter = res_dict['nit']; except errors.OptimizationTerminate as except_term:; self._interpret_term_exception(except_term, result). end_time = timeit.default_timer(); self._add_common_r",MatchSource.WIKI,docs/4.2/modules/qutip/control/optimizer.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/control/optimizer.html
https://qutip.org/docs/4.2/modules/qutip/control/optimizer.html:35528,Testability,log,logging,35528,"h control. Here "" + err_msg). def _build_bounds_list(self):; """"""; No bounds necessary here, as the bounds for the CRAB parameters; do not have much physical meaning.; This needs to override the default method, otherwise the shape; will be wrong; """"""; return None. def _get_optim_var_vals(self):; """"""; Generate the 1d array that holds the current variable values; of the function to be optimised; For CRAB these are the basis coefficients; ; Returns; -------; ndarray (1d) of float; ; """"""; pvals = []; for pgen in self.pulse_generator:; pvals.extend(pgen.get_optim_var_vals()). return np.array(pvals). def _get_ctrl_amps(self, optim_var_vals):; """"""; Get the control amplitudes from the current variable values; of the function to be optimised.; that is the 1d array that is passed from the optimisation method; For CRAB the amplitudes will need to calculated by expanding the; series. Returns; -------; float array[dynamics.num_tslots, dynamics.num_ctrls]; """"""; dyn = self.dynamics. if self.log_level <= logging.DEBUG:; changed_params = self.optim_var_vals != optim_var_vals; logger.debug(; ""{} out of {} optimisation parameters changed"".format(; changed_params.sum(), len(optim_var_vals))). amps = np.empty([dyn.num_tslots, dyn.num_ctrls]); j = 0; param_idx_st = 0; for p_gen in self.pulse_generator:; param_idx_end = param_idx_st + p_gen.num_optim_vars; pg_pvals = optim_var_vals[param_idx_st:param_idx_end]; p_gen.set_optim_var_vals(pg_pvals); amps[:, j] = p_gen.gen_pulse(); param_idx_st = param_idx_end; j += 1. #print(""param_idx_end={}"".format(param_idx_end)); self.optim_var_vals = optim_var_vals; return amps. [docs]class OptimizerCrabFmin(OptimizerCrab):; """"""; Optimises the pulse using the CRAB algorithm [1, 2].; It uses the scipy.optimize.fmin function which is effectively a wrapper; for the Nelder-mead method.; It minimises the fidelity error function with respect to the CRAB; basis function coefficients.; This is the default Optimizer for CRAB. Notes; -----; [1] P. Doria, T. Calarco ",MatchSource.WIKI,docs/4.2/modules/qutip/control/optimizer.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/control/optimizer.html
https://qutip.org/docs/4.2/modules/qutip/control/optimizer.html:35600,Testability,log,logger,35600,"""""""; No bounds necessary here, as the bounds for the CRAB parameters; do not have much physical meaning.; This needs to override the default method, otherwise the shape; will be wrong; """"""; return None. def _get_optim_var_vals(self):; """"""; Generate the 1d array that holds the current variable values; of the function to be optimised; For CRAB these are the basis coefficients; ; Returns; -------; ndarray (1d) of float; ; """"""; pvals = []; for pgen in self.pulse_generator:; pvals.extend(pgen.get_optim_var_vals()). return np.array(pvals). def _get_ctrl_amps(self, optim_var_vals):; """"""; Get the control amplitudes from the current variable values; of the function to be optimised.; that is the 1d array that is passed from the optimisation method; For CRAB the amplitudes will need to calculated by expanding the; series. Returns; -------; float array[dynamics.num_tslots, dynamics.num_ctrls]; """"""; dyn = self.dynamics. if self.log_level <= logging.DEBUG:; changed_params = self.optim_var_vals != optim_var_vals; logger.debug(; ""{} out of {} optimisation parameters changed"".format(; changed_params.sum(), len(optim_var_vals))). amps = np.empty([dyn.num_tslots, dyn.num_ctrls]); j = 0; param_idx_st = 0; for p_gen in self.pulse_generator:; param_idx_end = param_idx_st + p_gen.num_optim_vars; pg_pvals = optim_var_vals[param_idx_st:param_idx_end]; p_gen.set_optim_var_vals(pg_pvals); amps[:, j] = p_gen.gen_pulse(); param_idx_st = param_idx_end; j += 1. #print(""param_idx_end={}"".format(param_idx_end)); self.optim_var_vals = optim_var_vals; return amps. [docs]class OptimizerCrabFmin(OptimizerCrab):; """"""; Optimises the pulse using the CRAB algorithm [1, 2].; It uses the scipy.optimize.fmin function which is effectively a wrapper; for the Nelder-mead method.; It minimises the fidelity error function with respect to the CRAB; basis function coefficients.; This is the default Optimizer for CRAB. Notes; -----; [1] P. Doria, T. Calarco & S. Montangero. Phys. Rev. Lett. 106,; 190501 (2011).; [2] T",MatchSource.WIKI,docs/4.2/modules/qutip/control/optimizer.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/control/optimizer.html
https://qutip.org/docs/4.2/modules/qutip/control/optimizer.html:38222,Testability,log,logging,38222," or; function call or iteration count exceeded. Specifically to the fmin; method, the optimisation will stop when change parameter values; is less than xtol or the change in function value is below ftol. If the parameter term_conds=None, then the termination_conditions; attribute must already be set. It will be overwritten if the; parameter is not None. The result is returned in an OptimResult object, which includes; the final fidelity, time evolution, reason for termination etc; """"""; self.init_optim(term_conds); term_conds = self.termination_conditions; dyn = self.dynamics; cfg = self.config; self.optim_var_vals = self._get_optim_var_vals(); self._build_method_options(). #print(""Initial values:\n{}"".format(self.optim_var_vals)); st_time = timeit.default_timer(); self.wall_time_optimize_start = st_time. if self.stats is not None:; self.stats.wall_time_optim_start = st_time; self.stats.wall_time_optim_end = 0.0; self.stats.num_iter = 1. result = self._create_result(). if self.log_level <= logging.INFO:; logger.info(""Optimising pulse(s) using {} with ""; ""'fmin' (Nelder-Mead) method"".format(self.alg)). try:; ret = spopt.fmin(; self.fid_err_func_wrapper, self.optim_var_vals,; xtol=self.xtol, ftol=self.ftol,; maxiter=term_conds.max_iterations,; maxfun=term_conds.max_fid_func_calls,; full_output=True, disp=self.disp_conv_msg,; retall=self.record_iteration_steps,; callback=self.iter_step_callback_func). final_param_vals = ret[0]; num_iter = ret[2]; warn_flag = ret[4]; if self.record_iteration_steps:; self.iteration_steps = ret[5]; amps = self._get_ctrl_amps(final_param_vals); dyn.update_ctrl_amps(amps). # Note the iterations are counted in this object as well; # so there are compared here for interest sake only; if self.num_iter != num_iter:; logger.info(""The number of iterations counted {} ""; "" does not match the number reported {} ""; ""by {}"".format(self.num_iter, num_iter,; self.method)); result.num_iter = num_iter; if warn_flag == 0:; result.termination_reason = \; ""Func",MatchSource.WIKI,docs/4.2/modules/qutip/control/optimizer.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/control/optimizer.html
https://qutip.org/docs/4.2/modules/qutip/control/optimizer.html:38237,Testability,log,logger,38237," or iteration count exceeded. Specifically to the fmin; method, the optimisation will stop when change parameter values; is less than xtol or the change in function value is below ftol. If the parameter term_conds=None, then the termination_conditions; attribute must already be set. It will be overwritten if the; parameter is not None. The result is returned in an OptimResult object, which includes; the final fidelity, time evolution, reason for termination etc; """"""; self.init_optim(term_conds); term_conds = self.termination_conditions; dyn = self.dynamics; cfg = self.config; self.optim_var_vals = self._get_optim_var_vals(); self._build_method_options(). #print(""Initial values:\n{}"".format(self.optim_var_vals)); st_time = timeit.default_timer(); self.wall_time_optimize_start = st_time. if self.stats is not None:; self.stats.wall_time_optim_start = st_time; self.stats.wall_time_optim_end = 0.0; self.stats.num_iter = 1. result = self._create_result(). if self.log_level <= logging.INFO:; logger.info(""Optimising pulse(s) using {} with ""; ""'fmin' (Nelder-Mead) method"".format(self.alg)). try:; ret = spopt.fmin(; self.fid_err_func_wrapper, self.optim_var_vals,; xtol=self.xtol, ftol=self.ftol,; maxiter=term_conds.max_iterations,; maxfun=term_conds.max_fid_func_calls,; full_output=True, disp=self.disp_conv_msg,; retall=self.record_iteration_steps,; callback=self.iter_step_callback_func). final_param_vals = ret[0]; num_iter = ret[2]; warn_flag = ret[4]; if self.record_iteration_steps:; self.iteration_steps = ret[5]; amps = self._get_ctrl_amps(final_param_vals); dyn.update_ctrl_amps(amps). # Note the iterations are counted in this object as well; # so there are compared here for interest sake only; if self.num_iter != num_iter:; logger.info(""The number of iterations counted {} ""; "" does not match the number reported {} ""; ""by {}"".format(self.num_iter, num_iter,; self.method)); result.num_iter = num_iter; if warn_flag == 0:; result.termination_reason = \; ""Function converged (w",MatchSource.WIKI,docs/4.2/modules/qutip/control/optimizer.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/control/optimizer.html
https://qutip.org/docs/4.2/modules/qutip/control/optimizer.html:38985,Testability,log,logger,38985,"efault_timer(); self.wall_time_optimize_start = st_time. if self.stats is not None:; self.stats.wall_time_optim_start = st_time; self.stats.wall_time_optim_end = 0.0; self.stats.num_iter = 1. result = self._create_result(). if self.log_level <= logging.INFO:; logger.info(""Optimising pulse(s) using {} with ""; ""'fmin' (Nelder-Mead) method"".format(self.alg)). try:; ret = spopt.fmin(; self.fid_err_func_wrapper, self.optim_var_vals,; xtol=self.xtol, ftol=self.ftol,; maxiter=term_conds.max_iterations,; maxfun=term_conds.max_fid_func_calls,; full_output=True, disp=self.disp_conv_msg,; retall=self.record_iteration_steps,; callback=self.iter_step_callback_func). final_param_vals = ret[0]; num_iter = ret[2]; warn_flag = ret[4]; if self.record_iteration_steps:; self.iteration_steps = ret[5]; amps = self._get_ctrl_amps(final_param_vals); dyn.update_ctrl_amps(amps). # Note the iterations are counted in this object as well; # so there are compared here for interest sake only; if self.num_iter != num_iter:; logger.info(""The number of iterations counted {} ""; "" does not match the number reported {} ""; ""by {}"".format(self.num_iter, num_iter,; self.method)); result.num_iter = num_iter; if warn_flag == 0:; result.termination_reason = \; ""Function converged (within tolerance)""; elif warn_flag == 1:; result.termination_reason = \; ""Maximum number of function evaluations reached""; result.max_fid_func_exceeded = True; elif warn_flag == 2:; result.termination_reason = \; ""Maximum number of iterations reached""; result.max_iter_exceeded = True; else:; result.termination_reason = \; ""Unknown (warn_flag={})"".format(warn_flag). except errors.OptimizationTerminate as except_term:; self._interpret_term_exception(except_term, result). end_time = timeit.default_timer(); self._add_common_result_attribs(result, st_time, end_time). return result. [docs]class OptimIterSummary(qtrldump.DumpSummaryItem):; """"""A summary of the most recent iteration of the pulse optimisation. Attributes; ----------; iter_nu",MatchSource.WIKI,docs/4.2/modules/qutip/control/optimizer.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/control/optimizer.html
https://qutip.org/docs/4.2/modules/qutip/control/optimizer.html:13898,Usability,clear,clear,13898,"e optimisation.; This is called by run_optimization, but could called independently; to check the configuration.; """"""; if term_conds is not None:; self.termination_conditions = term_conds; term_conds = self.termination_conditions. if not isinstance(term_conds, termcond.TerminationConditions):; raise errors.UsageError(""No termination conditions for the ""; ""optimisation function""). if not isinstance(self.dynamics, dynamics.Dynamics):; raise errors.UsageError(""No dynamics object attribute set""); self.dynamics.check_ctrls_initialized(). self.apply_method_params(). if term_conds.fid_err_targ is None and term_conds.fid_goal is None:; raise errors.UsageError(""Either the goal or the fidelity ""; ""error tolerance must be set""). if term_conds.fid_err_targ is None:; term_conds.fid_err_targ = np.abs(1 - term_conds.fid_goal). if term_conds.fid_goal is None:; term_conds.fid_goal = 1 - term_conds.fid_err_targ. if self.alg == 'CRAB':; self.approx_grad = True. if self.stats is not None:; self.stats.clear(). if self.dump_to_file:; if self.dump is None:; self.dumping = 'SUMMARY'; self.dump.write_to_file = True; self.dump.create_dump_dir(); logger.info(""Optimiser dump will be written to:\n{}"".format(; self.dump.dump_dir)). if self.dump:; self.iter_summary = OptimIterSummary(); else:; self.iter_summary = None. self.num_iter = 0; self.num_fid_func_calls = 0; self.num_grad_func_calls = 0; self.iteration_steps = None. def _build_method_options(self):; """"""; Creates the method_options dictionary for the scipy.optimize.minimize; function based on the attributes of this object and the; termination_conditions; It assumes that apply_method_params has already been run and; hence the method_options attribute may already contain items.; These values will NOT be overridden; """"""; tc = self.termination_conditions; if self.method_options is None:; self.method_options = {}; mo = self.method_options. if 'max_metric_corr' in mo and not 'maxcor' in mo:; mo['maxcor'] = mo['max_metric_corr']; elif hasattr(sel",MatchSource.WIKI,docs/4.2/modules/qutip/control/optimizer.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/control/optimizer.html
https://qutip.org/docs/4.2/modules/qutip/control/optimresult.html:2666,Availability,error,error,2666,"OODS OR SERVICES; LOSS OF USE,; # DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY; # THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT; # (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE; # OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.; ###############################################################################. # @author: Alexander Pitchford; # @email1: agp1@aber.ac.uk; # @email2: alex.pitchford@gmail.com; # @organization: Aberystwyth University; # @supervisor: Daniel Burgarth. """"""; Class containing the results of the pulse optimisation; """""". import numpy as np. [docs]class OptimResult(object):; """"""; Attributes give the result of the pulse optimisation attempt. Attributes; ----------; termination_reason : string; Description of the reason for terminating the optimisation. fidelity : float; final (normalised) fidelity that was achieved. initial_fid_err : float; fidelity error before optimisation starting; ; fid_err : float; final fidelity error that was achieved. goal_achieved : boolean; True is the fidely error achieved was below the target. grad_norm_final : float; Final value of the sum of the squares of the (normalised) fidelity; error gradients. grad_norm_min_reached : float; True if the optimisation terminated due to the minimum value; of the gradient being reached. num_iter : integer; Number of iterations of the optimisation algorithm completed. max_iter_exceeded : boolean; True if the iteration limit was reached; ; max_fid_func_exceeded : boolean; True if the fidelity function call limit was reached. wall_time : float; time elapsed during the optimisation. wall_time_limit_exceeded : boolean; True if the wall time limit was reached. time : array[num_tslots+1] of float; Time are the start of each timeslot; with the final value being the total evolution time. initial_amps : array[num_tslots, n_ctrls]; The amplitudes at the start of the optimisation. final_amps : array[num_tsl",MatchSource.WIKI,docs/4.2/modules/qutip/control/optimresult.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/control/optimresult.html
https://qutip.org/docs/4.2/modules/qutip/control/optimresult.html:2736,Availability,error,error,2736,"OODS OR SERVICES; LOSS OF USE,; # DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY; # THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT; # (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE; # OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.; ###############################################################################. # @author: Alexander Pitchford; # @email1: agp1@aber.ac.uk; # @email2: alex.pitchford@gmail.com; # @organization: Aberystwyth University; # @supervisor: Daniel Burgarth. """"""; Class containing the results of the pulse optimisation; """""". import numpy as np. [docs]class OptimResult(object):; """"""; Attributes give the result of the pulse optimisation attempt. Attributes; ----------; termination_reason : string; Description of the reason for terminating the optimisation. fidelity : float; final (normalised) fidelity that was achieved. initial_fid_err : float; fidelity error before optimisation starting; ; fid_err : float; final fidelity error that was achieved. goal_achieved : boolean; True is the fidely error achieved was below the target. grad_norm_final : float; Final value of the sum of the squares of the (normalised) fidelity; error gradients. grad_norm_min_reached : float; True if the optimisation terminated due to the minimum value; of the gradient being reached. num_iter : integer; Number of iterations of the optimisation algorithm completed. max_iter_exceeded : boolean; True if the iteration limit was reached; ; max_fid_func_exceeded : boolean; True if the fidelity function call limit was reached. wall_time : float; time elapsed during the optimisation. wall_time_limit_exceeded : boolean; True if the wall time limit was reached. time : array[num_tslots+1] of float; Time are the start of each timeslot; with the final value being the total evolution time. initial_amps : array[num_tslots, n_ctrls]; The amplitudes at the start of the optimisation. final_amps : array[num_tsl",MatchSource.WIKI,docs/4.2/modules/qutip/control/optimresult.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/control/optimresult.html
https://qutip.org/docs/4.2/modules/qutip/control/optimresult.html:2805,Availability,error,error,2805,"# THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT; # (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE; # OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.; ###############################################################################. # @author: Alexander Pitchford; # @email1: agp1@aber.ac.uk; # @email2: alex.pitchford@gmail.com; # @organization: Aberystwyth University; # @supervisor: Daniel Burgarth. """"""; Class containing the results of the pulse optimisation; """""". import numpy as np. [docs]class OptimResult(object):; """"""; Attributes give the result of the pulse optimisation attempt. Attributes; ----------; termination_reason : string; Description of the reason for terminating the optimisation. fidelity : float; final (normalised) fidelity that was achieved. initial_fid_err : float; fidelity error before optimisation starting; ; fid_err : float; final fidelity error that was achieved. goal_achieved : boolean; True is the fidely error achieved was below the target. grad_norm_final : float; Final value of the sum of the squares of the (normalised) fidelity; error gradients. grad_norm_min_reached : float; True if the optimisation terminated due to the minimum value; of the gradient being reached. num_iter : integer; Number of iterations of the optimisation algorithm completed. max_iter_exceeded : boolean; True if the iteration limit was reached; ; max_fid_func_exceeded : boolean; True if the fidelity function call limit was reached. wall_time : float; time elapsed during the optimisation. wall_time_limit_exceeded : boolean; True if the wall time limit was reached. time : array[num_tslots+1] of float; Time are the start of each timeslot; with the final value being the total evolution time. initial_amps : array[num_tslots, n_ctrls]; The amplitudes at the start of the optimisation. final_amps : array[num_tslots, n_ctrls]; The amplitudes at the end of the optimisation. evo_full_final : Qobj; The evolution operat",MatchSource.WIKI,docs/4.2/modules/qutip/control/optimresult.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/control/optimresult.html
https://qutip.org/docs/4.2/modules/qutip/control/optimresult.html:2935,Availability,error,error,2935,"R OTHERWISE) ARISING IN ANY WAY OUT OF THE USE; # OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.; ###############################################################################. # @author: Alexander Pitchford; # @email1: agp1@aber.ac.uk; # @email2: alex.pitchford@gmail.com; # @organization: Aberystwyth University; # @supervisor: Daniel Burgarth. """"""; Class containing the results of the pulse optimisation; """""". import numpy as np. [docs]class OptimResult(object):; """"""; Attributes give the result of the pulse optimisation attempt. Attributes; ----------; termination_reason : string; Description of the reason for terminating the optimisation. fidelity : float; final (normalised) fidelity that was achieved. initial_fid_err : float; fidelity error before optimisation starting; ; fid_err : float; final fidelity error that was achieved. goal_achieved : boolean; True is the fidely error achieved was below the target. grad_norm_final : float; Final value of the sum of the squares of the (normalised) fidelity; error gradients. grad_norm_min_reached : float; True if the optimisation terminated due to the minimum value; of the gradient being reached. num_iter : integer; Number of iterations of the optimisation algorithm completed. max_iter_exceeded : boolean; True if the iteration limit was reached; ; max_fid_func_exceeded : boolean; True if the fidelity function call limit was reached. wall_time : float; time elapsed during the optimisation. wall_time_limit_exceeded : boolean; True if the wall time limit was reached. time : array[num_tslots+1] of float; Time are the start of each timeslot; with the final value being the total evolution time. initial_amps : array[num_tslots, n_ctrls]; The amplitudes at the start of the optimisation. final_amps : array[num_tslots, n_ctrls]; The amplitudes at the end of the optimisation. evo_full_final : Qobj; The evolution operator from t=0 to t=T based on the final amps. stats : Stats; Object contaning the stats for the r",MatchSource.WIKI,docs/4.2/modules/qutip/control/optimresult.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/control/optimresult.html
https://qutip.org/docs/4.2/modules/qutip/control/optimresult.html:4695,Deployability,update,updated,4695,"n; True is the fidely error achieved was below the target. grad_norm_final : float; Final value of the sum of the squares of the (normalised) fidelity; error gradients. grad_norm_min_reached : float; True if the optimisation terminated due to the minimum value; of the gradient being reached. num_iter : integer; Number of iterations of the optimisation algorithm completed. max_iter_exceeded : boolean; True if the iteration limit was reached; ; max_fid_func_exceeded : boolean; True if the fidelity function call limit was reached. wall_time : float; time elapsed during the optimisation. wall_time_limit_exceeded : boolean; True if the wall time limit was reached. time : array[num_tslots+1] of float; Time are the start of each timeslot; with the final value being the total evolution time. initial_amps : array[num_tslots, n_ctrls]; The amplitudes at the start of the optimisation. final_amps : array[num_tslots, n_ctrls]; The amplitudes at the end of the optimisation. evo_full_final : Qobj; The evolution operator from t=0 to t=T based on the final amps. stats : Stats; Object contaning the stats for the run (if any collected); ; optimizer : Optimizer; Instance of the Optimizer used to generate the result; """"""; def __init__(self):; self.reset(). def reset(self):; self.fidelity = 0.0; self.initial_fid_err = np.Inf; self.fid_err = np.Inf; self.goal_achieved = False; self.grad_norm_final = 0.0; self.grad_norm_min_reached = False; self.num_iter = 0; self.max_iter_exceeded = False; self.num_fid_func_calls = 0; self.max_fid_func_exceeded = False; self.wall_time = 0.0; self.wall_time_limit_exceeded = False; self.termination_reason = ""not started yet""; self.time = None; self.initial_amps = None; self.final_amps = None; self.evo_full_final = None; self.stats = None; self.optimizer = None. Â© Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, and A.L. Grimsmo.; Last updated on Jan 17, 2018. . Built with Sphinx using a theme provided by Read the Docs. . ",MatchSource.WIKI,docs/4.2/modules/qutip/control/optimresult.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/control/optimresult.html
https://qutip.org/docs/4.2/modules/qutip/control/optimresult.html:3921,Performance,optimiz,optimizer,3921,"n; True is the fidely error achieved was below the target. grad_norm_final : float; Final value of the sum of the squares of the (normalised) fidelity; error gradients. grad_norm_min_reached : float; True if the optimisation terminated due to the minimum value; of the gradient being reached. num_iter : integer; Number of iterations of the optimisation algorithm completed. max_iter_exceeded : boolean; True if the iteration limit was reached; ; max_fid_func_exceeded : boolean; True if the fidelity function call limit was reached. wall_time : float; time elapsed during the optimisation. wall_time_limit_exceeded : boolean; True if the wall time limit was reached. time : array[num_tslots+1] of float; Time are the start of each timeslot; with the final value being the total evolution time. initial_amps : array[num_tslots, n_ctrls]; The amplitudes at the start of the optimisation. final_amps : array[num_tslots, n_ctrls]; The amplitudes at the end of the optimisation. evo_full_final : Qobj; The evolution operator from t=0 to t=T based on the final amps. stats : Stats; Object contaning the stats for the run (if any collected); ; optimizer : Optimizer; Instance of the Optimizer used to generate the result; """"""; def __init__(self):; self.reset(). def reset(self):; self.fidelity = 0.0; self.initial_fid_err = np.Inf; self.fid_err = np.Inf; self.goal_achieved = False; self.grad_norm_final = 0.0; self.grad_norm_min_reached = False; self.num_iter = 0; self.max_iter_exceeded = False; self.num_fid_func_calls = 0; self.max_fid_func_exceeded = False; self.wall_time = 0.0; self.wall_time_limit_exceeded = False; self.termination_reason = ""not started yet""; self.time = None; self.initial_amps = None; self.final_amps = None; self.evo_full_final = None; self.stats = None; self.optimizer = None. Â© Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, and A.L. Grimsmo.; Last updated on Jan 17, 2018. . Built with Sphinx using a theme provided by Read the Docs. . ",MatchSource.WIKI,docs/4.2/modules/qutip/control/optimresult.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/control/optimresult.html
https://qutip.org/docs/4.2/modules/qutip/control/optimresult.html:4566,Performance,optimiz,optimizer,4566,"n; True is the fidely error achieved was below the target. grad_norm_final : float; Final value of the sum of the squares of the (normalised) fidelity; error gradients. grad_norm_min_reached : float; True if the optimisation terminated due to the minimum value; of the gradient being reached. num_iter : integer; Number of iterations of the optimisation algorithm completed. max_iter_exceeded : boolean; True if the iteration limit was reached; ; max_fid_func_exceeded : boolean; True if the fidelity function call limit was reached. wall_time : float; time elapsed during the optimisation. wall_time_limit_exceeded : boolean; True if the wall time limit was reached. time : array[num_tslots+1] of float; Time are the start of each timeslot; with the final value being the total evolution time. initial_amps : array[num_tslots, n_ctrls]; The amplitudes at the start of the optimisation. final_amps : array[num_tslots, n_ctrls]; The amplitudes at the end of the optimisation. evo_full_final : Qobj; The evolution operator from t=0 to t=T based on the final amps. stats : Stats; Object contaning the stats for the run (if any collected); ; optimizer : Optimizer; Instance of the Optimizer used to generate the result; """"""; def __init__(self):; self.reset(). def reset(self):; self.fidelity = 0.0; self.initial_fid_err = np.Inf; self.fid_err = np.Inf; self.goal_achieved = False; self.grad_norm_final = 0.0; self.grad_norm_min_reached = False; self.num_iter = 0; self.max_iter_exceeded = False; self.num_fid_func_calls = 0; self.max_fid_func_exceeded = False; self.wall_time = 0.0; self.wall_time_limit_exceeded = False; self.termination_reason = ""not started yet""; self.time = None; self.initial_amps = None; self.final_amps = None; self.evo_full_final = None; self.stats = None; self.optimizer = None. Â© Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, and A.L. Grimsmo.; Last updated on Jan 17, 2018. . Built with Sphinx using a theme provided by Read the Docs. . ",MatchSource.WIKI,docs/4.2/modules/qutip/control/optimresult.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/control/optimresult.html
https://qutip.org/docs/4.2/modules/qutip/control/propcomp.html:2826,Availability,error,errors,2826,"IN CONTRACT, STRICT LIABILITY, OR TORT; # (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE; # OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.; ###############################################################################. # @author: Alexander Pitchford; # @email1: agp1@aber.ac.uk; # @email2: alex.pitchford@gmail.com; # @organization: Aberystwyth University; # @supervisor: Daniel Burgarth. """"""; Propagator Computer; Classes used to calculate the propagators,; and also the propagator gradient when exact gradient methods are used. Note the methods in the _Diag class was inspired by:; DYNAMO - Dynamic Framework for Quantum Optimal Control; See Machnes et.al., arXiv.1011.4874; """""". # import os; import warnings; import numpy as np; import scipy.linalg as la; import scipy.sparse as sp; # QuTiP; from qutip import Qobj; # QuTiP logging; import qutip.logging_utils as logging; logger = logging.get_logger(); # QuTiP control modules; from qutip.control import errors. def _func_deprecation(message, stacklevel=3):; """"""; Issue deprecation warning; Using stacklevel=3 will ensure message refers the function; calling with the deprecated parameter,; """"""; warnings.warn(message, DeprecationWarning, stacklevel=stacklevel). [docs]class PropagatorComputer(object):; """"""; Base for all Propagator Computer classes; that are used to calculate the propagators,; and also the propagator gradient when exact gradient methods are used; Note: they must be instantiated with a Dynamics object, that is the; container for the data that the functions operate on; This base class cannot be used directly. See subclass descriptions; and choose the appropriate one for the application. Attributes; ----------; log_level : integer; level of messaging output from the logger.; Options are attributes of qutip_utils.logging,; in decreasing levels of messaging, are:; DEBUG_INTENSE, DEBUG_VERBOSE, DEBUG, INFO, WARN, ERROR, CRITICAL; Anything WARN or above is effectively 'quiet' ",MatchSource.WIKI,docs/4.2/modules/qutip/control/propcomp.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/control/propcomp.html
https://qutip.org/docs/4.2/modules/qutip/control/propcomp.html:6235,Availability,error,errors,6235,"he logger; that is call logger.setLevel(lvl); """"""; logger.setLevel(lvl). def grad_exact(self):; return self._grad_exact. def compute_propagator(self, k):; _func_deprecation(""'compute_propagator' has been replaced ""; ""by '_compute_propagator'""); return self._compute_propagator(k); ; def _compute_propagator(self, k):; """"""; calculate the progator between X(k) and X(k+1); Uses matrix expm of the dyn_gen at that point (in time); Assumes that the dyn_gen have been been calculated,; i.e. drift and ctrls combined; Return the propagator; """"""; dyn = self.parent; dgt = dyn._get_phased_dyn_gen(k)*dyn.tau[k]; if dyn.oper_dtype == Qobj:; prop = dgt.expm(); else:; prop = la.expm(dgt); return prop. def compute_diff_prop(self, k, j, epsilon):; _func_deprecation(""'compute_diff_prop' has been replaced ""; ""by '_compute_diff_prop'""); return self._compute_diff_prop( k, j, epsilon). def _compute_diff_prop(self, k, j, epsilon):; """"""; Calculate the propagator from the current point to a trial point; a distance 'epsilon' (change in amplitude); in the direction the given control j in timeslot k; Returns the propagator; """"""; raise errors.UsageError(""Not implemented in the baseclass.""; "" Choose a subclass""). def compute_prop_grad(self, k, j, compute_prop=True):; _func_deprecation(""'compute_prop_grad' has been replaced ""; ""by '_compute_prop_grad'""); return self._compute_prop_grad(self, k, j, compute_prop=compute_prop). def _compute_prop_grad(self, k, j, compute_prop=True):; """"""; Calculate the gradient of propagator wrt the control amplitude; in the timeslot.; """"""; raise errors.UsageError(""Not implemented in the baseclass.""; "" Choose a subclass""). [docs]class PropCompApproxGrad(PropagatorComputer):; """"""; This subclass can be used when the propagator is calculated simply; by expm of the dynamics generator, i.e. when gradients will be calculated; using approximate methods.; """""". [docs] def reset(self):; """"""; reset any configuration data; """"""; PropagatorComputer.reset(self); self.id_text = 'APPROX';",MatchSource.WIKI,docs/4.2/modules/qutip/control/propcomp.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/control/propcomp.html
https://qutip.org/docs/4.2/modules/qutip/control/propcomp.html:6681,Availability,error,errors,6681," dyn._get_phased_dyn_gen(k)*dyn.tau[k]; if dyn.oper_dtype == Qobj:; prop = dgt.expm(); else:; prop = la.expm(dgt); return prop. def compute_diff_prop(self, k, j, epsilon):; _func_deprecation(""'compute_diff_prop' has been replaced ""; ""by '_compute_diff_prop'""); return self._compute_diff_prop( k, j, epsilon). def _compute_diff_prop(self, k, j, epsilon):; """"""; Calculate the propagator from the current point to a trial point; a distance 'epsilon' (change in amplitude); in the direction the given control j in timeslot k; Returns the propagator; """"""; raise errors.UsageError(""Not implemented in the baseclass.""; "" Choose a subclass""). def compute_prop_grad(self, k, j, compute_prop=True):; _func_deprecation(""'compute_prop_grad' has been replaced ""; ""by '_compute_prop_grad'""); return self._compute_prop_grad(self, k, j, compute_prop=compute_prop). def _compute_prop_grad(self, k, j, compute_prop=True):; """"""; Calculate the gradient of propagator wrt the control amplitude; in the timeslot.; """"""; raise errors.UsageError(""Not implemented in the baseclass.""; "" Choose a subclass""). [docs]class PropCompApproxGrad(PropagatorComputer):; """"""; This subclass can be used when the propagator is calculated simply; by expm of the dynamics generator, i.e. when gradients will be calculated; using approximate methods.; """""". [docs] def reset(self):; """"""; reset any configuration data; """"""; PropagatorComputer.reset(self); self.id_text = 'APPROX'; self.grad_exact = False; self.apply_params(). def _compute_diff_prop(self, k, j, epsilon):; """"""; Calculate the propagator from the current point to a trial point; a distance 'epsilon' (change in amplitude); in the direction the given control j in timeslot k; Returns the propagator; """"""; dyn = self.parent; dgt_eps = (dyn._get_phased_dyn_gen(k) +; epsilon*dyn._get_phased_ctrl_dyn_gen(k, j))*dyn.tau[k]. if dyn.oper_dtype == Qobj:; prop_eps = dgt_eps.expm(); else:; prop_eps = la.expm(dgt_eps). return prop_eps. [docs]class PropCompDiag(PropagatorComputer):; """""";",MatchSource.WIKI,docs/4.2/modules/qutip/control/propcomp.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/control/propcomp.html
https://qutip.org/docs/4.2/modules/qutip/control/propcomp.html:4323,Deployability,configurat,configuration,4323,"ted with a Dynamics object, that is the; container for the data that the functions operate on; This base class cannot be used directly. See subclass descriptions; and choose the appropriate one for the application. Attributes; ----------; log_level : integer; level of messaging output from the logger.; Options are attributes of qutip_utils.logging,; in decreasing levels of messaging, are:; DEBUG_INTENSE, DEBUG_VERBOSE, DEBUG, INFO, WARN, ERROR, CRITICAL; Anything WARN or above is effectively 'quiet' execution,; assuming everything runs as expected.; The default NOTSET implies that the level will be taken from; the QuTiP settings file, which by default is WARN. grad_exact : boolean; indicates whether the computer class instance is capable; of computing propagator gradients. It is used to determine; whether to create the Dynamics prop_grad array; """"""; def __init__(self, dynamics, params=None):; self.parent = dynamics; self.params = params; self.reset(). [docs] def reset(self):; """"""; reset any configuration data; """"""; self.id_text = 'PROP_COMP_BASE'; self.log_level = self.parent.log_level; self._grad_exact = False. [docs] def apply_params(self, params=None):; """"""; Set object attributes based on the dictionary (if any) passed in the; instantiation, or passed as a parameter; This is called during the instantiation automatically.; The key value pairs are the attribute name and value; Note: attributes are created if they do not exist already,; and are overwritten if they do.; """"""; if not params:; params = self.params. if isinstance(params, dict):; self.params = params; for key in params:; setattr(self, key, params[key]). @property; def log_level(self):; return logger.level. @log_level.setter; def log_level(self, lvl):; """"""; Set the log_level attribute and set the level of the logger; that is call logger.setLevel(lvl); """"""; logger.setLevel(lvl). def grad_exact(self):; return self._grad_exact. def compute_propagator(self, k):; _func_deprecation(""'compute_propagator' has been ",MatchSource.WIKI,docs/4.2/modules/qutip/control/propcomp.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/control/propcomp.html
https://qutip.org/docs/4.2/modules/qutip/control/propcomp.html:7033,Deployability,configurat,configuration,7033,"""""; Calculate the propagator from the current point to a trial point; a distance 'epsilon' (change in amplitude); in the direction the given control j in timeslot k; Returns the propagator; """"""; raise errors.UsageError(""Not implemented in the baseclass.""; "" Choose a subclass""). def compute_prop_grad(self, k, j, compute_prop=True):; _func_deprecation(""'compute_prop_grad' has been replaced ""; ""by '_compute_prop_grad'""); return self._compute_prop_grad(self, k, j, compute_prop=compute_prop). def _compute_prop_grad(self, k, j, compute_prop=True):; """"""; Calculate the gradient of propagator wrt the control amplitude; in the timeslot.; """"""; raise errors.UsageError(""Not implemented in the baseclass.""; "" Choose a subclass""). [docs]class PropCompApproxGrad(PropagatorComputer):; """"""; This subclass can be used when the propagator is calculated simply; by expm of the dynamics generator, i.e. when gradients will be calculated; using approximate methods.; """""". [docs] def reset(self):; """"""; reset any configuration data; """"""; PropagatorComputer.reset(self); self.id_text = 'APPROX'; self.grad_exact = False; self.apply_params(). def _compute_diff_prop(self, k, j, epsilon):; """"""; Calculate the propagator from the current point to a trial point; a distance 'epsilon' (change in amplitude); in the direction the given control j in timeslot k; Returns the propagator; """"""; dyn = self.parent; dgt_eps = (dyn._get_phased_dyn_gen(k) +; epsilon*dyn._get_phased_ctrl_dyn_gen(k, j))*dyn.tau[k]. if dyn.oper_dtype == Qobj:; prop_eps = dgt_eps.expm(); else:; prop_eps = la.expm(dgt_eps). return prop_eps. [docs]class PropCompDiag(PropagatorComputer):; """"""; Coumputes the propagator exponentiation using diagonalisation of; of the dynamics generator; """"""; [docs] def reset(self):; """"""; reset any configuration data; """"""; PropagatorComputer.reset(self); self.id_text = 'DIAG'; self.grad_exact = True; self.apply_params(). def _compute_propagator(self, k):; """"""; Calculates the exponentiation of the dynamics generat",MatchSource.WIKI,docs/4.2/modules/qutip/control/propcomp.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/control/propcomp.html
https://qutip.org/docs/4.2/modules/qutip/control/propcomp.html:7817,Deployability,configurat,configuration,7817,"e a subclass""). [docs]class PropCompApproxGrad(PropagatorComputer):; """"""; This subclass can be used when the propagator is calculated simply; by expm of the dynamics generator, i.e. when gradients will be calculated; using approximate methods.; """""". [docs] def reset(self):; """"""; reset any configuration data; """"""; PropagatorComputer.reset(self); self.id_text = 'APPROX'; self.grad_exact = False; self.apply_params(). def _compute_diff_prop(self, k, j, epsilon):; """"""; Calculate the propagator from the current point to a trial point; a distance 'epsilon' (change in amplitude); in the direction the given control j in timeslot k; Returns the propagator; """"""; dyn = self.parent; dgt_eps = (dyn._get_phased_dyn_gen(k) +; epsilon*dyn._get_phased_ctrl_dyn_gen(k, j))*dyn.tau[k]. if dyn.oper_dtype == Qobj:; prop_eps = dgt_eps.expm(); else:; prop_eps = la.expm(dgt_eps). return prop_eps. [docs]class PropCompDiag(PropagatorComputer):; """"""; Coumputes the propagator exponentiation using diagonalisation of; of the dynamics generator; """"""; [docs] def reset(self):; """"""; reset any configuration data; """"""; PropagatorComputer.reset(self); self.id_text = 'DIAG'; self.grad_exact = True; self.apply_params(). def _compute_propagator(self, k):; """"""; Calculates the exponentiation of the dynamics generator (H); As part of the calc the the eigen decomposition is required, which; is reused in the propagator gradient calculation; """"""; dyn = self.parent; dyn._ensure_decomp_curr(k). if dyn.oper_dtype == Qobj:. prop = (dyn._dyn_gen_eigenvectors[k]*dyn._prop_eigen[k]*; dyn._get_dyn_gen_eigenvectors_adj(k)); else:; prop = dyn._dyn_gen_eigenvectors[k].dot(; dyn._prop_eigen[k]).dot(; dyn._get_dyn_gen_eigenvectors_adj(k)). return prop. def _compute_prop_grad(self, k, j, compute_prop=True):; """"""; Calculate the gradient of propagator wrt the control amplitude; in the timeslot. Returns:; [prop], prop_grad; """"""; dyn = self.parent; dyn._ensure_decomp_curr(k). if compute_prop:; prop = self._compute_propagator(k). if",MatchSource.WIKI,docs/4.2/modules/qutip/control/propcomp.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/control/propcomp.html
https://qutip.org/docs/4.2/modules/qutip/control/propcomp.html:14134,Deployability,update,updated,14134,"he propagator gradient; It should work for all systems, e.g. unitary, open, symplectic; There are other PropagatorComputer subclasses that may be more efficient; """"""; def reset(self):; PropagatorComputer.reset(self); self.id_text = 'FRECHET'; self.grad_exact = True; self.apply_params(). def _compute_prop_grad(self, k, j, compute_prop=True):; """"""; Calculate the gradient of propagator wrt the control amplitude; in the timeslot using the expm_frechet method; The propagtor is calculated (almost) for 'free' in this method; and hence it is returned if compute_prop==True; Returns:; [prop], prop_grad; """"""; dyn = self.parent. if dyn.oper_dtype == Qobj:; A = dyn._get_phased_dyn_gen(k).full()*dyn.tau[k]; E = dyn._get_phased_ctrl_dyn_gen(k, j).full()*dyn.tau[k]; if compute_prop:; prop_dense, prop_grad_dense = la.expm_frechet(A, E); prop = Qobj(prop_dense, dims=dyn.dyn_dims); prop_grad = Qobj(prop_grad_dense,; dims=dyn.dyn_dims); else:; prop_grad_dense = la.expm_frechet(A, E, compute_expm=False); prop_grad = Qobj(prop_grad_dense,; dims=dyn.dyn_dims); elif dyn.oper_dtype == np.ndarray:; A = dyn._get_phased_dyn_gen(k)*dyn.tau[k]; E = dyn._get_phased_ctrl_dyn_gen(k, j)*dyn.tau[k]; if compute_prop:; prop, prop_grad = la.expm_frechet(A, E); else:; prop_grad = la.expm_frechet(A, E,; compute_expm=False); else:; # Assuming some sparse matrix; spcls = dyn._dyn_gen[k].__class__; A = (dyn._get_phased_dyn_gen(k)*dyn.tau[k]).toarray(); E = (dyn._get_phased_ctrl_dyn_gen(k, j)*dyn.tau[k]).toarray(); if compute_prop:; prop_dense, prop_grad_dense = la.expm_frechet(A, E); prop = spcls(prop_dense); prop_grad = spcls(prop_grad_dense); else:; prop_grad_dense = la.expm_frechet(A, E, compute_expm=False); prop_grad = spcls(prop_grad_dense). if compute_prop:; return prop, prop_grad; else:; return prop_grad. Â© Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, and A.L. Grimsmo.; Last updated on Jan 17, 2018. . Built with Sphinx using a theme provided by Read the Docs. . ",MatchSource.WIKI,docs/4.2/modules/qutip/control/propcomp.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/control/propcomp.html
https://qutip.org/docs/4.2/modules/qutip/control/propcomp.html:9916,Energy Efficiency,efficient,efficient,9916,"genvectors[k]); # multiply (elementwise) by timeslice and factor matrix; cdg = Qobj(np.multiply(cdg.full()*dyn.tau[k],; dyn._dyn_gen_factormatrix[k]), dims=dyn.dyn_dims); # Return to canonical basis; prop_grad = (dyn._dyn_gen_eigenvectors[k]*cdg*; dyn._get_dyn_gen_eigenvectors_adj(k)); else:; # put control dyn_gen in combined dg diagonal basis; cdg = dyn._get_dyn_gen_eigenvectors_adj(k).dot(; dyn._get_phased_ctrl_dyn_gen(k, j)).dot(; dyn._dyn_gen_eigenvectors[k]); # multiply (elementwise) by timeslice and factor matrix; cdg = np.multiply(cdg*dyn.tau[k], dyn._dyn_gen_factormatrix[k]); # Return to canonical basis; prop_grad = dyn._dyn_gen_eigenvectors[k].dot(cdg).dot(; dyn._get_dyn_gen_eigenvectors_adj(k)). if compute_prop:; return prop, prop_grad; else:; return prop_grad. class PropCompAugMat(PropagatorComputer):; """"""; Augmented Matrix (deprecated - see _Frechet). It should work for all systems, e.g. open, symplectic; There will be other PropagatorComputer subclasses that are more efficient; The _Frechet class should provide exactly the same functionality; more efficiently. Note the propagator gradient calculation using the augmented matrix; is taken from:; 'Robust quantum gates for open systems via optimal control:; Markovian versus non-Markovian dynamics'; Frederik F Floether, Pierre de Fouquieres, and Sophie G Schirmer; """"""; def reset(self):; PropagatorComputer.reset(self); self.id_text = 'AUG_MAT'; self.grad_exact = True; self.apply_params(). def _get_aug_mat(self, k, j):; """"""; Generate the matrix [[A, E], [0, A]] where; A is the overall dynamics generator; E is the control dynamics generator; for a given timeslot and control; returns this augmented matrix; """"""; dyn = self.parent; dg = dyn._get_phased_dyn_gen(k). if dyn.oper_dtype == Qobj:; A = dg.data*dyn.tau[k]; E = dyn._get_phased_ctrl_dyn_gen(k, j).data*dyn.tau[k]; Z = sp.csr_matrix(dg.data.shape); aug = Qobj(sp.vstack([sp.hstack([A, E]), sp.hstack([Z, A])])); elif dyn.oper_dtype == np.ndarray:; A = dg*dyn.tau",MatchSource.WIKI,docs/4.2/modules/qutip/control/propcomp.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/control/propcomp.html
https://qutip.org/docs/4.2/modules/qutip/control/propcomp.html:9998,Energy Efficiency,efficient,efficiently,9998,"genvectors[k]); # multiply (elementwise) by timeslice and factor matrix; cdg = Qobj(np.multiply(cdg.full()*dyn.tau[k],; dyn._dyn_gen_factormatrix[k]), dims=dyn.dyn_dims); # Return to canonical basis; prop_grad = (dyn._dyn_gen_eigenvectors[k]*cdg*; dyn._get_dyn_gen_eigenvectors_adj(k)); else:; # put control dyn_gen in combined dg diagonal basis; cdg = dyn._get_dyn_gen_eigenvectors_adj(k).dot(; dyn._get_phased_ctrl_dyn_gen(k, j)).dot(; dyn._dyn_gen_eigenvectors[k]); # multiply (elementwise) by timeslice and factor matrix; cdg = np.multiply(cdg*dyn.tau[k], dyn._dyn_gen_factormatrix[k]); # Return to canonical basis; prop_grad = dyn._dyn_gen_eigenvectors[k].dot(cdg).dot(; dyn._get_dyn_gen_eigenvectors_adj(k)). if compute_prop:; return prop, prop_grad; else:; return prop_grad. class PropCompAugMat(PropagatorComputer):; """"""; Augmented Matrix (deprecated - see _Frechet). It should work for all systems, e.g. open, symplectic; There will be other PropagatorComputer subclasses that are more efficient; The _Frechet class should provide exactly the same functionality; more efficiently. Note the propagator gradient calculation using the augmented matrix; is taken from:; 'Robust quantum gates for open systems via optimal control:; Markovian versus non-Markovian dynamics'; Frederik F Floether, Pierre de Fouquieres, and Sophie G Schirmer; """"""; def reset(self):; PropagatorComputer.reset(self); self.id_text = 'AUG_MAT'; self.grad_exact = True; self.apply_params(). def _get_aug_mat(self, k, j):; """"""; Generate the matrix [[A, E], [0, A]] where; A is the overall dynamics generator; E is the control dynamics generator; for a given timeslot and control; returns this augmented matrix; """"""; dyn = self.parent; dg = dyn._get_phased_dyn_gen(k). if dyn.oper_dtype == Qobj:; A = dg.data*dyn.tau[k]; E = dyn._get_phased_ctrl_dyn_gen(k, j).data*dyn.tau[k]; Z = sp.csr_matrix(dg.data.shape); aug = Qobj(sp.vstack([sp.hstack([A, E]), sp.hstack([Z, A])])); elif dyn.oper_dtype == np.ndarray:; A = dg*dyn.tau",MatchSource.WIKI,docs/4.2/modules/qutip/control/propcomp.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/control/propcomp.html
https://qutip.org/docs/4.2/modules/qutip/control/propcomp.html:12373,Energy Efficiency,efficient,efficient,12373,"lot using the exponentiation of the the augmented; matrix.; The propagtor is calculated for 'free' in this method; and hence it is returned if compute_prop==True; Returns:; [prop], prop_grad; """"""; dyn = self.parent; dg = dyn._get_phased_dyn_gen(k); aug = self._get_aug_mat(k, j). if dyn.oper_dtype == Qobj:; aug_exp = aug.expm(); prop_grad = Qobj(aug_exp.data[:dg.shape[0], dg.shape[1]:],; dims=dyn.dyn_dims); if compute_prop:; prop = Qobj(aug_exp.data[:dg.shape[0], :dg.shape[1]],; dims=dyn.dyn_dims); else:; aug_exp = la.expm(aug); prop_grad = aug_exp[:dg.shape[0], dg.shape[1]:]; if compute_prop:; prop = aug_exp[:dg.shape[0], :dg.shape[1]]. if compute_prop:; return prop, prop_grad; else:; return prop_grad. [docs]class PropCompFrechet(PropagatorComputer):; """"""; Frechet method for calculating the propagator:; exponentiating the combined dynamics generator; and the propagator gradient; It should work for all systems, e.g. unitary, open, symplectic; There are other PropagatorComputer subclasses that may be more efficient; """"""; def reset(self):; PropagatorComputer.reset(self); self.id_text = 'FRECHET'; self.grad_exact = True; self.apply_params(). def _compute_prop_grad(self, k, j, compute_prop=True):; """"""; Calculate the gradient of propagator wrt the control amplitude; in the timeslot using the expm_frechet method; The propagtor is calculated (almost) for 'free' in this method; and hence it is returned if compute_prop==True; Returns:; [prop], prop_grad; """"""; dyn = self.parent. if dyn.oper_dtype == Qobj:; A = dyn._get_phased_dyn_gen(k).full()*dyn.tau[k]; E = dyn._get_phased_ctrl_dyn_gen(k, j).full()*dyn.tau[k]; if compute_prop:; prop_dense, prop_grad_dense = la.expm_frechet(A, E); prop = Qobj(prop_dense, dims=dyn.dyn_dims); prop_grad = Qobj(prop_grad_dense,; dims=dyn.dyn_dims); else:; prop_grad_dense = la.expm_frechet(A, E, compute_expm=False); prop_grad = Qobj(prop_grad_dense,; dims=dyn.dyn_dims); elif dyn.oper_dtype == np.ndarray:; A = dyn._get_phased_dyn_gen(k)*dyn.tau[k];",MatchSource.WIKI,docs/4.2/modules/qutip/control/propcomp.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/control/propcomp.html
https://qutip.org/docs/4.2/modules/qutip/control/propcomp.html:2856,Integrability,message,message,2856,"USE; # OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.; ###############################################################################. # @author: Alexander Pitchford; # @email1: agp1@aber.ac.uk; # @email2: alex.pitchford@gmail.com; # @organization: Aberystwyth University; # @supervisor: Daniel Burgarth. """"""; Propagator Computer; Classes used to calculate the propagators,; and also the propagator gradient when exact gradient methods are used. Note the methods in the _Diag class was inspired by:; DYNAMO - Dynamic Framework for Quantum Optimal Control; See Machnes et.al., arXiv.1011.4874; """""". # import os; import warnings; import numpy as np; import scipy.linalg as la; import scipy.sparse as sp; # QuTiP; from qutip import Qobj; # QuTiP logging; import qutip.logging_utils as logging; logger = logging.get_logger(); # QuTiP control modules; from qutip.control import errors. def _func_deprecation(message, stacklevel=3):; """"""; Issue deprecation warning; Using stacklevel=3 will ensure message refers the function; calling with the deprecated parameter,; """"""; warnings.warn(message, DeprecationWarning, stacklevel=stacklevel). [docs]class PropagatorComputer(object):; """"""; Base for all Propagator Computer classes; that are used to calculate the propagators,; and also the propagator gradient when exact gradient methods are used; Note: they must be instantiated with a Dynamics object, that is the; container for the data that the functions operate on; This base class cannot be used directly. See subclass descriptions; and choose the appropriate one for the application. Attributes; ----------; log_level : integer; level of messaging output from the logger.; Options are attributes of qutip_utils.logging,; in decreasing levels of messaging, are:; DEBUG_INTENSE, DEBUG_VERBOSE, DEBUG, INFO, WARN, ERROR, CRITICAL; Anything WARN or above is effectively 'quiet' execution,; assuming everything runs as expected.; The default NOTSET implies that the level will be taken f",MatchSource.WIKI,docs/4.2/modules/qutip/control/propcomp.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/control/propcomp.html
https://qutip.org/docs/4.2/modules/qutip/control/propcomp.html:2944,Integrability,message,message,2944,"USE; # OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.; ###############################################################################. # @author: Alexander Pitchford; # @email1: agp1@aber.ac.uk; # @email2: alex.pitchford@gmail.com; # @organization: Aberystwyth University; # @supervisor: Daniel Burgarth. """"""; Propagator Computer; Classes used to calculate the propagators,; and also the propagator gradient when exact gradient methods are used. Note the methods in the _Diag class was inspired by:; DYNAMO - Dynamic Framework for Quantum Optimal Control; See Machnes et.al., arXiv.1011.4874; """""". # import os; import warnings; import numpy as np; import scipy.linalg as la; import scipy.sparse as sp; # QuTiP; from qutip import Qobj; # QuTiP logging; import qutip.logging_utils as logging; logger = logging.get_logger(); # QuTiP control modules; from qutip.control import errors. def _func_deprecation(message, stacklevel=3):; """"""; Issue deprecation warning; Using stacklevel=3 will ensure message refers the function; calling with the deprecated parameter,; """"""; warnings.warn(message, DeprecationWarning, stacklevel=stacklevel). [docs]class PropagatorComputer(object):; """"""; Base for all Propagator Computer classes; that are used to calculate the propagators,; and also the propagator gradient when exact gradient methods are used; Note: they must be instantiated with a Dynamics object, that is the; container for the data that the functions operate on; This base class cannot be used directly. See subclass descriptions; and choose the appropriate one for the application. Attributes; ----------; log_level : integer; level of messaging output from the logger.; Options are attributes of qutip_utils.logging,; in decreasing levels of messaging, are:; DEBUG_INTENSE, DEBUG_VERBOSE, DEBUG, INFO, WARN, ERROR, CRITICAL; Anything WARN or above is effectively 'quiet' execution,; assuming everything runs as expected.; The default NOTSET implies that the level will be taken f",MatchSource.WIKI,docs/4.2/modules/qutip/control/propcomp.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/control/propcomp.html
https://qutip.org/docs/4.2/modules/qutip/control/propcomp.html:3032,Integrability,message,message,3032,"###############################. # @author: Alexander Pitchford; # @email1: agp1@aber.ac.uk; # @email2: alex.pitchford@gmail.com; # @organization: Aberystwyth University; # @supervisor: Daniel Burgarth. """"""; Propagator Computer; Classes used to calculate the propagators,; and also the propagator gradient when exact gradient methods are used. Note the methods in the _Diag class was inspired by:; DYNAMO - Dynamic Framework for Quantum Optimal Control; See Machnes et.al., arXiv.1011.4874; """""". # import os; import warnings; import numpy as np; import scipy.linalg as la; import scipy.sparse as sp; # QuTiP; from qutip import Qobj; # QuTiP logging; import qutip.logging_utils as logging; logger = logging.get_logger(); # QuTiP control modules; from qutip.control import errors. def _func_deprecation(message, stacklevel=3):; """"""; Issue deprecation warning; Using stacklevel=3 will ensure message refers the function; calling with the deprecated parameter,; """"""; warnings.warn(message, DeprecationWarning, stacklevel=stacklevel). [docs]class PropagatorComputer(object):; """"""; Base for all Propagator Computer classes; that are used to calculate the propagators,; and also the propagator gradient when exact gradient methods are used; Note: they must be instantiated with a Dynamics object, that is the; container for the data that the functions operate on; This base class cannot be used directly. See subclass descriptions; and choose the appropriate one for the application. Attributes; ----------; log_level : integer; level of messaging output from the logger.; Options are attributes of qutip_utils.logging,; in decreasing levels of messaging, are:; DEBUG_INTENSE, DEBUG_VERBOSE, DEBUG, INFO, WARN, ERROR, CRITICAL; Anything WARN or above is effectively 'quiet' execution,; assuming everything runs as expected.; The default NOTSET implies that the level will be taken from; the QuTiP settings file, which by default is WARN. grad_exact : boolean; indicates whether the computer class instance is",MatchSource.WIKI,docs/4.2/modules/qutip/control/propcomp.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/control/propcomp.html
https://qutip.org/docs/4.2/modules/qutip/control/propcomp.html:4323,Modifiability,config,configuration,4323,"ted with a Dynamics object, that is the; container for the data that the functions operate on; This base class cannot be used directly. See subclass descriptions; and choose the appropriate one for the application. Attributes; ----------; log_level : integer; level of messaging output from the logger.; Options are attributes of qutip_utils.logging,; in decreasing levels of messaging, are:; DEBUG_INTENSE, DEBUG_VERBOSE, DEBUG, INFO, WARN, ERROR, CRITICAL; Anything WARN or above is effectively 'quiet' execution,; assuming everything runs as expected.; The default NOTSET implies that the level will be taken from; the QuTiP settings file, which by default is WARN. grad_exact : boolean; indicates whether the computer class instance is capable; of computing propagator gradients. It is used to determine; whether to create the Dynamics prop_grad array; """"""; def __init__(self, dynamics, params=None):; self.parent = dynamics; self.params = params; self.reset(). [docs] def reset(self):; """"""; reset any configuration data; """"""; self.id_text = 'PROP_COMP_BASE'; self.log_level = self.parent.log_level; self._grad_exact = False. [docs] def apply_params(self, params=None):; """"""; Set object attributes based on the dictionary (if any) passed in the; instantiation, or passed as a parameter; This is called during the instantiation automatically.; The key value pairs are the attribute name and value; Note: attributes are created if they do not exist already,; and are overwritten if they do.; """"""; if not params:; params = self.params. if isinstance(params, dict):; self.params = params; for key in params:; setattr(self, key, params[key]). @property; def log_level(self):; return logger.level. @log_level.setter; def log_level(self, lvl):; """"""; Set the log_level attribute and set the level of the logger; that is call logger.setLevel(lvl); """"""; logger.setLevel(lvl). def grad_exact(self):; return self._grad_exact. def compute_propagator(self, k):; _func_deprecation(""'compute_propagator' has been ",MatchSource.WIKI,docs/4.2/modules/qutip/control/propcomp.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/control/propcomp.html
https://qutip.org/docs/4.2/modules/qutip/control/propcomp.html:7033,Modifiability,config,configuration,7033,"""""; Calculate the propagator from the current point to a trial point; a distance 'epsilon' (change in amplitude); in the direction the given control j in timeslot k; Returns the propagator; """"""; raise errors.UsageError(""Not implemented in the baseclass.""; "" Choose a subclass""). def compute_prop_grad(self, k, j, compute_prop=True):; _func_deprecation(""'compute_prop_grad' has been replaced ""; ""by '_compute_prop_grad'""); return self._compute_prop_grad(self, k, j, compute_prop=compute_prop). def _compute_prop_grad(self, k, j, compute_prop=True):; """"""; Calculate the gradient of propagator wrt the control amplitude; in the timeslot.; """"""; raise errors.UsageError(""Not implemented in the baseclass.""; "" Choose a subclass""). [docs]class PropCompApproxGrad(PropagatorComputer):; """"""; This subclass can be used when the propagator is calculated simply; by expm of the dynamics generator, i.e. when gradients will be calculated; using approximate methods.; """""". [docs] def reset(self):; """"""; reset any configuration data; """"""; PropagatorComputer.reset(self); self.id_text = 'APPROX'; self.grad_exact = False; self.apply_params(). def _compute_diff_prop(self, k, j, epsilon):; """"""; Calculate the propagator from the current point to a trial point; a distance 'epsilon' (change in amplitude); in the direction the given control j in timeslot k; Returns the propagator; """"""; dyn = self.parent; dgt_eps = (dyn._get_phased_dyn_gen(k) +; epsilon*dyn._get_phased_ctrl_dyn_gen(k, j))*dyn.tau[k]. if dyn.oper_dtype == Qobj:; prop_eps = dgt_eps.expm(); else:; prop_eps = la.expm(dgt_eps). return prop_eps. [docs]class PropCompDiag(PropagatorComputer):; """"""; Coumputes the propagator exponentiation using diagonalisation of; of the dynamics generator; """"""; [docs] def reset(self):; """"""; reset any configuration data; """"""; PropagatorComputer.reset(self); self.id_text = 'DIAG'; self.grad_exact = True; self.apply_params(). def _compute_propagator(self, k):; """"""; Calculates the exponentiation of the dynamics generat",MatchSource.WIKI,docs/4.2/modules/qutip/control/propcomp.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/control/propcomp.html
https://qutip.org/docs/4.2/modules/qutip/control/propcomp.html:7817,Modifiability,config,configuration,7817,"e a subclass""). [docs]class PropCompApproxGrad(PropagatorComputer):; """"""; This subclass can be used when the propagator is calculated simply; by expm of the dynamics generator, i.e. when gradients will be calculated; using approximate methods.; """""". [docs] def reset(self):; """"""; reset any configuration data; """"""; PropagatorComputer.reset(self); self.id_text = 'APPROX'; self.grad_exact = False; self.apply_params(). def _compute_diff_prop(self, k, j, epsilon):; """"""; Calculate the propagator from the current point to a trial point; a distance 'epsilon' (change in amplitude); in the direction the given control j in timeslot k; Returns the propagator; """"""; dyn = self.parent; dgt_eps = (dyn._get_phased_dyn_gen(k) +; epsilon*dyn._get_phased_ctrl_dyn_gen(k, j))*dyn.tau[k]. if dyn.oper_dtype == Qobj:; prop_eps = dgt_eps.expm(); else:; prop_eps = la.expm(dgt_eps). return prop_eps. [docs]class PropCompDiag(PropagatorComputer):; """"""; Coumputes the propagator exponentiation using diagonalisation of; of the dynamics generator; """"""; [docs] def reset(self):; """"""; reset any configuration data; """"""; PropagatorComputer.reset(self); self.id_text = 'DIAG'; self.grad_exact = True; self.apply_params(). def _compute_propagator(self, k):; """"""; Calculates the exponentiation of the dynamics generator (H); As part of the calc the the eigen decomposition is required, which; is reused in the propagator gradient calculation; """"""; dyn = self.parent; dyn._ensure_decomp_curr(k). if dyn.oper_dtype == Qobj:. prop = (dyn._dyn_gen_eigenvectors[k]*dyn._prop_eigen[k]*; dyn._get_dyn_gen_eigenvectors_adj(k)); else:; prop = dyn._dyn_gen_eigenvectors[k].dot(; dyn._prop_eigen[k]).dot(; dyn._get_dyn_gen_eigenvectors_adj(k)). return prop. def _compute_prop_grad(self, k, j, compute_prop=True):; """"""; Calculate the gradient of propagator wrt the control amplitude; in the timeslot. Returns:; [prop], prop_grad; """"""; dyn = self.parent; dyn._ensure_decomp_curr(k). if compute_prop:; prop = self._compute_propagator(k). if",MatchSource.WIKI,docs/4.2/modules/qutip/control/propcomp.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/control/propcomp.html
https://qutip.org/docs/4.2/modules/qutip/control/propcomp.html:2696,Testability,log,logging,2696,"ITUTE GOODS OR SERVICES; LOSS OF USE,; # DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY; # THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT; # (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE; # OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.; ###############################################################################. # @author: Alexander Pitchford; # @email1: agp1@aber.ac.uk; # @email2: alex.pitchford@gmail.com; # @organization: Aberystwyth University; # @supervisor: Daniel Burgarth. """"""; Propagator Computer; Classes used to calculate the propagators,; and also the propagator gradient when exact gradient methods are used. Note the methods in the _Diag class was inspired by:; DYNAMO - Dynamic Framework for Quantum Optimal Control; See Machnes et.al., arXiv.1011.4874; """""". # import os; import warnings; import numpy as np; import scipy.linalg as la; import scipy.sparse as sp; # QuTiP; from qutip import Qobj; # QuTiP logging; import qutip.logging_utils as logging; logger = logging.get_logger(); # QuTiP control modules; from qutip.control import errors. def _func_deprecation(message, stacklevel=3):; """"""; Issue deprecation warning; Using stacklevel=3 will ensure message refers the function; calling with the deprecated parameter,; """"""; warnings.warn(message, DeprecationWarning, stacklevel=stacklevel). [docs]class PropagatorComputer(object):; """"""; Base for all Propagator Computer classes; that are used to calculate the propagators,; and also the propagator gradient when exact gradient methods are used; Note: they must be instantiated with a Dynamics object, that is the; container for the data that the functions operate on; This base class cannot be used directly. See subclass descriptions; and choose the appropriate one for the application. Attributes; ----------; log_level : integer; level of messaging output from the logger.; Options are attributes of qutip_utils.logging,; in decreasi",MatchSource.WIKI,docs/4.2/modules/qutip/control/propcomp.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/control/propcomp.html
https://qutip.org/docs/4.2/modules/qutip/control/propcomp.html:2735,Testability,log,logging,2735,"R BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY; # THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT; # (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE; # OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.; ###############################################################################. # @author: Alexander Pitchford; # @email1: agp1@aber.ac.uk; # @email2: alex.pitchford@gmail.com; # @organization: Aberystwyth University; # @supervisor: Daniel Burgarth. """"""; Propagator Computer; Classes used to calculate the propagators,; and also the propagator gradient when exact gradient methods are used. Note the methods in the _Diag class was inspired by:; DYNAMO - Dynamic Framework for Quantum Optimal Control; See Machnes et.al., arXiv.1011.4874; """""". # import os; import warnings; import numpy as np; import scipy.linalg as la; import scipy.sparse as sp; # QuTiP; from qutip import Qobj; # QuTiP logging; import qutip.logging_utils as logging; logger = logging.get_logger(); # QuTiP control modules; from qutip.control import errors. def _func_deprecation(message, stacklevel=3):; """"""; Issue deprecation warning; Using stacklevel=3 will ensure message refers the function; calling with the deprecated parameter,; """"""; warnings.warn(message, DeprecationWarning, stacklevel=stacklevel). [docs]class PropagatorComputer(object):; """"""; Base for all Propagator Computer classes; that are used to calculate the propagators,; and also the propagator gradient when exact gradient methods are used; Note: they must be instantiated with a Dynamics object, that is the; container for the data that the functions operate on; This base class cannot be used directly. See subclass descriptions; and choose the appropriate one for the application. Attributes; ----------; log_level : integer; level of messaging output from the logger.; Options are attributes of qutip_utils.logging,; in decreasing levels of messaging, are:; DEBUG_INTENSE, DEBUG_VERBOSE, ",MatchSource.WIKI,docs/4.2/modules/qutip/control/propcomp.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/control/propcomp.html
https://qutip.org/docs/4.2/modules/qutip/control/propcomp.html:2744,Testability,log,logger,2744,"R BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY; # THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT; # (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE; # OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.; ###############################################################################. # @author: Alexander Pitchford; # @email1: agp1@aber.ac.uk; # @email2: alex.pitchford@gmail.com; # @organization: Aberystwyth University; # @supervisor: Daniel Burgarth. """"""; Propagator Computer; Classes used to calculate the propagators,; and also the propagator gradient when exact gradient methods are used. Note the methods in the _Diag class was inspired by:; DYNAMO - Dynamic Framework for Quantum Optimal Control; See Machnes et.al., arXiv.1011.4874; """""". # import os; import warnings; import numpy as np; import scipy.linalg as la; import scipy.sparse as sp; # QuTiP; from qutip import Qobj; # QuTiP logging; import qutip.logging_utils as logging; logger = logging.get_logger(); # QuTiP control modules; from qutip.control import errors. def _func_deprecation(message, stacklevel=3):; """"""; Issue deprecation warning; Using stacklevel=3 will ensure message refers the function; calling with the deprecated parameter,; """"""; warnings.warn(message, DeprecationWarning, stacklevel=stacklevel). [docs]class PropagatorComputer(object):; """"""; Base for all Propagator Computer classes; that are used to calculate the propagators,; and also the propagator gradient when exact gradient methods are used; Note: they must be instantiated with a Dynamics object, that is the; container for the data that the functions operate on; This base class cannot be used directly. See subclass descriptions; and choose the appropriate one for the application. Attributes; ----------; log_level : integer; level of messaging output from the logger.; Options are attributes of qutip_utils.logging,; in decreasing levels of messaging, are:; DEBUG_INTENSE, DEBUG_VERBOSE, ",MatchSource.WIKI,docs/4.2/modules/qutip/control/propcomp.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/control/propcomp.html
https://qutip.org/docs/4.2/modules/qutip/control/propcomp.html:2753,Testability,log,logging,2753,"R BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY; # THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT; # (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE; # OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.; ###############################################################################. # @author: Alexander Pitchford; # @email1: agp1@aber.ac.uk; # @email2: alex.pitchford@gmail.com; # @organization: Aberystwyth University; # @supervisor: Daniel Burgarth. """"""; Propagator Computer; Classes used to calculate the propagators,; and also the propagator gradient when exact gradient methods are used. Note the methods in the _Diag class was inspired by:; DYNAMO - Dynamic Framework for Quantum Optimal Control; See Machnes et.al., arXiv.1011.4874; """""". # import os; import warnings; import numpy as np; import scipy.linalg as la; import scipy.sparse as sp; # QuTiP; from qutip import Qobj; # QuTiP logging; import qutip.logging_utils as logging; logger = logging.get_logger(); # QuTiP control modules; from qutip.control import errors. def _func_deprecation(message, stacklevel=3):; """"""; Issue deprecation warning; Using stacklevel=3 will ensure message refers the function; calling with the deprecated parameter,; """"""; warnings.warn(message, DeprecationWarning, stacklevel=stacklevel). [docs]class PropagatorComputer(object):; """"""; Base for all Propagator Computer classes; that are used to calculate the propagators,; and also the propagator gradient when exact gradient methods are used; Note: they must be instantiated with a Dynamics object, that is the; container for the data that the functions operate on; This base class cannot be used directly. See subclass descriptions; and choose the appropriate one for the application. Attributes; ----------; log_level : integer; level of messaging output from the logger.; Options are attributes of qutip_utils.logging,; in decreasing levels of messaging, are:; DEBUG_INTENSE, DEBUG_VERBOSE, ",MatchSource.WIKI,docs/4.2/modules/qutip/control/propcomp.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/control/propcomp.html
https://qutip.org/docs/4.2/modules/qutip/control/propcomp.html:3612,Testability,log,logger,3612,"ings; import numpy as np; import scipy.linalg as la; import scipy.sparse as sp; # QuTiP; from qutip import Qobj; # QuTiP logging; import qutip.logging_utils as logging; logger = logging.get_logger(); # QuTiP control modules; from qutip.control import errors. def _func_deprecation(message, stacklevel=3):; """"""; Issue deprecation warning; Using stacklevel=3 will ensure message refers the function; calling with the deprecated parameter,; """"""; warnings.warn(message, DeprecationWarning, stacklevel=stacklevel). [docs]class PropagatorComputer(object):; """"""; Base for all Propagator Computer classes; that are used to calculate the propagators,; and also the propagator gradient when exact gradient methods are used; Note: they must be instantiated with a Dynamics object, that is the; container for the data that the functions operate on; This base class cannot be used directly. See subclass descriptions; and choose the appropriate one for the application. Attributes; ----------; log_level : integer; level of messaging output from the logger.; Options are attributes of qutip_utils.logging,; in decreasing levels of messaging, are:; DEBUG_INTENSE, DEBUG_VERBOSE, DEBUG, INFO, WARN, ERROR, CRITICAL; Anything WARN or above is effectively 'quiet' execution,; assuming everything runs as expected.; The default NOTSET implies that the level will be taken from; the QuTiP settings file, which by default is WARN. grad_exact : boolean; indicates whether the computer class instance is capable; of computing propagator gradients. It is used to determine; whether to create the Dynamics prop_grad array; """"""; def __init__(self, dynamics, params=None):; self.parent = dynamics; self.params = params; self.reset(). [docs] def reset(self):; """"""; reset any configuration data; """"""; self.id_text = 'PROP_COMP_BASE'; self.log_level = self.parent.log_level; self._grad_exact = False. [docs] def apply_params(self, params=None):; """"""; Set object attributes based on the dictionary (if any) passed in the; instanti",MatchSource.WIKI,docs/4.2/modules/qutip/control/propcomp.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/control/propcomp.html
https://qutip.org/docs/4.2/modules/qutip/control/propcomp.html:3659,Testability,log,logging,3659,"logger(); # QuTiP control modules; from qutip.control import errors. def _func_deprecation(message, stacklevel=3):; """"""; Issue deprecation warning; Using stacklevel=3 will ensure message refers the function; calling with the deprecated parameter,; """"""; warnings.warn(message, DeprecationWarning, stacklevel=stacklevel). [docs]class PropagatorComputer(object):; """"""; Base for all Propagator Computer classes; that are used to calculate the propagators,; and also the propagator gradient when exact gradient methods are used; Note: they must be instantiated with a Dynamics object, that is the; container for the data that the functions operate on; This base class cannot be used directly. See subclass descriptions; and choose the appropriate one for the application. Attributes; ----------; log_level : integer; level of messaging output from the logger.; Options are attributes of qutip_utils.logging,; in decreasing levels of messaging, are:; DEBUG_INTENSE, DEBUG_VERBOSE, DEBUG, INFO, WARN, ERROR, CRITICAL; Anything WARN or above is effectively 'quiet' execution,; assuming everything runs as expected.; The default NOTSET implies that the level will be taken from; the QuTiP settings file, which by default is WARN. grad_exact : boolean; indicates whether the computer class instance is capable; of computing propagator gradients. It is used to determine; whether to create the Dynamics prop_grad array; """"""; def __init__(self, dynamics, params=None):; self.parent = dynamics; self.params = params; self.reset(). [docs] def reset(self):; """"""; reset any configuration data; """"""; self.id_text = 'PROP_COMP_BASE'; self.log_level = self.parent.log_level; self._grad_exact = False. [docs] def apply_params(self, params=None):; """"""; Set object attributes based on the dictionary (if any) passed in the; instantiation, or passed as a parameter; This is called during the instantiation automatically.; The key value pairs are the attribute name and value; Note: attributes are created if they do not exi",MatchSource.WIKI,docs/4.2/modules/qutip/control/propcomp.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/control/propcomp.html
https://qutip.org/docs/4.2/modules/qutip/control/propcomp.html:4999,Testability,log,logger,4999,"RN. grad_exact : boolean; indicates whether the computer class instance is capable; of computing propagator gradients. It is used to determine; whether to create the Dynamics prop_grad array; """"""; def __init__(self, dynamics, params=None):; self.parent = dynamics; self.params = params; self.reset(). [docs] def reset(self):; """"""; reset any configuration data; """"""; self.id_text = 'PROP_COMP_BASE'; self.log_level = self.parent.log_level; self._grad_exact = False. [docs] def apply_params(self, params=None):; """"""; Set object attributes based on the dictionary (if any) passed in the; instantiation, or passed as a parameter; This is called during the instantiation automatically.; The key value pairs are the attribute name and value; Note: attributes are created if they do not exist already,; and are overwritten if they do.; """"""; if not params:; params = self.params. if isinstance(params, dict):; self.params = params; for key in params:; setattr(self, key, params[key]). @property; def log_level(self):; return logger.level. @log_level.setter; def log_level(self, lvl):; """"""; Set the log_level attribute and set the level of the logger; that is call logger.setLevel(lvl); """"""; logger.setLevel(lvl). def grad_exact(self):; return self._grad_exact. def compute_propagator(self, k):; _func_deprecation(""'compute_propagator' has been replaced ""; ""by '_compute_propagator'""); return self._compute_propagator(k); ; def _compute_propagator(self, k):; """"""; calculate the progator between X(k) and X(k+1); Uses matrix expm of the dyn_gen at that point (in time); Assumes that the dyn_gen have been been calculated,; i.e. drift and ctrls combined; Return the propagator; """"""; dyn = self.parent; dgt = dyn._get_phased_dyn_gen(k)*dyn.tau[k]; if dyn.oper_dtype == Qobj:; prop = dgt.expm(); else:; prop = la.expm(dgt); return prop. def compute_diff_prop(self, k, j, epsilon):; _func_deprecation(""'compute_diff_prop' has been replaced ""; ""by '_compute_diff_prop'""); return self._compute_diff_prop( k, j, epsil",MatchSource.WIKI,docs/4.2/modules/qutip/control/propcomp.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/control/propcomp.html
https://qutip.org/docs/4.2/modules/qutip/control/propcomp.html:5117,Testability,log,logger,5117,"gator gradients. It is used to determine; whether to create the Dynamics prop_grad array; """"""; def __init__(self, dynamics, params=None):; self.parent = dynamics; self.params = params; self.reset(). [docs] def reset(self):; """"""; reset any configuration data; """"""; self.id_text = 'PROP_COMP_BASE'; self.log_level = self.parent.log_level; self._grad_exact = False. [docs] def apply_params(self, params=None):; """"""; Set object attributes based on the dictionary (if any) passed in the; instantiation, or passed as a parameter; This is called during the instantiation automatically.; The key value pairs are the attribute name and value; Note: attributes are created if they do not exist already,; and are overwritten if they do.; """"""; if not params:; params = self.params. if isinstance(params, dict):; self.params = params; for key in params:; setattr(self, key, params[key]). @property; def log_level(self):; return logger.level. @log_level.setter; def log_level(self, lvl):; """"""; Set the log_level attribute and set the level of the logger; that is call logger.setLevel(lvl); """"""; logger.setLevel(lvl). def grad_exact(self):; return self._grad_exact. def compute_propagator(self, k):; _func_deprecation(""'compute_propagator' has been replaced ""; ""by '_compute_propagator'""); return self._compute_propagator(k); ; def _compute_propagator(self, k):; """"""; calculate the progator between X(k) and X(k+1); Uses matrix expm of the dyn_gen at that point (in time); Assumes that the dyn_gen have been been calculated,; i.e. drift and ctrls combined; Return the propagator; """"""; dyn = self.parent; dgt = dyn._get_phased_dyn_gen(k)*dyn.tau[k]; if dyn.oper_dtype == Qobj:; prop = dgt.expm(); else:; prop = la.expm(dgt); return prop. def compute_diff_prop(self, k, j, epsilon):; _func_deprecation(""'compute_diff_prop' has been replaced ""; ""by '_compute_diff_prop'""); return self._compute_diff_prop( k, j, epsilon). def _compute_diff_prop(self, k, j, epsilon):; """"""; Calculate the propagator from the current point",MatchSource.WIKI,docs/4.2/modules/qutip/control/propcomp.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/control/propcomp.html
https://qutip.org/docs/4.2/modules/qutip/control/propcomp.html:5138,Testability,log,logger,5138,"gator gradients. It is used to determine; whether to create the Dynamics prop_grad array; """"""; def __init__(self, dynamics, params=None):; self.parent = dynamics; self.params = params; self.reset(). [docs] def reset(self):; """"""; reset any configuration data; """"""; self.id_text = 'PROP_COMP_BASE'; self.log_level = self.parent.log_level; self._grad_exact = False. [docs] def apply_params(self, params=None):; """"""; Set object attributes based on the dictionary (if any) passed in the; instantiation, or passed as a parameter; This is called during the instantiation automatically.; The key value pairs are the attribute name and value; Note: attributes are created if they do not exist already,; and are overwritten if they do.; """"""; if not params:; params = self.params. if isinstance(params, dict):; self.params = params; for key in params:; setattr(self, key, params[key]). @property; def log_level(self):; return logger.level. @log_level.setter; def log_level(self, lvl):; """"""; Set the log_level attribute and set the level of the logger; that is call logger.setLevel(lvl); """"""; logger.setLevel(lvl). def grad_exact(self):; return self._grad_exact. def compute_propagator(self, k):; _func_deprecation(""'compute_propagator' has been replaced ""; ""by '_compute_propagator'""); return self._compute_propagator(k); ; def _compute_propagator(self, k):; """"""; calculate the progator between X(k) and X(k+1); Uses matrix expm of the dyn_gen at that point (in time); Assumes that the dyn_gen have been been calculated,; i.e. drift and ctrls combined; Return the propagator; """"""; dyn = self.parent; dgt = dyn._get_phased_dyn_gen(k)*dyn.tau[k]; if dyn.oper_dtype == Qobj:; prop = dgt.expm(); else:; prop = la.expm(dgt); return prop. def compute_diff_prop(self, k, j, epsilon):; _func_deprecation(""'compute_diff_prop' has been replaced ""; ""by '_compute_diff_prop'""); return self._compute_diff_prop( k, j, epsilon). def _compute_diff_prop(self, k, j, epsilon):; """"""; Calculate the propagator from the current point",MatchSource.WIKI,docs/4.2/modules/qutip/control/propcomp.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/control/propcomp.html
https://qutip.org/docs/4.2/modules/qutip/control/propcomp.html:5165,Testability,log,logger,5165,"rop_grad array; """"""; def __init__(self, dynamics, params=None):; self.parent = dynamics; self.params = params; self.reset(). [docs] def reset(self):; """"""; reset any configuration data; """"""; self.id_text = 'PROP_COMP_BASE'; self.log_level = self.parent.log_level; self._grad_exact = False. [docs] def apply_params(self, params=None):; """"""; Set object attributes based on the dictionary (if any) passed in the; instantiation, or passed as a parameter; This is called during the instantiation automatically.; The key value pairs are the attribute name and value; Note: attributes are created if they do not exist already,; and are overwritten if they do.; """"""; if not params:; params = self.params. if isinstance(params, dict):; self.params = params; for key in params:; setattr(self, key, params[key]). @property; def log_level(self):; return logger.level. @log_level.setter; def log_level(self, lvl):; """"""; Set the log_level attribute and set the level of the logger; that is call logger.setLevel(lvl); """"""; logger.setLevel(lvl). def grad_exact(self):; return self._grad_exact. def compute_propagator(self, k):; _func_deprecation(""'compute_propagator' has been replaced ""; ""by '_compute_propagator'""); return self._compute_propagator(k); ; def _compute_propagator(self, k):; """"""; calculate the progator between X(k) and X(k+1); Uses matrix expm of the dyn_gen at that point (in time); Assumes that the dyn_gen have been been calculated,; i.e. drift and ctrls combined; Return the propagator; """"""; dyn = self.parent; dgt = dyn._get_phased_dyn_gen(k)*dyn.tau[k]; if dyn.oper_dtype == Qobj:; prop = dgt.expm(); else:; prop = la.expm(dgt); return prop. def compute_diff_prop(self, k, j, epsilon):; _func_deprecation(""'compute_diff_prop' has been replaced ""; ""by '_compute_diff_prop'""); return self._compute_diff_prop( k, j, epsilon). def _compute_diff_prop(self, k, j, epsilon):; """"""; Calculate the propagator from the current point to a trial point; a distance 'epsilon' (change in amplitude); in the dire",MatchSource.WIKI,docs/4.2/modules/qutip/control/propcomp.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/control/propcomp.html
https://qutip.org/docs/4.2/modules/qutip/control/propcomp.html:6877,Usability,simpl,simply,6877,"epsilon):; _func_deprecation(""'compute_diff_prop' has been replaced ""; ""by '_compute_diff_prop'""); return self._compute_diff_prop( k, j, epsilon). def _compute_diff_prop(self, k, j, epsilon):; """"""; Calculate the propagator from the current point to a trial point; a distance 'epsilon' (change in amplitude); in the direction the given control j in timeslot k; Returns the propagator; """"""; raise errors.UsageError(""Not implemented in the baseclass.""; "" Choose a subclass""). def compute_prop_grad(self, k, j, compute_prop=True):; _func_deprecation(""'compute_prop_grad' has been replaced ""; ""by '_compute_prop_grad'""); return self._compute_prop_grad(self, k, j, compute_prop=compute_prop). def _compute_prop_grad(self, k, j, compute_prop=True):; """"""; Calculate the gradient of propagator wrt the control amplitude; in the timeslot.; """"""; raise errors.UsageError(""Not implemented in the baseclass.""; "" Choose a subclass""). [docs]class PropCompApproxGrad(PropagatorComputer):; """"""; This subclass can be used when the propagator is calculated simply; by expm of the dynamics generator, i.e. when gradients will be calculated; using approximate methods.; """""". [docs] def reset(self):; """"""; reset any configuration data; """"""; PropagatorComputer.reset(self); self.id_text = 'APPROX'; self.grad_exact = False; self.apply_params(). def _compute_diff_prop(self, k, j, epsilon):; """"""; Calculate the propagator from the current point to a trial point; a distance 'epsilon' (change in amplitude); in the direction the given control j in timeslot k; Returns the propagator; """"""; dyn = self.parent; dgt_eps = (dyn._get_phased_dyn_gen(k) +; epsilon*dyn._get_phased_ctrl_dyn_gen(k, j))*dyn.tau[k]. if dyn.oper_dtype == Qobj:; prop_eps = dgt_eps.expm(); else:; prop_eps = la.expm(dgt_eps). return prop_eps. [docs]class PropCompDiag(PropagatorComputer):; """"""; Coumputes the propagator exponentiation using diagonalisation of; of the dynamics generator; """"""; [docs] def reset(self):; """"""; reset any configuration data; """"""",MatchSource.WIKI,docs/4.2/modules/qutip/control/propcomp.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/control/propcomp.html
https://qutip.org/docs/4.2/modules/qutip/control/pulsegen.html:2672,Availability,error,errors,2672,"TUTE GOODS OR SERVICES; LOSS OF USE,; # DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY; # THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT; # (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE; # OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.; ###############################################################################. # @author: Alexander Pitchford; # @email1: agp1@aber.ac.uk; # @email2: alex.pitchford@gmail.com; # @organization: Aberystwyth University; # @supervisor: Daniel Burgarth. """"""; Pulse generator - Generate pulses for the timeslots; Each class defines a gen_pulse function that produces a float array of; size num_tslots. Each class produces a differ type of pulse.; See the class and gen_pulse function descriptions for details; """""". import numpy as np. import qutip.logging_utils as logging; logger = logging.get_logger(). import qutip.control.dynamics as dynamics; import qutip.control.errors as errors. [docs]def create_pulse_gen(pulse_type='RND', dyn=None, pulse_params=None):; """"""; Create and return a pulse generator object matching the given type.; The pulse generators each produce a different type of pulse,; see the gen_pulse function description for details.; These are the random pulse options:; ; RND - Independent random value in each timeslot; RNDFOURIER - Fourier series with random coefficients; RNDWAVES - Summation of random waves; RNDWALK1 - Random change in amplitude each timeslot; RNDWALK2 - Random change in amp gradient each timeslot; ; These are the other non-periodic options:; ; LIN - Linear, i.e. contant gradient over the time; ZERO - special case of the LIN pulse, where the gradient is 0; ; These are the periodic options; ; SINE - Sine wave; SQUARE - Square wave; SAW - Saw tooth wave; TRIANGLE - Triangular wave; ; If a Dynamics object is passed in then this is used in instantiate; the PulseGen, meaning that some timeslot and amplitude properties; are copied ov",MatchSource.WIKI,docs/4.2/modules/qutip/control/pulsegen.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/control/pulsegen.html
https://qutip.org/docs/4.2/modules/qutip/control/pulsegen.html:2682,Availability,error,errors,2682,"TUTE GOODS OR SERVICES; LOSS OF USE,; # DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY; # THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT; # (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE; # OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.; ###############################################################################. # @author: Alexander Pitchford; # @email1: agp1@aber.ac.uk; # @email2: alex.pitchford@gmail.com; # @organization: Aberystwyth University; # @supervisor: Daniel Burgarth. """"""; Pulse generator - Generate pulses for the timeslots; Each class defines a gen_pulse function that produces a float array of; size num_tslots. Each class produces a differ type of pulse.; See the class and gen_pulse function descriptions for details; """""". import numpy as np. import qutip.logging_utils as logging; logger = logging.get_logger(). import qutip.control.dynamics as dynamics; import qutip.control.errors as errors. [docs]def create_pulse_gen(pulse_type='RND', dyn=None, pulse_params=None):; """"""; Create and return a pulse generator object matching the given type.; The pulse generators each produce a different type of pulse,; see the gen_pulse function description for details.; These are the random pulse options:; ; RND - Independent random value in each timeslot; RNDFOURIER - Fourier series with random coefficients; RNDWAVES - Summation of random waves; RNDWALK1 - Random change in amplitude each timeslot; RNDWALK2 - Random change in amp gradient each timeslot; ; These are the other non-periodic options:; ; LIN - Linear, i.e. contant gradient over the time; ZERO - special case of the LIN pulse, where the gradient is 0; ; These are the periodic options; ; SINE - Sine wave; SQUARE - Square wave; SAW - Saw tooth wave; TRIANGLE - Triangular wave; ; If a Dynamics object is passed in then this is used in instantiate; the PulseGen, meaning that some timeslot and amplitude properties; are copied ov",MatchSource.WIKI,docs/4.2/modules/qutip/control/pulsegen.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/control/pulsegen.html
https://qutip.org/docs/4.2/modules/qutip/control/pulsegen.html:8515,Availability,error,errors,8515,".scaling = 1.0; self.tau = None; self.offset = 0.0. self._uses_time = False; self.time = None; self._pulse_initialised = False; self.periodic = False; self.random = False; self.lbound = None; self.ubound = None; self.ramping_pulse = None; ; self.apply_params(); ; [docs] def apply_params(self, params=None):; """"""; Set object attributes based on the dictionary (if any) passed in the ; instantiation, or passed as a parameter; This is called during the instantiation automatically.; The key value pairs are the attribute name and value; """""" ; if not params:; params = self.params; ; if isinstance(params, dict):; self.params = params; for key in params:; setattr(self, key, params[key]). @property; def log_level(self):; return logger.level ; ; @log_level.setter; def log_level(self, lvl):; """"""; Set the log_level attribute and set the level of the logger; that is call logger.setLevel(lvl); """"""; logger.setLevel(lvl); ; [docs] def gen_pulse(self):; """"""; returns the pulse as an array of vales for each timeslot; Must be implemented by subclass; """"""; # must be implemented by subclass; raise errors.UsageError(; ""No method defined for generating a pulse. ""; "" Suspect base class was used where sub class should have been""). [docs] def init_pulse(self):; """"""; Initialise the pulse parameters; """"""; if self.tau is None:; self.tau = np.ones(self.num_tslots, dtype='f') * \; self.pulse_time/self.num_tslots; ; if self._uses_time:; self.time = np.zeros(self.num_tslots, dtype=float); for k in range(self.num_tslots-1):; self.time[k+1] = self.time[k] + self.tau[k]; ; self._pulse_initialised = True. if not self.lbound is None:; if np.isinf(self.lbound):; self.lbound = None; if not self.ubound is None:; if np.isinf(self.ubound):; self.ubound = None; ; if not self.ubound is None and not self.lbound is None:; if self.ubound < self.lbound:; raise ValueError(""ubound cannot be less the lbound""). def _apply_bounds_and_offset(self, pulse):; """"""; Ensure that the randomly generated pulse fits within the bounds",MatchSource.WIKI,docs/4.2/modules/qutip/control/pulsegen.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/control/pulsegen.html
https://qutip.org/docs/4.2/modules/qutip/control/pulsegen.html:36477,Deployability,update,updated,36477,"rier basis functions, i.e. sin and cos. Attributes; ----------; freqs : float array[num_coeffs]; Frequencies for the basis functions; randomize_freqs : bool; If True (default) the some random offset is applied to the frequencies; """""". [docs] def reset(self):; """"""; reset attributes to default values; """"""; PulseGenCrab.reset(self); self.freqs = None; self.randomize_freqs = True. [docs] def init_pulse(self, num_coeffs=None):; """"""; Set the initial freq and coefficient values; """"""; PulseGenCrab.init_pulse(self); ; self.init_freqs(); ; [docs] def init_freqs(self):; """"""; Generate the frequencies; These are the Fourier harmonics with a uniformly distributed; random offset; """"""; self.freqs = np.empty(self.num_coeffs); ff = 2*np.pi / self.pulse_time; for i in range(self.num_coeffs):; self.freqs[i] = ff*(i + 1); ; if self.randomize_freqs:; self.freqs += np.random.random(self.num_coeffs) - 0.5; ; [docs] def gen_pulse(self, coeffs=None):; """"""; Generate a pulse using the Fourier basis with the freqs and; coeffs attributes.; ; Parameters; ----------; coeffs : float array[num_coeffs, num_basis_funcs]; The basis coefficient values; If given this overides the default and sets the attribute; of the same name.; """"""; if coeffs:; self.coeffs = coeffs; ; if not self._pulse_initialised:; self.init_pulse(); ; pulse = np.zeros(self.num_tslots). for i in range(self.num_coeffs):; phase = self.freqs[i]*self.time; # basis1comp = self.coeffs[i, 0]*np.sin(phase); # basis2comp = self.coeffs[i, 1]*np.cos(phase); # pulse += basis1comp + basis2comp; pulse += self.coeffs[i, 0]*np.sin(phase) + \; self.coeffs[i, 1]*np.cos(phase) . if self.guess_pulse_func:; pulse = self.guess_pulse_func(pulse); if self.ramping_pulse is not None:; pulse = self._apply_ramping_pulse(pulse); ; return self._apply_bounds(pulse); . Â© Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, and A.L. Grimsmo.; Last updated on Jan 17, 2018. . Built with Sphinx using a theme provided by Read the Docs. . ",MatchSource.WIKI,docs/4.2/modules/qutip/control/pulsegen.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/control/pulsegen.html
https://qutip.org/docs/4.2/modules/qutip/control/pulsegen.html:30731,Energy Efficiency,efficient,efficient,30731,"If given this overides the default and sets the attribute; of the same name.; """"""; if num_coeffs:; self.num_coeffs = num_coeffs; ; self._num_coeffs_estimated = False; if not self.num_coeffs:; if isinstance(self.parent, dynamics.Dynamics):; dim = self.parent.get_drift_dim(); self.num_coeffs = self.estimate_num_coeffs(dim); self._num_coeffs_estimated = True; else:; self.num_coeffs = self.DEF_NUM_COEFFS; self.num_optim_vars = self.num_coeffs*self.num_basis_funcs; ; if self._num_coeffs_estimated:; if self.log_level <= logging.INFO:; logger.info(; ""The number of CRAB coefficients per basis function ""; ""has been estimated as {}, which means a total of {} ""; ""optimisation variables for this pulse. Based on the ""; ""dimension ({}) of the system"".format(; self.num_coeffs, self.num_optim_vars, dim)); # Issue warning if beyond the recommended level; if self.log_level <= logging.WARN:; if self.num_coeffs > self.NUM_COEFFS_WARN_LVL:; logger.warn(; ""The estimated number of coefficients {} exceeds ""; ""the amount ({}) recommended for efficient ""; ""optimisation. You can set this level explicitly ""; ""to suppress this message."".format(; self.num_coeffs, self.NUM_COEFFS_WARN_LVL)); ; if self.randomize_coeffs:; r = np.random.random([self.num_coeffs, self.num_basis_funcs]); self.coeffs = (2*r - 1.0) * self.scaling; else:; self.coeffs = np.ones([self.num_coeffs, ; self.num_basis_funcs])*self.scaling; ; [docs] def estimate_num_coeffs(self, dim):; """"""; Estimate the number coefficients based on the dimensionality of the; system.; Returns; -------; num_coeffs : int; estimated number of coefficients; """"""; num_coeffs = max(2, dim - 1); return num_coeffs; ; [docs] def get_optim_var_vals(self):; """"""; Get the parameter values to be optimised; Returns; -------; list (or 1d array) of floats ; """"""; return self.coeffs.ravel().tolist(); ; [docs] def set_optim_var_vals(self, param_vals):; """"""; Set the values of the any of the pulse generation parameters; based on new values from the optimisation method; T",MatchSource.WIKI,docs/4.2/modules/qutip/control/pulsegen.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/control/pulsegen.html
https://qutip.org/docs/4.2/modules/qutip/control/pulsegen.html:30814,Integrability,message,message,30814,"effs:; self.num_coeffs = num_coeffs; ; self._num_coeffs_estimated = False; if not self.num_coeffs:; if isinstance(self.parent, dynamics.Dynamics):; dim = self.parent.get_drift_dim(); self.num_coeffs = self.estimate_num_coeffs(dim); self._num_coeffs_estimated = True; else:; self.num_coeffs = self.DEF_NUM_COEFFS; self.num_optim_vars = self.num_coeffs*self.num_basis_funcs; ; if self._num_coeffs_estimated:; if self.log_level <= logging.INFO:; logger.info(; ""The number of CRAB coefficients per basis function ""; ""has been estimated as {}, which means a total of {} ""; ""optimisation variables for this pulse. Based on the ""; ""dimension ({}) of the system"".format(; self.num_coeffs, self.num_optim_vars, dim)); # Issue warning if beyond the recommended level; if self.log_level <= logging.WARN:; if self.num_coeffs > self.NUM_COEFFS_WARN_LVL:; logger.warn(; ""The estimated number of coefficients {} exceeds ""; ""the amount ({}) recommended for efficient ""; ""optimisation. You can set this level explicitly ""; ""to suppress this message."".format(; self.num_coeffs, self.NUM_COEFFS_WARN_LVL)); ; if self.randomize_coeffs:; r = np.random.random([self.num_coeffs, self.num_basis_funcs]); self.coeffs = (2*r - 1.0) * self.scaling; else:; self.coeffs = np.ones([self.num_coeffs, ; self.num_basis_funcs])*self.scaling; ; [docs] def estimate_num_coeffs(self, dim):; """"""; Estimate the number coefficients based on the dimensionality of the; system.; Returns; -------; num_coeffs : int; estimated number of coefficients; """"""; num_coeffs = max(2, dim - 1); return num_coeffs; ; [docs] def get_optim_var_vals(self):; """"""; Get the parameter values to be optimised; Returns; -------; list (or 1d array) of floats ; """"""; return self.coeffs.ravel().tolist(); ; [docs] def set_optim_var_vals(self, param_vals):; """"""; Set the values of the any of the pulse generation parameters; based on new values from the optimisation method; Typically this will be the basis coefficients; """"""; # Type and size checking avoided here as",MatchSource.WIKI,docs/4.2/modules/qutip/control/pulsegen.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/control/pulsegen.html
https://qutip.org/docs/4.2/modules/qutip/control/pulsegen.html:29260,Modifiability,variab,variables,29260,".parent = dyn; self.num_coeffs = num_coeffs; self.params = params; self.reset(); ; [docs] def reset(self):; """"""; reset attributes to default values; """"""; PulseGen.reset(self); self.NUM_COEFFS_WARN_LVL = 20; self.DEF_NUM_COEFFS = 4; self._BSC_ALL = 1; self._BSC_GT_MEAN = 2; self._BSC_LT_MEAN = 3; ; self._uses_time = True; self.time = None; self.num_basis_funcs = 2; self.num_optim_vars = 0; self.coeffs = None; self.randomize_coeffs = True; self._num_coeffs_estimated = False; self.guess_pulse_action = 'MODULATE'; self.guess_pulse = None; self.guess_pulse_func = None; self.apply_params(); ; [docs] def init_pulse(self, num_coeffs=None):; """"""; Set the initial freq and coefficient values; """"""; PulseGen.init_pulse(self); self.init_coeffs(num_coeffs=num_coeffs); ; if self.guess_pulse is not None:; self.init_guess_pulse(); self._init_bounds(); ; if self.log_level <= logging.DEBUG and not self._num_coeffs_estimated:; logger.debug(; ""CRAB pulse initialised with {} coefficients per basis ""; ""function, which means a total of {} ""; ""optimisation variables for this pulse"".format(; self.num_coeffs, self.num_optim_vars)); ; # def generate_guess_pulse(self); # if isinstance(self.guess_pulsegen, PulseGen):; # self.guess_pulse = self.guess_pulsegen.gen_pulse(); # return self.guess_pulse; ; [docs] def init_coeffs(self, num_coeffs=None):; """"""; Generate the initial ceofficent values.; ; Parameters; ----------; num_coeffs : integer; Number of coefficients used for each basis function; If given this overides the default and sets the attribute; of the same name.; """"""; if num_coeffs:; self.num_coeffs = num_coeffs; ; self._num_coeffs_estimated = False; if not self.num_coeffs:; if isinstance(self.parent, dynamics.Dynamics):; dim = self.parent.get_drift_dim(); self.num_coeffs = self.estimate_num_coeffs(dim); self._num_coeffs_estimated = True; else:; self.num_coeffs = self.DEF_NUM_COEFFS; self.num_optim_vars = self.num_coeffs*self.num_basis_funcs; ; if self._num_coeffs_estimated:; if self.log_leve",MatchSource.WIKI,docs/4.2/modules/qutip/control/pulsegen.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/control/pulsegen.html
https://qutip.org/docs/4.2/modules/qutip/control/pulsegen.html:30372,Modifiability,variab,variables,30372,"um_optim_vars)); ; # def generate_guess_pulse(self); # if isinstance(self.guess_pulsegen, PulseGen):; # self.guess_pulse = self.guess_pulsegen.gen_pulse(); # return self.guess_pulse; ; [docs] def init_coeffs(self, num_coeffs=None):; """"""; Generate the initial ceofficent values.; ; Parameters; ----------; num_coeffs : integer; Number of coefficients used for each basis function; If given this overides the default and sets the attribute; of the same name.; """"""; if num_coeffs:; self.num_coeffs = num_coeffs; ; self._num_coeffs_estimated = False; if not self.num_coeffs:; if isinstance(self.parent, dynamics.Dynamics):; dim = self.parent.get_drift_dim(); self.num_coeffs = self.estimate_num_coeffs(dim); self._num_coeffs_estimated = True; else:; self.num_coeffs = self.DEF_NUM_COEFFS; self.num_optim_vars = self.num_coeffs*self.num_basis_funcs; ; if self._num_coeffs_estimated:; if self.log_level <= logging.INFO:; logger.info(; ""The number of CRAB coefficients per basis function ""; ""has been estimated as {}, which means a total of {} ""; ""optimisation variables for this pulse. Based on the ""; ""dimension ({}) of the system"".format(; self.num_coeffs, self.num_optim_vars, dim)); # Issue warning if beyond the recommended level; if self.log_level <= logging.WARN:; if self.num_coeffs > self.NUM_COEFFS_WARN_LVL:; logger.warn(; ""The estimated number of coefficients {} exceeds ""; ""the amount ({}) recommended for efficient ""; ""optimisation. You can set this level explicitly ""; ""to suppress this message."".format(; self.num_coeffs, self.NUM_COEFFS_WARN_LVL)); ; if self.randomize_coeffs:; r = np.random.random([self.num_coeffs, self.num_basis_funcs]); self.coeffs = (2*r - 1.0) * self.scaling; else:; self.coeffs = np.ones([self.num_coeffs, ; self.num_basis_funcs])*self.scaling; ; [docs] def estimate_num_coeffs(self, dim):; """"""; Estimate the number coefficients based on the dimensionality of the; system.; Returns; -------; num_coeffs : int; estimated number of coefficients; """"""; num_coeffs = max(",MatchSource.WIKI,docs/4.2/modules/qutip/control/pulsegen.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/control/pulsegen.html
https://qutip.org/docs/4.2/modules/qutip/control/pulsegen.html:12659,Safety,avoid,avoid,12659,"scaling : float; The pulses should fit approximately within -/+scaling; (before the offset is applied); as it is used to set a maximum for each component wave; Use bounds to be sure; (copied from Dynamics.initial_ctrl_scaling if given). min_wavelen : float; Minimum wavelength of any component wave; Set by default to 1/10th of the pulse time; """""". def reset(self):; """"""; reset attributes to default values; """"""; PulseGen.reset(self); self.random = True; self._uses_time = True; try:; self.min_wavelen = self.pulse_time / 10.0; except:; self.min_wavelen = 0.1; self.apply_params(). def gen_pulse(self, min_wavelen=None):; """"""; Generate a random pulse based on a Fourier series with a minimum; wavelength; """""". if min_wavelen is not None:; self.min_wavelen = min_wavelen; min_wavelen = self.min_wavelen. if min_wavelen > self.pulse_time:; raise ValueError(""Minimum wavelength cannot be greater than ""; ""the pulse time""); if not self._pulse_initialised:; self.init_pulse(). # use some phase to avoid the first pulse being always 0. sum_wave = np.zeros(self.tau.shape); wavelen = 2.0*self.pulse_time. t = self.time; wl = []; while wavelen > min_wavelen:; wl.append(wavelen); wavelen = wavelen/2.0. num_comp_waves = len(wl); amp_scale = np.sqrt(8)*self.scaling / float(num_comp_waves). for wavelen in wl:; amp = amp_scale*(np.random.rand()*2 - 1); phase_off = np.random.rand()*np.pi/2.0; curr_wave = amp*np.sin(2*np.pi*t/wavelen + phase_off); sum_wave += curr_wave. return self._apply_bounds_and_offset(sum_wave). class PulseGenRndWaves(PulseGen):; """"""; Generates pulses by summing sine waves with random frequencies; amplitudes and phase offset. Attributes; ----------; scaling : float; The pulses should fit approximately within -/+scaling; (before the offset is applied); as it is used to set a maximum for each component wave; Use bounds to be sure; (copied from Dynamics.initial_ctrl_scaling if given). num_comp_waves : integer; Number of component waves. That is the number of waves that; are summe",MatchSource.WIKI,docs/4.2/modules/qutip/control/pulsegen.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/control/pulsegen.html
https://qutip.org/docs/4.2/modules/qutip/control/pulsegen.html:15055,Safety,avoid,avoid,15055,"elf.num_comp_waves = 20; try:; self.min_wavelen = self.pulse_time / 10.0; except:; self.min_wavelen = 0.1; try:; self.max_wavelen = 2*self.pulse_time; except:; self.max_wavelen = 10.0; self.apply_params(). def gen_pulse(self, num_comp_waves=None,; min_wavelen=None, max_wavelen=None):; """"""; Generate a random pulse by summing sine waves with random freq,; amplitude and phase offset; """""". if num_comp_waves is not None:; self.num_comp_waves = num_comp_waves; if min_wavelen is not None:; self.min_wavelen = min_wavelen; if max_wavelen is not None:; self.max_wavelen = max_wavelen. num_comp_waves = self.num_comp_waves; min_wavelen = self.min_wavelen; max_wavelen = self.max_wavelen. if min_wavelen > self.pulse_time:; raise ValueError(""Minimum wavelength cannot be greater than ""; ""the pulse time""); if max_wavelen <= min_wavelen:; raise ValueError(""Maximum wavelength must be greater than ""; ""the minimum wavelength""). if not self._pulse_initialised:; self.init_pulse(). # use some phase to avoid the first pulse being always 0. sum_wave = np.zeros(self.tau.shape). t = self.time; wl_range = max_wavelen - min_wavelen; amp_scale = np.sqrt(8)*self.scaling / float(num_comp_waves); for n in range(num_comp_waves):; amp = amp_scale*(np.random.rand()*2 - 1); phase_off = np.random.rand()*np.pi/2.0; wavelen = min_wavelen + np.random.rand()*wl_range; curr_wave = amp*np.sin(2*np.pi*t/wavelen + phase_off); sum_wave += curr_wave. return self._apply_bounds_and_offset(sum_wave). class PulseGenRndWalk1(PulseGen):; """"""; Generates pulses by using a random walk algorithm. Attributes; ----------; scaling : float; Used as the range for the starting amplitude; Note must used bounds if values must be restricted.; Also scales the max_d_amp value; (copied from Dynamics.initial_ctrl_scaling if given). max_d_amp : float; Maximum amount amplitude will change between timeslots; Note this is also factored by the scaling attribute; """"""; def reset(self):; """"""; reset attributes to default values; """"""; PulseGen.res",MatchSource.WIKI,docs/4.2/modules/qutip/control/pulsegen.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/control/pulsegen.html
https://qutip.org/docs/4.2/modules/qutip/control/pulsegen.html:31775,Safety,avoid,avoided,31775," {} exceeds ""; ""the amount ({}) recommended for efficient ""; ""optimisation. You can set this level explicitly ""; ""to suppress this message."".format(; self.num_coeffs, self.NUM_COEFFS_WARN_LVL)); ; if self.randomize_coeffs:; r = np.random.random([self.num_coeffs, self.num_basis_funcs]); self.coeffs = (2*r - 1.0) * self.scaling; else:; self.coeffs = np.ones([self.num_coeffs, ; self.num_basis_funcs])*self.scaling; ; [docs] def estimate_num_coeffs(self, dim):; """"""; Estimate the number coefficients based on the dimensionality of the; system.; Returns; -------; num_coeffs : int; estimated number of coefficients; """"""; num_coeffs = max(2, dim - 1); return num_coeffs; ; [docs] def get_optim_var_vals(self):; """"""; Get the parameter values to be optimised; Returns; -------; list (or 1d array) of floats ; """"""; return self.coeffs.ravel().tolist(); ; [docs] def set_optim_var_vals(self, param_vals):; """"""; Set the values of the any of the pulse generation parameters; based on new values from the optimisation method; Typically this will be the basis coefficients; """"""; # Type and size checking avoided here as this is in the ; # main optmisation call sequence; self.set_coeffs(param_vals); ; def set_coeffs(self, param_vals):; self.coeffs = param_vals.reshape(; [self.num_coeffs, self.num_basis_funcs]); ; def init_guess_pulse(self):; ; self.guess_pulse_func = None; if not self.guess_pulse_action:; logger.WARN(""No guess pulse action given, hence ignored.""); elif self.guess_pulse_action.upper() == 'MODULATE':; self.guess_pulse_func = self.guess_pulse_modulate; elif self.guess_pulse_action.upper() == 'ADD':; self.guess_pulse_func = self.guess_pulse_add; else:; logger.WARN(""No option for guess pulse action '{}' ""; "", hence ignored."".format(self.guess_pulse_action)); ; def guess_pulse_add(self, pulse):; pulse = pulse + self.guess_pulse; return pulse; ; def guess_pulse_modulate(self, pulse):; pulse = (1.0 + pulse)*self.guess_pulse; return pulse; ; def _init_bounds(self):; add_guess_pulse_scale ",MatchSource.WIKI,docs/4.2/modules/qutip/control/pulsegen.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/control/pulsegen.html
https://qutip.org/docs/4.2/modules/qutip/control/pulsegen.html:2568,Testability,log,logging,2568,"AL,; # SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT; # LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,; # DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY; # THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT; # (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE; # OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.; ###############################################################################. # @author: Alexander Pitchford; # @email1: agp1@aber.ac.uk; # @email2: alex.pitchford@gmail.com; # @organization: Aberystwyth University; # @supervisor: Daniel Burgarth. """"""; Pulse generator - Generate pulses for the timeslots; Each class defines a gen_pulse function that produces a float array of; size num_tslots. Each class produces a differ type of pulse.; See the class and gen_pulse function descriptions for details; """""". import numpy as np. import qutip.logging_utils as logging; logger = logging.get_logger(). import qutip.control.dynamics as dynamics; import qutip.control.errors as errors. [docs]def create_pulse_gen(pulse_type='RND', dyn=None, pulse_params=None):; """"""; Create and return a pulse generator object matching the given type.; The pulse generators each produce a different type of pulse,; see the gen_pulse function description for details.; These are the random pulse options:; ; RND - Independent random value in each timeslot; RNDFOURIER - Fourier series with random coefficients; RNDWAVES - Summation of random waves; RNDWALK1 - Random change in amplitude each timeslot; RNDWALK2 - Random change in amp gradient each timeslot; ; These are the other non-periodic options:; ; LIN - Linear, i.e. contant gradient over the time; ZERO - special case of the LIN pulse, where the gradient is 0; ; These are the periodic options; ; SINE - Sine wave; SQUARE - Square wave; SAW - Saw tooth wave; TRIANGLE - Triangular wave; ; If a Dynamics object is passed in then t",MatchSource.WIKI,docs/4.2/modules/qutip/control/pulsegen.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/control/pulsegen.html
https://qutip.org/docs/4.2/modules/qutip/control/pulsegen.html:2577,Testability,log,logger,2577,"AL,; # SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT; # LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,; # DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY; # THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT; # (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE; # OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.; ###############################################################################. # @author: Alexander Pitchford; # @email1: agp1@aber.ac.uk; # @email2: alex.pitchford@gmail.com; # @organization: Aberystwyth University; # @supervisor: Daniel Burgarth. """"""; Pulse generator - Generate pulses for the timeslots; Each class defines a gen_pulse function that produces a float array of; size num_tslots. Each class produces a differ type of pulse.; See the class and gen_pulse function descriptions for details; """""". import numpy as np. import qutip.logging_utils as logging; logger = logging.get_logger(). import qutip.control.dynamics as dynamics; import qutip.control.errors as errors. [docs]def create_pulse_gen(pulse_type='RND', dyn=None, pulse_params=None):; """"""; Create and return a pulse generator object matching the given type.; The pulse generators each produce a different type of pulse,; see the gen_pulse function description for details.; These are the random pulse options:; ; RND - Independent random value in each timeslot; RNDFOURIER - Fourier series with random coefficients; RNDWAVES - Summation of random waves; RNDWALK1 - Random change in amplitude each timeslot; RNDWALK2 - Random change in amp gradient each timeslot; ; These are the other non-periodic options:; ; LIN - Linear, i.e. contant gradient over the time; ZERO - special case of the LIN pulse, where the gradient is 0; ; These are the periodic options; ; SINE - Sine wave; SQUARE - Square wave; SAW - Saw tooth wave; TRIANGLE - Triangular wave; ; If a Dynamics object is passed in then t",MatchSource.WIKI,docs/4.2/modules/qutip/control/pulsegen.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/control/pulsegen.html
https://qutip.org/docs/4.2/modules/qutip/control/pulsegen.html:2586,Testability,log,logging,2586,"AL,; # SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT; # LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,; # DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY; # THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT; # (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE; # OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.; ###############################################################################. # @author: Alexander Pitchford; # @email1: agp1@aber.ac.uk; # @email2: alex.pitchford@gmail.com; # @organization: Aberystwyth University; # @supervisor: Daniel Burgarth. """"""; Pulse generator - Generate pulses for the timeslots; Each class defines a gen_pulse function that produces a float array of; size num_tslots. Each class produces a differ type of pulse.; See the class and gen_pulse function descriptions for details; """""". import numpy as np. import qutip.logging_utils as logging; logger = logging.get_logger(). import qutip.control.dynamics as dynamics; import qutip.control.errors as errors. [docs]def create_pulse_gen(pulse_type='RND', dyn=None, pulse_params=None):; """"""; Create and return a pulse generator object matching the given type.; The pulse generators each produce a different type of pulse,; see the gen_pulse function description for details.; These are the random pulse options:; ; RND - Independent random value in each timeslot; RNDFOURIER - Fourier series with random coefficients; RNDWAVES - Summation of random waves; RNDWALK1 - Random change in amplitude each timeslot; RNDWALK2 - Random change in amp gradient each timeslot; ; These are the other non-periodic options:; ; LIN - Linear, i.e. contant gradient over the time; ZERO - special case of the LIN pulse, where the gradient is 0; ; These are the periodic options; ; SINE - Sine wave; SQUARE - Square wave; SAW - Saw tooth wave; TRIANGLE - Triangular wave; ; If a Dynamics object is passed in then t",MatchSource.WIKI,docs/4.2/modules/qutip/control/pulsegen.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/control/pulsegen.html
https://qutip.org/docs/4.2/modules/qutip/control/pulsegen.html:6553,Testability,log,logger,6553,"caling applied to the pulse; (copied from Dynamics.initial_ctrl_scaling if given). offset : float; linear offset applied to the pulse; (copied from Dynamics.initial_ctrl_offset if given). tau : array[num_tslots] of float; Duration of each timeslot; (copied from Dynamics if given). lbound : float; Lower boundary for the pulse amplitudes; Note that the scaling and offset attributes can be used to fully; bound the pulse for all generators except some of the random ones; This bound (if set) may result in additional shifting / scaling; Default is -Inf. ubound : float; Upper boundary for the pulse amplitudes; Note that the scaling and offset attributes can be used to fully; bound the pulse for all generators except some of the random ones; This bound (if set) may result in additional shifting / scaling; Default is Inf. periodic : boolean; True if the pulse generator produces periodic pulses. random : boolean; True if the pulse generator produces random pulses. log_level : integer; level of messaging output from the logger.; Options are attributes of qutip.logging_utils,; in decreasing levels of messaging, are:; DEBUG_INTENSE, DEBUG_VERBOSE, DEBUG, INFO, WARN, ERROR, CRITICAL; Anything WARN or above is effectively 'quiet' execution,; assuming everything runs as expected.; The default NOTSET implies that the level will be taken from; the QuTiP settings file, which by default is WARN; """"""; def __init__(self, dyn=None, params=None):; self.parent = dyn; self.params = params; self.reset(). [docs] def reset(self):; """"""; reset attributes to default values; """"""; if isinstance(self.parent, dynamics.Dynamics):; dyn = self.parent; self.num_tslots = dyn.num_tslots; self.pulse_time = dyn.evo_time; self.scaling = dyn.initial_ctrl_scaling; self.offset = dyn.initial_ctrl_offset; self.tau = dyn.tau; self.log_level = dyn.log_level; else:; self.num_tslots = 100; self.pulse_time = 1.0; self.scaling = 1.0; self.tau = None; self.offset = 0.0. self._uses_time = False; self.time = None; self._pul",MatchSource.WIKI,docs/4.2/modules/qutip/control/pulsegen.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/control/pulsegen.html
https://qutip.org/docs/4.2/modules/qutip/control/pulsegen.html:8151,Testability,log,logger,8151,"ics.Dynamics):; dyn = self.parent; self.num_tslots = dyn.num_tslots; self.pulse_time = dyn.evo_time; self.scaling = dyn.initial_ctrl_scaling; self.offset = dyn.initial_ctrl_offset; self.tau = dyn.tau; self.log_level = dyn.log_level; else:; self.num_tslots = 100; self.pulse_time = 1.0; self.scaling = 1.0; self.tau = None; self.offset = 0.0. self._uses_time = False; self.time = None; self._pulse_initialised = False; self.periodic = False; self.random = False; self.lbound = None; self.ubound = None; self.ramping_pulse = None; ; self.apply_params(); ; [docs] def apply_params(self, params=None):; """"""; Set object attributes based on the dictionary (if any) passed in the ; instantiation, or passed as a parameter; This is called during the instantiation automatically.; The key value pairs are the attribute name and value; """""" ; if not params:; params = self.params; ; if isinstance(params, dict):; self.params = params; for key in params:; setattr(self, key, params[key]). @property; def log_level(self):; return logger.level ; ; @log_level.setter; def log_level(self, lvl):; """"""; Set the log_level attribute and set the level of the logger; that is call logger.setLevel(lvl); """"""; logger.setLevel(lvl); ; [docs] def gen_pulse(self):; """"""; returns the pulse as an array of vales for each timeslot; Must be implemented by subclass; """"""; # must be implemented by subclass; raise errors.UsageError(; ""No method defined for generating a pulse. ""; "" Suspect base class was used where sub class should have been""). [docs] def init_pulse(self):; """"""; Initialise the pulse parameters; """"""; if self.tau is None:; self.tau = np.ones(self.num_tslots, dtype='f') * \; self.pulse_time/self.num_tslots; ; if self._uses_time:; self.time = np.zeros(self.num_tslots, dtype=float); for k in range(self.num_tslots-1):; self.time[k+1] = self.time[k] + self.tau[k]; ; self._pulse_initialised = True. if not self.lbound is None:; if np.isinf(self.lbound):; self.lbound = None; if not self.ubound is None:; if np.isinf(",MatchSource.WIKI,docs/4.2/modules/qutip/control/pulsegen.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/control/pulsegen.html
https://qutip.org/docs/4.2/modules/qutip/control/pulsegen.html:8272,Testability,log,logger,8272,".scaling = dyn.initial_ctrl_scaling; self.offset = dyn.initial_ctrl_offset; self.tau = dyn.tau; self.log_level = dyn.log_level; else:; self.num_tslots = 100; self.pulse_time = 1.0; self.scaling = 1.0; self.tau = None; self.offset = 0.0. self._uses_time = False; self.time = None; self._pulse_initialised = False; self.periodic = False; self.random = False; self.lbound = None; self.ubound = None; self.ramping_pulse = None; ; self.apply_params(); ; [docs] def apply_params(self, params=None):; """"""; Set object attributes based on the dictionary (if any) passed in the ; instantiation, or passed as a parameter; This is called during the instantiation automatically.; The key value pairs are the attribute name and value; """""" ; if not params:; params = self.params; ; if isinstance(params, dict):; self.params = params; for key in params:; setattr(self, key, params[key]). @property; def log_level(self):; return logger.level ; ; @log_level.setter; def log_level(self, lvl):; """"""; Set the log_level attribute and set the level of the logger; that is call logger.setLevel(lvl); """"""; logger.setLevel(lvl); ; [docs] def gen_pulse(self):; """"""; returns the pulse as an array of vales for each timeslot; Must be implemented by subclass; """"""; # must be implemented by subclass; raise errors.UsageError(; ""No method defined for generating a pulse. ""; "" Suspect base class was used where sub class should have been""). [docs] def init_pulse(self):; """"""; Initialise the pulse parameters; """"""; if self.tau is None:; self.tau = np.ones(self.num_tslots, dtype='f') * \; self.pulse_time/self.num_tslots; ; if self._uses_time:; self.time = np.zeros(self.num_tslots, dtype=float); for k in range(self.num_tslots-1):; self.time[k+1] = self.time[k] + self.tau[k]; ; self._pulse_initialised = True. if not self.lbound is None:; if np.isinf(self.lbound):; self.lbound = None; if not self.ubound is None:; if np.isinf(self.ubound):; self.ubound = None; ; if not self.ubound is None and not self.lbound is None:; if self.ubou",MatchSource.WIKI,docs/4.2/modules/qutip/control/pulsegen.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/control/pulsegen.html
https://qutip.org/docs/4.2/modules/qutip/control/pulsegen.html:8293,Testability,log,logger,8293,".scaling = dyn.initial_ctrl_scaling; self.offset = dyn.initial_ctrl_offset; self.tau = dyn.tau; self.log_level = dyn.log_level; else:; self.num_tslots = 100; self.pulse_time = 1.0; self.scaling = 1.0; self.tau = None; self.offset = 0.0. self._uses_time = False; self.time = None; self._pulse_initialised = False; self.periodic = False; self.random = False; self.lbound = None; self.ubound = None; self.ramping_pulse = None; ; self.apply_params(); ; [docs] def apply_params(self, params=None):; """"""; Set object attributes based on the dictionary (if any) passed in the ; instantiation, or passed as a parameter; This is called during the instantiation automatically.; The key value pairs are the attribute name and value; """""" ; if not params:; params = self.params; ; if isinstance(params, dict):; self.params = params; for key in params:; setattr(self, key, params[key]). @property; def log_level(self):; return logger.level ; ; @log_level.setter; def log_level(self, lvl):; """"""; Set the log_level attribute and set the level of the logger; that is call logger.setLevel(lvl); """"""; logger.setLevel(lvl); ; [docs] def gen_pulse(self):; """"""; returns the pulse as an array of vales for each timeslot; Must be implemented by subclass; """"""; # must be implemented by subclass; raise errors.UsageError(; ""No method defined for generating a pulse. ""; "" Suspect base class was used where sub class should have been""). [docs] def init_pulse(self):; """"""; Initialise the pulse parameters; """"""; if self.tau is None:; self.tau = np.ones(self.num_tslots, dtype='f') * \; self.pulse_time/self.num_tslots; ; if self._uses_time:; self.time = np.zeros(self.num_tslots, dtype=float); for k in range(self.num_tslots-1):; self.time[k+1] = self.time[k] + self.tau[k]; ; self._pulse_initialised = True. if not self.lbound is None:; if np.isinf(self.lbound):; self.lbound = None; if not self.ubound is None:; if np.isinf(self.ubound):; self.ubound = None; ; if not self.ubound is None and not self.lbound is None:; if self.ubou",MatchSource.WIKI,docs/4.2/modules/qutip/control/pulsegen.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/control/pulsegen.html
https://qutip.org/docs/4.2/modules/qutip/control/pulsegen.html:8320,Testability,log,logger,8320,"; self.tau = dyn.tau; self.log_level = dyn.log_level; else:; self.num_tslots = 100; self.pulse_time = 1.0; self.scaling = 1.0; self.tau = None; self.offset = 0.0. self._uses_time = False; self.time = None; self._pulse_initialised = False; self.periodic = False; self.random = False; self.lbound = None; self.ubound = None; self.ramping_pulse = None; ; self.apply_params(); ; [docs] def apply_params(self, params=None):; """"""; Set object attributes based on the dictionary (if any) passed in the ; instantiation, or passed as a parameter; This is called during the instantiation automatically.; The key value pairs are the attribute name and value; """""" ; if not params:; params = self.params; ; if isinstance(params, dict):; self.params = params; for key in params:; setattr(self, key, params[key]). @property; def log_level(self):; return logger.level ; ; @log_level.setter; def log_level(self, lvl):; """"""; Set the log_level attribute and set the level of the logger; that is call logger.setLevel(lvl); """"""; logger.setLevel(lvl); ; [docs] def gen_pulse(self):; """"""; returns the pulse as an array of vales for each timeslot; Must be implemented by subclass; """"""; # must be implemented by subclass; raise errors.UsageError(; ""No method defined for generating a pulse. ""; "" Suspect base class was used where sub class should have been""). [docs] def init_pulse(self):; """"""; Initialise the pulse parameters; """"""; if self.tau is None:; self.tau = np.ones(self.num_tslots, dtype='f') * \; self.pulse_time/self.num_tslots; ; if self._uses_time:; self.time = np.zeros(self.num_tslots, dtype=float); for k in range(self.num_tslots-1):; self.time[k+1] = self.time[k] + self.tau[k]; ; self._pulse_initialised = True. if not self.lbound is None:; if np.isinf(self.lbound):; self.lbound = None; if not self.ubound is None:; if np.isinf(self.ubound):; self.ubound = None; ; if not self.ubound is None and not self.lbound is None:; if self.ubound < self.lbound:; raise ValueError(""ubound cannot be less the lbound""). d",MatchSource.WIKI,docs/4.2/modules/qutip/control/pulsegen.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/control/pulsegen.html
https://qutip.org/docs/4.2/modules/qutip/control/pulsegen.html:29082,Testability,log,logging,29082," initialised, otherwise they will all be equal to self.scaling; """"""; def __init__(self, dyn=None, num_coeffs=None, params=None):; self.parent = dyn; self.num_coeffs = num_coeffs; self.params = params; self.reset(); ; [docs] def reset(self):; """"""; reset attributes to default values; """"""; PulseGen.reset(self); self.NUM_COEFFS_WARN_LVL = 20; self.DEF_NUM_COEFFS = 4; self._BSC_ALL = 1; self._BSC_GT_MEAN = 2; self._BSC_LT_MEAN = 3; ; self._uses_time = True; self.time = None; self.num_basis_funcs = 2; self.num_optim_vars = 0; self.coeffs = None; self.randomize_coeffs = True; self._num_coeffs_estimated = False; self.guess_pulse_action = 'MODULATE'; self.guess_pulse = None; self.guess_pulse_func = None; self.apply_params(); ; [docs] def init_pulse(self, num_coeffs=None):; """"""; Set the initial freq and coefficient values; """"""; PulseGen.init_pulse(self); self.init_coeffs(num_coeffs=num_coeffs); ; if self.guess_pulse is not None:; self.init_guess_pulse(); self._init_bounds(); ; if self.log_level <= logging.DEBUG and not self._num_coeffs_estimated:; logger.debug(; ""CRAB pulse initialised with {} coefficients per basis ""; ""function, which means a total of {} ""; ""optimisation variables for this pulse"".format(; self.num_coeffs, self.num_optim_vars)); ; # def generate_guess_pulse(self); # if isinstance(self.guess_pulsegen, PulseGen):; # self.guess_pulse = self.guess_pulsegen.gen_pulse(); # return self.guess_pulse; ; [docs] def init_coeffs(self, num_coeffs=None):; """"""; Generate the initial ceofficent values.; ; Parameters; ----------; num_coeffs : integer; Number of coefficients used for each basis function; If given this overides the default and sets the attribute; of the same name.; """"""; if num_coeffs:; self.num_coeffs = num_coeffs; ; self._num_coeffs_estimated = False; if not self.num_coeffs:; if isinstance(self.parent, dynamics.Dynamics):; dim = self.parent.get_drift_dim(); self.num_coeffs = self.estimate_num_coeffs(dim); self._num_coeffs_estimated = True; else:; self.num_coeffs ",MatchSource.WIKI,docs/4.2/modules/qutip/control/pulsegen.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/control/pulsegen.html
https://qutip.org/docs/4.2/modules/qutip/control/pulsegen.html:29133,Testability,log,logger,29133,"l to self.scaling; """"""; def __init__(self, dyn=None, num_coeffs=None, params=None):; self.parent = dyn; self.num_coeffs = num_coeffs; self.params = params; self.reset(); ; [docs] def reset(self):; """"""; reset attributes to default values; """"""; PulseGen.reset(self); self.NUM_COEFFS_WARN_LVL = 20; self.DEF_NUM_COEFFS = 4; self._BSC_ALL = 1; self._BSC_GT_MEAN = 2; self._BSC_LT_MEAN = 3; ; self._uses_time = True; self.time = None; self.num_basis_funcs = 2; self.num_optim_vars = 0; self.coeffs = None; self.randomize_coeffs = True; self._num_coeffs_estimated = False; self.guess_pulse_action = 'MODULATE'; self.guess_pulse = None; self.guess_pulse_func = None; self.apply_params(); ; [docs] def init_pulse(self, num_coeffs=None):; """"""; Set the initial freq and coefficient values; """"""; PulseGen.init_pulse(self); self.init_coeffs(num_coeffs=num_coeffs); ; if self.guess_pulse is not None:; self.init_guess_pulse(); self._init_bounds(); ; if self.log_level <= logging.DEBUG and not self._num_coeffs_estimated:; logger.debug(; ""CRAB pulse initialised with {} coefficients per basis ""; ""function, which means a total of {} ""; ""optimisation variables for this pulse"".format(; self.num_coeffs, self.num_optim_vars)); ; # def generate_guess_pulse(self); # if isinstance(self.guess_pulsegen, PulseGen):; # self.guess_pulse = self.guess_pulsegen.gen_pulse(); # return self.guess_pulse; ; [docs] def init_coeffs(self, num_coeffs=None):; """"""; Generate the initial ceofficent values.; ; Parameters; ----------; num_coeffs : integer; Number of coefficients used for each basis function; If given this overides the default and sets the attribute; of the same name.; """"""; if num_coeffs:; self.num_coeffs = num_coeffs; ; self._num_coeffs_estimated = False; if not self.num_coeffs:; if isinstance(self.parent, dynamics.Dynamics):; dim = self.parent.get_drift_dim(); self.num_coeffs = self.estimate_num_coeffs(dim); self._num_coeffs_estimated = True; else:; self.num_coeffs = self.DEF_NUM_COEFFS; self.num_optim_vars = ",MatchSource.WIKI,docs/4.2/modules/qutip/control/pulsegen.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/control/pulsegen.html
https://qutip.org/docs/4.2/modules/qutip/control/pulsegen.html:30218,Testability,log,logging,30218,", which means a total of {} ""; ""optimisation variables for this pulse"".format(; self.num_coeffs, self.num_optim_vars)); ; # def generate_guess_pulse(self); # if isinstance(self.guess_pulsegen, PulseGen):; # self.guess_pulse = self.guess_pulsegen.gen_pulse(); # return self.guess_pulse; ; [docs] def init_coeffs(self, num_coeffs=None):; """"""; Generate the initial ceofficent values.; ; Parameters; ----------; num_coeffs : integer; Number of coefficients used for each basis function; If given this overides the default and sets the attribute; of the same name.; """"""; if num_coeffs:; self.num_coeffs = num_coeffs; ; self._num_coeffs_estimated = False; if not self.num_coeffs:; if isinstance(self.parent, dynamics.Dynamics):; dim = self.parent.get_drift_dim(); self.num_coeffs = self.estimate_num_coeffs(dim); self._num_coeffs_estimated = True; else:; self.num_coeffs = self.DEF_NUM_COEFFS; self.num_optim_vars = self.num_coeffs*self.num_basis_funcs; ; if self._num_coeffs_estimated:; if self.log_level <= logging.INFO:; logger.info(; ""The number of CRAB coefficients per basis function ""; ""has been estimated as {}, which means a total of {} ""; ""optimisation variables for this pulse. Based on the ""; ""dimension ({}) of the system"".format(; self.num_coeffs, self.num_optim_vars, dim)); # Issue warning if beyond the recommended level; if self.log_level <= logging.WARN:; if self.num_coeffs > self.NUM_COEFFS_WARN_LVL:; logger.warn(; ""The estimated number of coefficients {} exceeds ""; ""the amount ({}) recommended for efficient ""; ""optimisation. You can set this level explicitly ""; ""to suppress this message."".format(; self.num_coeffs, self.NUM_COEFFS_WARN_LVL)); ; if self.randomize_coeffs:; r = np.random.random([self.num_coeffs, self.num_basis_funcs]); self.coeffs = (2*r - 1.0) * self.scaling; else:; self.coeffs = np.ones([self.num_coeffs, ; self.num_basis_funcs])*self.scaling; ; [docs] def estimate_num_coeffs(self, dim):; """"""; Estimate the number coefficients based on the dimensionality of the",MatchSource.WIKI,docs/4.2/modules/qutip/control/pulsegen.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/control/pulsegen.html
https://qutip.org/docs/4.2/modules/qutip/control/pulsegen.html:30233,Testability,log,logger,30233,"tal of {} ""; ""optimisation variables for this pulse"".format(; self.num_coeffs, self.num_optim_vars)); ; # def generate_guess_pulse(self); # if isinstance(self.guess_pulsegen, PulseGen):; # self.guess_pulse = self.guess_pulsegen.gen_pulse(); # return self.guess_pulse; ; [docs] def init_coeffs(self, num_coeffs=None):; """"""; Generate the initial ceofficent values.; ; Parameters; ----------; num_coeffs : integer; Number of coefficients used for each basis function; If given this overides the default and sets the attribute; of the same name.; """"""; if num_coeffs:; self.num_coeffs = num_coeffs; ; self._num_coeffs_estimated = False; if not self.num_coeffs:; if isinstance(self.parent, dynamics.Dynamics):; dim = self.parent.get_drift_dim(); self.num_coeffs = self.estimate_num_coeffs(dim); self._num_coeffs_estimated = True; else:; self.num_coeffs = self.DEF_NUM_COEFFS; self.num_optim_vars = self.num_coeffs*self.num_basis_funcs; ; if self._num_coeffs_estimated:; if self.log_level <= logging.INFO:; logger.info(; ""The number of CRAB coefficients per basis function ""; ""has been estimated as {}, which means a total of {} ""; ""optimisation variables for this pulse. Based on the ""; ""dimension ({}) of the system"".format(; self.num_coeffs, self.num_optim_vars, dim)); # Issue warning if beyond the recommended level; if self.log_level <= logging.WARN:; if self.num_coeffs > self.NUM_COEFFS_WARN_LVL:; logger.warn(; ""The estimated number of coefficients {} exceeds ""; ""the amount ({}) recommended for efficient ""; ""optimisation. You can set this level explicitly ""; ""to suppress this message."".format(; self.num_coeffs, self.NUM_COEFFS_WARN_LVL)); ; if self.randomize_coeffs:; r = np.random.random([self.num_coeffs, self.num_basis_funcs]); self.coeffs = (2*r - 1.0) * self.scaling; else:; self.coeffs = np.ones([self.num_coeffs, ; self.num_basis_funcs])*self.scaling; ; [docs] def estimate_num_coeffs(self, dim):; """"""; Estimate the number coefficients based on the dimensionality of the; system.; Return",MatchSource.WIKI,docs/4.2/modules/qutip/control/pulsegen.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/control/pulsegen.html
https://qutip.org/docs/4.2/modules/qutip/control/pulsegen.html:30569,Testability,log,logging,30569,"he initial ceofficent values.; ; Parameters; ----------; num_coeffs : integer; Number of coefficients used for each basis function; If given this overides the default and sets the attribute; of the same name.; """"""; if num_coeffs:; self.num_coeffs = num_coeffs; ; self._num_coeffs_estimated = False; if not self.num_coeffs:; if isinstance(self.parent, dynamics.Dynamics):; dim = self.parent.get_drift_dim(); self.num_coeffs = self.estimate_num_coeffs(dim); self._num_coeffs_estimated = True; else:; self.num_coeffs = self.DEF_NUM_COEFFS; self.num_optim_vars = self.num_coeffs*self.num_basis_funcs; ; if self._num_coeffs_estimated:; if self.log_level <= logging.INFO:; logger.info(; ""The number of CRAB coefficients per basis function ""; ""has been estimated as {}, which means a total of {} ""; ""optimisation variables for this pulse. Based on the ""; ""dimension ({}) of the system"".format(; self.num_coeffs, self.num_optim_vars, dim)); # Issue warning if beyond the recommended level; if self.log_level <= logging.WARN:; if self.num_coeffs > self.NUM_COEFFS_WARN_LVL:; logger.warn(; ""The estimated number of coefficients {} exceeds ""; ""the amount ({}) recommended for efficient ""; ""optimisation. You can set this level explicitly ""; ""to suppress this message."".format(; self.num_coeffs, self.NUM_COEFFS_WARN_LVL)); ; if self.randomize_coeffs:; r = np.random.random([self.num_coeffs, self.num_basis_funcs]); self.coeffs = (2*r - 1.0) * self.scaling; else:; self.coeffs = np.ones([self.num_coeffs, ; self.num_basis_funcs])*self.scaling; ; [docs] def estimate_num_coeffs(self, dim):; """"""; Estimate the number coefficients based on the dimensionality of the; system.; Returns; -------; num_coeffs : int; estimated number of coefficients; """"""; num_coeffs = max(2, dim - 1); return num_coeffs; ; [docs] def get_optim_var_vals(self):; """"""; Get the parameter values to be optimised; Returns; -------; list (or 1d array) of floats ; """"""; return self.coeffs.ravel().tolist(); ; [docs] def set_optim_var_vals(self, ",MatchSource.WIKI,docs/4.2/modules/qutip/control/pulsegen.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/control/pulsegen.html
https://qutip.org/docs/4.2/modules/qutip/control/pulsegen.html:30632,Testability,log,logger,30632,"um_coeffs : integer; Number of coefficients used for each basis function; If given this overides the default and sets the attribute; of the same name.; """"""; if num_coeffs:; self.num_coeffs = num_coeffs; ; self._num_coeffs_estimated = False; if not self.num_coeffs:; if isinstance(self.parent, dynamics.Dynamics):; dim = self.parent.get_drift_dim(); self.num_coeffs = self.estimate_num_coeffs(dim); self._num_coeffs_estimated = True; else:; self.num_coeffs = self.DEF_NUM_COEFFS; self.num_optim_vars = self.num_coeffs*self.num_basis_funcs; ; if self._num_coeffs_estimated:; if self.log_level <= logging.INFO:; logger.info(; ""The number of CRAB coefficients per basis function ""; ""has been estimated as {}, which means a total of {} ""; ""optimisation variables for this pulse. Based on the ""; ""dimension ({}) of the system"".format(; self.num_coeffs, self.num_optim_vars, dim)); # Issue warning if beyond the recommended level; if self.log_level <= logging.WARN:; if self.num_coeffs > self.NUM_COEFFS_WARN_LVL:; logger.warn(; ""The estimated number of coefficients {} exceeds ""; ""the amount ({}) recommended for efficient ""; ""optimisation. You can set this level explicitly ""; ""to suppress this message."".format(; self.num_coeffs, self.NUM_COEFFS_WARN_LVL)); ; if self.randomize_coeffs:; r = np.random.random([self.num_coeffs, self.num_basis_funcs]); self.coeffs = (2*r - 1.0) * self.scaling; else:; self.coeffs = np.ones([self.num_coeffs, ; self.num_basis_funcs])*self.scaling; ; [docs] def estimate_num_coeffs(self, dim):; """"""; Estimate the number coefficients based on the dimensionality of the; system.; Returns; -------; num_coeffs : int; estimated number of coefficients; """"""; num_coeffs = max(2, dim - 1); return num_coeffs; ; [docs] def get_optim_var_vals(self):; """"""; Get the parameter values to be optimised; Returns; -------; list (or 1d array) of floats ; """"""; return self.coeffs.ravel().tolist(); ; [docs] def set_optim_var_vals(self, param_vals):; """"""; Set the values of the any of the pulse ",MatchSource.WIKI,docs/4.2/modules/qutip/control/pulsegen.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/control/pulsegen.html
https://qutip.org/docs/4.2/modules/qutip/control/pulsegen.html:32081,Testability,log,logger,32081,"s_funcs])*self.scaling; ; [docs] def estimate_num_coeffs(self, dim):; """"""; Estimate the number coefficients based on the dimensionality of the; system.; Returns; -------; num_coeffs : int; estimated number of coefficients; """"""; num_coeffs = max(2, dim - 1); return num_coeffs; ; [docs] def get_optim_var_vals(self):; """"""; Get the parameter values to be optimised; Returns; -------; list (or 1d array) of floats ; """"""; return self.coeffs.ravel().tolist(); ; [docs] def set_optim_var_vals(self, param_vals):; """"""; Set the values of the any of the pulse generation parameters; based on new values from the optimisation method; Typically this will be the basis coefficients; """"""; # Type and size checking avoided here as this is in the ; # main optmisation call sequence; self.set_coeffs(param_vals); ; def set_coeffs(self, param_vals):; self.coeffs = param_vals.reshape(; [self.num_coeffs, self.num_basis_funcs]); ; def init_guess_pulse(self):; ; self.guess_pulse_func = None; if not self.guess_pulse_action:; logger.WARN(""No guess pulse action given, hence ignored.""); elif self.guess_pulse_action.upper() == 'MODULATE':; self.guess_pulse_func = self.guess_pulse_modulate; elif self.guess_pulse_action.upper() == 'ADD':; self.guess_pulse_func = self.guess_pulse_add; else:; logger.WARN(""No option for guess pulse action '{}' ""; "", hence ignored."".format(self.guess_pulse_action)); ; def guess_pulse_add(self, pulse):; pulse = pulse + self.guess_pulse; return pulse; ; def guess_pulse_modulate(self, pulse):; pulse = (1.0 + pulse)*self.guess_pulse; return pulse; ; def _init_bounds(self):; add_guess_pulse_scale = False; if self.lbound is None and self.ubound is None:; # no bounds to apply; self._bound_scale_cond = None; elif self.lbound is None:; # only upper bound; if self.ubound > 0:; self._bound_mean = 0.0; self._bound_scale = self.ubound; else:; add_guess_pulse_scale = True; self._bound_scale = self.scaling*self.num_coeffs + \; self.get_guess_pulse_scale(); self._bound_mean = -abs(self._boun",MatchSource.WIKI,docs/4.2/modules/qutip/control/pulsegen.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/control/pulsegen.html
https://qutip.org/docs/4.2/modules/qutip/control/pulsegen.html:32346,Testability,log,logger,32346,"n num_coeffs; ; [docs] def get_optim_var_vals(self):; """"""; Get the parameter values to be optimised; Returns; -------; list (or 1d array) of floats ; """"""; return self.coeffs.ravel().tolist(); ; [docs] def set_optim_var_vals(self, param_vals):; """"""; Set the values of the any of the pulse generation parameters; based on new values from the optimisation method; Typically this will be the basis coefficients; """"""; # Type and size checking avoided here as this is in the ; # main optmisation call sequence; self.set_coeffs(param_vals); ; def set_coeffs(self, param_vals):; self.coeffs = param_vals.reshape(; [self.num_coeffs, self.num_basis_funcs]); ; def init_guess_pulse(self):; ; self.guess_pulse_func = None; if not self.guess_pulse_action:; logger.WARN(""No guess pulse action given, hence ignored.""); elif self.guess_pulse_action.upper() == 'MODULATE':; self.guess_pulse_func = self.guess_pulse_modulate; elif self.guess_pulse_action.upper() == 'ADD':; self.guess_pulse_func = self.guess_pulse_add; else:; logger.WARN(""No option for guess pulse action '{}' ""; "", hence ignored."".format(self.guess_pulse_action)); ; def guess_pulse_add(self, pulse):; pulse = pulse + self.guess_pulse; return pulse; ; def guess_pulse_modulate(self, pulse):; pulse = (1.0 + pulse)*self.guess_pulse; return pulse; ; def _init_bounds(self):; add_guess_pulse_scale = False; if self.lbound is None and self.ubound is None:; # no bounds to apply; self._bound_scale_cond = None; elif self.lbound is None:; # only upper bound; if self.ubound > 0:; self._bound_mean = 0.0; self._bound_scale = self.ubound; else:; add_guess_pulse_scale = True; self._bound_scale = self.scaling*self.num_coeffs + \; self.get_guess_pulse_scale(); self._bound_mean = -abs(self._bound_scale) + self.ubound; self._bound_scale_cond = self._BSC_GT_MEAN. elif self.ubound is None:; # only lower bound; if self.lbound < 0:; self._bound_mean = 0.0; self._bound_scale = abs(self.lbound); else:; self._bound_scale = self.scaling*self.num_coeffs + \; self.",MatchSource.WIKI,docs/4.2/modules/qutip/control/pulsegen.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/control/pulsegen.html
https://qutip.org/docs/4.2/modules/qutip/control/pulsegen.html:11044,Usability,simpl,simply,11044,"und - max_amp; else:; # min_amp + offset must exceed the lbound; return pulse + self.lbound - min_amp; else:; bound_range = self.ubound - self.lbound; amp_range = max_amp - min_amp; if max_amp - min_amp > bound_range:; # pulse range is too high, it must be scaled; pulse = pulse * bound_range / amp_range. # otherwise the pulse should fit anyway; return pulse + self.lbound - min(pulse). def _apply_ramping_pulse(self, pulse, ramping_pulse=None):; if ramping_pulse is None:; ramping_pulse = self.ramping_pulse; if ramping_pulse is not None:; pulse = pulse*ramping_pulse; ; return pulse; ; [docs]class PulseGenZero(PulseGen):; """"""; Generates a flat pulse; """"""; [docs] def gen_pulse(self):; """"""; Generate a pulse with the same value in every timeslot.; The value will be zero, unless the offset is not zero,; in which case it will be the offset; """"""; pulse = np.zeros(self.num_tslots); return self._apply_bounds_and_offset(pulse). [docs]class PulseGenRandom(PulseGen):; """"""; Generates random pulses as simply random values for each timeslot; """"""; def reset(self):; PulseGen.reset(self); self.random = True; self.apply_params(). [docs] def gen_pulse(self):; """"""; Generate a pulse of random values between 1 and -1; Values are scaled using the scaling property; and shifted using the offset property; Returns the pulse as an array of vales for each timeslot; """"""; pulse = (2*np.random.random(self.num_tslots) - 1) * self.scaling. return self._apply_bounds_and_offset(pulse). class PulseGenRndFourier(PulseGen):; """"""; Generates pulses by summing sine waves as a Fourier series; with random coefficients. Attributes; ----------; scaling : float; The pulses should fit approximately within -/+scaling; (before the offset is applied); as it is used to set a maximum for each component wave; Use bounds to be sure; (copied from Dynamics.initial_ctrl_scaling if given). min_wavelen : float; Minimum wavelength of any component wave; Set by default to 1/10th of the pulse time; """""". def reset(self):; """"""; reset",MatchSource.WIKI,docs/4.2/modules/qutip/control/pulsegen.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/control/pulsegen.html
https://qutip.org/docs/4.2/modules/qutip/control/pulseoptim.html:2472,Availability,error,error,2472,"TORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,; # SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT; # LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,; # DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY; # THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT; # (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE; # OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.; ###############################################################################. # @author: Alexander Pitchford; # @email1: agp1@aber.ac.uk; # @email2: alex.pitchford@gmail.com; # @organization: Aberystwyth University; # @supervisor: Daniel Burgarth. """"""; Wrapper functions that will manage the creation of the objects,; build the configuration, and execute the algorithm required to optimise; a set of ctrl pulses for a given (quantum) system.; The fidelity error is some measure of distance of the system evolution; from the given target evolution in the time allowed for the evolution.; The functions minimise this fidelity error wrt the piecewise control; amplitudes in the timeslots. There are currently two quantum control pulse optmisations algorithms; implemented in this library. There are accessible through the methods; in this module. Both the algorithms use the scipy.optimize methods; to minimise the fidelity error with respect to to variables that define; the pulse. GRAPE; -----; The default algorithm (as it was implemented here first) is GRAPE; GRadient Ascent Pulse Engineering [1][2]. It uses a gradient based method such; as BFGS to minimise the fidelity error. This makes convergence very quick; when an exact gradient can be calculated, but this limits the factors that can; taken into account in the fidelity. CRAB; ----; The CRAB [3][4] algorithm was developed at the University of Ulm.; In full it is the Chopped RAndom Basis algorithm.; The main difference is that it reduces the number o",MatchSource.WIKI,docs/4.2/modules/qutip/control/pulseoptim.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/control/pulseoptim.html
https://qutip.org/docs/4.2/modules/qutip/control/pulseoptim.html:2640,Availability,error,error,2640,"# LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,; # DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY; # THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT; # (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE; # OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.; ###############################################################################. # @author: Alexander Pitchford; # @email1: agp1@aber.ac.uk; # @email2: alex.pitchford@gmail.com; # @organization: Aberystwyth University; # @supervisor: Daniel Burgarth. """"""; Wrapper functions that will manage the creation of the objects,; build the configuration, and execute the algorithm required to optimise; a set of ctrl pulses for a given (quantum) system.; The fidelity error is some measure of distance of the system evolution; from the given target evolution in the time allowed for the evolution.; The functions minimise this fidelity error wrt the piecewise control; amplitudes in the timeslots. There are currently two quantum control pulse optmisations algorithms; implemented in this library. There are accessible through the methods; in this module. Both the algorithms use the scipy.optimize methods; to minimise the fidelity error with respect to to variables that define; the pulse. GRAPE; -----; The default algorithm (as it was implemented here first) is GRAPE; GRadient Ascent Pulse Engineering [1][2]. It uses a gradient based method such; as BFGS to minimise the fidelity error. This makes convergence very quick; when an exact gradient can be calculated, but this limits the factors that can; taken into account in the fidelity. CRAB; ----; The CRAB [3][4] algorithm was developed at the University of Ulm.; In full it is the Chopped RAndom Basis algorithm.; The main difference is that it reduces the number of optimisation variables ; by defining the control pulses by expansions of basis functions, ; where the variables are the ",MatchSource.WIKI,docs/4.2/modules/qutip/control/pulseoptim.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/control/pulseoptim.html
https://qutip.org/docs/4.2/modules/qutip/control/pulseoptim.html:2937,Availability,error,error,2937,"F THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.; ###############################################################################. # @author: Alexander Pitchford; # @email1: agp1@aber.ac.uk; # @email2: alex.pitchford@gmail.com; # @organization: Aberystwyth University; # @supervisor: Daniel Burgarth. """"""; Wrapper functions that will manage the creation of the objects,; build the configuration, and execute the algorithm required to optimise; a set of ctrl pulses for a given (quantum) system.; The fidelity error is some measure of distance of the system evolution; from the given target evolution in the time allowed for the evolution.; The functions minimise this fidelity error wrt the piecewise control; amplitudes in the timeslots. There are currently two quantum control pulse optmisations algorithms; implemented in this library. There are accessible through the methods; in this module. Both the algorithms use the scipy.optimize methods; to minimise the fidelity error with respect to to variables that define; the pulse. GRAPE; -----; The default algorithm (as it was implemented here first) is GRAPE; GRadient Ascent Pulse Engineering [1][2]. It uses a gradient based method such; as BFGS to minimise the fidelity error. This makes convergence very quick; when an exact gradient can be calculated, but this limits the factors that can; taken into account in the fidelity. CRAB; ----; The CRAB [3][4] algorithm was developed at the University of Ulm.; In full it is the Chopped RAndom Basis algorithm.; The main difference is that it reduces the number of optimisation variables ; by defining the control pulses by expansions of basis functions, ; where the variables are the coefficients. Typically a Fourier series is chosen, ; i.e. the variables are the Fourier coefficients. ; Therefore it does not need to compute an explicit gradient. ; By default it uses the Nelder-Mead method for fidelity error minimisation. . References; ----------; 1. N Khaneja et. al. ; Opt",MatchSource.WIKI,docs/4.2/modules/qutip/control/pulseoptim.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/control/pulseoptim.html
https://qutip.org/docs/4.2/modules/qutip/control/pulseoptim.html:3190,Availability,error,error,3190,"email2: alex.pitchford@gmail.com; # @organization: Aberystwyth University; # @supervisor: Daniel Burgarth. """"""; Wrapper functions that will manage the creation of the objects,; build the configuration, and execute the algorithm required to optimise; a set of ctrl pulses for a given (quantum) system.; The fidelity error is some measure of distance of the system evolution; from the given target evolution in the time allowed for the evolution.; The functions minimise this fidelity error wrt the piecewise control; amplitudes in the timeslots. There are currently two quantum control pulse optmisations algorithms; implemented in this library. There are accessible through the methods; in this module. Both the algorithms use the scipy.optimize methods; to minimise the fidelity error with respect to to variables that define; the pulse. GRAPE; -----; The default algorithm (as it was implemented here first) is GRAPE; GRadient Ascent Pulse Engineering [1][2]. It uses a gradient based method such; as BFGS to minimise the fidelity error. This makes convergence very quick; when an exact gradient can be calculated, but this limits the factors that can; taken into account in the fidelity. CRAB; ----; The CRAB [3][4] algorithm was developed at the University of Ulm.; In full it is the Chopped RAndom Basis algorithm.; The main difference is that it reduces the number of optimisation variables ; by defining the control pulses by expansions of basis functions, ; where the variables are the coefficients. Typically a Fourier series is chosen, ; i.e. the variables are the Fourier coefficients. ; Therefore it does not need to compute an explicit gradient. ; By default it uses the Nelder-Mead method for fidelity error minimisation. . References; ----------; 1. N Khaneja et. al. ; Optimal control of coupled spin dynamics: Design of NMR pulse sequences ; by gradient ascent algorithms. J. Magn. Reson. 172, 296â305 (2005).; 2. Shai Machnes et.al; DYNAMO - Dynamic Framework for Quantum Optimal Co",MatchSource.WIKI,docs/4.2/modules/qutip/control/pulseoptim.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/control/pulseoptim.html
https://qutip.org/docs/4.2/modules/qutip/control/pulseoptim.html:3873,Availability,error,error,3873,"odule. Both the algorithms use the scipy.optimize methods; to minimise the fidelity error with respect to to variables that define; the pulse. GRAPE; -----; The default algorithm (as it was implemented here first) is GRAPE; GRadient Ascent Pulse Engineering [1][2]. It uses a gradient based method such; as BFGS to minimise the fidelity error. This makes convergence very quick; when an exact gradient can be calculated, but this limits the factors that can; taken into account in the fidelity. CRAB; ----; The CRAB [3][4] algorithm was developed at the University of Ulm.; In full it is the Chopped RAndom Basis algorithm.; The main difference is that it reduces the number of optimisation variables ; by defining the control pulses by expansions of basis functions, ; where the variables are the coefficients. Typically a Fourier series is chosen, ; i.e. the variables are the Fourier coefficients. ; Therefore it does not need to compute an explicit gradient. ; By default it uses the Nelder-Mead method for fidelity error minimisation. . References; ----------; 1. N Khaneja et. al. ; Optimal control of coupled spin dynamics: Design of NMR pulse sequences ; by gradient ascent algorithms. J. Magn. Reson. 172, 296â305 (2005).; 2. Shai Machnes et.al; DYNAMO - Dynamic Framework for Quantum Optimal Control; arXiv.1011.4874; 3. Doria, P., Calarco, T. & Montangero, S. ; Optimal Control Technique for Many-Body Quantum Dynamics. ; Phys. Rev. Lett. 106, 1â4 (2011).; 4. Caneva, T., Calarco, T. & Montangero, S. ; Chopped random-basis quantum optimization. ; Phys. Rev. A - At. Mol. Opt. Phys. 84, (2011). """"""; import numpy as np; import warnings. # QuTiP; from qutip import Qobj; import qutip.logging_utils as logging; logger = logging.get_logger(); # QuTiP control modules; import qutip.control.optimconfig as optimconfig; import qutip.control.dynamics as dynamics; import qutip.control.termcond as termcond; import qutip.control.optimizer as optimizer; import qutip.control.stats as stats; import q",MatchSource.WIKI,docs/4.2/modules/qutip/control/pulseoptim.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/control/pulseoptim.html
https://qutip.org/docs/4.2/modules/qutip/control/pulseoptim.html:4867,Availability,error,errors,4867,"imisation. . References; ----------; 1. N Khaneja et. al. ; Optimal control of coupled spin dynamics: Design of NMR pulse sequences ; by gradient ascent algorithms. J. Magn. Reson. 172, 296â305 (2005).; 2. Shai Machnes et.al; DYNAMO - Dynamic Framework for Quantum Optimal Control; arXiv.1011.4874; 3. Doria, P., Calarco, T. & Montangero, S. ; Optimal Control Technique for Many-Body Quantum Dynamics. ; Phys. Rev. Lett. 106, 1â4 (2011).; 4. Caneva, T., Calarco, T. & Montangero, S. ; Chopped random-basis quantum optimization. ; Phys. Rev. A - At. Mol. Opt. Phys. 84, (2011). """"""; import numpy as np; import warnings. # QuTiP; from qutip import Qobj; import qutip.logging_utils as logging; logger = logging.get_logger(); # QuTiP control modules; import qutip.control.optimconfig as optimconfig; import qutip.control.dynamics as dynamics; import qutip.control.termcond as termcond; import qutip.control.optimizer as optimizer; import qutip.control.stats as stats; import qutip.control.errors as errors; import qutip.control.fidcomp as fidcomp; import qutip.control.propcomp as propcomp; import qutip.control.pulsegen as pulsegen; #import qutip.control.pulsegencrab as pulsegencrab. warnings.simplefilter('always', DeprecationWarning) #turn off filter ; def _param_deprecation(message, stacklevel=3):; """"""; Issue deprecation warning; Using stacklevel=3 will ensure message refers the function; calling with the deprecated parameter,; """"""; warnings.warn(message, DeprecationWarning, stacklevel=stacklevel); ; def _upper_safe(s):; try:; s = s.upper(); except:; pass; return s; ; [docs]def optimize_pulse(; drift, ctrls, initial, target,; num_tslots=None, evo_time=None, tau=None,; amp_lbound=None, amp_ubound=None,; fid_err_targ=1e-10, min_grad=1e-10,; max_iter=500, max_wall_time=180,; alg='GRAPE', alg_params=None,; optim_params=None, optim_method='DEF', method_params=None,; optim_alg=None, max_metric_corr=None, accuracy_factor=None,; dyn_type='GEN_MAT', dyn_params=None,; prop_type='DEF', prop_param",MatchSource.WIKI,docs/4.2/modules/qutip/control/pulseoptim.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/control/pulseoptim.html
https://qutip.org/docs/4.2/modules/qutip/control/pulseoptim.html:4877,Availability,error,errors,4877,"imisation. . References; ----------; 1. N Khaneja et. al. ; Optimal control of coupled spin dynamics: Design of NMR pulse sequences ; by gradient ascent algorithms. J. Magn. Reson. 172, 296â305 (2005).; 2. Shai Machnes et.al; DYNAMO - Dynamic Framework for Quantum Optimal Control; arXiv.1011.4874; 3. Doria, P., Calarco, T. & Montangero, S. ; Optimal Control Technique for Many-Body Quantum Dynamics. ; Phys. Rev. Lett. 106, 1â4 (2011).; 4. Caneva, T., Calarco, T. & Montangero, S. ; Chopped random-basis quantum optimization. ; Phys. Rev. A - At. Mol. Opt. Phys. 84, (2011). """"""; import numpy as np; import warnings. # QuTiP; from qutip import Qobj; import qutip.logging_utils as logging; logger = logging.get_logger(); # QuTiP control modules; import qutip.control.optimconfig as optimconfig; import qutip.control.dynamics as dynamics; import qutip.control.termcond as termcond; import qutip.control.optimizer as optimizer; import qutip.control.stats as stats; import qutip.control.errors as errors; import qutip.control.fidcomp as fidcomp; import qutip.control.propcomp as propcomp; import qutip.control.pulsegen as pulsegen; #import qutip.control.pulsegencrab as pulsegencrab. warnings.simplefilter('always', DeprecationWarning) #turn off filter ; def _param_deprecation(message, stacklevel=3):; """"""; Issue deprecation warning; Using stacklevel=3 will ensure message refers the function; calling with the deprecated parameter,; """"""; warnings.warn(message, DeprecationWarning, stacklevel=stacklevel); ; def _upper_safe(s):; try:; s = s.upper(); except:; pass; return s; ; [docs]def optimize_pulse(; drift, ctrls, initial, target,; num_tslots=None, evo_time=None, tau=None,; amp_lbound=None, amp_ubound=None,; fid_err_targ=1e-10, min_grad=1e-10,; max_iter=500, max_wall_time=180,; alg='GRAPE', alg_params=None,; optim_params=None, optim_method='DEF', method_params=None,; optim_alg=None, max_metric_corr=None, accuracy_factor=None,; dyn_type='GEN_MAT', dyn_params=None,; prop_type='DEF', prop_param",MatchSource.WIKI,docs/4.2/modules/qutip/control/pulseoptim.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/control/pulseoptim.html
https://qutip.org/docs/4.2/modules/qutip/control/pulseoptim.html:6292,Availability,error,error,6292,"e message refers the function; calling with the deprecated parameter,; """"""; warnings.warn(message, DeprecationWarning, stacklevel=stacklevel); ; def _upper_safe(s):; try:; s = s.upper(); except:; pass; return s; ; [docs]def optimize_pulse(; drift, ctrls, initial, target,; num_tslots=None, evo_time=None, tau=None,; amp_lbound=None, amp_ubound=None,; fid_err_targ=1e-10, min_grad=1e-10,; max_iter=500, max_wall_time=180,; alg='GRAPE', alg_params=None,; optim_params=None, optim_method='DEF', method_params=None,; optim_alg=None, max_metric_corr=None, accuracy_factor=None,; dyn_type='GEN_MAT', dyn_params=None,; prop_type='DEF', prop_params=None,; fid_type='DEF', fid_params=None,; phase_option=None, fid_err_scale_factor=None,; tslot_type='DEF', tslot_params=None,; amp_update_mode=None,; init_pulse_type='DEF', init_pulse_params=None,; pulse_scaling=1.0, pulse_offset=0.0,; ramping_pulse_type=None, ramping_pulse_params=None,; log_level=logging.NOTSET, out_file_ext=None, gen_stats=False):; """"""; Optimise a control pulse to minimise the fidelity error.; The dynamics of the system in any given timeslot are governed; by the combined dynamics generator,; i.e. the sum of the drift+ctrl_amp[j]*ctrls[j]; The control pulse is an [n_ts, n_ctrls)] array of piecewise amplitudes; Starting from an intital (typically random) pulse,; a multivariable optimisation algorithm attempts to determines the; optimal values for the control pulse to minimise the fidelity error; The fidelity error is some measure of distance of the system evolution; from the given target evolution in the time allowed for the evolution. Parameters; ----------; drift : Qobj or list of Qobj; the underlying dynamics generator of the system; can provide list (of length num_tslots) for time dependent drift. ctrls : List of Qobj or array like [num_tslots, evo_time]; a list of control dynamics generators. These are scaled by; the amplitudes to alter the overall dynamics; Array like imput can be provided for time dependent control ",MatchSource.WIKI,docs/4.2/modules/qutip/control/pulseoptim.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/control/pulseoptim.html
https://qutip.org/docs/4.2/modules/qutip/control/pulseoptim.html:6701,Availability,error,error,6701,"10,; max_iter=500, max_wall_time=180,; alg='GRAPE', alg_params=None,; optim_params=None, optim_method='DEF', method_params=None,; optim_alg=None, max_metric_corr=None, accuracy_factor=None,; dyn_type='GEN_MAT', dyn_params=None,; prop_type='DEF', prop_params=None,; fid_type='DEF', fid_params=None,; phase_option=None, fid_err_scale_factor=None,; tslot_type='DEF', tslot_params=None,; amp_update_mode=None,; init_pulse_type='DEF', init_pulse_params=None,; pulse_scaling=1.0, pulse_offset=0.0,; ramping_pulse_type=None, ramping_pulse_params=None,; log_level=logging.NOTSET, out_file_ext=None, gen_stats=False):; """"""; Optimise a control pulse to minimise the fidelity error.; The dynamics of the system in any given timeslot are governed; by the combined dynamics generator,; i.e. the sum of the drift+ctrl_amp[j]*ctrls[j]; The control pulse is an [n_ts, n_ctrls)] array of piecewise amplitudes; Starting from an intital (typically random) pulse,; a multivariable optimisation algorithm attempts to determines the; optimal values for the control pulse to minimise the fidelity error; The fidelity error is some measure of distance of the system evolution; from the given target evolution in the time allowed for the evolution. Parameters; ----------; drift : Qobj or list of Qobj; the underlying dynamics generator of the system; can provide list (of length num_tslots) for time dependent drift. ctrls : List of Qobj or array like [num_tslots, evo_time]; a list of control dynamics generators. These are scaled by; the amplitudes to alter the overall dynamics; Array like imput can be provided for time dependent control generators. initial : Qobj; starting point for the evolution.; Typically the identity matrix. target : Qobj; target transformation, e.g. gate or state, for the time evolution. num_tslots : integer or None; number of timeslots.; None implies that timeslots will be given in the tau array. evo_time : float or None; total time for the evolution; None implies that timeslots will be gi",MatchSource.WIKI,docs/4.2/modules/qutip/control/pulseoptim.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/control/pulseoptim.html
https://qutip.org/docs/4.2/modules/qutip/control/pulseoptim.html:6721,Availability,error,error,6721,"10,; max_iter=500, max_wall_time=180,; alg='GRAPE', alg_params=None,; optim_params=None, optim_method='DEF', method_params=None,; optim_alg=None, max_metric_corr=None, accuracy_factor=None,; dyn_type='GEN_MAT', dyn_params=None,; prop_type='DEF', prop_params=None,; fid_type='DEF', fid_params=None,; phase_option=None, fid_err_scale_factor=None,; tslot_type='DEF', tslot_params=None,; amp_update_mode=None,; init_pulse_type='DEF', init_pulse_params=None,; pulse_scaling=1.0, pulse_offset=0.0,; ramping_pulse_type=None, ramping_pulse_params=None,; log_level=logging.NOTSET, out_file_ext=None, gen_stats=False):; """"""; Optimise a control pulse to minimise the fidelity error.; The dynamics of the system in any given timeslot are governed; by the combined dynamics generator,; i.e. the sum of the drift+ctrl_amp[j]*ctrls[j]; The control pulse is an [n_ts, n_ctrls)] array of piecewise amplitudes; Starting from an intital (typically random) pulse,; a multivariable optimisation algorithm attempts to determines the; optimal values for the control pulse to minimise the fidelity error; The fidelity error is some measure of distance of the system evolution; from the given target evolution in the time allowed for the evolution. Parameters; ----------; drift : Qobj or list of Qobj; the underlying dynamics generator of the system; can provide list (of length num_tslots) for time dependent drift. ctrls : List of Qobj or array like [num_tslots, evo_time]; a list of control dynamics generators. These are scaled by; the amplitudes to alter the overall dynamics; Array like imput can be provided for time dependent control generators. initial : Qobj; starting point for the evolution.; Typically the identity matrix. target : Qobj; target transformation, e.g. gate or state, for the time evolution. num_tslots : integer or None; number of timeslots.; None implies that timeslots will be given in the tau array. evo_time : float or None; total time for the evolution; None implies that timeslots will be gi",MatchSource.WIKI,docs/4.2/modules/qutip/control/pulseoptim.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/control/pulseoptim.html
https://qutip.org/docs/4.2/modules/qutip/control/pulseoptim.html:8249,Availability,error,error,8249,"ntrol generators. initial : Qobj; starting point for the evolution.; Typically the identity matrix. target : Qobj; target transformation, e.g. gate or state, for the time evolution. num_tslots : integer or None; number of timeslots.; None implies that timeslots will be given in the tau array. evo_time : float or None; total time for the evolution; None implies that timeslots will be given in the tau array. tau : array[num_tslots] of floats or None; durations for the timeslots.; if this is given then num_tslots and evo_time are dervived; from it; None implies that timeslot durations will be equal and; calculated as evo_time/num_tslots. amp_lbound : float or list of floats; lower boundaries for the control amplitudes; Can be a scalar value applied to all controls; or a list of bounds for each control. amp_ubound : float or list of floats; upper boundaries for the control amplitudes; Can be a scalar value applied to all controls; or a list of bounds for each control. fid_err_targ : float; Fidelity error target. Pulse optimisation will; terminate when the fidelity error falls below this value. mim_grad : float; Minimum gradient. When the sum of the squares of the; gradients wrt to the control amplitudes falls below this; value, the optimisation terminates, assuming local minima. max_iter : integer; Maximum number of iterations of the optimisation algorithm. max_wall_time : float; Maximum allowed elapsed time for the optimisation algorithm. alg : string; Algorithm to use in pulse optimisation.; Options are:; ; 'GRAPE' (default) - GRadient Ascent Pulse Engineering; 'CRAB' - Chopped RAndom Basis. alg_params : Dictionary; options that are specific to the algorithm see above; ; optim_params : Dictionary; The key value pairs are the attribute name and value; used to set attribute values; Note: attributes are created if they do not exist already,; and are overwritten if they do.; Note: method_params are applied afterwards and so may override these; ; optim_method : string; a sc",MatchSource.WIKI,docs/4.2/modules/qutip/control/pulseoptim.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/control/pulseoptim.html
https://qutip.org/docs/4.2/modules/qutip/control/pulseoptim.html:8316,Availability,error,error,8316,"on.; Typically the identity matrix. target : Qobj; target transformation, e.g. gate or state, for the time evolution. num_tslots : integer or None; number of timeslots.; None implies that timeslots will be given in the tau array. evo_time : float or None; total time for the evolution; None implies that timeslots will be given in the tau array. tau : array[num_tslots] of floats or None; durations for the timeslots.; if this is given then num_tslots and evo_time are dervived; from it; None implies that timeslot durations will be equal and; calculated as evo_time/num_tslots. amp_lbound : float or list of floats; lower boundaries for the control amplitudes; Can be a scalar value applied to all controls; or a list of bounds for each control. amp_ubound : float or list of floats; upper boundaries for the control amplitudes; Can be a scalar value applied to all controls; or a list of bounds for each control. fid_err_targ : float; Fidelity error target. Pulse optimisation will; terminate when the fidelity error falls below this value. mim_grad : float; Minimum gradient. When the sum of the squares of the; gradients wrt to the control amplitudes falls below this; value, the optimisation terminates, assuming local minima. max_iter : integer; Maximum number of iterations of the optimisation algorithm. max_wall_time : float; Maximum allowed elapsed time for the optimisation algorithm. alg : string; Algorithm to use in pulse optimisation.; Options are:; ; 'GRAPE' (default) - GRadient Ascent Pulse Engineering; 'CRAB' - Chopped RAndom Basis. alg_params : Dictionary; options that are specific to the algorithm see above; ; optim_params : Dictionary; The key value pairs are the attribute name and value; used to set attribute values; Note: attributes are created if they do not exist already,; and are overwritten if they do.; Note: method_params are applied afterwards and so may override these; ; optim_method : string; a scipy.optimize.minimize method that will be used to optimise; the ",MatchSource.WIKI,docs/4.2/modules/qutip/control/pulseoptim.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/control/pulseoptim.html
https://qutip.org/docs/4.2/modules/qutip/control/pulseoptim.html:9331,Availability,error,error,9331,"lue. mim_grad : float; Minimum gradient. When the sum of the squares of the; gradients wrt to the control amplitudes falls below this; value, the optimisation terminates, assuming local minima. max_iter : integer; Maximum number of iterations of the optimisation algorithm. max_wall_time : float; Maximum allowed elapsed time for the optimisation algorithm. alg : string; Algorithm to use in pulse optimisation.; Options are:; ; 'GRAPE' (default) - GRadient Ascent Pulse Engineering; 'CRAB' - Chopped RAndom Basis. alg_params : Dictionary; options that are specific to the algorithm see above; ; optim_params : Dictionary; The key value pairs are the attribute name and value; used to set attribute values; Note: attributes are created if they do not exist already,; and are overwritten if they do.; Note: method_params are applied afterwards and so may override these; ; optim_method : string; a scipy.optimize.minimize method that will be used to optimise; the pulse for minimum fidelity error; Note that FMIN, FMIN_BFGS & FMIN_L_BFGS_B will all result; in calling these specific scipy.optimize methods; Note the LBFGSB is equivalent to FMIN_L_BFGS_B for backwards ; capatibility reasons.; Supplying DEF will given alg dependent result:; GRAPE - Default optim_method is FMIN_L_BFGS_B; CRAB - Default optim_method is FMIN; ; method_params : dict; Parameters for the optim_method. ; Note that where there is an attribute of the; Optimizer object or the termination_conditions matching the key ; that attribute. Otherwise, and in some case also, ; they are assumed to be method_options; for the scipy.optimize.minimize method. ; ; optim_alg : string; Deprecated. Use optim_method. max_metric_corr : integer; Deprecated. Use method_params instead. accuracy_factor : float; Deprecated. Use method_params instead. dyn_type : string; Dynamics type, i.e. the type of matrix used to describe; the dynamics. Options are UNIT, GEN_MAT, SYMPL; (see Dynamics classes for details); ; dyn_params : dict; Parameter",MatchSource.WIKI,docs/4.2/modules/qutip/control/pulseoptim.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/control/pulseoptim.html
https://qutip.org/docs/4.2/modules/qutip/control/pulseoptim.html:10955,Availability,error,error,10955,"minimize method. ; ; optim_alg : string; Deprecated. Use optim_method. max_metric_corr : integer; Deprecated. Use method_params instead. accuracy_factor : float; Deprecated. Use method_params instead. dyn_type : string; Dynamics type, i.e. the type of matrix used to describe; the dynamics. Options are UNIT, GEN_MAT, SYMPL; (see Dynamics classes for details); ; dyn_params : dict; Parameters for the Dynamics object; The key value pairs are assumed to be attribute name value pairs; They applied after the object is created. prop_type : string; Propagator type i.e. the method used to calculate the; propagtors and propagtor gradient for each timeslot; options are DEF, APPROX, DIAG, FRECHET, AUG_MAT; DEF will use the default for the specific dyn_type; (see PropagatorComputer classes for details). prop_params : dict; Parameters for the PropagatorComputer object; The key value pairs are assumed to be attribute name value pairs; They applied after the object is created; ; fid_type : string; Fidelity error (and fidelity error gradient) computation method; Options are DEF, UNIT, TRACEDIFF, TD_APPROX; DEF will use the default for the specific dyn_type; (See FidelityComputer classes for details). fid_params : dict; Parameters for the FidelityComputer object; The key value pairs are assumed to be attribute name value pairs; They applied after the object is created; ; phase_option : string; Deprecated. Pass in fid_params instead. fid_err_scale_factor : float; Deprecated. Use scale_factor key in fid_params instead. tslot_type : string; Method for computing the dynamics generators, propagators and ; evolution in the timeslots.; Options: DEF, UPDATE_ALL, DYNAMIC; UPDATE_ALL is the only one that currently works; (See TimeslotComputer classes for details); ; tslot_params : dict; Parameters for the TimeslotComputer object; The key value pairs are assumed to be attribute name value pairs; They applied after the object is created; ; amp_update_mode : string; Deprecated. Use tslot_type inste",MatchSource.WIKI,docs/4.2/modules/qutip/control/pulseoptim.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/control/pulseoptim.html
https://qutip.org/docs/4.2/modules/qutip/control/pulseoptim.html:10975,Availability,error,error,10975,"minimize method. ; ; optim_alg : string; Deprecated. Use optim_method. max_metric_corr : integer; Deprecated. Use method_params instead. accuracy_factor : float; Deprecated. Use method_params instead. dyn_type : string; Dynamics type, i.e. the type of matrix used to describe; the dynamics. Options are UNIT, GEN_MAT, SYMPL; (see Dynamics classes for details); ; dyn_params : dict; Parameters for the Dynamics object; The key value pairs are assumed to be attribute name value pairs; They applied after the object is created. prop_type : string; Propagator type i.e. the method used to calculate the; propagtors and propagtor gradient for each timeslot; options are DEF, APPROX, DIAG, FRECHET, AUG_MAT; DEF will use the default for the specific dyn_type; (see PropagatorComputer classes for details). prop_params : dict; Parameters for the PropagatorComputer object; The key value pairs are assumed to be attribute name value pairs; They applied after the object is created; ; fid_type : string; Fidelity error (and fidelity error gradient) computation method; Options are DEF, UNIT, TRACEDIFF, TD_APPROX; DEF will use the default for the specific dyn_type; (See FidelityComputer classes for details). fid_params : dict; Parameters for the FidelityComputer object; The key value pairs are assumed to be attribute name value pairs; They applied after the object is created; ; phase_option : string; Deprecated. Pass in fid_params instead. fid_err_scale_factor : float; Deprecated. Use scale_factor key in fid_params instead. tslot_type : string; Method for computing the dynamics generators, propagators and ; evolution in the timeslots.; Options: DEF, UPDATE_ALL, DYNAMIC; UPDATE_ALL is the only one that currently works; (See TimeslotComputer classes for details); ; tslot_params : dict; Parameters for the TimeslotComputer object; The key value pairs are assumed to be attribute name value pairs; They applied after the object is created; ; amp_update_mode : string; Deprecated. Use tslot_type inste",MatchSource.WIKI,docs/4.2/modules/qutip/control/pulseoptim.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/control/pulseoptim.html
https://qutip.org/docs/4.2/modules/qutip/control/pulseoptim.html:14171,Availability,error,error,14171,"name value pairs; They applied after the object is created. log_level : integer; level of messaging output from the logger.; Options are attributes of qutip.logging_utils,; in decreasing levels of messaging, are:; DEBUG_INTENSE, DEBUG_VERBOSE, DEBUG, INFO, WARN, ERROR, CRITICAL; Anything WARN or above is effectively 'quiet' execution,; assuming everything runs as expected.; The default NOTSET implies that the level will be taken from; the QuTiP settings file, which by default is WARN. out_file_ext : string or None; files containing the initial and final control pulse; amplitudes are saved to the current directory.; The default name will be postfixed with this extension; Setting this to None will suppress the output of files. gen_stats : boolean; if set to True then statistics for the optimisation; run will be generated - accessible through attributes; of the stats object. Returns; -------; opt : OptimResult ; Returns instance of OptimResult, which has attributes giving the; reason for termination, final fidelity error, final evolution; final amplitudes, statistics etc; ; """"""; if log_level == logging.NOTSET:; log_level = logger.getEffectiveLevel(); else:; logger.setLevel(log_level); ; # The parameters types are checked in create_pulse_optimizer; # so no need to do so here; # However, the deprecation management is repeated here; # so that the stack level is correct; if not optim_alg is None:; optim_method = optim_alg; _param_deprecation(; ""The 'optim_alg' parameter is deprecated. ""; ""Use 'optim_method' instead""); ; if not max_metric_corr is None:; if isinstance(method_params, dict):; if not 'max_metric_corr' in method_params:; method_params['max_metric_corr'] = max_metric_corr; else:; method_params = {'max_metric_corr':max_metric_corr}; _param_deprecation(; ""The 'max_metric_corr' parameter is deprecated. ""; ""Use 'max_metric_corr' in method_params instead""); ; if not accuracy_factor is None:; if isinstance(method_params, dict):; if not 'accuracy_factor' in method_params",MatchSource.WIKI,docs/4.2/modules/qutip/control/pulseoptim.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/control/pulseoptim.html
https://qutip.org/docs/4.2/modules/qutip/control/pulseoptim.html:19520,Availability,error,error,19520,"not None:; # Save final amplitudes to a text file; pulsefile = ""ctrl_amps_final_"" + out_file_ext; dyn.save_amps(pulsefile); if log_level <= logging.INFO:; logger.info(""Final amplitudes output to file: "" + pulsefile). return result. [docs]def optimize_pulse_unitary(; H_d, H_c, U_0, U_targ,; num_tslots=None, evo_time=None, tau=None,; amp_lbound=None, amp_ubound=None,; fid_err_targ=1e-10, min_grad=1e-10,; max_iter=500, max_wall_time=180,; alg='GRAPE', alg_params=None,; optim_params=None, optim_method='DEF', method_params=None,; optim_alg=None, max_metric_corr=None, accuracy_factor=None,; phase_option='PSU', ; dyn_params=None, prop_params=None, fid_params=None,; tslot_type='DEF', tslot_params=None,; amp_update_mode=None,; init_pulse_type='DEF', init_pulse_params=None,; pulse_scaling=1.0, pulse_offset=0.0,; ramping_pulse_type=None, ramping_pulse_params=None,; log_level=logging.NOTSET, out_file_ext=None, gen_stats=False):. """"""; Optimise a control pulse to minimise the fidelity error, assuming that; the dynamics of the system are generated by unitary operators.; This function is simply a wrapper for optimize_pulse, where the; appropriate options for unitary dynamics are chosen and the parameter; names are in the format familiar to unitary dynamics; The dynamics of the system in any given timeslot are governed; by the combined Hamiltonian,; i.e. the sum of the H_d + ctrl_amp[j]*H_c[j]; The control pulse is an [n_ts, n_ctrls] array of piecewise amplitudes; Starting from an intital (typically random) pulse,; a multivariable optimisation algorithm attempts to determines the; optimal values for the control pulse to minimise the fidelity error; The maximum fidelity for a unitary system is 1, i.e. when the; time evolution resulting from the pulse is equivalent to the target.; And therefore the fidelity error is 1 - fidelity. Parameters; ----------; H_d : Qobj or list of Qobj; Drift (aka system) the underlying Hamiltonian of the system; can provide list (of length num_tslots) for ",MatchSource.WIKI,docs/4.2/modules/qutip/control/pulseoptim.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/control/pulseoptim.html
https://qutip.org/docs/4.2/modules/qutip/control/pulseoptim.html:20187,Availability,error,error,20187,"im_alg=None, max_metric_corr=None, accuracy_factor=None,; phase_option='PSU', ; dyn_params=None, prop_params=None, fid_params=None,; tslot_type='DEF', tslot_params=None,; amp_update_mode=None,; init_pulse_type='DEF', init_pulse_params=None,; pulse_scaling=1.0, pulse_offset=0.0,; ramping_pulse_type=None, ramping_pulse_params=None,; log_level=logging.NOTSET, out_file_ext=None, gen_stats=False):. """"""; Optimise a control pulse to minimise the fidelity error, assuming that; the dynamics of the system are generated by unitary operators.; This function is simply a wrapper for optimize_pulse, where the; appropriate options for unitary dynamics are chosen and the parameter; names are in the format familiar to unitary dynamics; The dynamics of the system in any given timeslot are governed; by the combined Hamiltonian,; i.e. the sum of the H_d + ctrl_amp[j]*H_c[j]; The control pulse is an [n_ts, n_ctrls] array of piecewise amplitudes; Starting from an intital (typically random) pulse,; a multivariable optimisation algorithm attempts to determines the; optimal values for the control pulse to minimise the fidelity error; The maximum fidelity for a unitary system is 1, i.e. when the; time evolution resulting from the pulse is equivalent to the target.; And therefore the fidelity error is 1 - fidelity. Parameters; ----------; H_d : Qobj or list of Qobj; Drift (aka system) the underlying Hamiltonian of the system; can provide list (of length num_tslots) for time dependent drift; ; H_c : List of Qobj or array like [num_tslots, evo_time]; a list of control Hamiltonians. These are scaled by; the amplitudes to alter the overall dynamics; Array like imput can be provided for time dependent control generators. U_0 : Qobj; starting point for the evolution.; Typically the identity matrix. U_targ : Qobj; target transformation, e.g. gate or state, for the time evolution. num_tslots : integer or None; number of timeslots.; None implies that timeslots will be given in the tau array. evo_time : ",MatchSource.WIKI,docs/4.2/modules/qutip/control/pulseoptim.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/control/pulseoptim.html
https://qutip.org/docs/4.2/modules/qutip/control/pulseoptim.html:20354,Availability,error,error,20354,"mping_pulse_type=None, ramping_pulse_params=None,; log_level=logging.NOTSET, out_file_ext=None, gen_stats=False):. """"""; Optimise a control pulse to minimise the fidelity error, assuming that; the dynamics of the system are generated by unitary operators.; This function is simply a wrapper for optimize_pulse, where the; appropriate options for unitary dynamics are chosen and the parameter; names are in the format familiar to unitary dynamics; The dynamics of the system in any given timeslot are governed; by the combined Hamiltonian,; i.e. the sum of the H_d + ctrl_amp[j]*H_c[j]; The control pulse is an [n_ts, n_ctrls] array of piecewise amplitudes; Starting from an intital (typically random) pulse,; a multivariable optimisation algorithm attempts to determines the; optimal values for the control pulse to minimise the fidelity error; The maximum fidelity for a unitary system is 1, i.e. when the; time evolution resulting from the pulse is equivalent to the target.; And therefore the fidelity error is 1 - fidelity. Parameters; ----------; H_d : Qobj or list of Qobj; Drift (aka system) the underlying Hamiltonian of the system; can provide list (of length num_tslots) for time dependent drift; ; H_c : List of Qobj or array like [num_tslots, evo_time]; a list of control Hamiltonians. These are scaled by; the amplitudes to alter the overall dynamics; Array like imput can be provided for time dependent control generators. U_0 : Qobj; starting point for the evolution.; Typically the identity matrix. U_targ : Qobj; target transformation, e.g. gate or state, for the time evolution. num_tslots : integer or None; number of timeslots.; None implies that timeslots will be given in the tau array. evo_time : float or None; total time for the evolution; None implies that timeslots will be given in the tau array. tau : array[num_tslots] of floats or None; durations for the timeslots.; if this is given then num_tslots and evo_time are dervived; from it; None implies that timeslot duration",MatchSource.WIKI,docs/4.2/modules/qutip/control/pulseoptim.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/control/pulseoptim.html
https://qutip.org/docs/4.2/modules/qutip/control/pulseoptim.html:21774,Availability,error,error,21774,"t control generators. U_0 : Qobj; starting point for the evolution.; Typically the identity matrix. U_targ : Qobj; target transformation, e.g. gate or state, for the time evolution. num_tslots : integer or None; number of timeslots.; None implies that timeslots will be given in the tau array. evo_time : float or None; total time for the evolution; None implies that timeslots will be given in the tau array. tau : array[num_tslots] of floats or None; durations for the timeslots.; if this is given then num_tslots and evo_time are dervived; from it; None implies that timeslot durations will be equal and; calculated as evo_time/num_tslots. amp_lbound : float or list of floats; lower boundaries for the control amplitudes; Can be a scalar value applied to all controls; or a list of bounds for each control. amp_ubound : float or list of floats; upper boundaries for the control amplitudes; Can be a scalar value applied to all controls; or a list of bounds for each control. fid_err_targ : float; Fidelity error target. Pulse optimisation will; terminate when the fidelity error falls below this value. mim_grad : float; Minimum gradient. When the sum of the squares of the; gradients wrt to the control amplitudes falls below this; value, the optimisation terminates, assuming local minima. max_iter : integer; Maximum number of iterations of the optimisation algorithm. max_wall_time : float; Maximum allowed elapsed time for the optimisation algorithm. alg : string; Algorithm to use in pulse optimisation.; Options are:; 'GRAPE' (default) - GRadient Ascent Pulse Engineering; 'CRAB' - Chopped RAndom Basis. alg_params : Dictionary; options that are specific to the algorithm see above; ; optim_params : Dictionary; The key value pairs are the attribute name and value; used to set attribute values; Note: attributes are created if they do not exist already,; and are overwritten if they do.; Note: method_params are applied afterwards and so may override these; ; optim_method : string; a scip",MatchSource.WIKI,docs/4.2/modules/qutip/control/pulseoptim.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/control/pulseoptim.html
https://qutip.org/docs/4.2/modules/qutip/control/pulseoptim.html:21841,Availability,error,error,21841,"on.; Typically the identity matrix. U_targ : Qobj; target transformation, e.g. gate or state, for the time evolution. num_tslots : integer or None; number of timeslots.; None implies that timeslots will be given in the tau array. evo_time : float or None; total time for the evolution; None implies that timeslots will be given in the tau array. tau : array[num_tslots] of floats or None; durations for the timeslots.; if this is given then num_tslots and evo_time are dervived; from it; None implies that timeslot durations will be equal and; calculated as evo_time/num_tslots. amp_lbound : float or list of floats; lower boundaries for the control amplitudes; Can be a scalar value applied to all controls; or a list of bounds for each control. amp_ubound : float or list of floats; upper boundaries for the control amplitudes; Can be a scalar value applied to all controls; or a list of bounds for each control. fid_err_targ : float; Fidelity error target. Pulse optimisation will; terminate when the fidelity error falls below this value. mim_grad : float; Minimum gradient. When the sum of the squares of the; gradients wrt to the control amplitudes falls below this; value, the optimisation terminates, assuming local minima. max_iter : integer; Maximum number of iterations of the optimisation algorithm. max_wall_time : float; Maximum allowed elapsed time for the optimisation algorithm. alg : string; Algorithm to use in pulse optimisation.; Options are:; 'GRAPE' (default) - GRadient Ascent Pulse Engineering; 'CRAB' - Chopped RAndom Basis. alg_params : Dictionary; options that are specific to the algorithm see above; ; optim_params : Dictionary; The key value pairs are the attribute name and value; used to set attribute values; Note: attributes are created if they do not exist already,; and are overwritten if they do.; Note: method_params are applied afterwards and so may override these; ; optim_method : string; a scipy.optimize.minimize method that will be used to optimise; the pu",MatchSource.WIKI,docs/4.2/modules/qutip/control/pulseoptim.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/control/pulseoptim.html
https://qutip.org/docs/4.2/modules/qutip/control/pulseoptim.html:22854,Availability,error,error,22854,"value. mim_grad : float; Minimum gradient. When the sum of the squares of the; gradients wrt to the control amplitudes falls below this; value, the optimisation terminates, assuming local minima. max_iter : integer; Maximum number of iterations of the optimisation algorithm. max_wall_time : float; Maximum allowed elapsed time for the optimisation algorithm. alg : string; Algorithm to use in pulse optimisation.; Options are:; 'GRAPE' (default) - GRadient Ascent Pulse Engineering; 'CRAB' - Chopped RAndom Basis. alg_params : Dictionary; options that are specific to the algorithm see above; ; optim_params : Dictionary; The key value pairs are the attribute name and value; used to set attribute values; Note: attributes are created if they do not exist already,; and are overwritten if they do.; Note: method_params are applied afterwards and so may override these; ; optim_method : string; a scipy.optimize.minimize method that will be used to optimise; the pulse for minimum fidelity error; Note that FMIN, FMIN_BFGS & FMIN_L_BFGS_B will all result; in calling these specific scipy.optimize methods; Note the LBFGSB is equivalent to FMIN_L_BFGS_B for backwards ; capatibility reasons.; Supplying DEF will given alg dependent result:; ; GRAPE - Default optim_method is FMIN_L_BFGS_B; CRAB - Default optim_method is FMIN; ; method_params : dict; Parameters for the optim_method. ; Note that where there is an attribute of the; Optimizer object or the termination_conditions matching the key ; that attribute. Otherwise, and in some case also, ; they are assumed to be method_options; for the scipy.optimize.minimize method. ; ; optim_alg : string; Deprecated. Use optim_method. max_metric_corr : integer; Deprecated. Use method_params instead. accuracy_factor : float; Deprecated. Use method_params instead. phase_option : string; determines how global phase is treated in fidelity; calculations (fid_type='UNIT' only). Options:; ; PSU - global phase ignored; SU - global phase included. dyn_para",MatchSource.WIKI,docs/4.2/modules/qutip/control/pulseoptim.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/control/pulseoptim.html
https://qutip.org/docs/4.2/modules/qutip/control/pulseoptim.html:27066,Availability,error,error,27066,"be attribute name value pairs; They applied after the object is created. log_level : integer; level of messaging output from the logger.; Options are attributes of qutip.logging_utils,; in decreasing levels of messaging, are:; DEBUG_INTENSE, DEBUG_VERBOSE, DEBUG, INFO, WARN, ERROR, CRITICAL; Anything WARN or above is effectively 'quiet' execution,; assuming everything runs as expected.; The default NOTSET implies that the level will be taken from; the QuTiP settings file, which by default is WARN. out_file_ext : string or None; files containing the initial and final control pulse; amplitudes are saved to the current directory.; The default name will be postfixed with this extension; Setting this to None will suppress the output of files. gen_stats : boolean; if set to True then statistics for the optimisation; run will be generated - accessible through attributes; of the stats object. Returns; -------; opt : OptimResult; Returns instance of OptimResult, which has attributes giving the; reason for termination, final fidelity error, final evolution; final amplitudes, statistics etc; ; """""". # parameters are checked in create pulse optimiser; ; # The deprecation management is repeated here; # so that the stack level is correct; if not optim_alg is None:; optim_method = optim_alg; _param_deprecation(; ""The 'optim_alg' parameter is deprecated. ""; ""Use 'optim_method' instead""); ; if not max_metric_corr is None:; if isinstance(method_params, dict):; if not 'max_metric_corr' in method_params:; method_params['max_metric_corr'] = max_metric_corr; else:; method_params = {'max_metric_corr':max_metric_corr}; _param_deprecation(; ""The 'max_metric_corr' parameter is deprecated. ""; ""Use 'max_metric_corr' in method_params instead""); ; if not accuracy_factor is None:; if isinstance(method_params, dict):; if not 'accuracy_factor' in method_params:; method_params['accuracy_factor'] = accuracy_factor; else:; method_params = {'accuracy_factor':accuracy_factor}; _param_deprecation(; ""The 'a",MatchSource.WIKI,docs/4.2/modules/qutip/control/pulseoptim.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/control/pulseoptim.html
https://qutip.org/docs/4.2/modules/qutip/control/pulseoptim.html:30220,Availability,error,error,30220,"nit_pulse_type=init_pulse_type, init_pulse_params=init_pulse_params,; pulse_scaling=pulse_scaling, pulse_offset=pulse_offset,; ramping_pulse_type=ramping_pulse_type, ; ramping_pulse_params=ramping_pulse_params,; log_level=log_level, out_file_ext=out_file_ext,; gen_stats=gen_stats); ; [docs]def opt_pulse_crab(; drift, ctrls, initial, target,; num_tslots=None, evo_time=None, tau=None,; amp_lbound=None, amp_ubound=None,; fid_err_targ=1e-5,; max_iter=500, max_wall_time=180,; alg_params=None,; num_coeffs=None, init_coeff_scaling=1.0, ; optim_params=None, optim_method='fmin', method_params=None,; dyn_type='GEN_MAT', dyn_params=None,; prop_type='DEF', prop_params=None,; fid_type='DEF', fid_params=None,; tslot_type='DEF', tslot_params=None,; guess_pulse_type=None, guess_pulse_params=None,; guess_pulse_scaling=1.0, guess_pulse_offset=0.0,; guess_pulse_action='MODULATE', ; ramping_pulse_type=None, ramping_pulse_params=None,; log_level=logging.NOTSET, out_file_ext=None, gen_stats=False):; """"""; Optimise a control pulse to minimise the fidelity error.; The dynamics of the system in any given timeslot are governed; by the combined dynamics generator,; i.e. the sum of the drift+ctrl_amp[j]*ctrls[j]; The control pulse is an [n_ts, n_ctrls] array of piecewise amplitudes.; The CRAB algorithm uses basis function coefficents as the variables to; optimise. It does NOT use any gradient function.; A multivariable optimisation algorithm attempts to determines the; optimal values for the control pulse to minimise the fidelity error; The fidelity error is some measure of distance of the system evolution; from the given target evolution in the time allowed for the evolution. Parameters; ----------; drift : Qobj or list of Qobj; the underlying dynamics generator of the system; can provide list (of length num_tslots) for time dependent drift. ctrls : List of Qobj or array like [num_tslots, evo_time]; a list of control dynamics generators. These are scaled by; the amplitudes to alter the overall ",MatchSource.WIKI,docs/4.2/modules/qutip/control/pulseoptim.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/control/pulseoptim.html
https://qutip.org/docs/4.2/modules/qutip/control/pulseoptim.html:30699,Availability,error,error,30699," optim_params=None, optim_method='fmin', method_params=None,; dyn_type='GEN_MAT', dyn_params=None,; prop_type='DEF', prop_params=None,; fid_type='DEF', fid_params=None,; tslot_type='DEF', tslot_params=None,; guess_pulse_type=None, guess_pulse_params=None,; guess_pulse_scaling=1.0, guess_pulse_offset=0.0,; guess_pulse_action='MODULATE', ; ramping_pulse_type=None, ramping_pulse_params=None,; log_level=logging.NOTSET, out_file_ext=None, gen_stats=False):; """"""; Optimise a control pulse to minimise the fidelity error.; The dynamics of the system in any given timeslot are governed; by the combined dynamics generator,; i.e. the sum of the drift+ctrl_amp[j]*ctrls[j]; The control pulse is an [n_ts, n_ctrls] array of piecewise amplitudes.; The CRAB algorithm uses basis function coefficents as the variables to; optimise. It does NOT use any gradient function.; A multivariable optimisation algorithm attempts to determines the; optimal values for the control pulse to minimise the fidelity error; The fidelity error is some measure of distance of the system evolution; from the given target evolution in the time allowed for the evolution. Parameters; ----------; drift : Qobj or list of Qobj; the underlying dynamics generator of the system; can provide list (of length num_tslots) for time dependent drift. ctrls : List of Qobj or array like [num_tslots, evo_time]; a list of control dynamics generators. These are scaled by; the amplitudes to alter the overall dynamics; Array like imput can be provided for time dependent control generators. initial : Qobj; starting point for the evolution.; Typically the identity matrix. target : Qobj; target transformation, e.g. gate or state, for the time evolution. num_tslots : integer or None; number of timeslots.; None implies that timeslots will be given in the tau array. evo_time : float or None; total time for the evolution; None implies that timeslots will be given in the tau array. tau : array[num_tslots] of floats or None; durations for the ",MatchSource.WIKI,docs/4.2/modules/qutip/control/pulseoptim.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/control/pulseoptim.html
https://qutip.org/docs/4.2/modules/qutip/control/pulseoptim.html:30719,Availability,error,error,30719," optim_params=None, optim_method='fmin', method_params=None,; dyn_type='GEN_MAT', dyn_params=None,; prop_type='DEF', prop_params=None,; fid_type='DEF', fid_params=None,; tslot_type='DEF', tslot_params=None,; guess_pulse_type=None, guess_pulse_params=None,; guess_pulse_scaling=1.0, guess_pulse_offset=0.0,; guess_pulse_action='MODULATE', ; ramping_pulse_type=None, ramping_pulse_params=None,; log_level=logging.NOTSET, out_file_ext=None, gen_stats=False):; """"""; Optimise a control pulse to minimise the fidelity error.; The dynamics of the system in any given timeslot are governed; by the combined dynamics generator,; i.e. the sum of the drift+ctrl_amp[j]*ctrls[j]; The control pulse is an [n_ts, n_ctrls] array of piecewise amplitudes.; The CRAB algorithm uses basis function coefficents as the variables to; optimise. It does NOT use any gradient function.; A multivariable optimisation algorithm attempts to determines the; optimal values for the control pulse to minimise the fidelity error; The fidelity error is some measure of distance of the system evolution; from the given target evolution in the time allowed for the evolution. Parameters; ----------; drift : Qobj or list of Qobj; the underlying dynamics generator of the system; can provide list (of length num_tslots) for time dependent drift. ctrls : List of Qobj or array like [num_tslots, evo_time]; a list of control dynamics generators. These are scaled by; the amplitudes to alter the overall dynamics; Array like imput can be provided for time dependent control generators. initial : Qobj; starting point for the evolution.; Typically the identity matrix. target : Qobj; target transformation, e.g. gate or state, for the time evolution. num_tslots : integer or None; number of timeslots.; None implies that timeslots will be given in the tau array. evo_time : float or None; total time for the evolution; None implies that timeslots will be given in the tau array. tau : array[num_tslots] of floats or None; durations for the ",MatchSource.WIKI,docs/4.2/modules/qutip/control/pulseoptim.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/control/pulseoptim.html
https://qutip.org/docs/4.2/modules/qutip/control/pulseoptim.html:32247,Availability,error,error,32247,"ntrol generators. initial : Qobj; starting point for the evolution.; Typically the identity matrix. target : Qobj; target transformation, e.g. gate or state, for the time evolution. num_tslots : integer or None; number of timeslots.; None implies that timeslots will be given in the tau array. evo_time : float or None; total time for the evolution; None implies that timeslots will be given in the tau array. tau : array[num_tslots] of floats or None; durations for the timeslots.; if this is given then num_tslots and evo_time are dervived; from it; None implies that timeslot durations will be equal and; calculated as evo_time/num_tslots. amp_lbound : float or list of floats; lower boundaries for the control amplitudes; Can be a scalar value applied to all controls; or a list of bounds for each control. amp_ubound : float or list of floats; upper boundaries for the control amplitudes; Can be a scalar value applied to all controls; or a list of bounds for each control. fid_err_targ : float; Fidelity error target. Pulse optimisation will; terminate when the fidelity error falls below this value. max_iter : integer; Maximum number of iterations of the optimisation algorithm. max_wall_time : float; Maximum allowed elapsed time for the optimisation algorithm. alg_params : Dictionary; options that are specific to the algorithm see above; ; optim_params : Dictionary; The key value pairs are the attribute name and value; used to set attribute values; Note: attributes are created if they do not exist already,; and are overwritten if they do.; Note: method_params are applied afterwards and so may override these. coeff_scaling : float; Linear scale factor for the random basis coefficients; By default these range from -1.0 to 1.0; Note this is overridden by alg_params (if given there); ; num_coeffs : integer; Number of coefficients used for each basis function; Note this is calculated automatically based on the dimension of the; dynamics if not given. It is crucial to the performane",MatchSource.WIKI,docs/4.2/modules/qutip/control/pulseoptim.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/control/pulseoptim.html
https://qutip.org/docs/4.2/modules/qutip/control/pulseoptim.html:32314,Availability,error,error,32314,"on.; Typically the identity matrix. target : Qobj; target transformation, e.g. gate or state, for the time evolution. num_tslots : integer or None; number of timeslots.; None implies that timeslots will be given in the tau array. evo_time : float or None; total time for the evolution; None implies that timeslots will be given in the tau array. tau : array[num_tslots] of floats or None; durations for the timeslots.; if this is given then num_tslots and evo_time are dervived; from it; None implies that timeslot durations will be equal and; calculated as evo_time/num_tslots. amp_lbound : float or list of floats; lower boundaries for the control amplitudes; Can be a scalar value applied to all controls; or a list of bounds for each control. amp_ubound : float or list of floats; upper boundaries for the control amplitudes; Can be a scalar value applied to all controls; or a list of bounds for each control. fid_err_targ : float; Fidelity error target. Pulse optimisation will; terminate when the fidelity error falls below this value. max_iter : integer; Maximum number of iterations of the optimisation algorithm. max_wall_time : float; Maximum allowed elapsed time for the optimisation algorithm. alg_params : Dictionary; options that are specific to the algorithm see above; ; optim_params : Dictionary; The key value pairs are the attribute name and value; used to set attribute values; Note: attributes are created if they do not exist already,; and are overwritten if they do.; Note: method_params are applied afterwards and so may override these. coeff_scaling : float; Linear scale factor for the random basis coefficients; By default these range from -1.0 to 1.0; Note this is overridden by alg_params (if given there); ; num_coeffs : integer; Number of coefficients used for each basis function; Note this is calculated automatically based on the dimension of the; dynamics if not given. It is crucial to the performane of the ; algorithm that it is set as low as possible, while sti",MatchSource.WIKI,docs/4.2/modules/qutip/control/pulseoptim.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/control/pulseoptim.html
https://qutip.org/docs/4.2/modules/qutip/control/pulseoptim.html:34009,Availability,error,error,34009,"his is overridden by alg_params (if given there); ; num_coeffs : integer; Number of coefficients used for each basis function; Note this is calculated automatically based on the dimension of the; dynamics if not given. It is crucial to the performane of the ; algorithm that it is set as low as possible, while still giving; high enough frequencies.; Note this is overridden by alg_params (if given there); ; optim_method : string; Multi-variable optimisation method; The only tested options are 'fmin' and 'Nelder-mead'; In theory any non-gradient method implemented in ; scipy.optimize.mininize could be used. method_params : dict; Parameters for the optim_method. ; Note that where there is an attribute of the; Optimizer object or the termination_conditions matching the key ; that attribute. Otherwise, and in some case also, ; they are assumed to be method_options; for the scipy.optimize.minimize method.; The commonly used parameter are:; xtol - limit on variable change for convergence; ftol - limit on fidelity error change for convergence; ; dyn_type : string; Dynamics type, i.e. the type of matrix used to describe; the dynamics. Options are UNIT, GEN_MAT, SYMPL; (see Dynamics classes for details); ; dyn_params : dict; Parameters for the Dynamics object; The key value pairs are assumed to be attribute name value pairs; They applied after the object is created. prop_type : string; Propagator type i.e. the method used to calculate the; propagtors and propagtor gradient for each timeslot; options are DEF, APPROX, DIAG, FRECHET, AUG_MAT; DEF will use the default for the specific dyn_type; (see PropagatorComputer classes for details). prop_params : dict; Parameters for the PropagatorComputer object; The key value pairs are assumed to be attribute name value pairs; They applied after the object is created; ; fid_type : string; Fidelity error (and fidelity error gradient) computation method; Options are DEF, UNIT, TRACEDIFF, TD_APPROX; DEF will use the default for the specific ",MatchSource.WIKI,docs/4.2/modules/qutip/control/pulseoptim.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/control/pulseoptim.html
https://qutip.org/docs/4.2/modules/qutip/control/pulseoptim.html:34845,Availability,error,error,34845," be method_options; for the scipy.optimize.minimize method.; The commonly used parameter are:; xtol - limit on variable change for convergence; ftol - limit on fidelity error change for convergence; ; dyn_type : string; Dynamics type, i.e. the type of matrix used to describe; the dynamics. Options are UNIT, GEN_MAT, SYMPL; (see Dynamics classes for details); ; dyn_params : dict; Parameters for the Dynamics object; The key value pairs are assumed to be attribute name value pairs; They applied after the object is created. prop_type : string; Propagator type i.e. the method used to calculate the; propagtors and propagtor gradient for each timeslot; options are DEF, APPROX, DIAG, FRECHET, AUG_MAT; DEF will use the default for the specific dyn_type; (see PropagatorComputer classes for details). prop_params : dict; Parameters for the PropagatorComputer object; The key value pairs are assumed to be attribute name value pairs; They applied after the object is created; ; fid_type : string; Fidelity error (and fidelity error gradient) computation method; Options are DEF, UNIT, TRACEDIFF, TD_APPROX; DEF will use the default for the specific dyn_type; (See FidelityComputer classes for details). fid_params : dict; Parameters for the FidelityComputer object; The key value pairs are assumed to be attribute name value pairs; They applied after the object is created; ; tslot_type : string; Method for computing the dynamics generators, propagators and ; evolution in the timeslots.; Options: DEF, UPDATE_ALL, DYNAMIC; UPDATE_ALL is the only one that currently works; (See TimeslotComputer classes for details); ; tslot_params : dict; Parameters for the TimeslotComputer object; The key value pairs are assumed to be attribute name value pairs; They applied after the object is created; ; guess_pulse_type : string; type / shape of pulse(s) used modulate the control amplitudes. ; Options include:; RND, LIN, ZERO, SINE, SQUARE, TRIANGLE, SAW, GAUSSIAN; Default is None; ; guess_pulse_params : di",MatchSource.WIKI,docs/4.2/modules/qutip/control/pulseoptim.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/control/pulseoptim.html
https://qutip.org/docs/4.2/modules/qutip/control/pulseoptim.html:34865,Availability,error,error,34865," be method_options; for the scipy.optimize.minimize method.; The commonly used parameter are:; xtol - limit on variable change for convergence; ftol - limit on fidelity error change for convergence; ; dyn_type : string; Dynamics type, i.e. the type of matrix used to describe; the dynamics. Options are UNIT, GEN_MAT, SYMPL; (see Dynamics classes for details); ; dyn_params : dict; Parameters for the Dynamics object; The key value pairs are assumed to be attribute name value pairs; They applied after the object is created. prop_type : string; Propagator type i.e. the method used to calculate the; propagtors and propagtor gradient for each timeslot; options are DEF, APPROX, DIAG, FRECHET, AUG_MAT; DEF will use the default for the specific dyn_type; (see PropagatorComputer classes for details). prop_params : dict; Parameters for the PropagatorComputer object; The key value pairs are assumed to be attribute name value pairs; They applied after the object is created; ; fid_type : string; Fidelity error (and fidelity error gradient) computation method; Options are DEF, UNIT, TRACEDIFF, TD_APPROX; DEF will use the default for the specific dyn_type; (See FidelityComputer classes for details). fid_params : dict; Parameters for the FidelityComputer object; The key value pairs are assumed to be attribute name value pairs; They applied after the object is created; ; tslot_type : string; Method for computing the dynamics generators, propagators and ; evolution in the timeslots.; Options: DEF, UPDATE_ALL, DYNAMIC; UPDATE_ALL is the only one that currently works; (See TimeslotComputer classes for details); ; tslot_params : dict; Parameters for the TimeslotComputer object; The key value pairs are assumed to be attribute name value pairs; They applied after the object is created; ; guess_pulse_type : string; type / shape of pulse(s) used modulate the control amplitudes. ; Options include:; RND, LIN, ZERO, SINE, SQUARE, TRIANGLE, SAW, GAUSSIAN; Default is None; ; guess_pulse_params : di",MatchSource.WIKI,docs/4.2/modules/qutip/control/pulseoptim.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/control/pulseoptim.html
https://qutip.org/docs/4.2/modules/qutip/control/pulseoptim.html:37908,Availability,error,error,37908,"e attribute name value pairs; They applied after the object is created. log_level : integer; level of messaging output from the logger.; Options are attributes of qutip.logging_utils,; in decreasing levels of messaging, are:; DEBUG_INTENSE, DEBUG_VERBOSE, DEBUG, INFO, WARN, ERROR, CRITICAL; Anything WARN or above is effectively 'quiet' execution,; assuming everything runs as expected.; The default NOTSET implies that the level will be taken from; the QuTiP settings file, which by default is WARN. out_file_ext : string or None; files containing the initial and final control pulse; amplitudes are saved to the current directory.; The default name will be postfixed with this extension; Setting this to None will suppress the output of files. gen_stats : boolean; if set to True then statistics for the optimisation; run will be generated - accessible through attributes; of the stats object. Returns; -------; opt : OptimResult ; Returns instance of OptimResult, which has attributes giving the; reason for termination, final fidelity error, final evolution; final amplitudes, statistics etc; ; """""". # The parameters are checked in create_pulse_optimizer; # so no need to do so here. if log_level == logging.NOTSET:; log_level = logger.getEffectiveLevel(); else:; logger.setLevel(log_level). # build the algorithm options; if not isinstance(alg_params, dict): ; alg_params = {'num_coeffs':num_coeffs, ; 'init_coeff_scaling':init_coeff_scaling}; else:; if (num_coeffs is not None and ; not 'num_coeffs' in alg_params):; alg_params['num_coeffs'] = num_coeffs; if (init_coeff_scaling is not None and ; not 'init_coeff_scaling' in alg_params):; alg_params['init_coeff_scaling'] = init_coeff_scaling; ; # Build the guess pulse options; # Any options passed in the guess_pulse_params take precedence; # over the parameter values.; if guess_pulse_type: ; if not isinstance(guess_pulse_params, dict):; guess_pulse_params = {}; if (guess_pulse_scaling is not None and ; not 'scaling' in guess_pulse_param",MatchSource.WIKI,docs/4.2/modules/qutip/control/pulseoptim.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/control/pulseoptim.html
https://qutip.org/docs/4.2/modules/qutip/control/pulseoptim.html:40713,Availability,error,error,40713,"t_type=tslot_type, tslot_params=tslot_params,; init_pulse_type=guess_pulse_type, ; init_pulse_params=guess_pulse_params,; ramping_pulse_type=ramping_pulse_type, ; ramping_pulse_params=ramping_pulse_params,; log_level=log_level, out_file_ext=out_file_ext, gen_stats=gen_stats); ; [docs]def opt_pulse_crab_unitary(; H_d, H_c, U_0, U_targ,; num_tslots=None, evo_time=None, tau=None,; amp_lbound=None, amp_ubound=None,; fid_err_targ=1e-5,; max_iter=500, max_wall_time=180,; alg_params=None,; num_coeffs=None, init_coeff_scaling=1.0, ; optim_params=None, optim_method='fmin', method_params=None,; phase_option='PSU', ; dyn_params=None, prop_params=None, fid_params=None,; tslot_type='DEF', tslot_params=None,; guess_pulse_type=None, guess_pulse_params=None,; guess_pulse_scaling=1.0, guess_pulse_offset=0.0,; guess_pulse_action='MODULATE', ; ramping_pulse_type=None, ramping_pulse_params=None,; log_level=logging.NOTSET, out_file_ext=None, gen_stats=False):; """"""; Optimise a control pulse to minimise the fidelity error, assuming that; the dynamics of the system are generated by unitary operators.; This function is simply a wrapper for optimize_pulse, where the; appropriate options for unitary dynamics are chosen and the parameter; names are in the format familiar to unitary dynamics; The dynamics of the system in any given timeslot are governed; by the combined Hamiltonian,; i.e. the sum of the H_d + ctrl_amp[j]*H_c[j]; The control pulse is an [n_ts, n_ctrls] array of piecewise amplitudes; ; The CRAB algorithm uses basis function coefficents as the variables to; optimise. It does NOT use any gradient function.; A multivariable optimisation algorithm attempts to determines the; optimal values for the control pulse to minimise the fidelity error; The fidelity error is some measure of distance of the system evolution; from the given target evolution in the time allowed for the evolution. Parameters; ----------. H_d : Qobj or list of Qobj; Drift (aka system) the underlying Hamiltonian of th",MatchSource.WIKI,docs/4.2/modules/qutip/control/pulseoptim.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/control/pulseoptim.html
https://qutip.org/docs/4.2/modules/qutip/control/pulseoptim.html:41452,Availability,error,error,41452,"ss_pulse_scaling=1.0, guess_pulse_offset=0.0,; guess_pulse_action='MODULATE', ; ramping_pulse_type=None, ramping_pulse_params=None,; log_level=logging.NOTSET, out_file_ext=None, gen_stats=False):; """"""; Optimise a control pulse to minimise the fidelity error, assuming that; the dynamics of the system are generated by unitary operators.; This function is simply a wrapper for optimize_pulse, where the; appropriate options for unitary dynamics are chosen and the parameter; names are in the format familiar to unitary dynamics; The dynamics of the system in any given timeslot are governed; by the combined Hamiltonian,; i.e. the sum of the H_d + ctrl_amp[j]*H_c[j]; The control pulse is an [n_ts, n_ctrls] array of piecewise amplitudes; ; The CRAB algorithm uses basis function coefficents as the variables to; optimise. It does NOT use any gradient function.; A multivariable optimisation algorithm attempts to determines the; optimal values for the control pulse to minimise the fidelity error; The fidelity error is some measure of distance of the system evolution; from the given target evolution in the time allowed for the evolution. Parameters; ----------. H_d : Qobj or list of Qobj; Drift (aka system) the underlying Hamiltonian of the system; can provide list (of length num_tslots) for time dependent drift. H_c : List of Qobj or array like [num_tslots, evo_time]; a list of control Hamiltonians. These are scaled by; the amplitudes to alter the overall dynamics; Array like imput can be provided for time dependent control generators. U_0 : Qobj; starting point for the evolution.; Typically the identity matrix. U_targ : Qobj; target transformation, e.g. gate or state, for the time evolution. num_tslots : integer or None; number of timeslots.; None implies that timeslots will be given in the tau array. evo_time : float or None; total time for the evolution; None implies that timeslots will be given in the tau array. tau : array[num_tslots] of floats or None; durations for the tim",MatchSource.WIKI,docs/4.2/modules/qutip/control/pulseoptim.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/control/pulseoptim.html
https://qutip.org/docs/4.2/modules/qutip/control/pulseoptim.html:41472,Availability,error,error,41472,"ss_pulse_scaling=1.0, guess_pulse_offset=0.0,; guess_pulse_action='MODULATE', ; ramping_pulse_type=None, ramping_pulse_params=None,; log_level=logging.NOTSET, out_file_ext=None, gen_stats=False):; """"""; Optimise a control pulse to minimise the fidelity error, assuming that; the dynamics of the system are generated by unitary operators.; This function is simply a wrapper for optimize_pulse, where the; appropriate options for unitary dynamics are chosen and the parameter; names are in the format familiar to unitary dynamics; The dynamics of the system in any given timeslot are governed; by the combined Hamiltonian,; i.e. the sum of the H_d + ctrl_amp[j]*H_c[j]; The control pulse is an [n_ts, n_ctrls] array of piecewise amplitudes; ; The CRAB algorithm uses basis function coefficents as the variables to; optimise. It does NOT use any gradient function.; A multivariable optimisation algorithm attempts to determines the; optimal values for the control pulse to minimise the fidelity error; The fidelity error is some measure of distance of the system evolution; from the given target evolution in the time allowed for the evolution. Parameters; ----------. H_d : Qobj or list of Qobj; Drift (aka system) the underlying Hamiltonian of the system; can provide list (of length num_tslots) for time dependent drift. H_c : List of Qobj or array like [num_tslots, evo_time]; a list of control Hamiltonians. These are scaled by; the amplitudes to alter the overall dynamics; Array like imput can be provided for time dependent control generators. U_0 : Qobj; starting point for the evolution.; Typically the identity matrix. U_targ : Qobj; target transformation, e.g. gate or state, for the time evolution. num_tslots : integer or None; number of timeslots.; None implies that timeslots will be given in the tau array. evo_time : float or None; total time for the evolution; None implies that timeslots will be given in the tau array. tau : array[num_tslots] of floats or None; durations for the tim",MatchSource.WIKI,docs/4.2/modules/qutip/control/pulseoptim.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/control/pulseoptim.html
https://qutip.org/docs/4.2/modules/qutip/control/pulseoptim.html:42997,Availability,error,error,42997,"t control generators. U_0 : Qobj; starting point for the evolution.; Typically the identity matrix. U_targ : Qobj; target transformation, e.g. gate or state, for the time evolution. num_tslots : integer or None; number of timeslots.; None implies that timeslots will be given in the tau array. evo_time : float or None; total time for the evolution; None implies that timeslots will be given in the tau array. tau : array[num_tslots] of floats or None; durations for the timeslots.; if this is given then num_tslots and evo_time are dervived; from it; None implies that timeslot durations will be equal and; calculated as evo_time/num_tslots. amp_lbound : float or list of floats; lower boundaries for the control amplitudes; Can be a scalar value applied to all controls; or a list of bounds for each control. amp_ubound : float or list of floats; upper boundaries for the control amplitudes; Can be a scalar value applied to all controls; or a list of bounds for each control. fid_err_targ : float; Fidelity error target. Pulse optimisation will; terminate when the fidelity error falls below this value. max_iter : integer; Maximum number of iterations of the optimisation algorithm. max_wall_time : float; Maximum allowed elapsed time for the optimisation algorithm. alg_params : Dictionary; options that are specific to the algorithm see above; ; optim_params : Dictionary; The key value pairs are the attribute name and value; used to set attribute values; Note: attributes are created if they do not exist already,; and are overwritten if they do.; Note: method_params are applied afterwards and so may override these. coeff_scaling : float; Linear scale factor for the random basis coefficients; By default these range from -1.0 to 1.0; Note this is overridden by alg_params (if given there); ; num_coeffs : integer; Number of coefficients used for each basis function; Note this is calculated automatically based on the dimension of the; dynamics if not given. It is crucial to the performane",MatchSource.WIKI,docs/4.2/modules/qutip/control/pulseoptim.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/control/pulseoptim.html
https://qutip.org/docs/4.2/modules/qutip/control/pulseoptim.html:43064,Availability,error,error,43064,"on.; Typically the identity matrix. U_targ : Qobj; target transformation, e.g. gate or state, for the time evolution. num_tslots : integer or None; number of timeslots.; None implies that timeslots will be given in the tau array. evo_time : float or None; total time for the evolution; None implies that timeslots will be given in the tau array. tau : array[num_tslots] of floats or None; durations for the timeslots.; if this is given then num_tslots and evo_time are dervived; from it; None implies that timeslot durations will be equal and; calculated as evo_time/num_tslots. amp_lbound : float or list of floats; lower boundaries for the control amplitudes; Can be a scalar value applied to all controls; or a list of bounds for each control. amp_ubound : float or list of floats; upper boundaries for the control amplitudes; Can be a scalar value applied to all controls; or a list of bounds for each control. fid_err_targ : float; Fidelity error target. Pulse optimisation will; terminate when the fidelity error falls below this value. max_iter : integer; Maximum number of iterations of the optimisation algorithm. max_wall_time : float; Maximum allowed elapsed time for the optimisation algorithm. alg_params : Dictionary; options that are specific to the algorithm see above; ; optim_params : Dictionary; The key value pairs are the attribute name and value; used to set attribute values; Note: attributes are created if they do not exist already,; and are overwritten if they do.; Note: method_params are applied afterwards and so may override these. coeff_scaling : float; Linear scale factor for the random basis coefficients; By default these range from -1.0 to 1.0; Note this is overridden by alg_params (if given there); ; num_coeffs : integer; Number of coefficients used for each basis function; Note this is calculated automatically based on the dimension of the; dynamics if not given. It is crucial to the performane of the ; algorithm that it is set as low as possible, while sti",MatchSource.WIKI,docs/4.2/modules/qutip/control/pulseoptim.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/control/pulseoptim.html
https://qutip.org/docs/4.2/modules/qutip/control/pulseoptim.html:44759,Availability,error,error,44759," -1.0 to 1.0; Note this is overridden by alg_params (if given there); ; num_coeffs : integer; Number of coefficients used for each basis function; Note this is calculated automatically based on the dimension of the; dynamics if not given. It is crucial to the performane of the ; algorithm that it is set as low as possible, while still giving; high enough frequencies.; Note this is overridden by alg_params (if given there); ; optim_method : string; Multi-variable optimisation method; The only tested options are 'fmin' and 'Nelder-mead'; In theory any non-gradient method implemented in ; scipy.optimize.mininize could be used. method_params : dict; Parameters for the optim_method. ; Note that where there is an attribute of the; Optimizer object or the termination_conditions matching the key ; that attribute. Otherwise, and in some case also, ; they are assumed to be method_options; for the scipy.optimize.minimize method.; The commonly used parameter are:; xtol - limit on variable change for convergence; ftol - limit on fidelity error change for convergence. phase_option : string; determines how global phase is treated in fidelity; calculations (fid_type='UNIT' only). Options:; PSU - global phase ignored; SU - global phase included. dyn_params : dict; Parameters for the Dynamics object; The key value pairs are assumed to be attribute name value pairs; They applied after the object is created. prop_params : dict; Parameters for the PropagatorComputer object; The key value pairs are assumed to be attribute name value pairs; They applied after the object is created. fid_params : dict; Parameters for the FidelityComputer object; The key value pairs are assumed to be attribute name value pairs; They applied after the object is created; ; tslot_type : string; Method for computing the dynamics generators, propagators and ; evolution in the timeslots.; Options: DEF, UPDATE_ALL, DYNAMIC; UPDATE_ALL is the only one that currently works; (See TimeslotComputer classes for details); ",MatchSource.WIKI,docs/4.2/modules/qutip/control/pulseoptim.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/control/pulseoptim.html
https://qutip.org/docs/4.2/modules/qutip/control/pulseoptim.html:48170,Availability,error,error,48170,"e attribute name value pairs; They applied after the object is created. log_level : integer; level of messaging output from the logger.; Options are attributes of qutip.logging_utils,; in decreasing levels of messaging, are:; DEBUG_INTENSE, DEBUG_VERBOSE, DEBUG, INFO, WARN, ERROR, CRITICAL; Anything WARN or above is effectively 'quiet' execution,; assuming everything runs as expected.; The default NOTSET implies that the level will be taken from; the QuTiP settings file, which by default is WARN. out_file_ext : string or None; files containing the initial and final control pulse; amplitudes are saved to the current directory.; The default name will be postfixed with this extension; Setting this to None will suppress the output of files. gen_stats : boolean; if set to True then statistics for the optimisation; run will be generated - accessible through attributes; of the stats object. Returns; -------; opt : OptimResult ; Returns instance of OptimResult, which has attributes giving the; reason for termination, final fidelity error, final evolution; final amplitudes, statistics etc; ; """""". # The parameters are checked in create_pulse_optimizer; # so no need to do so here. if log_level == logging.NOTSET:; log_level = logger.getEffectiveLevel(); else:; logger.setLevel(log_level). # build the algorithm options; if not isinstance(alg_params, dict): ; alg_params = {'num_coeffs':num_coeffs, ; 'init_coeff_scaling':init_coeff_scaling}; else:; if (num_coeffs is not None and ; not 'num_coeffs' in alg_params):; alg_params['num_coeffs'] = num_coeffs; if (init_coeff_scaling is not None and ; not 'init_coeff_scaling' in alg_params):; alg_params['init_coeff_scaling'] = init_coeff_scaling; ; # Build the guess pulse options; # Any options passed in the guess_pulse_params take precedence; # over the parameter values.; if guess_pulse_type: ; if not isinstance(guess_pulse_params, dict):; guess_pulse_params = {}; if (guess_pulse_scaling is not None and ; not 'scaling' in guess_pulse_param",MatchSource.WIKI,docs/4.2/modules/qutip/control/pulseoptim.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/control/pulseoptim.html
https://qutip.org/docs/4.2/modules/qutip/control/pulseoptim.html:52775,Availability,error,error,52775,"ntrol generators. initial : Qobj; starting point for the evolution.; Typically the identity matrix. target : Qobj; target transformation, e.g. gate or state, for the time evolution. num_tslots : integer or None; number of timeslots.; None implies that timeslots will be given in the tau array. evo_time : float or None; total time for the evolution; None implies that timeslots will be given in the tau array. tau : array[num_tslots] of floats or None; durations for the timeslots.; if this is given then num_tslots and evo_time are dervived; from it; None implies that timeslot durations will be equal and; calculated as evo_time/num_tslots. amp_lbound : float or list of floats; lower boundaries for the control amplitudes; Can be a scalar value applied to all controls; or a list of bounds for each control. amp_ubound : float or list of floats; upper boundaries for the control amplitudes; Can be a scalar value applied to all controls; or a list of bounds for each control. fid_err_targ : float; Fidelity error target. Pulse optimisation will; terminate when the fidelity error falls below this value. mim_grad : float; Minimum gradient. When the sum of the squares of the; gradients wrt to the control amplitudes falls below this; value, the optimisation terminates, assuming local minima. max_iter : integer; Maximum number of iterations of the optimisation algorithm. max_wall_time : float; Maximum allowed elapsed time for the optimisation algorithm; ; alg : string; Algorithm to use in pulse optimisation.; Options are:; 'GRAPE' (default) - GRadient Ascent Pulse Engineering; 'CRAB' - Chopped RAndom Basis. alg_params : Dictionary; options that are specific to the algorithm see above; ; optim_params : Dictionary; The key value pairs are the attribute name and value; used to set attribute values; Note: attributes are created if they do not exist already,; and are overwritten if they do.; Note: method_params are applied afterwards and so may override these; ; optim_method : string; a sc",MatchSource.WIKI,docs/4.2/modules/qutip/control/pulseoptim.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/control/pulseoptim.html
https://qutip.org/docs/4.2/modules/qutip/control/pulseoptim.html:52842,Availability,error,error,52842,"on.; Typically the identity matrix. target : Qobj; target transformation, e.g. gate or state, for the time evolution. num_tslots : integer or None; number of timeslots.; None implies that timeslots will be given in the tau array. evo_time : float or None; total time for the evolution; None implies that timeslots will be given in the tau array. tau : array[num_tslots] of floats or None; durations for the timeslots.; if this is given then num_tslots and evo_time are dervived; from it; None implies that timeslot durations will be equal and; calculated as evo_time/num_tslots. amp_lbound : float or list of floats; lower boundaries for the control amplitudes; Can be a scalar value applied to all controls; or a list of bounds for each control. amp_ubound : float or list of floats; upper boundaries for the control amplitudes; Can be a scalar value applied to all controls; or a list of bounds for each control. fid_err_targ : float; Fidelity error target. Pulse optimisation will; terminate when the fidelity error falls below this value. mim_grad : float; Minimum gradient. When the sum of the squares of the; gradients wrt to the control amplitudes falls below this; value, the optimisation terminates, assuming local minima. max_iter : integer; Maximum number of iterations of the optimisation algorithm. max_wall_time : float; Maximum allowed elapsed time for the optimisation algorithm; ; alg : string; Algorithm to use in pulse optimisation.; Options are:; 'GRAPE' (default) - GRadient Ascent Pulse Engineering; 'CRAB' - Chopped RAndom Basis. alg_params : Dictionary; options that are specific to the algorithm see above; ; optim_params : Dictionary; The key value pairs are the attribute name and value; used to set attribute values; Note: attributes are created if they do not exist already,; and are overwritten if they do.; Note: method_params are applied afterwards and so may override these; ; optim_method : string; a scipy.optimize.minimize method that will be used to optimise; the ",MatchSource.WIKI,docs/4.2/modules/qutip/control/pulseoptim.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/control/pulseoptim.html
https://qutip.org/docs/4.2/modules/qutip/control/pulseoptim.html:53857,Availability,error,error,53857,"lue. mim_grad : float; Minimum gradient. When the sum of the squares of the; gradients wrt to the control amplitudes falls below this; value, the optimisation terminates, assuming local minima. max_iter : integer; Maximum number of iterations of the optimisation algorithm. max_wall_time : float; Maximum allowed elapsed time for the optimisation algorithm; ; alg : string; Algorithm to use in pulse optimisation.; Options are:; 'GRAPE' (default) - GRadient Ascent Pulse Engineering; 'CRAB' - Chopped RAndom Basis. alg_params : Dictionary; options that are specific to the algorithm see above; ; optim_params : Dictionary; The key value pairs are the attribute name and value; used to set attribute values; Note: attributes are created if they do not exist already,; and are overwritten if they do.; Note: method_params are applied afterwards and so may override these; ; optim_method : string; a scipy.optimize.minimize method that will be used to optimise; the pulse for minimum fidelity error; Note that FMIN, FMIN_BFGS & FMIN_L_BFGS_B will all result; in calling these specific scipy.optimize methods; Note the LBFGSB is equivalent to FMIN_L_BFGS_B for backwards ; capatibility reasons.; Supplying DEF will given alg dependent result:; - GRAPE - Default optim_method is FMIN_L_BFGS_B; - CRAB - Default optim_method is Nelder-Mead; ; method_params : dict; Parameters for the optim_method. ; Note that where there is an attribute of the; Optimizer object or the termination_conditions matching the key ; that attribute. Otherwise, and in some case also, ; they are assumed to be method_options; for the scipy.optimize.minimize method. ; ; optim_alg : string; Deprecated. Use optim_method. max_metric_corr : integer; Deprecated. Use method_params instead. accuracy_factor : float; Deprecated. Use method_params instead. dyn_type : string; Dynamics type, i.e. the type of matrix used to describe; the dynamics. Options are UNIT, GEN_MAT, SYMPL; (see Dynamics classes for details); ; dyn_params : dict",MatchSource.WIKI,docs/4.2/modules/qutip/control/pulseoptim.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/control/pulseoptim.html
https://qutip.org/docs/4.2/modules/qutip/control/pulseoptim.html:55492,Availability,error,error,55492,"minimize method. ; ; optim_alg : string; Deprecated. Use optim_method. max_metric_corr : integer; Deprecated. Use method_params instead. accuracy_factor : float; Deprecated. Use method_params instead. dyn_type : string; Dynamics type, i.e. the type of matrix used to describe; the dynamics. Options are UNIT, GEN_MAT, SYMPL; (see Dynamics classes for details); ; dyn_params : dict; Parameters for the Dynamics object; The key value pairs are assumed to be attribute name value pairs; They applied after the object is created. prop_type : string; Propagator type i.e. the method used to calculate the; propagtors and propagtor gradient for each timeslot; options are DEF, APPROX, DIAG, FRECHET, AUG_MAT; DEF will use the default for the specific dyn_type; (see PropagatorComputer classes for details). prop_params : dict; Parameters for the PropagatorComputer object; The key value pairs are assumed to be attribute name value pairs; They applied after the object is created; ; fid_type : string; Fidelity error (and fidelity error gradient) computation method; Options are DEF, UNIT, TRACEDIFF, TD_APPROX; DEF will use the default for the specific dyn_type; (See FidelityComputer classes for details). fid_params : dict; Parameters for the FidelityComputer object; The key value pairs are assumed to be attribute name value pairs; They applied after the object is created; ; phase_option : string; Deprecated. Pass in fid_params instead. fid_err_scale_factor : float; Deprecated. Use scale_factor key in fid_params instead. tslot_type : string; Method for computing the dynamics generators, propagators and ; evolution in the timeslots.; Options: DEF, UPDATE_ALL, DYNAMIC; UPDATE_ALL is the only one that currently works; (See TimeslotComputer classes for details); ; tslot_params : dict; Parameters for the TimeslotComputer object; The key value pairs are assumed to be attribute name value pairs; They applied after the object is created; ; amp_update_mode : string; Deprecated. Use tslot_type inste",MatchSource.WIKI,docs/4.2/modules/qutip/control/pulseoptim.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/control/pulseoptim.html
https://qutip.org/docs/4.2/modules/qutip/control/pulseoptim.html:55512,Availability,error,error,55512,"minimize method. ; ; optim_alg : string; Deprecated. Use optim_method. max_metric_corr : integer; Deprecated. Use method_params instead. accuracy_factor : float; Deprecated. Use method_params instead. dyn_type : string; Dynamics type, i.e. the type of matrix used to describe; the dynamics. Options are UNIT, GEN_MAT, SYMPL; (see Dynamics classes for details); ; dyn_params : dict; Parameters for the Dynamics object; The key value pairs are assumed to be attribute name value pairs; They applied after the object is created. prop_type : string; Propagator type i.e. the method used to calculate the; propagtors and propagtor gradient for each timeslot; options are DEF, APPROX, DIAG, FRECHET, AUG_MAT; DEF will use the default for the specific dyn_type; (see PropagatorComputer classes for details). prop_params : dict; Parameters for the PropagatorComputer object; The key value pairs are assumed to be attribute name value pairs; They applied after the object is created; ; fid_type : string; Fidelity error (and fidelity error gradient) computation method; Options are DEF, UNIT, TRACEDIFF, TD_APPROX; DEF will use the default for the specific dyn_type; (See FidelityComputer classes for details). fid_params : dict; Parameters for the FidelityComputer object; The key value pairs are assumed to be attribute name value pairs; They applied after the object is created; ; phase_option : string; Deprecated. Pass in fid_params instead. fid_err_scale_factor : float; Deprecated. Use scale_factor key in fid_params instead. tslot_type : string; Method for computing the dynamics generators, propagators and ; evolution in the timeslots.; Options: DEF, UPDATE_ALL, DYNAMIC; UPDATE_ALL is the only one that currently works; (See TimeslotComputer classes for details); ; tslot_params : dict; Parameters for the TimeslotComputer object; The key value pairs are assumed to be attribute name value pairs; They applied after the object is created; ; amp_update_mode : string; Deprecated. Use tslot_type inste",MatchSource.WIKI,docs/4.2/modules/qutip/control/pulseoptim.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/control/pulseoptim.html
https://qutip.org/docs/4.2/modules/qutip/control/pulseoptim.html:60974,Availability,error,errors,60974,"tion is None:; if isinstance(fid_params, dict):; if not 'phase_option' in fid_params:; fid_params['phase_option'] = phase_option; else:; fid_params = {'phase_option':phase_option}; _param_deprecation(; ""The 'phase_option' parameter is deprecated. ""; ""Use 'phase_option' in fid_params instead""); ; # fid_err_scale_factor; if not fid_err_scale_factor is None:; if isinstance(fid_params, dict):; if not 'fid_err_scale_factor' in fid_params:; fid_params['scale_factor'] = fid_err_scale_factor; else:; fid_params = {'scale_factor':fid_err_scale_factor}; _param_deprecation(; ""The 'fid_err_scale_factor' parameter is deprecated. ""; ""Use 'scale_factor' in fid_params instead""); ; # amp_update_mode; if not amp_update_mode is None:; amp_update_mode_up = _upper_safe(amp_update_mode); if amp_update_mode_up == 'ALL':; tslot_type = 'UPDATE_ALL'; else:; tslot_type = amp_update_mode; _param_deprecation(; ""The 'amp_update_mode' parameter is deprecated. ""; ""Use 'tslot_type' instead""); ; # set algorithm defaults; alg_up = _upper_safe(alg); if alg is None:; raise errors.UsageError(; ""Optimisation algorithm must be specified through 'alg' parameter""); elif alg_up == 'GRAPE':; if optim_method is None or optim_method.upper() == 'DEF':; optim_method = 'FMIN_L_BFGS_B'; if init_pulse_type is None or init_pulse_type.upper() == 'DEF':; init_pulse_type = 'RND'; elif alg_up == 'CRAB':; if optim_method is None or optim_method.upper() == 'DEF':; optim_method = 'FMIN'; if prop_type is None or prop_type.upper() == 'DEF':; prop_type = 'APPROX'; if init_pulse_type is None or init_pulse_type.upper() == 'DEF':; init_pulse_type = None; else:; raise errors.UsageError(; ""No option for pulse optimisation algorithm alg={}"".format(alg)). cfg = optimconfig.OptimConfig(); cfg.optim_method = optim_method; cfg.dyn_type = dyn_type; cfg.prop_type = prop_type; cfg.fid_type = fid_type; cfg.init_pulse_type = init_pulse_type. if log_level == logging.NOTSET:; log_level = logger.getEffectiveLevel(); else:; logger.setLevel(log_le",MatchSource.WIKI,docs/4.2/modules/qutip/control/pulseoptim.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/control/pulseoptim.html
https://qutip.org/docs/4.2/modules/qutip/control/pulseoptim.html:61552,Availability,error,errors,61552,"er is deprecated. ""; ""Use 'scale_factor' in fid_params instead""); ; # amp_update_mode; if not amp_update_mode is None:; amp_update_mode_up = _upper_safe(amp_update_mode); if amp_update_mode_up == 'ALL':; tslot_type = 'UPDATE_ALL'; else:; tslot_type = amp_update_mode; _param_deprecation(; ""The 'amp_update_mode' parameter is deprecated. ""; ""Use 'tslot_type' instead""); ; # set algorithm defaults; alg_up = _upper_safe(alg); if alg is None:; raise errors.UsageError(; ""Optimisation algorithm must be specified through 'alg' parameter""); elif alg_up == 'GRAPE':; if optim_method is None or optim_method.upper() == 'DEF':; optim_method = 'FMIN_L_BFGS_B'; if init_pulse_type is None or init_pulse_type.upper() == 'DEF':; init_pulse_type = 'RND'; elif alg_up == 'CRAB':; if optim_method is None or optim_method.upper() == 'DEF':; optim_method = 'FMIN'; if prop_type is None or prop_type.upper() == 'DEF':; prop_type = 'APPROX'; if init_pulse_type is None or init_pulse_type.upper() == 'DEF':; init_pulse_type = None; else:; raise errors.UsageError(; ""No option for pulse optimisation algorithm alg={}"".format(alg)). cfg = optimconfig.OptimConfig(); cfg.optim_method = optim_method; cfg.dyn_type = dyn_type; cfg.prop_type = prop_type; cfg.fid_type = fid_type; cfg.init_pulse_type = init_pulse_type. if log_level == logging.NOTSET:; log_level = logger.getEffectiveLevel(); else:; logger.setLevel(log_level). cfg.log_level = log_level. # Create the Dynamics instance; if dyn_type == 'GEN_MAT' or dyn_type is None or dyn_type == '':; dyn = dynamics.DynamicsGenMat(cfg); elif dyn_type == 'UNIT':; dyn = dynamics.DynamicsUnitary(cfg); elif dyn_type == 'SYMPL':; dyn = dynamics.DynamicsSymplectic(cfg); else:; raise errors.UsageError(""No option for dyn_type: "" + dyn_type); dyn.apply_params(dyn_params); dyn._drift_dyn_gen_checked = True; dyn._ctrl_dyn_gen_checked = True; ; # Create the PropagatorComputer instance; # The default will be typically be the best option; if prop_type == 'DEF' or prop_type is None o",MatchSource.WIKI,docs/4.2/modules/qutip/control/pulseoptim.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/control/pulseoptim.html
https://qutip.org/docs/4.2/modules/qutip/control/pulseoptim.html:62231,Availability,error,errors,62231,"ulse_type.upper() == 'DEF':; init_pulse_type = 'RND'; elif alg_up == 'CRAB':; if optim_method is None or optim_method.upper() == 'DEF':; optim_method = 'FMIN'; if prop_type is None or prop_type.upper() == 'DEF':; prop_type = 'APPROX'; if init_pulse_type is None or init_pulse_type.upper() == 'DEF':; init_pulse_type = None; else:; raise errors.UsageError(; ""No option for pulse optimisation algorithm alg={}"".format(alg)). cfg = optimconfig.OptimConfig(); cfg.optim_method = optim_method; cfg.dyn_type = dyn_type; cfg.prop_type = prop_type; cfg.fid_type = fid_type; cfg.init_pulse_type = init_pulse_type. if log_level == logging.NOTSET:; log_level = logger.getEffectiveLevel(); else:; logger.setLevel(log_level). cfg.log_level = log_level. # Create the Dynamics instance; if dyn_type == 'GEN_MAT' or dyn_type is None or dyn_type == '':; dyn = dynamics.DynamicsGenMat(cfg); elif dyn_type == 'UNIT':; dyn = dynamics.DynamicsUnitary(cfg); elif dyn_type == 'SYMPL':; dyn = dynamics.DynamicsSymplectic(cfg); else:; raise errors.UsageError(""No option for dyn_type: "" + dyn_type); dyn.apply_params(dyn_params); dyn._drift_dyn_gen_checked = True; dyn._ctrl_dyn_gen_checked = True; ; # Create the PropagatorComputer instance; # The default will be typically be the best option; if prop_type == 'DEF' or prop_type is None or prop_type == '':; # Do nothing use the default for the Dynamics; pass; elif prop_type == 'APPROX':; if not isinstance(dyn.prop_computer, propcomp.PropCompApproxGrad):; dyn.prop_computer = propcomp.PropCompApproxGrad(dyn); elif prop_type == 'DIAG':; if not isinstance(dyn.prop_computer, propcomp.PropCompDiag):; dyn.prop_computer = propcomp.PropCompDiag(dyn); elif prop_type == 'AUG_MAT':; if not isinstance(dyn.prop_computer, propcomp.PropCompAugMat):; dyn.prop_computer = propcomp.PropCompAugMat(dyn); elif prop_type == 'FRECHET':; if not isinstance(dyn.prop_computer, propcomp.PropCompFrechet):; dyn.prop_computer = propcomp.PropCompFrechet(dyn); else:; raise errors.UsageError(""No op",MatchSource.WIKI,docs/4.2/modules/qutip/control/pulseoptim.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/control/pulseoptim.html
https://qutip.org/docs/4.2/modules/qutip/control/pulseoptim.html:63192,Availability,error,errors,63192,"dyn = dynamics.DynamicsSymplectic(cfg); else:; raise errors.UsageError(""No option for dyn_type: "" + dyn_type); dyn.apply_params(dyn_params); dyn._drift_dyn_gen_checked = True; dyn._ctrl_dyn_gen_checked = True; ; # Create the PropagatorComputer instance; # The default will be typically be the best option; if prop_type == 'DEF' or prop_type is None or prop_type == '':; # Do nothing use the default for the Dynamics; pass; elif prop_type == 'APPROX':; if not isinstance(dyn.prop_computer, propcomp.PropCompApproxGrad):; dyn.prop_computer = propcomp.PropCompApproxGrad(dyn); elif prop_type == 'DIAG':; if not isinstance(dyn.prop_computer, propcomp.PropCompDiag):; dyn.prop_computer = propcomp.PropCompDiag(dyn); elif prop_type == 'AUG_MAT':; if not isinstance(dyn.prop_computer, propcomp.PropCompAugMat):; dyn.prop_computer = propcomp.PropCompAugMat(dyn); elif prop_type == 'FRECHET':; if not isinstance(dyn.prop_computer, propcomp.PropCompFrechet):; dyn.prop_computer = propcomp.PropCompFrechet(dyn); else:; raise errors.UsageError(""No option for prop_type: "" + prop_type); dyn.prop_computer.apply_params(prop_params). # Create the FidelityComputer instance; # The default will be typically be the best option; # Note: the FidCompTraceDiffApprox is a subclass of FidCompTraceDiff; # so need to check this type first; fid_type_up = _upper_safe(fid_type); if fid_type_up == 'DEF' or fid_type_up is None or fid_type_up == '':; # None given, use the default for the Dynamics; pass; elif fid_type_up == 'TDAPPROX':; if not isinstance(dyn.fid_computer, fidcomp.FidCompTraceDiffApprox):; dyn.fid_computer = fidcomp.FidCompTraceDiffApprox(dyn); elif fid_type_up == 'TRACEDIFF':; if not isinstance(dyn.fid_computer, fidcomp.FidCompTraceDiff):; dyn.fid_computer = fidcomp.FidCompTraceDiff(dyn); elif fid_type_up == 'UNIT':; if not isinstance(dyn.fid_computer, fidcomp.FidCompUnitary):; dyn.fid_computer = fidcomp.FidCompUnitary(dyn); else:; raise errors.UsageError(""No option for fid_type: "" + fid_type); dyn.f",MatchSource.WIKI,docs/4.2/modules/qutip/control/pulseoptim.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/control/pulseoptim.html
https://qutip.org/docs/4.2/modules/qutip/control/pulseoptim.html:64115,Availability,error,errors,64115,"ropcomp.PropCompFrechet):; dyn.prop_computer = propcomp.PropCompFrechet(dyn); else:; raise errors.UsageError(""No option for prop_type: "" + prop_type); dyn.prop_computer.apply_params(prop_params). # Create the FidelityComputer instance; # The default will be typically be the best option; # Note: the FidCompTraceDiffApprox is a subclass of FidCompTraceDiff; # so need to check this type first; fid_type_up = _upper_safe(fid_type); if fid_type_up == 'DEF' or fid_type_up is None or fid_type_up == '':; # None given, use the default for the Dynamics; pass; elif fid_type_up == 'TDAPPROX':; if not isinstance(dyn.fid_computer, fidcomp.FidCompTraceDiffApprox):; dyn.fid_computer = fidcomp.FidCompTraceDiffApprox(dyn); elif fid_type_up == 'TRACEDIFF':; if not isinstance(dyn.fid_computer, fidcomp.FidCompTraceDiff):; dyn.fid_computer = fidcomp.FidCompTraceDiff(dyn); elif fid_type_up == 'UNIT':; if not isinstance(dyn.fid_computer, fidcomp.FidCompUnitary):; dyn.fid_computer = fidcomp.FidCompUnitary(dyn); else:; raise errors.UsageError(""No option for fid_type: "" + fid_type); dyn.fid_computer.apply_params(fid_params); ; # Currently the only working option for tslot computer is ; # TSlotCompUpdateAll.; # so just apply the parameters; dyn.tslot_computer.apply_params(tslot_params) . # Create the Optimiser instance; optim_method_up = _upper_safe(optim_method); if optim_method is None or optim_method_up == '':; raise errors.UsageError(""Optimisation method must be specified ""; ""via 'optim_method' parameter""); elif optim_method_up == 'FMIN_BFGS':; optim = optimizer.OptimizerBFGS(cfg, dyn); elif optim_method_up == 'LBFGSB' or optim_method_up == 'FMIN_L_BFGS_B':; optim = optimizer.OptimizerLBFGSB(cfg, dyn); elif optim_method_up == 'FMIN':; if alg_up == 'CRAB':; optim = optimizer.OptimizerCrabFmin(cfg, dyn); else:; raise errors.UsageError(; ""Invalid optim_method '{}' for '{}' algorthim"".format(; optim_method, alg)); else:; # Assume that the optim_method is a valid; #scipy.optimize.minimize method;",MatchSource.WIKI,docs/4.2/modules/qutip/control/pulseoptim.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/control/pulseoptim.html
https://qutip.org/docs/4.2/modules/qutip/control/pulseoptim.html:64516,Availability,error,errors,64516,"ceDiff; # so need to check this type first; fid_type_up = _upper_safe(fid_type); if fid_type_up == 'DEF' or fid_type_up is None or fid_type_up == '':; # None given, use the default for the Dynamics; pass; elif fid_type_up == 'TDAPPROX':; if not isinstance(dyn.fid_computer, fidcomp.FidCompTraceDiffApprox):; dyn.fid_computer = fidcomp.FidCompTraceDiffApprox(dyn); elif fid_type_up == 'TRACEDIFF':; if not isinstance(dyn.fid_computer, fidcomp.FidCompTraceDiff):; dyn.fid_computer = fidcomp.FidCompTraceDiff(dyn); elif fid_type_up == 'UNIT':; if not isinstance(dyn.fid_computer, fidcomp.FidCompUnitary):; dyn.fid_computer = fidcomp.FidCompUnitary(dyn); else:; raise errors.UsageError(""No option for fid_type: "" + fid_type); dyn.fid_computer.apply_params(fid_params); ; # Currently the only working option for tslot computer is ; # TSlotCompUpdateAll.; # so just apply the parameters; dyn.tslot_computer.apply_params(tslot_params) . # Create the Optimiser instance; optim_method_up = _upper_safe(optim_method); if optim_method is None or optim_method_up == '':; raise errors.UsageError(""Optimisation method must be specified ""; ""via 'optim_method' parameter""); elif optim_method_up == 'FMIN_BFGS':; optim = optimizer.OptimizerBFGS(cfg, dyn); elif optim_method_up == 'LBFGSB' or optim_method_up == 'FMIN_L_BFGS_B':; optim = optimizer.OptimizerLBFGSB(cfg, dyn); elif optim_method_up == 'FMIN':; if alg_up == 'CRAB':; optim = optimizer.OptimizerCrabFmin(cfg, dyn); else:; raise errors.UsageError(; ""Invalid optim_method '{}' for '{}' algorthim"".format(; optim_method, alg)); else:; # Assume that the optim_method is a valid; #scipy.optimize.minimize method; # Choose an optimiser based on the algorithm; if alg_up == 'CRAB':; optim = optimizer.OptimizerCrab(cfg, dyn); else:; optim = optimizer.Optimizer(cfg, dyn); ; optim.alg = alg; optim.method = optim_method; optim.amp_lbound = amp_lbound; optim.amp_ubound = amp_ubound; optim.apply_params(optim_params); ; # Create the TerminationConditions instance; t",MatchSource.WIKI,docs/4.2/modules/qutip/control/pulseoptim.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/control/pulseoptim.html
https://qutip.org/docs/4.2/modules/qutip/control/pulseoptim.html:64923,Availability,error,errors,64923,"Diff):; dyn.fid_computer = fidcomp.FidCompTraceDiff(dyn); elif fid_type_up == 'UNIT':; if not isinstance(dyn.fid_computer, fidcomp.FidCompUnitary):; dyn.fid_computer = fidcomp.FidCompUnitary(dyn); else:; raise errors.UsageError(""No option for fid_type: "" + fid_type); dyn.fid_computer.apply_params(fid_params); ; # Currently the only working option for tslot computer is ; # TSlotCompUpdateAll.; # so just apply the parameters; dyn.tslot_computer.apply_params(tslot_params) . # Create the Optimiser instance; optim_method_up = _upper_safe(optim_method); if optim_method is None or optim_method_up == '':; raise errors.UsageError(""Optimisation method must be specified ""; ""via 'optim_method' parameter""); elif optim_method_up == 'FMIN_BFGS':; optim = optimizer.OptimizerBFGS(cfg, dyn); elif optim_method_up == 'LBFGSB' or optim_method_up == 'FMIN_L_BFGS_B':; optim = optimizer.OptimizerLBFGSB(cfg, dyn); elif optim_method_up == 'FMIN':; if alg_up == 'CRAB':; optim = optimizer.OptimizerCrabFmin(cfg, dyn); else:; raise errors.UsageError(; ""Invalid optim_method '{}' for '{}' algorthim"".format(; optim_method, alg)); else:; # Assume that the optim_method is a valid; #scipy.optimize.minimize method; # Choose an optimiser based on the algorithm; if alg_up == 'CRAB':; optim = optimizer.OptimizerCrab(cfg, dyn); else:; optim = optimizer.Optimizer(cfg, dyn); ; optim.alg = alg; optim.method = optim_method; optim.amp_lbound = amp_lbound; optim.amp_ubound = amp_ubound; optim.apply_params(optim_params); ; # Create the TerminationConditions instance; tc = termcond.TerminationConditions(); tc.fid_err_targ = fid_err_targ; tc.min_gradient_norm = min_grad; tc.max_iterations = max_iter; tc.max_wall_time = max_wall_time; optim.termination_conditions = tc; ; optim.apply_method_params(method_params). if gen_stats:; # Create a stats object; # Note that stats object is optional; # if the Dynamics and Optimizer stats attribute is not set; # then no stats will be collected, which could improve performance; if",MatchSource.WIKI,docs/4.2/modules/qutip/control/pulseoptim.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/control/pulseoptim.html
https://qutip.org/docs/4.2/modules/qutip/control/pulseoptim.html:66300,Availability,error,errors,66300,"tim = optimizer.Optimizer(cfg, dyn); ; optim.alg = alg; optim.method = optim_method; optim.amp_lbound = amp_lbound; optim.amp_ubound = amp_ubound; optim.apply_params(optim_params); ; # Create the TerminationConditions instance; tc = termcond.TerminationConditions(); tc.fid_err_targ = fid_err_targ; tc.min_gradient_norm = min_grad; tc.max_iterations = max_iter; tc.max_wall_time = max_wall_time; optim.termination_conditions = tc; ; optim.apply_method_params(method_params). if gen_stats:; # Create a stats object; # Note that stats object is optional; # if the Dynamics and Optimizer stats attribute is not set; # then no stats will be collected, which could improve performance; if amp_update_mode == 'DYNAMIC':; sts = stats.StatsDynTsUpdate(); else:; sts = stats.Stats(). dyn.stats = sts; optim.stats = sts. # Configure the dynamics; dyn.drift_dyn_gen = drift; dyn.ctrl_dyn_gen = ctrls; dyn.initial = initial; dyn.target = target; if tau is None:; # Check that parameters have been supplied to generate the; # timeslot durations; try:; evo_time / num_tslots; except:; raise errors.UsageError(; ""Either the timeslot durations should be supplied as an ""; ""array 'tau' or the number of timeslots 'num_tslots' ""; ""and the evolution time 'evo_time' must be given.""). dyn.num_tslots = num_tslots; dyn.evo_time = evo_time; else:; dyn.tau = tau. # this function is called, so that the num_ctrls attribute will be set; n_ctrls = dyn.num_ctrls. ramping_pgen = None; if ramping_pulse_type:; ramping_pgen = pulsegen.create_pulse_gen(; pulse_type=ramping_pulse_type, dyn=dyn, ; pulse_params=ramping_pulse_params); if alg_up == 'CRAB':; # Create a pulse generator for each ctrl; crab_pulse_params = None; num_coeffs = None; init_coeff_scaling = None; if isinstance(alg_params, dict):; num_coeffs = alg_params.get('num_coeffs'); init_coeff_scaling = alg_params.get('init_coeff_scaling'); if 'crab_pulse_params' in alg_params:; crab_pulse_params = alg_params.get('crab_pulse_params'); ; guess_pulse_type = init_pul",MatchSource.WIKI,docs/4.2/modules/qutip/control/pulseoptim.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/control/pulseoptim.html
https://qutip.org/docs/4.2/modules/qutip/control/pulseoptim.html:2344,Deployability,configurat,configuration,2344,"OT; # LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A; # PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT; # HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,; # SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT; # LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,; # DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY; # THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT; # (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE; # OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.; ###############################################################################. # @author: Alexander Pitchford; # @email1: agp1@aber.ac.uk; # @email2: alex.pitchford@gmail.com; # @organization: Aberystwyth University; # @supervisor: Daniel Burgarth. """"""; Wrapper functions that will manage the creation of the objects,; build the configuration, and execute the algorithm required to optimise; a set of ctrl pulses for a given (quantum) system.; The fidelity error is some measure of distance of the system evolution; from the given target evolution in the time allowed for the evolution.; The functions minimise this fidelity error wrt the piecewise control; amplitudes in the timeslots. There are currently two quantum control pulse optmisations algorithms; implemented in this library. There are accessible through the methods; in this module. Both the algorithms use the scipy.optimize methods; to minimise the fidelity error with respect to to variables that define; the pulse. GRAPE; -----; The default algorithm (as it was implemented here first) is GRAPE; GRadient Ascent Pulse Engineering [1][2]. It uses a gradient based method such; as BFGS to minimise the fidelity error. This makes convergence very quick; when an exact gradient can be calculated, but this limits the factors that can; taken into account in the fidelity. CRAB; ----; ",MatchSource.WIKI,docs/4.2/modules/qutip/control/pulseoptim.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/control/pulseoptim.html
https://qutip.org/docs/4.2/modules/qutip/control/pulseoptim.html:17668,Deployability,configurat,configuration,17668,"tim_method=optim_method, method_params=method_params,; dyn_type=dyn_type, dyn_params=dyn_params, ; prop_type=prop_type, prop_params=prop_params,; fid_type=fid_type, fid_params=fid_params,; init_pulse_type=init_pulse_type, init_pulse_params=init_pulse_params,; pulse_scaling=pulse_scaling, pulse_offset=pulse_offset,; ramping_pulse_type=ramping_pulse_type, ; ramping_pulse_params=ramping_pulse_params,; log_level=log_level, gen_stats=gen_stats). dyn = optim.dynamics. dyn.init_timeslots(); # Generate initial pulses for each control; init_amps = np.zeros([dyn.num_tslots, dyn.num_ctrls]); ; if alg == 'CRAB':; for j in range(dyn.num_ctrls):; pgen = optim.pulse_generator[j]; pgen.init_pulse(); init_amps[:, j] = pgen.gen_pulse(); else:; pgen = optim.pulse_generator; for j in range(dyn.num_ctrls):; init_amps[:, j] = pgen.gen_pulse(); ; # Initialise the starting amplitudes; dyn.initialize_controls(init_amps); ; if log_level <= logging.INFO:; msg = ""System configuration:\n""; dg_name = ""dynamics generator""; if dyn_type == 'UNIT':; dg_name = ""Hamiltonian""; if dyn.time_depend_drift:; msg += ""Initial drift {}:\n"".format(dg_name); msg += str(dyn.drift_dyn_gen[0]); else:; msg += ""Drift {}:\n"".format(dg_name); msg += str(dyn.drift_dyn_gen); for j in range(dyn.num_ctrls):; msg += ""\nControl {} {}:\n"".format(j+1, dg_name); msg += str(dyn.ctrl_dyn_gen[j]); msg += ""\nInitial state / operator:\n""; msg += str(dyn.initial); msg += ""\nTarget state / operator:\n""; msg += str(dyn.target); logger.info(msg). if out_file_ext is not None:; # Save initial amplitudes to a text file; pulsefile = ""ctrl_amps_initial_"" + out_file_ext; dyn.save_amps(pulsefile); if log_level <= logging.INFO:; logger.info(""Initial amplitudes output to file: "" + pulsefile). # Start the optimisation; result = optim.run_optimization(). if out_file_ext is not None:; # Save final amplitudes to a text file; pulsefile = ""ctrl_amps_final_"" + out_file_ext; dyn.save_amps(pulsefile); if log_level <= logging.INFO:; logger.info(""Final amp",MatchSource.WIKI,docs/4.2/modules/qutip/control/pulseoptim.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/control/pulseoptim.html
https://qutip.org/docs/4.2/modules/qutip/control/pulseoptim.html:51179,Deployability,configurat,configuration,51179,"_file_ext, gen_stats=gen_stats). [docs]def create_pulse_optimizer(; drift, ctrls, initial, target,; num_tslots=None, evo_time=None, tau=None,; amp_lbound=None, amp_ubound=None,; fid_err_targ=1e-10, min_grad=1e-10,; max_iter=500, max_wall_time=180,; alg='GRAPE', alg_params=None,; optim_params=None, optim_method='DEF', method_params=None,; optim_alg=None, max_metric_corr=None, accuracy_factor=None,; dyn_type='GEN_MAT', dyn_params=None,; prop_type='DEF', prop_params=None,; fid_type='DEF', fid_params=None,; phase_option=None, fid_err_scale_factor=None,; tslot_type='DEF', tslot_params=None,; amp_update_mode=None,; init_pulse_type='DEF', init_pulse_params=None,; pulse_scaling=1.0, pulse_offset=0.0,; ramping_pulse_type=None, ramping_pulse_params=None,; log_level=logging.NOTSET, gen_stats=False):. """"""; Generate the objects of the appropriate subclasses; required for the pulse optmisation based on the parameters given; Note this method may be preferable to calling optimize_pulse; if more detailed configuration is required before running the; optmisation algorthim, or the algorithm will be run many times,; for instances when trying to finding global the optimum or; minimum time optimisation. Parameters; ----------; drift : Qobj or list of Qobj; the underlying dynamics generator of the system; can provide list (of length num_tslots) for time dependent drift. ctrls : List of Qobj or array like [num_tslots, evo_time]; a list of control dynamics generators. These are scaled by; the amplitudes to alter the overall dynamics; Array like imput can be provided for time dependent control generators. initial : Qobj; starting point for the evolution.; Typically the identity matrix. target : Qobj; target transformation, e.g. gate or state, for the time evolution. num_tslots : integer or None; number of timeslots.; None implies that timeslots will be given in the tau array. evo_time : float or None; total time for the evolution; None implies that timeslots will be given in the tau array. t",MatchSource.WIKI,docs/4.2/modules/qutip/control/pulseoptim.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/control/pulseoptim.html
https://qutip.org/docs/4.2/modules/qutip/control/pulseoptim.html:69413,Deployability,update,updated,69413,"_params); guess_pulse_action = init_pulse_params.get('pulse_action'). optim.pulse_generator = []; for j in range(n_ctrls):; crab_pgen = pulsegen.PulseGenCrabFourier(; dyn=dyn, num_coeffs=num_coeffs); if init_coeff_scaling is not None:; crab_pgen.scaling = init_coeff_scaling; if isinstance(crab_pulse_params, dict):; crab_pgen.apply_params(crab_pulse_params); ; lb = None; if amp_lbound:; if isinstance(amp_lbound, list):; try:; lb = amp_lbound[j]; except:; lb = amp_lbound[-1]; else:; lb = amp_lbound; ub = None; if amp_ubound:; if isinstance(amp_ubound, list):; try:; ub = amp_ubound[j]; except:; ub = amp_ubound[-1]; else:; ub = amp_ubound; crab_pgen.lbound = lb; crab_pgen.ubound = ub; ; if guess_pulse_type:; guess_pgen.lbound = lb; guess_pgen.ubound = ub; crab_pgen.guess_pulse = guess_pgen.gen_pulse(); if guess_pulse_action:; crab_pgen.guess_pulse_action = guess_pulse_action; ; if ramping_pgen:; crab_pgen.ramping_pulse = ramping_pgen.gen_pulse(). optim.pulse_generator.append(crab_pgen); #This is just for the debug message now; pgen = optim.pulse_generator[0]; ; else:; # Create a pulse generator of the type specified; pgen = pulsegen.create_pulse_gen(pulse_type=init_pulse_type, dyn=dyn,; pulse_params=init_pulse_params); pgen.scaling = pulse_scaling; pgen.offset = pulse_offset; pgen.lbound = amp_lbound; pgen.ubound = amp_ubound. optim.pulse_generator = pgen. if log_level <= logging.DEBUG:; logger.debug(; ""Optimisation config summary...\n""; "" object classes:\n""; "" optimizer: "" + optim.__class__.__name__ +; ""\n dynamics: "" + dyn.__class__.__name__ +; ""\n tslotcomp: "" + dyn.tslot_computer.__class__.__name__ +; ""\n fidcomp: "" + dyn.fid_computer.__class__.__name__ +; ""\n propcomp: "" + dyn.prop_computer.__class__.__name__ +; ""\n pulsegen: "" + pgen.__class__.__name__). return optim. Â© Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, and A.L. Grimsmo.; Last updated on Jan 17, 2018. . Built with Sphinx using a theme provided by Read the Docs. . ",MatchSource.WIKI,docs/4.2/modules/qutip/control/pulseoptim.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/control/pulseoptim.html
https://qutip.org/docs/4.2/modules/qutip/control/pulseoptim.html:3509,Energy Efficiency,reduce,reduces,3509,"time allowed for the evolution.; The functions minimise this fidelity error wrt the piecewise control; amplitudes in the timeslots. There are currently two quantum control pulse optmisations algorithms; implemented in this library. There are accessible through the methods; in this module. Both the algorithms use the scipy.optimize methods; to minimise the fidelity error with respect to to variables that define; the pulse. GRAPE; -----; The default algorithm (as it was implemented here first) is GRAPE; GRadient Ascent Pulse Engineering [1][2]. It uses a gradient based method such; as BFGS to minimise the fidelity error. This makes convergence very quick; when an exact gradient can be calculated, but this limits the factors that can; taken into account in the fidelity. CRAB; ----; The CRAB [3][4] algorithm was developed at the University of Ulm.; In full it is the Chopped RAndom Basis algorithm.; The main difference is that it reduces the number of optimisation variables ; by defining the control pulses by expansions of basis functions, ; where the variables are the coefficients. Typically a Fourier series is chosen, ; i.e. the variables are the Fourier coefficients. ; Therefore it does not need to compute an explicit gradient. ; By default it uses the Nelder-Mead method for fidelity error minimisation. . References; ----------; 1. N Khaneja et. al. ; Optimal control of coupled spin dynamics: Design of NMR pulse sequences ; by gradient ascent algorithms. J. Magn. Reson. 172, 296â305 (2005).; 2. Shai Machnes et.al; DYNAMO - Dynamic Framework for Quantum Optimal Control; arXiv.1011.4874; 3. Doria, P., Calarco, T. & Montangero, S. ; Optimal Control Technique for Many-Body Quantum Dynamics. ; Phys. Rev. Lett. 106, 1â4 (2011).; 4. Caneva, T., Calarco, T. & Montangero, S. ; Chopped random-basis quantum optimization. ; Phys. Rev. A - At. Mol. Opt. Phys. 84, (2011). """"""; import numpy as np; import warnings. # QuTiP; from qutip import Qobj; import qutip.logging_utils as loggin",MatchSource.WIKI,docs/4.2/modules/qutip/control/pulseoptim.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/control/pulseoptim.html
https://qutip.org/docs/4.2/modules/qutip/control/pulseoptim.html:5158,Integrability,message,message,5158,"o, T. & Montangero, S. ; Optimal Control Technique for Many-Body Quantum Dynamics. ; Phys. Rev. Lett. 106, 1â4 (2011).; 4. Caneva, T., Calarco, T. & Montangero, S. ; Chopped random-basis quantum optimization. ; Phys. Rev. A - At. Mol. Opt. Phys. 84, (2011). """"""; import numpy as np; import warnings. # QuTiP; from qutip import Qobj; import qutip.logging_utils as logging; logger = logging.get_logger(); # QuTiP control modules; import qutip.control.optimconfig as optimconfig; import qutip.control.dynamics as dynamics; import qutip.control.termcond as termcond; import qutip.control.optimizer as optimizer; import qutip.control.stats as stats; import qutip.control.errors as errors; import qutip.control.fidcomp as fidcomp; import qutip.control.propcomp as propcomp; import qutip.control.pulsegen as pulsegen; #import qutip.control.pulsegencrab as pulsegencrab. warnings.simplefilter('always', DeprecationWarning) #turn off filter ; def _param_deprecation(message, stacklevel=3):; """"""; Issue deprecation warning; Using stacklevel=3 will ensure message refers the function; calling with the deprecated parameter,; """"""; warnings.warn(message, DeprecationWarning, stacklevel=stacklevel); ; def _upper_safe(s):; try:; s = s.upper(); except:; pass; return s; ; [docs]def optimize_pulse(; drift, ctrls, initial, target,; num_tslots=None, evo_time=None, tau=None,; amp_lbound=None, amp_ubound=None,; fid_err_targ=1e-10, min_grad=1e-10,; max_iter=500, max_wall_time=180,; alg='GRAPE', alg_params=None,; optim_params=None, optim_method='DEF', method_params=None,; optim_alg=None, max_metric_corr=None, accuracy_factor=None,; dyn_type='GEN_MAT', dyn_params=None,; prop_type='DEF', prop_params=None,; fid_type='DEF', fid_params=None,; phase_option=None, fid_err_scale_factor=None,; tslot_type='DEF', tslot_params=None,; amp_update_mode=None,; init_pulse_type='DEF', init_pulse_params=None,; pulse_scaling=1.0, pulse_offset=0.0,; ramping_pulse_type=None, ramping_pulse_params=None,; log_level=logging.NOTSET, ou",MatchSource.WIKI,docs/4.2/modules/qutip/control/pulseoptim.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/control/pulseoptim.html
https://qutip.org/docs/4.2/modules/qutip/control/pulseoptim.html:5246,Integrability,message,message,5246,"o, T. & Montangero, S. ; Optimal Control Technique for Many-Body Quantum Dynamics. ; Phys. Rev. Lett. 106, 1â4 (2011).; 4. Caneva, T., Calarco, T. & Montangero, S. ; Chopped random-basis quantum optimization. ; Phys. Rev. A - At. Mol. Opt. Phys. 84, (2011). """"""; import numpy as np; import warnings. # QuTiP; from qutip import Qobj; import qutip.logging_utils as logging; logger = logging.get_logger(); # QuTiP control modules; import qutip.control.optimconfig as optimconfig; import qutip.control.dynamics as dynamics; import qutip.control.termcond as termcond; import qutip.control.optimizer as optimizer; import qutip.control.stats as stats; import qutip.control.errors as errors; import qutip.control.fidcomp as fidcomp; import qutip.control.propcomp as propcomp; import qutip.control.pulsegen as pulsegen; #import qutip.control.pulsegencrab as pulsegencrab. warnings.simplefilter('always', DeprecationWarning) #turn off filter ; def _param_deprecation(message, stacklevel=3):; """"""; Issue deprecation warning; Using stacklevel=3 will ensure message refers the function; calling with the deprecated parameter,; """"""; warnings.warn(message, DeprecationWarning, stacklevel=stacklevel); ; def _upper_safe(s):; try:; s = s.upper(); except:; pass; return s; ; [docs]def optimize_pulse(; drift, ctrls, initial, target,; num_tslots=None, evo_time=None, tau=None,; amp_lbound=None, amp_ubound=None,; fid_err_targ=1e-10, min_grad=1e-10,; max_iter=500, max_wall_time=180,; alg='GRAPE', alg_params=None,; optim_params=None, optim_method='DEF', method_params=None,; optim_alg=None, max_metric_corr=None, accuracy_factor=None,; dyn_type='GEN_MAT', dyn_params=None,; prop_type='DEF', prop_params=None,; fid_type='DEF', fid_params=None,; phase_option=None, fid_err_scale_factor=None,; tslot_type='DEF', tslot_params=None,; amp_update_mode=None,; init_pulse_type='DEF', init_pulse_params=None,; pulse_scaling=1.0, pulse_offset=0.0,; ramping_pulse_type=None, ramping_pulse_params=None,; log_level=logging.NOTSET, ou",MatchSource.WIKI,docs/4.2/modules/qutip/control/pulseoptim.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/control/pulseoptim.html
https://qutip.org/docs/4.2/modules/qutip/control/pulseoptim.html:5334,Integrability,message,message,5334,"random-basis quantum optimization. ; Phys. Rev. A - At. Mol. Opt. Phys. 84, (2011). """"""; import numpy as np; import warnings. # QuTiP; from qutip import Qobj; import qutip.logging_utils as logging; logger = logging.get_logger(); # QuTiP control modules; import qutip.control.optimconfig as optimconfig; import qutip.control.dynamics as dynamics; import qutip.control.termcond as termcond; import qutip.control.optimizer as optimizer; import qutip.control.stats as stats; import qutip.control.errors as errors; import qutip.control.fidcomp as fidcomp; import qutip.control.propcomp as propcomp; import qutip.control.pulsegen as pulsegen; #import qutip.control.pulsegencrab as pulsegencrab. warnings.simplefilter('always', DeprecationWarning) #turn off filter ; def _param_deprecation(message, stacklevel=3):; """"""; Issue deprecation warning; Using stacklevel=3 will ensure message refers the function; calling with the deprecated parameter,; """"""; warnings.warn(message, DeprecationWarning, stacklevel=stacklevel); ; def _upper_safe(s):; try:; s = s.upper(); except:; pass; return s; ; [docs]def optimize_pulse(; drift, ctrls, initial, target,; num_tslots=None, evo_time=None, tau=None,; amp_lbound=None, amp_ubound=None,; fid_err_targ=1e-10, min_grad=1e-10,; max_iter=500, max_wall_time=180,; alg='GRAPE', alg_params=None,; optim_params=None, optim_method='DEF', method_params=None,; optim_alg=None, max_metric_corr=None, accuracy_factor=None,; dyn_type='GEN_MAT', dyn_params=None,; prop_type='DEF', prop_params=None,; fid_type='DEF', fid_params=None,; phase_option=None, fid_err_scale_factor=None,; tslot_type='DEF', tslot_params=None,; amp_update_mode=None,; init_pulse_type='DEF', init_pulse_params=None,; pulse_scaling=1.0, pulse_offset=0.0,; ramping_pulse_type=None, ramping_pulse_params=None,; log_level=logging.NOTSET, out_file_ext=None, gen_stats=False):; """"""; Optimise a control pulse to minimise the fidelity error.; The dynamics of the system in any given timeslot are governed; by the combin",MatchSource.WIKI,docs/4.2/modules/qutip/control/pulseoptim.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/control/pulseoptim.html
https://qutip.org/docs/4.2/modules/qutip/control/pulseoptim.html:7003,Integrability,depend,dependent,7003,"tion=None, fid_err_scale_factor=None,; tslot_type='DEF', tslot_params=None,; amp_update_mode=None,; init_pulse_type='DEF', init_pulse_params=None,; pulse_scaling=1.0, pulse_offset=0.0,; ramping_pulse_type=None, ramping_pulse_params=None,; log_level=logging.NOTSET, out_file_ext=None, gen_stats=False):; """"""; Optimise a control pulse to minimise the fidelity error.; The dynamics of the system in any given timeslot are governed; by the combined dynamics generator,; i.e. the sum of the drift+ctrl_amp[j]*ctrls[j]; The control pulse is an [n_ts, n_ctrls)] array of piecewise amplitudes; Starting from an intital (typically random) pulse,; a multivariable optimisation algorithm attempts to determines the; optimal values for the control pulse to minimise the fidelity error; The fidelity error is some measure of distance of the system evolution; from the given target evolution in the time allowed for the evolution. Parameters; ----------; drift : Qobj or list of Qobj; the underlying dynamics generator of the system; can provide list (of length num_tslots) for time dependent drift. ctrls : List of Qobj or array like [num_tslots, evo_time]; a list of control dynamics generators. These are scaled by; the amplitudes to alter the overall dynamics; Array like imput can be provided for time dependent control generators. initial : Qobj; starting point for the evolution.; Typically the identity matrix. target : Qobj; target transformation, e.g. gate or state, for the time evolution. num_tslots : integer or None; number of timeslots.; None implies that timeslots will be given in the tau array. evo_time : float or None; total time for the evolution; None implies that timeslots will be given in the tau array. tau : array[num_tslots] of floats or None; durations for the timeslots.; if this is given then num_tslots and evo_time are dervived; from it; None implies that timeslot durations will be equal and; calculated as evo_time/num_tslots. amp_lbound : float or list of floats; lower boundarie",MatchSource.WIKI,docs/4.2/modules/qutip/control/pulseoptim.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/control/pulseoptim.html
https://qutip.org/docs/4.2/modules/qutip/control/pulseoptim.html:7227,Integrability,depend,dependent,7227,"ging.NOTSET, out_file_ext=None, gen_stats=False):; """"""; Optimise a control pulse to minimise the fidelity error.; The dynamics of the system in any given timeslot are governed; by the combined dynamics generator,; i.e. the sum of the drift+ctrl_amp[j]*ctrls[j]; The control pulse is an [n_ts, n_ctrls)] array of piecewise amplitudes; Starting from an intital (typically random) pulse,; a multivariable optimisation algorithm attempts to determines the; optimal values for the control pulse to minimise the fidelity error; The fidelity error is some measure of distance of the system evolution; from the given target evolution in the time allowed for the evolution. Parameters; ----------; drift : Qobj or list of Qobj; the underlying dynamics generator of the system; can provide list (of length num_tslots) for time dependent drift. ctrls : List of Qobj or array like [num_tslots, evo_time]; a list of control dynamics generators. These are scaled by; the amplitudes to alter the overall dynamics; Array like imput can be provided for time dependent control generators. initial : Qobj; starting point for the evolution.; Typically the identity matrix. target : Qobj; target transformation, e.g. gate or state, for the time evolution. num_tslots : integer or None; number of timeslots.; None implies that timeslots will be given in the tau array. evo_time : float or None; total time for the evolution; None implies that timeslots will be given in the tau array. tau : array[num_tslots] of floats or None; durations for the timeslots.; if this is given then num_tslots and evo_time are dervived; from it; None implies that timeslot durations will be equal and; calculated as evo_time/num_tslots. amp_lbound : float or list of floats; lower boundaries for the control amplitudes; Can be a scalar value applied to all controls; or a list of bounds for each control. amp_ubound : float or list of floats; upper boundaries for the control amplitudes; Can be a scalar value applied to all controls; or a li",MatchSource.WIKI,docs/4.2/modules/qutip/control/pulseoptim.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/control/pulseoptim.html
https://qutip.org/docs/4.2/modules/qutip/control/pulseoptim.html:9562,Integrability,depend,dependent,9562,"me : float; Maximum allowed elapsed time for the optimisation algorithm. alg : string; Algorithm to use in pulse optimisation.; Options are:; ; 'GRAPE' (default) - GRadient Ascent Pulse Engineering; 'CRAB' - Chopped RAndom Basis. alg_params : Dictionary; options that are specific to the algorithm see above; ; optim_params : Dictionary; The key value pairs are the attribute name and value; used to set attribute values; Note: attributes are created if they do not exist already,; and are overwritten if they do.; Note: method_params are applied afterwards and so may override these; ; optim_method : string; a scipy.optimize.minimize method that will be used to optimise; the pulse for minimum fidelity error; Note that FMIN, FMIN_BFGS & FMIN_L_BFGS_B will all result; in calling these specific scipy.optimize methods; Note the LBFGSB is equivalent to FMIN_L_BFGS_B for backwards ; capatibility reasons.; Supplying DEF will given alg dependent result:; GRAPE - Default optim_method is FMIN_L_BFGS_B; CRAB - Default optim_method is FMIN; ; method_params : dict; Parameters for the optim_method. ; Note that where there is an attribute of the; Optimizer object or the termination_conditions matching the key ; that attribute. Otherwise, and in some case also, ; they are assumed to be method_options; for the scipy.optimize.minimize method. ; ; optim_alg : string; Deprecated. Use optim_method. max_metric_corr : integer; Deprecated. Use method_params instead. accuracy_factor : float; Deprecated. Use method_params instead. dyn_type : string; Dynamics type, i.e. the type of matrix used to describe; the dynamics. Options are UNIT, GEN_MAT, SYMPL; (see Dynamics classes for details); ; dyn_params : dict; Parameters for the Dynamics object; The key value pairs are assumed to be attribute name value pairs; They applied after the object is created. prop_type : string; Propagator type i.e. the method used to calculate the; propagtors and propagtor gradient for each timeslot; options are DEF, APPRO",MatchSource.WIKI,docs/4.2/modules/qutip/control/pulseoptim.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/control/pulseoptim.html
https://qutip.org/docs/4.2/modules/qutip/control/pulseoptim.html:19632,Integrability,wrap,wrapper,19632,"e). return result. [docs]def optimize_pulse_unitary(; H_d, H_c, U_0, U_targ,; num_tslots=None, evo_time=None, tau=None,; amp_lbound=None, amp_ubound=None,; fid_err_targ=1e-10, min_grad=1e-10,; max_iter=500, max_wall_time=180,; alg='GRAPE', alg_params=None,; optim_params=None, optim_method='DEF', method_params=None,; optim_alg=None, max_metric_corr=None, accuracy_factor=None,; phase_option='PSU', ; dyn_params=None, prop_params=None, fid_params=None,; tslot_type='DEF', tslot_params=None,; amp_update_mode=None,; init_pulse_type='DEF', init_pulse_params=None,; pulse_scaling=1.0, pulse_offset=0.0,; ramping_pulse_type=None, ramping_pulse_params=None,; log_level=logging.NOTSET, out_file_ext=None, gen_stats=False):. """"""; Optimise a control pulse to minimise the fidelity error, assuming that; the dynamics of the system are generated by unitary operators.; This function is simply a wrapper for optimize_pulse, where the; appropriate options for unitary dynamics are chosen and the parameter; names are in the format familiar to unitary dynamics; The dynamics of the system in any given timeslot are governed; by the combined Hamiltonian,; i.e. the sum of the H_d + ctrl_amp[j]*H_c[j]; The control pulse is an [n_ts, n_ctrls] array of piecewise amplitudes; Starting from an intital (typically random) pulse,; a multivariable optimisation algorithm attempts to determines the; optimal values for the control pulse to minimise the fidelity error; The maximum fidelity for a unitary system is 1, i.e. when the; time evolution resulting from the pulse is equivalent to the target.; And therefore the fidelity error is 1 - fidelity. Parameters; ----------; H_d : Qobj or list of Qobj; Drift (aka system) the underlying Hamiltonian of the system; can provide list (of length num_tslots) for time dependent drift; ; H_c : List of Qobj or array like [num_tslots, evo_time]; a list of control Hamiltonians. These are scaled by; the amplitudes to alter the overall dynamics; Array like imput can be provided f",MatchSource.WIKI,docs/4.2/modules/qutip/control/pulseoptim.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/control/pulseoptim.html
https://qutip.org/docs/4.2/modules/qutip/control/pulseoptim.html:20539,Integrability,depend,dependent,20539,"fidelity error, assuming that; the dynamics of the system are generated by unitary operators.; This function is simply a wrapper for optimize_pulse, where the; appropriate options for unitary dynamics are chosen and the parameter; names are in the format familiar to unitary dynamics; The dynamics of the system in any given timeslot are governed; by the combined Hamiltonian,; i.e. the sum of the H_d + ctrl_amp[j]*H_c[j]; The control pulse is an [n_ts, n_ctrls] array of piecewise amplitudes; Starting from an intital (typically random) pulse,; a multivariable optimisation algorithm attempts to determines the; optimal values for the control pulse to minimise the fidelity error; The maximum fidelity for a unitary system is 1, i.e. when the; time evolution resulting from the pulse is equivalent to the target.; And therefore the fidelity error is 1 - fidelity. Parameters; ----------; H_d : Qobj or list of Qobj; Drift (aka system) the underlying Hamiltonian of the system; can provide list (of length num_tslots) for time dependent drift; ; H_c : List of Qobj or array like [num_tslots, evo_time]; a list of control Hamiltonians. These are scaled by; the amplitudes to alter the overall dynamics; Array like imput can be provided for time dependent control generators. U_0 : Qobj; starting point for the evolution.; Typically the identity matrix. U_targ : Qobj; target transformation, e.g. gate or state, for the time evolution. num_tslots : integer or None; number of timeslots.; None implies that timeslots will be given in the tau array. evo_time : float or None; total time for the evolution; None implies that timeslots will be given in the tau array. tau : array[num_tslots] of floats or None; durations for the timeslots.; if this is given then num_tslots and evo_time are dervived; from it; None implies that timeslot durations will be equal and; calculated as evo_time/num_tslots. amp_lbound : float or list of floats; lower boundaries for the control amplitudes; Can be a scalar value",MatchSource.WIKI,docs/4.2/modules/qutip/control/pulseoptim.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/control/pulseoptim.html
https://qutip.org/docs/4.2/modules/qutip/control/pulseoptim.html:20756,Integrability,depend,dependent,20756," chosen and the parameter; names are in the format familiar to unitary dynamics; The dynamics of the system in any given timeslot are governed; by the combined Hamiltonian,; i.e. the sum of the H_d + ctrl_amp[j]*H_c[j]; The control pulse is an [n_ts, n_ctrls] array of piecewise amplitudes; Starting from an intital (typically random) pulse,; a multivariable optimisation algorithm attempts to determines the; optimal values for the control pulse to minimise the fidelity error; The maximum fidelity for a unitary system is 1, i.e. when the; time evolution resulting from the pulse is equivalent to the target.; And therefore the fidelity error is 1 - fidelity. Parameters; ----------; H_d : Qobj or list of Qobj; Drift (aka system) the underlying Hamiltonian of the system; can provide list (of length num_tslots) for time dependent drift; ; H_c : List of Qobj or array like [num_tslots, evo_time]; a list of control Hamiltonians. These are scaled by; the amplitudes to alter the overall dynamics; Array like imput can be provided for time dependent control generators. U_0 : Qobj; starting point for the evolution.; Typically the identity matrix. U_targ : Qobj; target transformation, e.g. gate or state, for the time evolution. num_tslots : integer or None; number of timeslots.; None implies that timeslots will be given in the tau array. evo_time : float or None; total time for the evolution; None implies that timeslots will be given in the tau array. tau : array[num_tslots] of floats or None; durations for the timeslots.; if this is given then num_tslots and evo_time are dervived; from it; None implies that timeslot durations will be equal and; calculated as evo_time/num_tslots. amp_lbound : float or list of floats; lower boundaries for the control amplitudes; Can be a scalar value applied to all controls; or a list of bounds for each control. amp_ubound : float or list of floats; upper boundaries for the control amplitudes; Can be a scalar value applied to all controls; or a list o",MatchSource.WIKI,docs/4.2/modules/qutip/control/pulseoptim.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/control/pulseoptim.html
https://qutip.org/docs/4.2/modules/qutip/control/pulseoptim.html:23085,Integrability,depend,dependent,23085,"ime : float; Maximum allowed elapsed time for the optimisation algorithm. alg : string; Algorithm to use in pulse optimisation.; Options are:; 'GRAPE' (default) - GRadient Ascent Pulse Engineering; 'CRAB' - Chopped RAndom Basis. alg_params : Dictionary; options that are specific to the algorithm see above; ; optim_params : Dictionary; The key value pairs are the attribute name and value; used to set attribute values; Note: attributes are created if they do not exist already,; and are overwritten if they do.; Note: method_params are applied afterwards and so may override these; ; optim_method : string; a scipy.optimize.minimize method that will be used to optimise; the pulse for minimum fidelity error; Note that FMIN, FMIN_BFGS & FMIN_L_BFGS_B will all result; in calling these specific scipy.optimize methods; Note the LBFGSB is equivalent to FMIN_L_BFGS_B for backwards ; capatibility reasons.; Supplying DEF will given alg dependent result:; ; GRAPE - Default optim_method is FMIN_L_BFGS_B; CRAB - Default optim_method is FMIN; ; method_params : dict; Parameters for the optim_method. ; Note that where there is an attribute of the; Optimizer object or the termination_conditions matching the key ; that attribute. Otherwise, and in some case also, ; they are assumed to be method_options; for the scipy.optimize.minimize method. ; ; optim_alg : string; Deprecated. Use optim_method. max_metric_corr : integer; Deprecated. Use method_params instead. accuracy_factor : float; Deprecated. Use method_params instead. phase_option : string; determines how global phase is treated in fidelity; calculations (fid_type='UNIT' only). Options:; ; PSU - global phase ignored; SU - global phase included. dyn_params : dict; Parameters for the Dynamics object; The key value pairs are assumed to be attribute name value pairs; They applied after the object is created. prop_params : dict; Parameters for the PropagatorComputer object; The key value pairs are assumed to be attribute name value pairs;",MatchSource.WIKI,docs/4.2/modules/qutip/control/pulseoptim.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/control/pulseoptim.html
https://qutip.org/docs/4.2/modules/qutip/control/pulseoptim.html:31001,Integrability,depend,dependent,31001,"=None, guess_pulse_params=None,; guess_pulse_scaling=1.0, guess_pulse_offset=0.0,; guess_pulse_action='MODULATE', ; ramping_pulse_type=None, ramping_pulse_params=None,; log_level=logging.NOTSET, out_file_ext=None, gen_stats=False):; """"""; Optimise a control pulse to minimise the fidelity error.; The dynamics of the system in any given timeslot are governed; by the combined dynamics generator,; i.e. the sum of the drift+ctrl_amp[j]*ctrls[j]; The control pulse is an [n_ts, n_ctrls] array of piecewise amplitudes.; The CRAB algorithm uses basis function coefficents as the variables to; optimise. It does NOT use any gradient function.; A multivariable optimisation algorithm attempts to determines the; optimal values for the control pulse to minimise the fidelity error; The fidelity error is some measure of distance of the system evolution; from the given target evolution in the time allowed for the evolution. Parameters; ----------; drift : Qobj or list of Qobj; the underlying dynamics generator of the system; can provide list (of length num_tslots) for time dependent drift. ctrls : List of Qobj or array like [num_tslots, evo_time]; a list of control dynamics generators. These are scaled by; the amplitudes to alter the overall dynamics; Array like imput can be provided for time dependent control generators. initial : Qobj; starting point for the evolution.; Typically the identity matrix. target : Qobj; target transformation, e.g. gate or state, for the time evolution. num_tslots : integer or None; number of timeslots.; None implies that timeslots will be given in the tau array. evo_time : float or None; total time for the evolution; None implies that timeslots will be given in the tau array. tau : array[num_tslots] of floats or None; durations for the timeslots.; if this is given then num_tslots and evo_time are dervived; from it; None implies that timeslot durations will be equal and; calculated as evo_time/num_tslots. amp_lbound : float or list of floats; lower boundarie",MatchSource.WIKI,docs/4.2/modules/qutip/control/pulseoptim.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/control/pulseoptim.html
https://qutip.org/docs/4.2/modules/qutip/control/pulseoptim.html:31225,Integrability,depend,dependent,31225,"trol pulse to minimise the fidelity error.; The dynamics of the system in any given timeslot are governed; by the combined dynamics generator,; i.e. the sum of the drift+ctrl_amp[j]*ctrls[j]; The control pulse is an [n_ts, n_ctrls] array of piecewise amplitudes.; The CRAB algorithm uses basis function coefficents as the variables to; optimise. It does NOT use any gradient function.; A multivariable optimisation algorithm attempts to determines the; optimal values for the control pulse to minimise the fidelity error; The fidelity error is some measure of distance of the system evolution; from the given target evolution in the time allowed for the evolution. Parameters; ----------; drift : Qobj or list of Qobj; the underlying dynamics generator of the system; can provide list (of length num_tslots) for time dependent drift. ctrls : List of Qobj or array like [num_tslots, evo_time]; a list of control dynamics generators. These are scaled by; the amplitudes to alter the overall dynamics; Array like imput can be provided for time dependent control generators. initial : Qobj; starting point for the evolution.; Typically the identity matrix. target : Qobj; target transformation, e.g. gate or state, for the time evolution. num_tslots : integer or None; number of timeslots.; None implies that timeslots will be given in the tau array. evo_time : float or None; total time for the evolution; None implies that timeslots will be given in the tau array. tau : array[num_tslots] of floats or None; durations for the timeslots.; if this is given then num_tslots and evo_time are dervived; from it; None implies that timeslot durations will be equal and; calculated as evo_time/num_tslots. amp_lbound : float or list of floats; lower boundaries for the control amplitudes; Can be a scalar value applied to all controls; or a list of bounds for each control. amp_ubound : float or list of floats; upper boundaries for the control amplitudes; Can be a scalar value applied to all controls; or a li",MatchSource.WIKI,docs/4.2/modules/qutip/control/pulseoptim.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/control/pulseoptim.html
https://qutip.org/docs/4.2/modules/qutip/control/pulseoptim.html:40825,Integrability,wrap,wrapper,40825,"_ext=out_file_ext, gen_stats=gen_stats); ; [docs]def opt_pulse_crab_unitary(; H_d, H_c, U_0, U_targ,; num_tslots=None, evo_time=None, tau=None,; amp_lbound=None, amp_ubound=None,; fid_err_targ=1e-5,; max_iter=500, max_wall_time=180,; alg_params=None,; num_coeffs=None, init_coeff_scaling=1.0, ; optim_params=None, optim_method='fmin', method_params=None,; phase_option='PSU', ; dyn_params=None, prop_params=None, fid_params=None,; tslot_type='DEF', tslot_params=None,; guess_pulse_type=None, guess_pulse_params=None,; guess_pulse_scaling=1.0, guess_pulse_offset=0.0,; guess_pulse_action='MODULATE', ; ramping_pulse_type=None, ramping_pulse_params=None,; log_level=logging.NOTSET, out_file_ext=None, gen_stats=False):; """"""; Optimise a control pulse to minimise the fidelity error, assuming that; the dynamics of the system are generated by unitary operators.; This function is simply a wrapper for optimize_pulse, where the; appropriate options for unitary dynamics are chosen and the parameter; names are in the format familiar to unitary dynamics; The dynamics of the system in any given timeslot are governed; by the combined Hamiltonian,; i.e. the sum of the H_d + ctrl_amp[j]*H_c[j]; The control pulse is an [n_ts, n_ctrls] array of piecewise amplitudes; ; The CRAB algorithm uses basis function coefficents as the variables to; optimise. It does NOT use any gradient function.; A multivariable optimisation algorithm attempts to determines the; optimal values for the control pulse to minimise the fidelity error; The fidelity error is some measure of distance of the system evolution; from the given target evolution in the time allowed for the evolution. Parameters; ----------. H_d : Qobj or list of Qobj; Drift (aka system) the underlying Hamiltonian of the system; can provide list (of length num_tslots) for time dependent drift. H_c : List of Qobj or array like [num_tslots, evo_time]; a list of control Hamiltonians. These are scaled by; the amplitudes to alter the overall dynamics; Arra",MatchSource.WIKI,docs/4.2/modules/qutip/control/pulseoptim.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/control/pulseoptim.html
https://qutip.org/docs/4.2/modules/qutip/control/pulseoptim.html:41764,Integrability,depend,dependent,41764,"e fidelity error, assuming that; the dynamics of the system are generated by unitary operators.; This function is simply a wrapper for optimize_pulse, where the; appropriate options for unitary dynamics are chosen and the parameter; names are in the format familiar to unitary dynamics; The dynamics of the system in any given timeslot are governed; by the combined Hamiltonian,; i.e. the sum of the H_d + ctrl_amp[j]*H_c[j]; The control pulse is an [n_ts, n_ctrls] array of piecewise amplitudes; ; The CRAB algorithm uses basis function coefficents as the variables to; optimise. It does NOT use any gradient function.; A multivariable optimisation algorithm attempts to determines the; optimal values for the control pulse to minimise the fidelity error; The fidelity error is some measure of distance of the system evolution; from the given target evolution in the time allowed for the evolution. Parameters; ----------. H_d : Qobj or list of Qobj; Drift (aka system) the underlying Hamiltonian of the system; can provide list (of length num_tslots) for time dependent drift. H_c : List of Qobj or array like [num_tslots, evo_time]; a list of control Hamiltonians. These are scaled by; the amplitudes to alter the overall dynamics; Array like imput can be provided for time dependent control generators. U_0 : Qobj; starting point for the evolution.; Typically the identity matrix. U_targ : Qobj; target transformation, e.g. gate or state, for the time evolution. num_tslots : integer or None; number of timeslots.; None implies that timeslots will be given in the tau array. evo_time : float or None; total time for the evolution; None implies that timeslots will be given in the tau array. tau : array[num_tslots] of floats or None; durations for the timeslots.; if this is given then num_tslots and evo_time are dervived; from it; None implies that timeslot durations will be equal and; calculated as evo_time/num_tslots. amp_lbound : float or list of floats; lower boundaries for the control am",MatchSource.WIKI,docs/4.2/modules/qutip/control/pulseoptim.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/control/pulseoptim.html
https://qutip.org/docs/4.2/modules/qutip/control/pulseoptim.html:41979,Integrability,depend,dependent,41979,"es are in the format familiar to unitary dynamics; The dynamics of the system in any given timeslot are governed; by the combined Hamiltonian,; i.e. the sum of the H_d + ctrl_amp[j]*H_c[j]; The control pulse is an [n_ts, n_ctrls] array of piecewise amplitudes; ; The CRAB algorithm uses basis function coefficents as the variables to; optimise. It does NOT use any gradient function.; A multivariable optimisation algorithm attempts to determines the; optimal values for the control pulse to minimise the fidelity error; The fidelity error is some measure of distance of the system evolution; from the given target evolution in the time allowed for the evolution. Parameters; ----------. H_d : Qobj or list of Qobj; Drift (aka system) the underlying Hamiltonian of the system; can provide list (of length num_tslots) for time dependent drift. H_c : List of Qobj or array like [num_tslots, evo_time]; a list of control Hamiltonians. These are scaled by; the amplitudes to alter the overall dynamics; Array like imput can be provided for time dependent control generators. U_0 : Qobj; starting point for the evolution.; Typically the identity matrix. U_targ : Qobj; target transformation, e.g. gate or state, for the time evolution. num_tslots : integer or None; number of timeslots.; None implies that timeslots will be given in the tau array. evo_time : float or None; total time for the evolution; None implies that timeslots will be given in the tau array. tau : array[num_tslots] of floats or None; durations for the timeslots.; if this is given then num_tslots and evo_time are dervived; from it; None implies that timeslot durations will be equal and; calculated as evo_time/num_tslots. amp_lbound : float or list of floats; lower boundaries for the control amplitudes; Can be a scalar value applied to all controls; or a list of bounds for each control. amp_ubound : float or list of floats; upper boundaries for the control amplitudes; Can be a scalar value applied to all controls; or a list o",MatchSource.WIKI,docs/4.2/modules/qutip/control/pulseoptim.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/control/pulseoptim.html
https://qutip.org/docs/4.2/modules/qutip/control/pulseoptim.html:51529,Integrability,depend,dependent,51529,"m_params=None, optim_method='DEF', method_params=None,; optim_alg=None, max_metric_corr=None, accuracy_factor=None,; dyn_type='GEN_MAT', dyn_params=None,; prop_type='DEF', prop_params=None,; fid_type='DEF', fid_params=None,; phase_option=None, fid_err_scale_factor=None,; tslot_type='DEF', tslot_params=None,; amp_update_mode=None,; init_pulse_type='DEF', init_pulse_params=None,; pulse_scaling=1.0, pulse_offset=0.0,; ramping_pulse_type=None, ramping_pulse_params=None,; log_level=logging.NOTSET, gen_stats=False):. """"""; Generate the objects of the appropriate subclasses; required for the pulse optmisation based on the parameters given; Note this method may be preferable to calling optimize_pulse; if more detailed configuration is required before running the; optmisation algorthim, or the algorithm will be run many times,; for instances when trying to finding global the optimum or; minimum time optimisation. Parameters; ----------; drift : Qobj or list of Qobj; the underlying dynamics generator of the system; can provide list (of length num_tslots) for time dependent drift. ctrls : List of Qobj or array like [num_tslots, evo_time]; a list of control dynamics generators. These are scaled by; the amplitudes to alter the overall dynamics; Array like imput can be provided for time dependent control generators. initial : Qobj; starting point for the evolution.; Typically the identity matrix. target : Qobj; target transformation, e.g. gate or state, for the time evolution. num_tslots : integer or None; number of timeslots.; None implies that timeslots will be given in the tau array. evo_time : float or None; total time for the evolution; None implies that timeslots will be given in the tau array. tau : array[num_tslots] of floats or None; durations for the timeslots.; if this is given then num_tslots and evo_time are dervived; from it; None implies that timeslot durations will be equal and; calculated as evo_time/num_tslots. amp_lbound : float or list of floats; lower boundarie",MatchSource.WIKI,docs/4.2/modules/qutip/control/pulseoptim.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/control/pulseoptim.html
https://qutip.org/docs/4.2/modules/qutip/control/pulseoptim.html:51753,Integrability,depend,dependent,51753,"scale_factor=None,; tslot_type='DEF', tslot_params=None,; amp_update_mode=None,; init_pulse_type='DEF', init_pulse_params=None,; pulse_scaling=1.0, pulse_offset=0.0,; ramping_pulse_type=None, ramping_pulse_params=None,; log_level=logging.NOTSET, gen_stats=False):. """"""; Generate the objects of the appropriate subclasses; required for the pulse optmisation based on the parameters given; Note this method may be preferable to calling optimize_pulse; if more detailed configuration is required before running the; optmisation algorthim, or the algorithm will be run many times,; for instances when trying to finding global the optimum or; minimum time optimisation. Parameters; ----------; drift : Qobj or list of Qobj; the underlying dynamics generator of the system; can provide list (of length num_tslots) for time dependent drift. ctrls : List of Qobj or array like [num_tslots, evo_time]; a list of control dynamics generators. These are scaled by; the amplitudes to alter the overall dynamics; Array like imput can be provided for time dependent control generators. initial : Qobj; starting point for the evolution.; Typically the identity matrix. target : Qobj; target transformation, e.g. gate or state, for the time evolution. num_tslots : integer or None; number of timeslots.; None implies that timeslots will be given in the tau array. evo_time : float or None; total time for the evolution; None implies that timeslots will be given in the tau array. tau : array[num_tslots] of floats or None; durations for the timeslots.; if this is given then num_tslots and evo_time are dervived; from it; None implies that timeslot durations will be equal and; calculated as evo_time/num_tslots. amp_lbound : float or list of floats; lower boundaries for the control amplitudes; Can be a scalar value applied to all controls; or a list of bounds for each control. amp_ubound : float or list of floats; upper boundaries for the control amplitudes; Can be a scalar value applied to all controls; or a li",MatchSource.WIKI,docs/4.2/modules/qutip/control/pulseoptim.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/control/pulseoptim.html
https://qutip.org/docs/4.2/modules/qutip/control/pulseoptim.html:54088,Integrability,depend,dependent,54088,"float; Maximum allowed elapsed time for the optimisation algorithm; ; alg : string; Algorithm to use in pulse optimisation.; Options are:; 'GRAPE' (default) - GRadient Ascent Pulse Engineering; 'CRAB' - Chopped RAndom Basis. alg_params : Dictionary; options that are specific to the algorithm see above; ; optim_params : Dictionary; The key value pairs are the attribute name and value; used to set attribute values; Note: attributes are created if they do not exist already,; and are overwritten if they do.; Note: method_params are applied afterwards and so may override these; ; optim_method : string; a scipy.optimize.minimize method that will be used to optimise; the pulse for minimum fidelity error; Note that FMIN, FMIN_BFGS & FMIN_L_BFGS_B will all result; in calling these specific scipy.optimize methods; Note the LBFGSB is equivalent to FMIN_L_BFGS_B for backwards ; capatibility reasons.; Supplying DEF will given alg dependent result:; - GRAPE - Default optim_method is FMIN_L_BFGS_B; - CRAB - Default optim_method is Nelder-Mead; ; method_params : dict; Parameters for the optim_method. ; Note that where there is an attribute of the; Optimizer object or the termination_conditions matching the key ; that attribute. Otherwise, and in some case also, ; they are assumed to be method_options; for the scipy.optimize.minimize method. ; ; optim_alg : string; Deprecated. Use optim_method. max_metric_corr : integer; Deprecated. Use method_params instead. accuracy_factor : float; Deprecated. Use method_params instead. dyn_type : string; Dynamics type, i.e. the type of matrix used to describe; the dynamics. Options are UNIT, GEN_MAT, SYMPL; (see Dynamics classes for details); ; dyn_params : dict; Parameters for the Dynamics object; The key value pairs are assumed to be attribute name value pairs; They applied after the object is created. prop_type : string; Propagator type i.e. the method used to calculate the; propagtors and propagtor gradient for each timeslot; options are DEF, ",MatchSource.WIKI,docs/4.2/modules/qutip/control/pulseoptim.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/control/pulseoptim.html
https://qutip.org/docs/4.2/modules/qutip/control/pulseoptim.html:68527,Integrability,message,message,68527,"_params); guess_pulse_action = init_pulse_params.get('pulse_action'). optim.pulse_generator = []; for j in range(n_ctrls):; crab_pgen = pulsegen.PulseGenCrabFourier(; dyn=dyn, num_coeffs=num_coeffs); if init_coeff_scaling is not None:; crab_pgen.scaling = init_coeff_scaling; if isinstance(crab_pulse_params, dict):; crab_pgen.apply_params(crab_pulse_params); ; lb = None; if amp_lbound:; if isinstance(amp_lbound, list):; try:; lb = amp_lbound[j]; except:; lb = amp_lbound[-1]; else:; lb = amp_lbound; ub = None; if amp_ubound:; if isinstance(amp_ubound, list):; try:; ub = amp_ubound[j]; except:; ub = amp_ubound[-1]; else:; ub = amp_ubound; crab_pgen.lbound = lb; crab_pgen.ubound = ub; ; if guess_pulse_type:; guess_pgen.lbound = lb; guess_pgen.ubound = ub; crab_pgen.guess_pulse = guess_pgen.gen_pulse(); if guess_pulse_action:; crab_pgen.guess_pulse_action = guess_pulse_action; ; if ramping_pgen:; crab_pgen.ramping_pulse = ramping_pgen.gen_pulse(). optim.pulse_generator.append(crab_pgen); #This is just for the debug message now; pgen = optim.pulse_generator[0]; ; else:; # Create a pulse generator of the type specified; pgen = pulsegen.create_pulse_gen(pulse_type=init_pulse_type, dyn=dyn,; pulse_params=init_pulse_params); pgen.scaling = pulse_scaling; pgen.offset = pulse_offset; pgen.lbound = amp_lbound; pgen.ubound = amp_ubound. optim.pulse_generator = pgen. if log_level <= logging.DEBUG:; logger.debug(; ""Optimisation config summary...\n""; "" object classes:\n""; "" optimizer: "" + optim.__class__.__name__ +; ""\n dynamics: "" + dyn.__class__.__name__ +; ""\n tslotcomp: "" + dyn.tslot_computer.__class__.__name__ +; ""\n fidcomp: "" + dyn.fid_computer.__class__.__name__ +; ""\n propcomp: "" + dyn.prop_computer.__class__.__name__ +; ""\n pulsegen: "" + pgen.__class__.__name__). return optim. Â© Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, and A.L. Grimsmo.; Last updated on Jan 17, 2018. . Built with Sphinx using a theme provided by Read the Docs. . ",MatchSource.WIKI,docs/4.2/modules/qutip/control/pulseoptim.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/control/pulseoptim.html
https://qutip.org/docs/4.2/modules/qutip/control/pulseoptim.html:2344,Modifiability,config,configuration,2344,"OT; # LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A; # PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT; # HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,; # SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT; # LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,; # DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY; # THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT; # (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE; # OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.; ###############################################################################. # @author: Alexander Pitchford; # @email1: agp1@aber.ac.uk; # @email2: alex.pitchford@gmail.com; # @organization: Aberystwyth University; # @supervisor: Daniel Burgarth. """"""; Wrapper functions that will manage the creation of the objects,; build the configuration, and execute the algorithm required to optimise; a set of ctrl pulses for a given (quantum) system.; The fidelity error is some measure of distance of the system evolution; from the given target evolution in the time allowed for the evolution.; The functions minimise this fidelity error wrt the piecewise control; amplitudes in the timeslots. There are currently two quantum control pulse optmisations algorithms; implemented in this library. There are accessible through the methods; in this module. Both the algorithms use the scipy.optimize methods; to minimise the fidelity error with respect to to variables that define; the pulse. GRAPE; -----; The default algorithm (as it was implemented here first) is GRAPE; GRadient Ascent Pulse Engineering [1][2]. It uses a gradient based method such; as BFGS to minimise the fidelity error. This makes convergence very quick; when an exact gradient can be calculated, but this limits the factors that can; taken into account in the fidelity. CRAB; ----; ",MatchSource.WIKI,docs/4.2/modules/qutip/control/pulseoptim.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/control/pulseoptim.html
https://qutip.org/docs/4.2/modules/qutip/control/pulseoptim.html:2962,Modifiability,variab,variables,2962,"F THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.; ###############################################################################. # @author: Alexander Pitchford; # @email1: agp1@aber.ac.uk; # @email2: alex.pitchford@gmail.com; # @organization: Aberystwyth University; # @supervisor: Daniel Burgarth. """"""; Wrapper functions that will manage the creation of the objects,; build the configuration, and execute the algorithm required to optimise; a set of ctrl pulses for a given (quantum) system.; The fidelity error is some measure of distance of the system evolution; from the given target evolution in the time allowed for the evolution.; The functions minimise this fidelity error wrt the piecewise control; amplitudes in the timeslots. There are currently two quantum control pulse optmisations algorithms; implemented in this library. There are accessible through the methods; in this module. Both the algorithms use the scipy.optimize methods; to minimise the fidelity error with respect to to variables that define; the pulse. GRAPE; -----; The default algorithm (as it was implemented here first) is GRAPE; GRadient Ascent Pulse Engineering [1][2]. It uses a gradient based method such; as BFGS to minimise the fidelity error. This makes convergence very quick; when an exact gradient can be calculated, but this limits the factors that can; taken into account in the fidelity. CRAB; ----; The CRAB [3][4] algorithm was developed at the University of Ulm.; In full it is the Chopped RAndom Basis algorithm.; The main difference is that it reduces the number of optimisation variables ; by defining the control pulses by expansions of basis functions, ; where the variables are the coefficients. Typically a Fourier series is chosen, ; i.e. the variables are the Fourier coefficients. ; Therefore it does not need to compute an explicit gradient. ; By default it uses the Nelder-Mead method for fidelity error minimisation. . References; ----------; 1. N Khaneja et. al. ; Opt",MatchSource.WIKI,docs/4.2/modules/qutip/control/pulseoptim.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/control/pulseoptim.html
https://qutip.org/docs/4.2/modules/qutip/control/pulseoptim.html:3544,Modifiability,variab,variables,3544,"time allowed for the evolution.; The functions minimise this fidelity error wrt the piecewise control; amplitudes in the timeslots. There are currently two quantum control pulse optmisations algorithms; implemented in this library. There are accessible through the methods; in this module. Both the algorithms use the scipy.optimize methods; to minimise the fidelity error with respect to to variables that define; the pulse. GRAPE; -----; The default algorithm (as it was implemented here first) is GRAPE; GRadient Ascent Pulse Engineering [1][2]. It uses a gradient based method such; as BFGS to minimise the fidelity error. This makes convergence very quick; when an exact gradient can be calculated, but this limits the factors that can; taken into account in the fidelity. CRAB; ----; The CRAB [3][4] algorithm was developed at the University of Ulm.; In full it is the Chopped RAndom Basis algorithm.; The main difference is that it reduces the number of optimisation variables ; by defining the control pulses by expansions of basis functions, ; where the variables are the coefficients. Typically a Fourier series is chosen, ; i.e. the variables are the Fourier coefficients. ; Therefore it does not need to compute an explicit gradient. ; By default it uses the Nelder-Mead method for fidelity error minimisation. . References; ----------; 1. N Khaneja et. al. ; Optimal control of coupled spin dynamics: Design of NMR pulse sequences ; by gradient ascent algorithms. J. Magn. Reson. 172, 296â305 (2005).; 2. Shai Machnes et.al; DYNAMO - Dynamic Framework for Quantum Optimal Control; arXiv.1011.4874; 3. Doria, P., Calarco, T. & Montangero, S. ; Optimal Control Technique for Many-Body Quantum Dynamics. ; Phys. Rev. Lett. 106, 1â4 (2011).; 4. Caneva, T., Calarco, T. & Montangero, S. ; Chopped random-basis quantum optimization. ; Phys. Rev. A - At. Mol. Opt. Phys. 84, (2011). """"""; import numpy as np; import warnings. # QuTiP; from qutip import Qobj; import qutip.logging_utils as loggin",MatchSource.WIKI,docs/4.2/modules/qutip/control/pulseoptim.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/control/pulseoptim.html
https://qutip.org/docs/4.2/modules/qutip/control/pulseoptim.html:3633,Modifiability,variab,variables,3633,"time allowed for the evolution.; The functions minimise this fidelity error wrt the piecewise control; amplitudes in the timeslots. There are currently two quantum control pulse optmisations algorithms; implemented in this library. There are accessible through the methods; in this module. Both the algorithms use the scipy.optimize methods; to minimise the fidelity error with respect to to variables that define; the pulse. GRAPE; -----; The default algorithm (as it was implemented here first) is GRAPE; GRadient Ascent Pulse Engineering [1][2]. It uses a gradient based method such; as BFGS to minimise the fidelity error. This makes convergence very quick; when an exact gradient can be calculated, but this limits the factors that can; taken into account in the fidelity. CRAB; ----; The CRAB [3][4] algorithm was developed at the University of Ulm.; In full it is the Chopped RAndom Basis algorithm.; The main difference is that it reduces the number of optimisation variables ; by defining the control pulses by expansions of basis functions, ; where the variables are the coefficients. Typically a Fourier series is chosen, ; i.e. the variables are the Fourier coefficients. ; Therefore it does not need to compute an explicit gradient. ; By default it uses the Nelder-Mead method for fidelity error minimisation. . References; ----------; 1. N Khaneja et. al. ; Optimal control of coupled spin dynamics: Design of NMR pulse sequences ; by gradient ascent algorithms. J. Magn. Reson. 172, 296â305 (2005).; 2. Shai Machnes et.al; DYNAMO - Dynamic Framework for Quantum Optimal Control; arXiv.1011.4874; 3. Doria, P., Calarco, T. & Montangero, S. ; Optimal Control Technique for Many-Body Quantum Dynamics. ; Phys. Rev. Lett. 106, 1â4 (2011).; 4. Caneva, T., Calarco, T. & Montangero, S. ; Chopped random-basis quantum optimization. ; Phys. Rev. A - At. Mol. Opt. Phys. 84, (2011). """"""; import numpy as np; import warnings. # QuTiP; from qutip import Qobj; import qutip.logging_utils as loggin",MatchSource.WIKI,docs/4.2/modules/qutip/control/pulseoptim.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/control/pulseoptim.html
https://qutip.org/docs/4.2/modules/qutip/control/pulseoptim.html:3714,Modifiability,variab,variables,3714,"um control pulse optmisations algorithms; implemented in this library. There are accessible through the methods; in this module. Both the algorithms use the scipy.optimize methods; to minimise the fidelity error with respect to to variables that define; the pulse. GRAPE; -----; The default algorithm (as it was implemented here first) is GRAPE; GRadient Ascent Pulse Engineering [1][2]. It uses a gradient based method such; as BFGS to minimise the fidelity error. This makes convergence very quick; when an exact gradient can be calculated, but this limits the factors that can; taken into account in the fidelity. CRAB; ----; The CRAB [3][4] algorithm was developed at the University of Ulm.; In full it is the Chopped RAndom Basis algorithm.; The main difference is that it reduces the number of optimisation variables ; by defining the control pulses by expansions of basis functions, ; where the variables are the coefficients. Typically a Fourier series is chosen, ; i.e. the variables are the Fourier coefficients. ; Therefore it does not need to compute an explicit gradient. ; By default it uses the Nelder-Mead method for fidelity error minimisation. . References; ----------; 1. N Khaneja et. al. ; Optimal control of coupled spin dynamics: Design of NMR pulse sequences ; by gradient ascent algorithms. J. Magn. Reson. 172, 296â305 (2005).; 2. Shai Machnes et.al; DYNAMO - Dynamic Framework for Quantum Optimal Control; arXiv.1011.4874; 3. Doria, P., Calarco, T. & Montangero, S. ; Optimal Control Technique for Many-Body Quantum Dynamics. ; Phys. Rev. Lett. 106, 1â4 (2011).; 4. Caneva, T., Calarco, T. & Montangero, S. ; Chopped random-basis quantum optimization. ; Phys. Rev. A - At. Mol. Opt. Phys. 84, (2011). """"""; import numpy as np; import warnings. # QuTiP; from qutip import Qobj; import qutip.logging_utils as logging; logger = logging.get_logger(); # QuTiP control modules; import qutip.control.optimconfig as optimconfig; import qutip.control.dynamics as dynamics; import qut",MatchSource.WIKI,docs/4.2/modules/qutip/control/pulseoptim.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/control/pulseoptim.html
https://qutip.org/docs/4.2/modules/qutip/control/pulseoptim.html:17668,Modifiability,config,configuration,17668,"tim_method=optim_method, method_params=method_params,; dyn_type=dyn_type, dyn_params=dyn_params, ; prop_type=prop_type, prop_params=prop_params,; fid_type=fid_type, fid_params=fid_params,; init_pulse_type=init_pulse_type, init_pulse_params=init_pulse_params,; pulse_scaling=pulse_scaling, pulse_offset=pulse_offset,; ramping_pulse_type=ramping_pulse_type, ; ramping_pulse_params=ramping_pulse_params,; log_level=log_level, gen_stats=gen_stats). dyn = optim.dynamics. dyn.init_timeslots(); # Generate initial pulses for each control; init_amps = np.zeros([dyn.num_tslots, dyn.num_ctrls]); ; if alg == 'CRAB':; for j in range(dyn.num_ctrls):; pgen = optim.pulse_generator[j]; pgen.init_pulse(); init_amps[:, j] = pgen.gen_pulse(); else:; pgen = optim.pulse_generator; for j in range(dyn.num_ctrls):; init_amps[:, j] = pgen.gen_pulse(); ; # Initialise the starting amplitudes; dyn.initialize_controls(init_amps); ; if log_level <= logging.INFO:; msg = ""System configuration:\n""; dg_name = ""dynamics generator""; if dyn_type == 'UNIT':; dg_name = ""Hamiltonian""; if dyn.time_depend_drift:; msg += ""Initial drift {}:\n"".format(dg_name); msg += str(dyn.drift_dyn_gen[0]); else:; msg += ""Drift {}:\n"".format(dg_name); msg += str(dyn.drift_dyn_gen); for j in range(dyn.num_ctrls):; msg += ""\nControl {} {}:\n"".format(j+1, dg_name); msg += str(dyn.ctrl_dyn_gen[j]); msg += ""\nInitial state / operator:\n""; msg += str(dyn.initial); msg += ""\nTarget state / operator:\n""; msg += str(dyn.target); logger.info(msg). if out_file_ext is not None:; # Save initial amplitudes to a text file; pulsefile = ""ctrl_amps_initial_"" + out_file_ext; dyn.save_amps(pulsefile); if log_level <= logging.INFO:; logger.info(""Initial amplitudes output to file: "" + pulsefile). # Start the optimisation; result = optim.run_optimization(). if out_file_ext is not None:; # Save final amplitudes to a text file; pulsefile = ""ctrl_amps_final_"" + out_file_ext; dyn.save_amps(pulsefile); if log_level <= logging.INFO:; logger.info(""Final amp",MatchSource.WIKI,docs/4.2/modules/qutip/control/pulseoptim.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/control/pulseoptim.html
https://qutip.org/docs/4.2/modules/qutip/control/pulseoptim.html:30506,Modifiability,variab,variables,30506,"ft, ctrls, initial, target,; num_tslots=None, evo_time=None, tau=None,; amp_lbound=None, amp_ubound=None,; fid_err_targ=1e-5,; max_iter=500, max_wall_time=180,; alg_params=None,; num_coeffs=None, init_coeff_scaling=1.0, ; optim_params=None, optim_method='fmin', method_params=None,; dyn_type='GEN_MAT', dyn_params=None,; prop_type='DEF', prop_params=None,; fid_type='DEF', fid_params=None,; tslot_type='DEF', tslot_params=None,; guess_pulse_type=None, guess_pulse_params=None,; guess_pulse_scaling=1.0, guess_pulse_offset=0.0,; guess_pulse_action='MODULATE', ; ramping_pulse_type=None, ramping_pulse_params=None,; log_level=logging.NOTSET, out_file_ext=None, gen_stats=False):; """"""; Optimise a control pulse to minimise the fidelity error.; The dynamics of the system in any given timeslot are governed; by the combined dynamics generator,; i.e. the sum of the drift+ctrl_amp[j]*ctrls[j]; The control pulse is an [n_ts, n_ctrls] array of piecewise amplitudes.; The CRAB algorithm uses basis function coefficents as the variables to; optimise. It does NOT use any gradient function.; A multivariable optimisation algorithm attempts to determines the; optimal values for the control pulse to minimise the fidelity error; The fidelity error is some measure of distance of the system evolution; from the given target evolution in the time allowed for the evolution. Parameters; ----------; drift : Qobj or list of Qobj; the underlying dynamics generator of the system; can provide list (of length num_tslots) for time dependent drift. ctrls : List of Qobj or array like [num_tslots, evo_time]; a list of control dynamics generators. These are scaled by; the amplitudes to alter the overall dynamics; Array like imput can be provided for time dependent control generators. initial : Qobj; starting point for the evolution.; Typically the identity matrix. target : Qobj; target transformation, e.g. gate or state, for the time evolution. num_tslots : integer or None; number of timeslots.; None implies that",MatchSource.WIKI,docs/4.2/modules/qutip/control/pulseoptim.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/control/pulseoptim.html
https://qutip.org/docs/4.2/modules/qutip/control/pulseoptim.html:33426,Modifiability,variab,variable,33426,"um allowed elapsed time for the optimisation algorithm. alg_params : Dictionary; options that are specific to the algorithm see above; ; optim_params : Dictionary; The key value pairs are the attribute name and value; used to set attribute values; Note: attributes are created if they do not exist already,; and are overwritten if they do.; Note: method_params are applied afterwards and so may override these. coeff_scaling : float; Linear scale factor for the random basis coefficients; By default these range from -1.0 to 1.0; Note this is overridden by alg_params (if given there); ; num_coeffs : integer; Number of coefficients used for each basis function; Note this is calculated automatically based on the dimension of the; dynamics if not given. It is crucial to the performane of the ; algorithm that it is set as low as possible, while still giving; high enough frequencies.; Note this is overridden by alg_params (if given there); ; optim_method : string; Multi-variable optimisation method; The only tested options are 'fmin' and 'Nelder-mead'; In theory any non-gradient method implemented in ; scipy.optimize.mininize could be used. method_params : dict; Parameters for the optim_method. ; Note that where there is an attribute of the; Optimizer object or the termination_conditions matching the key ; that attribute. Otherwise, and in some case also, ; they are assumed to be method_options; for the scipy.optimize.minimize method.; The commonly used parameter are:; xtol - limit on variable change for convergence; ftol - limit on fidelity error change for convergence; ; dyn_type : string; Dynamics type, i.e. the type of matrix used to describe; the dynamics. Options are UNIT, GEN_MAT, SYMPL; (see Dynamics classes for details); ; dyn_params : dict; Parameters for the Dynamics object; The key value pairs are assumed to be attribute name value pairs; They applied after the object is created. prop_type : string; Propagator type i.e. the method used to calculate the; propagtors ",MatchSource.WIKI,docs/4.2/modules/qutip/control/pulseoptim.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/control/pulseoptim.html
https://qutip.org/docs/4.2/modules/qutip/control/pulseoptim.html:33951,Modifiability,variab,variable,33951,"his is overridden by alg_params (if given there); ; num_coeffs : integer; Number of coefficients used for each basis function; Note this is calculated automatically based on the dimension of the; dynamics if not given. It is crucial to the performane of the ; algorithm that it is set as low as possible, while still giving; high enough frequencies.; Note this is overridden by alg_params (if given there); ; optim_method : string; Multi-variable optimisation method; The only tested options are 'fmin' and 'Nelder-mead'; In theory any non-gradient method implemented in ; scipy.optimize.mininize could be used. method_params : dict; Parameters for the optim_method. ; Note that where there is an attribute of the; Optimizer object or the termination_conditions matching the key ; that attribute. Otherwise, and in some case also, ; they are assumed to be method_options; for the scipy.optimize.minimize method.; The commonly used parameter are:; xtol - limit on variable change for convergence; ftol - limit on fidelity error change for convergence; ; dyn_type : string; Dynamics type, i.e. the type of matrix used to describe; the dynamics. Options are UNIT, GEN_MAT, SYMPL; (see Dynamics classes for details); ; dyn_params : dict; Parameters for the Dynamics object; The key value pairs are assumed to be attribute name value pairs; They applied after the object is created. prop_type : string; Propagator type i.e. the method used to calculate the; propagtors and propagtor gradient for each timeslot; options are DEF, APPROX, DIAG, FRECHET, AUG_MAT; DEF will use the default for the specific dyn_type; (see PropagatorComputer classes for details). prop_params : dict; Parameters for the PropagatorComputer object; The key value pairs are assumed to be attribute name value pairs; They applied after the object is created; ; fid_type : string; Fidelity error (and fidelity error gradient) computation method; Options are DEF, UNIT, TRACEDIFF, TD_APPROX; DEF will use the default for the specific ",MatchSource.WIKI,docs/4.2/modules/qutip/control/pulseoptim.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/control/pulseoptim.html
https://qutip.org/docs/4.2/modules/qutip/control/pulseoptim.html:41259,Modifiability,variab,variables,41259,"=None,; num_coeffs=None, init_coeff_scaling=1.0, ; optim_params=None, optim_method='fmin', method_params=None,; phase_option='PSU', ; dyn_params=None, prop_params=None, fid_params=None,; tslot_type='DEF', tslot_params=None,; guess_pulse_type=None, guess_pulse_params=None,; guess_pulse_scaling=1.0, guess_pulse_offset=0.0,; guess_pulse_action='MODULATE', ; ramping_pulse_type=None, ramping_pulse_params=None,; log_level=logging.NOTSET, out_file_ext=None, gen_stats=False):; """"""; Optimise a control pulse to minimise the fidelity error, assuming that; the dynamics of the system are generated by unitary operators.; This function is simply a wrapper for optimize_pulse, where the; appropriate options for unitary dynamics are chosen and the parameter; names are in the format familiar to unitary dynamics; The dynamics of the system in any given timeslot are governed; by the combined Hamiltonian,; i.e. the sum of the H_d + ctrl_amp[j]*H_c[j]; The control pulse is an [n_ts, n_ctrls] array of piecewise amplitudes; ; The CRAB algorithm uses basis function coefficents as the variables to; optimise. It does NOT use any gradient function.; A multivariable optimisation algorithm attempts to determines the; optimal values for the control pulse to minimise the fidelity error; The fidelity error is some measure of distance of the system evolution; from the given target evolution in the time allowed for the evolution. Parameters; ----------. H_d : Qobj or list of Qobj; Drift (aka system) the underlying Hamiltonian of the system; can provide list (of length num_tslots) for time dependent drift. H_c : List of Qobj or array like [num_tslots, evo_time]; a list of control Hamiltonians. These are scaled by; the amplitudes to alter the overall dynamics; Array like imput can be provided for time dependent control generators. U_0 : Qobj; starting point for the evolution.; Typically the identity matrix. U_targ : Qobj; target transformation, e.g. gate or state, for the time evolution. num_tslots : in",MatchSource.WIKI,docs/4.2/modules/qutip/control/pulseoptim.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/control/pulseoptim.html
https://qutip.org/docs/4.2/modules/qutip/control/pulseoptim.html:44176,Modifiability,variab,variable,44176,"um allowed elapsed time for the optimisation algorithm. alg_params : Dictionary; options that are specific to the algorithm see above; ; optim_params : Dictionary; The key value pairs are the attribute name and value; used to set attribute values; Note: attributes are created if they do not exist already,; and are overwritten if they do.; Note: method_params are applied afterwards and so may override these. coeff_scaling : float; Linear scale factor for the random basis coefficients; By default these range from -1.0 to 1.0; Note this is overridden by alg_params (if given there); ; num_coeffs : integer; Number of coefficients used for each basis function; Note this is calculated automatically based on the dimension of the; dynamics if not given. It is crucial to the performane of the ; algorithm that it is set as low as possible, while still giving; high enough frequencies.; Note this is overridden by alg_params (if given there); ; optim_method : string; Multi-variable optimisation method; The only tested options are 'fmin' and 'Nelder-mead'; In theory any non-gradient method implemented in ; scipy.optimize.mininize could be used. method_params : dict; Parameters for the optim_method. ; Note that where there is an attribute of the; Optimizer object or the termination_conditions matching the key ; that attribute. Otherwise, and in some case also, ; they are assumed to be method_options; for the scipy.optimize.minimize method.; The commonly used parameter are:; xtol - limit on variable change for convergence; ftol - limit on fidelity error change for convergence. phase_option : string; determines how global phase is treated in fidelity; calculations (fid_type='UNIT' only). Options:; PSU - global phase ignored; SU - global phase included. dyn_params : dict; Parameters for the Dynamics object; The key value pairs are assumed to be attribute name value pairs; They applied after the object is created. prop_params : dict; Parameters for the PropagatorComputer object; The ke",MatchSource.WIKI,docs/4.2/modules/qutip/control/pulseoptim.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/control/pulseoptim.html
https://qutip.org/docs/4.2/modules/qutip/control/pulseoptim.html:44701,Modifiability,variab,variable,44701," -1.0 to 1.0; Note this is overridden by alg_params (if given there); ; num_coeffs : integer; Number of coefficients used for each basis function; Note this is calculated automatically based on the dimension of the; dynamics if not given. It is crucial to the performane of the ; algorithm that it is set as low as possible, while still giving; high enough frequencies.; Note this is overridden by alg_params (if given there); ; optim_method : string; Multi-variable optimisation method; The only tested options are 'fmin' and 'Nelder-mead'; In theory any non-gradient method implemented in ; scipy.optimize.mininize could be used. method_params : dict; Parameters for the optim_method. ; Note that where there is an attribute of the; Optimizer object or the termination_conditions matching the key ; that attribute. Otherwise, and in some case also, ; they are assumed to be method_options; for the scipy.optimize.minimize method.; The commonly used parameter are:; xtol - limit on variable change for convergence; ftol - limit on fidelity error change for convergence. phase_option : string; determines how global phase is treated in fidelity; calculations (fid_type='UNIT' only). Options:; PSU - global phase ignored; SU - global phase included. dyn_params : dict; Parameters for the Dynamics object; The key value pairs are assumed to be attribute name value pairs; They applied after the object is created. prop_params : dict; Parameters for the PropagatorComputer object; The key value pairs are assumed to be attribute name value pairs; They applied after the object is created. fid_params : dict; Parameters for the FidelityComputer object; The key value pairs are assumed to be attribute name value pairs; They applied after the object is created; ; tslot_type : string; Method for computing the dynamics generators, propagators and ; evolution in the timeslots.; Options: DEF, UPDATE_ALL, DYNAMIC; UPDATE_ALL is the only one that currently works; (See TimeslotComputer classes for details); ",MatchSource.WIKI,docs/4.2/modules/qutip/control/pulseoptim.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/control/pulseoptim.html
https://qutip.org/docs/4.2/modules/qutip/control/pulseoptim.html:51179,Modifiability,config,configuration,51179,"_file_ext, gen_stats=gen_stats). [docs]def create_pulse_optimizer(; drift, ctrls, initial, target,; num_tslots=None, evo_time=None, tau=None,; amp_lbound=None, amp_ubound=None,; fid_err_targ=1e-10, min_grad=1e-10,; max_iter=500, max_wall_time=180,; alg='GRAPE', alg_params=None,; optim_params=None, optim_method='DEF', method_params=None,; optim_alg=None, max_metric_corr=None, accuracy_factor=None,; dyn_type='GEN_MAT', dyn_params=None,; prop_type='DEF', prop_params=None,; fid_type='DEF', fid_params=None,; phase_option=None, fid_err_scale_factor=None,; tslot_type='DEF', tslot_params=None,; amp_update_mode=None,; init_pulse_type='DEF', init_pulse_params=None,; pulse_scaling=1.0, pulse_offset=0.0,; ramping_pulse_type=None, ramping_pulse_params=None,; log_level=logging.NOTSET, gen_stats=False):. """"""; Generate the objects of the appropriate subclasses; required for the pulse optmisation based on the parameters given; Note this method may be preferable to calling optimize_pulse; if more detailed configuration is required before running the; optmisation algorthim, or the algorithm will be run many times,; for instances when trying to finding global the optimum or; minimum time optimisation. Parameters; ----------; drift : Qobj or list of Qobj; the underlying dynamics generator of the system; can provide list (of length num_tslots) for time dependent drift. ctrls : List of Qobj or array like [num_tslots, evo_time]; a list of control dynamics generators. These are scaled by; the amplitudes to alter the overall dynamics; Array like imput can be provided for time dependent control generators. initial : Qobj; starting point for the evolution.; Typically the identity matrix. target : Qobj; target transformation, e.g. gate or state, for the time evolution. num_tslots : integer or None; number of timeslots.; None implies that timeslots will be given in the tau array. evo_time : float or None; total time for the evolution; None implies that timeslots will be given in the tau array. t",MatchSource.WIKI,docs/4.2/modules/qutip/control/pulseoptim.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/control/pulseoptim.html
https://qutip.org/docs/4.2/modules/qutip/control/pulseoptim.html:68937,Modifiability,config,config,68937,"_params); guess_pulse_action = init_pulse_params.get('pulse_action'). optim.pulse_generator = []; for j in range(n_ctrls):; crab_pgen = pulsegen.PulseGenCrabFourier(; dyn=dyn, num_coeffs=num_coeffs); if init_coeff_scaling is not None:; crab_pgen.scaling = init_coeff_scaling; if isinstance(crab_pulse_params, dict):; crab_pgen.apply_params(crab_pulse_params); ; lb = None; if amp_lbound:; if isinstance(amp_lbound, list):; try:; lb = amp_lbound[j]; except:; lb = amp_lbound[-1]; else:; lb = amp_lbound; ub = None; if amp_ubound:; if isinstance(amp_ubound, list):; try:; ub = amp_ubound[j]; except:; ub = amp_ubound[-1]; else:; ub = amp_ubound; crab_pgen.lbound = lb; crab_pgen.ubound = ub; ; if guess_pulse_type:; guess_pgen.lbound = lb; guess_pgen.ubound = ub; crab_pgen.guess_pulse = guess_pgen.gen_pulse(); if guess_pulse_action:; crab_pgen.guess_pulse_action = guess_pulse_action; ; if ramping_pgen:; crab_pgen.ramping_pulse = ramping_pgen.gen_pulse(). optim.pulse_generator.append(crab_pgen); #This is just for the debug message now; pgen = optim.pulse_generator[0]; ; else:; # Create a pulse generator of the type specified; pgen = pulsegen.create_pulse_gen(pulse_type=init_pulse_type, dyn=dyn,; pulse_params=init_pulse_params); pgen.scaling = pulse_scaling; pgen.offset = pulse_offset; pgen.lbound = amp_lbound; pgen.ubound = amp_ubound. optim.pulse_generator = pgen. if log_level <= logging.DEBUG:; logger.debug(; ""Optimisation config summary...\n""; "" object classes:\n""; "" optimizer: "" + optim.__class__.__name__ +; ""\n dynamics: "" + dyn.__class__.__name__ +; ""\n tslotcomp: "" + dyn.tslot_computer.__class__.__name__ +; ""\n fidcomp: "" + dyn.fid_computer.__class__.__name__ +; ""\n propcomp: "" + dyn.prop_computer.__class__.__name__ +; ""\n pulsegen: "" + pgen.__class__.__name__). return optim. Â© Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, and A.L. Grimsmo.; Last updated on Jan 17, 2018. . Built with Sphinx using a theme provided by Read the Docs. . ",MatchSource.WIKI,docs/4.2/modules/qutip/control/pulseoptim.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/control/pulseoptim.html
https://qutip.org/docs/4.2/modules/qutip/control/pulseoptim.html:2894,Performance,optimiz,optimize,2894,"F THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.; ###############################################################################. # @author: Alexander Pitchford; # @email1: agp1@aber.ac.uk; # @email2: alex.pitchford@gmail.com; # @organization: Aberystwyth University; # @supervisor: Daniel Burgarth. """"""; Wrapper functions that will manage the creation of the objects,; build the configuration, and execute the algorithm required to optimise; a set of ctrl pulses for a given (quantum) system.; The fidelity error is some measure of distance of the system evolution; from the given target evolution in the time allowed for the evolution.; The functions minimise this fidelity error wrt the piecewise control; amplitudes in the timeslots. There are currently two quantum control pulse optmisations algorithms; implemented in this library. There are accessible through the methods; in this module. Both the algorithms use the scipy.optimize methods; to minimise the fidelity error with respect to to variables that define; the pulse. GRAPE; -----; The default algorithm (as it was implemented here first) is GRAPE; GRadient Ascent Pulse Engineering [1][2]. It uses a gradient based method such; as BFGS to minimise the fidelity error. This makes convergence very quick; when an exact gradient can be calculated, but this limits the factors that can; taken into account in the fidelity. CRAB; ----; The CRAB [3][4] algorithm was developed at the University of Ulm.; In full it is the Chopped RAndom Basis algorithm.; The main difference is that it reduces the number of optimisation variables ; by defining the control pulses by expansions of basis functions, ; where the variables are the coefficients. Typically a Fourier series is chosen, ; i.e. the variables are the Fourier coefficients. ; Therefore it does not need to compute an explicit gradient. ; By default it uses the Nelder-Mead method for fidelity error minimisation. . References; ----------; 1. N Khaneja et. al. ; Opt",MatchSource.WIKI,docs/4.2/modules/qutip/control/pulseoptim.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/control/pulseoptim.html
https://qutip.org/docs/4.2/modules/qutip/control/pulseoptim.html:4396,Performance,optimiz,optimization,4396,"was developed at the University of Ulm.; In full it is the Chopped RAndom Basis algorithm.; The main difference is that it reduces the number of optimisation variables ; by defining the control pulses by expansions of basis functions, ; where the variables are the coefficients. Typically a Fourier series is chosen, ; i.e. the variables are the Fourier coefficients. ; Therefore it does not need to compute an explicit gradient. ; By default it uses the Nelder-Mead method for fidelity error minimisation. . References; ----------; 1. N Khaneja et. al. ; Optimal control of coupled spin dynamics: Design of NMR pulse sequences ; by gradient ascent algorithms. J. Magn. Reson. 172, 296â305 (2005).; 2. Shai Machnes et.al; DYNAMO - Dynamic Framework for Quantum Optimal Control; arXiv.1011.4874; 3. Doria, P., Calarco, T. & Montangero, S. ; Optimal Control Technique for Many-Body Quantum Dynamics. ; Phys. Rev. Lett. 106, 1â4 (2011).; 4. Caneva, T., Calarco, T. & Montangero, S. ; Chopped random-basis quantum optimization. ; Phys. Rev. A - At. Mol. Opt. Phys. 84, (2011). """"""; import numpy as np; import warnings. # QuTiP; from qutip import Qobj; import qutip.logging_utils as logging; logger = logging.get_logger(); # QuTiP control modules; import qutip.control.optimconfig as optimconfig; import qutip.control.dynamics as dynamics; import qutip.control.termcond as termcond; import qutip.control.optimizer as optimizer; import qutip.control.stats as stats; import qutip.control.errors as errors; import qutip.control.fidcomp as fidcomp; import qutip.control.propcomp as propcomp; import qutip.control.pulsegen as pulsegen; #import qutip.control.pulsegencrab as pulsegencrab. warnings.simplefilter('always', DeprecationWarning) #turn off filter ; def _param_deprecation(message, stacklevel=3):; """"""; Issue deprecation warning; Using stacklevel=3 will ensure message refers the function; calling with the deprecated parameter,; """"""; warnings.warn(message, DeprecationWarning, stacklevel=stacklevel); ",MatchSource.WIKI,docs/4.2/modules/qutip/control/pulseoptim.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/control/pulseoptim.html
https://qutip.org/docs/4.2/modules/qutip/control/pulseoptim.html:4785,Performance,optimiz,optimizer,4785,"it gradient. ; By default it uses the Nelder-Mead method for fidelity error minimisation. . References; ----------; 1. N Khaneja et. al. ; Optimal control of coupled spin dynamics: Design of NMR pulse sequences ; by gradient ascent algorithms. J. Magn. Reson. 172, 296â305 (2005).; 2. Shai Machnes et.al; DYNAMO - Dynamic Framework for Quantum Optimal Control; arXiv.1011.4874; 3. Doria, P., Calarco, T. & Montangero, S. ; Optimal Control Technique for Many-Body Quantum Dynamics. ; Phys. Rev. Lett. 106, 1â4 (2011).; 4. Caneva, T., Calarco, T. & Montangero, S. ; Chopped random-basis quantum optimization. ; Phys. Rev. A - At. Mol. Opt. Phys. 84, (2011). """"""; import numpy as np; import warnings. # QuTiP; from qutip import Qobj; import qutip.logging_utils as logging; logger = logging.get_logger(); # QuTiP control modules; import qutip.control.optimconfig as optimconfig; import qutip.control.dynamics as dynamics; import qutip.control.termcond as termcond; import qutip.control.optimizer as optimizer; import qutip.control.stats as stats; import qutip.control.errors as errors; import qutip.control.fidcomp as fidcomp; import qutip.control.propcomp as propcomp; import qutip.control.pulsegen as pulsegen; #import qutip.control.pulsegencrab as pulsegencrab. warnings.simplefilter('always', DeprecationWarning) #turn off filter ; def _param_deprecation(message, stacklevel=3):; """"""; Issue deprecation warning; Using stacklevel=3 will ensure message refers the function; calling with the deprecated parameter,; """"""; warnings.warn(message, DeprecationWarning, stacklevel=stacklevel); ; def _upper_safe(s):; try:; s = s.upper(); except:; pass; return s; ; [docs]def optimize_pulse(; drift, ctrls, initial, target,; num_tslots=None, evo_time=None, tau=None,; amp_lbound=None, amp_ubound=None,; fid_err_targ=1e-10, min_grad=1e-10,; max_iter=500, max_wall_time=180,; alg='GRAPE', alg_params=None,; optim_params=None, optim_method='DEF', method_params=None,; optim_alg=None, max_metric_corr=None, accuracy_",MatchSource.WIKI,docs/4.2/modules/qutip/control/pulseoptim.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/control/pulseoptim.html
https://qutip.org/docs/4.2/modules/qutip/control/pulseoptim.html:4798,Performance,optimiz,optimizer,4798,"it gradient. ; By default it uses the Nelder-Mead method for fidelity error minimisation. . References; ----------; 1. N Khaneja et. al. ; Optimal control of coupled spin dynamics: Design of NMR pulse sequences ; by gradient ascent algorithms. J. Magn. Reson. 172, 296â305 (2005).; 2. Shai Machnes et.al; DYNAMO - Dynamic Framework for Quantum Optimal Control; arXiv.1011.4874; 3. Doria, P., Calarco, T. & Montangero, S. ; Optimal Control Technique for Many-Body Quantum Dynamics. ; Phys. Rev. Lett. 106, 1â4 (2011).; 4. Caneva, T., Calarco, T. & Montangero, S. ; Chopped random-basis quantum optimization. ; Phys. Rev. A - At. Mol. Opt. Phys. 84, (2011). """"""; import numpy as np; import warnings. # QuTiP; from qutip import Qobj; import qutip.logging_utils as logging; logger = logging.get_logger(); # QuTiP control modules; import qutip.control.optimconfig as optimconfig; import qutip.control.dynamics as dynamics; import qutip.control.termcond as termcond; import qutip.control.optimizer as optimizer; import qutip.control.stats as stats; import qutip.control.errors as errors; import qutip.control.fidcomp as fidcomp; import qutip.control.propcomp as propcomp; import qutip.control.pulsegen as pulsegen; #import qutip.control.pulsegencrab as pulsegencrab. warnings.simplefilter('always', DeprecationWarning) #turn off filter ; def _param_deprecation(message, stacklevel=3):; """"""; Issue deprecation warning; Using stacklevel=3 will ensure message refers the function; calling with the deprecated parameter,; """"""; warnings.warn(message, DeprecationWarning, stacklevel=stacklevel); ; def _upper_safe(s):; try:; s = s.upper(); except:; pass; return s; ; [docs]def optimize_pulse(; drift, ctrls, initial, target,; num_tslots=None, evo_time=None, tau=None,; amp_lbound=None, amp_ubound=None,; fid_err_targ=1e-10, min_grad=1e-10,; max_iter=500, max_wall_time=180,; alg='GRAPE', alg_params=None,; optim_params=None, optim_method='DEF', method_params=None,; optim_alg=None, max_metric_corr=None, accuracy_",MatchSource.WIKI,docs/4.2/modules/qutip/control/pulseoptim.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/control/pulseoptim.html
https://qutip.org/docs/4.2/modules/qutip/control/pulseoptim.html:9244,Performance,optimiz,optimize,9244," error target. Pulse optimisation will; terminate when the fidelity error falls below this value. mim_grad : float; Minimum gradient. When the sum of the squares of the; gradients wrt to the control amplitudes falls below this; value, the optimisation terminates, assuming local minima. max_iter : integer; Maximum number of iterations of the optimisation algorithm. max_wall_time : float; Maximum allowed elapsed time for the optimisation algorithm. alg : string; Algorithm to use in pulse optimisation.; Options are:; ; 'GRAPE' (default) - GRadient Ascent Pulse Engineering; 'CRAB' - Chopped RAndom Basis. alg_params : Dictionary; options that are specific to the algorithm see above; ; optim_params : Dictionary; The key value pairs are the attribute name and value; used to set attribute values; Note: attributes are created if they do not exist already,; and are overwritten if they do.; Note: method_params are applied afterwards and so may override these; ; optim_method : string; a scipy.optimize.minimize method that will be used to optimise; the pulse for minimum fidelity error; Note that FMIN, FMIN_BFGS & FMIN_L_BFGS_B will all result; in calling these specific scipy.optimize methods; Note the LBFGSB is equivalent to FMIN_L_BFGS_B for backwards ; capatibility reasons.; Supplying DEF will given alg dependent result:; GRAPE - Default optim_method is FMIN_L_BFGS_B; CRAB - Default optim_method is FMIN; ; method_params : dict; Parameters for the optim_method. ; Note that where there is an attribute of the; Optimizer object or the termination_conditions matching the key ; that attribute. Otherwise, and in some case also, ; they are assumed to be method_options; for the scipy.optimize.minimize method. ; ; optim_alg : string; Deprecated. Use optim_method. max_metric_corr : integer; Deprecated. Use method_params instead. accuracy_factor : float; Deprecated. Use method_params instead. dyn_type : string; Dynamics type, i.e. the type of matrix used to describe; the dynamics. Options ",MatchSource.WIKI,docs/4.2/modules/qutip/control/pulseoptim.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/control/pulseoptim.html
https://qutip.org/docs/4.2/modules/qutip/control/pulseoptim.html:9429,Performance,optimiz,optimize,9429,"e, the optimisation terminates, assuming local minima. max_iter : integer; Maximum number of iterations of the optimisation algorithm. max_wall_time : float; Maximum allowed elapsed time for the optimisation algorithm. alg : string; Algorithm to use in pulse optimisation.; Options are:; ; 'GRAPE' (default) - GRadient Ascent Pulse Engineering; 'CRAB' - Chopped RAndom Basis. alg_params : Dictionary; options that are specific to the algorithm see above; ; optim_params : Dictionary; The key value pairs are the attribute name and value; used to set attribute values; Note: attributes are created if they do not exist already,; and are overwritten if they do.; Note: method_params are applied afterwards and so may override these; ; optim_method : string; a scipy.optimize.minimize method that will be used to optimise; the pulse for minimum fidelity error; Note that FMIN, FMIN_BFGS & FMIN_L_BFGS_B will all result; in calling these specific scipy.optimize methods; Note the LBFGSB is equivalent to FMIN_L_BFGS_B for backwards ; capatibility reasons.; Supplying DEF will given alg dependent result:; GRAPE - Default optim_method is FMIN_L_BFGS_B; CRAB - Default optim_method is FMIN; ; method_params : dict; Parameters for the optim_method. ; Note that where there is an attribute of the; Optimizer object or the termination_conditions matching the key ; that attribute. Otherwise, and in some case also, ; they are assumed to be method_options; for the scipy.optimize.minimize method. ; ; optim_alg : string; Deprecated. Use optim_method. max_metric_corr : integer; Deprecated. Use method_params instead. accuracy_factor : float; Deprecated. Use method_params instead. dyn_type : string; Dynamics type, i.e. the type of matrix used to describe; the dynamics. Options are UNIT, GEN_MAT, SYMPL; (see Dynamics classes for details); ; dyn_params : dict; Parameters for the Dynamics object; The key value pairs are assumed to be attribute name value pairs; They applied after the object is created. prop",MatchSource.WIKI,docs/4.2/modules/qutip/control/pulseoptim.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/control/pulseoptim.html
https://qutip.org/docs/4.2/modules/qutip/control/pulseoptim.html:9941,Performance,optimiz,optimize,9941,"rams : Dictionary; The key value pairs are the attribute name and value; used to set attribute values; Note: attributes are created if they do not exist already,; and are overwritten if they do.; Note: method_params are applied afterwards and so may override these; ; optim_method : string; a scipy.optimize.minimize method that will be used to optimise; the pulse for minimum fidelity error; Note that FMIN, FMIN_BFGS & FMIN_L_BFGS_B will all result; in calling these specific scipy.optimize methods; Note the LBFGSB is equivalent to FMIN_L_BFGS_B for backwards ; capatibility reasons.; Supplying DEF will given alg dependent result:; GRAPE - Default optim_method is FMIN_L_BFGS_B; CRAB - Default optim_method is FMIN; ; method_params : dict; Parameters for the optim_method. ; Note that where there is an attribute of the; Optimizer object or the termination_conditions matching the key ; that attribute. Otherwise, and in some case also, ; they are assumed to be method_options; for the scipy.optimize.minimize method. ; ; optim_alg : string; Deprecated. Use optim_method. max_metric_corr : integer; Deprecated. Use method_params instead. accuracy_factor : float; Deprecated. Use method_params instead. dyn_type : string; Dynamics type, i.e. the type of matrix used to describe; the dynamics. Options are UNIT, GEN_MAT, SYMPL; (see Dynamics classes for details); ; dyn_params : dict; Parameters for the Dynamics object; The key value pairs are assumed to be attribute name value pairs; They applied after the object is created. prop_type : string; Propagator type i.e. the method used to calculate the; propagtors and propagtor gradient for each timeslot; options are DEF, APPROX, DIAG, FRECHET, AUG_MAT; DEF will use the default for the specific dyn_type; (see PropagatorComputer classes for details). prop_params : dict; Parameters for the PropagatorComputer object; The key value pairs are assumed to be attribute name value pairs; They applied after the object is created; ; fid_type : string; ",MatchSource.WIKI,docs/4.2/modules/qutip/control/pulseoptim.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/control/pulseoptim.html
https://qutip.org/docs/4.2/modules/qutip/control/pulseoptim.html:22767,Performance,optimiz,optimize,22767,"ty error target. Pulse optimisation will; terminate when the fidelity error falls below this value. mim_grad : float; Minimum gradient. When the sum of the squares of the; gradients wrt to the control amplitudes falls below this; value, the optimisation terminates, assuming local minima. max_iter : integer; Maximum number of iterations of the optimisation algorithm. max_wall_time : float; Maximum allowed elapsed time for the optimisation algorithm. alg : string; Algorithm to use in pulse optimisation.; Options are:; 'GRAPE' (default) - GRadient Ascent Pulse Engineering; 'CRAB' - Chopped RAndom Basis. alg_params : Dictionary; options that are specific to the algorithm see above; ; optim_params : Dictionary; The key value pairs are the attribute name and value; used to set attribute values; Note: attributes are created if they do not exist already,; and are overwritten if they do.; Note: method_params are applied afterwards and so may override these; ; optim_method : string; a scipy.optimize.minimize method that will be used to optimise; the pulse for minimum fidelity error; Note that FMIN, FMIN_BFGS & FMIN_L_BFGS_B will all result; in calling these specific scipy.optimize methods; Note the LBFGSB is equivalent to FMIN_L_BFGS_B for backwards ; capatibility reasons.; Supplying DEF will given alg dependent result:; ; GRAPE - Default optim_method is FMIN_L_BFGS_B; CRAB - Default optim_method is FMIN; ; method_params : dict; Parameters for the optim_method. ; Note that where there is an attribute of the; Optimizer object or the termination_conditions matching the key ; that attribute. Otherwise, and in some case also, ; they are assumed to be method_options; for the scipy.optimize.minimize method. ; ; optim_alg : string; Deprecated. Use optim_method. max_metric_corr : integer; Deprecated. Use method_params instead. accuracy_factor : float; Deprecated. Use method_params instead. phase_option : string; determines how global phase is treated in fidelity; calculations (fid_typ",MatchSource.WIKI,docs/4.2/modules/qutip/control/pulseoptim.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/control/pulseoptim.html
https://qutip.org/docs/4.2/modules/qutip/control/pulseoptim.html:22952,Performance,optimiz,optimize,22952,"lue, the optimisation terminates, assuming local minima. max_iter : integer; Maximum number of iterations of the optimisation algorithm. max_wall_time : float; Maximum allowed elapsed time for the optimisation algorithm. alg : string; Algorithm to use in pulse optimisation.; Options are:; 'GRAPE' (default) - GRadient Ascent Pulse Engineering; 'CRAB' - Chopped RAndom Basis. alg_params : Dictionary; options that are specific to the algorithm see above; ; optim_params : Dictionary; The key value pairs are the attribute name and value; used to set attribute values; Note: attributes are created if they do not exist already,; and are overwritten if they do.; Note: method_params are applied afterwards and so may override these; ; optim_method : string; a scipy.optimize.minimize method that will be used to optimise; the pulse for minimum fidelity error; Note that FMIN, FMIN_BFGS & FMIN_L_BFGS_B will all result; in calling these specific scipy.optimize methods; Note the LBFGSB is equivalent to FMIN_L_BFGS_B for backwards ; capatibility reasons.; Supplying DEF will given alg dependent result:; ; GRAPE - Default optim_method is FMIN_L_BFGS_B; CRAB - Default optim_method is FMIN; ; method_params : dict; Parameters for the optim_method. ; Note that where there is an attribute of the; Optimizer object or the termination_conditions matching the key ; that attribute. Otherwise, and in some case also, ; they are assumed to be method_options; for the scipy.optimize.minimize method. ; ; optim_alg : string; Deprecated. Use optim_method. max_metric_corr : integer; Deprecated. Use method_params instead. accuracy_factor : float; Deprecated. Use method_params instead. phase_option : string; determines how global phase is treated in fidelity; calculations (fid_type='UNIT' only). Options:; ; PSU - global phase ignored; SU - global phase included. dyn_params : dict; Parameters for the Dynamics object; The key value pairs are assumed to be attribute name value pairs; They applied after the obj",MatchSource.WIKI,docs/4.2/modules/qutip/control/pulseoptim.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/control/pulseoptim.html
https://qutip.org/docs/4.2/modules/qutip/control/pulseoptim.html:23466,Performance,optimiz,optimize,23466,"ms : Dictionary; The key value pairs are the attribute name and value; used to set attribute values; Note: attributes are created if they do not exist already,; and are overwritten if they do.; Note: method_params are applied afterwards and so may override these; ; optim_method : string; a scipy.optimize.minimize method that will be used to optimise; the pulse for minimum fidelity error; Note that FMIN, FMIN_BFGS & FMIN_L_BFGS_B will all result; in calling these specific scipy.optimize methods; Note the LBFGSB is equivalent to FMIN_L_BFGS_B for backwards ; capatibility reasons.; Supplying DEF will given alg dependent result:; ; GRAPE - Default optim_method is FMIN_L_BFGS_B; CRAB - Default optim_method is FMIN; ; method_params : dict; Parameters for the optim_method. ; Note that where there is an attribute of the; Optimizer object or the termination_conditions matching the key ; that attribute. Otherwise, and in some case also, ; they are assumed to be method_options; for the scipy.optimize.minimize method. ; ; optim_alg : string; Deprecated. Use optim_method. max_metric_corr : integer; Deprecated. Use method_params instead. accuracy_factor : float; Deprecated. Use method_params instead. phase_option : string; determines how global phase is treated in fidelity; calculations (fid_type='UNIT' only). Options:; ; PSU - global phase ignored; SU - global phase included. dyn_params : dict; Parameters for the Dynamics object; The key value pairs are assumed to be attribute name value pairs; They applied after the object is created. prop_params : dict; Parameters for the PropagatorComputer object; The key value pairs are assumed to be attribute name value pairs; They applied after the object is created. fid_params : dict; Parameters for the FidelityComputer object; The key value pairs are assumed to be attribute name value pairs; They applied after the object is created; ; tslot_type : string; Method for computing the dynamics generators, propagators and ; evolution in the tim",MatchSource.WIKI,docs/4.2/modules/qutip/control/pulseoptim.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/control/pulseoptim.html
https://qutip.org/docs/4.2/modules/qutip/control/pulseoptim.html:33228,Performance,perform,performane,33228,"misation will; terminate when the fidelity error falls below this value. max_iter : integer; Maximum number of iterations of the optimisation algorithm. max_wall_time : float; Maximum allowed elapsed time for the optimisation algorithm. alg_params : Dictionary; options that are specific to the algorithm see above; ; optim_params : Dictionary; The key value pairs are the attribute name and value; used to set attribute values; Note: attributes are created if they do not exist already,; and are overwritten if they do.; Note: method_params are applied afterwards and so may override these. coeff_scaling : float; Linear scale factor for the random basis coefficients; By default these range from -1.0 to 1.0; Note this is overridden by alg_params (if given there); ; num_coeffs : integer; Number of coefficients used for each basis function; Note this is calculated automatically based on the dimension of the; dynamics if not given. It is crucial to the performane of the ; algorithm that it is set as low as possible, while still giving; high enough frequencies.; Note this is overridden by alg_params (if given there); ; optim_method : string; Multi-variable optimisation method; The only tested options are 'fmin' and 'Nelder-mead'; In theory any non-gradient method implemented in ; scipy.optimize.mininize could be used. method_params : dict; Parameters for the optim_method. ; Note that where there is an attribute of the; Optimizer object or the termination_conditions matching the key ; that attribute. Otherwise, and in some case also, ; they are assumed to be method_options; for the scipy.optimize.minimize method.; The commonly used parameter are:; xtol - limit on variable change for convergence; ftol - limit on fidelity error change for convergence; ; dyn_type : string; Dynamics type, i.e. the type of matrix used to describe; the dynamics. Options are UNIT, GEN_MAT, SYMPL; (see Dynamics classes for details); ; dyn_params : dict; Parameters for the Dynamics object; The key value ",MatchSource.WIKI,docs/4.2/modules/qutip/control/pulseoptim.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/control/pulseoptim.html
https://qutip.org/docs/4.2/modules/qutip/control/pulseoptim.html:33567,Performance,optimiz,optimize,33567,"ithm see above; ; optim_params : Dictionary; The key value pairs are the attribute name and value; used to set attribute values; Note: attributes are created if they do not exist already,; and are overwritten if they do.; Note: method_params are applied afterwards and so may override these. coeff_scaling : float; Linear scale factor for the random basis coefficients; By default these range from -1.0 to 1.0; Note this is overridden by alg_params (if given there); ; num_coeffs : integer; Number of coefficients used for each basis function; Note this is calculated automatically based on the dimension of the; dynamics if not given. It is crucial to the performane of the ; algorithm that it is set as low as possible, while still giving; high enough frequencies.; Note this is overridden by alg_params (if given there); ; optim_method : string; Multi-variable optimisation method; The only tested options are 'fmin' and 'Nelder-mead'; In theory any non-gradient method implemented in ; scipy.optimize.mininize could be used. method_params : dict; Parameters for the optim_method. ; Note that where there is an attribute of the; Optimizer object or the termination_conditions matching the key ; that attribute. Otherwise, and in some case also, ; they are assumed to be method_options; for the scipy.optimize.minimize method.; The commonly used parameter are:; xtol - limit on variable change for convergence; ftol - limit on fidelity error change for convergence; ; dyn_type : string; Dynamics type, i.e. the type of matrix used to describe; the dynamics. Options are UNIT, GEN_MAT, SYMPL; (see Dynamics classes for details); ; dyn_params : dict; Parameters for the Dynamics object; The key value pairs are assumed to be attribute name value pairs; They applied after the object is created. prop_type : string; Propagator type i.e. the method used to calculate the; propagtors and propagtor gradient for each timeslot; options are DEF, APPROX, DIAG, FRECHET, AUG_MAT; DEF will use the default for ",MatchSource.WIKI,docs/4.2/modules/qutip/control/pulseoptim.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/control/pulseoptim.html
https://qutip.org/docs/4.2/modules/qutip/control/pulseoptim.html:33874,Performance,optimiz,optimize,33874," float; Linear scale factor for the random basis coefficients; By default these range from -1.0 to 1.0; Note this is overridden by alg_params (if given there); ; num_coeffs : integer; Number of coefficients used for each basis function; Note this is calculated automatically based on the dimension of the; dynamics if not given. It is crucial to the performane of the ; algorithm that it is set as low as possible, while still giving; high enough frequencies.; Note this is overridden by alg_params (if given there); ; optim_method : string; Multi-variable optimisation method; The only tested options are 'fmin' and 'Nelder-mead'; In theory any non-gradient method implemented in ; scipy.optimize.mininize could be used. method_params : dict; Parameters for the optim_method. ; Note that where there is an attribute of the; Optimizer object or the termination_conditions matching the key ; that attribute. Otherwise, and in some case also, ; they are assumed to be method_options; for the scipy.optimize.minimize method.; The commonly used parameter are:; xtol - limit on variable change for convergence; ftol - limit on fidelity error change for convergence; ; dyn_type : string; Dynamics type, i.e. the type of matrix used to describe; the dynamics. Options are UNIT, GEN_MAT, SYMPL; (see Dynamics classes for details); ; dyn_params : dict; Parameters for the Dynamics object; The key value pairs are assumed to be attribute name value pairs; They applied after the object is created. prop_type : string; Propagator type i.e. the method used to calculate the; propagtors and propagtor gradient for each timeslot; options are DEF, APPROX, DIAG, FRECHET, AUG_MAT; DEF will use the default for the specific dyn_type; (see PropagatorComputer classes for details). prop_params : dict; Parameters for the PropagatorComputer object; The key value pairs are assumed to be attribute name value pairs; They applied after the object is created; ; fid_type : string; Fidelity error (and fidelity error gradient",MatchSource.WIKI,docs/4.2/modules/qutip/control/pulseoptim.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/control/pulseoptim.html
https://qutip.org/docs/4.2/modules/qutip/control/pulseoptim.html:43978,Performance,perform,performane,43978,"misation will; terminate when the fidelity error falls below this value. max_iter : integer; Maximum number of iterations of the optimisation algorithm. max_wall_time : float; Maximum allowed elapsed time for the optimisation algorithm. alg_params : Dictionary; options that are specific to the algorithm see above; ; optim_params : Dictionary; The key value pairs are the attribute name and value; used to set attribute values; Note: attributes are created if they do not exist already,; and are overwritten if they do.; Note: method_params are applied afterwards and so may override these. coeff_scaling : float; Linear scale factor for the random basis coefficients; By default these range from -1.0 to 1.0; Note this is overridden by alg_params (if given there); ; num_coeffs : integer; Number of coefficients used for each basis function; Note this is calculated automatically based on the dimension of the; dynamics if not given. It is crucial to the performane of the ; algorithm that it is set as low as possible, while still giving; high enough frequencies.; Note this is overridden by alg_params (if given there); ; optim_method : string; Multi-variable optimisation method; The only tested options are 'fmin' and 'Nelder-mead'; In theory any non-gradient method implemented in ; scipy.optimize.mininize could be used. method_params : dict; Parameters for the optim_method. ; Note that where there is an attribute of the; Optimizer object or the termination_conditions matching the key ; that attribute. Otherwise, and in some case also, ; they are assumed to be method_options; for the scipy.optimize.minimize method.; The commonly used parameter are:; xtol - limit on variable change for convergence; ftol - limit on fidelity error change for convergence. phase_option : string; determines how global phase is treated in fidelity; calculations (fid_type='UNIT' only). Options:; PSU - global phase ignored; SU - global phase included. dyn_params : dict; Parameters for the Dynamics object; ",MatchSource.WIKI,docs/4.2/modules/qutip/control/pulseoptim.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/control/pulseoptim.html
https://qutip.org/docs/4.2/modules/qutip/control/pulseoptim.html:44317,Performance,optimiz,optimize,44317,"ithm see above; ; optim_params : Dictionary; The key value pairs are the attribute name and value; used to set attribute values; Note: attributes are created if they do not exist already,; and are overwritten if they do.; Note: method_params are applied afterwards and so may override these. coeff_scaling : float; Linear scale factor for the random basis coefficients; By default these range from -1.0 to 1.0; Note this is overridden by alg_params (if given there); ; num_coeffs : integer; Number of coefficients used for each basis function; Note this is calculated automatically based on the dimension of the; dynamics if not given. It is crucial to the performane of the ; algorithm that it is set as low as possible, while still giving; high enough frequencies.; Note this is overridden by alg_params (if given there); ; optim_method : string; Multi-variable optimisation method; The only tested options are 'fmin' and 'Nelder-mead'; In theory any non-gradient method implemented in ; scipy.optimize.mininize could be used. method_params : dict; Parameters for the optim_method. ; Note that where there is an attribute of the; Optimizer object or the termination_conditions matching the key ; that attribute. Otherwise, and in some case also, ; they are assumed to be method_options; for the scipy.optimize.minimize method.; The commonly used parameter are:; xtol - limit on variable change for convergence; ftol - limit on fidelity error change for convergence. phase_option : string; determines how global phase is treated in fidelity; calculations (fid_type='UNIT' only). Options:; PSU - global phase ignored; SU - global phase included. dyn_params : dict; Parameters for the Dynamics object; The key value pairs are assumed to be attribute name value pairs; They applied after the object is created. prop_params : dict; Parameters for the PropagatorComputer object; The key value pairs are assumed to be attribute name value pairs; They applied after the object is created. fid_params : dict;",MatchSource.WIKI,docs/4.2/modules/qutip/control/pulseoptim.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/control/pulseoptim.html
https://qutip.org/docs/4.2/modules/qutip/control/pulseoptim.html:44624,Performance,optimiz,optimize,44624," float; Linear scale factor for the random basis coefficients; By default these range from -1.0 to 1.0; Note this is overridden by alg_params (if given there); ; num_coeffs : integer; Number of coefficients used for each basis function; Note this is calculated automatically based on the dimension of the; dynamics if not given. It is crucial to the performane of the ; algorithm that it is set as low as possible, while still giving; high enough frequencies.; Note this is overridden by alg_params (if given there); ; optim_method : string; Multi-variable optimisation method; The only tested options are 'fmin' and 'Nelder-mead'; In theory any non-gradient method implemented in ; scipy.optimize.mininize could be used. method_params : dict; Parameters for the optim_method. ; Note that where there is an attribute of the; Optimizer object or the termination_conditions matching the key ; that attribute. Otherwise, and in some case also, ; they are assumed to be method_options; for the scipy.optimize.minimize method.; The commonly used parameter are:; xtol - limit on variable change for convergence; ftol - limit on fidelity error change for convergence. phase_option : string; determines how global phase is treated in fidelity; calculations (fid_type='UNIT' only). Options:; PSU - global phase ignored; SU - global phase included. dyn_params : dict; Parameters for the Dynamics object; The key value pairs are assumed to be attribute name value pairs; They applied after the object is created. prop_params : dict; Parameters for the PropagatorComputer object; The key value pairs are assumed to be attribute name value pairs; They applied after the object is created. fid_params : dict; Parameters for the FidelityComputer object; The key value pairs are assumed to be attribute name value pairs; They applied after the object is created; ; tslot_type : string; Method for computing the dynamics generators, propagators and ; evolution in the timeslots.; Options: DEF, UPDATE_ALL, DYNAMIC; UPD",MatchSource.WIKI,docs/4.2/modules/qutip/control/pulseoptim.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/control/pulseoptim.html
https://qutip.org/docs/4.2/modules/qutip/control/pulseoptim.html:53770,Performance,optimiz,optimize,53770," error target. Pulse optimisation will; terminate when the fidelity error falls below this value. mim_grad : float; Minimum gradient. When the sum of the squares of the; gradients wrt to the control amplitudes falls below this; value, the optimisation terminates, assuming local minima. max_iter : integer; Maximum number of iterations of the optimisation algorithm. max_wall_time : float; Maximum allowed elapsed time for the optimisation algorithm; ; alg : string; Algorithm to use in pulse optimisation.; Options are:; 'GRAPE' (default) - GRadient Ascent Pulse Engineering; 'CRAB' - Chopped RAndom Basis. alg_params : Dictionary; options that are specific to the algorithm see above; ; optim_params : Dictionary; The key value pairs are the attribute name and value; used to set attribute values; Note: attributes are created if they do not exist already,; and are overwritten if they do.; Note: method_params are applied afterwards and so may override these; ; optim_method : string; a scipy.optimize.minimize method that will be used to optimise; the pulse for minimum fidelity error; Note that FMIN, FMIN_BFGS & FMIN_L_BFGS_B will all result; in calling these specific scipy.optimize methods; Note the LBFGSB is equivalent to FMIN_L_BFGS_B for backwards ; capatibility reasons.; Supplying DEF will given alg dependent result:; - GRAPE - Default optim_method is FMIN_L_BFGS_B; - CRAB - Default optim_method is Nelder-Mead; ; method_params : dict; Parameters for the optim_method. ; Note that where there is an attribute of the; Optimizer object or the termination_conditions matching the key ; that attribute. Otherwise, and in some case also, ; they are assumed to be method_options; for the scipy.optimize.minimize method. ; ; optim_alg : string; Deprecated. Use optim_method. max_metric_corr : integer; Deprecated. Use method_params instead. accuracy_factor : float; Deprecated. Use method_params instead. dyn_type : string; Dynamics type, i.e. the type of matrix used to describe; the dynamic",MatchSource.WIKI,docs/4.2/modules/qutip/control/pulseoptim.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/control/pulseoptim.html
https://qutip.org/docs/4.2/modules/qutip/control/pulseoptim.html:53955,Performance,optimiz,optimize,53955,"e, the optimisation terminates, assuming local minima. max_iter : integer; Maximum number of iterations of the optimisation algorithm. max_wall_time : float; Maximum allowed elapsed time for the optimisation algorithm; ; alg : string; Algorithm to use in pulse optimisation.; Options are:; 'GRAPE' (default) - GRadient Ascent Pulse Engineering; 'CRAB' - Chopped RAndom Basis. alg_params : Dictionary; options that are specific to the algorithm see above; ; optim_params : Dictionary; The key value pairs are the attribute name and value; used to set attribute values; Note: attributes are created if they do not exist already,; and are overwritten if they do.; Note: method_params are applied afterwards and so may override these; ; optim_method : string; a scipy.optimize.minimize method that will be used to optimise; the pulse for minimum fidelity error; Note that FMIN, FMIN_BFGS & FMIN_L_BFGS_B will all result; in calling these specific scipy.optimize methods; Note the LBFGSB is equivalent to FMIN_L_BFGS_B for backwards ; capatibility reasons.; Supplying DEF will given alg dependent result:; - GRAPE - Default optim_method is FMIN_L_BFGS_B; - CRAB - Default optim_method is Nelder-Mead; ; method_params : dict; Parameters for the optim_method. ; Note that where there is an attribute of the; Optimizer object or the termination_conditions matching the key ; that attribute. Otherwise, and in some case also, ; they are assumed to be method_options; for the scipy.optimize.minimize method. ; ; optim_alg : string; Deprecated. Use optim_method. max_metric_corr : integer; Deprecated. Use method_params instead. accuracy_factor : float; Deprecated. Use method_params instead. dyn_type : string; Dynamics type, i.e. the type of matrix used to describe; the dynamics. Options are UNIT, GEN_MAT, SYMPL; (see Dynamics classes for details); ; dyn_params : dict; Parameters for the Dynamics object; The key value pairs are assumed to be attribute name value pairs; They applied after the object is cr",MatchSource.WIKI,docs/4.2/modules/qutip/control/pulseoptim.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/control/pulseoptim.html
https://qutip.org/docs/4.2/modules/qutip/control/pulseoptim.html:54478,Performance,optimiz,optimize,54478,"ionary; The key value pairs are the attribute name and value; used to set attribute values; Note: attributes are created if they do not exist already,; and are overwritten if they do.; Note: method_params are applied afterwards and so may override these; ; optim_method : string; a scipy.optimize.minimize method that will be used to optimise; the pulse for minimum fidelity error; Note that FMIN, FMIN_BFGS & FMIN_L_BFGS_B will all result; in calling these specific scipy.optimize methods; Note the LBFGSB is equivalent to FMIN_L_BFGS_B for backwards ; capatibility reasons.; Supplying DEF will given alg dependent result:; - GRAPE - Default optim_method is FMIN_L_BFGS_B; - CRAB - Default optim_method is Nelder-Mead; ; method_params : dict; Parameters for the optim_method. ; Note that where there is an attribute of the; Optimizer object or the termination_conditions matching the key ; that attribute. Otherwise, and in some case also, ; they are assumed to be method_options; for the scipy.optimize.minimize method. ; ; optim_alg : string; Deprecated. Use optim_method. max_metric_corr : integer; Deprecated. Use method_params instead. accuracy_factor : float; Deprecated. Use method_params instead. dyn_type : string; Dynamics type, i.e. the type of matrix used to describe; the dynamics. Options are UNIT, GEN_MAT, SYMPL; (see Dynamics classes for details); ; dyn_params : dict; Parameters for the Dynamics object; The key value pairs are assumed to be attribute name value pairs; They applied after the object is created. prop_type : string; Propagator type i.e. the method used to calculate the; propagtors and propagtor gradient for each timeslot; options are DEF, APPROX, DIAG, FRECHET, AUG_MAT; DEF will use the default for the specific dyn_type; (see PropagatorComputer classes for details). prop_params : dict; Parameters for the PropagatorComputer object; The key value pairs are assumed to be attribute name value pairs; They applied after the object is created; ; fid_type : string; ",MatchSource.WIKI,docs/4.2/modules/qutip/control/pulseoptim.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/control/pulseoptim.html
https://qutip.org/docs/4.2/modules/qutip/control/pulseoptim.html:58632,Performance,optimiz,optimizer,58632,"The key value pairs are assumed to be attribute name value pairs; They applied after the object is created; ; log_level : integer; level of messaging output from the logger.; Options are attributes of qutip.logging_utils,; in decreasing levels of messaging, are:; DEBUG_INTENSE, DEBUG_VERBOSE, DEBUG, INFO, WARN, ERROR, CRITICAL; Anything WARN or above is effectively 'quiet' execution,; assuming everything runs as expected.; The default NOTSET implies that the level will be taken from; the QuTiP settings file, which by default is WARN. gen_stats : boolean; if set to True then statistics for the optimisation; run will be generated - accessible through attributes; of the stats object. Returns; -------; opt : Optimizer ; Instance of an Optimizer, through which the; Config, Dynamics, PulseGen, and TerminationConditions objects; can be accessed as attributes.; The PropagatorComputer, FidelityComputer and TimeslotComputer objects; can be accessed as attributes of the Dynamics object, e.g. optimizer.dynamics.fid_computer; The optimisation can be run through the optimizer.run_optimization; ; """""". # check parameters; ctrls = dynamics._check_ctrls_container(ctrls); dynamics._check_drift_dyn_gen(drift). if not isinstance(initial, Qobj):; raise TypeError(""initial must be a Qobj""). if not isinstance(target, Qobj):; raise TypeError(""target must be a Qobj""); ; # Deprecated parameter management; if not optim_alg is None:; optim_method = optim_alg; _param_deprecation(; ""The 'optim_alg' parameter is deprecated. ""; ""Use 'optim_method' instead""); ; if not max_metric_corr is None:; if isinstance(method_params, dict):; if not 'max_metric_corr' in method_params:; method_params['max_metric_corr'] = max_metric_corr; else:; method_params = {'max_metric_corr':max_metric_corr}; _param_deprecation(; ""The 'max_metric_corr' parameter is deprecated. ""; ""Use 'max_metric_corr' in method_params instead""); ; if not accuracy_factor is None:; if isinstance(method_params, dict):; if not 'accuracy_factor' in",MatchSource.WIKI,docs/4.2/modules/qutip/control/pulseoptim.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/control/pulseoptim.html
https://qutip.org/docs/4.2/modules/qutip/control/pulseoptim.html:58705,Performance,optimiz,optimizer,58705," name value pairs; They applied after the object is created; ; log_level : integer; level of messaging output from the logger.; Options are attributes of qutip.logging_utils,; in decreasing levels of messaging, are:; DEBUG_INTENSE, DEBUG_VERBOSE, DEBUG, INFO, WARN, ERROR, CRITICAL; Anything WARN or above is effectively 'quiet' execution,; assuming everything runs as expected.; The default NOTSET implies that the level will be taken from; the QuTiP settings file, which by default is WARN. gen_stats : boolean; if set to True then statistics for the optimisation; run will be generated - accessible through attributes; of the stats object. Returns; -------; opt : Optimizer ; Instance of an Optimizer, through which the; Config, Dynamics, PulseGen, and TerminationConditions objects; can be accessed as attributes.; The PropagatorComputer, FidelityComputer and TimeslotComputer objects; can be accessed as attributes of the Dynamics object, e.g. optimizer.dynamics.fid_computer; The optimisation can be run through the optimizer.run_optimization; ; """""". # check parameters; ctrls = dynamics._check_ctrls_container(ctrls); dynamics._check_drift_dyn_gen(drift). if not isinstance(initial, Qobj):; raise TypeError(""initial must be a Qobj""). if not isinstance(target, Qobj):; raise TypeError(""target must be a Qobj""); ; # Deprecated parameter management; if not optim_alg is None:; optim_method = optim_alg; _param_deprecation(; ""The 'optim_alg' parameter is deprecated. ""; ""Use 'optim_method' instead""); ; if not max_metric_corr is None:; if isinstance(method_params, dict):; if not 'max_metric_corr' in method_params:; method_params['max_metric_corr'] = max_metric_corr; else:; method_params = {'max_metric_corr':max_metric_corr}; _param_deprecation(; ""The 'max_metric_corr' parameter is deprecated. ""; ""Use 'max_metric_corr' in method_params instead""); ; if not accuracy_factor is None:; if isinstance(method_params, dict):; if not 'accuracy_factor' in method_params:; method_params['accuracy_facto",MatchSource.WIKI,docs/4.2/modules/qutip/control/pulseoptim.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/control/pulseoptim.html
https://qutip.org/docs/4.2/modules/qutip/control/pulseoptim.html:64655,Performance,optimiz,optimizer,64655,"== '':; # None given, use the default for the Dynamics; pass; elif fid_type_up == 'TDAPPROX':; if not isinstance(dyn.fid_computer, fidcomp.FidCompTraceDiffApprox):; dyn.fid_computer = fidcomp.FidCompTraceDiffApprox(dyn); elif fid_type_up == 'TRACEDIFF':; if not isinstance(dyn.fid_computer, fidcomp.FidCompTraceDiff):; dyn.fid_computer = fidcomp.FidCompTraceDiff(dyn); elif fid_type_up == 'UNIT':; if not isinstance(dyn.fid_computer, fidcomp.FidCompUnitary):; dyn.fid_computer = fidcomp.FidCompUnitary(dyn); else:; raise errors.UsageError(""No option for fid_type: "" + fid_type); dyn.fid_computer.apply_params(fid_params); ; # Currently the only working option for tslot computer is ; # TSlotCompUpdateAll.; # so just apply the parameters; dyn.tslot_computer.apply_params(tslot_params) . # Create the Optimiser instance; optim_method_up = _upper_safe(optim_method); if optim_method is None or optim_method_up == '':; raise errors.UsageError(""Optimisation method must be specified ""; ""via 'optim_method' parameter""); elif optim_method_up == 'FMIN_BFGS':; optim = optimizer.OptimizerBFGS(cfg, dyn); elif optim_method_up == 'LBFGSB' or optim_method_up == 'FMIN_L_BFGS_B':; optim = optimizer.OptimizerLBFGSB(cfg, dyn); elif optim_method_up == 'FMIN':; if alg_up == 'CRAB':; optim = optimizer.OptimizerCrabFmin(cfg, dyn); else:; raise errors.UsageError(; ""Invalid optim_method '{}' for '{}' algorthim"".format(; optim_method, alg)); else:; # Assume that the optim_method is a valid; #scipy.optimize.minimize method; # Choose an optimiser based on the algorithm; if alg_up == 'CRAB':; optim = optimizer.OptimizerCrab(cfg, dyn); else:; optim = optimizer.Optimizer(cfg, dyn); ; optim.alg = alg; optim.method = optim_method; optim.amp_lbound = amp_lbound; optim.amp_ubound = amp_ubound; optim.apply_params(optim_params); ; # Create the TerminationConditions instance; tc = termcond.TerminationConditions(); tc.fid_err_targ = fid_err_targ; tc.min_gradient_norm = min_grad; tc.max_iterations = max_iter; tc.max_wa",MatchSource.WIKI,docs/4.2/modules/qutip/control/pulseoptim.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/control/pulseoptim.html
https://qutip.org/docs/4.2/modules/qutip/control/pulseoptim.html:64771,Performance,optimiz,optimizer,64771,", fidcomp.FidCompTraceDiffApprox):; dyn.fid_computer = fidcomp.FidCompTraceDiffApprox(dyn); elif fid_type_up == 'TRACEDIFF':; if not isinstance(dyn.fid_computer, fidcomp.FidCompTraceDiff):; dyn.fid_computer = fidcomp.FidCompTraceDiff(dyn); elif fid_type_up == 'UNIT':; if not isinstance(dyn.fid_computer, fidcomp.FidCompUnitary):; dyn.fid_computer = fidcomp.FidCompUnitary(dyn); else:; raise errors.UsageError(""No option for fid_type: "" + fid_type); dyn.fid_computer.apply_params(fid_params); ; # Currently the only working option for tslot computer is ; # TSlotCompUpdateAll.; # so just apply the parameters; dyn.tslot_computer.apply_params(tslot_params) . # Create the Optimiser instance; optim_method_up = _upper_safe(optim_method); if optim_method is None or optim_method_up == '':; raise errors.UsageError(""Optimisation method must be specified ""; ""via 'optim_method' parameter""); elif optim_method_up == 'FMIN_BFGS':; optim = optimizer.OptimizerBFGS(cfg, dyn); elif optim_method_up == 'LBFGSB' or optim_method_up == 'FMIN_L_BFGS_B':; optim = optimizer.OptimizerLBFGSB(cfg, dyn); elif optim_method_up == 'FMIN':; if alg_up == 'CRAB':; optim = optimizer.OptimizerCrabFmin(cfg, dyn); else:; raise errors.UsageError(; ""Invalid optim_method '{}' for '{}' algorthim"".format(; optim_method, alg)); else:; # Assume that the optim_method is a valid; #scipy.optimize.minimize method; # Choose an optimiser based on the algorithm; if alg_up == 'CRAB':; optim = optimizer.OptimizerCrab(cfg, dyn); else:; optim = optimizer.Optimizer(cfg, dyn); ; optim.alg = alg; optim.method = optim_method; optim.amp_lbound = amp_lbound; optim.amp_ubound = amp_ubound; optim.apply_params(optim_params); ; # Create the TerminationConditions instance; tc = termcond.TerminationConditions(); tc.fid_err_targ = fid_err_targ; tc.min_gradient_norm = min_grad; tc.max_iterations = max_iter; tc.max_wall_time = max_wall_time; optim.termination_conditions = tc; ; optim.apply_method_params(method_params). if gen_stats:; # Create a",MatchSource.WIKI,docs/4.2/modules/qutip/control/pulseoptim.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/control/pulseoptim.html
https://qutip.org/docs/4.2/modules/qutip/control/pulseoptim.html:64871,Performance,optimiz,optimizer,64871," == 'TRACEDIFF':; if not isinstance(dyn.fid_computer, fidcomp.FidCompTraceDiff):; dyn.fid_computer = fidcomp.FidCompTraceDiff(dyn); elif fid_type_up == 'UNIT':; if not isinstance(dyn.fid_computer, fidcomp.FidCompUnitary):; dyn.fid_computer = fidcomp.FidCompUnitary(dyn); else:; raise errors.UsageError(""No option for fid_type: "" + fid_type); dyn.fid_computer.apply_params(fid_params); ; # Currently the only working option for tslot computer is ; # TSlotCompUpdateAll.; # so just apply the parameters; dyn.tslot_computer.apply_params(tslot_params) . # Create the Optimiser instance; optim_method_up = _upper_safe(optim_method); if optim_method is None or optim_method_up == '':; raise errors.UsageError(""Optimisation method must be specified ""; ""via 'optim_method' parameter""); elif optim_method_up == 'FMIN_BFGS':; optim = optimizer.OptimizerBFGS(cfg, dyn); elif optim_method_up == 'LBFGSB' or optim_method_up == 'FMIN_L_BFGS_B':; optim = optimizer.OptimizerLBFGSB(cfg, dyn); elif optim_method_up == 'FMIN':; if alg_up == 'CRAB':; optim = optimizer.OptimizerCrabFmin(cfg, dyn); else:; raise errors.UsageError(; ""Invalid optim_method '{}' for '{}' algorthim"".format(; optim_method, alg)); else:; # Assume that the optim_method is a valid; #scipy.optimize.minimize method; # Choose an optimiser based on the algorithm; if alg_up == 'CRAB':; optim = optimizer.OptimizerCrab(cfg, dyn); else:; optim = optimizer.Optimizer(cfg, dyn); ; optim.alg = alg; optim.method = optim_method; optim.amp_lbound = amp_lbound; optim.amp_ubound = amp_ubound; optim.apply_params(optim_params); ; # Create the TerminationConditions instance; tc = termcond.TerminationConditions(); tc.fid_err_targ = fid_err_targ; tc.min_gradient_norm = min_grad; tc.max_iterations = max_iter; tc.max_wall_time = max_wall_time; optim.termination_conditions = tc; ; optim.apply_method_params(method_params). if gen_stats:; # Create a stats object; # Note that stats object is optional; # if the Dynamics and Optimizer stats attribute is not ",MatchSource.WIKI,docs/4.2/modules/qutip/control/pulseoptim.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/control/pulseoptim.html
https://qutip.org/docs/4.2/modules/qutip/control/pulseoptim.html:65077,Performance,optimiz,optimize,65077,"FidCompUnitary(dyn); else:; raise errors.UsageError(""No option for fid_type: "" + fid_type); dyn.fid_computer.apply_params(fid_params); ; # Currently the only working option for tslot computer is ; # TSlotCompUpdateAll.; # so just apply the parameters; dyn.tslot_computer.apply_params(tslot_params) . # Create the Optimiser instance; optim_method_up = _upper_safe(optim_method); if optim_method is None or optim_method_up == '':; raise errors.UsageError(""Optimisation method must be specified ""; ""via 'optim_method' parameter""); elif optim_method_up == 'FMIN_BFGS':; optim = optimizer.OptimizerBFGS(cfg, dyn); elif optim_method_up == 'LBFGSB' or optim_method_up == 'FMIN_L_BFGS_B':; optim = optimizer.OptimizerLBFGSB(cfg, dyn); elif optim_method_up == 'FMIN':; if alg_up == 'CRAB':; optim = optimizer.OptimizerCrabFmin(cfg, dyn); else:; raise errors.UsageError(; ""Invalid optim_method '{}' for '{}' algorthim"".format(; optim_method, alg)); else:; # Assume that the optim_method is a valid; #scipy.optimize.minimize method; # Choose an optimiser based on the algorithm; if alg_up == 'CRAB':; optim = optimizer.OptimizerCrab(cfg, dyn); else:; optim = optimizer.Optimizer(cfg, dyn); ; optim.alg = alg; optim.method = optim_method; optim.amp_lbound = amp_lbound; optim.amp_ubound = amp_ubound; optim.apply_params(optim_params); ; # Create the TerminationConditions instance; tc = termcond.TerminationConditions(); tc.fid_err_targ = fid_err_targ; tc.min_gradient_norm = min_grad; tc.max_iterations = max_iter; tc.max_wall_time = max_wall_time; optim.termination_conditions = tc; ; optim.apply_method_params(method_params). if gen_stats:; # Create a stats object; # Note that stats object is optional; # if the Dynamics and Optimizer stats attribute is not set; # then no stats will be collected, which could improve performance; if amp_update_mode == 'DYNAMIC':; sts = stats.StatsDynTsUpdate(); else:; sts = stats.Stats(). dyn.stats = sts; optim.stats = sts. # Configure the dynamics; dyn.drift_dyn_gen = dr",MatchSource.WIKI,docs/4.2/modules/qutip/control/pulseoptim.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/control/pulseoptim.html
https://qutip.org/docs/4.2/modules/qutip/control/pulseoptim.html:65179,Performance,optimiz,optimizer,65179,"option for fid_type: "" + fid_type); dyn.fid_computer.apply_params(fid_params); ; # Currently the only working option for tslot computer is ; # TSlotCompUpdateAll.; # so just apply the parameters; dyn.tslot_computer.apply_params(tslot_params) . # Create the Optimiser instance; optim_method_up = _upper_safe(optim_method); if optim_method is None or optim_method_up == '':; raise errors.UsageError(""Optimisation method must be specified ""; ""via 'optim_method' parameter""); elif optim_method_up == 'FMIN_BFGS':; optim = optimizer.OptimizerBFGS(cfg, dyn); elif optim_method_up == 'LBFGSB' or optim_method_up == 'FMIN_L_BFGS_B':; optim = optimizer.OptimizerLBFGSB(cfg, dyn); elif optim_method_up == 'FMIN':; if alg_up == 'CRAB':; optim = optimizer.OptimizerCrabFmin(cfg, dyn); else:; raise errors.UsageError(; ""Invalid optim_method '{}' for '{}' algorthim"".format(; optim_method, alg)); else:; # Assume that the optim_method is a valid; #scipy.optimize.minimize method; # Choose an optimiser based on the algorithm; if alg_up == 'CRAB':; optim = optimizer.OptimizerCrab(cfg, dyn); else:; optim = optimizer.Optimizer(cfg, dyn); ; optim.alg = alg; optim.method = optim_method; optim.amp_lbound = amp_lbound; optim.amp_ubound = amp_ubound; optim.apply_params(optim_params); ; # Create the TerminationConditions instance; tc = termcond.TerminationConditions(); tc.fid_err_targ = fid_err_targ; tc.min_gradient_norm = min_grad; tc.max_iterations = max_iter; tc.max_wall_time = max_wall_time; optim.termination_conditions = tc; ; optim.apply_method_params(method_params). if gen_stats:; # Create a stats object; # Note that stats object is optional; # if the Dynamics and Optimizer stats attribute is not set; # then no stats will be collected, which could improve performance; if amp_update_mode == 'DYNAMIC':; sts = stats.StatsDynTsUpdate(); else:; sts = stats.Stats(). dyn.stats = sts; optim.stats = sts. # Configure the dynamics; dyn.drift_dyn_gen = drift; dyn.ctrl_dyn_gen = ctrls; dyn.initial = initial; dy",MatchSource.WIKI,docs/4.2/modules/qutip/control/pulseoptim.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/control/pulseoptim.html
https://qutip.org/docs/4.2/modules/qutip/control/pulseoptim.html:65229,Performance,optimiz,optimizer,65229,"; ; # Currently the only working option for tslot computer is ; # TSlotCompUpdateAll.; # so just apply the parameters; dyn.tslot_computer.apply_params(tslot_params) . # Create the Optimiser instance; optim_method_up = _upper_safe(optim_method); if optim_method is None or optim_method_up == '':; raise errors.UsageError(""Optimisation method must be specified ""; ""via 'optim_method' parameter""); elif optim_method_up == 'FMIN_BFGS':; optim = optimizer.OptimizerBFGS(cfg, dyn); elif optim_method_up == 'LBFGSB' or optim_method_up == 'FMIN_L_BFGS_B':; optim = optimizer.OptimizerLBFGSB(cfg, dyn); elif optim_method_up == 'FMIN':; if alg_up == 'CRAB':; optim = optimizer.OptimizerCrabFmin(cfg, dyn); else:; raise errors.UsageError(; ""Invalid optim_method '{}' for '{}' algorthim"".format(; optim_method, alg)); else:; # Assume that the optim_method is a valid; #scipy.optimize.minimize method; # Choose an optimiser based on the algorithm; if alg_up == 'CRAB':; optim = optimizer.OptimizerCrab(cfg, dyn); else:; optim = optimizer.Optimizer(cfg, dyn); ; optim.alg = alg; optim.method = optim_method; optim.amp_lbound = amp_lbound; optim.amp_ubound = amp_ubound; optim.apply_params(optim_params); ; # Create the TerminationConditions instance; tc = termcond.TerminationConditions(); tc.fid_err_targ = fid_err_targ; tc.min_gradient_norm = min_grad; tc.max_iterations = max_iter; tc.max_wall_time = max_wall_time; optim.termination_conditions = tc; ; optim.apply_method_params(method_params). if gen_stats:; # Create a stats object; # Note that stats object is optional; # if the Dynamics and Optimizer stats attribute is not set; # then no stats will be collected, which could improve performance; if amp_update_mode == 'DYNAMIC':; sts = stats.StatsDynTsUpdate(); else:; sts = stats.Stats(). dyn.stats = sts; optim.stats = sts. # Configure the dynamics; dyn.drift_dyn_gen = drift; dyn.ctrl_dyn_gen = ctrls; dyn.initial = initial; dyn.target = target; if tau is None:; # Check that parameters have been suppli",MatchSource.WIKI,docs/4.2/modules/qutip/control/pulseoptim.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/control/pulseoptim.html
https://qutip.org/docs/4.2/modules/qutip/control/pulseoptim.html:65891,Performance,perform,performance,65891,"od_up == 'FMIN':; if alg_up == 'CRAB':; optim = optimizer.OptimizerCrabFmin(cfg, dyn); else:; raise errors.UsageError(; ""Invalid optim_method '{}' for '{}' algorthim"".format(; optim_method, alg)); else:; # Assume that the optim_method is a valid; #scipy.optimize.minimize method; # Choose an optimiser based on the algorithm; if alg_up == 'CRAB':; optim = optimizer.OptimizerCrab(cfg, dyn); else:; optim = optimizer.Optimizer(cfg, dyn); ; optim.alg = alg; optim.method = optim_method; optim.amp_lbound = amp_lbound; optim.amp_ubound = amp_ubound; optim.apply_params(optim_params); ; # Create the TerminationConditions instance; tc = termcond.TerminationConditions(); tc.fid_err_targ = fid_err_targ; tc.min_gradient_norm = min_grad; tc.max_iterations = max_iter; tc.max_wall_time = max_wall_time; optim.termination_conditions = tc; ; optim.apply_method_params(method_params). if gen_stats:; # Create a stats object; # Note that stats object is optional; # if the Dynamics and Optimizer stats attribute is not set; # then no stats will be collected, which could improve performance; if amp_update_mode == 'DYNAMIC':; sts = stats.StatsDynTsUpdate(); else:; sts = stats.Stats(). dyn.stats = sts; optim.stats = sts. # Configure the dynamics; dyn.drift_dyn_gen = drift; dyn.ctrl_dyn_gen = ctrls; dyn.initial = initial; dyn.target = target; if tau is None:; # Check that parameters have been supplied to generate the; # timeslot durations; try:; evo_time / num_tslots; except:; raise errors.UsageError(; ""Either the timeslot durations should be supplied as an ""; ""array 'tau' or the number of timeslots 'num_tslots' ""; ""and the evolution time 'evo_time' must be given.""). dyn.num_tslots = num_tslots; dyn.evo_time = evo_time; else:; dyn.tau = tau. # this function is called, so that the num_ctrls attribute will be set; n_ctrls = dyn.num_ctrls. ramping_pgen = None; if ramping_pulse_type:; ramping_pgen = pulsegen.create_pulse_gen(; pulse_type=ramping_pulse_type, dyn=dyn, ; pulse_params=ramping_pulse_params",MatchSource.WIKI,docs/4.2/modules/qutip/control/pulseoptim.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/control/pulseoptim.html
https://qutip.org/docs/4.2/modules/qutip/control/pulseoptim.html:68983,Performance,optimiz,optimizer,68983,"_params); guess_pulse_action = init_pulse_params.get('pulse_action'). optim.pulse_generator = []; for j in range(n_ctrls):; crab_pgen = pulsegen.PulseGenCrabFourier(; dyn=dyn, num_coeffs=num_coeffs); if init_coeff_scaling is not None:; crab_pgen.scaling = init_coeff_scaling; if isinstance(crab_pulse_params, dict):; crab_pgen.apply_params(crab_pulse_params); ; lb = None; if amp_lbound:; if isinstance(amp_lbound, list):; try:; lb = amp_lbound[j]; except:; lb = amp_lbound[-1]; else:; lb = amp_lbound; ub = None; if amp_ubound:; if isinstance(amp_ubound, list):; try:; ub = amp_ubound[j]; except:; ub = amp_ubound[-1]; else:; ub = amp_ubound; crab_pgen.lbound = lb; crab_pgen.ubound = ub; ; if guess_pulse_type:; guess_pgen.lbound = lb; guess_pgen.ubound = ub; crab_pgen.guess_pulse = guess_pgen.gen_pulse(); if guess_pulse_action:; crab_pgen.guess_pulse_action = guess_pulse_action; ; if ramping_pgen:; crab_pgen.ramping_pulse = ramping_pgen.gen_pulse(). optim.pulse_generator.append(crab_pgen); #This is just for the debug message now; pgen = optim.pulse_generator[0]; ; else:; # Create a pulse generator of the type specified; pgen = pulsegen.create_pulse_gen(pulse_type=init_pulse_type, dyn=dyn,; pulse_params=init_pulse_params); pgen.scaling = pulse_scaling; pgen.offset = pulse_offset; pgen.lbound = amp_lbound; pgen.ubound = amp_ubound. optim.pulse_generator = pgen. if log_level <= logging.DEBUG:; logger.debug(; ""Optimisation config summary...\n""; "" object classes:\n""; "" optimizer: "" + optim.__class__.__name__ +; ""\n dynamics: "" + dyn.__class__.__name__ +; ""\n tslotcomp: "" + dyn.tslot_computer.__class__.__name__ +; ""\n fidcomp: "" + dyn.fid_computer.__class__.__name__ +; ""\n propcomp: "" + dyn.prop_computer.__class__.__name__ +; ""\n pulsegen: "" + pgen.__class__.__name__). return optim. Â© Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, and A.L. Grimsmo.; Last updated on Jan 17, 2018. . Built with Sphinx using a theme provided by Read the Docs. . ",MatchSource.WIKI,docs/4.2/modules/qutip/control/pulseoptim.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/control/pulseoptim.html
https://qutip.org/docs/4.2/modules/qutip/control/pulseoptim.html:2812,Security,access,accessible,2812," CONTRACT, STRICT LIABILITY, OR TORT; # (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE; # OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.; ###############################################################################. # @author: Alexander Pitchford; # @email1: agp1@aber.ac.uk; # @email2: alex.pitchford@gmail.com; # @organization: Aberystwyth University; # @supervisor: Daniel Burgarth. """"""; Wrapper functions that will manage the creation of the objects,; build the configuration, and execute the algorithm required to optimise; a set of ctrl pulses for a given (quantum) system.; The fidelity error is some measure of distance of the system evolution; from the given target evolution in the time allowed for the evolution.; The functions minimise this fidelity error wrt the piecewise control; amplitudes in the timeslots. There are currently two quantum control pulse optmisations algorithms; implemented in this library. There are accessible through the methods; in this module. Both the algorithms use the scipy.optimize methods; to minimise the fidelity error with respect to to variables that define; the pulse. GRAPE; -----; The default algorithm (as it was implemented here first) is GRAPE; GRadient Ascent Pulse Engineering [1][2]. It uses a gradient based method such; as BFGS to minimise the fidelity error. This makes convergence very quick; when an exact gradient can be calculated, but this limits the factors that can; taken into account in the fidelity. CRAB; ----; The CRAB [3][4] algorithm was developed at the University of Ulm.; In full it is the Chopped RAndom Basis algorithm.; The main difference is that it reduces the number of optimisation variables ; by defining the control pulses by expansions of basis functions, ; where the variables are the coefficients. Typically a Fourier series is chosen, ; i.e. the variables are the Fourier coefficients. ; Therefore it does not need to compute an explicit gradient. ; By default i",MatchSource.WIKI,docs/4.2/modules/qutip/control/pulseoptim.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/control/pulseoptim.html
https://qutip.org/docs/4.2/modules/qutip/control/pulseoptim.html:13976,Security,access,accessible,13976,"emented in CRAB.; GAUSSIAN_EDGE was added for this purpose.; ; ramping_pulse_params : dict; Parameters for the ramping pulse generator object; The key value pairs are assumed to be attribute name value pairs; They applied after the object is created. log_level : integer; level of messaging output from the logger.; Options are attributes of qutip.logging_utils,; in decreasing levels of messaging, are:; DEBUG_INTENSE, DEBUG_VERBOSE, DEBUG, INFO, WARN, ERROR, CRITICAL; Anything WARN or above is effectively 'quiet' execution,; assuming everything runs as expected.; The default NOTSET implies that the level will be taken from; the QuTiP settings file, which by default is WARN. out_file_ext : string or None; files containing the initial and final control pulse; amplitudes are saved to the current directory.; The default name will be postfixed with this extension; Setting this to None will suppress the output of files. gen_stats : boolean; if set to True then statistics for the optimisation; run will be generated - accessible through attributes; of the stats object. Returns; -------; opt : OptimResult ; Returns instance of OptimResult, which has attributes giving the; reason for termination, final fidelity error, final evolution; final amplitudes, statistics etc; ; """"""; if log_level == logging.NOTSET:; log_level = logger.getEffectiveLevel(); else:; logger.setLevel(log_level); ; # The parameters types are checked in create_pulse_optimizer; # so no need to do so here; # However, the deprecation management is repeated here; # so that the stack level is correct; if not optim_alg is None:; optim_method = optim_alg; _param_deprecation(; ""The 'optim_alg' parameter is deprecated. ""; ""Use 'optim_method' instead""); ; if not max_metric_corr is None:; if isinstance(method_params, dict):; if not 'max_metric_corr' in method_params:; method_params['max_metric_corr'] = max_metric_corr; else:; method_params = {'max_metric_corr':max_metric_corr}; _param_deprecation(; ""The 'max_metric_corr' ",MatchSource.WIKI,docs/4.2/modules/qutip/control/pulseoptim.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/control/pulseoptim.html
https://qutip.org/docs/4.2/modules/qutip/control/pulseoptim.html:26872,Security,access,accessible,26872,"emented in CRAB.; GAUSSIAN_EDGE was added for this purpose.; ; ramping_pulse_params : dict; Parameters for the ramping pulse generator object; The key value pairs are assumed to be attribute name value pairs; They applied after the object is created. log_level : integer; level of messaging output from the logger.; Options are attributes of qutip.logging_utils,; in decreasing levels of messaging, are:; DEBUG_INTENSE, DEBUG_VERBOSE, DEBUG, INFO, WARN, ERROR, CRITICAL; Anything WARN or above is effectively 'quiet' execution,; assuming everything runs as expected.; The default NOTSET implies that the level will be taken from; the QuTiP settings file, which by default is WARN. out_file_ext : string or None; files containing the initial and final control pulse; amplitudes are saved to the current directory.; The default name will be postfixed with this extension; Setting this to None will suppress the output of files. gen_stats : boolean; if set to True then statistics for the optimisation; run will be generated - accessible through attributes; of the stats object. Returns; -------; opt : OptimResult; Returns instance of OptimResult, which has attributes giving the; reason for termination, final fidelity error, final evolution; final amplitudes, statistics etc; ; """""". # parameters are checked in create pulse optimiser; ; # The deprecation management is repeated here; # so that the stack level is correct; if not optim_alg is None:; optim_method = optim_alg; _param_deprecation(; ""The 'optim_alg' parameter is deprecated. ""; ""Use 'optim_method' instead""); ; if not max_metric_corr is None:; if isinstance(method_params, dict):; if not 'max_metric_corr' in method_params:; method_params['max_metric_corr'] = max_metric_corr; else:; method_params = {'max_metric_corr':max_metric_corr}; _param_deprecation(; ""The 'max_metric_corr' parameter is deprecated. ""; ""Use 'max_metric_corr' in method_params instead""); ; if not accuracy_factor is None:; if isinstance(method_params, dict):; if no",MatchSource.WIKI,docs/4.2/modules/qutip/control/pulseoptim.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/control/pulseoptim.html
https://qutip.org/docs/4.2/modules/qutip/control/pulseoptim.html:37713,Security,access,accessible,37713,"emented in CRAB.; GAUSSIAN_EDGE was added for this purpose.; ; ramping_pulse_params : dict; Parameters for the ramping pulse generator object; The key value pairs are assumed to be attribute name value pairs; They applied after the object is created. log_level : integer; level of messaging output from the logger.; Options are attributes of qutip.logging_utils,; in decreasing levels of messaging, are:; DEBUG_INTENSE, DEBUG_VERBOSE, DEBUG, INFO, WARN, ERROR, CRITICAL; Anything WARN or above is effectively 'quiet' execution,; assuming everything runs as expected.; The default NOTSET implies that the level will be taken from; the QuTiP settings file, which by default is WARN. out_file_ext : string or None; files containing the initial and final control pulse; amplitudes are saved to the current directory.; The default name will be postfixed with this extension; Setting this to None will suppress the output of files. gen_stats : boolean; if set to True then statistics for the optimisation; run will be generated - accessible through attributes; of the stats object. Returns; -------; opt : OptimResult ; Returns instance of OptimResult, which has attributes giving the; reason for termination, final fidelity error, final evolution; final amplitudes, statistics etc; ; """""". # The parameters are checked in create_pulse_optimizer; # so no need to do so here. if log_level == logging.NOTSET:; log_level = logger.getEffectiveLevel(); else:; logger.setLevel(log_level). # build the algorithm options; if not isinstance(alg_params, dict): ; alg_params = {'num_coeffs':num_coeffs, ; 'init_coeff_scaling':init_coeff_scaling}; else:; if (num_coeffs is not None and ; not 'num_coeffs' in alg_params):; alg_params['num_coeffs'] = num_coeffs; if (init_coeff_scaling is not None and ; not 'init_coeff_scaling' in alg_params):; alg_params['init_coeff_scaling'] = init_coeff_scaling; ; # Build the guess pulse options; # Any options passed in the guess_pulse_params take precedence; # over the parameter ",MatchSource.WIKI,docs/4.2/modules/qutip/control/pulseoptim.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/control/pulseoptim.html
https://qutip.org/docs/4.2/modules/qutip/control/pulseoptim.html:47975,Security,access,accessible,47975,"emented in CRAB.; GAUSSIAN_EDGE was added for this purpose.; ; ramping_pulse_params : dict; Parameters for the ramping pulse generator object; The key value pairs are assumed to be attribute name value pairs; They applied after the object is created. log_level : integer; level of messaging output from the logger.; Options are attributes of qutip.logging_utils,; in decreasing levels of messaging, are:; DEBUG_INTENSE, DEBUG_VERBOSE, DEBUG, INFO, WARN, ERROR, CRITICAL; Anything WARN or above is effectively 'quiet' execution,; assuming everything runs as expected.; The default NOTSET implies that the level will be taken from; the QuTiP settings file, which by default is WARN. out_file_ext : string or None; files containing the initial and final control pulse; amplitudes are saved to the current directory.; The default name will be postfixed with this extension; Setting this to None will suppress the output of files. gen_stats : boolean; if set to True then statistics for the optimisation; run will be generated - accessible through attributes; of the stats object. Returns; -------; opt : OptimResult ; Returns instance of OptimResult, which has attributes giving the; reason for termination, final fidelity error, final evolution; final amplitudes, statistics etc; ; """""". # The parameters are checked in create_pulse_optimizer; # so no need to do so here. if log_level == logging.NOTSET:; log_level = logger.getEffectiveLevel(); else:; logger.setLevel(log_level). # build the algorithm options; if not isinstance(alg_params, dict): ; alg_params = {'num_coeffs':num_coeffs, ; 'init_coeff_scaling':init_coeff_scaling}; else:; if (num_coeffs is not None and ; not 'num_coeffs' in alg_params):; alg_params['num_coeffs'] = num_coeffs; if (init_coeff_scaling is not None and ; not 'init_coeff_scaling' in alg_params):; alg_params['init_coeff_scaling'] = init_coeff_scaling; ; # Build the guess pulse options; # Any options passed in the guess_pulse_params take precedence; # over the parameter ",MatchSource.WIKI,docs/4.2/modules/qutip/control/pulseoptim.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/control/pulseoptim.html
https://qutip.org/docs/4.2/modules/qutip/control/pulseoptim.html:58274,Security,access,accessible,58274,"any initial / guess pulses generated.; ; ramping_pulse_type : string; Type of pulse used to modulate the control pulse.; It's intended use for a ramping modulation, which is often required in ; experimental setups.; This is only currently implemented in CRAB.; GAUSSIAN_EDGE was added for this purpose.; ; ramping_pulse_params : dict; Parameters for the ramping pulse generator object; The key value pairs are assumed to be attribute name value pairs; They applied after the object is created; ; log_level : integer; level of messaging output from the logger.; Options are attributes of qutip.logging_utils,; in decreasing levels of messaging, are:; DEBUG_INTENSE, DEBUG_VERBOSE, DEBUG, INFO, WARN, ERROR, CRITICAL; Anything WARN or above is effectively 'quiet' execution,; assuming everything runs as expected.; The default NOTSET implies that the level will be taken from; the QuTiP settings file, which by default is WARN. gen_stats : boolean; if set to True then statistics for the optimisation; run will be generated - accessible through attributes; of the stats object. Returns; -------; opt : Optimizer ; Instance of an Optimizer, through which the; Config, Dynamics, PulseGen, and TerminationConditions objects; can be accessed as attributes.; The PropagatorComputer, FidelityComputer and TimeslotComputer objects; can be accessed as attributes of the Dynamics object, e.g. optimizer.dynamics.fid_computer; The optimisation can be run through the optimizer.run_optimization; ; """""". # check parameters; ctrls = dynamics._check_ctrls_container(ctrls); dynamics._check_drift_dyn_gen(drift). if not isinstance(initial, Qobj):; raise TypeError(""initial must be a Qobj""). if not isinstance(target, Qobj):; raise TypeError(""target must be a Qobj""); ; # Deprecated parameter management; if not optim_alg is None:; optim_method = optim_alg; _param_deprecation(; ""The 'optim_alg' parameter is deprecated. ""; ""Use 'optim_method' instead""); ; if not max_metric_corr is None:; if isinstance(method_params,",MatchSource.WIKI,docs/4.2/modules/qutip/control/pulseoptim.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/control/pulseoptim.html
https://qutip.org/docs/4.2/modules/qutip/control/pulseoptim.html:58477,Security,access,accessed,58477,"n, which is often required in ; experimental setups.; This is only currently implemented in CRAB.; GAUSSIAN_EDGE was added for this purpose.; ; ramping_pulse_params : dict; Parameters for the ramping pulse generator object; The key value pairs are assumed to be attribute name value pairs; They applied after the object is created; ; log_level : integer; level of messaging output from the logger.; Options are attributes of qutip.logging_utils,; in decreasing levels of messaging, are:; DEBUG_INTENSE, DEBUG_VERBOSE, DEBUG, INFO, WARN, ERROR, CRITICAL; Anything WARN or above is effectively 'quiet' execution,; assuming everything runs as expected.; The default NOTSET implies that the level will be taken from; the QuTiP settings file, which by default is WARN. gen_stats : boolean; if set to True then statistics for the optimisation; run will be generated - accessible through attributes; of the stats object. Returns; -------; opt : Optimizer ; Instance of an Optimizer, through which the; Config, Dynamics, PulseGen, and TerminationConditions objects; can be accessed as attributes.; The PropagatorComputer, FidelityComputer and TimeslotComputer objects; can be accessed as attributes of the Dynamics object, e.g. optimizer.dynamics.fid_computer; The optimisation can be run through the optimizer.run_optimization; ; """""". # check parameters; ctrls = dynamics._check_ctrls_container(ctrls); dynamics._check_drift_dyn_gen(drift). if not isinstance(initial, Qobj):; raise TypeError(""initial must be a Qobj""). if not isinstance(target, Qobj):; raise TypeError(""target must be a Qobj""); ; # Deprecated parameter management; if not optim_alg is None:; optim_method = optim_alg; _param_deprecation(; ""The 'optim_alg' parameter is deprecated. ""; ""Use 'optim_method' instead""); ; if not max_metric_corr is None:; if isinstance(method_params, dict):; if not 'max_metric_corr' in method_params:; method_params['max_metric_corr'] = max_metric_corr; else:; method_params = {'max_metric_corr':max_metric_corr}",MatchSource.WIKI,docs/4.2/modules/qutip/control/pulseoptim.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/control/pulseoptim.html
https://qutip.org/docs/4.2/modules/qutip/control/pulseoptim.html:58580,Security,access,accessed,58580,"pulse_params : dict; Parameters for the ramping pulse generator object; The key value pairs are assumed to be attribute name value pairs; They applied after the object is created; ; log_level : integer; level of messaging output from the logger.; Options are attributes of qutip.logging_utils,; in decreasing levels of messaging, are:; DEBUG_INTENSE, DEBUG_VERBOSE, DEBUG, INFO, WARN, ERROR, CRITICAL; Anything WARN or above is effectively 'quiet' execution,; assuming everything runs as expected.; The default NOTSET implies that the level will be taken from; the QuTiP settings file, which by default is WARN. gen_stats : boolean; if set to True then statistics for the optimisation; run will be generated - accessible through attributes; of the stats object. Returns; -------; opt : Optimizer ; Instance of an Optimizer, through which the; Config, Dynamics, PulseGen, and TerminationConditions objects; can be accessed as attributes.; The PropagatorComputer, FidelityComputer and TimeslotComputer objects; can be accessed as attributes of the Dynamics object, e.g. optimizer.dynamics.fid_computer; The optimisation can be run through the optimizer.run_optimization; ; """""". # check parameters; ctrls = dynamics._check_ctrls_container(ctrls); dynamics._check_drift_dyn_gen(drift). if not isinstance(initial, Qobj):; raise TypeError(""initial must be a Qobj""). if not isinstance(target, Qobj):; raise TypeError(""target must be a Qobj""); ; # Deprecated parameter management; if not optim_alg is None:; optim_method = optim_alg; _param_deprecation(; ""The 'optim_alg' parameter is deprecated. ""; ""Use 'optim_method' instead""); ; if not max_metric_corr is None:; if isinstance(method_params, dict):; if not 'max_metric_corr' in method_params:; method_params['max_metric_corr'] = max_metric_corr; else:; method_params = {'max_metric_corr':max_metric_corr}; _param_deprecation(; ""The 'max_metric_corr' parameter is deprecated. ""; ""Use 'max_metric_corr' in method_params instead""); ; if not accuracy_factor is",MatchSource.WIKI,docs/4.2/modules/qutip/control/pulseoptim.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/control/pulseoptim.html
https://qutip.org/docs/4.2/modules/qutip/control/pulseoptim.html:4564,Testability,log,logging,4564,"the control pulses by expansions of basis functions, ; where the variables are the coefficients. Typically a Fourier series is chosen, ; i.e. the variables are the Fourier coefficients. ; Therefore it does not need to compute an explicit gradient. ; By default it uses the Nelder-Mead method for fidelity error minimisation. . References; ----------; 1. N Khaneja et. al. ; Optimal control of coupled spin dynamics: Design of NMR pulse sequences ; by gradient ascent algorithms. J. Magn. Reson. 172, 296â305 (2005).; 2. Shai Machnes et.al; DYNAMO - Dynamic Framework for Quantum Optimal Control; arXiv.1011.4874; 3. Doria, P., Calarco, T. & Montangero, S. ; Optimal Control Technique for Many-Body Quantum Dynamics. ; Phys. Rev. Lett. 106, 1â4 (2011).; 4. Caneva, T., Calarco, T. & Montangero, S. ; Chopped random-basis quantum optimization. ; Phys. Rev. A - At. Mol. Opt. Phys. 84, (2011). """"""; import numpy as np; import warnings. # QuTiP; from qutip import Qobj; import qutip.logging_utils as logging; logger = logging.get_logger(); # QuTiP control modules; import qutip.control.optimconfig as optimconfig; import qutip.control.dynamics as dynamics; import qutip.control.termcond as termcond; import qutip.control.optimizer as optimizer; import qutip.control.stats as stats; import qutip.control.errors as errors; import qutip.control.fidcomp as fidcomp; import qutip.control.propcomp as propcomp; import qutip.control.pulsegen as pulsegen; #import qutip.control.pulsegencrab as pulsegencrab. warnings.simplefilter('always', DeprecationWarning) #turn off filter ; def _param_deprecation(message, stacklevel=3):; """"""; Issue deprecation warning; Using stacklevel=3 will ensure message refers the function; calling with the deprecated parameter,; """"""; warnings.warn(message, DeprecationWarning, stacklevel=stacklevel); ; def _upper_safe(s):; try:; s = s.upper(); except:; pass; return s; ; [docs]def optimize_pulse(; drift, ctrls, initial, target,; num_tslots=None, evo_time=None, tau=None,; amp_lboun",MatchSource.WIKI,docs/4.2/modules/qutip/control/pulseoptim.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/control/pulseoptim.html
https://qutip.org/docs/4.2/modules/qutip/control/pulseoptim.html:4573,Testability,log,logger,4573,"the control pulses by expansions of basis functions, ; where the variables are the coefficients. Typically a Fourier series is chosen, ; i.e. the variables are the Fourier coefficients. ; Therefore it does not need to compute an explicit gradient. ; By default it uses the Nelder-Mead method for fidelity error minimisation. . References; ----------; 1. N Khaneja et. al. ; Optimal control of coupled spin dynamics: Design of NMR pulse sequences ; by gradient ascent algorithms. J. Magn. Reson. 172, 296â305 (2005).; 2. Shai Machnes et.al; DYNAMO - Dynamic Framework for Quantum Optimal Control; arXiv.1011.4874; 3. Doria, P., Calarco, T. & Montangero, S. ; Optimal Control Technique for Many-Body Quantum Dynamics. ; Phys. Rev. Lett. 106, 1â4 (2011).; 4. Caneva, T., Calarco, T. & Montangero, S. ; Chopped random-basis quantum optimization. ; Phys. Rev. A - At. Mol. Opt. Phys. 84, (2011). """"""; import numpy as np; import warnings. # QuTiP; from qutip import Qobj; import qutip.logging_utils as logging; logger = logging.get_logger(); # QuTiP control modules; import qutip.control.optimconfig as optimconfig; import qutip.control.dynamics as dynamics; import qutip.control.termcond as termcond; import qutip.control.optimizer as optimizer; import qutip.control.stats as stats; import qutip.control.errors as errors; import qutip.control.fidcomp as fidcomp; import qutip.control.propcomp as propcomp; import qutip.control.pulsegen as pulsegen; #import qutip.control.pulsegencrab as pulsegencrab. warnings.simplefilter('always', DeprecationWarning) #turn off filter ; def _param_deprecation(message, stacklevel=3):; """"""; Issue deprecation warning; Using stacklevel=3 will ensure message refers the function; calling with the deprecated parameter,; """"""; warnings.warn(message, DeprecationWarning, stacklevel=stacklevel); ; def _upper_safe(s):; try:; s = s.upper(); except:; pass; return s; ; [docs]def optimize_pulse(; drift, ctrls, initial, target,; num_tslots=None, evo_time=None, tau=None,; amp_lboun",MatchSource.WIKI,docs/4.2/modules/qutip/control/pulseoptim.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/control/pulseoptim.html
https://qutip.org/docs/4.2/modules/qutip/control/pulseoptim.html:4582,Testability,log,logging,4582,"the control pulses by expansions of basis functions, ; where the variables are the coefficients. Typically a Fourier series is chosen, ; i.e. the variables are the Fourier coefficients. ; Therefore it does not need to compute an explicit gradient. ; By default it uses the Nelder-Mead method for fidelity error minimisation. . References; ----------; 1. N Khaneja et. al. ; Optimal control of coupled spin dynamics: Design of NMR pulse sequences ; by gradient ascent algorithms. J. Magn. Reson. 172, 296â305 (2005).; 2. Shai Machnes et.al; DYNAMO - Dynamic Framework for Quantum Optimal Control; arXiv.1011.4874; 3. Doria, P., Calarco, T. & Montangero, S. ; Optimal Control Technique for Many-Body Quantum Dynamics. ; Phys. Rev. Lett. 106, 1â4 (2011).; 4. Caneva, T., Calarco, T. & Montangero, S. ; Chopped random-basis quantum optimization. ; Phys. Rev. A - At. Mol. Opt. Phys. 84, (2011). """"""; import numpy as np; import warnings. # QuTiP; from qutip import Qobj; import qutip.logging_utils as logging; logger = logging.get_logger(); # QuTiP control modules; import qutip.control.optimconfig as optimconfig; import qutip.control.dynamics as dynamics; import qutip.control.termcond as termcond; import qutip.control.optimizer as optimizer; import qutip.control.stats as stats; import qutip.control.errors as errors; import qutip.control.fidcomp as fidcomp; import qutip.control.propcomp as propcomp; import qutip.control.pulsegen as pulsegen; #import qutip.control.pulsegencrab as pulsegencrab. warnings.simplefilter('always', DeprecationWarning) #turn off filter ; def _param_deprecation(message, stacklevel=3):; """"""; Issue deprecation warning; Using stacklevel=3 will ensure message refers the function; calling with the deprecated parameter,; """"""; warnings.warn(message, DeprecationWarning, stacklevel=stacklevel); ; def _upper_safe(s):; try:; s = s.upper(); except:; pass; return s; ; [docs]def optimize_pulse(; drift, ctrls, initial, target,; num_tslots=None, evo_time=None, tau=None,; amp_lboun",MatchSource.WIKI,docs/4.2/modules/qutip/control/pulseoptim.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/control/pulseoptim.html
https://qutip.org/docs/4.2/modules/qutip/control/pulseoptim.html:6183,Testability,log,logging,6183,"tion(message, stacklevel=3):; """"""; Issue deprecation warning; Using stacklevel=3 will ensure message refers the function; calling with the deprecated parameter,; """"""; warnings.warn(message, DeprecationWarning, stacklevel=stacklevel); ; def _upper_safe(s):; try:; s = s.upper(); except:; pass; return s; ; [docs]def optimize_pulse(; drift, ctrls, initial, target,; num_tslots=None, evo_time=None, tau=None,; amp_lbound=None, amp_ubound=None,; fid_err_targ=1e-10, min_grad=1e-10,; max_iter=500, max_wall_time=180,; alg='GRAPE', alg_params=None,; optim_params=None, optim_method='DEF', method_params=None,; optim_alg=None, max_metric_corr=None, accuracy_factor=None,; dyn_type='GEN_MAT', dyn_params=None,; prop_type='DEF', prop_params=None,; fid_type='DEF', fid_params=None,; phase_option=None, fid_err_scale_factor=None,; tslot_type='DEF', tslot_params=None,; amp_update_mode=None,; init_pulse_type='DEF', init_pulse_params=None,; pulse_scaling=1.0, pulse_offset=0.0,; ramping_pulse_type=None, ramping_pulse_params=None,; log_level=logging.NOTSET, out_file_ext=None, gen_stats=False):; """"""; Optimise a control pulse to minimise the fidelity error.; The dynamics of the system in any given timeslot are governed; by the combined dynamics generator,; i.e. the sum of the drift+ctrl_amp[j]*ctrls[j]; The control pulse is an [n_ts, n_ctrls)] array of piecewise amplitudes; Starting from an intital (typically random) pulse,; a multivariable optimisation algorithm attempts to determines the; optimal values for the control pulse to minimise the fidelity error; The fidelity error is some measure of distance of the system evolution; from the given target evolution in the time allowed for the evolution. Parameters; ----------; drift : Qobj or list of Qobj; the underlying dynamics generator of the system; can provide list (of length num_tslots) for time dependent drift. ctrls : List of Qobj or array like [num_tslots, evo_time]; a list of control dynamics generators. These are scaled by; the amplitudes ",MatchSource.WIKI,docs/4.2/modules/qutip/control/pulseoptim.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/control/pulseoptim.html
https://qutip.org/docs/4.2/modules/qutip/control/pulseoptim.html:13259,Testability,log,logger,13259,"_params : dict; Parameters for the initial / guess pulse generator object; The key value pairs are assumed to be attribute name value pairs; They applied after the object is created. pulse_scaling : float; Linear scale factor for generated initial / guess pulses; By default initial pulses are generated with amplitudes in the; range (-1.0, 1.0). These will be scaled by this parameter. pulse_offset : float; Linear offset for the pulse. That is this value will be added; to any initial / guess pulses generated.; ; ramping_pulse_type : string; Type of pulse used to modulate the control pulse.; It's intended use for a ramping modulation, which is often required in ; experimental setups.; This is only currently implemented in CRAB.; GAUSSIAN_EDGE was added for this purpose.; ; ramping_pulse_params : dict; Parameters for the ramping pulse generator object; The key value pairs are assumed to be attribute name value pairs; They applied after the object is created. log_level : integer; level of messaging output from the logger.; Options are attributes of qutip.logging_utils,; in decreasing levels of messaging, are:; DEBUG_INTENSE, DEBUG_VERBOSE, DEBUG, INFO, WARN, ERROR, CRITICAL; Anything WARN or above is effectively 'quiet' execution,; assuming everything runs as expected.; The default NOTSET implies that the level will be taken from; the QuTiP settings file, which by default is WARN. out_file_ext : string or None; files containing the initial and final control pulse; amplitudes are saved to the current directory.; The default name will be postfixed with this extension; Setting this to None will suppress the output of files. gen_stats : boolean; if set to True then statistics for the optimisation; run will be generated - accessible through attributes; of the stats object. Returns; -------; opt : OptimResult ; Returns instance of OptimResult, which has attributes giving the; reason for termination, final fidelity error, final evolution; final amplitudes, statistics etc; ; """"""",MatchSource.WIKI,docs/4.2/modules/qutip/control/pulseoptim.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/control/pulseoptim.html
https://qutip.org/docs/4.2/modules/qutip/control/pulseoptim.html:14252,Testability,log,logging,14252,"name value pairs; They applied after the object is created. log_level : integer; level of messaging output from the logger.; Options are attributes of qutip.logging_utils,; in decreasing levels of messaging, are:; DEBUG_INTENSE, DEBUG_VERBOSE, DEBUG, INFO, WARN, ERROR, CRITICAL; Anything WARN or above is effectively 'quiet' execution,; assuming everything runs as expected.; The default NOTSET implies that the level will be taken from; the QuTiP settings file, which by default is WARN. out_file_ext : string or None; files containing the initial and final control pulse; amplitudes are saved to the current directory.; The default name will be postfixed with this extension; Setting this to None will suppress the output of files. gen_stats : boolean; if set to True then statistics for the optimisation; run will be generated - accessible through attributes; of the stats object. Returns; -------; opt : OptimResult ; Returns instance of OptimResult, which has attributes giving the; reason for termination, final fidelity error, final evolution; final amplitudes, statistics etc; ; """"""; if log_level == logging.NOTSET:; log_level = logger.getEffectiveLevel(); else:; logger.setLevel(log_level); ; # The parameters types are checked in create_pulse_optimizer; # so no need to do so here; # However, the deprecation management is repeated here; # so that the stack level is correct; if not optim_alg is None:; optim_method = optim_alg; _param_deprecation(; ""The 'optim_alg' parameter is deprecated. ""; ""Use 'optim_method' instead""); ; if not max_metric_corr is None:; if isinstance(method_params, dict):; if not 'max_metric_corr' in method_params:; method_params['max_metric_corr'] = max_metric_corr; else:; method_params = {'max_metric_corr':max_metric_corr}; _param_deprecation(; ""The 'max_metric_corr' parameter is deprecated. ""; ""Use 'max_metric_corr' in method_params instead""); ; if not accuracy_factor is None:; if isinstance(method_params, dict):; if not 'accuracy_factor' in method_params",MatchSource.WIKI,docs/4.2/modules/qutip/control/pulseoptim.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/control/pulseoptim.html
https://qutip.org/docs/4.2/modules/qutip/control/pulseoptim.html:14281,Testability,log,logger,14281,"s are attributes of qutip.logging_utils,; in decreasing levels of messaging, are:; DEBUG_INTENSE, DEBUG_VERBOSE, DEBUG, INFO, WARN, ERROR, CRITICAL; Anything WARN or above is effectively 'quiet' execution,; assuming everything runs as expected.; The default NOTSET implies that the level will be taken from; the QuTiP settings file, which by default is WARN. out_file_ext : string or None; files containing the initial and final control pulse; amplitudes are saved to the current directory.; The default name will be postfixed with this extension; Setting this to None will suppress the output of files. gen_stats : boolean; if set to True then statistics for the optimisation; run will be generated - accessible through attributes; of the stats object. Returns; -------; opt : OptimResult ; Returns instance of OptimResult, which has attributes giving the; reason for termination, final fidelity error, final evolution; final amplitudes, statistics etc; ; """"""; if log_level == logging.NOTSET:; log_level = logger.getEffectiveLevel(); else:; logger.setLevel(log_level); ; # The parameters types are checked in create_pulse_optimizer; # so no need to do so here; # However, the deprecation management is repeated here; # so that the stack level is correct; if not optim_alg is None:; optim_method = optim_alg; _param_deprecation(; ""The 'optim_alg' parameter is deprecated. ""; ""Use 'optim_method' instead""); ; if not max_metric_corr is None:; if isinstance(method_params, dict):; if not 'max_metric_corr' in method_params:; method_params['max_metric_corr'] = max_metric_corr; else:; method_params = {'max_metric_corr':max_metric_corr}; _param_deprecation(; ""The 'max_metric_corr' parameter is deprecated. ""; ""Use 'max_metric_corr' in method_params instead""); ; if not accuracy_factor is None:; if isinstance(method_params, dict):; if not 'accuracy_factor' in method_params:; method_params['accuracy_factor'] = accuracy_factor; else:; method_params = {'accuracy_factor':accuracy_factor}; _param_deprecat",MatchSource.WIKI,docs/4.2/modules/qutip/control/pulseoptim.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/control/pulseoptim.html
https://qutip.org/docs/4.2/modules/qutip/control/pulseoptim.html:14316,Testability,log,logger,14316,"ng_utils,; in decreasing levels of messaging, are:; DEBUG_INTENSE, DEBUG_VERBOSE, DEBUG, INFO, WARN, ERROR, CRITICAL; Anything WARN or above is effectively 'quiet' execution,; assuming everything runs as expected.; The default NOTSET implies that the level will be taken from; the QuTiP settings file, which by default is WARN. out_file_ext : string or None; files containing the initial and final control pulse; amplitudes are saved to the current directory.; The default name will be postfixed with this extension; Setting this to None will suppress the output of files. gen_stats : boolean; if set to True then statistics for the optimisation; run will be generated - accessible through attributes; of the stats object. Returns; -------; opt : OptimResult ; Returns instance of OptimResult, which has attributes giving the; reason for termination, final fidelity error, final evolution; final amplitudes, statistics etc; ; """"""; if log_level == logging.NOTSET:; log_level = logger.getEffectiveLevel(); else:; logger.setLevel(log_level); ; # The parameters types are checked in create_pulse_optimizer; # so no need to do so here; # However, the deprecation management is repeated here; # so that the stack level is correct; if not optim_alg is None:; optim_method = optim_alg; _param_deprecation(; ""The 'optim_alg' parameter is deprecated. ""; ""Use 'optim_method' instead""); ; if not max_metric_corr is None:; if isinstance(method_params, dict):; if not 'max_metric_corr' in method_params:; method_params['max_metric_corr'] = max_metric_corr; else:; method_params = {'max_metric_corr':max_metric_corr}; _param_deprecation(; ""The 'max_metric_corr' parameter is deprecated. ""; ""Use 'max_metric_corr' in method_params instead""); ; if not accuracy_factor is None:; if isinstance(method_params, dict):; if not 'accuracy_factor' in method_params:; method_params['accuracy_factor'] = accuracy_factor; else:; method_params = {'accuracy_factor':accuracy_factor}; _param_deprecation(; ""The 'accuracy_factor' par",MatchSource.WIKI,docs/4.2/modules/qutip/control/pulseoptim.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/control/pulseoptim.html
https://qutip.org/docs/4.2/modules/qutip/control/pulseoptim.html:17639,Testability,log,logging,17639," max_wall_time=max_wall_time,; alg=alg, alg_params=alg_params, optim_params=optim_params,; optim_method=optim_method, method_params=method_params,; dyn_type=dyn_type, dyn_params=dyn_params, ; prop_type=prop_type, prop_params=prop_params,; fid_type=fid_type, fid_params=fid_params,; init_pulse_type=init_pulse_type, init_pulse_params=init_pulse_params,; pulse_scaling=pulse_scaling, pulse_offset=pulse_offset,; ramping_pulse_type=ramping_pulse_type, ; ramping_pulse_params=ramping_pulse_params,; log_level=log_level, gen_stats=gen_stats). dyn = optim.dynamics. dyn.init_timeslots(); # Generate initial pulses for each control; init_amps = np.zeros([dyn.num_tslots, dyn.num_ctrls]); ; if alg == 'CRAB':; for j in range(dyn.num_ctrls):; pgen = optim.pulse_generator[j]; pgen.init_pulse(); init_amps[:, j] = pgen.gen_pulse(); else:; pgen = optim.pulse_generator; for j in range(dyn.num_ctrls):; init_amps[:, j] = pgen.gen_pulse(); ; # Initialise the starting amplitudes; dyn.initialize_controls(init_amps); ; if log_level <= logging.INFO:; msg = ""System configuration:\n""; dg_name = ""dynamics generator""; if dyn_type == 'UNIT':; dg_name = ""Hamiltonian""; if dyn.time_depend_drift:; msg += ""Initial drift {}:\n"".format(dg_name); msg += str(dyn.drift_dyn_gen[0]); else:; msg += ""Drift {}:\n"".format(dg_name); msg += str(dyn.drift_dyn_gen); for j in range(dyn.num_ctrls):; msg += ""\nControl {} {}:\n"".format(j+1, dg_name); msg += str(dyn.ctrl_dyn_gen[j]); msg += ""\nInitial state / operator:\n""; msg += str(dyn.initial); msg += ""\nTarget state / operator:\n""; msg += str(dyn.target); logger.info(msg). if out_file_ext is not None:; # Save initial amplitudes to a text file; pulsefile = ""ctrl_amps_initial_"" + out_file_ext; dyn.save_amps(pulsefile); if log_level <= logging.INFO:; logger.info(""Initial amplitudes output to file: "" + pulsefile). # Start the optimisation; result = optim.run_optimization(). if out_file_ext is not None:; # Save final amplitudes to a text file; pulsefile = ""ctrl_amps_final_"" + ",MatchSource.WIKI,docs/4.2/modules/qutip/control/pulseoptim.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/control/pulseoptim.html
https://qutip.org/docs/4.2/modules/qutip/control/pulseoptim.html:18194,Testability,log,logger,18194,"ots(); # Generate initial pulses for each control; init_amps = np.zeros([dyn.num_tslots, dyn.num_ctrls]); ; if alg == 'CRAB':; for j in range(dyn.num_ctrls):; pgen = optim.pulse_generator[j]; pgen.init_pulse(); init_amps[:, j] = pgen.gen_pulse(); else:; pgen = optim.pulse_generator; for j in range(dyn.num_ctrls):; init_amps[:, j] = pgen.gen_pulse(); ; # Initialise the starting amplitudes; dyn.initialize_controls(init_amps); ; if log_level <= logging.INFO:; msg = ""System configuration:\n""; dg_name = ""dynamics generator""; if dyn_type == 'UNIT':; dg_name = ""Hamiltonian""; if dyn.time_depend_drift:; msg += ""Initial drift {}:\n"".format(dg_name); msg += str(dyn.drift_dyn_gen[0]); else:; msg += ""Drift {}:\n"".format(dg_name); msg += str(dyn.drift_dyn_gen); for j in range(dyn.num_ctrls):; msg += ""\nControl {} {}:\n"".format(j+1, dg_name); msg += str(dyn.ctrl_dyn_gen[j]); msg += ""\nInitial state / operator:\n""; msg += str(dyn.initial); msg += ""\nTarget state / operator:\n""; msg += str(dyn.target); logger.info(msg). if out_file_ext is not None:; # Save initial amplitudes to a text file; pulsefile = ""ctrl_amps_initial_"" + out_file_ext; dyn.save_amps(pulsefile); if log_level <= logging.INFO:; logger.info(""Initial amplitudes output to file: "" + pulsefile). # Start the optimisation; result = optim.run_optimization(). if out_file_ext is not None:; # Save final amplitudes to a text file; pulsefile = ""ctrl_amps_final_"" + out_file_ext; dyn.save_amps(pulsefile); if log_level <= logging.INFO:; logger.info(""Final amplitudes output to file: "" + pulsefile). return result. [docs]def optimize_pulse_unitary(; H_d, H_c, U_0, U_targ,; num_tslots=None, evo_time=None, tau=None,; amp_lbound=None, amp_ubound=None,; fid_err_targ=1e-10, min_grad=1e-10,; max_iter=500, max_wall_time=180,; alg='GRAPE', alg_params=None,; optim_params=None, optim_method='DEF', method_params=None,; optim_alg=None, max_metric_corr=None, accuracy_factor=None,; phase_option='PSU', ; dyn_params=None, prop_params=None, fid_params",MatchSource.WIKI,docs/4.2/modules/qutip/control/pulseoptim.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/control/pulseoptim.html
https://qutip.org/docs/4.2/modules/qutip/control/pulseoptim.html:18375,Testability,log,logging,18375,"ptim.pulse_generator[j]; pgen.init_pulse(); init_amps[:, j] = pgen.gen_pulse(); else:; pgen = optim.pulse_generator; for j in range(dyn.num_ctrls):; init_amps[:, j] = pgen.gen_pulse(); ; # Initialise the starting amplitudes; dyn.initialize_controls(init_amps); ; if log_level <= logging.INFO:; msg = ""System configuration:\n""; dg_name = ""dynamics generator""; if dyn_type == 'UNIT':; dg_name = ""Hamiltonian""; if dyn.time_depend_drift:; msg += ""Initial drift {}:\n"".format(dg_name); msg += str(dyn.drift_dyn_gen[0]); else:; msg += ""Drift {}:\n"".format(dg_name); msg += str(dyn.drift_dyn_gen); for j in range(dyn.num_ctrls):; msg += ""\nControl {} {}:\n"".format(j+1, dg_name); msg += str(dyn.ctrl_dyn_gen[j]); msg += ""\nInitial state / operator:\n""; msg += str(dyn.initial); msg += ""\nTarget state / operator:\n""; msg += str(dyn.target); logger.info(msg). if out_file_ext is not None:; # Save initial amplitudes to a text file; pulsefile = ""ctrl_amps_initial_"" + out_file_ext; dyn.save_amps(pulsefile); if log_level <= logging.INFO:; logger.info(""Initial amplitudes output to file: "" + pulsefile). # Start the optimisation; result = optim.run_optimization(). if out_file_ext is not None:; # Save final amplitudes to a text file; pulsefile = ""ctrl_amps_final_"" + out_file_ext; dyn.save_amps(pulsefile); if log_level <= logging.INFO:; logger.info(""Final amplitudes output to file: "" + pulsefile). return result. [docs]def optimize_pulse_unitary(; H_d, H_c, U_0, U_targ,; num_tslots=None, evo_time=None, tau=None,; amp_lbound=None, amp_ubound=None,; fid_err_targ=1e-10, min_grad=1e-10,; max_iter=500, max_wall_time=180,; alg='GRAPE', alg_params=None,; optim_params=None, optim_method='DEF', method_params=None,; optim_alg=None, max_metric_corr=None, accuracy_factor=None,; phase_option='PSU', ; dyn_params=None, prop_params=None, fid_params=None,; tslot_type='DEF', tslot_params=None,; amp_update_mode=None,; init_pulse_type='DEF', init_pulse_params=None,; pulse_scaling=1.0, pulse_offset=0.0,; ramping_puls",MatchSource.WIKI,docs/4.2/modules/qutip/control/pulseoptim.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/control/pulseoptim.html
https://qutip.org/docs/4.2/modules/qutip/control/pulseoptim.html:18390,Testability,log,logger,18390,"init_pulse(); init_amps[:, j] = pgen.gen_pulse(); else:; pgen = optim.pulse_generator; for j in range(dyn.num_ctrls):; init_amps[:, j] = pgen.gen_pulse(); ; # Initialise the starting amplitudes; dyn.initialize_controls(init_amps); ; if log_level <= logging.INFO:; msg = ""System configuration:\n""; dg_name = ""dynamics generator""; if dyn_type == 'UNIT':; dg_name = ""Hamiltonian""; if dyn.time_depend_drift:; msg += ""Initial drift {}:\n"".format(dg_name); msg += str(dyn.drift_dyn_gen[0]); else:; msg += ""Drift {}:\n"".format(dg_name); msg += str(dyn.drift_dyn_gen); for j in range(dyn.num_ctrls):; msg += ""\nControl {} {}:\n"".format(j+1, dg_name); msg += str(dyn.ctrl_dyn_gen[j]); msg += ""\nInitial state / operator:\n""; msg += str(dyn.initial); msg += ""\nTarget state / operator:\n""; msg += str(dyn.target); logger.info(msg). if out_file_ext is not None:; # Save initial amplitudes to a text file; pulsefile = ""ctrl_amps_initial_"" + out_file_ext; dyn.save_amps(pulsefile); if log_level <= logging.INFO:; logger.info(""Initial amplitudes output to file: "" + pulsefile). # Start the optimisation; result = optim.run_optimization(). if out_file_ext is not None:; # Save final amplitudes to a text file; pulsefile = ""ctrl_amps_final_"" + out_file_ext; dyn.save_amps(pulsefile); if log_level <= logging.INFO:; logger.info(""Final amplitudes output to file: "" + pulsefile). return result. [docs]def optimize_pulse_unitary(; H_d, H_c, U_0, U_targ,; num_tslots=None, evo_time=None, tau=None,; amp_lbound=None, amp_ubound=None,; fid_err_targ=1e-10, min_grad=1e-10,; max_iter=500, max_wall_time=180,; alg='GRAPE', alg_params=None,; optim_params=None, optim_method='DEF', method_params=None,; optim_alg=None, max_metric_corr=None, accuracy_factor=None,; phase_option='PSU', ; dyn_params=None, prop_params=None, fid_params=None,; tslot_type='DEF', tslot_params=None,; amp_update_mode=None,; init_pulse_type='DEF', init_pulse_params=None,; pulse_scaling=1.0, pulse_offset=0.0,; ramping_pulse_type=None, ramping_pulse_par",MatchSource.WIKI,docs/4.2/modules/qutip/control/pulseoptim.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/control/pulseoptim.html
https://qutip.org/docs/4.2/modules/qutip/control/pulseoptim.html:18674,Testability,log,logging,18674," ""System configuration:\n""; dg_name = ""dynamics generator""; if dyn_type == 'UNIT':; dg_name = ""Hamiltonian""; if dyn.time_depend_drift:; msg += ""Initial drift {}:\n"".format(dg_name); msg += str(dyn.drift_dyn_gen[0]); else:; msg += ""Drift {}:\n"".format(dg_name); msg += str(dyn.drift_dyn_gen); for j in range(dyn.num_ctrls):; msg += ""\nControl {} {}:\n"".format(j+1, dg_name); msg += str(dyn.ctrl_dyn_gen[j]); msg += ""\nInitial state / operator:\n""; msg += str(dyn.initial); msg += ""\nTarget state / operator:\n""; msg += str(dyn.target); logger.info(msg). if out_file_ext is not None:; # Save initial amplitudes to a text file; pulsefile = ""ctrl_amps_initial_"" + out_file_ext; dyn.save_amps(pulsefile); if log_level <= logging.INFO:; logger.info(""Initial amplitudes output to file: "" + pulsefile). # Start the optimisation; result = optim.run_optimization(). if out_file_ext is not None:; # Save final amplitudes to a text file; pulsefile = ""ctrl_amps_final_"" + out_file_ext; dyn.save_amps(pulsefile); if log_level <= logging.INFO:; logger.info(""Final amplitudes output to file: "" + pulsefile). return result. [docs]def optimize_pulse_unitary(; H_d, H_c, U_0, U_targ,; num_tslots=None, evo_time=None, tau=None,; amp_lbound=None, amp_ubound=None,; fid_err_targ=1e-10, min_grad=1e-10,; max_iter=500, max_wall_time=180,; alg='GRAPE', alg_params=None,; optim_params=None, optim_method='DEF', method_params=None,; optim_alg=None, max_metric_corr=None, accuracy_factor=None,; phase_option='PSU', ; dyn_params=None, prop_params=None, fid_params=None,; tslot_type='DEF', tslot_params=None,; amp_update_mode=None,; init_pulse_type='DEF', init_pulse_params=None,; pulse_scaling=1.0, pulse_offset=0.0,; ramping_pulse_type=None, ramping_pulse_params=None,; log_level=logging.NOTSET, out_file_ext=None, gen_stats=False):. """"""; Optimise a control pulse to minimise the fidelity error, assuming that; the dynamics of the system are generated by unitary operators.; This function is simply a wrapper for optimize_pulse,",MatchSource.WIKI,docs/4.2/modules/qutip/control/pulseoptim.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/control/pulseoptim.html
https://qutip.org/docs/4.2/modules/qutip/control/pulseoptim.html:18689,Testability,log,logger,18689,"_name = ""dynamics generator""; if dyn_type == 'UNIT':; dg_name = ""Hamiltonian""; if dyn.time_depend_drift:; msg += ""Initial drift {}:\n"".format(dg_name); msg += str(dyn.drift_dyn_gen[0]); else:; msg += ""Drift {}:\n"".format(dg_name); msg += str(dyn.drift_dyn_gen); for j in range(dyn.num_ctrls):; msg += ""\nControl {} {}:\n"".format(j+1, dg_name); msg += str(dyn.ctrl_dyn_gen[j]); msg += ""\nInitial state / operator:\n""; msg += str(dyn.initial); msg += ""\nTarget state / operator:\n""; msg += str(dyn.target); logger.info(msg). if out_file_ext is not None:; # Save initial amplitudes to a text file; pulsefile = ""ctrl_amps_initial_"" + out_file_ext; dyn.save_amps(pulsefile); if log_level <= logging.INFO:; logger.info(""Initial amplitudes output to file: "" + pulsefile). # Start the optimisation; result = optim.run_optimization(). if out_file_ext is not None:; # Save final amplitudes to a text file; pulsefile = ""ctrl_amps_final_"" + out_file_ext; dyn.save_amps(pulsefile); if log_level <= logging.INFO:; logger.info(""Final amplitudes output to file: "" + pulsefile). return result. [docs]def optimize_pulse_unitary(; H_d, H_c, U_0, U_targ,; num_tslots=None, evo_time=None, tau=None,; amp_lbound=None, amp_ubound=None,; fid_err_targ=1e-10, min_grad=1e-10,; max_iter=500, max_wall_time=180,; alg='GRAPE', alg_params=None,; optim_params=None, optim_method='DEF', method_params=None,; optim_alg=None, max_metric_corr=None, accuracy_factor=None,; phase_option='PSU', ; dyn_params=None, prop_params=None, fid_params=None,; tslot_type='DEF', tslot_params=None,; amp_update_mode=None,; init_pulse_type='DEF', init_pulse_params=None,; pulse_scaling=1.0, pulse_offset=0.0,; ramping_pulse_type=None, ramping_pulse_params=None,; log_level=logging.NOTSET, out_file_ext=None, gen_stats=False):. """"""; Optimise a control pulse to minimise the fidelity error, assuming that; the dynamics of the system are generated by unitary operators.; This function is simply a wrapper for optimize_pulse, where the; appropriate option",MatchSource.WIKI,docs/4.2/modules/qutip/control/pulseoptim.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/control/pulseoptim.html
https://qutip.org/docs/4.2/modules/qutip/control/pulseoptim.html:19411,Testability,log,logging,19411,"g.INFO:; logger.info(""Initial amplitudes output to file: "" + pulsefile). # Start the optimisation; result = optim.run_optimization(). if out_file_ext is not None:; # Save final amplitudes to a text file; pulsefile = ""ctrl_amps_final_"" + out_file_ext; dyn.save_amps(pulsefile); if log_level <= logging.INFO:; logger.info(""Final amplitudes output to file: "" + pulsefile). return result. [docs]def optimize_pulse_unitary(; H_d, H_c, U_0, U_targ,; num_tslots=None, evo_time=None, tau=None,; amp_lbound=None, amp_ubound=None,; fid_err_targ=1e-10, min_grad=1e-10,; max_iter=500, max_wall_time=180,; alg='GRAPE', alg_params=None,; optim_params=None, optim_method='DEF', method_params=None,; optim_alg=None, max_metric_corr=None, accuracy_factor=None,; phase_option='PSU', ; dyn_params=None, prop_params=None, fid_params=None,; tslot_type='DEF', tslot_params=None,; amp_update_mode=None,; init_pulse_type='DEF', init_pulse_params=None,; pulse_scaling=1.0, pulse_offset=0.0,; ramping_pulse_type=None, ramping_pulse_params=None,; log_level=logging.NOTSET, out_file_ext=None, gen_stats=False):. """"""; Optimise a control pulse to minimise the fidelity error, assuming that; the dynamics of the system are generated by unitary operators.; This function is simply a wrapper for optimize_pulse, where the; appropriate options for unitary dynamics are chosen and the parameter; names are in the format familiar to unitary dynamics; The dynamics of the system in any given timeslot are governed; by the combined Hamiltonian,; i.e. the sum of the H_d + ctrl_amp[j]*H_c[j]; The control pulse is an [n_ts, n_ctrls] array of piecewise amplitudes; Starting from an intital (typically random) pulse,; a multivariable optimisation algorithm attempts to determines the; optimal values for the control pulse to minimise the fidelity error; The maximum fidelity for a unitary system is 1, i.e. when the; time evolution resulting from the pulse is equivalent to the target.; And therefore the fidelity error is 1 - fidelity. Param",MatchSource.WIKI,docs/4.2/modules/qutip/control/pulseoptim.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/control/pulseoptim.html
https://qutip.org/docs/4.2/modules/qutip/control/pulseoptim.html:26155,Testability,log,logger,26155,"_params : dict; Parameters for the initial / guess pulse generator object; The key value pairs are assumed to be attribute name value pairs; They applied after the object is created. pulse_scaling : float; Linear scale factor for generated initial / guess pulses; By default initial pulses are generated with amplitudes in the; range (-1.0, 1.0). These will be scaled by this parameter. pulse_offset : float; Linear offset for the pulse. That is this value will be added; to any initial / guess pulses generated.; ; ramping_pulse_type : string; Type of pulse used to modulate the control pulse.; It's intended use for a ramping modulation, which is often required in ; experimental setups.; This is only currently implemented in CRAB.; GAUSSIAN_EDGE was added for this purpose.; ; ramping_pulse_params : dict; Parameters for the ramping pulse generator object; The key value pairs are assumed to be attribute name value pairs; They applied after the object is created. log_level : integer; level of messaging output from the logger.; Options are attributes of qutip.logging_utils,; in decreasing levels of messaging, are:; DEBUG_INTENSE, DEBUG_VERBOSE, DEBUG, INFO, WARN, ERROR, CRITICAL; Anything WARN or above is effectively 'quiet' execution,; assuming everything runs as expected.; The default NOTSET implies that the level will be taken from; the QuTiP settings file, which by default is WARN. out_file_ext : string or None; files containing the initial and final control pulse; amplitudes are saved to the current directory.; The default name will be postfixed with this extension; Setting this to None will suppress the output of files. gen_stats : boolean; if set to True then statistics for the optimisation; run will be generated - accessible through attributes; of the stats object. Returns; -------; opt : OptimResult; Returns instance of OptimResult, which has attributes giving the; reason for termination, final fidelity error, final evolution; final amplitudes, statistics etc; ; """""".",MatchSource.WIKI,docs/4.2/modules/qutip/control/pulseoptim.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/control/pulseoptim.html
https://qutip.org/docs/4.2/modules/qutip/control/pulseoptim.html:30111,Testability,log,logging,30111,"method_params,; dyn_type='UNIT', dyn_params=dyn_params,; prop_params=prop_params, fid_params=fid_params,; init_pulse_type=init_pulse_type, init_pulse_params=init_pulse_params,; pulse_scaling=pulse_scaling, pulse_offset=pulse_offset,; ramping_pulse_type=ramping_pulse_type, ; ramping_pulse_params=ramping_pulse_params,; log_level=log_level, out_file_ext=out_file_ext,; gen_stats=gen_stats); ; [docs]def opt_pulse_crab(; drift, ctrls, initial, target,; num_tslots=None, evo_time=None, tau=None,; amp_lbound=None, amp_ubound=None,; fid_err_targ=1e-5,; max_iter=500, max_wall_time=180,; alg_params=None,; num_coeffs=None, init_coeff_scaling=1.0, ; optim_params=None, optim_method='fmin', method_params=None,; dyn_type='GEN_MAT', dyn_params=None,; prop_type='DEF', prop_params=None,; fid_type='DEF', fid_params=None,; tslot_type='DEF', tslot_params=None,; guess_pulse_type=None, guess_pulse_params=None,; guess_pulse_scaling=1.0, guess_pulse_offset=0.0,; guess_pulse_action='MODULATE', ; ramping_pulse_type=None, ramping_pulse_params=None,; log_level=logging.NOTSET, out_file_ext=None, gen_stats=False):; """"""; Optimise a control pulse to minimise the fidelity error.; The dynamics of the system in any given timeslot are governed; by the combined dynamics generator,; i.e. the sum of the drift+ctrl_amp[j]*ctrls[j]; The control pulse is an [n_ts, n_ctrls] array of piecewise amplitudes.; The CRAB algorithm uses basis function coefficents as the variables to; optimise. It does NOT use any gradient function.; A multivariable optimisation algorithm attempts to determines the; optimal values for the control pulse to minimise the fidelity error; The fidelity error is some measure of distance of the system evolution; from the given target evolution in the time allowed for the evolution. Parameters; ----------; drift : Qobj or list of Qobj; the underlying dynamics generator of the system; can provide list (of length num_tslots) for time dependent drift. ctrls : List of Qobj or array like [num_tslots,",MatchSource.WIKI,docs/4.2/modules/qutip/control/pulseoptim.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/control/pulseoptim.html
https://qutip.org/docs/4.2/modules/qutip/control/pulseoptim.html:33465,Testability,test,tested,33465,"um allowed elapsed time for the optimisation algorithm. alg_params : Dictionary; options that are specific to the algorithm see above; ; optim_params : Dictionary; The key value pairs are the attribute name and value; used to set attribute values; Note: attributes are created if they do not exist already,; and are overwritten if they do.; Note: method_params are applied afterwards and so may override these. coeff_scaling : float; Linear scale factor for the random basis coefficients; By default these range from -1.0 to 1.0; Note this is overridden by alg_params (if given there); ; num_coeffs : integer; Number of coefficients used for each basis function; Note this is calculated automatically based on the dimension of the; dynamics if not given. It is crucial to the performane of the ; algorithm that it is set as low as possible, while still giving; high enough frequencies.; Note this is overridden by alg_params (if given there); ; optim_method : string; Multi-variable optimisation method; The only tested options are 'fmin' and 'Nelder-mead'; In theory any non-gradient method implemented in ; scipy.optimize.mininize could be used. method_params : dict; Parameters for the optim_method. ; Note that where there is an attribute of the; Optimizer object or the termination_conditions matching the key ; that attribute. Otherwise, and in some case also, ; they are assumed to be method_options; for the scipy.optimize.minimize method.; The commonly used parameter are:; xtol - limit on variable change for convergence; ftol - limit on fidelity error change for convergence; ; dyn_type : string; Dynamics type, i.e. the type of matrix used to describe; the dynamics. Options are UNIT, GEN_MAT, SYMPL; (see Dynamics classes for details); ; dyn_params : dict; Parameters for the Dynamics object; The key value pairs are assumed to be attribute name value pairs; They applied after the object is created. prop_type : string; Propagator type i.e. the method used to calculate the; propagtors ",MatchSource.WIKI,docs/4.2/modules/qutip/control/pulseoptim.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/control/pulseoptim.html
https://qutip.org/docs/4.2/modules/qutip/control/pulseoptim.html:36996,Testability,log,logger,36996,"d after the object is created; ; guess_pulse_action : string; Determines how the guess pulse is applied to the pulse generated; by the basis expansion.; Options are: MODULATE, ADD ; Default is MODULATE. pulse_scaling : float; Linear scale factor for generated guess pulses; By default initial pulses are generated with amplitudes in the; range (-1.0, 1.0). These will be scaled by this parameter. pulse_offset : float; Linear offset for the pulse. That is this value will be added; to any guess pulses generated.; ; ramping_pulse_type : string; Type of pulse used to modulate the control pulse.; It's intended use for a ramping modulation, which is often required in ; experimental setups.; This is only currently implemented in CRAB.; GAUSSIAN_EDGE was added for this purpose.; ; ramping_pulse_params : dict; Parameters for the ramping pulse generator object; The key value pairs are assumed to be attribute name value pairs; They applied after the object is created. log_level : integer; level of messaging output from the logger.; Options are attributes of qutip.logging_utils,; in decreasing levels of messaging, are:; DEBUG_INTENSE, DEBUG_VERBOSE, DEBUG, INFO, WARN, ERROR, CRITICAL; Anything WARN or above is effectively 'quiet' execution,; assuming everything runs as expected.; The default NOTSET implies that the level will be taken from; the QuTiP settings file, which by default is WARN. out_file_ext : string or None; files containing the initial and final control pulse; amplitudes are saved to the current directory.; The default name will be postfixed with this extension; Setting this to None will suppress the output of files. gen_stats : boolean; if set to True then statistics for the optimisation; run will be generated - accessible through attributes; of the stats object. Returns; -------; opt : OptimResult ; Returns instance of OptimResult, which has attributes giving the; reason for termination, final fidelity error, final evolution; final amplitudes, statistics etc; ; """"""",MatchSource.WIKI,docs/4.2/modules/qutip/control/pulseoptim.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/control/pulseoptim.html
https://qutip.org/docs/4.2/modules/qutip/control/pulseoptim.html:38073,Testability,log,logging,38073,"evels of messaging, are:; DEBUG_INTENSE, DEBUG_VERBOSE, DEBUG, INFO, WARN, ERROR, CRITICAL; Anything WARN or above is effectively 'quiet' execution,; assuming everything runs as expected.; The default NOTSET implies that the level will be taken from; the QuTiP settings file, which by default is WARN. out_file_ext : string or None; files containing the initial and final control pulse; amplitudes are saved to the current directory.; The default name will be postfixed with this extension; Setting this to None will suppress the output of files. gen_stats : boolean; if set to True then statistics for the optimisation; run will be generated - accessible through attributes; of the stats object. Returns; -------; opt : OptimResult ; Returns instance of OptimResult, which has attributes giving the; reason for termination, final fidelity error, final evolution; final amplitudes, statistics etc; ; """""". # The parameters are checked in create_pulse_optimizer; # so no need to do so here. if log_level == logging.NOTSET:; log_level = logger.getEffectiveLevel(); else:; logger.setLevel(log_level). # build the algorithm options; if not isinstance(alg_params, dict): ; alg_params = {'num_coeffs':num_coeffs, ; 'init_coeff_scaling':init_coeff_scaling}; else:; if (num_coeffs is not None and ; not 'num_coeffs' in alg_params):; alg_params['num_coeffs'] = num_coeffs; if (init_coeff_scaling is not None and ; not 'init_coeff_scaling' in alg_params):; alg_params['init_coeff_scaling'] = init_coeff_scaling; ; # Build the guess pulse options; # Any options passed in the guess_pulse_params take precedence; # over the parameter values.; if guess_pulse_type: ; if not isinstance(guess_pulse_params, dict):; guess_pulse_params = {}; if (guess_pulse_scaling is not None and ; not 'scaling' in guess_pulse_params):; guess_pulse_params['scaling'] = guess_pulse_scaling; if (guess_pulse_offset is not None and ; not 'offset' in guess_pulse_params):; guess_pulse_params['offset'] = guess_pulse_offset; if (guess_pul",MatchSource.WIKI,docs/4.2/modules/qutip/control/pulseoptim.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/control/pulseoptim.html
https://qutip.org/docs/4.2/modules/qutip/control/pulseoptim.html:38102,Testability,log,logger,38102,"EBUG_INTENSE, DEBUG_VERBOSE, DEBUG, INFO, WARN, ERROR, CRITICAL; Anything WARN or above is effectively 'quiet' execution,; assuming everything runs as expected.; The default NOTSET implies that the level will be taken from; the QuTiP settings file, which by default is WARN. out_file_ext : string or None; files containing the initial and final control pulse; amplitudes are saved to the current directory.; The default name will be postfixed with this extension; Setting this to None will suppress the output of files. gen_stats : boolean; if set to True then statistics for the optimisation; run will be generated - accessible through attributes; of the stats object. Returns; -------; opt : OptimResult ; Returns instance of OptimResult, which has attributes giving the; reason for termination, final fidelity error, final evolution; final amplitudes, statistics etc; ; """""". # The parameters are checked in create_pulse_optimizer; # so no need to do so here. if log_level == logging.NOTSET:; log_level = logger.getEffectiveLevel(); else:; logger.setLevel(log_level). # build the algorithm options; if not isinstance(alg_params, dict): ; alg_params = {'num_coeffs':num_coeffs, ; 'init_coeff_scaling':init_coeff_scaling}; else:; if (num_coeffs is not None and ; not 'num_coeffs' in alg_params):; alg_params['num_coeffs'] = num_coeffs; if (init_coeff_scaling is not None and ; not 'init_coeff_scaling' in alg_params):; alg_params['init_coeff_scaling'] = init_coeff_scaling; ; # Build the guess pulse options; # Any options passed in the guess_pulse_params take precedence; # over the parameter values.; if guess_pulse_type: ; if not isinstance(guess_pulse_params, dict):; guess_pulse_params = {}; if (guess_pulse_scaling is not None and ; not 'scaling' in guess_pulse_params):; guess_pulse_params['scaling'] = guess_pulse_scaling; if (guess_pulse_offset is not None and ; not 'offset' in guess_pulse_params):; guess_pulse_params['offset'] = guess_pulse_offset; if (guess_pulse_action is not None and ",MatchSource.WIKI,docs/4.2/modules/qutip/control/pulseoptim.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/control/pulseoptim.html
https://qutip.org/docs/4.2/modules/qutip/control/pulseoptim.html:38137,Testability,log,logger,38137,"BUG, INFO, WARN, ERROR, CRITICAL; Anything WARN or above is effectively 'quiet' execution,; assuming everything runs as expected.; The default NOTSET implies that the level will be taken from; the QuTiP settings file, which by default is WARN. out_file_ext : string or None; files containing the initial and final control pulse; amplitudes are saved to the current directory.; The default name will be postfixed with this extension; Setting this to None will suppress the output of files. gen_stats : boolean; if set to True then statistics for the optimisation; run will be generated - accessible through attributes; of the stats object. Returns; -------; opt : OptimResult ; Returns instance of OptimResult, which has attributes giving the; reason for termination, final fidelity error, final evolution; final amplitudes, statistics etc; ; """""". # The parameters are checked in create_pulse_optimizer; # so no need to do so here. if log_level == logging.NOTSET:; log_level = logger.getEffectiveLevel(); else:; logger.setLevel(log_level). # build the algorithm options; if not isinstance(alg_params, dict): ; alg_params = {'num_coeffs':num_coeffs, ; 'init_coeff_scaling':init_coeff_scaling}; else:; if (num_coeffs is not None and ; not 'num_coeffs' in alg_params):; alg_params['num_coeffs'] = num_coeffs; if (init_coeff_scaling is not None and ; not 'init_coeff_scaling' in alg_params):; alg_params['init_coeff_scaling'] = init_coeff_scaling; ; # Build the guess pulse options; # Any options passed in the guess_pulse_params take precedence; # over the parameter values.; if guess_pulse_type: ; if not isinstance(guess_pulse_params, dict):; guess_pulse_params = {}; if (guess_pulse_scaling is not None and ; not 'scaling' in guess_pulse_params):; guess_pulse_params['scaling'] = guess_pulse_scaling; if (guess_pulse_offset is not None and ; not 'offset' in guess_pulse_params):; guess_pulse_params['offset'] = guess_pulse_offset; if (guess_pulse_action is not None and ; not 'pulse_action' in guess_pu",MatchSource.WIKI,docs/4.2/modules/qutip/control/pulseoptim.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/control/pulseoptim.html
https://qutip.org/docs/4.2/modules/qutip/control/pulseoptim.html:40604,Testability,log,logging,40604,"arams,; dyn_type=dyn_type, dyn_params=dyn_params, ; prop_type=prop_type, prop_params=prop_params,; fid_type=fid_type, fid_params=fid_params,; tslot_type=tslot_type, tslot_params=tslot_params,; init_pulse_type=guess_pulse_type, ; init_pulse_params=guess_pulse_params,; ramping_pulse_type=ramping_pulse_type, ; ramping_pulse_params=ramping_pulse_params,; log_level=log_level, out_file_ext=out_file_ext, gen_stats=gen_stats); ; [docs]def opt_pulse_crab_unitary(; H_d, H_c, U_0, U_targ,; num_tslots=None, evo_time=None, tau=None,; amp_lbound=None, amp_ubound=None,; fid_err_targ=1e-5,; max_iter=500, max_wall_time=180,; alg_params=None,; num_coeffs=None, init_coeff_scaling=1.0, ; optim_params=None, optim_method='fmin', method_params=None,; phase_option='PSU', ; dyn_params=None, prop_params=None, fid_params=None,; tslot_type='DEF', tslot_params=None,; guess_pulse_type=None, guess_pulse_params=None,; guess_pulse_scaling=1.0, guess_pulse_offset=0.0,; guess_pulse_action='MODULATE', ; ramping_pulse_type=None, ramping_pulse_params=None,; log_level=logging.NOTSET, out_file_ext=None, gen_stats=False):; """"""; Optimise a control pulse to minimise the fidelity error, assuming that; the dynamics of the system are generated by unitary operators.; This function is simply a wrapper for optimize_pulse, where the; appropriate options for unitary dynamics are chosen and the parameter; names are in the format familiar to unitary dynamics; The dynamics of the system in any given timeslot are governed; by the combined Hamiltonian,; i.e. the sum of the H_d + ctrl_amp[j]*H_c[j]; The control pulse is an [n_ts, n_ctrls] array of piecewise amplitudes; ; The CRAB algorithm uses basis function coefficents as the variables to; optimise. It does NOT use any gradient function.; A multivariable optimisation algorithm attempts to determines the; optimal values for the control pulse to minimise the fidelity error; The fidelity error is some measure of distance of the system evolution; from the given target evolu",MatchSource.WIKI,docs/4.2/modules/qutip/control/pulseoptim.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/control/pulseoptim.html
https://qutip.org/docs/4.2/modules/qutip/control/pulseoptim.html:44215,Testability,test,tested,44215,"um allowed elapsed time for the optimisation algorithm. alg_params : Dictionary; options that are specific to the algorithm see above; ; optim_params : Dictionary; The key value pairs are the attribute name and value; used to set attribute values; Note: attributes are created if they do not exist already,; and are overwritten if they do.; Note: method_params are applied afterwards and so may override these. coeff_scaling : float; Linear scale factor for the random basis coefficients; By default these range from -1.0 to 1.0; Note this is overridden by alg_params (if given there); ; num_coeffs : integer; Number of coefficients used for each basis function; Note this is calculated automatically based on the dimension of the; dynamics if not given. It is crucial to the performane of the ; algorithm that it is set as low as possible, while still giving; high enough frequencies.; Note this is overridden by alg_params (if given there); ; optim_method : string; Multi-variable optimisation method; The only tested options are 'fmin' and 'Nelder-mead'; In theory any non-gradient method implemented in ; scipy.optimize.mininize could be used. method_params : dict; Parameters for the optim_method. ; Note that where there is an attribute of the; Optimizer object or the termination_conditions matching the key ; that attribute. Otherwise, and in some case also, ; they are assumed to be method_options; for the scipy.optimize.minimize method.; The commonly used parameter are:; xtol - limit on variable change for convergence; ftol - limit on fidelity error change for convergence. phase_option : string; determines how global phase is treated in fidelity; calculations (fid_type='UNIT' only). Options:; PSU - global phase ignored; SU - global phase included. dyn_params : dict; Parameters for the Dynamics object; The key value pairs are assumed to be attribute name value pairs; They applied after the object is created. prop_params : dict; Parameters for the PropagatorComputer object; The ke",MatchSource.WIKI,docs/4.2/modules/qutip/control/pulseoptim.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/control/pulseoptim.html
https://qutip.org/docs/4.2/modules/qutip/control/pulseoptim.html:47258,Testability,log,logger,47258,"d after the object is created; ; guess_pulse_action : string; Determines how the guess pulse is applied to the pulse generated; by the basis expansion.; Options are: MODULATE, ADD ; Default is MODULATE. pulse_scaling : float; Linear scale factor for generated guess pulses; By default initial pulses are generated with amplitudes in the; range (-1.0, 1.0). These will be scaled by this parameter. pulse_offset : float; Linear offset for the pulse. That is this value will be added; to any guess pulses generated.; ; ramping_pulse_type : string; Type of pulse used to modulate the control pulse.; It's intended use for a ramping modulation, which is often required in ; experimental setups.; This is only currently implemented in CRAB.; GAUSSIAN_EDGE was added for this purpose.; ; ramping_pulse_params : dict; Parameters for the ramping pulse generator object; The key value pairs are assumed to be attribute name value pairs; They applied after the object is created. log_level : integer; level of messaging output from the logger.; Options are attributes of qutip.logging_utils,; in decreasing levels of messaging, are:; DEBUG_INTENSE, DEBUG_VERBOSE, DEBUG, INFO, WARN, ERROR, CRITICAL; Anything WARN or above is effectively 'quiet' execution,; assuming everything runs as expected.; The default NOTSET implies that the level will be taken from; the QuTiP settings file, which by default is WARN. out_file_ext : string or None; files containing the initial and final control pulse; amplitudes are saved to the current directory.; The default name will be postfixed with this extension; Setting this to None will suppress the output of files. gen_stats : boolean; if set to True then statistics for the optimisation; run will be generated - accessible through attributes; of the stats object. Returns; -------; opt : OptimResult ; Returns instance of OptimResult, which has attributes giving the; reason for termination, final fidelity error, final evolution; final amplitudes, statistics etc; ; """"""",MatchSource.WIKI,docs/4.2/modules/qutip/control/pulseoptim.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/control/pulseoptim.html
https://qutip.org/docs/4.2/modules/qutip/control/pulseoptim.html:48335,Testability,log,logging,48335,"evels of messaging, are:; DEBUG_INTENSE, DEBUG_VERBOSE, DEBUG, INFO, WARN, ERROR, CRITICAL; Anything WARN or above is effectively 'quiet' execution,; assuming everything runs as expected.; The default NOTSET implies that the level will be taken from; the QuTiP settings file, which by default is WARN. out_file_ext : string or None; files containing the initial and final control pulse; amplitudes are saved to the current directory.; The default name will be postfixed with this extension; Setting this to None will suppress the output of files. gen_stats : boolean; if set to True then statistics for the optimisation; run will be generated - accessible through attributes; of the stats object. Returns; -------; opt : OptimResult ; Returns instance of OptimResult, which has attributes giving the; reason for termination, final fidelity error, final evolution; final amplitudes, statistics etc; ; """""". # The parameters are checked in create_pulse_optimizer; # so no need to do so here. if log_level == logging.NOTSET:; log_level = logger.getEffectiveLevel(); else:; logger.setLevel(log_level). # build the algorithm options; if not isinstance(alg_params, dict): ; alg_params = {'num_coeffs':num_coeffs, ; 'init_coeff_scaling':init_coeff_scaling}; else:; if (num_coeffs is not None and ; not 'num_coeffs' in alg_params):; alg_params['num_coeffs'] = num_coeffs; if (init_coeff_scaling is not None and ; not 'init_coeff_scaling' in alg_params):; alg_params['init_coeff_scaling'] = init_coeff_scaling; ; # Build the guess pulse options; # Any options passed in the guess_pulse_params take precedence; # over the parameter values.; if guess_pulse_type: ; if not isinstance(guess_pulse_params, dict):; guess_pulse_params = {}; if (guess_pulse_scaling is not None and ; not 'scaling' in guess_pulse_params):; guess_pulse_params['scaling'] = guess_pulse_scaling; if (guess_pulse_offset is not None and ; not 'offset' in guess_pulse_params):; guess_pulse_params['offset'] = guess_pulse_offset; if (guess_pul",MatchSource.WIKI,docs/4.2/modules/qutip/control/pulseoptim.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/control/pulseoptim.html
https://qutip.org/docs/4.2/modules/qutip/control/pulseoptim.html:48364,Testability,log,logger,48364,"EBUG_INTENSE, DEBUG_VERBOSE, DEBUG, INFO, WARN, ERROR, CRITICAL; Anything WARN or above is effectively 'quiet' execution,; assuming everything runs as expected.; The default NOTSET implies that the level will be taken from; the QuTiP settings file, which by default is WARN. out_file_ext : string or None; files containing the initial and final control pulse; amplitudes are saved to the current directory.; The default name will be postfixed with this extension; Setting this to None will suppress the output of files. gen_stats : boolean; if set to True then statistics for the optimisation; run will be generated - accessible through attributes; of the stats object. Returns; -------; opt : OptimResult ; Returns instance of OptimResult, which has attributes giving the; reason for termination, final fidelity error, final evolution; final amplitudes, statistics etc; ; """""". # The parameters are checked in create_pulse_optimizer; # so no need to do so here. if log_level == logging.NOTSET:; log_level = logger.getEffectiveLevel(); else:; logger.setLevel(log_level). # build the algorithm options; if not isinstance(alg_params, dict): ; alg_params = {'num_coeffs':num_coeffs, ; 'init_coeff_scaling':init_coeff_scaling}; else:; if (num_coeffs is not None and ; not 'num_coeffs' in alg_params):; alg_params['num_coeffs'] = num_coeffs; if (init_coeff_scaling is not None and ; not 'init_coeff_scaling' in alg_params):; alg_params['init_coeff_scaling'] = init_coeff_scaling; ; # Build the guess pulse options; # Any options passed in the guess_pulse_params take precedence; # over the parameter values.; if guess_pulse_type: ; if not isinstance(guess_pulse_params, dict):; guess_pulse_params = {}; if (guess_pulse_scaling is not None and ; not 'scaling' in guess_pulse_params):; guess_pulse_params['scaling'] = guess_pulse_scaling; if (guess_pulse_offset is not None and ; not 'offset' in guess_pulse_params):; guess_pulse_params['offset'] = guess_pulse_offset; if (guess_pulse_action is not None and ",MatchSource.WIKI,docs/4.2/modules/qutip/control/pulseoptim.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/control/pulseoptim.html
https://qutip.org/docs/4.2/modules/qutip/control/pulseoptim.html:48399,Testability,log,logger,48399,"BUG, INFO, WARN, ERROR, CRITICAL; Anything WARN or above is effectively 'quiet' execution,; assuming everything runs as expected.; The default NOTSET implies that the level will be taken from; the QuTiP settings file, which by default is WARN. out_file_ext : string or None; files containing the initial and final control pulse; amplitudes are saved to the current directory.; The default name will be postfixed with this extension; Setting this to None will suppress the output of files. gen_stats : boolean; if set to True then statistics for the optimisation; run will be generated - accessible through attributes; of the stats object. Returns; -------; opt : OptimResult ; Returns instance of OptimResult, which has attributes giving the; reason for termination, final fidelity error, final evolution; final amplitudes, statistics etc; ; """""". # The parameters are checked in create_pulse_optimizer; # so no need to do so here. if log_level == logging.NOTSET:; log_level = logger.getEffectiveLevel(); else:; logger.setLevel(log_level). # build the algorithm options; if not isinstance(alg_params, dict): ; alg_params = {'num_coeffs':num_coeffs, ; 'init_coeff_scaling':init_coeff_scaling}; else:; if (num_coeffs is not None and ; not 'num_coeffs' in alg_params):; alg_params['num_coeffs'] = num_coeffs; if (init_coeff_scaling is not None and ; not 'init_coeff_scaling' in alg_params):; alg_params['init_coeff_scaling'] = init_coeff_scaling; ; # Build the guess pulse options; # Any options passed in the guess_pulse_params take precedence; # over the parameter values.; if guess_pulse_type: ; if not isinstance(guess_pulse_params, dict):; guess_pulse_params = {}; if (guess_pulse_scaling is not None and ; not 'scaling' in guess_pulse_params):; guess_pulse_params['scaling'] = guess_pulse_scaling; if (guess_pulse_offset is not None and ; not 'offset' in guess_pulse_params):; guess_pulse_params['offset'] = guess_pulse_offset; if (guess_pulse_action is not None and ; not 'pulse_action' in guess_pu",MatchSource.WIKI,docs/4.2/modules/qutip/control/pulseoptim.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/control/pulseoptim.html
https://qutip.org/docs/4.2/modules/qutip/control/pulseoptim.html:50942,Testability,log,logging,50942,"ms=fid_params,; tslot_type=tslot_type, tslot_params=tslot_params,; init_pulse_type=guess_pulse_type, ; init_pulse_params=guess_pulse_params,; ramping_pulse_type=ramping_pulse_type, ; ramping_pulse_params=ramping_pulse_params,; log_level=log_level, out_file_ext=out_file_ext, gen_stats=gen_stats). [docs]def create_pulse_optimizer(; drift, ctrls, initial, target,; num_tslots=None, evo_time=None, tau=None,; amp_lbound=None, amp_ubound=None,; fid_err_targ=1e-10, min_grad=1e-10,; max_iter=500, max_wall_time=180,; alg='GRAPE', alg_params=None,; optim_params=None, optim_method='DEF', method_params=None,; optim_alg=None, max_metric_corr=None, accuracy_factor=None,; dyn_type='GEN_MAT', dyn_params=None,; prop_type='DEF', prop_params=None,; fid_type='DEF', fid_params=None,; phase_option=None, fid_err_scale_factor=None,; tslot_type='DEF', tslot_params=None,; amp_update_mode=None,; init_pulse_type='DEF', init_pulse_params=None,; pulse_scaling=1.0, pulse_offset=0.0,; ramping_pulse_type=None, ramping_pulse_params=None,; log_level=logging.NOTSET, gen_stats=False):. """"""; Generate the objects of the appropriate subclasses; required for the pulse optmisation based on the parameters given; Note this method may be preferable to calling optimize_pulse; if more detailed configuration is required before running the; optmisation algorthim, or the algorithm will be run many times,; for instances when trying to finding global the optimum or; minimum time optimisation. Parameters; ----------; drift : Qobj or list of Qobj; the underlying dynamics generator of the system; can provide list (of length num_tslots) for time dependent drift. ctrls : List of Qobj or array like [num_tslots, evo_time]; a list of control dynamics generators. These are scaled by; the amplitudes to alter the overall dynamics; Array like imput can be provided for time dependent control generators. initial : Qobj; starting point for the evolution.; Typically the identity matrix. target : Qobj; target transformation, e.g. gate ",MatchSource.WIKI,docs/4.2/modules/qutip/control/pulseoptim.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/control/pulseoptim.html
https://qutip.org/docs/4.2/modules/qutip/control/pulseoptim.html:57802,Testability,log,logger,57802," ; (see PulseGen classes for details); For the CRAB the this the guess_pulse_type. . init_pulse_params : dict; Parameters for the initial / guess pulse generator object; The key value pairs are assumed to be attribute name value pairs; They applied after the object is created. pulse_scaling : float; Linear scale factor for generated initial / guess pulses; By default initial pulses are generated with amplitudes in the; range (-1.0, 1.0). These will be scaled by this parameter. pulse_offset : float; Linear offset for the pulse. That is this value will be added; to any initial / guess pulses generated.; ; ramping_pulse_type : string; Type of pulse used to modulate the control pulse.; It's intended use for a ramping modulation, which is often required in ; experimental setups.; This is only currently implemented in CRAB.; GAUSSIAN_EDGE was added for this purpose.; ; ramping_pulse_params : dict; Parameters for the ramping pulse generator object; The key value pairs are assumed to be attribute name value pairs; They applied after the object is created; ; log_level : integer; level of messaging output from the logger.; Options are attributes of qutip.logging_utils,; in decreasing levels of messaging, are:; DEBUG_INTENSE, DEBUG_VERBOSE, DEBUG, INFO, WARN, ERROR, CRITICAL; Anything WARN or above is effectively 'quiet' execution,; assuming everything runs as expected.; The default NOTSET implies that the level will be taken from; the QuTiP settings file, which by default is WARN. gen_stats : boolean; if set to True then statistics for the optimisation; run will be generated - accessible through attributes; of the stats object. Returns; -------; opt : Optimizer ; Instance of an Optimizer, through which the; Config, Dynamics, PulseGen, and TerminationConditions objects; can be accessed as attributes.; The PropagatorComputer, FidelityComputer and TimeslotComputer objects; can be accessed as attributes of the Dynamics object, e.g. optimizer.dynamics.fid_computer; The optimisation",MatchSource.WIKI,docs/4.2/modules/qutip/control/pulseoptim.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/control/pulseoptim.html
https://qutip.org/docs/4.2/modules/qutip/control/pulseoptim.html:61836,Testability,log,logging,61836,"e_mode' parameter is deprecated. ""; ""Use 'tslot_type' instead""); ; # set algorithm defaults; alg_up = _upper_safe(alg); if alg is None:; raise errors.UsageError(; ""Optimisation algorithm must be specified through 'alg' parameter""); elif alg_up == 'GRAPE':; if optim_method is None or optim_method.upper() == 'DEF':; optim_method = 'FMIN_L_BFGS_B'; if init_pulse_type is None or init_pulse_type.upper() == 'DEF':; init_pulse_type = 'RND'; elif alg_up == 'CRAB':; if optim_method is None or optim_method.upper() == 'DEF':; optim_method = 'FMIN'; if prop_type is None or prop_type.upper() == 'DEF':; prop_type = 'APPROX'; if init_pulse_type is None or init_pulse_type.upper() == 'DEF':; init_pulse_type = None; else:; raise errors.UsageError(; ""No option for pulse optimisation algorithm alg={}"".format(alg)). cfg = optimconfig.OptimConfig(); cfg.optim_method = optim_method; cfg.dyn_type = dyn_type; cfg.prop_type = prop_type; cfg.fid_type = fid_type; cfg.init_pulse_type = init_pulse_type. if log_level == logging.NOTSET:; log_level = logger.getEffectiveLevel(); else:; logger.setLevel(log_level). cfg.log_level = log_level. # Create the Dynamics instance; if dyn_type == 'GEN_MAT' or dyn_type is None or dyn_type == '':; dyn = dynamics.DynamicsGenMat(cfg); elif dyn_type == 'UNIT':; dyn = dynamics.DynamicsUnitary(cfg); elif dyn_type == 'SYMPL':; dyn = dynamics.DynamicsSymplectic(cfg); else:; raise errors.UsageError(""No option for dyn_type: "" + dyn_type); dyn.apply_params(dyn_params); dyn._drift_dyn_gen_checked = True; dyn._ctrl_dyn_gen_checked = True; ; # Create the PropagatorComputer instance; # The default will be typically be the best option; if prop_type == 'DEF' or prop_type is None or prop_type == '':; # Do nothing use the default for the Dynamics; pass; elif prop_type == 'APPROX':; if not isinstance(dyn.prop_computer, propcomp.PropCompApproxGrad):; dyn.prop_computer = propcomp.PropCompApproxGrad(dyn); elif prop_type == 'DIAG':; if not isinstance(dyn.prop_computer, propcomp.PropCom",MatchSource.WIKI,docs/4.2/modules/qutip/control/pulseoptim.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/control/pulseoptim.html
https://qutip.org/docs/4.2/modules/qutip/control/pulseoptim.html:61865,Testability,log,logger,61865,"ated. ""; ""Use 'tslot_type' instead""); ; # set algorithm defaults; alg_up = _upper_safe(alg); if alg is None:; raise errors.UsageError(; ""Optimisation algorithm must be specified through 'alg' parameter""); elif alg_up == 'GRAPE':; if optim_method is None or optim_method.upper() == 'DEF':; optim_method = 'FMIN_L_BFGS_B'; if init_pulse_type is None or init_pulse_type.upper() == 'DEF':; init_pulse_type = 'RND'; elif alg_up == 'CRAB':; if optim_method is None or optim_method.upper() == 'DEF':; optim_method = 'FMIN'; if prop_type is None or prop_type.upper() == 'DEF':; prop_type = 'APPROX'; if init_pulse_type is None or init_pulse_type.upper() == 'DEF':; init_pulse_type = None; else:; raise errors.UsageError(; ""No option for pulse optimisation algorithm alg={}"".format(alg)). cfg = optimconfig.OptimConfig(); cfg.optim_method = optim_method; cfg.dyn_type = dyn_type; cfg.prop_type = prop_type; cfg.fid_type = fid_type; cfg.init_pulse_type = init_pulse_type. if log_level == logging.NOTSET:; log_level = logger.getEffectiveLevel(); else:; logger.setLevel(log_level). cfg.log_level = log_level. # Create the Dynamics instance; if dyn_type == 'GEN_MAT' or dyn_type is None or dyn_type == '':; dyn = dynamics.DynamicsGenMat(cfg); elif dyn_type == 'UNIT':; dyn = dynamics.DynamicsUnitary(cfg); elif dyn_type == 'SYMPL':; dyn = dynamics.DynamicsSymplectic(cfg); else:; raise errors.UsageError(""No option for dyn_type: "" + dyn_type); dyn.apply_params(dyn_params); dyn._drift_dyn_gen_checked = True; dyn._ctrl_dyn_gen_checked = True; ; # Create the PropagatorComputer instance; # The default will be typically be the best option; if prop_type == 'DEF' or prop_type is None or prop_type == '':; # Do nothing use the default for the Dynamics; pass; elif prop_type == 'APPROX':; if not isinstance(dyn.prop_computer, propcomp.PropCompApproxGrad):; dyn.prop_computer = propcomp.PropCompApproxGrad(dyn); elif prop_type == 'DIAG':; if not isinstance(dyn.prop_computer, propcomp.PropCompDiag):; dyn.prop_computer",MatchSource.WIKI,docs/4.2/modules/qutip/control/pulseoptim.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/control/pulseoptim.html
https://qutip.org/docs/4.2/modules/qutip/control/pulseoptim.html:61900,Testability,log,logger,61900,"ead""); ; # set algorithm defaults; alg_up = _upper_safe(alg); if alg is None:; raise errors.UsageError(; ""Optimisation algorithm must be specified through 'alg' parameter""); elif alg_up == 'GRAPE':; if optim_method is None or optim_method.upper() == 'DEF':; optim_method = 'FMIN_L_BFGS_B'; if init_pulse_type is None or init_pulse_type.upper() == 'DEF':; init_pulse_type = 'RND'; elif alg_up == 'CRAB':; if optim_method is None or optim_method.upper() == 'DEF':; optim_method = 'FMIN'; if prop_type is None or prop_type.upper() == 'DEF':; prop_type = 'APPROX'; if init_pulse_type is None or init_pulse_type.upper() == 'DEF':; init_pulse_type = None; else:; raise errors.UsageError(; ""No option for pulse optimisation algorithm alg={}"".format(alg)). cfg = optimconfig.OptimConfig(); cfg.optim_method = optim_method; cfg.dyn_type = dyn_type; cfg.prop_type = prop_type; cfg.fid_type = fid_type; cfg.init_pulse_type = init_pulse_type. if log_level == logging.NOTSET:; log_level = logger.getEffectiveLevel(); else:; logger.setLevel(log_level). cfg.log_level = log_level. # Create the Dynamics instance; if dyn_type == 'GEN_MAT' or dyn_type is None or dyn_type == '':; dyn = dynamics.DynamicsGenMat(cfg); elif dyn_type == 'UNIT':; dyn = dynamics.DynamicsUnitary(cfg); elif dyn_type == 'SYMPL':; dyn = dynamics.DynamicsSymplectic(cfg); else:; raise errors.UsageError(""No option for dyn_type: "" + dyn_type); dyn.apply_params(dyn_params); dyn._drift_dyn_gen_checked = True; dyn._ctrl_dyn_gen_checked = True; ; # Create the PropagatorComputer instance; # The default will be typically be the best option; if prop_type == 'DEF' or prop_type is None or prop_type == '':; # Do nothing use the default for the Dynamics; pass; elif prop_type == 'APPROX':; if not isinstance(dyn.prop_computer, propcomp.PropCompApproxGrad):; dyn.prop_computer = propcomp.PropCompApproxGrad(dyn); elif prop_type == 'DIAG':; if not isinstance(dyn.prop_computer, propcomp.PropCompDiag):; dyn.prop_computer = propcomp.PropCompDiag(dyn); e",MatchSource.WIKI,docs/4.2/modules/qutip/control/pulseoptim.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/control/pulseoptim.html
https://qutip.org/docs/4.2/modules/qutip/control/pulseoptim.html:68892,Testability,log,logging,68892,"_params); guess_pulse_action = init_pulse_params.get('pulse_action'). optim.pulse_generator = []; for j in range(n_ctrls):; crab_pgen = pulsegen.PulseGenCrabFourier(; dyn=dyn, num_coeffs=num_coeffs); if init_coeff_scaling is not None:; crab_pgen.scaling = init_coeff_scaling; if isinstance(crab_pulse_params, dict):; crab_pgen.apply_params(crab_pulse_params); ; lb = None; if amp_lbound:; if isinstance(amp_lbound, list):; try:; lb = amp_lbound[j]; except:; lb = amp_lbound[-1]; else:; lb = amp_lbound; ub = None; if amp_ubound:; if isinstance(amp_ubound, list):; try:; ub = amp_ubound[j]; except:; ub = amp_ubound[-1]; else:; ub = amp_ubound; crab_pgen.lbound = lb; crab_pgen.ubound = ub; ; if guess_pulse_type:; guess_pgen.lbound = lb; guess_pgen.ubound = ub; crab_pgen.guess_pulse = guess_pgen.gen_pulse(); if guess_pulse_action:; crab_pgen.guess_pulse_action = guess_pulse_action; ; if ramping_pgen:; crab_pgen.ramping_pulse = ramping_pgen.gen_pulse(). optim.pulse_generator.append(crab_pgen); #This is just for the debug message now; pgen = optim.pulse_generator[0]; ; else:; # Create a pulse generator of the type specified; pgen = pulsegen.create_pulse_gen(pulse_type=init_pulse_type, dyn=dyn,; pulse_params=init_pulse_params); pgen.scaling = pulse_scaling; pgen.offset = pulse_offset; pgen.lbound = amp_lbound; pgen.ubound = amp_ubound. optim.pulse_generator = pgen. if log_level <= logging.DEBUG:; logger.debug(; ""Optimisation config summary...\n""; "" object classes:\n""; "" optimizer: "" + optim.__class__.__name__ +; ""\n dynamics: "" + dyn.__class__.__name__ +; ""\n tslotcomp: "" + dyn.tslot_computer.__class__.__name__ +; ""\n fidcomp: "" + dyn.fid_computer.__class__.__name__ +; ""\n propcomp: "" + dyn.prop_computer.__class__.__name__ +; ""\n pulsegen: "" + pgen.__class__.__name__). return optim. Â© Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, and A.L. Grimsmo.; Last updated on Jan 17, 2018. . Built with Sphinx using a theme provided by Read the Docs. . ",MatchSource.WIKI,docs/4.2/modules/qutip/control/pulseoptim.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/control/pulseoptim.html
https://qutip.org/docs/4.2/modules/qutip/control/pulseoptim.html:68908,Testability,log,logger,68908,"_params); guess_pulse_action = init_pulse_params.get('pulse_action'). optim.pulse_generator = []; for j in range(n_ctrls):; crab_pgen = pulsegen.PulseGenCrabFourier(; dyn=dyn, num_coeffs=num_coeffs); if init_coeff_scaling is not None:; crab_pgen.scaling = init_coeff_scaling; if isinstance(crab_pulse_params, dict):; crab_pgen.apply_params(crab_pulse_params); ; lb = None; if amp_lbound:; if isinstance(amp_lbound, list):; try:; lb = amp_lbound[j]; except:; lb = amp_lbound[-1]; else:; lb = amp_lbound; ub = None; if amp_ubound:; if isinstance(amp_ubound, list):; try:; ub = amp_ubound[j]; except:; ub = amp_ubound[-1]; else:; ub = amp_ubound; crab_pgen.lbound = lb; crab_pgen.ubound = ub; ; if guess_pulse_type:; guess_pgen.lbound = lb; guess_pgen.ubound = ub; crab_pgen.guess_pulse = guess_pgen.gen_pulse(); if guess_pulse_action:; crab_pgen.guess_pulse_action = guess_pulse_action; ; if ramping_pgen:; crab_pgen.ramping_pulse = ramping_pgen.gen_pulse(). optim.pulse_generator.append(crab_pgen); #This is just for the debug message now; pgen = optim.pulse_generator[0]; ; else:; # Create a pulse generator of the type specified; pgen = pulsegen.create_pulse_gen(pulse_type=init_pulse_type, dyn=dyn,; pulse_params=init_pulse_params); pgen.scaling = pulse_scaling; pgen.offset = pulse_offset; pgen.lbound = amp_lbound; pgen.ubound = amp_ubound. optim.pulse_generator = pgen. if log_level <= logging.DEBUG:; logger.debug(; ""Optimisation config summary...\n""; "" object classes:\n""; "" optimizer: "" + optim.__class__.__name__ +; ""\n dynamics: "" + dyn.__class__.__name__ +; ""\n tslotcomp: "" + dyn.tslot_computer.__class__.__name__ +; ""\n fidcomp: "" + dyn.fid_computer.__class__.__name__ +; ""\n propcomp: "" + dyn.prop_computer.__class__.__name__ +; ""\n pulsegen: "" + pgen.__class__.__name__). return optim. Â© Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, and A.L. Grimsmo.; Last updated on Jan 17, 2018. . Built with Sphinx using a theme provided by Read the Docs. . ",MatchSource.WIKI,docs/4.2/modules/qutip/control/pulseoptim.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/control/pulseoptim.html
https://qutip.org/docs/4.2/modules/qutip/control/pulseoptim.html:5073,Usability,simpl,simplefilter,5073,"o, T. & Montangero, S. ; Optimal Control Technique for Many-Body Quantum Dynamics. ; Phys. Rev. Lett. 106, 1â4 (2011).; 4. Caneva, T., Calarco, T. & Montangero, S. ; Chopped random-basis quantum optimization. ; Phys. Rev. A - At. Mol. Opt. Phys. 84, (2011). """"""; import numpy as np; import warnings. # QuTiP; from qutip import Qobj; import qutip.logging_utils as logging; logger = logging.get_logger(); # QuTiP control modules; import qutip.control.optimconfig as optimconfig; import qutip.control.dynamics as dynamics; import qutip.control.termcond as termcond; import qutip.control.optimizer as optimizer; import qutip.control.stats as stats; import qutip.control.errors as errors; import qutip.control.fidcomp as fidcomp; import qutip.control.propcomp as propcomp; import qutip.control.pulsegen as pulsegen; #import qutip.control.pulsegencrab as pulsegencrab. warnings.simplefilter('always', DeprecationWarning) #turn off filter ; def _param_deprecation(message, stacklevel=3):; """"""; Issue deprecation warning; Using stacklevel=3 will ensure message refers the function; calling with the deprecated parameter,; """"""; warnings.warn(message, DeprecationWarning, stacklevel=stacklevel); ; def _upper_safe(s):; try:; s = s.upper(); except:; pass; return s; ; [docs]def optimize_pulse(; drift, ctrls, initial, target,; num_tslots=None, evo_time=None, tau=None,; amp_lbound=None, amp_ubound=None,; fid_err_targ=1e-10, min_grad=1e-10,; max_iter=500, max_wall_time=180,; alg='GRAPE', alg_params=None,; optim_params=None, optim_method='DEF', method_params=None,; optim_alg=None, max_metric_corr=None, accuracy_factor=None,; dyn_type='GEN_MAT', dyn_params=None,; prop_type='DEF', prop_params=None,; fid_type='DEF', fid_params=None,; phase_option=None, fid_err_scale_factor=None,; tslot_type='DEF', tslot_params=None,; amp_update_mode=None,; init_pulse_type='DEF', init_pulse_params=None,; pulse_scaling=1.0, pulse_offset=0.0,; ramping_pulse_type=None, ramping_pulse_params=None,; log_level=logging.NOTSET, ou",MatchSource.WIKI,docs/4.2/modules/qutip/control/pulseoptim.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/control/pulseoptim.html
https://qutip.org/docs/4.2/modules/qutip/control/pulseoptim.html:19623,Usability,simpl,simply,19623,"e). return result. [docs]def optimize_pulse_unitary(; H_d, H_c, U_0, U_targ,; num_tslots=None, evo_time=None, tau=None,; amp_lbound=None, amp_ubound=None,; fid_err_targ=1e-10, min_grad=1e-10,; max_iter=500, max_wall_time=180,; alg='GRAPE', alg_params=None,; optim_params=None, optim_method='DEF', method_params=None,; optim_alg=None, max_metric_corr=None, accuracy_factor=None,; phase_option='PSU', ; dyn_params=None, prop_params=None, fid_params=None,; tslot_type='DEF', tslot_params=None,; amp_update_mode=None,; init_pulse_type='DEF', init_pulse_params=None,; pulse_scaling=1.0, pulse_offset=0.0,; ramping_pulse_type=None, ramping_pulse_params=None,; log_level=logging.NOTSET, out_file_ext=None, gen_stats=False):. """"""; Optimise a control pulse to minimise the fidelity error, assuming that; the dynamics of the system are generated by unitary operators.; This function is simply a wrapper for optimize_pulse, where the; appropriate options for unitary dynamics are chosen and the parameter; names are in the format familiar to unitary dynamics; The dynamics of the system in any given timeslot are governed; by the combined Hamiltonian,; i.e. the sum of the H_d + ctrl_amp[j]*H_c[j]; The control pulse is an [n_ts, n_ctrls] array of piecewise amplitudes; Starting from an intital (typically random) pulse,; a multivariable optimisation algorithm attempts to determines the; optimal values for the control pulse to minimise the fidelity error; The maximum fidelity for a unitary system is 1, i.e. when the; time evolution resulting from the pulse is equivalent to the target.; And therefore the fidelity error is 1 - fidelity. Parameters; ----------; H_d : Qobj or list of Qobj; Drift (aka system) the underlying Hamiltonian of the system; can provide list (of length num_tslots) for time dependent drift; ; H_c : List of Qobj or array like [num_tslots, evo_time]; a list of control Hamiltonians. These are scaled by; the amplitudes to alter the overall dynamics; Array like imput can be provided f",MatchSource.WIKI,docs/4.2/modules/qutip/control/pulseoptim.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/control/pulseoptim.html
https://qutip.org/docs/4.2/modules/qutip/control/pulseoptim.html:40816,Usability,simpl,simply,40816,"_ext=out_file_ext, gen_stats=gen_stats); ; [docs]def opt_pulse_crab_unitary(; H_d, H_c, U_0, U_targ,; num_tslots=None, evo_time=None, tau=None,; amp_lbound=None, amp_ubound=None,; fid_err_targ=1e-5,; max_iter=500, max_wall_time=180,; alg_params=None,; num_coeffs=None, init_coeff_scaling=1.0, ; optim_params=None, optim_method='fmin', method_params=None,; phase_option='PSU', ; dyn_params=None, prop_params=None, fid_params=None,; tslot_type='DEF', tslot_params=None,; guess_pulse_type=None, guess_pulse_params=None,; guess_pulse_scaling=1.0, guess_pulse_offset=0.0,; guess_pulse_action='MODULATE', ; ramping_pulse_type=None, ramping_pulse_params=None,; log_level=logging.NOTSET, out_file_ext=None, gen_stats=False):; """"""; Optimise a control pulse to minimise the fidelity error, assuming that; the dynamics of the system are generated by unitary operators.; This function is simply a wrapper for optimize_pulse, where the; appropriate options for unitary dynamics are chosen and the parameter; names are in the format familiar to unitary dynamics; The dynamics of the system in any given timeslot are governed; by the combined Hamiltonian,; i.e. the sum of the H_d + ctrl_amp[j]*H_c[j]; The control pulse is an [n_ts, n_ctrls] array of piecewise amplitudes; ; The CRAB algorithm uses basis function coefficents as the variables to; optimise. It does NOT use any gradient function.; A multivariable optimisation algorithm attempts to determines the; optimal values for the control pulse to minimise the fidelity error; The fidelity error is some measure of distance of the system evolution; from the given target evolution in the time allowed for the evolution. Parameters; ----------. H_d : Qobj or list of Qobj; Drift (aka system) the underlying Hamiltonian of the system; can provide list (of length num_tslots) for time dependent drift. H_c : List of Qobj or array like [num_tslots, evo_time]; a list of control Hamiltonians. These are scaled by; the amplitudes to alter the overall dynamics; Arra",MatchSource.WIKI,docs/4.2/modules/qutip/control/pulseoptim.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/control/pulseoptim.html
https://qutip.org/docs/4.2/modules/qutip/control/stats.html:2324,Availability,redundant,redundant,2324," BUT NOT; # LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A; # PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT; # HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,; # SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT; # LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,; # DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY; # THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT; # (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE; # OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.; ###############################################################################. # @author: Alexander Pitchford; # @email1: agp1@aber.ac.uk; # @email2: alex.pitchford@gmail.com; # @organization: Aberystwyth University; # @supervisor: Daniel Burgarth. """"""; Statistics for the optimisation; Note that some of the stats here are redundant copies from the optimiser; used here for calculations; """"""; import numpy as np; import datetime. [docs]class Stats(object):; """"""; Base class for all optimisation statistics; Used for configurations where all timeslots are updated each iteration; e.g. exact gradients; Note that all times are generated using timeit.default_timer() and are; in seconds. Attributes; ----------; dyn_gen_name : string; Text used in some report functions.; Makes sense to set it to 'Hamiltonian' when using unitary dynamics; Default is simply 'dynamics generator'. num_iter : integer; Number of iterations of the optimisation algorithm. wall_time_optim_start : float; Start time for the optimisation. wall_time_optim_end : float; End time for the optimisation. wall_time_optim : float; Time elasped during the optimisation. wall_time_dyn_gen_compute : float; Total wall (elasped) time computing combined dynamics generator; (for example combining drift and control Hamiltonians). wall_time_prop_compute : float; Total wall (el",MatchSource.WIKI,docs/4.2/modules/qutip/control/stats.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/control/stats.html
https://qutip.org/docs/4.2/modules/qutip/control/stats.html:4025,Availability,error,error,4025,"me for the optimisation. wall_time_optim_end : float; End time for the optimisation. wall_time_optim : float; Time elasped during the optimisation. wall_time_dyn_gen_compute : float; Total wall (elasped) time computing combined dynamics generator; (for example combining drift and control Hamiltonians). wall_time_prop_compute : float; Total wall (elasped) time computing propagators, that is the; time evolution from one timeslot to the next; Includes calculating the propagator gradient for exact gradients. wall_time_fwd_prop_compute : float; Total wall (elasped) time computing combined forward propagation,; that is the time evolution from the start to a specific timeslot.; Excludes calculating the propagators themselves. wall_time_onwd_prop_compute : float; Total wall (elasped) time computing combined onward propagation,; that is the time evolution from a specific timeslot to the end time.; Excludes calculating the propagators themselves. wall_time_gradient_compute : float; Total wall (elasped) time computing the fidelity error gradient.; Excludes calculating the propagator gradients (in exact gradient; methods). num_fidelity_func_calls : integer; Number of calls to fidelity function by the optimisation algorithm. num_grad_func_calls : integer; Number of calls to gradient function by the optimisation algorithm. num_tslot_recompute : integer; Number of time the timeslot evolution is recomputed; (It is only computed if any amplitudes changed since the last call). num_fidelity_computes : integer; Number of time the fidelity is computed; (It is only computed if any amplitudes changed since the last call). num_grad_computes : integer; Number of time the gradient is computed; (It is only computed if any amplitudes changed since the last call). num_ctrl_amp_updates : integer; Number of times the control amplitudes are updated. mean_num_ctrl_amp_updates_per_iter : float; Mean number of control amplitude updates per iteration. num_timeslot_changes : integer; Number of times the",MatchSource.WIKI,docs/4.2/modules/qutip/control/stats.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/control/stats.html
https://qutip.org/docs/4.2/modules/qutip/control/stats.html:2517,Deployability,configurat,configurations,2517,"CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,; # SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT; # LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,; # DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY; # THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT; # (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE; # OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.; ###############################################################################. # @author: Alexander Pitchford; # @email1: agp1@aber.ac.uk; # @email2: alex.pitchford@gmail.com; # @organization: Aberystwyth University; # @supervisor: Daniel Burgarth. """"""; Statistics for the optimisation; Note that some of the stats here are redundant copies from the optimiser; used here for calculations; """"""; import numpy as np; import datetime. [docs]class Stats(object):; """"""; Base class for all optimisation statistics; Used for configurations where all timeslots are updated each iteration; e.g. exact gradients; Note that all times are generated using timeit.default_timer() and are; in seconds. Attributes; ----------; dyn_gen_name : string; Text used in some report functions.; Makes sense to set it to 'Hamiltonian' when using unitary dynamics; Default is simply 'dynamics generator'. num_iter : integer; Number of iterations of the optimisation algorithm. wall_time_optim_start : float; Start time for the optimisation. wall_time_optim_end : float; End time for the optimisation. wall_time_optim : float; Time elasped during the optimisation. wall_time_dyn_gen_compute : float; Total wall (elasped) time computing combined dynamics generator; (for example combining drift and control Hamiltonians). wall_time_prop_compute : float; Total wall (elasped) time computing propagators, that is the; time evolution from one timeslot to the next; Includes calculating the propagator gradient for exact gradients. wall_ti",MatchSource.WIKI,docs/4.2/modules/qutip/control/stats.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/control/stats.html
https://qutip.org/docs/4.2/modules/qutip/control/stats.html:2556,Deployability,update,updated,2556,"CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,; # SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT; # LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,; # DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY; # THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT; # (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE; # OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.; ###############################################################################. # @author: Alexander Pitchford; # @email1: agp1@aber.ac.uk; # @email2: alex.pitchford@gmail.com; # @organization: Aberystwyth University; # @supervisor: Daniel Burgarth. """"""; Statistics for the optimisation; Note that some of the stats here are redundant copies from the optimiser; used here for calculations; """"""; import numpy as np; import datetime. [docs]class Stats(object):; """"""; Base class for all optimisation statistics; Used for configurations where all timeslots are updated each iteration; e.g. exact gradients; Note that all times are generated using timeit.default_timer() and are; in seconds. Attributes; ----------; dyn_gen_name : string; Text used in some report functions.; Makes sense to set it to 'Hamiltonian' when using unitary dynamics; Default is simply 'dynamics generator'. num_iter : integer; Number of iterations of the optimisation algorithm. wall_time_optim_start : float; Start time for the optimisation. wall_time_optim_end : float; End time for the optimisation. wall_time_optim : float; Time elasped during the optimisation. wall_time_dyn_gen_compute : float; Total wall (elasped) time computing combined dynamics generator; (for example combining drift and control Hamiltonians). wall_time_prop_compute : float; Total wall (elasped) time computing propagators, that is the; time evolution from one timeslot to the next; Includes calculating the propagator gradient for exact gradients. wall_ti",MatchSource.WIKI,docs/4.2/modules/qutip/control/stats.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/control/stats.html
https://qutip.org/docs/4.2/modules/qutip/control/stats.html:4830,Deployability,update,updated,4830,"ned onward propagation,; that is the time evolution from a specific timeslot to the end time.; Excludes calculating the propagators themselves. wall_time_gradient_compute : float; Total wall (elasped) time computing the fidelity error gradient.; Excludes calculating the propagator gradients (in exact gradient; methods). num_fidelity_func_calls : integer; Number of calls to fidelity function by the optimisation algorithm. num_grad_func_calls : integer; Number of calls to gradient function by the optimisation algorithm. num_tslot_recompute : integer; Number of time the timeslot evolution is recomputed; (It is only computed if any amplitudes changed since the last call). num_fidelity_computes : integer; Number of time the fidelity is computed; (It is only computed if any amplitudes changed since the last call). num_grad_computes : integer; Number of time the gradient is computed; (It is only computed if any amplitudes changed since the last call). num_ctrl_amp_updates : integer; Number of times the control amplitudes are updated. mean_num_ctrl_amp_updates_per_iter : float; Mean number of control amplitude updates per iteration. num_timeslot_changes : integer; Number of times the amplitudes of a any control in a timeslot changes. mean_num_timeslot_changes_per_update : float; Mean average number of timeslot amplitudes that are changed per update. num_ctrl_amp_changes : integer; Number of times individual control amplitudes that are changed. mean_num_ctrl_amp_changes_per_update : float; Mean average number of control amplitudes that are changed per update; """"""; def __init__(self):; self.reset(). def reset(self):; self.dyn_gen_name = ""dynamics generator""; self.clear(). def clear(self):; self.num_iter = 0; # Duration attributes; self.wall_time_optim_start = 0.0; self.wall_time_optim_end = 0.0; self.wall_time_optim = 0.0; self.wall_time_dyn_gen_compute = 0.0; self.wall_time_prop_compute = 0.0; self.wall_time_fwd_prop_compute = 0.0; self.wall_time_onwd_prop_compute = 0.0; sel",MatchSource.WIKI,docs/4.2/modules/qutip/control/stats.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/control/stats.html
https://qutip.org/docs/4.2/modules/qutip/control/stats.html:4916,Deployability,update,updates,4916,".; Excludes calculating the propagators themselves. wall_time_gradient_compute : float; Total wall (elasped) time computing the fidelity error gradient.; Excludes calculating the propagator gradients (in exact gradient; methods). num_fidelity_func_calls : integer; Number of calls to fidelity function by the optimisation algorithm. num_grad_func_calls : integer; Number of calls to gradient function by the optimisation algorithm. num_tslot_recompute : integer; Number of time the timeslot evolution is recomputed; (It is only computed if any amplitudes changed since the last call). num_fidelity_computes : integer; Number of time the fidelity is computed; (It is only computed if any amplitudes changed since the last call). num_grad_computes : integer; Number of time the gradient is computed; (It is only computed if any amplitudes changed since the last call). num_ctrl_amp_updates : integer; Number of times the control amplitudes are updated. mean_num_ctrl_amp_updates_per_iter : float; Mean number of control amplitude updates per iteration. num_timeslot_changes : integer; Number of times the amplitudes of a any control in a timeslot changes. mean_num_timeslot_changes_per_update : float; Mean average number of timeslot amplitudes that are changed per update. num_ctrl_amp_changes : integer; Number of times individual control amplitudes that are changed. mean_num_ctrl_amp_changes_per_update : float; Mean average number of control amplitudes that are changed per update; """"""; def __init__(self):; self.reset(). def reset(self):; self.dyn_gen_name = ""dynamics generator""; self.clear(). def clear(self):; self.num_iter = 0; # Duration attributes; self.wall_time_optim_start = 0.0; self.wall_time_optim_end = 0.0; self.wall_time_optim = 0.0; self.wall_time_dyn_gen_compute = 0.0; self.wall_time_prop_compute = 0.0; self.wall_time_fwd_prop_compute = 0.0; self.wall_time_onwd_prop_compute = 0.0; self.wall_time_gradient_compute = 0.0; # Fidelity and gradient function calls and computes; sel",MatchSource.WIKI,docs/4.2/modules/qutip/control/stats.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/control/stats.html
https://qutip.org/docs/4.2/modules/qutip/control/stats.html:5152,Deployability,update,update,5152,"adient; methods). num_fidelity_func_calls : integer; Number of calls to fidelity function by the optimisation algorithm. num_grad_func_calls : integer; Number of calls to gradient function by the optimisation algorithm. num_tslot_recompute : integer; Number of time the timeslot evolution is recomputed; (It is only computed if any amplitudes changed since the last call). num_fidelity_computes : integer; Number of time the fidelity is computed; (It is only computed if any amplitudes changed since the last call). num_grad_computes : integer; Number of time the gradient is computed; (It is only computed if any amplitudes changed since the last call). num_ctrl_amp_updates : integer; Number of times the control amplitudes are updated. mean_num_ctrl_amp_updates_per_iter : float; Mean number of control amplitude updates per iteration. num_timeslot_changes : integer; Number of times the amplitudes of a any control in a timeslot changes. mean_num_timeslot_changes_per_update : float; Mean average number of timeslot amplitudes that are changed per update. num_ctrl_amp_changes : integer; Number of times individual control amplitudes that are changed. mean_num_ctrl_amp_changes_per_update : float; Mean average number of control amplitudes that are changed per update; """"""; def __init__(self):; self.reset(). def reset(self):; self.dyn_gen_name = ""dynamics generator""; self.clear(). def clear(self):; self.num_iter = 0; # Duration attributes; self.wall_time_optim_start = 0.0; self.wall_time_optim_end = 0.0; self.wall_time_optim = 0.0; self.wall_time_dyn_gen_compute = 0.0; self.wall_time_prop_compute = 0.0; self.wall_time_fwd_prop_compute = 0.0; self.wall_time_onwd_prop_compute = 0.0; self.wall_time_gradient_compute = 0.0; # Fidelity and gradient function calls and computes; self.num_fidelity_func_calls = 0; self.num_grad_func_calls = 0; self.num_tslot_recompute = 0; self.num_fidelity_computes = 0; self.num_grad_computes = 0; # Control amplitudes; self.num_ctrl_amp_updates = 0; self.mea",MatchSource.WIKI,docs/4.2/modules/qutip/control/stats.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/control/stats.html
https://qutip.org/docs/4.2/modules/qutip/control/stats.html:5365,Deployability,update,update,5365,"_recompute : integer; Number of time the timeslot evolution is recomputed; (It is only computed if any amplitudes changed since the last call). num_fidelity_computes : integer; Number of time the fidelity is computed; (It is only computed if any amplitudes changed since the last call). num_grad_computes : integer; Number of time the gradient is computed; (It is only computed if any amplitudes changed since the last call). num_ctrl_amp_updates : integer; Number of times the control amplitudes are updated. mean_num_ctrl_amp_updates_per_iter : float; Mean number of control amplitude updates per iteration. num_timeslot_changes : integer; Number of times the amplitudes of a any control in a timeslot changes. mean_num_timeslot_changes_per_update : float; Mean average number of timeslot amplitudes that are changed per update. num_ctrl_amp_changes : integer; Number of times individual control amplitudes that are changed. mean_num_ctrl_amp_changes_per_update : float; Mean average number of control amplitudes that are changed per update; """"""; def __init__(self):; self.reset(). def reset(self):; self.dyn_gen_name = ""dynamics generator""; self.clear(). def clear(self):; self.num_iter = 0; # Duration attributes; self.wall_time_optim_start = 0.0; self.wall_time_optim_end = 0.0; self.wall_time_optim = 0.0; self.wall_time_dyn_gen_compute = 0.0; self.wall_time_prop_compute = 0.0; self.wall_time_fwd_prop_compute = 0.0; self.wall_time_onwd_prop_compute = 0.0; self.wall_time_gradient_compute = 0.0; # Fidelity and gradient function calls and computes; self.num_fidelity_func_calls = 0; self.num_grad_func_calls = 0; self.num_tslot_recompute = 0; self.num_fidelity_computes = 0; self.num_grad_computes = 0; # Control amplitudes; self.num_ctrl_amp_updates = 0; self.mean_num_ctrl_amp_updates_per_iter = 0.0; self.num_timeslot_changes = 0; self.mean_num_timeslot_changes_per_update = 0.0; self.num_ctrl_amp_changes = 0; self.mean_num_ctrl_amp_changes_per_update = 0.0. [docs] def calculate(self):; """"",MatchSource.WIKI,docs/4.2/modules/qutip/control/stats.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/control/stats.html
https://qutip.org/docs/4.2/modules/qutip/control/stats.html:9078,Deployability,update,updates,9078,"(""Wall time computing forward propagation: "" +; self._format_datetime(self.wall_time_fwd_prop_compute, tot)); print(""Wall time computing onward propagation: "" +; self._format_datetime(self.wall_time_onwd_prop_compute, tot)); print(""Wall time computing gradient: "" +; self._format_datetime(self.wall_time_gradient_compute, tot)); print(""""). def report_func_calls(self):; print(""**** Iterations and function calls ****""); print(""Number of iterations: {}"".format(self.num_iter)); print(""Number of fidelity function calls: ""; ""{}"".format(self.num_fidelity_func_calls)); print(""Number of times fidelity is computed: ""; ""{}"".format(self.num_fidelity_computes)); print(""Number of gradient function calls: ""; ""{}"".format(self.num_grad_func_calls)); print(""Number of times gradients are computed: ""; ""{}"".format(self.num_grad_computes)); print(""Number of times timeslot evolution is recomputed: ""; ""{}"".format(self.num_tslot_recompute)); print(""""). def report_amp_updates(self):; print(""**** Control amplitudes ****""); print(""Number of control amplitude updates: ""; ""{}"".format(self.num_ctrl_amp_updates)); print(""Mean number of updates per iteration: ""; ""{}"".format(self.mean_num_ctrl_amp_updates_per_iter)); print(""Number of timeslot values changed: ""; ""{}"".format(self.num_timeslot_changes)); print(""Mean number of timeslot changes per update: ""; ""{}"".format(self.mean_num_timeslot_changes_per_update)); print(""Number of amplitude values changed: ""; ""{}"".format(self.num_ctrl_amp_changes)); print(""Mean number of amplitude changes per update: ""; ""{}"".format(self.mean_num_ctrl_amp_changes_per_update)). class StatsDynTsUpdate(Stats):; """"""; Optimisation stats class for configurations where all timeslots are not; necessarily updated at each iteration. In this case it may be interesting; to know how many Hamiltions etc are computed each ctrl amplitude update. Attributes; ----------; num_dyn_gen_computes : integer; Total number of dynamics generator (Hamiltonian) computations,; that is combining drift an",MatchSource.WIKI,docs/4.2/modules/qutip/control/stats.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/control/stats.html
https://qutip.org/docs/4.2/modules/qutip/control/stats.html:9153,Deployability,update,updates,9153,"int(""Wall time computing onward propagation: "" +; self._format_datetime(self.wall_time_onwd_prop_compute, tot)); print(""Wall time computing gradient: "" +; self._format_datetime(self.wall_time_gradient_compute, tot)); print(""""). def report_func_calls(self):; print(""**** Iterations and function calls ****""); print(""Number of iterations: {}"".format(self.num_iter)); print(""Number of fidelity function calls: ""; ""{}"".format(self.num_fidelity_func_calls)); print(""Number of times fidelity is computed: ""; ""{}"".format(self.num_fidelity_computes)); print(""Number of gradient function calls: ""; ""{}"".format(self.num_grad_func_calls)); print(""Number of times gradients are computed: ""; ""{}"".format(self.num_grad_computes)); print(""Number of times timeslot evolution is recomputed: ""; ""{}"".format(self.num_tslot_recompute)); print(""""). def report_amp_updates(self):; print(""**** Control amplitudes ****""); print(""Number of control amplitude updates: ""; ""{}"".format(self.num_ctrl_amp_updates)); print(""Mean number of updates per iteration: ""; ""{}"".format(self.mean_num_ctrl_amp_updates_per_iter)); print(""Number of timeslot values changed: ""; ""{}"".format(self.num_timeslot_changes)); print(""Mean number of timeslot changes per update: ""; ""{}"".format(self.mean_num_timeslot_changes_per_update)); print(""Number of amplitude values changed: ""; ""{}"".format(self.num_ctrl_amp_changes)); print(""Mean number of amplitude changes per update: ""; ""{}"".format(self.mean_num_ctrl_amp_changes_per_update)). class StatsDynTsUpdate(Stats):; """"""; Optimisation stats class for configurations where all timeslots are not; necessarily updated at each iteration. In this case it may be interesting; to know how many Hamiltions etc are computed each ctrl amplitude update. Attributes; ----------; num_dyn_gen_computes : integer; Total number of dynamics generator (Hamiltonian) computations,; that is combining drift and control dynamics to calculate the; combined dynamics generator for the timeslot. mean_num_dyn_gen_computes_per",MatchSource.WIKI,docs/4.2/modules/qutip/control/stats.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/control/stats.html
https://qutip.org/docs/4.2/modules/qutip/control/stats.html:9363,Deployability,update,update,9363,"gradient_compute, tot)); print(""""). def report_func_calls(self):; print(""**** Iterations and function calls ****""); print(""Number of iterations: {}"".format(self.num_iter)); print(""Number of fidelity function calls: ""; ""{}"".format(self.num_fidelity_func_calls)); print(""Number of times fidelity is computed: ""; ""{}"".format(self.num_fidelity_computes)); print(""Number of gradient function calls: ""; ""{}"".format(self.num_grad_func_calls)); print(""Number of times gradients are computed: ""; ""{}"".format(self.num_grad_computes)); print(""Number of times timeslot evolution is recomputed: ""; ""{}"".format(self.num_tslot_recompute)); print(""""). def report_amp_updates(self):; print(""**** Control amplitudes ****""); print(""Number of control amplitude updates: ""; ""{}"".format(self.num_ctrl_amp_updates)); print(""Mean number of updates per iteration: ""; ""{}"".format(self.mean_num_ctrl_amp_updates_per_iter)); print(""Number of timeslot values changed: ""; ""{}"".format(self.num_timeslot_changes)); print(""Mean number of timeslot changes per update: ""; ""{}"".format(self.mean_num_timeslot_changes_per_update)); print(""Number of amplitude values changed: ""; ""{}"".format(self.num_ctrl_amp_changes)); print(""Mean number of amplitude changes per update: ""; ""{}"".format(self.mean_num_ctrl_amp_changes_per_update)). class StatsDynTsUpdate(Stats):; """"""; Optimisation stats class for configurations where all timeslots are not; necessarily updated at each iteration. In this case it may be interesting; to know how many Hamiltions etc are computed each ctrl amplitude update. Attributes; ----------; num_dyn_gen_computes : integer; Total number of dynamics generator (Hamiltonian) computations,; that is combining drift and control dynamics to calculate the; combined dynamics generator for the timeslot. mean_num_dyn_gen_computes_per_update : float; # Mean average number of dynamics generator computations per update. mean_wall_time_dyn_gen_compute : float; # Mean average time to compute a timeslot dynamics generator. num_",MatchSource.WIKI,docs/4.2/modules/qutip/control/stats.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/control/stats.html
https://qutip.org/docs/4.2/modules/qutip/control/stats.html:9562,Deployability,update,update,9562,"function calls: ""; ""{}"".format(self.num_fidelity_func_calls)); print(""Number of times fidelity is computed: ""; ""{}"".format(self.num_fidelity_computes)); print(""Number of gradient function calls: ""; ""{}"".format(self.num_grad_func_calls)); print(""Number of times gradients are computed: ""; ""{}"".format(self.num_grad_computes)); print(""Number of times timeslot evolution is recomputed: ""; ""{}"".format(self.num_tslot_recompute)); print(""""). def report_amp_updates(self):; print(""**** Control amplitudes ****""); print(""Number of control amplitude updates: ""; ""{}"".format(self.num_ctrl_amp_updates)); print(""Mean number of updates per iteration: ""; ""{}"".format(self.mean_num_ctrl_amp_updates_per_iter)); print(""Number of timeslot values changed: ""; ""{}"".format(self.num_timeslot_changes)); print(""Mean number of timeslot changes per update: ""; ""{}"".format(self.mean_num_timeslot_changes_per_update)); print(""Number of amplitude values changed: ""; ""{}"".format(self.num_ctrl_amp_changes)); print(""Mean number of amplitude changes per update: ""; ""{}"".format(self.mean_num_ctrl_amp_changes_per_update)). class StatsDynTsUpdate(Stats):; """"""; Optimisation stats class for configurations where all timeslots are not; necessarily updated at each iteration. In this case it may be interesting; to know how many Hamiltions etc are computed each ctrl amplitude update. Attributes; ----------; num_dyn_gen_computes : integer; Total number of dynamics generator (Hamiltonian) computations,; that is combining drift and control dynamics to calculate the; combined dynamics generator for the timeslot. mean_num_dyn_gen_computes_per_update : float; # Mean average number of dynamics generator computations per update. mean_wall_time_dyn_gen_compute : float; # Mean average time to compute a timeslot dynamics generator. num_prop_computes : integer; Total number of propagator (and propagator gradient for exact; gradient types) computations. mean_num_prop_computes_per_update : float; Mean average number of propagator com",MatchSource.WIKI,docs/4.2/modules/qutip/control/stats.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/control/stats.html
https://qutip.org/docs/4.2/modules/qutip/control/stats.html:9696,Deployability,configurat,configurations,9696,"of gradient function calls: ""; ""{}"".format(self.num_grad_func_calls)); print(""Number of times gradients are computed: ""; ""{}"".format(self.num_grad_computes)); print(""Number of times timeslot evolution is recomputed: ""; ""{}"".format(self.num_tslot_recompute)); print(""""). def report_amp_updates(self):; print(""**** Control amplitudes ****""); print(""Number of control amplitude updates: ""; ""{}"".format(self.num_ctrl_amp_updates)); print(""Mean number of updates per iteration: ""; ""{}"".format(self.mean_num_ctrl_amp_updates_per_iter)); print(""Number of timeslot values changed: ""; ""{}"".format(self.num_timeslot_changes)); print(""Mean number of timeslot changes per update: ""; ""{}"".format(self.mean_num_timeslot_changes_per_update)); print(""Number of amplitude values changed: ""; ""{}"".format(self.num_ctrl_amp_changes)); print(""Mean number of amplitude changes per update: ""; ""{}"".format(self.mean_num_ctrl_amp_changes_per_update)). class StatsDynTsUpdate(Stats):; """"""; Optimisation stats class for configurations where all timeslots are not; necessarily updated at each iteration. In this case it may be interesting; to know how many Hamiltions etc are computed each ctrl amplitude update. Attributes; ----------; num_dyn_gen_computes : integer; Total number of dynamics generator (Hamiltonian) computations,; that is combining drift and control dynamics to calculate the; combined dynamics generator for the timeslot. mean_num_dyn_gen_computes_per_update : float; # Mean average number of dynamics generator computations per update. mean_wall_time_dyn_gen_compute : float; # Mean average time to compute a timeslot dynamics generator. num_prop_computes : integer; Total number of propagator (and propagator gradient for exact; gradient types) computations. mean_num_prop_computes_per_update : float; Mean average number of propagator computations per update. mean_wall_time_prop_compute : float; Mean average time to compute a propagator (and its gradient). num_fwd_prop_step_computes : integer; Total num",MatchSource.WIKI,docs/4.2/modules/qutip/control/stats.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/control/stats.html
https://qutip.org/docs/4.2/modules/qutip/control/stats.html:9752,Deployability,update,updated,9752,"of gradient function calls: ""; ""{}"".format(self.num_grad_func_calls)); print(""Number of times gradients are computed: ""; ""{}"".format(self.num_grad_computes)); print(""Number of times timeslot evolution is recomputed: ""; ""{}"".format(self.num_tslot_recompute)); print(""""). def report_amp_updates(self):; print(""**** Control amplitudes ****""); print(""Number of control amplitude updates: ""; ""{}"".format(self.num_ctrl_amp_updates)); print(""Mean number of updates per iteration: ""; ""{}"".format(self.mean_num_ctrl_amp_updates_per_iter)); print(""Number of timeslot values changed: ""; ""{}"".format(self.num_timeslot_changes)); print(""Mean number of timeslot changes per update: ""; ""{}"".format(self.mean_num_timeslot_changes_per_update)); print(""Number of amplitude values changed: ""; ""{}"".format(self.num_ctrl_amp_changes)); print(""Mean number of amplitude changes per update: ""; ""{}"".format(self.mean_num_ctrl_amp_changes_per_update)). class StatsDynTsUpdate(Stats):; """"""; Optimisation stats class for configurations where all timeslots are not; necessarily updated at each iteration. In this case it may be interesting; to know how many Hamiltions etc are computed each ctrl amplitude update. Attributes; ----------; num_dyn_gen_computes : integer; Total number of dynamics generator (Hamiltonian) computations,; that is combining drift and control dynamics to calculate the; combined dynamics generator for the timeslot. mean_num_dyn_gen_computes_per_update : float; # Mean average number of dynamics generator computations per update. mean_wall_time_dyn_gen_compute : float; # Mean average time to compute a timeslot dynamics generator. num_prop_computes : integer; Total number of propagator (and propagator gradient for exact; gradient types) computations. mean_num_prop_computes_per_update : float; Mean average number of propagator computations per update. mean_wall_time_prop_compute : float; Mean average time to compute a propagator (and its gradient). num_fwd_prop_step_computes : integer; Total num",MatchSource.WIKI,docs/4.2/modules/qutip/control/stats.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/control/stats.html
https://qutip.org/docs/4.2/modules/qutip/control/stats.html:9880,Deployability,update,update,9880,"mat(self.num_grad_computes)); print(""Number of times timeslot evolution is recomputed: ""; ""{}"".format(self.num_tslot_recompute)); print(""""). def report_amp_updates(self):; print(""**** Control amplitudes ****""); print(""Number of control amplitude updates: ""; ""{}"".format(self.num_ctrl_amp_updates)); print(""Mean number of updates per iteration: ""; ""{}"".format(self.mean_num_ctrl_amp_updates_per_iter)); print(""Number of timeslot values changed: ""; ""{}"".format(self.num_timeslot_changes)); print(""Mean number of timeslot changes per update: ""; ""{}"".format(self.mean_num_timeslot_changes_per_update)); print(""Number of amplitude values changed: ""; ""{}"".format(self.num_ctrl_amp_changes)); print(""Mean number of amplitude changes per update: ""; ""{}"".format(self.mean_num_ctrl_amp_changes_per_update)). class StatsDynTsUpdate(Stats):; """"""; Optimisation stats class for configurations where all timeslots are not; necessarily updated at each iteration. In this case it may be interesting; to know how many Hamiltions etc are computed each ctrl amplitude update. Attributes; ----------; num_dyn_gen_computes : integer; Total number of dynamics generator (Hamiltonian) computations,; that is combining drift and control dynamics to calculate the; combined dynamics generator for the timeslot. mean_num_dyn_gen_computes_per_update : float; # Mean average number of dynamics generator computations per update. mean_wall_time_dyn_gen_compute : float; # Mean average time to compute a timeslot dynamics generator. num_prop_computes : integer; Total number of propagator (and propagator gradient for exact; gradient types) computations. mean_num_prop_computes_per_update : float; Mean average number of propagator computations per update. mean_wall_time_prop_compute : float; Mean average time to compute a propagator (and its gradient). num_fwd_prop_step_computes : integer; Total number of steps (matrix product) computing forward propagation. mean_num_fwd_prop_step_computes_per_update : float; Mean average num",MatchSource.WIKI,docs/4.2/modules/qutip/control/stats.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/control/stats.html
https://qutip.org/docs/4.2/modules/qutip/control/stats.html:10224,Deployability,update,update,10224,"n: ""; ""{}"".format(self.mean_num_ctrl_amp_updates_per_iter)); print(""Number of timeslot values changed: ""; ""{}"".format(self.num_timeslot_changes)); print(""Mean number of timeslot changes per update: ""; ""{}"".format(self.mean_num_timeslot_changes_per_update)); print(""Number of amplitude values changed: ""; ""{}"".format(self.num_ctrl_amp_changes)); print(""Mean number of amplitude changes per update: ""; ""{}"".format(self.mean_num_ctrl_amp_changes_per_update)). class StatsDynTsUpdate(Stats):; """"""; Optimisation stats class for configurations where all timeslots are not; necessarily updated at each iteration. In this case it may be interesting; to know how many Hamiltions etc are computed each ctrl amplitude update. Attributes; ----------; num_dyn_gen_computes : integer; Total number of dynamics generator (Hamiltonian) computations,; that is combining drift and control dynamics to calculate the; combined dynamics generator for the timeslot. mean_num_dyn_gen_computes_per_update : float; # Mean average number of dynamics generator computations per update. mean_wall_time_dyn_gen_compute : float; # Mean average time to compute a timeslot dynamics generator. num_prop_computes : integer; Total number of propagator (and propagator gradient for exact; gradient types) computations. mean_num_prop_computes_per_update : float; Mean average number of propagator computations per update. mean_wall_time_prop_compute : float; Mean average time to compute a propagator (and its gradient). num_fwd_prop_step_computes : integer; Total number of steps (matrix product) computing forward propagation. mean_num_fwd_prop_step_computes_per_update : float; Mean average number of steps computing forward propagation. mean_wall_time_fwd_prop_compute : float; Mean average time to compute forward propagation. num_onwd_prop_step_computes : integer; Total number of steps (matrix product) computing onward propagation. mean_num_onwd_prop_step_computes_per_update : float; Mean average number of steps computing onward",MatchSource.WIKI,docs/4.2/modules/qutip/control/stats.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/control/stats.html
https://qutip.org/docs/4.2/modules/qutip/control/stats.html:10550,Deployability,update,update,10550,"_changes)); print(""Mean number of amplitude changes per update: ""; ""{}"".format(self.mean_num_ctrl_amp_changes_per_update)). class StatsDynTsUpdate(Stats):; """"""; Optimisation stats class for configurations where all timeslots are not; necessarily updated at each iteration. In this case it may be interesting; to know how many Hamiltions etc are computed each ctrl amplitude update. Attributes; ----------; num_dyn_gen_computes : integer; Total number of dynamics generator (Hamiltonian) computations,; that is combining drift and control dynamics to calculate the; combined dynamics generator for the timeslot. mean_num_dyn_gen_computes_per_update : float; # Mean average number of dynamics generator computations per update. mean_wall_time_dyn_gen_compute : float; # Mean average time to compute a timeslot dynamics generator. num_prop_computes : integer; Total number of propagator (and propagator gradient for exact; gradient types) computations. mean_num_prop_computes_per_update : float; Mean average number of propagator computations per update. mean_wall_time_prop_compute : float; Mean average time to compute a propagator (and its gradient). num_fwd_prop_step_computes : integer; Total number of steps (matrix product) computing forward propagation. mean_num_fwd_prop_step_computes_per_update : float; Mean average number of steps computing forward propagation. mean_wall_time_fwd_prop_compute : float; Mean average time to compute forward propagation. num_onwd_prop_step_computes : integer; Total number of steps (matrix product) computing onward propagation. mean_num_onwd_prop_step_computes_per_update : float; Mean average number of steps computing onward propagation. mean_wall_time_onwd_prop_compute; Mean average time to compute onward propagation; """""". def __init__(self):; self.reset(). def reset(self):; Stats.reset(self); # Dynamics generators (Hamiltonians); self.num_dyn_gen_computes = 0; self.mean_num_dyn_gen_computes_per_update = 0.0; self.mean_wall_time_dyn_gen_compute = 0.",MatchSource.WIKI,docs/4.2/modules/qutip/control/stats.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/control/stats.html
https://qutip.org/docs/4.2/modules/qutip/control/stats.html:13552,Deployability,update,update,13552,"_step_computes /; float(self.num_ctrl_amp_updates)). self.mean_wall_time_fwd_prop_compute = \; (self.wall_time_fwd_prop_compute /; float(self.num_fwd_prop_step_computes)). self.mean_num_onwd_prop_step_computes_per_update = \; (self.num_onwd_prop_step_computes /; float(self.num_ctrl_amp_updates)). self.mean_wall_time_onwd_prop_compute = \; (self.wall_time_onwd_prop_compute /; float(self.num_onwd_prop_step_computes)). def report(self):; """"""; Print a report of the stats to the console; """""". print(""\n------------------------------------""; ""\n---- Control optimisation stats ----""); self.report_timings(); self.report_func_calls(); self.report_amp_updates(); self.report_dyn_gen_comps(); self.report_fwd_prop(); self.report_onwd_prop(); print(""------------------------------------""). def report_dyn_gen_comps(self):; print(""**** {} Computations ****"".format(self.dyn_gen_name)); print(""Total number of {} computations: ""; ""{}"".format(self.dyn_gen_name, self.num_dyn_gen_computes)); print(""Mean number of {} computations per update: ""; ""{}"".format(self.dyn_gen_name,; self.mean_num_dyn_gen_computes_per_update)); print(""Mean wall time to compute {}s: ""; ""{} s"".format(self.dyn_gen_name,; self.mean_wall_time_dyn_gen_compute)); print(""**** Propagator Computations ****""); print(""Total number of propagator computations: ""; ""{}"".format(self.num_prop_computes)); print(""Mean number of propagator computations per update: ""; ""{}"".format(self.mean_num_prop_computes_per_update)); print(""Mean wall time to compute propagator ""; ""{} s"".format(self.mean_wall_time_prop_compute)). def report_fwd_prop(self):; print(""**** Forward Propagation ****""); print(""Total number of forward propagation step computations: ""; ""{}"".format(self.num_fwd_prop_step_computes)); print(""Mean number of forward propagation step computations""; "" per update: ""; ""{}"".format(self.mean_num_fwd_prop_step_computes_per_update)); print(""Mean wall time to compute forward propagation ""; ""{} s"".format(self.mean_wall_time_fwd_prop_compute",MatchSource.WIKI,docs/4.2/modules/qutip/control/stats.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/control/stats.html
https://qutip.org/docs/4.2/modules/qutip/control/stats.html:13937,Deployability,update,update,13937,"t(self.num_onwd_prop_step_computes)). def report(self):; """"""; Print a report of the stats to the console; """""". print(""\n------------------------------------""; ""\n---- Control optimisation stats ----""); self.report_timings(); self.report_func_calls(); self.report_amp_updates(); self.report_dyn_gen_comps(); self.report_fwd_prop(); self.report_onwd_prop(); print(""------------------------------------""). def report_dyn_gen_comps(self):; print(""**** {} Computations ****"".format(self.dyn_gen_name)); print(""Total number of {} computations: ""; ""{}"".format(self.dyn_gen_name, self.num_dyn_gen_computes)); print(""Mean number of {} computations per update: ""; ""{}"".format(self.dyn_gen_name,; self.mean_num_dyn_gen_computes_per_update)); print(""Mean wall time to compute {}s: ""; ""{} s"".format(self.dyn_gen_name,; self.mean_wall_time_dyn_gen_compute)); print(""**** Propagator Computations ****""); print(""Total number of propagator computations: ""; ""{}"".format(self.num_prop_computes)); print(""Mean number of propagator computations per update: ""; ""{}"".format(self.mean_num_prop_computes_per_update)); print(""Mean wall time to compute propagator ""; ""{} s"".format(self.mean_wall_time_prop_compute)). def report_fwd_prop(self):; print(""**** Forward Propagation ****""); print(""Total number of forward propagation step computations: ""; ""{}"".format(self.num_fwd_prop_step_computes)); print(""Mean number of forward propagation step computations""; "" per update: ""; ""{}"".format(self.mean_num_fwd_prop_step_computes_per_update)); print(""Mean wall time to compute forward propagation ""; ""{} s"".format(self.mean_wall_time_fwd_prop_compute)). def report_onwd_prop(self):; print(""**** Onward Propagation ****""); print(""Total number of onward propagation step computations: ""; ""{}"".format(self.num_onwd_prop_step_computes)); print(""Mean number of onward propagation step computations""; "" per update: ""; ""{}"".format(self.mean_num_onwd_prop_step_computes_per_update)); print(""Mean wall time to compute onward propagation ""; ""{",MatchSource.WIKI,docs/4.2/modules/qutip/control/stats.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/control/stats.html
https://qutip.org/docs/4.2/modules/qutip/control/stats.html:14347,Deployability,update,update,14347,"lf.report_amp_updates(); self.report_dyn_gen_comps(); self.report_fwd_prop(); self.report_onwd_prop(); print(""------------------------------------""). def report_dyn_gen_comps(self):; print(""**** {} Computations ****"".format(self.dyn_gen_name)); print(""Total number of {} computations: ""; ""{}"".format(self.dyn_gen_name, self.num_dyn_gen_computes)); print(""Mean number of {} computations per update: ""; ""{}"".format(self.dyn_gen_name,; self.mean_num_dyn_gen_computes_per_update)); print(""Mean wall time to compute {}s: ""; ""{} s"".format(self.dyn_gen_name,; self.mean_wall_time_dyn_gen_compute)); print(""**** Propagator Computations ****""); print(""Total number of propagator computations: ""; ""{}"".format(self.num_prop_computes)); print(""Mean number of propagator computations per update: ""; ""{}"".format(self.mean_num_prop_computes_per_update)); print(""Mean wall time to compute propagator ""; ""{} s"".format(self.mean_wall_time_prop_compute)). def report_fwd_prop(self):; print(""**** Forward Propagation ****""); print(""Total number of forward propagation step computations: ""; ""{}"".format(self.num_fwd_prop_step_computes)); print(""Mean number of forward propagation step computations""; "" per update: ""; ""{}"".format(self.mean_num_fwd_prop_step_computes_per_update)); print(""Mean wall time to compute forward propagation ""; ""{} s"".format(self.mean_wall_time_fwd_prop_compute)). def report_onwd_prop(self):; print(""**** Onward Propagation ****""); print(""Total number of onward propagation step computations: ""; ""{}"".format(self.num_onwd_prop_step_computes)); print(""Mean number of onward propagation step computations""; "" per update: ""; ""{}"".format(self.mean_num_onwd_prop_step_computes_per_update)); print(""Mean wall time to compute onward propagation ""; ""{} s"".format(self.mean_wall_time_onwd_prop_compute)). Â© Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, and A.L. Grimsmo.; Last updated on Jan 17, 2018. . Built with Sphinx using a theme provided by Read the Docs. . ",MatchSource.WIKI,docs/4.2/modules/qutip/control/stats.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/control/stats.html
https://qutip.org/docs/4.2/modules/qutip/control/stats.html:14778,Deployability,update,update,14778,"lf.report_amp_updates(); self.report_dyn_gen_comps(); self.report_fwd_prop(); self.report_onwd_prop(); print(""------------------------------------""). def report_dyn_gen_comps(self):; print(""**** {} Computations ****"".format(self.dyn_gen_name)); print(""Total number of {} computations: ""; ""{}"".format(self.dyn_gen_name, self.num_dyn_gen_computes)); print(""Mean number of {} computations per update: ""; ""{}"".format(self.dyn_gen_name,; self.mean_num_dyn_gen_computes_per_update)); print(""Mean wall time to compute {}s: ""; ""{} s"".format(self.dyn_gen_name,; self.mean_wall_time_dyn_gen_compute)); print(""**** Propagator Computations ****""); print(""Total number of propagator computations: ""; ""{}"".format(self.num_prop_computes)); print(""Mean number of propagator computations per update: ""; ""{}"".format(self.mean_num_prop_computes_per_update)); print(""Mean wall time to compute propagator ""; ""{} s"".format(self.mean_wall_time_prop_compute)). def report_fwd_prop(self):; print(""**** Forward Propagation ****""); print(""Total number of forward propagation step computations: ""; ""{}"".format(self.num_fwd_prop_step_computes)); print(""Mean number of forward propagation step computations""; "" per update: ""; ""{}"".format(self.mean_num_fwd_prop_step_computes_per_update)); print(""Mean wall time to compute forward propagation ""; ""{} s"".format(self.mean_wall_time_fwd_prop_compute)). def report_onwd_prop(self):; print(""**** Onward Propagation ****""); print(""Total number of onward propagation step computations: ""; ""{}"".format(self.num_onwd_prop_step_computes)); print(""Mean number of onward propagation step computations""; "" per update: ""; ""{}"".format(self.mean_num_onwd_prop_step_computes_per_update)); print(""Mean wall time to compute onward propagation ""; ""{} s"".format(self.mean_wall_time_onwd_prop_compute)). Â© Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, and A.L. Grimsmo.; Last updated on Jan 17, 2018. . Built with Sphinx using a theme provided by Read the Docs. . ",MatchSource.WIKI,docs/4.2/modules/qutip/control/stats.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/control/stats.html
https://qutip.org/docs/4.2/modules/qutip/control/stats.html:15074,Deployability,update,updated,15074,"lf.report_amp_updates(); self.report_dyn_gen_comps(); self.report_fwd_prop(); self.report_onwd_prop(); print(""------------------------------------""). def report_dyn_gen_comps(self):; print(""**** {} Computations ****"".format(self.dyn_gen_name)); print(""Total number of {} computations: ""; ""{}"".format(self.dyn_gen_name, self.num_dyn_gen_computes)); print(""Mean number of {} computations per update: ""; ""{}"".format(self.dyn_gen_name,; self.mean_num_dyn_gen_computes_per_update)); print(""Mean wall time to compute {}s: ""; ""{} s"".format(self.dyn_gen_name,; self.mean_wall_time_dyn_gen_compute)); print(""**** Propagator Computations ****""); print(""Total number of propagator computations: ""; ""{}"".format(self.num_prop_computes)); print(""Mean number of propagator computations per update: ""; ""{}"".format(self.mean_num_prop_computes_per_update)); print(""Mean wall time to compute propagator ""; ""{} s"".format(self.mean_wall_time_prop_compute)). def report_fwd_prop(self):; print(""**** Forward Propagation ****""); print(""Total number of forward propagation step computations: ""; ""{}"".format(self.num_fwd_prop_step_computes)); print(""Mean number of forward propagation step computations""; "" per update: ""; ""{}"".format(self.mean_num_fwd_prop_step_computes_per_update)); print(""Mean wall time to compute forward propagation ""; ""{} s"".format(self.mean_wall_time_fwd_prop_compute)). def report_onwd_prop(self):; print(""**** Onward Propagation ****""); print(""Total number of onward propagation step computations: ""; ""{}"".format(self.num_onwd_prop_step_computes)); print(""Mean number of onward propagation step computations""; "" per update: ""; ""{}"".format(self.mean_num_onwd_prop_step_computes_per_update)); print(""Mean wall time to compute onward propagation ""; ""{} s"".format(self.mean_wall_time_onwd_prop_compute)). Â© Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, and A.L. Grimsmo.; Last updated on Jan 17, 2018. . Built with Sphinx using a theme provided by Read the Docs. . ",MatchSource.WIKI,docs/4.2/modules/qutip/control/stats.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/control/stats.html
https://qutip.org/docs/4.2/modules/qutip/control/stats.html:2517,Modifiability,config,configurations,2517,"CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,; # SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT; # LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,; # DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY; # THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT; # (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE; # OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.; ###############################################################################. # @author: Alexander Pitchford; # @email1: agp1@aber.ac.uk; # @email2: alex.pitchford@gmail.com; # @organization: Aberystwyth University; # @supervisor: Daniel Burgarth. """"""; Statistics for the optimisation; Note that some of the stats here are redundant copies from the optimiser; used here for calculations; """"""; import numpy as np; import datetime. [docs]class Stats(object):; """"""; Base class for all optimisation statistics; Used for configurations where all timeslots are updated each iteration; e.g. exact gradients; Note that all times are generated using timeit.default_timer() and are; in seconds. Attributes; ----------; dyn_gen_name : string; Text used in some report functions.; Makes sense to set it to 'Hamiltonian' when using unitary dynamics; Default is simply 'dynamics generator'. num_iter : integer; Number of iterations of the optimisation algorithm. wall_time_optim_start : float; Start time for the optimisation. wall_time_optim_end : float; End time for the optimisation. wall_time_optim : float; Time elasped during the optimisation. wall_time_dyn_gen_compute : float; Total wall (elasped) time computing combined dynamics generator; (for example combining drift and control Hamiltonians). wall_time_prop_compute : float; Total wall (elasped) time computing propagators, that is the; time evolution from one timeslot to the next; Includes calculating the propagator gradient for exact gradients. wall_ti",MatchSource.WIKI,docs/4.2/modules/qutip/control/stats.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/control/stats.html
https://qutip.org/docs/4.2/modules/qutip/control/stats.html:9696,Modifiability,config,configurations,9696,"of gradient function calls: ""; ""{}"".format(self.num_grad_func_calls)); print(""Number of times gradients are computed: ""; ""{}"".format(self.num_grad_computes)); print(""Number of times timeslot evolution is recomputed: ""; ""{}"".format(self.num_tslot_recompute)); print(""""). def report_amp_updates(self):; print(""**** Control amplitudes ****""); print(""Number of control amplitude updates: ""; ""{}"".format(self.num_ctrl_amp_updates)); print(""Mean number of updates per iteration: ""; ""{}"".format(self.mean_num_ctrl_amp_updates_per_iter)); print(""Number of timeslot values changed: ""; ""{}"".format(self.num_timeslot_changes)); print(""Mean number of timeslot changes per update: ""; ""{}"".format(self.mean_num_timeslot_changes_per_update)); print(""Number of amplitude values changed: ""; ""{}"".format(self.num_ctrl_amp_changes)); print(""Mean number of amplitude changes per update: ""; ""{}"".format(self.mean_num_ctrl_amp_changes_per_update)). class StatsDynTsUpdate(Stats):; """"""; Optimisation stats class for configurations where all timeslots are not; necessarily updated at each iteration. In this case it may be interesting; to know how many Hamiltions etc are computed each ctrl amplitude update. Attributes; ----------; num_dyn_gen_computes : integer; Total number of dynamics generator (Hamiltonian) computations,; that is combining drift and control dynamics to calculate the; combined dynamics generator for the timeslot. mean_num_dyn_gen_computes_per_update : float; # Mean average number of dynamics generator computations per update. mean_wall_time_dyn_gen_compute : float; # Mean average time to compute a timeslot dynamics generator. num_prop_computes : integer; Total number of propagator (and propagator gradient for exact; gradient types) computations. mean_num_prop_computes_per_update : float; Mean average number of propagator computations per update. mean_wall_time_prop_compute : float; Mean average time to compute a propagator (and its gradient). num_fwd_prop_step_computes : integer; Total num",MatchSource.WIKI,docs/4.2/modules/qutip/control/stats.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/control/stats.html
https://qutip.org/docs/4.2/modules/qutip/control/stats.html:2324,Safety,redund,redundant,2324," BUT NOT; # LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A; # PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT; # HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,; # SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT; # LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,; # DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY; # THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT; # (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE; # OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.; ###############################################################################. # @author: Alexander Pitchford; # @email1: agp1@aber.ac.uk; # @email2: alex.pitchford@gmail.com; # @organization: Aberystwyth University; # @supervisor: Daniel Burgarth. """"""; Statistics for the optimisation; Note that some of the stats here are redundant copies from the optimiser; used here for calculations; """"""; import numpy as np; import datetime. [docs]class Stats(object):; """"""; Base class for all optimisation statistics; Used for configurations where all timeslots are updated each iteration; e.g. exact gradients; Note that all times are generated using timeit.default_timer() and are; in seconds. Attributes; ----------; dyn_gen_name : string; Text used in some report functions.; Makes sense to set it to 'Hamiltonian' when using unitary dynamics; Default is simply 'dynamics generator'. num_iter : integer; Number of iterations of the optimisation algorithm. wall_time_optim_start : float; Start time for the optimisation. wall_time_optim_end : float; End time for the optimisation. wall_time_optim : float; Time elasped during the optimisation. wall_time_dyn_gen_compute : float; Total wall (elasped) time computing combined dynamics generator; (for example combining drift and control Hamiltonians). wall_time_prop_compute : float; Total wall (el",MatchSource.WIKI,docs/4.2/modules/qutip/control/stats.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/control/stats.html
https://qutip.org/docs/4.2/modules/qutip/control/stats.html:2849,Usability,simpl,simply,2849,"CT, STRICT LIABILITY, OR TORT; # (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE; # OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.; ###############################################################################. # @author: Alexander Pitchford; # @email1: agp1@aber.ac.uk; # @email2: alex.pitchford@gmail.com; # @organization: Aberystwyth University; # @supervisor: Daniel Burgarth. """"""; Statistics for the optimisation; Note that some of the stats here are redundant copies from the optimiser; used here for calculations; """"""; import numpy as np; import datetime. [docs]class Stats(object):; """"""; Base class for all optimisation statistics; Used for configurations where all timeslots are updated each iteration; e.g. exact gradients; Note that all times are generated using timeit.default_timer() and are; in seconds. Attributes; ----------; dyn_gen_name : string; Text used in some report functions.; Makes sense to set it to 'Hamiltonian' when using unitary dynamics; Default is simply 'dynamics generator'. num_iter : integer; Number of iterations of the optimisation algorithm. wall_time_optim_start : float; Start time for the optimisation. wall_time_optim_end : float; End time for the optimisation. wall_time_optim : float; Time elasped during the optimisation. wall_time_dyn_gen_compute : float; Total wall (elasped) time computing combined dynamics generator; (for example combining drift and control Hamiltonians). wall_time_prop_compute : float; Total wall (elasped) time computing propagators, that is the; time evolution from one timeslot to the next; Includes calculating the propagator gradient for exact gradients. wall_time_fwd_prop_compute : float; Total wall (elasped) time computing combined forward propagation,; that is the time evolution from the start to a specific timeslot.; Excludes calculating the propagators themselves. wall_time_onwd_prop_compute : float; Total wall (elasped) time computing combined onward propagation,; th",MatchSource.WIKI,docs/4.2/modules/qutip/control/stats.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/control/stats.html
https://qutip.org/docs/4.2/modules/qutip/control/stats.html:5478,Usability,clear,clear,5478,"ity_computes : integer; Number of time the fidelity is computed; (It is only computed if any amplitudes changed since the last call). num_grad_computes : integer; Number of time the gradient is computed; (It is only computed if any amplitudes changed since the last call). num_ctrl_amp_updates : integer; Number of times the control amplitudes are updated. mean_num_ctrl_amp_updates_per_iter : float; Mean number of control amplitude updates per iteration. num_timeslot_changes : integer; Number of times the amplitudes of a any control in a timeslot changes. mean_num_timeslot_changes_per_update : float; Mean average number of timeslot amplitudes that are changed per update. num_ctrl_amp_changes : integer; Number of times individual control amplitudes that are changed. mean_num_ctrl_amp_changes_per_update : float; Mean average number of control amplitudes that are changed per update; """"""; def __init__(self):; self.reset(). def reset(self):; self.dyn_gen_name = ""dynamics generator""; self.clear(). def clear(self):; self.num_iter = 0; # Duration attributes; self.wall_time_optim_start = 0.0; self.wall_time_optim_end = 0.0; self.wall_time_optim = 0.0; self.wall_time_dyn_gen_compute = 0.0; self.wall_time_prop_compute = 0.0; self.wall_time_fwd_prop_compute = 0.0; self.wall_time_onwd_prop_compute = 0.0; self.wall_time_gradient_compute = 0.0; # Fidelity and gradient function calls and computes; self.num_fidelity_func_calls = 0; self.num_grad_func_calls = 0; self.num_tslot_recompute = 0; self.num_fidelity_computes = 0; self.num_grad_computes = 0; # Control amplitudes; self.num_ctrl_amp_updates = 0; self.mean_num_ctrl_amp_updates_per_iter = 0.0; self.num_timeslot_changes = 0; self.mean_num_timeslot_changes_per_update = 0.0; self.num_ctrl_amp_changes = 0; self.mean_num_ctrl_amp_changes_per_update = 0.0. [docs] def calculate(self):; """"""; Perform the calculations (e.g. averages) that are required on the stats; Should be called before calling report; """"""; # If the optimation is still ru",MatchSource.WIKI,docs/4.2/modules/qutip/control/stats.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/control/stats.html
https://qutip.org/docs/4.2/modules/qutip/control/stats.html:5491,Usability,clear,clear,5491,"nteger; Number of time the fidelity is computed; (It is only computed if any amplitudes changed since the last call). num_grad_computes : integer; Number of time the gradient is computed; (It is only computed if any amplitudes changed since the last call). num_ctrl_amp_updates : integer; Number of times the control amplitudes are updated. mean_num_ctrl_amp_updates_per_iter : float; Mean number of control amplitude updates per iteration. num_timeslot_changes : integer; Number of times the amplitudes of a any control in a timeslot changes. mean_num_timeslot_changes_per_update : float; Mean average number of timeslot amplitudes that are changed per update. num_ctrl_amp_changes : integer; Number of times individual control amplitudes that are changed. mean_num_ctrl_amp_changes_per_update : float; Mean average number of control amplitudes that are changed per update; """"""; def __init__(self):; self.reset(). def reset(self):; self.dyn_gen_name = ""dynamics generator""; self.clear(). def clear(self):; self.num_iter = 0; # Duration attributes; self.wall_time_optim_start = 0.0; self.wall_time_optim_end = 0.0; self.wall_time_optim = 0.0; self.wall_time_dyn_gen_compute = 0.0; self.wall_time_prop_compute = 0.0; self.wall_time_fwd_prop_compute = 0.0; self.wall_time_onwd_prop_compute = 0.0; self.wall_time_gradient_compute = 0.0; # Fidelity and gradient function calls and computes; self.num_fidelity_func_calls = 0; self.num_grad_func_calls = 0; self.num_tslot_recompute = 0; self.num_fidelity_computes = 0; self.num_grad_computes = 0; # Control amplitudes; self.num_ctrl_amp_updates = 0; self.mean_num_ctrl_amp_updates_per_iter = 0.0; self.num_timeslot_changes = 0; self.mean_num_timeslot_changes_per_update = 0.0; self.num_ctrl_amp_changes = 0; self.mean_num_ctrl_amp_changes_per_update = 0.0. [docs] def calculate(self):; """"""; Perform the calculations (e.g. averages) that are required on the stats; Should be called before calling report; """"""; # If the optimation is still running then the o",MatchSource.WIKI,docs/4.2/modules/qutip/control/stats.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/control/stats.html
https://qutip.org/docs/4.2/modules/qutip/control/termcond.html:2789,Availability,error,error,2789,"ON) HOWEVER CAUSED AND ON ANY; # THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT; # (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE; # OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.; ###############################################################################. # @author: Alexander Pitchford; # @email1: agp1@aber.ac.uk; # @email2: alex.pitchford@gmail.com; # @organization: Aberystwyth University; # @supervisor: Daniel Burgarth. """"""; Classes containing termination conditions for the control pulse optimisation; i.e. attributes that will be checked during the optimisation, that; will determine if the algorithm has completed its task / exceeded limits; """""". [docs]class TerminationConditions(object):; """"""; Base class for all termination conditions; Used to determine when to stop the optimisation algorithm; Note different subclasses should be used to match the type of; optimisation being used. Attributes; ----------; fid_err_targ : float; Target fidelity error. fid_goal : float; goal fidelity, e.g. 1 - self.fid_err_targ; It its typical to set this for unitary systems. max_wall_time : float; # maximum time for optimisation (seconds). min_gradient_norm : float; Minimum normalised gradient after which optimisation will terminate. max_iterations : integer; Maximum iterations of the optimisation algorithm. max_fid_func_calls : integer; Maximum number of calls to the fidelity function during; the optimisation algorithm; ; accuracy_factor : float; Determines the accuracy of the result.; Typical values for accuracy_factor are: 1e12 for low accuracy;; 1e7 for moderate accuracy; 10.0 for extremely high accuracy; scipy.optimize.fmin_l_bfgs_b factr argument.; Only set for specific methods (fmin_l_bfgs_b) that uses this; Otherwise the same thing is passed as method_option ftol; (although the scale is different); Hence it is not defined here, but may be set by the user; """"""; def __init__(self):; self.reset(). def reset(se",MatchSource.WIKI,docs/4.2/modules/qutip/control/termcond.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/control/termcond.html
https://qutip.org/docs/4.2/modules/qutip/control/termcond.html:4047,Deployability,update,updated,4047,"@aber.ac.uk; # @email2: alex.pitchford@gmail.com; # @organization: Aberystwyth University; # @supervisor: Daniel Burgarth. """"""; Classes containing termination conditions for the control pulse optimisation; i.e. attributes that will be checked during the optimisation, that; will determine if the algorithm has completed its task / exceeded limits; """""". [docs]class TerminationConditions(object):; """"""; Base class for all termination conditions; Used to determine when to stop the optimisation algorithm; Note different subclasses should be used to match the type of; optimisation being used. Attributes; ----------; fid_err_targ : float; Target fidelity error. fid_goal : float; goal fidelity, e.g. 1 - self.fid_err_targ; It its typical to set this for unitary systems. max_wall_time : float; # maximum time for optimisation (seconds). min_gradient_norm : float; Minimum normalised gradient after which optimisation will terminate. max_iterations : integer; Maximum iterations of the optimisation algorithm. max_fid_func_calls : integer; Maximum number of calls to the fidelity function during; the optimisation algorithm; ; accuracy_factor : float; Determines the accuracy of the result.; Typical values for accuracy_factor are: 1e12 for low accuracy;; 1e7 for moderate accuracy; 10.0 for extremely high accuracy; scipy.optimize.fmin_l_bfgs_b factr argument.; Only set for specific methods (fmin_l_bfgs_b) that uses this; Otherwise the same thing is passed as method_option ftol; (although the scale is different); Hence it is not defined here, but may be set by the user; """"""; def __init__(self):; self.reset(). def reset(self):; self.fid_err_targ = 1e-5; self.fid_goal = None; self.max_wall_time = 60*60.0; self.min_gradient_norm = 1e-5; self.max_iterations = 1e10; self.max_fid_func_calls = 1e10. Â© Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, and A.L. Grimsmo.; Last updated on Jan 17, 2018. . Built with Sphinx using a theme provided by Read the Docs. . ",MatchSource.WIKI,docs/4.2/modules/qutip/control/termcond.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/control/termcond.html
https://qutip.org/docs/4.2/modules/qutip/control/termcond.html:3456,Performance,optimiz,optimize,3456,"@aber.ac.uk; # @email2: alex.pitchford@gmail.com; # @organization: Aberystwyth University; # @supervisor: Daniel Burgarth. """"""; Classes containing termination conditions for the control pulse optimisation; i.e. attributes that will be checked during the optimisation, that; will determine if the algorithm has completed its task / exceeded limits; """""". [docs]class TerminationConditions(object):; """"""; Base class for all termination conditions; Used to determine when to stop the optimisation algorithm; Note different subclasses should be used to match the type of; optimisation being used. Attributes; ----------; fid_err_targ : float; Target fidelity error. fid_goal : float; goal fidelity, e.g. 1 - self.fid_err_targ; It its typical to set this for unitary systems. max_wall_time : float; # maximum time for optimisation (seconds). min_gradient_norm : float; Minimum normalised gradient after which optimisation will terminate. max_iterations : integer; Maximum iterations of the optimisation algorithm. max_fid_func_calls : integer; Maximum number of calls to the fidelity function during; the optimisation algorithm; ; accuracy_factor : float; Determines the accuracy of the result.; Typical values for accuracy_factor are: 1e12 for low accuracy;; 1e7 for moderate accuracy; 10.0 for extremely high accuracy; scipy.optimize.fmin_l_bfgs_b factr argument.; Only set for specific methods (fmin_l_bfgs_b) that uses this; Otherwise the same thing is passed as method_option ftol; (although the scale is different); Hence it is not defined here, but may be set by the user; """"""; def __init__(self):; self.reset(). def reset(self):; self.fid_err_targ = 1e-5; self.fid_goal = None; self.max_wall_time = 60*60.0; self.min_gradient_norm = 1e-5; self.max_iterations = 1e10; self.max_fid_func_calls = 1e10. Â© Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, and A.L. Grimsmo.; Last updated on Jan 17, 2018. . Built with Sphinx using a theme provided by Read the Docs. . ",MatchSource.WIKI,docs/4.2/modules/qutip/control/termcond.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/control/termcond.html
https://qutip.org/docs/4.2/modules/qutip/control/tslotcomp.html:3624,Availability,error,errors,3624,"; when using optimisation methods like BFGS in the GRAPE algorithm. The alternative (DynUpdate) assumes that only a subset of amplitudes; are updated each iteration and attempts to minimise the number of expensive; calculations accordingly. This would be the appropriate class for Krotov type; methods. Note that the Stats_DynTsUpdate class must be used for stats; in conjunction with this class.; NOTE: AJGP 2011-10-2014: This _DynUpdate class currently has some bug,; no pressing need to fix it presently. If all amplitudes change at each update, then the behavior of the classes is; equivalent. _UpdateAll is easier to understand and potentially slightly faster; in this situation. Note the methods in the _DynUpdate class were inspired by:; DYNAMO - Dynamic Framework for Quantum Optimal Control; See Machnes et.al., arXiv.1011.4874; """""". import os; import warnings; import numpy as np; import timeit; # QuTiP; from qutip import Qobj; # QuTiP control modules; import qutip.control.errors as errors; import qutip.control.dump as qtrldump; # QuTiP logging; import qutip.logging_utils as logging; logger = logging.get_logger(). def _func_deprecation(message, stacklevel=3):; """"""; Issue deprecation warning; Using stacklevel=3 will ensure message refers the function; calling with the deprecated parameter,; """"""; warnings.warn(message, DeprecationWarning, stacklevel=stacklevel). [docs]class TimeslotComputer(object):; """"""; Base class for all Timeslot Computers; Note: this must be instantiated with a Dynamics object, that is the; container for the data that the methods operate on. Attributes; ----------; log_level : integer; level of messaging output from the logger.; Options are attributes of qutip.logging_utils,; in decreasing levels of messaging, are:; DEBUG_INTENSE, DEBUG_VERBOSE, DEBUG, INFO, WARN, ERROR, CRITICAL; Anything WARN or above is effectively 'quiet' execution,; assuming everything runs as expected.; The default NOTSET implies that the level will be taken from; the QuTiP sett",MatchSource.WIKI,docs/4.2/modules/qutip/control/tslotcomp.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/control/tslotcomp.html
https://qutip.org/docs/4.2/modules/qutip/control/tslotcomp.html:3634,Availability,error,errors,3634,"; when using optimisation methods like BFGS in the GRAPE algorithm. The alternative (DynUpdate) assumes that only a subset of amplitudes; are updated each iteration and attempts to minimise the number of expensive; calculations accordingly. This would be the appropriate class for Krotov type; methods. Note that the Stats_DynTsUpdate class must be used for stats; in conjunction with this class.; NOTE: AJGP 2011-10-2014: This _DynUpdate class currently has some bug,; no pressing need to fix it presently. If all amplitudes change at each update, then the behavior of the classes is; equivalent. _UpdateAll is easier to understand and potentially slightly faster; in this situation. Note the methods in the _DynUpdate class were inspired by:; DYNAMO - Dynamic Framework for Quantum Optimal Control; See Machnes et.al., arXiv.1011.4874; """""". import os; import warnings; import numpy as np; import timeit; # QuTiP; from qutip import Qobj; # QuTiP control modules; import qutip.control.errors as errors; import qutip.control.dump as qtrldump; # QuTiP logging; import qutip.logging_utils as logging; logger = logging.get_logger(). def _func_deprecation(message, stacklevel=3):; """"""; Issue deprecation warning; Using stacklevel=3 will ensure message refers the function; calling with the deprecated parameter,; """"""; warnings.warn(message, DeprecationWarning, stacklevel=stacklevel). [docs]class TimeslotComputer(object):; """"""; Base class for all Timeslot Computers; Note: this must be instantiated with a Dynamics object, that is the; container for the data that the methods operate on. Attributes; ----------; log_level : integer; level of messaging output from the logger.; Options are attributes of qutip.logging_utils,; in decreasing levels of messaging, are:; DEBUG_INTENSE, DEBUG_VERBOSE, DEBUG, INFO, WARN, ERROR, CRITICAL; Anything WARN or above is effectively 'quiet' execution,; assuming everything runs as expected.; The default NOTSET implies that the level will be taken from; the QuTiP sett",MatchSource.WIKI,docs/4.2/modules/qutip/control/tslotcomp.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/control/tslotcomp.html
https://qutip.org/docs/4.2/modules/qutip/control/tslotcomp.html:14206,Availability,mask,masks,14206,"inal; # evolution operator vals (which never change) and hence all other; # values are set as requiring calculation.; n_ts = self.parent.num_tslots; self.dyn_gen_recalc = np.ones(n_ts, dtype=bool); # np.ones(n_ts, dtype=bool); self.prop_recalc = np.ones(n_ts, dtype=bool); self.evo_init2t_recalc = np.ones(n_ts + 1, dtype=bool); self.evo_init2t_recalc[0] = False; self.evo_t2targ_recalc = np.ones(n_ts + 1, dtype=bool); self.evo_t2targ_recalc[-1] = False. # The _calc_now map is used to during the calcs to specify; # which values need updating immediately; self.dyn_gen_calc_now = np.zeros(n_ts, dtype=bool); self.prop_calc_now = np.zeros(n_ts, dtype=bool); self.evo_init2t_calc_now = np.zeros(n_ts + 1, dtype=bool); self.evo_t2targ_calc_now = np.zeros(n_ts + 1, dtype=bool). def compare_amps(self, new_amps):; """"""; Determine which timeslots will have changed Hamiltonians; i.e. any where control amplitudes have changed for that slot; and mark (using masks) them and corresponding exponentiations and; time evo operators for update; Returns: True if amplitudes are the same, False if they have changed; """"""; dyn = self.parent; n_ts = dyn.num_tslots; # create boolean array with same shape as ctrl_amps; # True where value in New_amps differs, otherwise false; if self.parent.ctrl_amps is None:; changed_amps = np.ones(new_amps.shape, dtype=bool); else:; changed_amps = self.parent.ctrl_amps != new_amps. if self.log_level <= logging.DEBUG_VERBOSE:; logger.log(logging.DEBUG_VERBOSE, ""changed_amps:\n{}"".format(; changed_amps)); # create Boolean vector with same length as number of timeslots; # True where any of the amplitudes have changed, otherwise false; changed_ts_mask = np.any(changed_amps, 1); # if any of the amplidudes have changed then mark for recalc; if np.any(changed_ts_mask):; self.dyn_gen_recalc[changed_ts_mask] = True; self.prop_recalc[changed_ts_mask] = True; dyn.ctrl_amps = new_amps; if self.log_level <= logging.DEBUG:; logger.debug(""Control amplitudes updated""); # find firs",MatchSource.WIKI,docs/4.2/modules/qutip/control/tslotcomp.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/control/tslotcomp.html
https://qutip.org/docs/4.2/modules/qutip/control/tslotcomp.html:20388,Availability,error,errors,20388,"w.sum(); dyn.stats.wall_time_onwd_prop_compute += \; timeit.default_timer() - time_start. # Clear calc now flags; self.dyn_gen_calc_now[:] = False; self.prop_calc_now[:] = False; self.evo_init2t_calc_now[:] = False; self.evo_t2targ_calc_now[:] = False. def get_timeslot_for_fidelity_calc(self):; """"""; Returns the timeslot index that will be used calculate current fidelity; value. Attempts to find a timeslot where the least number of propagator; calculations will be required.; Flags the associated evolution operators for calculation now; """"""; dyn = self.parent; n_ts = dyn.num_tslots; kBothEvoCurrent = -1; kFwdEvoCurrent = -1; kUse = -1; # If no specific timeslot set in config, then determine dynamically; if kUse < 0:; for k in range(n_ts):; # find first timeslot where both evo_init2t and; # evo_t2targ are current; if not self.evo_init2t_recalc[k]:; kFwdEvoCurrent = k; if not self.evo_t2targ_recalc[k]:; kBothEvoCurrent = k; break. if kBothEvoCurrent >= 0:; kUse = kBothEvoCurrent; elif kFwdEvoCurrent >= 0:; kUse = kFwdEvoCurrent; else:; raise errors.FunctionalError(""No timeslot found matching ""; ""criteria""). self.evo_init2t_calc_now[kUse] = True; self.evo_t2targ_calc_now[kUse] = True; return kUse. class EvoCompSummary(qtrldump.DumpSummaryItem):; """"""; A summary of the most recent time evolution computation; Used in stats calculations and for data dumping; ; Attributes; ----------; evo_dump_idx : int; Index of the linked :class:`dump.EvoCompDumpItem`; None if no linked item; ; iter_num : int; Iteration number of the pulse optimisation; None if evolution compute outside of a pulse optimisation; ; fid_func_call_num : int; Fidelity function call number of the pulse optimisation; None if evolution compute outside of a pulse optimisation; ; grad_func_call_num : int; Gradient function call number of the pulse optimisation; None if evolution compute outside of a pulse optimisation; ; num_amps_changed : int; Number of control timeslot amplitudes changed since previous; evolution ca",MatchSource.WIKI,docs/4.2/modules/qutip/control/tslotcomp.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/control/tslotcomp.html
https://qutip.org/docs/4.2/modules/qutip/control/tslotcomp.html:2415,Deployability,update,update,2415,"INCLUDING, BUT NOT; # LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A; # PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT; # HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,; # SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT; # LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,; # DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY; # THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT; # (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE; # OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.; ###############################################################################. # @author: Alexander Pitchford; # @email1: agp1@aber.ac.uk; # @email2: alex.pitchford@gmail.com; # @organization: Aberystwyth University; # @supervisor: Daniel Burgarth. """"""; Timeslot Computer; These classes determine which dynamics generators, propagators and evolutions; are recalculated when there is a control amplitude update.; The timeslot computer processes the lists held by the dynamics object. The default (UpdateAll) updates all of these each amp update, on the; assumption that all amplitudes are changed each iteration. This is typical; when using optimisation methods like BFGS in the GRAPE algorithm. The alternative (DynUpdate) assumes that only a subset of amplitudes; are updated each iteration and attempts to minimise the number of expensive; calculations accordingly. This would be the appropriate class for Krotov type; methods. Note that the Stats_DynTsUpdate class must be used for stats; in conjunction with this class.; NOTE: AJGP 2011-10-2014: This _DynUpdate class currently has some bug,; no pressing need to fix it presently. If all amplitudes change at each update, then the behavior of the classes is; equivalent. _UpdateAll is easier to understand and potentially slightly faster; in this situation. Note the methods ",MatchSource.WIKI,docs/4.2/modules/qutip/control/tslotcomp.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/control/tslotcomp.html
https://qutip.org/docs/4.2/modules/qutip/control/tslotcomp.html:2519,Deployability,update,updates,2519,"NDIRECT, INCIDENTAL,; # SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT; # LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,; # DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY; # THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT; # (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE; # OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.; ###############################################################################. # @author: Alexander Pitchford; # @email1: agp1@aber.ac.uk; # @email2: alex.pitchford@gmail.com; # @organization: Aberystwyth University; # @supervisor: Daniel Burgarth. """"""; Timeslot Computer; These classes determine which dynamics generators, propagators and evolutions; are recalculated when there is a control amplitude update.; The timeslot computer processes the lists held by the dynamics object. The default (UpdateAll) updates all of these each amp update, on the; assumption that all amplitudes are changed each iteration. This is typical; when using optimisation methods like BFGS in the GRAPE algorithm. The alternative (DynUpdate) assumes that only a subset of amplitudes; are updated each iteration and attempts to minimise the number of expensive; calculations accordingly. This would be the appropriate class for Krotov type; methods. Note that the Stats_DynTsUpdate class must be used for stats; in conjunction with this class.; NOTE: AJGP 2011-10-2014: This _DynUpdate class currently has some bug,; no pressing need to fix it presently. If all amplitudes change at each update, then the behavior of the classes is; equivalent. _UpdateAll is easier to understand and potentially slightly faster; in this situation. Note the methods in the _DynUpdate class were inspired by:; DYNAMO - Dynamic Framework for Quantum Optimal Control; See Machnes et.al., arXiv.1011.4874; """""". import os; import warnings; import numpy as np; import timeit; # QuTiP; from ",MatchSource.WIKI,docs/4.2/modules/qutip/control/tslotcomp.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/control/tslotcomp.html
https://qutip.org/docs/4.2/modules/qutip/control/tslotcomp.html:2549,Deployability,update,update,2549,"NDIRECT, INCIDENTAL,; # SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT; # LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,; # DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY; # THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT; # (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE; # OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.; ###############################################################################. # @author: Alexander Pitchford; # @email1: agp1@aber.ac.uk; # @email2: alex.pitchford@gmail.com; # @organization: Aberystwyth University; # @supervisor: Daniel Burgarth. """"""; Timeslot Computer; These classes determine which dynamics generators, propagators and evolutions; are recalculated when there is a control amplitude update.; The timeslot computer processes the lists held by the dynamics object. The default (UpdateAll) updates all of these each amp update, on the; assumption that all amplitudes are changed each iteration. This is typical; when using optimisation methods like BFGS in the GRAPE algorithm. The alternative (DynUpdate) assumes that only a subset of amplitudes; are updated each iteration and attempts to minimise the number of expensive; calculations accordingly. This would be the appropriate class for Krotov type; methods. Note that the Stats_DynTsUpdate class must be used for stats; in conjunction with this class.; NOTE: AJGP 2011-10-2014: This _DynUpdate class currently has some bug,; no pressing need to fix it presently. If all amplitudes change at each update, then the behavior of the classes is; equivalent. _UpdateAll is easier to understand and potentially slightly faster; in this situation. Note the methods in the _DynUpdate class were inspired by:; DYNAMO - Dynamic Framework for Quantum Optimal Control; See Machnes et.al., arXiv.1011.4874; """""". import os; import warnings; import numpy as np; import timeit; # QuTiP; from ",MatchSource.WIKI,docs/4.2/modules/qutip/control/tslotcomp.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/control/tslotcomp.html
https://qutip.org/docs/4.2/modules/qutip/control/tslotcomp.html:2781,Deployability,update,updated,2781,"; # THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT; # (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE; # OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.; ###############################################################################. # @author: Alexander Pitchford; # @email1: agp1@aber.ac.uk; # @email2: alex.pitchford@gmail.com; # @organization: Aberystwyth University; # @supervisor: Daniel Burgarth. """"""; Timeslot Computer; These classes determine which dynamics generators, propagators and evolutions; are recalculated when there is a control amplitude update.; The timeslot computer processes the lists held by the dynamics object. The default (UpdateAll) updates all of these each amp update, on the; assumption that all amplitudes are changed each iteration. This is typical; when using optimisation methods like BFGS in the GRAPE algorithm. The alternative (DynUpdate) assumes that only a subset of amplitudes; are updated each iteration and attempts to minimise the number of expensive; calculations accordingly. This would be the appropriate class for Krotov type; methods. Note that the Stats_DynTsUpdate class must be used for stats; in conjunction with this class.; NOTE: AJGP 2011-10-2014: This _DynUpdate class currently has some bug,; no pressing need to fix it presently. If all amplitudes change at each update, then the behavior of the classes is; equivalent. _UpdateAll is easier to understand and potentially slightly faster; in this situation. Note the methods in the _DynUpdate class were inspired by:; DYNAMO - Dynamic Framework for Quantum Optimal Control; See Machnes et.al., arXiv.1011.4874; """""". import os; import warnings; import numpy as np; import timeit; # QuTiP; from qutip import Qobj; # QuTiP control modules; import qutip.control.errors as errors; import qutip.control.dump as qtrldump; # QuTiP logging; import qutip.logging_utils as logging; logger = logging.get_logger(). def _func_deprecation(mes",MatchSource.WIKI,docs/4.2/modules/qutip/control/tslotcomp.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/control/tslotcomp.html
https://qutip.org/docs/4.2/modules/qutip/control/tslotcomp.html:3180,Deployability,update,update,3180,"organization: Aberystwyth University; # @supervisor: Daniel Burgarth. """"""; Timeslot Computer; These classes determine which dynamics generators, propagators and evolutions; are recalculated when there is a control amplitude update.; The timeslot computer processes the lists held by the dynamics object. The default (UpdateAll) updates all of these each amp update, on the; assumption that all amplitudes are changed each iteration. This is typical; when using optimisation methods like BFGS in the GRAPE algorithm. The alternative (DynUpdate) assumes that only a subset of amplitudes; are updated each iteration and attempts to minimise the number of expensive; calculations accordingly. This would be the appropriate class for Krotov type; methods. Note that the Stats_DynTsUpdate class must be used for stats; in conjunction with this class.; NOTE: AJGP 2011-10-2014: This _DynUpdate class currently has some bug,; no pressing need to fix it presently. If all amplitudes change at each update, then the behavior of the classes is; equivalent. _UpdateAll is easier to understand and potentially slightly faster; in this situation. Note the methods in the _DynUpdate class were inspired by:; DYNAMO - Dynamic Framework for Quantum Optimal Control; See Machnes et.al., arXiv.1011.4874; """""". import os; import warnings; import numpy as np; import timeit; # QuTiP; from qutip import Qobj; # QuTiP control modules; import qutip.control.errors as errors; import qutip.control.dump as qtrldump; # QuTiP logging; import qutip.logging_utils as logging; logger = logging.get_logger(). def _func_deprecation(message, stacklevel=3):; """"""; Issue deprecation warning; Using stacklevel=3 will ensure message refers the function; calling with the deprecated parameter,; """"""; warnings.warn(message, DeprecationWarning, stacklevel=stacklevel). [docs]class TimeslotComputer(object):; """"""; Base class for all Timeslot Computers; Note: this must be instantiated with a Dynamics object, that is the; container for the da",MatchSource.WIKI,docs/4.2/modules/qutip/control/tslotcomp.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/control/tslotcomp.html
https://qutip.org/docs/4.2/modules/qutip/control/tslotcomp.html:6805,Deployability,update,updated,6805,"def flag_all_calc_now(self):; pass. def init_comp(self):; pass. @property; def log_level(self):; return logger.level. @log_level.setter; def log_level(self, lvl):; """"""; Set the log_level attribute and set the level of the logger; that is call logger.setLevel(lvl); """"""; logger.setLevel(lvl); ; [docs] def dump_current(self):; """"""Store a copy of the current time evolution""""""; dyn = self.parent; dump = dyn.dump; if not isinstance(dump, qtrldump.DynamicsDump):; raise RuntimeError(""Cannot dump current evolution, ""; ""as dynamics.dump is not set""); ; anything_dumped = False; item_idx = None; if dump.dump_any:; dump_item = dump.add_evo_dump(); item_idx = dump_item.idx; anything_dumped = True; ; if dump.dump_summary:; dump.add_evo_comp_summary(dump_item_idx=item_idx); anything_dumped = True; ; if not anything_dumped:; logger.warning(""Dump set, but nothing dumped, check dump config""); . [docs]class TSlotCompUpdateAll(TimeslotComputer):; """"""; Timeslot Computer - Update All; Updates all dynamics generators, propagators and evolutions when; ctrl amplitudes are updated; """"""; def reset(self):; TimeslotComputer.reset(self); self.id_text = 'ALL'; self.apply_params(). [docs] def compare_amps(self, new_amps):; """"""; Determine if any amplitudes have changed. If so, then mark the; timeslots as needing recalculation; Returns: True if amplitudes are the same, False if they have changed; """"""; changed = False; dyn = self.parent; ; if (dyn.stats or dyn.dump):; if self.evo_comp_summary:; self.evo_comp_summary.reset(); else:; self.evo_comp_summary = EvoCompSummary(); ecs = self.evo_comp_summary; ; if dyn.ctrl_amps is None:; # Flag fidelity and gradients as needing recalculation; changed = True; if ecs:; ecs.num_amps_changed = len(new_amps.flat); ecs.num_timeslots_changed = new_amps.shape[0]; else:; # create boolean array with same shape as ctrl_amps; # True where value in new_amps differs, otherwise false; changed_amps = dyn.ctrl_amps != new_amps; if np.any(changed_amps):; # Flag fidelity and gr",MatchSource.WIKI,docs/4.2/modules/qutip/control/tslotcomp.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/control/tslotcomp.html
https://qutip.org/docs/4.2/modules/qutip/control/tslotcomp.html:8099,Deployability,update,update,8099,"they have changed; """"""; changed = False; dyn = self.parent; ; if (dyn.stats or dyn.dump):; if self.evo_comp_summary:; self.evo_comp_summary.reset(); else:; self.evo_comp_summary = EvoCompSummary(); ecs = self.evo_comp_summary; ; if dyn.ctrl_amps is None:; # Flag fidelity and gradients as needing recalculation; changed = True; if ecs:; ecs.num_amps_changed = len(new_amps.flat); ecs.num_timeslots_changed = new_amps.shape[0]; else:; # create boolean array with same shape as ctrl_amps; # True where value in new_amps differs, otherwise false; changed_amps = dyn.ctrl_amps != new_amps; if np.any(changed_amps):; # Flag fidelity and gradients as needing recalculation; changed = True; if self.log_level <= logging.DEBUG:; logger.debug(""{} amplitudes changed"".format(; changed_amps.sum())); ; if ecs:; ecs.num_amps_changed = changed_amps.sum(); ecs.num_timeslots_changed = np.any(changed_amps, 1).sum(). else:; if self.log_level <= logging.DEBUG:; logger.debug(""No amplitudes changed""). # *** update stats ***; if dyn.stats:; dyn.stats.num_ctrl_amp_updates += bool(ecs.num_amps_changed); dyn.stats.num_ctrl_amp_changes += ecs.num_amps_changed; dyn.stats.num_timeslot_changes += ecs.num_timeslots_changed; ; if changed:; dyn.ctrl_amps = new_amps; dyn.flag_system_changed(); return False; else:; return True. [docs] def recompute_evolution(self):; """"""; Recalculates the evolution operators.; Dynamics generators (e.g. Hamiltonian) and; prop (propagators) are calculated as necessary; """""". dyn = self.parent; prop_comp = dyn.prop_computer; n_ts = dyn.num_tslots; n_ctrls = dyn.num_ctrls. # Clear the public lists; # These are only set if (external) users access them; dyn._dyn_gen_qobj = None; dyn._prop_qobj = None; dyn._prop_grad_qobj = None; dyn._fwd_evo_qobj = None; dyn._onwd_evo_qobj = None; dyn._onto_evo_qobj = None; ; if (dyn.stats or dyn.dump) and not self.evo_comp_summary:; self.evo_comp_summary = EvoCompSummary(); ecs = self.evo_comp_summary. if dyn.stats is not None:; dyn.stats.num_tslot_r",MatchSource.WIKI,docs/4.2/modules/qutip/control/tslotcomp.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/control/tslotcomp.html
https://qutip.org/docs/4.2/modules/qutip/control/tslotcomp.html:12613,Deployability,update,updated,12613,"itarity_check_level:; dyn.check_unitarity(); ; if dyn.dump:; self.dump_current(). [docs] def get_timeslot_for_fidelity_calc(self):; """"""; Returns the timeslot index that will be used calculate current fidelity; value.; This (default) method simply returns the last timeslot; """"""; _func_deprecation(""'get_timeslot_for_fidelity_calc' is deprecated. ""; ""Use '_get_timeslot_for_fidelity_calc'""); return self._get_timeslot_for_fidelity_calc. def _get_timeslot_for_fidelity_calc(self):; """"""; Returns the timeslot index that will be used calculate current fidelity; value.; This (default) method simply returns the last timeslot; """"""; return self.parent.num_tslots. class TSlotCompDynUpdate(TimeslotComputer):; """"""; Timeslot Computer - Dynamic Update; ********************************; ***** CURRENTLY HAS ISSUES *****; ***** AJGP 2014-10-02; ***** and is therefore not being maintained; ***** i.e. changes made to _UpdateAll are not being implemented here; ********************************; Updates only the dynamics generators, propagators and evolutions as; required when a subset of the ctrl amplitudes are updated.; Will update all if all amps have changed.; """""". def reset(self):; self.dyn_gen_recalc = None; self.prop_recalc = None; self.evo_init2t_recalc = None; self.evo_t2targ_recalc = None; self.dyn_gen_calc_now = None; self.prop_calc_now = None; self.evo_init2t_calc_now = None; self.evo_t2targ_calc_now = None; TimeslotComputer.reset(self); self.id_text = 'DYNAMIC'; self.apply_params(). def init_comp(self):; """"""; Initialise the flags; """"""; ####; # These maps are used to determine what needs to be updated; ####; # Note _recalc means the value needs updating at some point; # e.g. here no values have been set, except the initial and final; # evolution operator vals (which never change) and hence all other; # values are set as requiring calculation.; n_ts = self.parent.num_tslots; self.dyn_gen_recalc = np.ones(n_ts, dtype=bool); # np.ones(n_ts, dtype=bool); self.prop_recalc = np.ones(n_ts",MatchSource.WIKI,docs/4.2/modules/qutip/control/tslotcomp.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/control/tslotcomp.html
https://qutip.org/docs/4.2/modules/qutip/control/tslotcomp.html:12628,Deployability,update,update,12628,"""""""; Returns the timeslot index that will be used calculate current fidelity; value.; This (default) method simply returns the last timeslot; """"""; _func_deprecation(""'get_timeslot_for_fidelity_calc' is deprecated. ""; ""Use '_get_timeslot_for_fidelity_calc'""); return self._get_timeslot_for_fidelity_calc. def _get_timeslot_for_fidelity_calc(self):; """"""; Returns the timeslot index that will be used calculate current fidelity; value.; This (default) method simply returns the last timeslot; """"""; return self.parent.num_tslots. class TSlotCompDynUpdate(TimeslotComputer):; """"""; Timeslot Computer - Dynamic Update; ********************************; ***** CURRENTLY HAS ISSUES *****; ***** AJGP 2014-10-02; ***** and is therefore not being maintained; ***** i.e. changes made to _UpdateAll are not being implemented here; ********************************; Updates only the dynamics generators, propagators and evolutions as; required when a subset of the ctrl amplitudes are updated.; Will update all if all amps have changed.; """""". def reset(self):; self.dyn_gen_recalc = None; self.prop_recalc = None; self.evo_init2t_recalc = None; self.evo_t2targ_recalc = None; self.dyn_gen_calc_now = None; self.prop_calc_now = None; self.evo_init2t_calc_now = None; self.evo_t2targ_calc_now = None; TimeslotComputer.reset(self); self.id_text = 'DYNAMIC'; self.apply_params(). def init_comp(self):; """"""; Initialise the flags; """"""; ####; # These maps are used to determine what needs to be updated; ####; # Note _recalc means the value needs updating at some point; # e.g. here no values have been set, except the initial and final; # evolution operator vals (which never change) and hence all other; # values are set as requiring calculation.; n_ts = self.parent.num_tslots; self.dyn_gen_recalc = np.ones(n_ts, dtype=bool); # np.ones(n_ts, dtype=bool); self.prop_recalc = np.ones(n_ts, dtype=bool); self.evo_init2t_recalc = np.ones(n_ts + 1, dtype=bool); self.evo_init2t_recalc[0] = False; self.evo_t2targ_recalc = n",MatchSource.WIKI,docs/4.2/modules/qutip/control/tslotcomp.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/control/tslotcomp.html
https://qutip.org/docs/4.2/modules/qutip/control/tslotcomp.html:13116,Deployability,update,updated,13116,"imply returns the last timeslot; """"""; return self.parent.num_tslots. class TSlotCompDynUpdate(TimeslotComputer):; """"""; Timeslot Computer - Dynamic Update; ********************************; ***** CURRENTLY HAS ISSUES *****; ***** AJGP 2014-10-02; ***** and is therefore not being maintained; ***** i.e. changes made to _UpdateAll are not being implemented here; ********************************; Updates only the dynamics generators, propagators and evolutions as; required when a subset of the ctrl amplitudes are updated.; Will update all if all amps have changed.; """""". def reset(self):; self.dyn_gen_recalc = None; self.prop_recalc = None; self.evo_init2t_recalc = None; self.evo_t2targ_recalc = None; self.dyn_gen_calc_now = None; self.prop_calc_now = None; self.evo_init2t_calc_now = None; self.evo_t2targ_calc_now = None; TimeslotComputer.reset(self); self.id_text = 'DYNAMIC'; self.apply_params(). def init_comp(self):; """"""; Initialise the flags; """"""; ####; # These maps are used to determine what needs to be updated; ####; # Note _recalc means the value needs updating at some point; # e.g. here no values have been set, except the initial and final; # evolution operator vals (which never change) and hence all other; # values are set as requiring calculation.; n_ts = self.parent.num_tslots; self.dyn_gen_recalc = np.ones(n_ts, dtype=bool); # np.ones(n_ts, dtype=bool); self.prop_recalc = np.ones(n_ts, dtype=bool); self.evo_init2t_recalc = np.ones(n_ts + 1, dtype=bool); self.evo_init2t_recalc[0] = False; self.evo_t2targ_recalc = np.ones(n_ts + 1, dtype=bool); self.evo_t2targ_recalc[-1] = False. # The _calc_now map is used to during the calcs to specify; # which values need updating immediately; self.dyn_gen_calc_now = np.zeros(n_ts, dtype=bool); self.prop_calc_now = np.zeros(n_ts, dtype=bool); self.evo_init2t_calc_now = np.zeros(n_ts + 1, dtype=bool); self.evo_t2targ_calc_now = np.zeros(n_ts + 1, dtype=bool). def compare_amps(self, new_amps):; """"""; Determine which timeslots will",MatchSource.WIKI,docs/4.2/modules/qutip/control/tslotcomp.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/control/tslotcomp.html
https://qutip.org/docs/4.2/modules/qutip/control/tslotcomp.html:14280,Deployability,update,update,14280,"inal; # evolution operator vals (which never change) and hence all other; # values are set as requiring calculation.; n_ts = self.parent.num_tslots; self.dyn_gen_recalc = np.ones(n_ts, dtype=bool); # np.ones(n_ts, dtype=bool); self.prop_recalc = np.ones(n_ts, dtype=bool); self.evo_init2t_recalc = np.ones(n_ts + 1, dtype=bool); self.evo_init2t_recalc[0] = False; self.evo_t2targ_recalc = np.ones(n_ts + 1, dtype=bool); self.evo_t2targ_recalc[-1] = False. # The _calc_now map is used to during the calcs to specify; # which values need updating immediately; self.dyn_gen_calc_now = np.zeros(n_ts, dtype=bool); self.prop_calc_now = np.zeros(n_ts, dtype=bool); self.evo_init2t_calc_now = np.zeros(n_ts + 1, dtype=bool); self.evo_t2targ_calc_now = np.zeros(n_ts + 1, dtype=bool). def compare_amps(self, new_amps):; """"""; Determine which timeslots will have changed Hamiltonians; i.e. any where control amplitudes have changed for that slot; and mark (using masks) them and corresponding exponentiations and; time evo operators for update; Returns: True if amplitudes are the same, False if they have changed; """"""; dyn = self.parent; n_ts = dyn.num_tslots; # create boolean array with same shape as ctrl_amps; # True where value in New_amps differs, otherwise false; if self.parent.ctrl_amps is None:; changed_amps = np.ones(new_amps.shape, dtype=bool); else:; changed_amps = self.parent.ctrl_amps != new_amps. if self.log_level <= logging.DEBUG_VERBOSE:; logger.log(logging.DEBUG_VERBOSE, ""changed_amps:\n{}"".format(; changed_amps)); # create Boolean vector with same length as number of timeslots; # True where any of the amplitudes have changed, otherwise false; changed_ts_mask = np.any(changed_amps, 1); # if any of the amplidudes have changed then mark for recalc; if np.any(changed_ts_mask):; self.dyn_gen_recalc[changed_ts_mask] = True; self.prop_recalc[changed_ts_mask] = True; dyn.ctrl_amps = new_amps; if self.log_level <= logging.DEBUG:; logger.debug(""Control amplitudes updated""); # find firs",MatchSource.WIKI,docs/4.2/modules/qutip/control/tslotcomp.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/control/tslotcomp.html
https://qutip.org/docs/4.2/modules/qutip/control/tslotcomp.html:15231,Deployability,update,updated,15231," are the same, False if they have changed; """"""; dyn = self.parent; n_ts = dyn.num_tslots; # create boolean array with same shape as ctrl_amps; # True where value in New_amps differs, otherwise false; if self.parent.ctrl_amps is None:; changed_amps = np.ones(new_amps.shape, dtype=bool); else:; changed_amps = self.parent.ctrl_amps != new_amps. if self.log_level <= logging.DEBUG_VERBOSE:; logger.log(logging.DEBUG_VERBOSE, ""changed_amps:\n{}"".format(; changed_amps)); # create Boolean vector with same length as number of timeslots; # True where any of the amplitudes have changed, otherwise false; changed_ts_mask = np.any(changed_amps, 1); # if any of the amplidudes have changed then mark for recalc; if np.any(changed_ts_mask):; self.dyn_gen_recalc[changed_ts_mask] = True; self.prop_recalc[changed_ts_mask] = True; dyn.ctrl_amps = new_amps; if self.log_level <= logging.DEBUG:; logger.debug(""Control amplitudes updated""); # find first and last changed dynamics generators; first_changed = None; for i in range(n_ts):; if changed_ts_mask[i]:; last_changed = i; if first_changed is None:; first_changed = i. # set all fwd evo ops after first changed Ham to be recalculated; self.evo_init2t_recalc[first_changed + 1:] = True; # set all bkwd evo ops up to (incl) last changed Ham to be; # recalculated; self.evo_t2targ_recalc[:last_changed + 1] = True. # Flag fidelity and gradients as needing recalculation; dyn.flag_system_changed(). # *** update stats ***; if dyn.stats is not None:; dyn.stats.num_ctrl_amp_updates += 1; dyn.stats.num_ctrl_amp_changes += changed_amps.sum(); dyn.stats.num_timeslot_changes += changed_ts_mask.sum(). return False; else:; return True. def flag_all_calc_now(self):; """"""; Flags all Hamiltonians, propagators and propagations to be; calculated now; """"""; # set flags for calculations; self.dyn_gen_calc_now[:] = True; self.prop_calc_now[:] = True; self.evo_init2t_calc_now[:-1] = True; self.evo_t2targ_calc_now[1:] = True. def recompute_evolution(self):; """"""; Recalcula",MatchSource.WIKI,docs/4.2/modules/qutip/control/tslotcomp.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/control/tslotcomp.html
https://qutip.org/docs/4.2/modules/qutip/control/tslotcomp.html:15758,Deployability,update,update,15758,"changed_amps)); # create Boolean vector with same length as number of timeslots; # True where any of the amplitudes have changed, otherwise false; changed_ts_mask = np.any(changed_amps, 1); # if any of the amplidudes have changed then mark for recalc; if np.any(changed_ts_mask):; self.dyn_gen_recalc[changed_ts_mask] = True; self.prop_recalc[changed_ts_mask] = True; dyn.ctrl_amps = new_amps; if self.log_level <= logging.DEBUG:; logger.debug(""Control amplitudes updated""); # find first and last changed dynamics generators; first_changed = None; for i in range(n_ts):; if changed_ts_mask[i]:; last_changed = i; if first_changed is None:; first_changed = i. # set all fwd evo ops after first changed Ham to be recalculated; self.evo_init2t_recalc[first_changed + 1:] = True; # set all bkwd evo ops up to (incl) last changed Ham to be; # recalculated; self.evo_t2targ_recalc[:last_changed + 1] = True. # Flag fidelity and gradients as needing recalculation; dyn.flag_system_changed(). # *** update stats ***; if dyn.stats is not None:; dyn.stats.num_ctrl_amp_updates += 1; dyn.stats.num_ctrl_amp_changes += changed_amps.sum(); dyn.stats.num_timeslot_changes += changed_ts_mask.sum(). return False; else:; return True. def flag_all_calc_now(self):; """"""; Flags all Hamiltonians, propagators and propagations to be; calculated now; """"""; # set flags for calculations; self.dyn_gen_calc_now[:] = True; self.prop_calc_now[:] = True; self.evo_init2t_calc_now[:-1] = True; self.evo_t2targ_calc_now[1:] = True. def recompute_evolution(self):; """"""; Recalculates the evo_init2t (forward) and evo_t2targ (onward) time; evolution operators; DynGen (Hamiltonians etc) and prop (propagator) are calculated; as necessary; """"""; if self.log_level <= logging.DEBUG_VERBOSE:; logger.log(logging.DEBUG_VERBOSE, ""recomputing evolution ""; ""(DynUpdate)""). dyn = self.parent; n_ts = dyn.num_tslots; # find the op slots that have been marked for update now; # and need recalculation; evo_init2t_recomp_now = self.evo_init2t_ca",MatchSource.WIKI,docs/4.2/modules/qutip/control/tslotcomp.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/control/tslotcomp.html
https://qutip.org/docs/4.2/modules/qutip/control/tslotcomp.html:16687,Deployability,update,update,16687,"adients as needing recalculation; dyn.flag_system_changed(). # *** update stats ***; if dyn.stats is not None:; dyn.stats.num_ctrl_amp_updates += 1; dyn.stats.num_ctrl_amp_changes += changed_amps.sum(); dyn.stats.num_timeslot_changes += changed_ts_mask.sum(). return False; else:; return True. def flag_all_calc_now(self):; """"""; Flags all Hamiltonians, propagators and propagations to be; calculated now; """"""; # set flags for calculations; self.dyn_gen_calc_now[:] = True; self.prop_calc_now[:] = True; self.evo_init2t_calc_now[:-1] = True; self.evo_t2targ_calc_now[1:] = True. def recompute_evolution(self):; """"""; Recalculates the evo_init2t (forward) and evo_t2targ (onward) time; evolution operators; DynGen (Hamiltonians etc) and prop (propagator) are calculated; as necessary; """"""; if self.log_level <= logging.DEBUG_VERBOSE:; logger.log(logging.DEBUG_VERBOSE, ""recomputing evolution ""; ""(DynUpdate)""). dyn = self.parent; n_ts = dyn.num_tslots; # find the op slots that have been marked for update now; # and need recalculation; evo_init2t_recomp_now = self.evo_init2t_calc_now & \; self.evo_init2t_recalc; evo_t2targ_recomp_now = self.evo_t2targ_calc_now & \; self.evo_t2targ_recalc. # to recomupte evo_init2t, will need to start; # at a cell that has been computed; if np.any(evo_init2t_recomp_now):; for k in range(n_ts, 0, -1):; if evo_init2t_recomp_now[k] and self.evo_init2t_recalc[k-1]:; evo_init2t_recomp_now[k-1] = True. # for evo_t2targ, will also need to start; # at a cell that has been computed; if np.any(evo_t2targ_recomp_now):; for k in range(0, n_ts):; if evo_t2targ_recomp_now[k] and self.evo_t2targ_recalc[k+1]:; evo_t2targ_recomp_now[k+1] = True. # determine which dyn gen and prop need recalculating now in order to; # calculate the forwrd and onward evolutions; prop_recomp_now = (evo_init2t_recomp_now[1:]; | evo_t2targ_recomp_now[:-1]; | self.prop_calc_now[:]) & self.prop_recalc[:]; dyn_gen_recomp_now = (prop_recomp_now[:] | self.dyn_gen_calc_now[:]) \; & self.dyn_gen_r",MatchSource.WIKI,docs/4.2/modules/qutip/control/tslotcomp.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/control/tslotcomp.html
https://qutip.org/docs/4.2/modules/qutip/control/tslotcomp.html:23073,Deployability,update,updated,23073," optimisation; None if evolution compute outside of a pulse optimisation; ; num_amps_changed : int; Number of control timeslot amplitudes changed since previous; evolution calculation; ; num_timeslots_changed : int; Number of timeslots in which any amplitudes changed since previous; evolution calculation; ; wall_time_dyn_gen_compute : float; Time spent computing dynamics generators; (in seconds of elapsed time); ; wall_time_prop_compute : float; Time spent computing propagators (including and propagator gradients); (in seconds of elapsed time); ; wall_time_fwd_prop_compute : float; Time spent computing the forward evolution of the system; see :property:`dynamics.fwd_evo` ; (in seconds of elapsed time); ; wall_time_onwd_prop_compute : float; Time spent computing the 'backward' evolution of the system; see :property:`dynamics.onwd_evo` and :property:`dynamics.onto_evo`; (in seconds of elapsed time); """"""; ; min_col_width = 11; summary_property_names = (; ""idx"", ""evo_dump_idx"", ; ""iter_num"", ""fid_func_call_num"", ""grad_func_call_num"",; ""num_amps_changed"", ""num_timeslots_changed"",; ""wall_time_dyn_gen_compute"", ""wall_time_prop_compute"",; ""wall_time_fwd_prop_compute"", ""wall_time_onwd_prop_compute""); ; summary_property_fmt_type = (; 'd', 'd',; 'd', 'd', 'd',; 'd', 'd',; 'g', 'g', ; 'g', 'g'; ); ; summary_property_fmt_prec = (; 0, 0, ; 0, 0, 0,; 0, 0, ; 3, 3,; 3, 3; ); ; def __init__(self):; self.reset(); ; def reset(self):; qtrldump.DumpSummaryItem.reset(self); self.evo_dump_idx = None; self.iter_num = None; self.fid_func_call_num = None; self.grad_func_call_num = None; self.num_amps_changed = 0; self.num_timeslots_changed = 0; self.wall_time_dyn_gen_compute = 0.0; self.wall_time_prop_compute = 0.0; self.wall_time_fwd_prop_compute = 0.0; self.wall_time_onwd_prop_compute = 0.0; . Â© Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, and A.L. Grimsmo.; Last updated on Jan 17, 2018. . Built with Sphinx using a theme provided by Read the Docs. . ",MatchSource.WIKI,docs/4.2/modules/qutip/control/tslotcomp.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/control/tslotcomp.html
https://qutip.org/docs/4.2/modules/qutip/control/tslotcomp.html:3790,Integrability,message,message,3790,"ns accordingly. This would be the appropriate class for Krotov type; methods. Note that the Stats_DynTsUpdate class must be used for stats; in conjunction with this class.; NOTE: AJGP 2011-10-2014: This _DynUpdate class currently has some bug,; no pressing need to fix it presently. If all amplitudes change at each update, then the behavior of the classes is; equivalent. _UpdateAll is easier to understand and potentially slightly faster; in this situation. Note the methods in the _DynUpdate class were inspired by:; DYNAMO - Dynamic Framework for Quantum Optimal Control; See Machnes et.al., arXiv.1011.4874; """""". import os; import warnings; import numpy as np; import timeit; # QuTiP; from qutip import Qobj; # QuTiP control modules; import qutip.control.errors as errors; import qutip.control.dump as qtrldump; # QuTiP logging; import qutip.logging_utils as logging; logger = logging.get_logger(). def _func_deprecation(message, stacklevel=3):; """"""; Issue deprecation warning; Using stacklevel=3 will ensure message refers the function; calling with the deprecated parameter,; """"""; warnings.warn(message, DeprecationWarning, stacklevel=stacklevel). [docs]class TimeslotComputer(object):; """"""; Base class for all Timeslot Computers; Note: this must be instantiated with a Dynamics object, that is the; container for the data that the methods operate on. Attributes; ----------; log_level : integer; level of messaging output from the logger.; Options are attributes of qutip.logging_utils,; in decreasing levels of messaging, are:; DEBUG_INTENSE, DEBUG_VERBOSE, DEBUG, INFO, WARN, ERROR, CRITICAL; Anything WARN or above is effectively 'quiet' execution,; assuming everything runs as expected.; The default NOTSET implies that the level will be taken from; the QuTiP settings file, which by default is WARN; ; evo_comp_summary : EvoCompSummary; A summary of the most recent evolution computation; Used in the stats and dump; Will be set to None if neither stats or dump are set; """"""; def __init_",MatchSource.WIKI,docs/4.2/modules/qutip/control/tslotcomp.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/control/tslotcomp.html
https://qutip.org/docs/4.2/modules/qutip/control/tslotcomp.html:3878,Integrability,message,message,3878,"ns accordingly. This would be the appropriate class for Krotov type; methods. Note that the Stats_DynTsUpdate class must be used for stats; in conjunction with this class.; NOTE: AJGP 2011-10-2014: This _DynUpdate class currently has some bug,; no pressing need to fix it presently. If all amplitudes change at each update, then the behavior of the classes is; equivalent. _UpdateAll is easier to understand and potentially slightly faster; in this situation. Note the methods in the _DynUpdate class were inspired by:; DYNAMO - Dynamic Framework for Quantum Optimal Control; See Machnes et.al., arXiv.1011.4874; """""". import os; import warnings; import numpy as np; import timeit; # QuTiP; from qutip import Qobj; # QuTiP control modules; import qutip.control.errors as errors; import qutip.control.dump as qtrldump; # QuTiP logging; import qutip.logging_utils as logging; logger = logging.get_logger(). def _func_deprecation(message, stacklevel=3):; """"""; Issue deprecation warning; Using stacklevel=3 will ensure message refers the function; calling with the deprecated parameter,; """"""; warnings.warn(message, DeprecationWarning, stacklevel=stacklevel). [docs]class TimeslotComputer(object):; """"""; Base class for all Timeslot Computers; Note: this must be instantiated with a Dynamics object, that is the; container for the data that the methods operate on. Attributes; ----------; log_level : integer; level of messaging output from the logger.; Options are attributes of qutip.logging_utils,; in decreasing levels of messaging, are:; DEBUG_INTENSE, DEBUG_VERBOSE, DEBUG, INFO, WARN, ERROR, CRITICAL; Anything WARN or above is effectively 'quiet' execution,; assuming everything runs as expected.; The default NOTSET implies that the level will be taken from; the QuTiP settings file, which by default is WARN; ; evo_comp_summary : EvoCompSummary; A summary of the most recent evolution computation; Used in the stats and dump; Will be set to None if neither stats or dump are set; """"""; def __init_",MatchSource.WIKI,docs/4.2/modules/qutip/control/tslotcomp.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/control/tslotcomp.html
https://qutip.org/docs/4.2/modules/qutip/control/tslotcomp.html:3966,Integrability,message,message,3966,"sed for stats; in conjunction with this class.; NOTE: AJGP 2011-10-2014: This _DynUpdate class currently has some bug,; no pressing need to fix it presently. If all amplitudes change at each update, then the behavior of the classes is; equivalent. _UpdateAll is easier to understand and potentially slightly faster; in this situation. Note the methods in the _DynUpdate class were inspired by:; DYNAMO - Dynamic Framework for Quantum Optimal Control; See Machnes et.al., arXiv.1011.4874; """""". import os; import warnings; import numpy as np; import timeit; # QuTiP; from qutip import Qobj; # QuTiP control modules; import qutip.control.errors as errors; import qutip.control.dump as qtrldump; # QuTiP logging; import qutip.logging_utils as logging; logger = logging.get_logger(). def _func_deprecation(message, stacklevel=3):; """"""; Issue deprecation warning; Using stacklevel=3 will ensure message refers the function; calling with the deprecated parameter,; """"""; warnings.warn(message, DeprecationWarning, stacklevel=stacklevel). [docs]class TimeslotComputer(object):; """"""; Base class for all Timeslot Computers; Note: this must be instantiated with a Dynamics object, that is the; container for the data that the methods operate on. Attributes; ----------; log_level : integer; level of messaging output from the logger.; Options are attributes of qutip.logging_utils,; in decreasing levels of messaging, are:; DEBUG_INTENSE, DEBUG_VERBOSE, DEBUG, INFO, WARN, ERROR, CRITICAL; Anything WARN or above is effectively 'quiet' execution,; assuming everything runs as expected.; The default NOTSET implies that the level will be taken from; the QuTiP settings file, which by default is WARN; ; evo_comp_summary : EvoCompSummary; A summary of the most recent evolution computation; Used in the stats and dump; Will be set to None if neither stats or dump are set; """"""; def __init__(self, dynamics, params=None):; from qutip.control.dynamics import Dynamics; if not isinstance(dynamics, Dynamics):; raise Ty",MatchSource.WIKI,docs/4.2/modules/qutip/control/tslotcomp.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/control/tslotcomp.html
https://qutip.org/docs/4.2/modules/qutip/control/tslotcomp.html:6619,Modifiability,config,config,6619,"if not params:; params = self.params. if isinstance(params, dict):; self.params = params; for key in params:; setattr(self, key, params[key]). def flag_all_calc_now(self):; pass. def init_comp(self):; pass. @property; def log_level(self):; return logger.level. @log_level.setter; def log_level(self, lvl):; """"""; Set the log_level attribute and set the level of the logger; that is call logger.setLevel(lvl); """"""; logger.setLevel(lvl); ; [docs] def dump_current(self):; """"""Store a copy of the current time evolution""""""; dyn = self.parent; dump = dyn.dump; if not isinstance(dump, qtrldump.DynamicsDump):; raise RuntimeError(""Cannot dump current evolution, ""; ""as dynamics.dump is not set""); ; anything_dumped = False; item_idx = None; if dump.dump_any:; dump_item = dump.add_evo_dump(); item_idx = dump_item.idx; anything_dumped = True; ; if dump.dump_summary:; dump.add_evo_comp_summary(dump_item_idx=item_idx); anything_dumped = True; ; if not anything_dumped:; logger.warning(""Dump set, but nothing dumped, check dump config""); . [docs]class TSlotCompUpdateAll(TimeslotComputer):; """"""; Timeslot Computer - Update All; Updates all dynamics generators, propagators and evolutions when; ctrl amplitudes are updated; """"""; def reset(self):; TimeslotComputer.reset(self); self.id_text = 'ALL'; self.apply_params(). [docs] def compare_amps(self, new_amps):; """"""; Determine if any amplitudes have changed. If so, then mark the; timeslots as needing recalculation; Returns: True if amplitudes are the same, False if they have changed; """"""; changed = False; dyn = self.parent; ; if (dyn.stats or dyn.dump):; if self.evo_comp_summary:; self.evo_comp_summary.reset(); else:; self.evo_comp_summary = EvoCompSummary(); ecs = self.evo_comp_summary; ; if dyn.ctrl_amps is None:; # Flag fidelity and gradients as needing recalculation; changed = True; if ecs:; ecs.num_amps_changed = len(new_amps.flat); ecs.num_timeslots_changed = new_amps.shape[0]; else:; # create boolean array with same shape as ctrl_amps; # Tru",MatchSource.WIKI,docs/4.2/modules/qutip/control/tslotcomp.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/control/tslotcomp.html
https://qutip.org/docs/4.2/modules/qutip/control/tslotcomp.html:20009,Modifiability,config,config,20009,"mer(); # compute the onward propagation; R = range(n_ts-1, -1, -1); for k in R:; if evo_t2targ_recomp_now[k]:; dyn.evo_t2targ[k] = dyn.evo_t2targ[k+1].dot(dyn.prop[k]); self.evo_t2targ_recalc[k] = False; if dyn.stats is not None:; dyn.stats.num_onwd_prop_step_computes += \; evo_t2targ_recomp_now.sum(); dyn.stats.wall_time_onwd_prop_compute += \; timeit.default_timer() - time_start. # Clear calc now flags; self.dyn_gen_calc_now[:] = False; self.prop_calc_now[:] = False; self.evo_init2t_calc_now[:] = False; self.evo_t2targ_calc_now[:] = False. def get_timeslot_for_fidelity_calc(self):; """"""; Returns the timeslot index that will be used calculate current fidelity; value. Attempts to find a timeslot where the least number of propagator; calculations will be required.; Flags the associated evolution operators for calculation now; """"""; dyn = self.parent; n_ts = dyn.num_tslots; kBothEvoCurrent = -1; kFwdEvoCurrent = -1; kUse = -1; # If no specific timeslot set in config, then determine dynamically; if kUse < 0:; for k in range(n_ts):; # find first timeslot where both evo_init2t and; # evo_t2targ are current; if not self.evo_init2t_recalc[k]:; kFwdEvoCurrent = k; if not self.evo_t2targ_recalc[k]:; kBothEvoCurrent = k; break. if kBothEvoCurrent >= 0:; kUse = kBothEvoCurrent; elif kFwdEvoCurrent >= 0:; kUse = kFwdEvoCurrent; else:; raise errors.FunctionalError(""No timeslot found matching ""; ""criteria""). self.evo_init2t_calc_now[kUse] = True; self.evo_t2targ_calc_now[kUse] = True; return kUse. class EvoCompSummary(qtrldump.DumpSummaryItem):; """"""; A summary of the most recent time evolution computation; Used in stats calculations and for data dumping; ; Attributes; ----------; evo_dump_idx : int; Index of the linked :class:`dump.EvoCompDumpItem`; None if no linked item; ; iter_num : int; Iteration number of the pulse optimisation; None if evolution compute outside of a pulse optimisation; ; fid_func_call_num : int; Fidelity function call number of the pulse optimisation; None if ",MatchSource.WIKI,docs/4.2/modules/qutip/control/tslotcomp.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/control/tslotcomp.html
https://qutip.org/docs/4.2/modules/qutip/control/tslotcomp.html:8758,Security,access,access,8758,"ity and gradients as needing recalculation; changed = True; if self.log_level <= logging.DEBUG:; logger.debug(""{} amplitudes changed"".format(; changed_amps.sum())); ; if ecs:; ecs.num_amps_changed = changed_amps.sum(); ecs.num_timeslots_changed = np.any(changed_amps, 1).sum(). else:; if self.log_level <= logging.DEBUG:; logger.debug(""No amplitudes changed""). # *** update stats ***; if dyn.stats:; dyn.stats.num_ctrl_amp_updates += bool(ecs.num_amps_changed); dyn.stats.num_ctrl_amp_changes += ecs.num_amps_changed; dyn.stats.num_timeslot_changes += ecs.num_timeslots_changed; ; if changed:; dyn.ctrl_amps = new_amps; dyn.flag_system_changed(); return False; else:; return True. [docs] def recompute_evolution(self):; """"""; Recalculates the evolution operators.; Dynamics generators (e.g. Hamiltonian) and; prop (propagators) are calculated as necessary; """""". dyn = self.parent; prop_comp = dyn.prop_computer; n_ts = dyn.num_tslots; n_ctrls = dyn.num_ctrls. # Clear the public lists; # These are only set if (external) users access them; dyn._dyn_gen_qobj = None; dyn._prop_qobj = None; dyn._prop_grad_qobj = None; dyn._fwd_evo_qobj = None; dyn._onwd_evo_qobj = None; dyn._onto_evo_qobj = None; ; if (dyn.stats or dyn.dump) and not self.evo_comp_summary:; self.evo_comp_summary = EvoCompSummary(); ecs = self.evo_comp_summary. if dyn.stats is not None:; dyn.stats.num_tslot_recompute += 1; if self.log_level <= logging.DEBUG:; logger.log(logging.DEBUG, ""recomputing evolution {} ""; ""(UpdateAll)"".format(; dyn.stats.num_tslot_recompute)). # calculate the Hamiltonians; if ecs: time_start = timeit.default_timer(); for k in range(n_ts):; dyn._combine_dyn_gen(k); if dyn._decomp_curr is not None:; dyn._decomp_curr[k] = False; ; if ecs:; ecs.wall_time_dyn_gen_compute = \; timeit.default_timer() - time_start. # calculate the propagators and the propagotor gradients; if ecs: time_start = timeit.default_timer(); for k in range(n_ts):; if prop_comp.grad_exact and dyn.cache_prop_grad:; for j in range(n_",MatchSource.WIKI,docs/4.2/modules/qutip/control/tslotcomp.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/control/tslotcomp.html
https://qutip.org/docs/4.2/modules/qutip/control/tslotcomp.html:3689,Testability,log,logging,3689,"he GRAPE algorithm. The alternative (DynUpdate) assumes that only a subset of amplitudes; are updated each iteration and attempts to minimise the number of expensive; calculations accordingly. This would be the appropriate class for Krotov type; methods. Note that the Stats_DynTsUpdate class must be used for stats; in conjunction with this class.; NOTE: AJGP 2011-10-2014: This _DynUpdate class currently has some bug,; no pressing need to fix it presently. If all amplitudes change at each update, then the behavior of the classes is; equivalent. _UpdateAll is easier to understand and potentially slightly faster; in this situation. Note the methods in the _DynUpdate class were inspired by:; DYNAMO - Dynamic Framework for Quantum Optimal Control; See Machnes et.al., arXiv.1011.4874; """""". import os; import warnings; import numpy as np; import timeit; # QuTiP; from qutip import Qobj; # QuTiP control modules; import qutip.control.errors as errors; import qutip.control.dump as qtrldump; # QuTiP logging; import qutip.logging_utils as logging; logger = logging.get_logger(). def _func_deprecation(message, stacklevel=3):; """"""; Issue deprecation warning; Using stacklevel=3 will ensure message refers the function; calling with the deprecated parameter,; """"""; warnings.warn(message, DeprecationWarning, stacklevel=stacklevel). [docs]class TimeslotComputer(object):; """"""; Base class for all Timeslot Computers; Note: this must be instantiated with a Dynamics object, that is the; container for the data that the methods operate on. Attributes; ----------; log_level : integer; level of messaging output from the logger.; Options are attributes of qutip.logging_utils,; in decreasing levels of messaging, are:; DEBUG_INTENSE, DEBUG_VERBOSE, DEBUG, INFO, WARN, ERROR, CRITICAL; Anything WARN or above is effectively 'quiet' execution,; assuming everything runs as expected.; The default NOTSET implies that the level will be taken from; the QuTiP settings file, which by default is WARN; ; evo_comp",MatchSource.WIKI,docs/4.2/modules/qutip/control/tslotcomp.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/control/tslotcomp.html
https://qutip.org/docs/4.2/modules/qutip/control/tslotcomp.html:3728,Testability,log,logging,3728,"e) assumes that only a subset of amplitudes; are updated each iteration and attempts to minimise the number of expensive; calculations accordingly. This would be the appropriate class for Krotov type; methods. Note that the Stats_DynTsUpdate class must be used for stats; in conjunction with this class.; NOTE: AJGP 2011-10-2014: This _DynUpdate class currently has some bug,; no pressing need to fix it presently. If all amplitudes change at each update, then the behavior of the classes is; equivalent. _UpdateAll is easier to understand and potentially slightly faster; in this situation. Note the methods in the _DynUpdate class were inspired by:; DYNAMO - Dynamic Framework for Quantum Optimal Control; See Machnes et.al., arXiv.1011.4874; """""". import os; import warnings; import numpy as np; import timeit; # QuTiP; from qutip import Qobj; # QuTiP control modules; import qutip.control.errors as errors; import qutip.control.dump as qtrldump; # QuTiP logging; import qutip.logging_utils as logging; logger = logging.get_logger(). def _func_deprecation(message, stacklevel=3):; """"""; Issue deprecation warning; Using stacklevel=3 will ensure message refers the function; calling with the deprecated parameter,; """"""; warnings.warn(message, DeprecationWarning, stacklevel=stacklevel). [docs]class TimeslotComputer(object):; """"""; Base class for all Timeslot Computers; Note: this must be instantiated with a Dynamics object, that is the; container for the data that the methods operate on. Attributes; ----------; log_level : integer; level of messaging output from the logger.; Options are attributes of qutip.logging_utils,; in decreasing levels of messaging, are:; DEBUG_INTENSE, DEBUG_VERBOSE, DEBUG, INFO, WARN, ERROR, CRITICAL; Anything WARN or above is effectively 'quiet' execution,; assuming everything runs as expected.; The default NOTSET implies that the level will be taken from; the QuTiP settings file, which by default is WARN; ; evo_comp_summary : EvoCompSummary; A summary of the mo",MatchSource.WIKI,docs/4.2/modules/qutip/control/tslotcomp.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/control/tslotcomp.html
https://qutip.org/docs/4.2/modules/qutip/control/tslotcomp.html:3737,Testability,log,logger,3737,"e) assumes that only a subset of amplitudes; are updated each iteration and attempts to minimise the number of expensive; calculations accordingly. This would be the appropriate class for Krotov type; methods. Note that the Stats_DynTsUpdate class must be used for stats; in conjunction with this class.; NOTE: AJGP 2011-10-2014: This _DynUpdate class currently has some bug,; no pressing need to fix it presently. If all amplitudes change at each update, then the behavior of the classes is; equivalent. _UpdateAll is easier to understand and potentially slightly faster; in this situation. Note the methods in the _DynUpdate class were inspired by:; DYNAMO - Dynamic Framework for Quantum Optimal Control; See Machnes et.al., arXiv.1011.4874; """""". import os; import warnings; import numpy as np; import timeit; # QuTiP; from qutip import Qobj; # QuTiP control modules; import qutip.control.errors as errors; import qutip.control.dump as qtrldump; # QuTiP logging; import qutip.logging_utils as logging; logger = logging.get_logger(). def _func_deprecation(message, stacklevel=3):; """"""; Issue deprecation warning; Using stacklevel=3 will ensure message refers the function; calling with the deprecated parameter,; """"""; warnings.warn(message, DeprecationWarning, stacklevel=stacklevel). [docs]class TimeslotComputer(object):; """"""; Base class for all Timeslot Computers; Note: this must be instantiated with a Dynamics object, that is the; container for the data that the methods operate on. Attributes; ----------; log_level : integer; level of messaging output from the logger.; Options are attributes of qutip.logging_utils,; in decreasing levels of messaging, are:; DEBUG_INTENSE, DEBUG_VERBOSE, DEBUG, INFO, WARN, ERROR, CRITICAL; Anything WARN or above is effectively 'quiet' execution,; assuming everything runs as expected.; The default NOTSET implies that the level will be taken from; the QuTiP settings file, which by default is WARN; ; evo_comp_summary : EvoCompSummary; A summary of the mo",MatchSource.WIKI,docs/4.2/modules/qutip/control/tslotcomp.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/control/tslotcomp.html
https://qutip.org/docs/4.2/modules/qutip/control/tslotcomp.html:3746,Testability,log,logging,3746,"e) assumes that only a subset of amplitudes; are updated each iteration and attempts to minimise the number of expensive; calculations accordingly. This would be the appropriate class for Krotov type; methods. Note that the Stats_DynTsUpdate class must be used for stats; in conjunction with this class.; NOTE: AJGP 2011-10-2014: This _DynUpdate class currently has some bug,; no pressing need to fix it presently. If all amplitudes change at each update, then the behavior of the classes is; equivalent. _UpdateAll is easier to understand and potentially slightly faster; in this situation. Note the methods in the _DynUpdate class were inspired by:; DYNAMO - Dynamic Framework for Quantum Optimal Control; See Machnes et.al., arXiv.1011.4874; """""". import os; import warnings; import numpy as np; import timeit; # QuTiP; from qutip import Qobj; # QuTiP control modules; import qutip.control.errors as errors; import qutip.control.dump as qtrldump; # QuTiP logging; import qutip.logging_utils as logging; logger = logging.get_logger(). def _func_deprecation(message, stacklevel=3):; """"""; Issue deprecation warning; Using stacklevel=3 will ensure message refers the function; calling with the deprecated parameter,; """"""; warnings.warn(message, DeprecationWarning, stacklevel=stacklevel). [docs]class TimeslotComputer(object):; """"""; Base class for all Timeslot Computers; Note: this must be instantiated with a Dynamics object, that is the; container for the data that the methods operate on. Attributes; ----------; log_level : integer; level of messaging output from the logger.; Options are attributes of qutip.logging_utils,; in decreasing levels of messaging, are:; DEBUG_INTENSE, DEBUG_VERBOSE, DEBUG, INFO, WARN, ERROR, CRITICAL; Anything WARN or above is effectively 'quiet' execution,; assuming everything runs as expected.; The default NOTSET implies that the level will be taken from; the QuTiP settings file, which by default is WARN; ; evo_comp_summary : EvoCompSummary; A summary of the mo",MatchSource.WIKI,docs/4.2/modules/qutip/control/tslotcomp.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/control/tslotcomp.html
https://qutip.org/docs/4.2/modules/qutip/control/tslotcomp.html:4303,Testability,log,logger,4303,"stand and potentially slightly faster; in this situation. Note the methods in the _DynUpdate class were inspired by:; DYNAMO - Dynamic Framework for Quantum Optimal Control; See Machnes et.al., arXiv.1011.4874; """""". import os; import warnings; import numpy as np; import timeit; # QuTiP; from qutip import Qobj; # QuTiP control modules; import qutip.control.errors as errors; import qutip.control.dump as qtrldump; # QuTiP logging; import qutip.logging_utils as logging; logger = logging.get_logger(). def _func_deprecation(message, stacklevel=3):; """"""; Issue deprecation warning; Using stacklevel=3 will ensure message refers the function; calling with the deprecated parameter,; """"""; warnings.warn(message, DeprecationWarning, stacklevel=stacklevel). [docs]class TimeslotComputer(object):; """"""; Base class for all Timeslot Computers; Note: this must be instantiated with a Dynamics object, that is the; container for the data that the methods operate on. Attributes; ----------; log_level : integer; level of messaging output from the logger.; Options are attributes of qutip.logging_utils,; in decreasing levels of messaging, are:; DEBUG_INTENSE, DEBUG_VERBOSE, DEBUG, INFO, WARN, ERROR, CRITICAL; Anything WARN or above is effectively 'quiet' execution,; assuming everything runs as expected.; The default NOTSET implies that the level will be taken from; the QuTiP settings file, which by default is WARN; ; evo_comp_summary : EvoCompSummary; A summary of the most recent evolution computation; Used in the stats and dump; Will be set to None if neither stats or dump are set; """"""; def __init__(self, dynamics, params=None):; from qutip.control.dynamics import Dynamics; if not isinstance(dynamics, Dynamics):; raise TypeError(""Must instantiate with {} type"".format(; Dynamics)); self.parent = dynamics; self.params = params; self.reset(). def reset(self):; self.log_level = self.parent.log_level; self.id_text = 'TS_COMP_BASE'; self.evo_comp_summary = None. [docs] def apply_params(self, params",MatchSource.WIKI,docs/4.2/modules/qutip/control/tslotcomp.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/control/tslotcomp.html
https://qutip.org/docs/4.2/modules/qutip/control/tslotcomp.html:5846,Testability,log,logger,5846,"s or dump are set; """"""; def __init__(self, dynamics, params=None):; from qutip.control.dynamics import Dynamics; if not isinstance(dynamics, Dynamics):; raise TypeError(""Must instantiate with {} type"".format(; Dynamics)); self.parent = dynamics; self.params = params; self.reset(). def reset(self):; self.log_level = self.parent.log_level; self.id_text = 'TS_COMP_BASE'; self.evo_comp_summary = None. [docs] def apply_params(self, params=None):; """"""; Set object attributes based on the dictionary (if any) passed in the; instantiation, or passed as a parameter; This is called during the instantiation automatically.; The key value pairs are the attribute name and value; Note: attributes are created if they do not exist already,; and are overwritten if they do.; """"""; if not params:; params = self.params. if isinstance(params, dict):; self.params = params; for key in params:; setattr(self, key, params[key]). def flag_all_calc_now(self):; pass. def init_comp(self):; pass. @property; def log_level(self):; return logger.level. @log_level.setter; def log_level(self, lvl):; """"""; Set the log_level attribute and set the level of the logger; that is call logger.setLevel(lvl); """"""; logger.setLevel(lvl); ; [docs] def dump_current(self):; """"""Store a copy of the current time evolution""""""; dyn = self.parent; dump = dyn.dump; if not isinstance(dump, qtrldump.DynamicsDump):; raise RuntimeError(""Cannot dump current evolution, ""; ""as dynamics.dump is not set""); ; anything_dumped = False; item_idx = None; if dump.dump_any:; dump_item = dump.add_evo_dump(); item_idx = dump_item.idx; anything_dumped = True; ; if dump.dump_summary:; dump.add_evo_comp_summary(dump_item_idx=item_idx); anything_dumped = True; ; if not anything_dumped:; logger.warning(""Dump set, but nothing dumped, check dump config""); . [docs]class TSlotCompUpdateAll(TimeslotComputer):; """"""; Timeslot Computer - Update All; Updates all dynamics generators, propagators and evolutions when; ctrl amplitudes are updated; """"""; def reset(",MatchSource.WIKI,docs/4.2/modules/qutip/control/tslotcomp.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/control/tslotcomp.html
https://qutip.org/docs/4.2/modules/qutip/control/tslotcomp.html:5964,Testability,log,logger,5964," Dynamics; if not isinstance(dynamics, Dynamics):; raise TypeError(""Must instantiate with {} type"".format(; Dynamics)); self.parent = dynamics; self.params = params; self.reset(). def reset(self):; self.log_level = self.parent.log_level; self.id_text = 'TS_COMP_BASE'; self.evo_comp_summary = None. [docs] def apply_params(self, params=None):; """"""; Set object attributes based on the dictionary (if any) passed in the; instantiation, or passed as a parameter; This is called during the instantiation automatically.; The key value pairs are the attribute name and value; Note: attributes are created if they do not exist already,; and are overwritten if they do.; """"""; if not params:; params = self.params. if isinstance(params, dict):; self.params = params; for key in params:; setattr(self, key, params[key]). def flag_all_calc_now(self):; pass. def init_comp(self):; pass. @property; def log_level(self):; return logger.level. @log_level.setter; def log_level(self, lvl):; """"""; Set the log_level attribute and set the level of the logger; that is call logger.setLevel(lvl); """"""; logger.setLevel(lvl); ; [docs] def dump_current(self):; """"""Store a copy of the current time evolution""""""; dyn = self.parent; dump = dyn.dump; if not isinstance(dump, qtrldump.DynamicsDump):; raise RuntimeError(""Cannot dump current evolution, ""; ""as dynamics.dump is not set""); ; anything_dumped = False; item_idx = None; if dump.dump_any:; dump_item = dump.add_evo_dump(); item_idx = dump_item.idx; anything_dumped = True; ; if dump.dump_summary:; dump.add_evo_comp_summary(dump_item_idx=item_idx); anything_dumped = True; ; if not anything_dumped:; logger.warning(""Dump set, but nothing dumped, check dump config""); . [docs]class TSlotCompUpdateAll(TimeslotComputer):; """"""; Timeslot Computer - Update All; Updates all dynamics generators, propagators and evolutions when; ctrl amplitudes are updated; """"""; def reset(self):; TimeslotComputer.reset(self); self.id_text = 'ALL'; self.apply_params(). [docs] def compare_amp",MatchSource.WIKI,docs/4.2/modules/qutip/control/tslotcomp.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/control/tslotcomp.html
https://qutip.org/docs/4.2/modules/qutip/control/tslotcomp.html:5985,Testability,log,logger,5985," Dynamics; if not isinstance(dynamics, Dynamics):; raise TypeError(""Must instantiate with {} type"".format(; Dynamics)); self.parent = dynamics; self.params = params; self.reset(). def reset(self):; self.log_level = self.parent.log_level; self.id_text = 'TS_COMP_BASE'; self.evo_comp_summary = None. [docs] def apply_params(self, params=None):; """"""; Set object attributes based on the dictionary (if any) passed in the; instantiation, or passed as a parameter; This is called during the instantiation automatically.; The key value pairs are the attribute name and value; Note: attributes are created if they do not exist already,; and are overwritten if they do.; """"""; if not params:; params = self.params. if isinstance(params, dict):; self.params = params; for key in params:; setattr(self, key, params[key]). def flag_all_calc_now(self):; pass. def init_comp(self):; pass. @property; def log_level(self):; return logger.level. @log_level.setter; def log_level(self, lvl):; """"""; Set the log_level attribute and set the level of the logger; that is call logger.setLevel(lvl); """"""; logger.setLevel(lvl); ; [docs] def dump_current(self):; """"""Store a copy of the current time evolution""""""; dyn = self.parent; dump = dyn.dump; if not isinstance(dump, qtrldump.DynamicsDump):; raise RuntimeError(""Cannot dump current evolution, ""; ""as dynamics.dump is not set""); ; anything_dumped = False; item_idx = None; if dump.dump_any:; dump_item = dump.add_evo_dump(); item_idx = dump_item.idx; anything_dumped = True; ; if dump.dump_summary:; dump.add_evo_comp_summary(dump_item_idx=item_idx); anything_dumped = True; ; if not anything_dumped:; logger.warning(""Dump set, but nothing dumped, check dump config""); . [docs]class TSlotCompUpdateAll(TimeslotComputer):; """"""; Timeslot Computer - Update All; Updates all dynamics generators, propagators and evolutions when; ctrl amplitudes are updated; """"""; def reset(self):; TimeslotComputer.reset(self); self.id_text = 'ALL'; self.apply_params(). [docs] def compare_amp",MatchSource.WIKI,docs/4.2/modules/qutip/control/tslotcomp.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/control/tslotcomp.html
https://qutip.org/docs/4.2/modules/qutip/control/tslotcomp.html:6012,Testability,log,logger,6012,"nstantiate with {} type"".format(; Dynamics)); self.parent = dynamics; self.params = params; self.reset(). def reset(self):; self.log_level = self.parent.log_level; self.id_text = 'TS_COMP_BASE'; self.evo_comp_summary = None. [docs] def apply_params(self, params=None):; """"""; Set object attributes based on the dictionary (if any) passed in the; instantiation, or passed as a parameter; This is called during the instantiation automatically.; The key value pairs are the attribute name and value; Note: attributes are created if they do not exist already,; and are overwritten if they do.; """"""; if not params:; params = self.params. if isinstance(params, dict):; self.params = params; for key in params:; setattr(self, key, params[key]). def flag_all_calc_now(self):; pass. def init_comp(self):; pass. @property; def log_level(self):; return logger.level. @log_level.setter; def log_level(self, lvl):; """"""; Set the log_level attribute and set the level of the logger; that is call logger.setLevel(lvl); """"""; logger.setLevel(lvl); ; [docs] def dump_current(self):; """"""Store a copy of the current time evolution""""""; dyn = self.parent; dump = dyn.dump; if not isinstance(dump, qtrldump.DynamicsDump):; raise RuntimeError(""Cannot dump current evolution, ""; ""as dynamics.dump is not set""); ; anything_dumped = False; item_idx = None; if dump.dump_any:; dump_item = dump.add_evo_dump(); item_idx = dump_item.idx; anything_dumped = True; ; if dump.dump_summary:; dump.add_evo_comp_summary(dump_item_idx=item_idx); anything_dumped = True; ; if not anything_dumped:; logger.warning(""Dump set, but nothing dumped, check dump config""); . [docs]class TSlotCompUpdateAll(TimeslotComputer):; """"""; Timeslot Computer - Update All; Updates all dynamics generators, propagators and evolutions when; ctrl amplitudes are updated; """"""; def reset(self):; TimeslotComputer.reset(self); self.id_text = 'ALL'; self.apply_params(). [docs] def compare_amps(self, new_amps):; """"""; Determine if any amplitudes have changed. If so, ",MatchSource.WIKI,docs/4.2/modules/qutip/control/tslotcomp.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/control/tslotcomp.html
https://qutip.org/docs/4.2/modules/qutip/control/tslotcomp.html:6562,Testability,log,logger,6562," are created if they do not exist already,; and are overwritten if they do.; """"""; if not params:; params = self.params. if isinstance(params, dict):; self.params = params; for key in params:; setattr(self, key, params[key]). def flag_all_calc_now(self):; pass. def init_comp(self):; pass. @property; def log_level(self):; return logger.level. @log_level.setter; def log_level(self, lvl):; """"""; Set the log_level attribute and set the level of the logger; that is call logger.setLevel(lvl); """"""; logger.setLevel(lvl); ; [docs] def dump_current(self):; """"""Store a copy of the current time evolution""""""; dyn = self.parent; dump = dyn.dump; if not isinstance(dump, qtrldump.DynamicsDump):; raise RuntimeError(""Cannot dump current evolution, ""; ""as dynamics.dump is not set""); ; anything_dumped = False; item_idx = None; if dump.dump_any:; dump_item = dump.add_evo_dump(); item_idx = dump_item.idx; anything_dumped = True; ; if dump.dump_summary:; dump.add_evo_comp_summary(dump_item_idx=item_idx); anything_dumped = True; ; if not anything_dumped:; logger.warning(""Dump set, but nothing dumped, check dump config""); . [docs]class TSlotCompUpdateAll(TimeslotComputer):; """"""; Timeslot Computer - Update All; Updates all dynamics generators, propagators and evolutions when; ctrl amplitudes are updated; """"""; def reset(self):; TimeslotComputer.reset(self); self.id_text = 'ALL'; self.apply_params(). [docs] def compare_amps(self, new_amps):; """"""; Determine if any amplitudes have changed. If so, then mark the; timeslots as needing recalculation; Returns: True if amplitudes are the same, False if they have changed; """"""; changed = False; dyn = self.parent; ; if (dyn.stats or dyn.dump):; if self.evo_comp_summary:; self.evo_comp_summary.reset(); else:; self.evo_comp_summary = EvoCompSummary(); ecs = self.evo_comp_summary; ; if dyn.ctrl_amps is None:; # Flag fidelity and gradients as needing recalculation; changed = True; if ecs:; ecs.num_amps_changed = len(new_amps.flat); ecs.num_timeslots_changed = n",MatchSource.WIKI,docs/4.2/modules/qutip/control/tslotcomp.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/control/tslotcomp.html
https://qutip.org/docs/4.2/modules/qutip/control/tslotcomp.html:7813,Testability,log,logging,7813,"ed; """"""; def reset(self):; TimeslotComputer.reset(self); self.id_text = 'ALL'; self.apply_params(). [docs] def compare_amps(self, new_amps):; """"""; Determine if any amplitudes have changed. If so, then mark the; timeslots as needing recalculation; Returns: True if amplitudes are the same, False if they have changed; """"""; changed = False; dyn = self.parent; ; if (dyn.stats or dyn.dump):; if self.evo_comp_summary:; self.evo_comp_summary.reset(); else:; self.evo_comp_summary = EvoCompSummary(); ecs = self.evo_comp_summary; ; if dyn.ctrl_amps is None:; # Flag fidelity and gradients as needing recalculation; changed = True; if ecs:; ecs.num_amps_changed = len(new_amps.flat); ecs.num_timeslots_changed = new_amps.shape[0]; else:; # create boolean array with same shape as ctrl_amps; # True where value in new_amps differs, otherwise false; changed_amps = dyn.ctrl_amps != new_amps; if np.any(changed_amps):; # Flag fidelity and gradients as needing recalculation; changed = True; if self.log_level <= logging.DEBUG:; logger.debug(""{} amplitudes changed"".format(; changed_amps.sum())); ; if ecs:; ecs.num_amps_changed = changed_amps.sum(); ecs.num_timeslots_changed = np.any(changed_amps, 1).sum(). else:; if self.log_level <= logging.DEBUG:; logger.debug(""No amplitudes changed""). # *** update stats ***; if dyn.stats:; dyn.stats.num_ctrl_amp_updates += bool(ecs.num_amps_changed); dyn.stats.num_ctrl_amp_changes += ecs.num_amps_changed; dyn.stats.num_timeslot_changes += ecs.num_timeslots_changed; ; if changed:; dyn.ctrl_amps = new_amps; dyn.flag_system_changed(); return False; else:; return True. [docs] def recompute_evolution(self):; """"""; Recalculates the evolution operators.; Dynamics generators (e.g. Hamiltonian) and; prop (propagators) are calculated as necessary; """""". dyn = self.parent; prop_comp = dyn.prop_computer; n_ts = dyn.num_tslots; n_ctrls = dyn.num_ctrls. # Clear the public lists; # These are only set if (external) users access them; dyn._dyn_gen_qobj = None; dyn._prop_qobj",MatchSource.WIKI,docs/4.2/modules/qutip/control/tslotcomp.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/control/tslotcomp.html
https://qutip.org/docs/4.2/modules/qutip/control/tslotcomp.html:7829,Testability,log,logger,7829,"(self):; TimeslotComputer.reset(self); self.id_text = 'ALL'; self.apply_params(). [docs] def compare_amps(self, new_amps):; """"""; Determine if any amplitudes have changed. If so, then mark the; timeslots as needing recalculation; Returns: True if amplitudes are the same, False if they have changed; """"""; changed = False; dyn = self.parent; ; if (dyn.stats or dyn.dump):; if self.evo_comp_summary:; self.evo_comp_summary.reset(); else:; self.evo_comp_summary = EvoCompSummary(); ecs = self.evo_comp_summary; ; if dyn.ctrl_amps is None:; # Flag fidelity and gradients as needing recalculation; changed = True; if ecs:; ecs.num_amps_changed = len(new_amps.flat); ecs.num_timeslots_changed = new_amps.shape[0]; else:; # create boolean array with same shape as ctrl_amps; # True where value in new_amps differs, otherwise false; changed_amps = dyn.ctrl_amps != new_amps; if np.any(changed_amps):; # Flag fidelity and gradients as needing recalculation; changed = True; if self.log_level <= logging.DEBUG:; logger.debug(""{} amplitudes changed"".format(; changed_amps.sum())); ; if ecs:; ecs.num_amps_changed = changed_amps.sum(); ecs.num_timeslots_changed = np.any(changed_amps, 1).sum(). else:; if self.log_level <= logging.DEBUG:; logger.debug(""No amplitudes changed""). # *** update stats ***; if dyn.stats:; dyn.stats.num_ctrl_amp_updates += bool(ecs.num_amps_changed); dyn.stats.num_ctrl_amp_changes += ecs.num_amps_changed; dyn.stats.num_timeslot_changes += ecs.num_timeslots_changed; ; if changed:; dyn.ctrl_amps = new_amps; dyn.flag_system_changed(); return False; else:; return True. [docs] def recompute_evolution(self):; """"""; Recalculates the evolution operators.; Dynamics generators (e.g. Hamiltonian) and; prop (propagators) are calculated as necessary; """""". dyn = self.parent; prop_comp = dyn.prop_computer; n_ts = dyn.num_tslots; n_ctrls = dyn.num_ctrls. # Clear the public lists; # These are only set if (external) users access them; dyn._dyn_gen_qobj = None; dyn._prop_qobj = None; dyn._prop",MatchSource.WIKI,docs/4.2/modules/qutip/control/tslotcomp.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/control/tslotcomp.html
https://qutip.org/docs/4.2/modules/qutip/control/tslotcomp.html:8038,Testability,log,logging,8038,"eeding recalculation; Returns: True if amplitudes are the same, False if they have changed; """"""; changed = False; dyn = self.parent; ; if (dyn.stats or dyn.dump):; if self.evo_comp_summary:; self.evo_comp_summary.reset(); else:; self.evo_comp_summary = EvoCompSummary(); ecs = self.evo_comp_summary; ; if dyn.ctrl_amps is None:; # Flag fidelity and gradients as needing recalculation; changed = True; if ecs:; ecs.num_amps_changed = len(new_amps.flat); ecs.num_timeslots_changed = new_amps.shape[0]; else:; # create boolean array with same shape as ctrl_amps; # True where value in new_amps differs, otherwise false; changed_amps = dyn.ctrl_amps != new_amps; if np.any(changed_amps):; # Flag fidelity and gradients as needing recalculation; changed = True; if self.log_level <= logging.DEBUG:; logger.debug(""{} amplitudes changed"".format(; changed_amps.sum())); ; if ecs:; ecs.num_amps_changed = changed_amps.sum(); ecs.num_timeslots_changed = np.any(changed_amps, 1).sum(). else:; if self.log_level <= logging.DEBUG:; logger.debug(""No amplitudes changed""). # *** update stats ***; if dyn.stats:; dyn.stats.num_ctrl_amp_updates += bool(ecs.num_amps_changed); dyn.stats.num_ctrl_amp_changes += ecs.num_amps_changed; dyn.stats.num_timeslot_changes += ecs.num_timeslots_changed; ; if changed:; dyn.ctrl_amps = new_amps; dyn.flag_system_changed(); return False; else:; return True. [docs] def recompute_evolution(self):; """"""; Recalculates the evolution operators.; Dynamics generators (e.g. Hamiltonian) and; prop (propagators) are calculated as necessary; """""". dyn = self.parent; prop_comp = dyn.prop_computer; n_ts = dyn.num_tslots; n_ctrls = dyn.num_ctrls. # Clear the public lists; # These are only set if (external) users access them; dyn._dyn_gen_qobj = None; dyn._prop_qobj = None; dyn._prop_grad_qobj = None; dyn._fwd_evo_qobj = None; dyn._onwd_evo_qobj = None; dyn._onto_evo_qobj = None; ; if (dyn.stats or dyn.dump) and not self.evo_comp_summary:; self.evo_comp_summary = EvoCompSummary(); ecs =",MatchSource.WIKI,docs/4.2/modules/qutip/control/tslotcomp.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/control/tslotcomp.html
https://qutip.org/docs/4.2/modules/qutip/control/tslotcomp.html:8054,Testability,log,logger,8054,"on; Returns: True if amplitudes are the same, False if they have changed; """"""; changed = False; dyn = self.parent; ; if (dyn.stats or dyn.dump):; if self.evo_comp_summary:; self.evo_comp_summary.reset(); else:; self.evo_comp_summary = EvoCompSummary(); ecs = self.evo_comp_summary; ; if dyn.ctrl_amps is None:; # Flag fidelity and gradients as needing recalculation; changed = True; if ecs:; ecs.num_amps_changed = len(new_amps.flat); ecs.num_timeslots_changed = new_amps.shape[0]; else:; # create boolean array with same shape as ctrl_amps; # True where value in new_amps differs, otherwise false; changed_amps = dyn.ctrl_amps != new_amps; if np.any(changed_amps):; # Flag fidelity and gradients as needing recalculation; changed = True; if self.log_level <= logging.DEBUG:; logger.debug(""{} amplitudes changed"".format(; changed_amps.sum())); ; if ecs:; ecs.num_amps_changed = changed_amps.sum(); ecs.num_timeslots_changed = np.any(changed_amps, 1).sum(). else:; if self.log_level <= logging.DEBUG:; logger.debug(""No amplitudes changed""). # *** update stats ***; if dyn.stats:; dyn.stats.num_ctrl_amp_updates += bool(ecs.num_amps_changed); dyn.stats.num_ctrl_amp_changes += ecs.num_amps_changed; dyn.stats.num_timeslot_changes += ecs.num_timeslots_changed; ; if changed:; dyn.ctrl_amps = new_amps; dyn.flag_system_changed(); return False; else:; return True. [docs] def recompute_evolution(self):; """"""; Recalculates the evolution operators.; Dynamics generators (e.g. Hamiltonian) and; prop (propagators) are calculated as necessary; """""". dyn = self.parent; prop_comp = dyn.prop_computer; n_ts = dyn.num_tslots; n_ctrls = dyn.num_ctrls. # Clear the public lists; # These are only set if (external) users access them; dyn._dyn_gen_qobj = None; dyn._prop_qobj = None; dyn._prop_grad_qobj = None; dyn._fwd_evo_qobj = None; dyn._onwd_evo_qobj = None; dyn._onto_evo_qobj = None; ; if (dyn.stats or dyn.dump) and not self.evo_comp_summary:; self.evo_comp_summary = EvoCompSummary(); ecs = self.evo_comp_sum",MatchSource.WIKI,docs/4.2/modules/qutip/control/tslotcomp.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/control/tslotcomp.html
https://qutip.org/docs/4.2/modules/qutip/control/tslotcomp.html:9144,Testability,log,logging,9144,".num_ctrl_amp_updates += bool(ecs.num_amps_changed); dyn.stats.num_ctrl_amp_changes += ecs.num_amps_changed; dyn.stats.num_timeslot_changes += ecs.num_timeslots_changed; ; if changed:; dyn.ctrl_amps = new_amps; dyn.flag_system_changed(); return False; else:; return True. [docs] def recompute_evolution(self):; """"""; Recalculates the evolution operators.; Dynamics generators (e.g. Hamiltonian) and; prop (propagators) are calculated as necessary; """""". dyn = self.parent; prop_comp = dyn.prop_computer; n_ts = dyn.num_tslots; n_ctrls = dyn.num_ctrls. # Clear the public lists; # These are only set if (external) users access them; dyn._dyn_gen_qobj = None; dyn._prop_qobj = None; dyn._prop_grad_qobj = None; dyn._fwd_evo_qobj = None; dyn._onwd_evo_qobj = None; dyn._onto_evo_qobj = None; ; if (dyn.stats or dyn.dump) and not self.evo_comp_summary:; self.evo_comp_summary = EvoCompSummary(); ecs = self.evo_comp_summary. if dyn.stats is not None:; dyn.stats.num_tslot_recompute += 1; if self.log_level <= logging.DEBUG:; logger.log(logging.DEBUG, ""recomputing evolution {} ""; ""(UpdateAll)"".format(; dyn.stats.num_tslot_recompute)). # calculate the Hamiltonians; if ecs: time_start = timeit.default_timer(); for k in range(n_ts):; dyn._combine_dyn_gen(k); if dyn._decomp_curr is not None:; dyn._decomp_curr[k] = False; ; if ecs:; ecs.wall_time_dyn_gen_compute = \; timeit.default_timer() - time_start. # calculate the propagators and the propagotor gradients; if ecs: time_start = timeit.default_timer(); for k in range(n_ts):; if prop_comp.grad_exact and dyn.cache_prop_grad:; for j in range(n_ctrls):; if j == 0:; dyn._prop[k], dyn._prop_grad[k, j] = \; prop_comp._compute_prop_grad(k, j); if self.log_level <= logging.DEBUG_INTENSE:; logger.log(logging.DEBUG_INTENSE,; ""propagator {}:\n{:10.3g}"".format(; k, self._prop[k])); else:; dyn._prop_grad[k, j] = \; prop_comp._compute_prop_grad(k, j, ; compute_prop=False); else:; dyn._prop[k] = prop_comp._compute_propagator(k); ; if ecs:; ecs.wall_time_prop",MatchSource.WIKI,docs/4.2/modules/qutip/control/tslotcomp.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/control/tslotcomp.html
https://qutip.org/docs/4.2/modules/qutip/control/tslotcomp.html:9160,Testability,log,logger,9160,"tes += bool(ecs.num_amps_changed); dyn.stats.num_ctrl_amp_changes += ecs.num_amps_changed; dyn.stats.num_timeslot_changes += ecs.num_timeslots_changed; ; if changed:; dyn.ctrl_amps = new_amps; dyn.flag_system_changed(); return False; else:; return True. [docs] def recompute_evolution(self):; """"""; Recalculates the evolution operators.; Dynamics generators (e.g. Hamiltonian) and; prop (propagators) are calculated as necessary; """""". dyn = self.parent; prop_comp = dyn.prop_computer; n_ts = dyn.num_tslots; n_ctrls = dyn.num_ctrls. # Clear the public lists; # These are only set if (external) users access them; dyn._dyn_gen_qobj = None; dyn._prop_qobj = None; dyn._prop_grad_qobj = None; dyn._fwd_evo_qobj = None; dyn._onwd_evo_qobj = None; dyn._onto_evo_qobj = None; ; if (dyn.stats or dyn.dump) and not self.evo_comp_summary:; self.evo_comp_summary = EvoCompSummary(); ecs = self.evo_comp_summary. if dyn.stats is not None:; dyn.stats.num_tslot_recompute += 1; if self.log_level <= logging.DEBUG:; logger.log(logging.DEBUG, ""recomputing evolution {} ""; ""(UpdateAll)"".format(; dyn.stats.num_tslot_recompute)). # calculate the Hamiltonians; if ecs: time_start = timeit.default_timer(); for k in range(n_ts):; dyn._combine_dyn_gen(k); if dyn._decomp_curr is not None:; dyn._decomp_curr[k] = False; ; if ecs:; ecs.wall_time_dyn_gen_compute = \; timeit.default_timer() - time_start. # calculate the propagators and the propagotor gradients; if ecs: time_start = timeit.default_timer(); for k in range(n_ts):; if prop_comp.grad_exact and dyn.cache_prop_grad:; for j in range(n_ctrls):; if j == 0:; dyn._prop[k], dyn._prop_grad[k, j] = \; prop_comp._compute_prop_grad(k, j); if self.log_level <= logging.DEBUG_INTENSE:; logger.log(logging.DEBUG_INTENSE,; ""propagator {}:\n{:10.3g}"".format(; k, self._prop[k])); else:; dyn._prop_grad[k, j] = \; prop_comp._compute_prop_grad(k, j, ; compute_prop=False); else:; dyn._prop[k] = prop_comp._compute_propagator(k); ; if ecs:; ecs.wall_time_prop_compute = \; time",MatchSource.WIKI,docs/4.2/modules/qutip/control/tslotcomp.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/control/tslotcomp.html
https://qutip.org/docs/4.2/modules/qutip/control/tslotcomp.html:9167,Testability,log,log,9167,"s.num_amps_changed); dyn.stats.num_ctrl_amp_changes += ecs.num_amps_changed; dyn.stats.num_timeslot_changes += ecs.num_timeslots_changed; ; if changed:; dyn.ctrl_amps = new_amps; dyn.flag_system_changed(); return False; else:; return True. [docs] def recompute_evolution(self):; """"""; Recalculates the evolution operators.; Dynamics generators (e.g. Hamiltonian) and; prop (propagators) are calculated as necessary; """""". dyn = self.parent; prop_comp = dyn.prop_computer; n_ts = dyn.num_tslots; n_ctrls = dyn.num_ctrls. # Clear the public lists; # These are only set if (external) users access them; dyn._dyn_gen_qobj = None; dyn._prop_qobj = None; dyn._prop_grad_qobj = None; dyn._fwd_evo_qobj = None; dyn._onwd_evo_qobj = None; dyn._onto_evo_qobj = None; ; if (dyn.stats or dyn.dump) and not self.evo_comp_summary:; self.evo_comp_summary = EvoCompSummary(); ecs = self.evo_comp_summary. if dyn.stats is not None:; dyn.stats.num_tslot_recompute += 1; if self.log_level <= logging.DEBUG:; logger.log(logging.DEBUG, ""recomputing evolution {} ""; ""(UpdateAll)"".format(; dyn.stats.num_tslot_recompute)). # calculate the Hamiltonians; if ecs: time_start = timeit.default_timer(); for k in range(n_ts):; dyn._combine_dyn_gen(k); if dyn._decomp_curr is not None:; dyn._decomp_curr[k] = False; ; if ecs:; ecs.wall_time_dyn_gen_compute = \; timeit.default_timer() - time_start. # calculate the propagators and the propagotor gradients; if ecs: time_start = timeit.default_timer(); for k in range(n_ts):; if prop_comp.grad_exact and dyn.cache_prop_grad:; for j in range(n_ctrls):; if j == 0:; dyn._prop[k], dyn._prop_grad[k, j] = \; prop_comp._compute_prop_grad(k, j); if self.log_level <= logging.DEBUG_INTENSE:; logger.log(logging.DEBUG_INTENSE,; ""propagator {}:\n{:10.3g}"".format(; k, self._prop[k])); else:; dyn._prop_grad[k, j] = \; prop_comp._compute_prop_grad(k, j, ; compute_prop=False); else:; dyn._prop[k] = prop_comp._compute_propagator(k); ; if ecs:; ecs.wall_time_prop_compute = \; timeit.default_ti",MatchSource.WIKI,docs/4.2/modules/qutip/control/tslotcomp.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/control/tslotcomp.html
https://qutip.org/docs/4.2/modules/qutip/control/tslotcomp.html:9171,Testability,log,logging,9171,"s.num_amps_changed); dyn.stats.num_ctrl_amp_changes += ecs.num_amps_changed; dyn.stats.num_timeslot_changes += ecs.num_timeslots_changed; ; if changed:; dyn.ctrl_amps = new_amps; dyn.flag_system_changed(); return False; else:; return True. [docs] def recompute_evolution(self):; """"""; Recalculates the evolution operators.; Dynamics generators (e.g. Hamiltonian) and; prop (propagators) are calculated as necessary; """""". dyn = self.parent; prop_comp = dyn.prop_computer; n_ts = dyn.num_tslots; n_ctrls = dyn.num_ctrls. # Clear the public lists; # These are only set if (external) users access them; dyn._dyn_gen_qobj = None; dyn._prop_qobj = None; dyn._prop_grad_qobj = None; dyn._fwd_evo_qobj = None; dyn._onwd_evo_qobj = None; dyn._onto_evo_qobj = None; ; if (dyn.stats or dyn.dump) and not self.evo_comp_summary:; self.evo_comp_summary = EvoCompSummary(); ecs = self.evo_comp_summary. if dyn.stats is not None:; dyn.stats.num_tslot_recompute += 1; if self.log_level <= logging.DEBUG:; logger.log(logging.DEBUG, ""recomputing evolution {} ""; ""(UpdateAll)"".format(; dyn.stats.num_tslot_recompute)). # calculate the Hamiltonians; if ecs: time_start = timeit.default_timer(); for k in range(n_ts):; dyn._combine_dyn_gen(k); if dyn._decomp_curr is not None:; dyn._decomp_curr[k] = False; ; if ecs:; ecs.wall_time_dyn_gen_compute = \; timeit.default_timer() - time_start. # calculate the propagators and the propagotor gradients; if ecs: time_start = timeit.default_timer(); for k in range(n_ts):; if prop_comp.grad_exact and dyn.cache_prop_grad:; for j in range(n_ctrls):; if j == 0:; dyn._prop[k], dyn._prop_grad[k, j] = \; prop_comp._compute_prop_grad(k, j); if self.log_level <= logging.DEBUG_INTENSE:; logger.log(logging.DEBUG_INTENSE,; ""propagator {}:\n{:10.3g}"".format(; k, self._prop[k])); else:; dyn._prop_grad[k, j] = \; prop_comp._compute_prop_grad(k, j, ; compute_prop=False); else:; dyn._prop[k] = prop_comp._compute_propagator(k); ; if ecs:; ecs.wall_time_prop_compute = \; timeit.default_ti",MatchSource.WIKI,docs/4.2/modules/qutip/control/tslotcomp.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/control/tslotcomp.html
https://qutip.org/docs/4.2/modules/qutip/control/tslotcomp.html:9851,Testability,log,logging,9851,"dyn._fwd_evo_qobj = None; dyn._onwd_evo_qobj = None; dyn._onto_evo_qobj = None; ; if (dyn.stats or dyn.dump) and not self.evo_comp_summary:; self.evo_comp_summary = EvoCompSummary(); ecs = self.evo_comp_summary. if dyn.stats is not None:; dyn.stats.num_tslot_recompute += 1; if self.log_level <= logging.DEBUG:; logger.log(logging.DEBUG, ""recomputing evolution {} ""; ""(UpdateAll)"".format(; dyn.stats.num_tslot_recompute)). # calculate the Hamiltonians; if ecs: time_start = timeit.default_timer(); for k in range(n_ts):; dyn._combine_dyn_gen(k); if dyn._decomp_curr is not None:; dyn._decomp_curr[k] = False; ; if ecs:; ecs.wall_time_dyn_gen_compute = \; timeit.default_timer() - time_start. # calculate the propagators and the propagotor gradients; if ecs: time_start = timeit.default_timer(); for k in range(n_ts):; if prop_comp.grad_exact and dyn.cache_prop_grad:; for j in range(n_ctrls):; if j == 0:; dyn._prop[k], dyn._prop_grad[k, j] = \; prop_comp._compute_prop_grad(k, j); if self.log_level <= logging.DEBUG_INTENSE:; logger.log(logging.DEBUG_INTENSE,; ""propagator {}:\n{:10.3g}"".format(; k, self._prop[k])); else:; dyn._prop_grad[k, j] = \; prop_comp._compute_prop_grad(k, j, ; compute_prop=False); else:; dyn._prop[k] = prop_comp._compute_propagator(k); ; if ecs:; ecs.wall_time_prop_compute = \; timeit.default_timer() - time_start. if ecs: time_start = timeit.default_timer(); # compute the forward propagation; R = range(n_ts); for k in R:; if dyn.oper_dtype == Qobj:; dyn._fwd_evo[k+1] = dyn._prop[k]*dyn._fwd_evo[k]; else:; dyn._fwd_evo[k+1] = dyn._prop[k].dot(dyn._fwd_evo[k]). if ecs:; ecs.wall_time_fwd_prop_compute = \; timeit.default_timer() - time_start; time_start = timeit.default_timer(); # compute the onward propagation; if dyn.fid_computer.uses_onwd_evo:; dyn._onwd_evo[n_ts-1] = dyn._prop[n_ts-1]; R = range(n_ts-2, -1, -1); for k in R:; if dyn.oper_dtype == Qobj:; dyn._onwd_evo[k] = dyn._onwd_evo[k+1]*dyn._prop[k]; else:; dyn._onwd_evo[k] = dyn._onwd_evo[k+1].dot(dyn._",MatchSource.WIKI,docs/4.2/modules/qutip/control/tslotcomp.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/control/tslotcomp.html
https://qutip.org/docs/4.2/modules/qutip/control/tslotcomp.html:9875,Testability,log,logger,9875,"ne; dyn._onwd_evo_qobj = None; dyn._onto_evo_qobj = None; ; if (dyn.stats or dyn.dump) and not self.evo_comp_summary:; self.evo_comp_summary = EvoCompSummary(); ecs = self.evo_comp_summary. if dyn.stats is not None:; dyn.stats.num_tslot_recompute += 1; if self.log_level <= logging.DEBUG:; logger.log(logging.DEBUG, ""recomputing evolution {} ""; ""(UpdateAll)"".format(; dyn.stats.num_tslot_recompute)). # calculate the Hamiltonians; if ecs: time_start = timeit.default_timer(); for k in range(n_ts):; dyn._combine_dyn_gen(k); if dyn._decomp_curr is not None:; dyn._decomp_curr[k] = False; ; if ecs:; ecs.wall_time_dyn_gen_compute = \; timeit.default_timer() - time_start. # calculate the propagators and the propagotor gradients; if ecs: time_start = timeit.default_timer(); for k in range(n_ts):; if prop_comp.grad_exact and dyn.cache_prop_grad:; for j in range(n_ctrls):; if j == 0:; dyn._prop[k], dyn._prop_grad[k, j] = \; prop_comp._compute_prop_grad(k, j); if self.log_level <= logging.DEBUG_INTENSE:; logger.log(logging.DEBUG_INTENSE,; ""propagator {}:\n{:10.3g}"".format(; k, self._prop[k])); else:; dyn._prop_grad[k, j] = \; prop_comp._compute_prop_grad(k, j, ; compute_prop=False); else:; dyn._prop[k] = prop_comp._compute_propagator(k); ; if ecs:; ecs.wall_time_prop_compute = \; timeit.default_timer() - time_start. if ecs: time_start = timeit.default_timer(); # compute the forward propagation; R = range(n_ts); for k in R:; if dyn.oper_dtype == Qobj:; dyn._fwd_evo[k+1] = dyn._prop[k]*dyn._fwd_evo[k]; else:; dyn._fwd_evo[k+1] = dyn._prop[k].dot(dyn._fwd_evo[k]). if ecs:; ecs.wall_time_fwd_prop_compute = \; timeit.default_timer() - time_start; time_start = timeit.default_timer(); # compute the onward propagation; if dyn.fid_computer.uses_onwd_evo:; dyn._onwd_evo[n_ts-1] = dyn._prop[n_ts-1]; R = range(n_ts-2, -1, -1); for k in R:; if dyn.oper_dtype == Qobj:; dyn._onwd_evo[k] = dyn._onwd_evo[k+1]*dyn._prop[k]; else:; dyn._onwd_evo[k] = dyn._onwd_evo[k+1].dot(dyn._prop[k]). if dyn.fid_c",MatchSource.WIKI,docs/4.2/modules/qutip/control/tslotcomp.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/control/tslotcomp.html
https://qutip.org/docs/4.2/modules/qutip/control/tslotcomp.html:9882,Testability,log,log,9882,"qobj = None; dyn._onto_evo_qobj = None; ; if (dyn.stats or dyn.dump) and not self.evo_comp_summary:; self.evo_comp_summary = EvoCompSummary(); ecs = self.evo_comp_summary. if dyn.stats is not None:; dyn.stats.num_tslot_recompute += 1; if self.log_level <= logging.DEBUG:; logger.log(logging.DEBUG, ""recomputing evolution {} ""; ""(UpdateAll)"".format(; dyn.stats.num_tslot_recompute)). # calculate the Hamiltonians; if ecs: time_start = timeit.default_timer(); for k in range(n_ts):; dyn._combine_dyn_gen(k); if dyn._decomp_curr is not None:; dyn._decomp_curr[k] = False; ; if ecs:; ecs.wall_time_dyn_gen_compute = \; timeit.default_timer() - time_start. # calculate the propagators and the propagotor gradients; if ecs: time_start = timeit.default_timer(); for k in range(n_ts):; if prop_comp.grad_exact and dyn.cache_prop_grad:; for j in range(n_ctrls):; if j == 0:; dyn._prop[k], dyn._prop_grad[k, j] = \; prop_comp._compute_prop_grad(k, j); if self.log_level <= logging.DEBUG_INTENSE:; logger.log(logging.DEBUG_INTENSE,; ""propagator {}:\n{:10.3g}"".format(; k, self._prop[k])); else:; dyn._prop_grad[k, j] = \; prop_comp._compute_prop_grad(k, j, ; compute_prop=False); else:; dyn._prop[k] = prop_comp._compute_propagator(k); ; if ecs:; ecs.wall_time_prop_compute = \; timeit.default_timer() - time_start. if ecs: time_start = timeit.default_timer(); # compute the forward propagation; R = range(n_ts); for k in R:; if dyn.oper_dtype == Qobj:; dyn._fwd_evo[k+1] = dyn._prop[k]*dyn._fwd_evo[k]; else:; dyn._fwd_evo[k+1] = dyn._prop[k].dot(dyn._fwd_evo[k]). if ecs:; ecs.wall_time_fwd_prop_compute = \; timeit.default_timer() - time_start; time_start = timeit.default_timer(); # compute the onward propagation; if dyn.fid_computer.uses_onwd_evo:; dyn._onwd_evo[n_ts-1] = dyn._prop[n_ts-1]; R = range(n_ts-2, -1, -1); for k in R:; if dyn.oper_dtype == Qobj:; dyn._onwd_evo[k] = dyn._onwd_evo[k+1]*dyn._prop[k]; else:; dyn._onwd_evo[k] = dyn._onwd_evo[k+1].dot(dyn._prop[k]). if dyn.fid_computer.uses_onto",MatchSource.WIKI,docs/4.2/modules/qutip/control/tslotcomp.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/control/tslotcomp.html
https://qutip.org/docs/4.2/modules/qutip/control/tslotcomp.html:9886,Testability,log,logging,9886,"qobj = None; dyn._onto_evo_qobj = None; ; if (dyn.stats or dyn.dump) and not self.evo_comp_summary:; self.evo_comp_summary = EvoCompSummary(); ecs = self.evo_comp_summary. if dyn.stats is not None:; dyn.stats.num_tslot_recompute += 1; if self.log_level <= logging.DEBUG:; logger.log(logging.DEBUG, ""recomputing evolution {} ""; ""(UpdateAll)"".format(; dyn.stats.num_tslot_recompute)). # calculate the Hamiltonians; if ecs: time_start = timeit.default_timer(); for k in range(n_ts):; dyn._combine_dyn_gen(k); if dyn._decomp_curr is not None:; dyn._decomp_curr[k] = False; ; if ecs:; ecs.wall_time_dyn_gen_compute = \; timeit.default_timer() - time_start. # calculate the propagators and the propagotor gradients; if ecs: time_start = timeit.default_timer(); for k in range(n_ts):; if prop_comp.grad_exact and dyn.cache_prop_grad:; for j in range(n_ctrls):; if j == 0:; dyn._prop[k], dyn._prop_grad[k, j] = \; prop_comp._compute_prop_grad(k, j); if self.log_level <= logging.DEBUG_INTENSE:; logger.log(logging.DEBUG_INTENSE,; ""propagator {}:\n{:10.3g}"".format(; k, self._prop[k])); else:; dyn._prop_grad[k, j] = \; prop_comp._compute_prop_grad(k, j, ; compute_prop=False); else:; dyn._prop[k] = prop_comp._compute_propagator(k); ; if ecs:; ecs.wall_time_prop_compute = \; timeit.default_timer() - time_start. if ecs: time_start = timeit.default_timer(); # compute the forward propagation; R = range(n_ts); for k in R:; if dyn.oper_dtype == Qobj:; dyn._fwd_evo[k+1] = dyn._prop[k]*dyn._fwd_evo[k]; else:; dyn._fwd_evo[k+1] = dyn._prop[k].dot(dyn._fwd_evo[k]). if ecs:; ecs.wall_time_fwd_prop_compute = \; timeit.default_timer() - time_start; time_start = timeit.default_timer(); # compute the onward propagation; if dyn.fid_computer.uses_onwd_evo:; dyn._onwd_evo[n_ts-1] = dyn._prop[n_ts-1]; R = range(n_ts-2, -1, -1); for k in R:; if dyn.oper_dtype == Qobj:; dyn._onwd_evo[k] = dyn._onwd_evo[k+1]*dyn._prop[k]; else:; dyn._onwd_evo[k] = dyn._onwd_evo[k+1].dot(dyn._prop[k]). if dyn.fid_computer.uses_onto",MatchSource.WIKI,docs/4.2/modules/qutip/control/tslotcomp.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/control/tslotcomp.html
https://qutip.org/docs/4.2/modules/qutip/control/tslotcomp.html:14680,Testability,log,logging,14680,".evo_t2targ_recalc[-1] = False. # The _calc_now map is used to during the calcs to specify; # which values need updating immediately; self.dyn_gen_calc_now = np.zeros(n_ts, dtype=bool); self.prop_calc_now = np.zeros(n_ts, dtype=bool); self.evo_init2t_calc_now = np.zeros(n_ts + 1, dtype=bool); self.evo_t2targ_calc_now = np.zeros(n_ts + 1, dtype=bool). def compare_amps(self, new_amps):; """"""; Determine which timeslots will have changed Hamiltonians; i.e. any where control amplitudes have changed for that slot; and mark (using masks) them and corresponding exponentiations and; time evo operators for update; Returns: True if amplitudes are the same, False if they have changed; """"""; dyn = self.parent; n_ts = dyn.num_tslots; # create boolean array with same shape as ctrl_amps; # True where value in New_amps differs, otherwise false; if self.parent.ctrl_amps is None:; changed_amps = np.ones(new_amps.shape, dtype=bool); else:; changed_amps = self.parent.ctrl_amps != new_amps. if self.log_level <= logging.DEBUG_VERBOSE:; logger.log(logging.DEBUG_VERBOSE, ""changed_amps:\n{}"".format(; changed_amps)); # create Boolean vector with same length as number of timeslots; # True where any of the amplitudes have changed, otherwise false; changed_ts_mask = np.any(changed_amps, 1); # if any of the amplidudes have changed then mark for recalc; if np.any(changed_ts_mask):; self.dyn_gen_recalc[changed_ts_mask] = True; self.prop_recalc[changed_ts_mask] = True; dyn.ctrl_amps = new_amps; if self.log_level <= logging.DEBUG:; logger.debug(""Control amplitudes updated""); # find first and last changed dynamics generators; first_changed = None; for i in range(n_ts):; if changed_ts_mask[i]:; last_changed = i; if first_changed is None:; first_changed = i. # set all fwd evo ops after first changed Ham to be recalculated; self.evo_init2t_recalc[first_changed + 1:] = True; # set all bkwd evo ops up to (incl) last changed Ham to be; # recalculated; self.evo_t2targ_recalc[:last_changed + 1] = True. # Flag fi",MatchSource.WIKI,docs/4.2/modules/qutip/control/tslotcomp.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/control/tslotcomp.html
https://qutip.org/docs/4.2/modules/qutip/control/tslotcomp.html:14704,Testability,log,logger,14704," = False. # The _calc_now map is used to during the calcs to specify; # which values need updating immediately; self.dyn_gen_calc_now = np.zeros(n_ts, dtype=bool); self.prop_calc_now = np.zeros(n_ts, dtype=bool); self.evo_init2t_calc_now = np.zeros(n_ts + 1, dtype=bool); self.evo_t2targ_calc_now = np.zeros(n_ts + 1, dtype=bool). def compare_amps(self, new_amps):; """"""; Determine which timeslots will have changed Hamiltonians; i.e. any where control amplitudes have changed for that slot; and mark (using masks) them and corresponding exponentiations and; time evo operators for update; Returns: True if amplitudes are the same, False if they have changed; """"""; dyn = self.parent; n_ts = dyn.num_tslots; # create boolean array with same shape as ctrl_amps; # True where value in New_amps differs, otherwise false; if self.parent.ctrl_amps is None:; changed_amps = np.ones(new_amps.shape, dtype=bool); else:; changed_amps = self.parent.ctrl_amps != new_amps. if self.log_level <= logging.DEBUG_VERBOSE:; logger.log(logging.DEBUG_VERBOSE, ""changed_amps:\n{}"".format(; changed_amps)); # create Boolean vector with same length as number of timeslots; # True where any of the amplitudes have changed, otherwise false; changed_ts_mask = np.any(changed_amps, 1); # if any of the amplidudes have changed then mark for recalc; if np.any(changed_ts_mask):; self.dyn_gen_recalc[changed_ts_mask] = True; self.prop_recalc[changed_ts_mask] = True; dyn.ctrl_amps = new_amps; if self.log_level <= logging.DEBUG:; logger.debug(""Control amplitudes updated""); # find first and last changed dynamics generators; first_changed = None; for i in range(n_ts):; if changed_ts_mask[i]:; last_changed = i; if first_changed is None:; first_changed = i. # set all fwd evo ops after first changed Ham to be recalculated; self.evo_init2t_recalc[first_changed + 1:] = True; # set all bkwd evo ops up to (incl) last changed Ham to be; # recalculated; self.evo_t2targ_recalc[:last_changed + 1] = True. # Flag fidelity and gradients a",MatchSource.WIKI,docs/4.2/modules/qutip/control/tslotcomp.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/control/tslotcomp.html
https://qutip.org/docs/4.2/modules/qutip/control/tslotcomp.html:14711,Testability,log,log,14711,"alc_now map is used to during the calcs to specify; # which values need updating immediately; self.dyn_gen_calc_now = np.zeros(n_ts, dtype=bool); self.prop_calc_now = np.zeros(n_ts, dtype=bool); self.evo_init2t_calc_now = np.zeros(n_ts + 1, dtype=bool); self.evo_t2targ_calc_now = np.zeros(n_ts + 1, dtype=bool). def compare_amps(self, new_amps):; """"""; Determine which timeslots will have changed Hamiltonians; i.e. any where control amplitudes have changed for that slot; and mark (using masks) them and corresponding exponentiations and; time evo operators for update; Returns: True if amplitudes are the same, False if they have changed; """"""; dyn = self.parent; n_ts = dyn.num_tslots; # create boolean array with same shape as ctrl_amps; # True where value in New_amps differs, otherwise false; if self.parent.ctrl_amps is None:; changed_amps = np.ones(new_amps.shape, dtype=bool); else:; changed_amps = self.parent.ctrl_amps != new_amps. if self.log_level <= logging.DEBUG_VERBOSE:; logger.log(logging.DEBUG_VERBOSE, ""changed_amps:\n{}"".format(; changed_amps)); # create Boolean vector with same length as number of timeslots; # True where any of the amplitudes have changed, otherwise false; changed_ts_mask = np.any(changed_amps, 1); # if any of the amplidudes have changed then mark for recalc; if np.any(changed_ts_mask):; self.dyn_gen_recalc[changed_ts_mask] = True; self.prop_recalc[changed_ts_mask] = True; dyn.ctrl_amps = new_amps; if self.log_level <= logging.DEBUG:; logger.debug(""Control amplitudes updated""); # find first and last changed dynamics generators; first_changed = None; for i in range(n_ts):; if changed_ts_mask[i]:; last_changed = i; if first_changed is None:; first_changed = i. # set all fwd evo ops after first changed Ham to be recalculated; self.evo_init2t_recalc[first_changed + 1:] = True; # set all bkwd evo ops up to (incl) last changed Ham to be; # recalculated; self.evo_t2targ_recalc[:last_changed + 1] = True. # Flag fidelity and gradients as needing recalcu",MatchSource.WIKI,docs/4.2/modules/qutip/control/tslotcomp.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/control/tslotcomp.html
https://qutip.org/docs/4.2/modules/qutip/control/tslotcomp.html:14715,Testability,log,logging,14715,"alc_now map is used to during the calcs to specify; # which values need updating immediately; self.dyn_gen_calc_now = np.zeros(n_ts, dtype=bool); self.prop_calc_now = np.zeros(n_ts, dtype=bool); self.evo_init2t_calc_now = np.zeros(n_ts + 1, dtype=bool); self.evo_t2targ_calc_now = np.zeros(n_ts + 1, dtype=bool). def compare_amps(self, new_amps):; """"""; Determine which timeslots will have changed Hamiltonians; i.e. any where control amplitudes have changed for that slot; and mark (using masks) them and corresponding exponentiations and; time evo operators for update; Returns: True if amplitudes are the same, False if they have changed; """"""; dyn = self.parent; n_ts = dyn.num_tslots; # create boolean array with same shape as ctrl_amps; # True where value in New_amps differs, otherwise false; if self.parent.ctrl_amps is None:; changed_amps = np.ones(new_amps.shape, dtype=bool); else:; changed_amps = self.parent.ctrl_amps != new_amps. if self.log_level <= logging.DEBUG_VERBOSE:; logger.log(logging.DEBUG_VERBOSE, ""changed_amps:\n{}"".format(; changed_amps)); # create Boolean vector with same length as number of timeslots; # True where any of the amplitudes have changed, otherwise false; changed_ts_mask = np.any(changed_amps, 1); # if any of the amplidudes have changed then mark for recalc; if np.any(changed_ts_mask):; self.dyn_gen_recalc[changed_ts_mask] = True; self.prop_recalc[changed_ts_mask] = True; dyn.ctrl_amps = new_amps; if self.log_level <= logging.DEBUG:; logger.debug(""Control amplitudes updated""); # find first and last changed dynamics generators; first_changed = None; for i in range(n_ts):; if changed_ts_mask[i]:; last_changed = i; if first_changed is None:; first_changed = i. # set all fwd evo ops after first changed Ham to be recalculated; self.evo_init2t_recalc[first_changed + 1:] = True; # set all bkwd evo ops up to (incl) last changed Ham to be; # recalculated; self.evo_t2targ_recalc[:last_changed + 1] = True. # Flag fidelity and gradients as needing recalcu",MatchSource.WIKI,docs/4.2/modules/qutip/control/tslotcomp.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/control/tslotcomp.html
https://qutip.org/docs/4.2/modules/qutip/control/tslotcomp.html:15182,Testability,log,logging,15182,"that slot; and mark (using masks) them and corresponding exponentiations and; time evo operators for update; Returns: True if amplitudes are the same, False if they have changed; """"""; dyn = self.parent; n_ts = dyn.num_tslots; # create boolean array with same shape as ctrl_amps; # True where value in New_amps differs, otherwise false; if self.parent.ctrl_amps is None:; changed_amps = np.ones(new_amps.shape, dtype=bool); else:; changed_amps = self.parent.ctrl_amps != new_amps. if self.log_level <= logging.DEBUG_VERBOSE:; logger.log(logging.DEBUG_VERBOSE, ""changed_amps:\n{}"".format(; changed_amps)); # create Boolean vector with same length as number of timeslots; # True where any of the amplitudes have changed, otherwise false; changed_ts_mask = np.any(changed_amps, 1); # if any of the amplidudes have changed then mark for recalc; if np.any(changed_ts_mask):; self.dyn_gen_recalc[changed_ts_mask] = True; self.prop_recalc[changed_ts_mask] = True; dyn.ctrl_amps = new_amps; if self.log_level <= logging.DEBUG:; logger.debug(""Control amplitudes updated""); # find first and last changed dynamics generators; first_changed = None; for i in range(n_ts):; if changed_ts_mask[i]:; last_changed = i; if first_changed is None:; first_changed = i. # set all fwd evo ops after first changed Ham to be recalculated; self.evo_init2t_recalc[first_changed + 1:] = True; # set all bkwd evo ops up to (incl) last changed Ham to be; # recalculated; self.evo_t2targ_recalc[:last_changed + 1] = True. # Flag fidelity and gradients as needing recalculation; dyn.flag_system_changed(). # *** update stats ***; if dyn.stats is not None:; dyn.stats.num_ctrl_amp_updates += 1; dyn.stats.num_ctrl_amp_changes += changed_amps.sum(); dyn.stats.num_timeslot_changes += changed_ts_mask.sum(). return False; else:; return True. def flag_all_calc_now(self):; """"""; Flags all Hamiltonians, propagators and propagations to be; calculated now; """"""; # set flags for calculations; self.dyn_gen_calc_now[:] = True; self.prop_calc_n",MatchSource.WIKI,docs/4.2/modules/qutip/control/tslotcomp.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/control/tslotcomp.html
https://qutip.org/docs/4.2/modules/qutip/control/tslotcomp.html:15198,Testability,log,logger,15198,"k (using masks) them and corresponding exponentiations and; time evo operators for update; Returns: True if amplitudes are the same, False if they have changed; """"""; dyn = self.parent; n_ts = dyn.num_tslots; # create boolean array with same shape as ctrl_amps; # True where value in New_amps differs, otherwise false; if self.parent.ctrl_amps is None:; changed_amps = np.ones(new_amps.shape, dtype=bool); else:; changed_amps = self.parent.ctrl_amps != new_amps. if self.log_level <= logging.DEBUG_VERBOSE:; logger.log(logging.DEBUG_VERBOSE, ""changed_amps:\n{}"".format(; changed_amps)); # create Boolean vector with same length as number of timeslots; # True where any of the amplitudes have changed, otherwise false; changed_ts_mask = np.any(changed_amps, 1); # if any of the amplidudes have changed then mark for recalc; if np.any(changed_ts_mask):; self.dyn_gen_recalc[changed_ts_mask] = True; self.prop_recalc[changed_ts_mask] = True; dyn.ctrl_amps = new_amps; if self.log_level <= logging.DEBUG:; logger.debug(""Control amplitudes updated""); # find first and last changed dynamics generators; first_changed = None; for i in range(n_ts):; if changed_ts_mask[i]:; last_changed = i; if first_changed is None:; first_changed = i. # set all fwd evo ops after first changed Ham to be recalculated; self.evo_init2t_recalc[first_changed + 1:] = True; # set all bkwd evo ops up to (incl) last changed Ham to be; # recalculated; self.evo_t2targ_recalc[:last_changed + 1] = True. # Flag fidelity and gradients as needing recalculation; dyn.flag_system_changed(). # *** update stats ***; if dyn.stats is not None:; dyn.stats.num_ctrl_amp_updates += 1; dyn.stats.num_ctrl_amp_changes += changed_amps.sum(); dyn.stats.num_timeslot_changes += changed_ts_mask.sum(). return False; else:; return True. def flag_all_calc_now(self):; """"""; Flags all Hamiltonians, propagators and propagations to be; calculated now; """"""; # set flags for calculations; self.dyn_gen_calc_now[:] = True; self.prop_calc_now[:] = True; self",MatchSource.WIKI,docs/4.2/modules/qutip/control/tslotcomp.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/control/tslotcomp.html
https://qutip.org/docs/4.2/modules/qutip/control/tslotcomp.html:16499,Testability,log,logging,16499,".evo_init2t_recalc[first_changed + 1:] = True; # set all bkwd evo ops up to (incl) last changed Ham to be; # recalculated; self.evo_t2targ_recalc[:last_changed + 1] = True. # Flag fidelity and gradients as needing recalculation; dyn.flag_system_changed(). # *** update stats ***; if dyn.stats is not None:; dyn.stats.num_ctrl_amp_updates += 1; dyn.stats.num_ctrl_amp_changes += changed_amps.sum(); dyn.stats.num_timeslot_changes += changed_ts_mask.sum(). return False; else:; return True. def flag_all_calc_now(self):; """"""; Flags all Hamiltonians, propagators and propagations to be; calculated now; """"""; # set flags for calculations; self.dyn_gen_calc_now[:] = True; self.prop_calc_now[:] = True; self.evo_init2t_calc_now[:-1] = True; self.evo_t2targ_calc_now[1:] = True. def recompute_evolution(self):; """"""; Recalculates the evo_init2t (forward) and evo_t2targ (onward) time; evolution operators; DynGen (Hamiltonians etc) and prop (propagator) are calculated; as necessary; """"""; if self.log_level <= logging.DEBUG_VERBOSE:; logger.log(logging.DEBUG_VERBOSE, ""recomputing evolution ""; ""(DynUpdate)""). dyn = self.parent; n_ts = dyn.num_tslots; # find the op slots that have been marked for update now; # and need recalculation; evo_init2t_recomp_now = self.evo_init2t_calc_now & \; self.evo_init2t_recalc; evo_t2targ_recomp_now = self.evo_t2targ_calc_now & \; self.evo_t2targ_recalc. # to recomupte evo_init2t, will need to start; # at a cell that has been computed; if np.any(evo_init2t_recomp_now):; for k in range(n_ts, 0, -1):; if evo_init2t_recomp_now[k] and self.evo_init2t_recalc[k-1]:; evo_init2t_recomp_now[k-1] = True. # for evo_t2targ, will also need to start; # at a cell that has been computed; if np.any(evo_t2targ_recomp_now):; for k in range(0, n_ts):; if evo_t2targ_recomp_now[k] and self.evo_t2targ_recalc[k+1]:; evo_t2targ_recomp_now[k+1] = True. # determine which dyn gen and prop need recalculating now in order to; # calculate the forwrd and onward evolutions; prop_recomp_now =",MatchSource.WIKI,docs/4.2/modules/qutip/control/tslotcomp.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/control/tslotcomp.html
https://qutip.org/docs/4.2/modules/qutip/control/tslotcomp.html:16523,Testability,log,logger,16523,"st_changed + 1:] = True; # set all bkwd evo ops up to (incl) last changed Ham to be; # recalculated; self.evo_t2targ_recalc[:last_changed + 1] = True. # Flag fidelity and gradients as needing recalculation; dyn.flag_system_changed(). # *** update stats ***; if dyn.stats is not None:; dyn.stats.num_ctrl_amp_updates += 1; dyn.stats.num_ctrl_amp_changes += changed_amps.sum(); dyn.stats.num_timeslot_changes += changed_ts_mask.sum(). return False; else:; return True. def flag_all_calc_now(self):; """"""; Flags all Hamiltonians, propagators and propagations to be; calculated now; """"""; # set flags for calculations; self.dyn_gen_calc_now[:] = True; self.prop_calc_now[:] = True; self.evo_init2t_calc_now[:-1] = True; self.evo_t2targ_calc_now[1:] = True. def recompute_evolution(self):; """"""; Recalculates the evo_init2t (forward) and evo_t2targ (onward) time; evolution operators; DynGen (Hamiltonians etc) and prop (propagator) are calculated; as necessary; """"""; if self.log_level <= logging.DEBUG_VERBOSE:; logger.log(logging.DEBUG_VERBOSE, ""recomputing evolution ""; ""(DynUpdate)""). dyn = self.parent; n_ts = dyn.num_tslots; # find the op slots that have been marked for update now; # and need recalculation; evo_init2t_recomp_now = self.evo_init2t_calc_now & \; self.evo_init2t_recalc; evo_t2targ_recomp_now = self.evo_t2targ_calc_now & \; self.evo_t2targ_recalc. # to recomupte evo_init2t, will need to start; # at a cell that has been computed; if np.any(evo_init2t_recomp_now):; for k in range(n_ts, 0, -1):; if evo_init2t_recomp_now[k] and self.evo_init2t_recalc[k-1]:; evo_init2t_recomp_now[k-1] = True. # for evo_t2targ, will also need to start; # at a cell that has been computed; if np.any(evo_t2targ_recomp_now):; for k in range(0, n_ts):; if evo_t2targ_recomp_now[k] and self.evo_t2targ_recalc[k+1]:; evo_t2targ_recomp_now[k+1] = True. # determine which dyn gen and prop need recalculating now in order to; # calculate the forwrd and onward evolutions; prop_recomp_now = (evo_init2t_recomp_no",MatchSource.WIKI,docs/4.2/modules/qutip/control/tslotcomp.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/control/tslotcomp.html
https://qutip.org/docs/4.2/modules/qutip/control/tslotcomp.html:16530,Testability,log,log,16530," True; # set all bkwd evo ops up to (incl) last changed Ham to be; # recalculated; self.evo_t2targ_recalc[:last_changed + 1] = True. # Flag fidelity and gradients as needing recalculation; dyn.flag_system_changed(). # *** update stats ***; if dyn.stats is not None:; dyn.stats.num_ctrl_amp_updates += 1; dyn.stats.num_ctrl_amp_changes += changed_amps.sum(); dyn.stats.num_timeslot_changes += changed_ts_mask.sum(). return False; else:; return True. def flag_all_calc_now(self):; """"""; Flags all Hamiltonians, propagators and propagations to be; calculated now; """"""; # set flags for calculations; self.dyn_gen_calc_now[:] = True; self.prop_calc_now[:] = True; self.evo_init2t_calc_now[:-1] = True; self.evo_t2targ_calc_now[1:] = True. def recompute_evolution(self):; """"""; Recalculates the evo_init2t (forward) and evo_t2targ (onward) time; evolution operators; DynGen (Hamiltonians etc) and prop (propagator) are calculated; as necessary; """"""; if self.log_level <= logging.DEBUG_VERBOSE:; logger.log(logging.DEBUG_VERBOSE, ""recomputing evolution ""; ""(DynUpdate)""). dyn = self.parent; n_ts = dyn.num_tslots; # find the op slots that have been marked for update now; # and need recalculation; evo_init2t_recomp_now = self.evo_init2t_calc_now & \; self.evo_init2t_recalc; evo_t2targ_recomp_now = self.evo_t2targ_calc_now & \; self.evo_t2targ_recalc. # to recomupte evo_init2t, will need to start; # at a cell that has been computed; if np.any(evo_init2t_recomp_now):; for k in range(n_ts, 0, -1):; if evo_init2t_recomp_now[k] and self.evo_init2t_recalc[k-1]:; evo_init2t_recomp_now[k-1] = True. # for evo_t2targ, will also need to start; # at a cell that has been computed; if np.any(evo_t2targ_recomp_now):; for k in range(0, n_ts):; if evo_t2targ_recomp_now[k] and self.evo_t2targ_recalc[k+1]:; evo_t2targ_recomp_now[k+1] = True. # determine which dyn gen and prop need recalculating now in order to; # calculate the forwrd and onward evolutions; prop_recomp_now = (evo_init2t_recomp_now[1:]; | evo_t2ta",MatchSource.WIKI,docs/4.2/modules/qutip/control/tslotcomp.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/control/tslotcomp.html
https://qutip.org/docs/4.2/modules/qutip/control/tslotcomp.html:16534,Testability,log,logging,16534," True; # set all bkwd evo ops up to (incl) last changed Ham to be; # recalculated; self.evo_t2targ_recalc[:last_changed + 1] = True. # Flag fidelity and gradients as needing recalculation; dyn.flag_system_changed(). # *** update stats ***; if dyn.stats is not None:; dyn.stats.num_ctrl_amp_updates += 1; dyn.stats.num_ctrl_amp_changes += changed_amps.sum(); dyn.stats.num_timeslot_changes += changed_ts_mask.sum(). return False; else:; return True. def flag_all_calc_now(self):; """"""; Flags all Hamiltonians, propagators and propagations to be; calculated now; """"""; # set flags for calculations; self.dyn_gen_calc_now[:] = True; self.prop_calc_now[:] = True; self.evo_init2t_calc_now[:-1] = True; self.evo_t2targ_calc_now[1:] = True. def recompute_evolution(self):; """"""; Recalculates the evo_init2t (forward) and evo_t2targ (onward) time; evolution operators; DynGen (Hamiltonians etc) and prop (propagator) are calculated; as necessary; """"""; if self.log_level <= logging.DEBUG_VERBOSE:; logger.log(logging.DEBUG_VERBOSE, ""recomputing evolution ""; ""(DynUpdate)""). dyn = self.parent; n_ts = dyn.num_tslots; # find the op slots that have been marked for update now; # and need recalculation; evo_init2t_recomp_now = self.evo_init2t_calc_now & \; self.evo_init2t_recalc; evo_t2targ_recomp_now = self.evo_t2targ_calc_now & \; self.evo_t2targ_recalc. # to recomupte evo_init2t, will need to start; # at a cell that has been computed; if np.any(evo_init2t_recomp_now):; for k in range(n_ts, 0, -1):; if evo_init2t_recomp_now[k] and self.evo_init2t_recalc[k-1]:; evo_init2t_recomp_now[k-1] = True. # for evo_t2targ, will also need to start; # at a cell that has been computed; if np.any(evo_t2targ_recomp_now):; for k in range(0, n_ts):; if evo_t2targ_recomp_now[k] and self.evo_t2targ_recalc[k+1]:; evo_t2targ_recomp_now[k+1] = True. # determine which dyn gen and prop need recalculating now in order to; # calculate the forwrd and onward evolutions; prop_recomp_now = (evo_init2t_recomp_now[1:]; | evo_t2ta",MatchSource.WIKI,docs/4.2/modules/qutip/control/tslotcomp.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/control/tslotcomp.html
https://qutip.org/docs/4.2/modules/qutip/control/tslotcomp.html:11750,Usability,simpl,simply,11750,"[k]; else:; dyn._onwd_evo[k] = dyn._onwd_evo[k+1].dot(dyn._prop[k]). if dyn.fid_computer.uses_onto_evo:; #R = range(n_ts-1, -1, -1); R = range(n_ts-1, -1, -1); for k in R:; if dyn.oper_dtype == Qobj:; dyn._onto_evo[k] = dyn._onto_evo[k+1]*dyn._prop[k]; else:; dyn._onto_evo[k] = dyn._onto_evo[k+1].dot(dyn._prop[k]). if ecs:; ecs.wall_time_onwd_prop_compute = \; timeit.default_timer() - time_start; ; if dyn.stats:; dyn.stats.wall_time_dyn_gen_compute += \; ecs.wall_time_dyn_gen_compute; dyn.stats.wall_time_prop_compute += \; ecs.wall_time_prop_compute; dyn.stats.wall_time_fwd_prop_compute += \; ecs.wall_time_fwd_prop_compute; dyn.stats.wall_time_onwd_prop_compute += \; ecs.wall_time_onwd_prop_compute; ; if dyn.unitarity_check_level:; dyn.check_unitarity(); ; if dyn.dump:; self.dump_current(). [docs] def get_timeslot_for_fidelity_calc(self):; """"""; Returns the timeslot index that will be used calculate current fidelity; value.; This (default) method simply returns the last timeslot; """"""; _func_deprecation(""'get_timeslot_for_fidelity_calc' is deprecated. ""; ""Use '_get_timeslot_for_fidelity_calc'""); return self._get_timeslot_for_fidelity_calc. def _get_timeslot_for_fidelity_calc(self):; """"""; Returns the timeslot index that will be used calculate current fidelity; value.; This (default) method simply returns the last timeslot; """"""; return self.parent.num_tslots. class TSlotCompDynUpdate(TimeslotComputer):; """"""; Timeslot Computer - Dynamic Update; ********************************; ***** CURRENTLY HAS ISSUES *****; ***** AJGP 2014-10-02; ***** and is therefore not being maintained; ***** i.e. changes made to _UpdateAll are not being implemented here; ********************************; Updates only the dynamics generators, propagators and evolutions as; required when a subset of the ctrl amplitudes are updated.; Will update all if all amps have changed.; """""". def reset(self):; self.dyn_gen_recalc = None; self.prop_recalc = None; self.evo_init2t_recalc = None; self.evo_t2targ_re",MatchSource.WIKI,docs/4.2/modules/qutip/control/tslotcomp.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/control/tslotcomp.html
https://qutip.org/docs/4.2/modules/qutip/control/tslotcomp.html:12098,Usability,simpl,simply,12098,"cs:; ecs.wall_time_onwd_prop_compute = \; timeit.default_timer() - time_start; ; if dyn.stats:; dyn.stats.wall_time_dyn_gen_compute += \; ecs.wall_time_dyn_gen_compute; dyn.stats.wall_time_prop_compute += \; ecs.wall_time_prop_compute; dyn.stats.wall_time_fwd_prop_compute += \; ecs.wall_time_fwd_prop_compute; dyn.stats.wall_time_onwd_prop_compute += \; ecs.wall_time_onwd_prop_compute; ; if dyn.unitarity_check_level:; dyn.check_unitarity(); ; if dyn.dump:; self.dump_current(). [docs] def get_timeslot_for_fidelity_calc(self):; """"""; Returns the timeslot index that will be used calculate current fidelity; value.; This (default) method simply returns the last timeslot; """"""; _func_deprecation(""'get_timeslot_for_fidelity_calc' is deprecated. ""; ""Use '_get_timeslot_for_fidelity_calc'""); return self._get_timeslot_for_fidelity_calc. def _get_timeslot_for_fidelity_calc(self):; """"""; Returns the timeslot index that will be used calculate current fidelity; value.; This (default) method simply returns the last timeslot; """"""; return self.parent.num_tslots. class TSlotCompDynUpdate(TimeslotComputer):; """"""; Timeslot Computer - Dynamic Update; ********************************; ***** CURRENTLY HAS ISSUES *****; ***** AJGP 2014-10-02; ***** and is therefore not being maintained; ***** i.e. changes made to _UpdateAll are not being implemented here; ********************************; Updates only the dynamics generators, propagators and evolutions as; required when a subset of the ctrl amplitudes are updated.; Will update all if all amps have changed.; """""". def reset(self):; self.dyn_gen_recalc = None; self.prop_recalc = None; self.evo_init2t_recalc = None; self.evo_t2targ_recalc = None; self.dyn_gen_calc_now = None; self.prop_calc_now = None; self.evo_init2t_calc_now = None; self.evo_t2targ_calc_now = None; TimeslotComputer.reset(self); self.id_text = 'DYNAMIC'; self.apply_params(). def init_comp(self):; """"""; Initialise the flags; """"""; ####; # These maps are used to determine what needs to",MatchSource.WIKI,docs/4.2/modules/qutip/control/tslotcomp.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/control/tslotcomp.html
https://qutip.org/docs/4.2/modules/qutip/nonmarkov/heom.html:2454,Deployability,integrat,integrate,2454,"OSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT; # HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,; # SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT; # LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,; # DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY; # THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT; # (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE; # OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.; ###############################################################################; """"""; This module provides exact solvers for a system-bath setup using the; hierarchy equations of motion (HEOM).; """""". # Authors: Neill Lambert, Anubhav Vardhan, Alexander Pitchford; # Contact: nwlambert@gmail.com. import timeit; import numpy as np; #from scipy.misc import factorial; import scipy.sparse as sp; import scipy.integrate; from copy import copy; from qutip import Qobj, qeye; from qutip.states import enr_state_dictionaries; from qutip.superoperator import liouvillian, spre, spost; from qutip.cy.spmatfuncs import cy_ode_rhs; from qutip.solver import Options, Result, Stats; from qutip.ui.progressbar import BaseProgressBar, TextProgressBar; from qutip.cy.heom import cy_pad_csr; from qutip.cy.spmath import zcsr_kron; from qutip.fastsparse import fast_csr_matrix, fast_identity. [docs]class HEOMSolver(object):; """"""; This is superclass for all solvers that use the HEOM method for; calculating the dynamics evolution. There are many references for this.; A good introduction, and perhaps closest to the notation used here is:; DOI:10.1103/PhysRevLett.104.250401; A more canonical reference, with full derivation is:; DOI: 10.1103/PhysRevA.41.6676; The method can compute open system dynamics without using any Markovian; or rotating wave approximation (RWA) for systems where the bath; correlations can be approximated to a sum of complex eponentia",MatchSource.WIKI,docs/4.2/modules/qutip/nonmarkov/heom.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/nonmarkov/heom.html
https://qutip.org/docs/4.2/modules/qutip/nonmarkov/heom.html:7390,Deployability,integrat,integrate,7390,"ar. stats: :class:`qutip.solver.Stats`; Optional instance of solver.Stats, or a subclass thereof, for; storing performance statistics for the solver; If set to True, then the default Stats for this class will be used; Set to False for no stats; """""". self.H_sys = H_sys; self.coup_op = coup_op; self.coup_strength = coup_strength; self.temperature = temperature; self.N_cut = N_cut; self.N_exp = N_exp; if planck: self.planck = planck; if boltzmann: self.boltzmann = boltzmann; if isinstance(options, Options): self.options = options; if isinstance(progress_bar, BaseProgressBar):; self.progress_bar = progress_bar; elif progress_bar == True:; self.progress_bar = TextProgressBar(); elif progress_bar == False:; self.progress_bar = None; if isinstance(stats, Stats):; self.stats = stats; elif stats == True:; self.stats = self.create_new_stats(); elif stats == False:; self.stats = None. [docs] def create_new_stats(self):; """"""; Creates a new stats object suitable for use with this solver; Note: this solver expects the stats object to have sections; config; integrate; """"""; stats = Stats(['config', 'run']); stats.header = ""Hierarchy Solver Stats""; return stats. [docs]class HSolverDL(HEOMSolver):; """"""; HEOM solver based on the Drude-Lorentz model for spectral density.; Drude-Lorentz bath the correlation functions can be exactly analytically; expressed as an infinite sum of exponentials which depend on the; temperature, these are called the Matsubara terms or Matsubara frequencies. For practical computation purposes an approximation must be used based; on a small number of Matsubara terms (typically < 4). Attributes; ----------; cut_freq : float; Bath spectral density cutoff frequency. renorm : bool; Apply renormalisation to coupling terms; Can be useful if using SI units for planck and boltzmann. bnd_cut_approx : bool; Use boundary cut off approximation; Can be; """""". def __init__(self, H_sys, coup_op, coup_strength, temperature,; N_cut, N_exp, cut_freq, planck=1.0, boltzmann=1.0,; re",MatchSource.WIKI,docs/4.2/modules/qutip/nonmarkov/heom.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/nonmarkov/heom.html
https://qutip.org/docs/4.2/modules/qutip/nonmarkov/heom.html:13358,Deployability,integrat,integrate,13358,"he; N_he_interact += 1. he_state_neigh[k] = n_k. if n_excite <= N_c - 1:; # find the hierarchy element index of the neighbour after; # this element, for this Matsubara term; he_state_neigh[k] = n_k + 1; he_idx_neigh = he2idx[tuple(he_state_neigh)]. op = commQ; if renorm:; op = -1j*norm_plus[n_k, k]*op; else:; op = -1j*op. L_he = cy_pad_csr(op, N_he, N_he, he_idx, he_idx_neigh); L_helems += L_he; N_he_interact += 1. he_state_neigh[k] = n_k. if stats:; stats.add_timing('hierarchy contruct',; timeit.default_timer() - start_helem_constr,; ss_conf); stats.add_count('Num hierarchy elements', N_he, ss_conf); stats.add_count('Num he interactions', N_he_interact, ss_conf). # Setup Liouvillian; if stats: ; start_louvillian = timeit.default_timer(); ; H_he = zcsr_kron(unit_helems, liouvillian(H_sys).data). L_helems += H_he. if stats:; stats.add_timing('Liouvillian contruct',; timeit.default_timer() - start_louvillian,; ss_conf). if stats: start_integ_conf = timeit.default_timer(). r = scipy.integrate.ode(cy_ode_rhs). r.set_f_params(L_helems.data, L_helems.indices, L_helems.indptr); r.set_integrator('zvode', method=options.method, order=options.order,; atol=options.atol, rtol=options.rtol,; nsteps=options.nsteps, first_step=options.first_step,; min_step=options.min_step, max_step=options.max_step). if stats:; time_now = timeit.default_timer(); stats.add_timing('Liouvillian contruct',; time_now - start_integ_conf,; ss_conf); if ss_conf.total_time is None:; ss_conf.total_time = time_now - start_config; else:; ss_conf.total_time += time_now - start_config. self._ode = r; self._N_he = N_he; self._sup_dim = sup_dim; self._configured = True. [docs] def run(self, rho0, tlist):; """"""; Function to solve for an open quantum system using the; HEOM model. Parameters; ----------; rho0 : Qobj; Initial state (density matrix) of the system. tlist : list; Time over which system evolves. Returns; -------; results : :class:`qutip.solver.Result`; Object storing all results from the simulation.; """"""",MatchSource.WIKI,docs/4.2/modules/qutip/nonmarkov/heom.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/nonmarkov/heom.html
https://qutip.org/docs/4.2/modules/qutip/nonmarkov/heom.html:15432,Deployability,integrat,integrate,15432,".stats; r = self._ode. if not self._configured:; raise RuntimeError(""Solver must be configured before it is run""); if stats:; ss_conf = stats.sections.get('config'); if ss_conf is None:; raise RuntimeError(""No config section for solver stats""); ss_run = stats.sections.get('run'); if ss_run is None:; ss_run = stats.add_section('run'). # Set up terms of the matsubara and tanimura boundaries; output = Result(); output.solver = ""hsolve""; output.times = tlist; output.states = []. if stats: start_init = timeit.default_timer(); output.states.append(Qobj(rho0)); rho0_flat = rho0.full().ravel('F') # Using 'F' effectively transposes; rho0_he = np.zeros([sup_dim*self._N_he], dtype=complex); rho0_he[:sup_dim] = rho0_flat; r.set_initial_value(rho0_he, tlist[0]). if stats:; stats.add_timing('initialize',; timeit.default_timer() - start_init, ss_run); start_integ = timeit.default_timer(). dt = np.diff(tlist); n_tsteps = len(tlist); for t_idx, t in enumerate(tlist):; if t_idx < n_tsteps - 1:; r.integrate(r.t + dt[t_idx]); rho = Qobj(r.y[:sup_dim].reshape(rho0.shape), dims=rho0.dims); output.states.append(rho). if stats:; time_now = timeit.default_timer(); stats.add_timing('integrate',; time_now - start_integ, ss_run); if ss_run.total_time is None:; ss_run.total_time = time_now - start_run; else:; ss_run.total_time += time_now - start_run; stats.total_time = ss_conf.total_time + ss_run.total_time. return output. def _calc_matsubara_params(self):; """"""; Calculate the Matsubara coefficents and frequencies. Returns; -------; c, nu: both list(float). """"""; c = []; nu = []; lam0 = self.coup_strength; gam = self.cut_freq; hbar = self.planck; beta = 1.0/(self.boltzmann*self.temperature); N_m = self.N_exp. g = 2*np.pi / (beta*hbar); for k in range(N_m):; if k == 0:; nu.append(gam); c.append(lam0*gam*; (1.0/np.tan(gam*hbar*beta/2.0) - 1j) / hbar); else:; nu.append(k*g); c.append(4*lam0*gam*nu[k] /; ((nu[k]**2 - gam**2)*beta*hbar**2)). self.exp_coeff = c; self.exp_freq = nu; return c, nu. def _",MatchSource.WIKI,docs/4.2/modules/qutip/nonmarkov/heom.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/nonmarkov/heom.html
https://qutip.org/docs/4.2/modules/qutip/nonmarkov/heom.html:15614,Deployability,integrat,integrate,15614,"meError(""No config section for solver stats""); ss_run = stats.sections.get('run'); if ss_run is None:; ss_run = stats.add_section('run'). # Set up terms of the matsubara and tanimura boundaries; output = Result(); output.solver = ""hsolve""; output.times = tlist; output.states = []. if stats: start_init = timeit.default_timer(); output.states.append(Qobj(rho0)); rho0_flat = rho0.full().ravel('F') # Using 'F' effectively transposes; rho0_he = np.zeros([sup_dim*self._N_he], dtype=complex); rho0_he[:sup_dim] = rho0_flat; r.set_initial_value(rho0_he, tlist[0]). if stats:; stats.add_timing('initialize',; timeit.default_timer() - start_init, ss_run); start_integ = timeit.default_timer(). dt = np.diff(tlist); n_tsteps = len(tlist); for t_idx, t in enumerate(tlist):; if t_idx < n_tsteps - 1:; r.integrate(r.t + dt[t_idx]); rho = Qobj(r.y[:sup_dim].reshape(rho0.shape), dims=rho0.dims); output.states.append(rho). if stats:; time_now = timeit.default_timer(); stats.add_timing('integrate',; time_now - start_integ, ss_run); if ss_run.total_time is None:; ss_run.total_time = time_now - start_run; else:; ss_run.total_time += time_now - start_run; stats.total_time = ss_conf.total_time + ss_run.total_time. return output. def _calc_matsubara_params(self):; """"""; Calculate the Matsubara coefficents and frequencies. Returns; -------; c, nu: both list(float). """"""; c = []; nu = []; lam0 = self.coup_strength; gam = self.cut_freq; hbar = self.planck; beta = 1.0/(self.boltzmann*self.temperature); N_m = self.N_exp. g = 2*np.pi / (beta*hbar); for k in range(N_m):; if k == 0:; nu.append(gam); c.append(lam0*gam*; (1.0/np.tan(gam*hbar*beta/2.0) - 1j) / hbar); else:; nu.append(k*g); c.append(4*lam0*gam*nu[k] /; ((nu[k]**2 - gam**2)*beta*hbar**2)). self.exp_coeff = c; self.exp_freq = nu; return c, nu. def _calc_renorm_factors(self):; """"""; Calculate the renormalisation factors. Returns; -------; norm_plus, norm_minus : array[N_c, N_m] of float; """"""; c = self.exp_coeff; N_m = self.N_exp; N_c = self.N_cu",MatchSource.WIKI,docs/4.2/modules/qutip/nonmarkov/heom.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/nonmarkov/heom.html
https://qutip.org/docs/4.2/modules/qutip/nonmarkov/heom.html:18694,Deployability,update,updated,18694,"t(abs(c[k])*(n + 1)); norm_minus[n, k] = np.sqrt(float(n)/abs(c[k])). return norm_plus, norm_minus. def _pad_csr(A, row_scale, col_scale, insertrow=0, insertcol=0):; """"""; Expand the input csr_matrix to a greater space as given by the scale.; Effectively inserting A into a larger matrix; zeros([A.shape[0]*row_scale, A.shape[1]*col_scale]; at the position [A.shape[0]*insertrow, A.shape[1]*insertcol]; The same could be achieved through using a kron with a matrix with; one element set to 1. However, this is more efficient; """""". # ajgpitch 2016-03-08:; # Clearly this is a very simple operation in dense matrices; # It seems strange that there is nothing equivalent in sparse however,; # after much searching most threads suggest directly addressing; # the underlying arrays, as done here.; # This certainly proved more efficient than other methods such as stacking; #TODO: Perhaps cythonize and move to spmatfuncs. if not isinstance(A, sp.csr_matrix):; raise TypeError(""First parameter must be a csr matrix""); nrowin = A.shape[0]; ncolin = A.shape[1]; nrowout = nrowin*row_scale; ncolout = ncolin*col_scale. A._shape = (nrowout, ncolout); if insertcol == 0:; pass; elif insertcol > 0 and insertcol < col_scale:; A.indices = A.indices + insertcol*ncolin; else:; raise ValueError(""insertcol must be >= 0 and < col_scale""). if insertrow == 0:; A.indptr = np.concatenate((A.indptr,; np.array([A.indptr[-1]]*(row_scale-1)*nrowin))); elif insertrow == row_scale-1:; A.indptr = np.concatenate((np.array([0]*(row_scale - 1)*nrowin),; A.indptr)); elif insertrow > 0 and insertrow < row_scale - 1:; A.indptr = np.concatenate((np.array([0]*insertrow*nrowin), A.indptr,; np.array([A.indptr[-1]]*(row_scale - insertrow - 1)*nrowin))); else:; raise ValueError(""insertrow must be >= 0 and < row_scale""). return A. Â© Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, and A.L. Grimsmo.; Last updated on Jan 17, 2018. . Built with Sphinx using a theme provided by Read the Docs. . ",MatchSource.WIKI,docs/4.2/modules/qutip/nonmarkov/heom.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/nonmarkov/heom.html
https://qutip.org/docs/4.2/modules/qutip/nonmarkov/heom.html:4418,Energy Efficiency,reduce,reduced,4418,"he bath; correlations can be approximated to a sum of complex eponentials.; The method builds a matrix of linked differential equations, which are; then solved used the same ODE solvers as other qutip solvers (e.g. mesolve). This class should be treated as abstract. Currently the only subclass; implemented is that for the Drude-Lorentz spectral density. This covers; the majority of the work that has been done using this model, and there; are some performance advantages to assuming this model where it is; appropriate. There are opportunities to develop a more general spectral density code. Attributes; ----------; H_sys : Qobj; System Hamiltonian. coup_op : Qobj; Operator describing the coupling between system and bath. coup_strength : float; Coupling strength. temperature : float; Bath temperature, in units corresponding to planck. N_cut : int; Cutoff parameter for the bath. N_exp : int; Number of exponential terms used to approximate the bath correlation; functions. planck : float; reduced Planck constant. boltzmann : float; Boltzmann's constant. options : :class:`qutip.solver.Options`; Generic solver options.; If set to None the default options will be used. progress_bar: BaseProgressBar; Optional instance of BaseProgressBar, or a subclass thereof, for; showing the progress of the simulation. stats : :class:`qutip.solver.Stats`; optional container for holding performance statitics; If None is set, then statistics are not collected; There may be an overhead in collecting statistics. exp_coeff : list of complex; Coefficients for the exponential series terms. exp_freq : list of complex; Frequencies for the exponential series terms; """"""; def __init__(self):; raise NotImplementedError(""This is a abstract class only. ""; ""Use a subclass, for example HSolverDL""). [docs] def reset(self):; """"""; Reset any attributes to default values; """"""; self.planck = 1.0; self.boltzmann = 1.0; self.H_sys = None; self.coup_op = None; self.coup_strength = 0.0; self.temperature = 1.0; self.N_c",MatchSource.WIKI,docs/4.2/modules/qutip/nonmarkov/heom.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/nonmarkov/heom.html
https://qutip.org/docs/4.2/modules/qutip/nonmarkov/heom.html:17296,Energy Efficiency,efficient,efficient,17296,"se:; nu.append(k*g); c.append(4*lam0*gam*nu[k] /; ((nu[k]**2 - gam**2)*beta*hbar**2)). self.exp_coeff = c; self.exp_freq = nu; return c, nu. def _calc_renorm_factors(self):; """"""; Calculate the renormalisation factors. Returns; -------; norm_plus, norm_minus : array[N_c, N_m] of float; """"""; c = self.exp_coeff; N_m = self.N_exp; N_c = self.N_cut. norm_plus = np.empty((N_c+1, N_m)); norm_minus = np.empty((N_c+1, N_m)); for k in range(N_m):; for n in range(N_c+1):; norm_plus[n, k] = np.sqrt(abs(c[k])*(n + 1)); norm_minus[n, k] = np.sqrt(float(n)/abs(c[k])). return norm_plus, norm_minus. def _pad_csr(A, row_scale, col_scale, insertrow=0, insertcol=0):; """"""; Expand the input csr_matrix to a greater space as given by the scale.; Effectively inserting A into a larger matrix; zeros([A.shape[0]*row_scale, A.shape[1]*col_scale]; at the position [A.shape[0]*insertrow, A.shape[1]*insertcol]; The same could be achieved through using a kron with a matrix with; one element set to 1. However, this is more efficient; """""". # ajgpitch 2016-03-08:; # Clearly this is a very simple operation in dense matrices; # It seems strange that there is nothing equivalent in sparse however,; # after much searching most threads suggest directly addressing; # the underlying arrays, as done here.; # This certainly proved more efficient than other methods such as stacking; #TODO: Perhaps cythonize and move to spmatfuncs. if not isinstance(A, sp.csr_matrix):; raise TypeError(""First parameter must be a csr matrix""); nrowin = A.shape[0]; ncolin = A.shape[1]; nrowout = nrowin*row_scale; ncolout = ncolin*col_scale. A._shape = (nrowout, ncolout); if insertcol == 0:; pass; elif insertcol > 0 and insertcol < col_scale:; A.indices = A.indices + insertcol*ncolin; else:; raise ValueError(""insertcol must be >= 0 and < col_scale""). if insertrow == 0:; A.indptr = np.concatenate((A.indptr,; np.array([A.indptr[-1]]*(row_scale-1)*nrowin))); elif insertrow == row_scale-1:; A.indptr = np.concatenate((np.array([0]*(row_sca",MatchSource.WIKI,docs/4.2/modules/qutip/nonmarkov/heom.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/nonmarkov/heom.html
https://qutip.org/docs/4.2/modules/qutip/nonmarkov/heom.html:17603,Energy Efficiency,efficient,efficient,17603,"ut. norm_plus = np.empty((N_c+1, N_m)); norm_minus = np.empty((N_c+1, N_m)); for k in range(N_m):; for n in range(N_c+1):; norm_plus[n, k] = np.sqrt(abs(c[k])*(n + 1)); norm_minus[n, k] = np.sqrt(float(n)/abs(c[k])). return norm_plus, norm_minus. def _pad_csr(A, row_scale, col_scale, insertrow=0, insertcol=0):; """"""; Expand the input csr_matrix to a greater space as given by the scale.; Effectively inserting A into a larger matrix; zeros([A.shape[0]*row_scale, A.shape[1]*col_scale]; at the position [A.shape[0]*insertrow, A.shape[1]*insertcol]; The same could be achieved through using a kron with a matrix with; one element set to 1. However, this is more efficient; """""". # ajgpitch 2016-03-08:; # Clearly this is a very simple operation in dense matrices; # It seems strange that there is nothing equivalent in sparse however,; # after much searching most threads suggest directly addressing; # the underlying arrays, as done here.; # This certainly proved more efficient than other methods such as stacking; #TODO: Perhaps cythonize and move to spmatfuncs. if not isinstance(A, sp.csr_matrix):; raise TypeError(""First parameter must be a csr matrix""); nrowin = A.shape[0]; ncolin = A.shape[1]; nrowout = nrowin*row_scale; ncolout = ncolin*col_scale. A._shape = (nrowout, ncolout); if insertcol == 0:; pass; elif insertcol > 0 and insertcol < col_scale:; A.indices = A.indices + insertcol*ncolin; else:; raise ValueError(""insertcol must be >= 0 and < col_scale""). if insertrow == 0:; A.indptr = np.concatenate((A.indptr,; np.array([A.indptr[-1]]*(row_scale-1)*nrowin))); elif insertrow == row_scale-1:; A.indptr = np.concatenate((np.array([0]*(row_scale - 1)*nrowin),; A.indptr)); elif insertrow > 0 and insertrow < row_scale - 1:; A.indptr = np.concatenate((np.array([0]*insertrow*nrowin), A.indptr,; np.array([A.indptr[-1]]*(row_scale - insertrow - 1)*nrowin))); else:; raise ValueError(""insertrow must be >= 0 and < row_scale""). return A. Â© Copyright 2011 and later, P.D. Nation, J.R. Johans",MatchSource.WIKI,docs/4.2/modules/qutip/nonmarkov/heom.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/nonmarkov/heom.html
https://qutip.org/docs/4.2/modules/qutip/nonmarkov/heom.html:2454,Integrability,integrat,integrate,2454,"OSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT; # HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,; # SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT; # LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,; # DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY; # THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT; # (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE; # OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.; ###############################################################################; """"""; This module provides exact solvers for a system-bath setup using the; hierarchy equations of motion (HEOM).; """""". # Authors: Neill Lambert, Anubhav Vardhan, Alexander Pitchford; # Contact: nwlambert@gmail.com. import timeit; import numpy as np; #from scipy.misc import factorial; import scipy.sparse as sp; import scipy.integrate; from copy import copy; from qutip import Qobj, qeye; from qutip.states import enr_state_dictionaries; from qutip.superoperator import liouvillian, spre, spost; from qutip.cy.spmatfuncs import cy_ode_rhs; from qutip.solver import Options, Result, Stats; from qutip.ui.progressbar import BaseProgressBar, TextProgressBar; from qutip.cy.heom import cy_pad_csr; from qutip.cy.spmath import zcsr_kron; from qutip.fastsparse import fast_csr_matrix, fast_identity. [docs]class HEOMSolver(object):; """"""; This is superclass for all solvers that use the HEOM method for; calculating the dynamics evolution. There are many references for this.; A good introduction, and perhaps closest to the notation used here is:; DOI:10.1103/PhysRevLett.104.250401; A more canonical reference, with full derivation is:; DOI: 10.1103/PhysRevA.41.6676; The method can compute open system dynamics without using any Markovian; or rotating wave approximation (RWA) for systems where the bath; correlations can be approximated to a sum of complex eponentia",MatchSource.WIKI,docs/4.2/modules/qutip/nonmarkov/heom.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/nonmarkov/heom.html
https://qutip.org/docs/4.2/modules/qutip/nonmarkov/heom.html:7390,Integrability,integrat,integrate,7390,"ar. stats: :class:`qutip.solver.Stats`; Optional instance of solver.Stats, or a subclass thereof, for; storing performance statistics for the solver; If set to True, then the default Stats for this class will be used; Set to False for no stats; """""". self.H_sys = H_sys; self.coup_op = coup_op; self.coup_strength = coup_strength; self.temperature = temperature; self.N_cut = N_cut; self.N_exp = N_exp; if planck: self.planck = planck; if boltzmann: self.boltzmann = boltzmann; if isinstance(options, Options): self.options = options; if isinstance(progress_bar, BaseProgressBar):; self.progress_bar = progress_bar; elif progress_bar == True:; self.progress_bar = TextProgressBar(); elif progress_bar == False:; self.progress_bar = None; if isinstance(stats, Stats):; self.stats = stats; elif stats == True:; self.stats = self.create_new_stats(); elif stats == False:; self.stats = None. [docs] def create_new_stats(self):; """"""; Creates a new stats object suitable for use with this solver; Note: this solver expects the stats object to have sections; config; integrate; """"""; stats = Stats(['config', 'run']); stats.header = ""Hierarchy Solver Stats""; return stats. [docs]class HSolverDL(HEOMSolver):; """"""; HEOM solver based on the Drude-Lorentz model for spectral density.; Drude-Lorentz bath the correlation functions can be exactly analytically; expressed as an infinite sum of exponentials which depend on the; temperature, these are called the Matsubara terms or Matsubara frequencies. For practical computation purposes an approximation must be used based; on a small number of Matsubara terms (typically < 4). Attributes; ----------; cut_freq : float; Bath spectral density cutoff frequency. renorm : bool; Apply renormalisation to coupling terms; Can be useful if using SI units for planck and boltzmann. bnd_cut_approx : bool; Use boundary cut off approximation; Can be; """""". def __init__(self, H_sys, coup_op, coup_strength, temperature,; N_cut, N_exp, cut_freq, planck=1.0, boltzmann=1.0,; re",MatchSource.WIKI,docs/4.2/modules/qutip/nonmarkov/heom.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/nonmarkov/heom.html
https://qutip.org/docs/4.2/modules/qutip/nonmarkov/heom.html:7729,Integrability,depend,depend,7729,"t; self.N_exp = N_exp; if planck: self.planck = planck; if boltzmann: self.boltzmann = boltzmann; if isinstance(options, Options): self.options = options; if isinstance(progress_bar, BaseProgressBar):; self.progress_bar = progress_bar; elif progress_bar == True:; self.progress_bar = TextProgressBar(); elif progress_bar == False:; self.progress_bar = None; if isinstance(stats, Stats):; self.stats = stats; elif stats == True:; self.stats = self.create_new_stats(); elif stats == False:; self.stats = None. [docs] def create_new_stats(self):; """"""; Creates a new stats object suitable for use with this solver; Note: this solver expects the stats object to have sections; config; integrate; """"""; stats = Stats(['config', 'run']); stats.header = ""Hierarchy Solver Stats""; return stats. [docs]class HSolverDL(HEOMSolver):; """"""; HEOM solver based on the Drude-Lorentz model for spectral density.; Drude-Lorentz bath the correlation functions can be exactly analytically; expressed as an infinite sum of exponentials which depend on the; temperature, these are called the Matsubara terms or Matsubara frequencies. For practical computation purposes an approximation must be used based; on a small number of Matsubara terms (typically < 4). Attributes; ----------; cut_freq : float; Bath spectral density cutoff frequency. renorm : bool; Apply renormalisation to coupling terms; Can be useful if using SI units for planck and boltzmann. bnd_cut_approx : bool; Use boundary cut off approximation; Can be; """""". def __init__(self, H_sys, coup_op, coup_strength, temperature,; N_cut, N_exp, cut_freq, planck=1.0, boltzmann=1.0,; renorm=True, bnd_cut_approx=True,; options=None, progress_bar=None, stats=None):. self.reset(). if options is None:; self.options = Options(); else:; self.options = options. self.progress_bar = False; if progress_bar is None:; self.progress_bar = BaseProgressBar(); elif progress_bar == True:; self.progress_bar = TextProgressBar(). # the other attributes will be set in the config",MatchSource.WIKI,docs/4.2/modules/qutip/nonmarkov/heom.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/nonmarkov/heom.html
https://qutip.org/docs/4.2/modules/qutip/nonmarkov/heom.html:13358,Integrability,integrat,integrate,13358,"he; N_he_interact += 1. he_state_neigh[k] = n_k. if n_excite <= N_c - 1:; # find the hierarchy element index of the neighbour after; # this element, for this Matsubara term; he_state_neigh[k] = n_k + 1; he_idx_neigh = he2idx[tuple(he_state_neigh)]. op = commQ; if renorm:; op = -1j*norm_plus[n_k, k]*op; else:; op = -1j*op. L_he = cy_pad_csr(op, N_he, N_he, he_idx, he_idx_neigh); L_helems += L_he; N_he_interact += 1. he_state_neigh[k] = n_k. if stats:; stats.add_timing('hierarchy contruct',; timeit.default_timer() - start_helem_constr,; ss_conf); stats.add_count('Num hierarchy elements', N_he, ss_conf); stats.add_count('Num he interactions', N_he_interact, ss_conf). # Setup Liouvillian; if stats: ; start_louvillian = timeit.default_timer(); ; H_he = zcsr_kron(unit_helems, liouvillian(H_sys).data). L_helems += H_he. if stats:; stats.add_timing('Liouvillian contruct',; timeit.default_timer() - start_louvillian,; ss_conf). if stats: start_integ_conf = timeit.default_timer(). r = scipy.integrate.ode(cy_ode_rhs). r.set_f_params(L_helems.data, L_helems.indices, L_helems.indptr); r.set_integrator('zvode', method=options.method, order=options.order,; atol=options.atol, rtol=options.rtol,; nsteps=options.nsteps, first_step=options.first_step,; min_step=options.min_step, max_step=options.max_step). if stats:; time_now = timeit.default_timer(); stats.add_timing('Liouvillian contruct',; time_now - start_integ_conf,; ss_conf); if ss_conf.total_time is None:; ss_conf.total_time = time_now - start_config; else:; ss_conf.total_time += time_now - start_config. self._ode = r; self._N_he = N_he; self._sup_dim = sup_dim; self._configured = True. [docs] def run(self, rho0, tlist):; """"""; Function to solve for an open quantum system using the; HEOM model. Parameters; ----------; rho0 : Qobj; Initial state (density matrix) of the system. tlist : list; Time over which system evolves. Returns; -------; results : :class:`qutip.solver.Result`; Object storing all results from the simulation.; """"""",MatchSource.WIKI,docs/4.2/modules/qutip/nonmarkov/heom.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/nonmarkov/heom.html
https://qutip.org/docs/4.2/modules/qutip/nonmarkov/heom.html:15432,Integrability,integrat,integrate,15432,".stats; r = self._ode. if not self._configured:; raise RuntimeError(""Solver must be configured before it is run""); if stats:; ss_conf = stats.sections.get('config'); if ss_conf is None:; raise RuntimeError(""No config section for solver stats""); ss_run = stats.sections.get('run'); if ss_run is None:; ss_run = stats.add_section('run'). # Set up terms of the matsubara and tanimura boundaries; output = Result(); output.solver = ""hsolve""; output.times = tlist; output.states = []. if stats: start_init = timeit.default_timer(); output.states.append(Qobj(rho0)); rho0_flat = rho0.full().ravel('F') # Using 'F' effectively transposes; rho0_he = np.zeros([sup_dim*self._N_he], dtype=complex); rho0_he[:sup_dim] = rho0_flat; r.set_initial_value(rho0_he, tlist[0]). if stats:; stats.add_timing('initialize',; timeit.default_timer() - start_init, ss_run); start_integ = timeit.default_timer(). dt = np.diff(tlist); n_tsteps = len(tlist); for t_idx, t in enumerate(tlist):; if t_idx < n_tsteps - 1:; r.integrate(r.t + dt[t_idx]); rho = Qobj(r.y[:sup_dim].reshape(rho0.shape), dims=rho0.dims); output.states.append(rho). if stats:; time_now = timeit.default_timer(); stats.add_timing('integrate',; time_now - start_integ, ss_run); if ss_run.total_time is None:; ss_run.total_time = time_now - start_run; else:; ss_run.total_time += time_now - start_run; stats.total_time = ss_conf.total_time + ss_run.total_time. return output. def _calc_matsubara_params(self):; """"""; Calculate the Matsubara coefficents and frequencies. Returns; -------; c, nu: both list(float). """"""; c = []; nu = []; lam0 = self.coup_strength; gam = self.cut_freq; hbar = self.planck; beta = 1.0/(self.boltzmann*self.temperature); N_m = self.N_exp. g = 2*np.pi / (beta*hbar); for k in range(N_m):; if k == 0:; nu.append(gam); c.append(lam0*gam*; (1.0/np.tan(gam*hbar*beta/2.0) - 1j) / hbar); else:; nu.append(k*g); c.append(4*lam0*gam*nu[k] /; ((nu[k]**2 - gam**2)*beta*hbar**2)). self.exp_coeff = c; self.exp_freq = nu; return c, nu. def _",MatchSource.WIKI,docs/4.2/modules/qutip/nonmarkov/heom.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/nonmarkov/heom.html
https://qutip.org/docs/4.2/modules/qutip/nonmarkov/heom.html:15614,Integrability,integrat,integrate,15614,"meError(""No config section for solver stats""); ss_run = stats.sections.get('run'); if ss_run is None:; ss_run = stats.add_section('run'). # Set up terms of the matsubara and tanimura boundaries; output = Result(); output.solver = ""hsolve""; output.times = tlist; output.states = []. if stats: start_init = timeit.default_timer(); output.states.append(Qobj(rho0)); rho0_flat = rho0.full().ravel('F') # Using 'F' effectively transposes; rho0_he = np.zeros([sup_dim*self._N_he], dtype=complex); rho0_he[:sup_dim] = rho0_flat; r.set_initial_value(rho0_he, tlist[0]). if stats:; stats.add_timing('initialize',; timeit.default_timer() - start_init, ss_run); start_integ = timeit.default_timer(). dt = np.diff(tlist); n_tsteps = len(tlist); for t_idx, t in enumerate(tlist):; if t_idx < n_tsteps - 1:; r.integrate(r.t + dt[t_idx]); rho = Qobj(r.y[:sup_dim].reshape(rho0.shape), dims=rho0.dims); output.states.append(rho). if stats:; time_now = timeit.default_timer(); stats.add_timing('integrate',; time_now - start_integ, ss_run); if ss_run.total_time is None:; ss_run.total_time = time_now - start_run; else:; ss_run.total_time += time_now - start_run; stats.total_time = ss_conf.total_time + ss_run.total_time. return output. def _calc_matsubara_params(self):; """"""; Calculate the Matsubara coefficents and frequencies. Returns; -------; c, nu: both list(float). """"""; c = []; nu = []; lam0 = self.coup_strength; gam = self.cut_freq; hbar = self.planck; beta = 1.0/(self.boltzmann*self.temperature); N_m = self.N_exp. g = 2*np.pi / (beta*hbar); for k in range(N_m):; if k == 0:; nu.append(gam); c.append(lam0*gam*; (1.0/np.tan(gam*hbar*beta/2.0) - 1j) / hbar); else:; nu.append(k*g); c.append(4*lam0*gam*nu[k] /; ((nu[k]**2 - gam**2)*beta*hbar**2)). self.exp_coeff = c; self.exp_freq = nu; return c, nu. def _calc_renorm_factors(self):; """"""; Calculate the renormalisation factors. Returns; -------; norm_plus, norm_minus : array[N_c, N_m] of float; """"""; c = self.exp_coeff; N_m = self.N_exp; N_c = self.N_cu",MatchSource.WIKI,docs/4.2/modules/qutip/nonmarkov/heom.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/nonmarkov/heom.html
https://qutip.org/docs/4.2/modules/qutip/nonmarkov/heom.html:4115,Modifiability,coupling,coupling,4115,"duction, and perhaps closest to the notation used here is:; DOI:10.1103/PhysRevLett.104.250401; A more canonical reference, with full derivation is:; DOI: 10.1103/PhysRevA.41.6676; The method can compute open system dynamics without using any Markovian; or rotating wave approximation (RWA) for systems where the bath; correlations can be approximated to a sum of complex eponentials.; The method builds a matrix of linked differential equations, which are; then solved used the same ODE solvers as other qutip solvers (e.g. mesolve). This class should be treated as abstract. Currently the only subclass; implemented is that for the Drude-Lorentz spectral density. This covers; the majority of the work that has been done using this model, and there; are some performance advantages to assuming this model where it is; appropriate. There are opportunities to develop a more general spectral density code. Attributes; ----------; H_sys : Qobj; System Hamiltonian. coup_op : Qobj; Operator describing the coupling between system and bath. coup_strength : float; Coupling strength. temperature : float; Bath temperature, in units corresponding to planck. N_cut : int; Cutoff parameter for the bath. N_exp : int; Number of exponential terms used to approximate the bath correlation; functions. planck : float; reduced Planck constant. boltzmann : float; Boltzmann's constant. options : :class:`qutip.solver.Options`; Generic solver options.; If set to None the default options will be used. progress_bar: BaseProgressBar; Optional instance of BaseProgressBar, or a subclass thereof, for; showing the progress of the simulation. stats : :class:`qutip.solver.Stats`; optional container for holding performance statitics; If None is set, then statistics are not collected; There may be an overhead in collecting statistics. exp_coeff : list of complex; Coefficients for the exponential series terms. exp_freq : list of complex; Frequencies for the exponential series terms; """"""; def __init__(self):; raise ",MatchSource.WIKI,docs/4.2/modules/qutip/nonmarkov/heom.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/nonmarkov/heom.html
https://qutip.org/docs/4.2/modules/qutip/nonmarkov/heom.html:5595,Modifiability,config,configured,5595,"ess_bar: BaseProgressBar; Optional instance of BaseProgressBar, or a subclass thereof, for; showing the progress of the simulation. stats : :class:`qutip.solver.Stats`; optional container for holding performance statitics; If None is set, then statistics are not collected; There may be an overhead in collecting statistics. exp_coeff : list of complex; Coefficients for the exponential series terms. exp_freq : list of complex; Frequencies for the exponential series terms; """"""; def __init__(self):; raise NotImplementedError(""This is a abstract class only. ""; ""Use a subclass, for example HSolverDL""). [docs] def reset(self):; """"""; Reset any attributes to default values; """"""; self.planck = 1.0; self.boltzmann = 1.0; self.H_sys = None; self.coup_op = None; self.coup_strength = 0.0; self.temperature = 1.0; self.N_cut = 10; self.N_exp = 2; self.N_he = 0. self.exp_coeff = None; self.exp_freq = None. self.options = None; self.progress_bar = None; self.stats = None. self.ode = None; self.configured = False. [docs] def configure(self, H_sys, coup_op, coup_strength, temperature,; N_cut, N_exp, planck=None, boltzmann=None,; renorm=None, bnd_cut_approx=None,; options=None, progress_bar=None, stats=None):; """"""; Configure the solver using the passed parameters; The parameters are described in the class attributes, unless there; is some specific behaviour. Parameters; ----------; options : :class:`qutip.solver.Options`; Generic solver options.; If set to None the default options will be used. progress_bar: BaseProgressBar; Optional instance of BaseProgressBar, or a subclass thereof, for; showing the progress of the simulation.; If set to None, then the default progress bar will be used; Set to False for no progress bar. stats: :class:`qutip.solver.Stats`; Optional instance of solver.Stats, or a subclass thereof, for; storing performance statistics for the solver; If set to True, then the default Stats for this class will be used; Set to False for no stats; """""". self.H_sys = H_sys; self",MatchSource.WIKI,docs/4.2/modules/qutip/nonmarkov/heom.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/nonmarkov/heom.html
https://qutip.org/docs/4.2/modules/qutip/nonmarkov/heom.html:5626,Modifiability,config,configure,5626,"ner for holding performance statitics; If None is set, then statistics are not collected; There may be an overhead in collecting statistics. exp_coeff : list of complex; Coefficients for the exponential series terms. exp_freq : list of complex; Frequencies for the exponential series terms; """"""; def __init__(self):; raise NotImplementedError(""This is a abstract class only. ""; ""Use a subclass, for example HSolverDL""). [docs] def reset(self):; """"""; Reset any attributes to default values; """"""; self.planck = 1.0; self.boltzmann = 1.0; self.H_sys = None; self.coup_op = None; self.coup_strength = 0.0; self.temperature = 1.0; self.N_cut = 10; self.N_exp = 2; self.N_he = 0. self.exp_coeff = None; self.exp_freq = None. self.options = None; self.progress_bar = None; self.stats = None. self.ode = None; self.configured = False. [docs] def configure(self, H_sys, coup_op, coup_strength, temperature,; N_cut, N_exp, planck=None, boltzmann=None,; renorm=None, bnd_cut_approx=None,; options=None, progress_bar=None, stats=None):; """"""; Configure the solver using the passed parameters; The parameters are described in the class attributes, unless there; is some specific behaviour. Parameters; ----------; options : :class:`qutip.solver.Options`; Generic solver options.; If set to None the default options will be used. progress_bar: BaseProgressBar; Optional instance of BaseProgressBar, or a subclass thereof, for; showing the progress of the simulation.; If set to None, then the default progress bar will be used; Set to False for no progress bar. stats: :class:`qutip.solver.Stats`; Optional instance of solver.Stats, or a subclass thereof, for; storing performance statistics for the solver; If set to True, then the default Stats for this class will be used; Set to False for no stats; """""". self.H_sys = H_sys; self.coup_op = coup_op; self.coup_strength = coup_strength; self.temperature = temperature; self.N_cut = N_cut; self.N_exp = N_exp; if planck: self.planck = planck; if boltzmann: self.bolt",MatchSource.WIKI,docs/4.2/modules/qutip/nonmarkov/heom.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/nonmarkov/heom.html
https://qutip.org/docs/4.2/modules/qutip/nonmarkov/heom.html:7382,Modifiability,config,config,7382,"ar. stats: :class:`qutip.solver.Stats`; Optional instance of solver.Stats, or a subclass thereof, for; storing performance statistics for the solver; If set to True, then the default Stats for this class will be used; Set to False for no stats; """""". self.H_sys = H_sys; self.coup_op = coup_op; self.coup_strength = coup_strength; self.temperature = temperature; self.N_cut = N_cut; self.N_exp = N_exp; if planck: self.planck = planck; if boltzmann: self.boltzmann = boltzmann; if isinstance(options, Options): self.options = options; if isinstance(progress_bar, BaseProgressBar):; self.progress_bar = progress_bar; elif progress_bar == True:; self.progress_bar = TextProgressBar(); elif progress_bar == False:; self.progress_bar = None; if isinstance(stats, Stats):; self.stats = stats; elif stats == True:; self.stats = self.create_new_stats(); elif stats == False:; self.stats = None. [docs] def create_new_stats(self):; """"""; Creates a new stats object suitable for use with this solver; Note: this solver expects the stats object to have sections; config; integrate; """"""; stats = Stats(['config', 'run']); stats.header = ""Hierarchy Solver Stats""; return stats. [docs]class HSolverDL(HEOMSolver):; """"""; HEOM solver based on the Drude-Lorentz model for spectral density.; Drude-Lorentz bath the correlation functions can be exactly analytically; expressed as an infinite sum of exponentials which depend on the; temperature, these are called the Matsubara terms or Matsubara frequencies. For practical computation purposes an approximation must be used based; on a small number of Matsubara terms (typically < 4). Attributes; ----------; cut_freq : float; Bath spectral density cutoff frequency. renorm : bool; Apply renormalisation to coupling terms; Can be useful if using SI units for planck and boltzmann. bnd_cut_approx : bool; Use boundary cut off approximation; Can be; """""". def __init__(self, H_sys, coup_op, coup_strength, temperature,; N_cut, N_exp, cut_freq, planck=1.0, boltzmann=1.0,; re",MatchSource.WIKI,docs/4.2/modules/qutip/nonmarkov/heom.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/nonmarkov/heom.html
https://qutip.org/docs/4.2/modules/qutip/nonmarkov/heom.html:7422,Modifiability,config,config,7422,"ar. stats: :class:`qutip.solver.Stats`; Optional instance of solver.Stats, or a subclass thereof, for; storing performance statistics for the solver; If set to True, then the default Stats for this class will be used; Set to False for no stats; """""". self.H_sys = H_sys; self.coup_op = coup_op; self.coup_strength = coup_strength; self.temperature = temperature; self.N_cut = N_cut; self.N_exp = N_exp; if planck: self.planck = planck; if boltzmann: self.boltzmann = boltzmann; if isinstance(options, Options): self.options = options; if isinstance(progress_bar, BaseProgressBar):; self.progress_bar = progress_bar; elif progress_bar == True:; self.progress_bar = TextProgressBar(); elif progress_bar == False:; self.progress_bar = None; if isinstance(stats, Stats):; self.stats = stats; elif stats == True:; self.stats = self.create_new_stats(); elif stats == False:; self.stats = None. [docs] def create_new_stats(self):; """"""; Creates a new stats object suitable for use with this solver; Note: this solver expects the stats object to have sections; config; integrate; """"""; stats = Stats(['config', 'run']); stats.header = ""Hierarchy Solver Stats""; return stats. [docs]class HSolverDL(HEOMSolver):; """"""; HEOM solver based on the Drude-Lorentz model for spectral density.; Drude-Lorentz bath the correlation functions can be exactly analytically; expressed as an infinite sum of exponentials which depend on the; temperature, these are called the Matsubara terms or Matsubara frequencies. For practical computation purposes an approximation must be used based; on a small number of Matsubara terms (typically < 4). Attributes; ----------; cut_freq : float; Bath spectral density cutoff frequency. renorm : bool; Apply renormalisation to coupling terms; Can be useful if using SI units for planck and boltzmann. bnd_cut_approx : bool; Use boundary cut off approximation; Can be; """""". def __init__(self, H_sys, coup_op, coup_strength, temperature,; N_cut, N_exp, cut_freq, planck=1.0, boltzmann=1.0,; re",MatchSource.WIKI,docs/4.2/modules/qutip/nonmarkov/heom.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/nonmarkov/heom.html
https://qutip.org/docs/4.2/modules/qutip/nonmarkov/heom.html:8068,Modifiability,coupling,coupling,8068,"ats, Stats):; self.stats = stats; elif stats == True:; self.stats = self.create_new_stats(); elif stats == False:; self.stats = None. [docs] def create_new_stats(self):; """"""; Creates a new stats object suitable for use with this solver; Note: this solver expects the stats object to have sections; config; integrate; """"""; stats = Stats(['config', 'run']); stats.header = ""Hierarchy Solver Stats""; return stats. [docs]class HSolverDL(HEOMSolver):; """"""; HEOM solver based on the Drude-Lorentz model for spectral density.; Drude-Lorentz bath the correlation functions can be exactly analytically; expressed as an infinite sum of exponentials which depend on the; temperature, these are called the Matsubara terms or Matsubara frequencies. For practical computation purposes an approximation must be used based; on a small number of Matsubara terms (typically < 4). Attributes; ----------; cut_freq : float; Bath spectral density cutoff frequency. renorm : bool; Apply renormalisation to coupling terms; Can be useful if using SI units for planck and boltzmann. bnd_cut_approx : bool; Use boundary cut off approximation; Can be; """""". def __init__(self, H_sys, coup_op, coup_strength, temperature,; N_cut, N_exp, cut_freq, planck=1.0, boltzmann=1.0,; renorm=True, bnd_cut_approx=True,; options=None, progress_bar=None, stats=None):. self.reset(). if options is None:; self.options = Options(); else:; self.options = options. self.progress_bar = False; if progress_bar is None:; self.progress_bar = BaseProgressBar(); elif progress_bar == True:; self.progress_bar = TextProgressBar(). # the other attributes will be set in the configure method; self.configure(H_sys, coup_op, coup_strength, temperature,; N_cut, N_exp, cut_freq, planck=planck, boltzmann=boltzmann,; renorm=renorm, bnd_cut_approx=bnd_cut_approx, stats=stats). [docs] def reset(self):; """"""; Reset any attributes to default values; """"""; HEOMSolver.reset(self); self.cut_freq = 1.0; self.renorm = False; self.bnd_cut_approx = False. [docs] def",MatchSource.WIKI,docs/4.2/modules/qutip/nonmarkov/heom.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/nonmarkov/heom.html
https://qutip.org/docs/4.2/modules/qutip/nonmarkov/heom.html:8705,Modifiability,config,configure,8705,"nfinite sum of exponentials which depend on the; temperature, these are called the Matsubara terms or Matsubara frequencies. For practical computation purposes an approximation must be used based; on a small number of Matsubara terms (typically < 4). Attributes; ----------; cut_freq : float; Bath spectral density cutoff frequency. renorm : bool; Apply renormalisation to coupling terms; Can be useful if using SI units for planck and boltzmann. bnd_cut_approx : bool; Use boundary cut off approximation; Can be; """""". def __init__(self, H_sys, coup_op, coup_strength, temperature,; N_cut, N_exp, cut_freq, planck=1.0, boltzmann=1.0,; renorm=True, bnd_cut_approx=True,; options=None, progress_bar=None, stats=None):. self.reset(). if options is None:; self.options = Options(); else:; self.options = options. self.progress_bar = False; if progress_bar is None:; self.progress_bar = BaseProgressBar(); elif progress_bar == True:; self.progress_bar = TextProgressBar(). # the other attributes will be set in the configure method; self.configure(H_sys, coup_op, coup_strength, temperature,; N_cut, N_exp, cut_freq, planck=planck, boltzmann=boltzmann,; renorm=renorm, bnd_cut_approx=bnd_cut_approx, stats=stats). [docs] def reset(self):; """"""; Reset any attributes to default values; """"""; HEOMSolver.reset(self); self.cut_freq = 1.0; self.renorm = False; self.bnd_cut_approx = False. [docs] def configure(self, H_sys, coup_op, coup_strength, temperature,; N_cut, N_exp, cut_freq, planck=None, boltzmann=None,; renorm=None, bnd_cut_approx=None,; options=None, progress_bar=None, stats=None):; """"""; Calls configure from :class:`HEOMSolver` and sets any attributes; that are specific to this subclass; """"""; start_config = timeit.default_timer(). HEOMSolver.configure(self, H_sys, coup_op, coup_strength,; temperature, N_cut, N_exp,; planck=planck, boltzmann=boltzmann,; options=options, progress_bar=progress_bar, stats=stats); self.cut_freq = cut_freq; if renorm is not None: self.renorm = renorm; if bnd_cu",MatchSource.WIKI,docs/4.2/modules/qutip/nonmarkov/heom.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/nonmarkov/heom.html
https://qutip.org/docs/4.2/modules/qutip/nonmarkov/heom.html:8728,Modifiability,config,configure,8728,"ies. For practical computation purposes an approximation must be used based; on a small number of Matsubara terms (typically < 4). Attributes; ----------; cut_freq : float; Bath spectral density cutoff frequency. renorm : bool; Apply renormalisation to coupling terms; Can be useful if using SI units for planck and boltzmann. bnd_cut_approx : bool; Use boundary cut off approximation; Can be; """""". def __init__(self, H_sys, coup_op, coup_strength, temperature,; N_cut, N_exp, cut_freq, planck=1.0, boltzmann=1.0,; renorm=True, bnd_cut_approx=True,; options=None, progress_bar=None, stats=None):. self.reset(). if options is None:; self.options = Options(); else:; self.options = options. self.progress_bar = False; if progress_bar is None:; self.progress_bar = BaseProgressBar(); elif progress_bar == True:; self.progress_bar = TextProgressBar(). # the other attributes will be set in the configure method; self.configure(H_sys, coup_op, coup_strength, temperature,; N_cut, N_exp, cut_freq, planck=planck, boltzmann=boltzmann,; renorm=renorm, bnd_cut_approx=bnd_cut_approx, stats=stats). [docs] def reset(self):; """"""; Reset any attributes to default values; """"""; HEOMSolver.reset(self); self.cut_freq = 1.0; self.renorm = False; self.bnd_cut_approx = False. [docs] def configure(self, H_sys, coup_op, coup_strength, temperature,; N_cut, N_exp, cut_freq, planck=None, boltzmann=None,; renorm=None, bnd_cut_approx=None,; options=None, progress_bar=None, stats=None):; """"""; Calls configure from :class:`HEOMSolver` and sets any attributes; that are specific to this subclass; """"""; start_config = timeit.default_timer(). HEOMSolver.configure(self, H_sys, coup_op, coup_strength,; temperature, N_cut, N_exp,; planck=planck, boltzmann=boltzmann,; options=options, progress_bar=progress_bar, stats=stats); self.cut_freq = cut_freq; if renorm is not None: self.renorm = renorm; if bnd_cut_approx is not None: self.bnd_cut_approx = bnd_cut_approx. # Load local values for optional parameters; # Constants and ",MatchSource.WIKI,docs/4.2/modules/qutip/nonmarkov/heom.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/nonmarkov/heom.html
https://qutip.org/docs/4.2/modules/qutip/nonmarkov/heom.html:9085,Modifiability,config,configure,9085,"_op, coup_strength, temperature,; N_cut, N_exp, cut_freq, planck=1.0, boltzmann=1.0,; renorm=True, bnd_cut_approx=True,; options=None, progress_bar=None, stats=None):. self.reset(). if options is None:; self.options = Options(); else:; self.options = options. self.progress_bar = False; if progress_bar is None:; self.progress_bar = BaseProgressBar(); elif progress_bar == True:; self.progress_bar = TextProgressBar(). # the other attributes will be set in the configure method; self.configure(H_sys, coup_op, coup_strength, temperature,; N_cut, N_exp, cut_freq, planck=planck, boltzmann=boltzmann,; renorm=renorm, bnd_cut_approx=bnd_cut_approx, stats=stats). [docs] def reset(self):; """"""; Reset any attributes to default values; """"""; HEOMSolver.reset(self); self.cut_freq = 1.0; self.renorm = False; self.bnd_cut_approx = False. [docs] def configure(self, H_sys, coup_op, coup_strength, temperature,; N_cut, N_exp, cut_freq, planck=None, boltzmann=None,; renorm=None, bnd_cut_approx=None,; options=None, progress_bar=None, stats=None):; """"""; Calls configure from :class:`HEOMSolver` and sets any attributes; that are specific to this subclass; """"""; start_config = timeit.default_timer(). HEOMSolver.configure(self, H_sys, coup_op, coup_strength,; temperature, N_cut, N_exp,; planck=planck, boltzmann=boltzmann,; options=options, progress_bar=progress_bar, stats=stats); self.cut_freq = cut_freq; if renorm is not None: self.renorm = renorm; if bnd_cut_approx is not None: self.bnd_cut_approx = bnd_cut_approx. # Load local values for optional parameters; # Constants and Hamiltonian.; hbar = self.planck; options = self.options; progress_bar = self.progress_bar; stats = self.stats. if stats:; ss_conf = stats.sections.get('config'); if ss_conf is None:; ss_conf = stats.add_section('config'). c, nu = self._calc_matsubara_params(). if renorm:; norm_plus, norm_minus = self._calc_renorm_factors(); if stats:; stats.add_message('options', 'renormalisation', ss_conf); # Dimensions et by system; sup_di",MatchSource.WIKI,docs/4.2/modules/qutip/nonmarkov/heom.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/nonmarkov/heom.html
https://qutip.org/docs/4.2/modules/qutip/nonmarkov/heom.html:9293,Modifiability,config,configure,9293,"_op, coup_strength, temperature,; N_cut, N_exp, cut_freq, planck=1.0, boltzmann=1.0,; renorm=True, bnd_cut_approx=True,; options=None, progress_bar=None, stats=None):. self.reset(). if options is None:; self.options = Options(); else:; self.options = options. self.progress_bar = False; if progress_bar is None:; self.progress_bar = BaseProgressBar(); elif progress_bar == True:; self.progress_bar = TextProgressBar(). # the other attributes will be set in the configure method; self.configure(H_sys, coup_op, coup_strength, temperature,; N_cut, N_exp, cut_freq, planck=planck, boltzmann=boltzmann,; renorm=renorm, bnd_cut_approx=bnd_cut_approx, stats=stats). [docs] def reset(self):; """"""; Reset any attributes to default values; """"""; HEOMSolver.reset(self); self.cut_freq = 1.0; self.renorm = False; self.bnd_cut_approx = False. [docs] def configure(self, H_sys, coup_op, coup_strength, temperature,; N_cut, N_exp, cut_freq, planck=None, boltzmann=None,; renorm=None, bnd_cut_approx=None,; options=None, progress_bar=None, stats=None):; """"""; Calls configure from :class:`HEOMSolver` and sets any attributes; that are specific to this subclass; """"""; start_config = timeit.default_timer(). HEOMSolver.configure(self, H_sys, coup_op, coup_strength,; temperature, N_cut, N_exp,; planck=planck, boltzmann=boltzmann,; options=options, progress_bar=progress_bar, stats=stats); self.cut_freq = cut_freq; if renorm is not None: self.renorm = renorm; if bnd_cut_approx is not None: self.bnd_cut_approx = bnd_cut_approx. # Load local values for optional parameters; # Constants and Hamiltonian.; hbar = self.planck; options = self.options; progress_bar = self.progress_bar; stats = self.stats. if stats:; ss_conf = stats.sections.get('config'); if ss_conf is None:; ss_conf = stats.add_section('config'). c, nu = self._calc_matsubara_params(). if renorm:; norm_plus, norm_minus = self._calc_renorm_factors(); if stats:; stats.add_message('options', 'renormalisation', ss_conf); # Dimensions et by system; sup_di",MatchSource.WIKI,docs/4.2/modules/qutip/nonmarkov/heom.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/nonmarkov/heom.html
https://qutip.org/docs/4.2/modules/qutip/nonmarkov/heom.html:9444,Modifiability,config,configure,9444,"f progress_bar is None:; self.progress_bar = BaseProgressBar(); elif progress_bar == True:; self.progress_bar = TextProgressBar(). # the other attributes will be set in the configure method; self.configure(H_sys, coup_op, coup_strength, temperature,; N_cut, N_exp, cut_freq, planck=planck, boltzmann=boltzmann,; renorm=renorm, bnd_cut_approx=bnd_cut_approx, stats=stats). [docs] def reset(self):; """"""; Reset any attributes to default values; """"""; HEOMSolver.reset(self); self.cut_freq = 1.0; self.renorm = False; self.bnd_cut_approx = False. [docs] def configure(self, H_sys, coup_op, coup_strength, temperature,; N_cut, N_exp, cut_freq, planck=None, boltzmann=None,; renorm=None, bnd_cut_approx=None,; options=None, progress_bar=None, stats=None):; """"""; Calls configure from :class:`HEOMSolver` and sets any attributes; that are specific to this subclass; """"""; start_config = timeit.default_timer(). HEOMSolver.configure(self, H_sys, coup_op, coup_strength,; temperature, N_cut, N_exp,; planck=planck, boltzmann=boltzmann,; options=options, progress_bar=progress_bar, stats=stats); self.cut_freq = cut_freq; if renorm is not None: self.renorm = renorm; if bnd_cut_approx is not None: self.bnd_cut_approx = bnd_cut_approx. # Load local values for optional parameters; # Constants and Hamiltonian.; hbar = self.planck; options = self.options; progress_bar = self.progress_bar; stats = self.stats. if stats:; ss_conf = stats.sections.get('config'); if ss_conf is None:; ss_conf = stats.add_section('config'). c, nu = self._calc_matsubara_params(). if renorm:; norm_plus, norm_minus = self._calc_renorm_factors(); if stats:; stats.add_message('options', 'renormalisation', ss_conf); # Dimensions et by system; sup_dim = H_sys.dims[0][0]**2; unit_sys = qeye(H_sys.dims[0]). # Use shorthands (mainly as in referenced PRL); lam0 = self.coup_strength; gam = self.cut_freq; N_c = self.N_cut; N_m = self.N_exp; Q = coup_op # Q as shorthand for coupling operator; beta = 1.0/(self.boltzmann*self.temperature). ",MatchSource.WIKI,docs/4.2/modules/qutip/nonmarkov/heom.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/nonmarkov/heom.html
https://qutip.org/docs/4.2/modules/qutip/nonmarkov/heom.html:9969,Modifiability,config,config,9969,"reset(self); self.cut_freq = 1.0; self.renorm = False; self.bnd_cut_approx = False. [docs] def configure(self, H_sys, coup_op, coup_strength, temperature,; N_cut, N_exp, cut_freq, planck=None, boltzmann=None,; renorm=None, bnd_cut_approx=None,; options=None, progress_bar=None, stats=None):; """"""; Calls configure from :class:`HEOMSolver` and sets any attributes; that are specific to this subclass; """"""; start_config = timeit.default_timer(). HEOMSolver.configure(self, H_sys, coup_op, coup_strength,; temperature, N_cut, N_exp,; planck=planck, boltzmann=boltzmann,; options=options, progress_bar=progress_bar, stats=stats); self.cut_freq = cut_freq; if renorm is not None: self.renorm = renorm; if bnd_cut_approx is not None: self.bnd_cut_approx = bnd_cut_approx. # Load local values for optional parameters; # Constants and Hamiltonian.; hbar = self.planck; options = self.options; progress_bar = self.progress_bar; stats = self.stats. if stats:; ss_conf = stats.sections.get('config'); if ss_conf is None:; ss_conf = stats.add_section('config'). c, nu = self._calc_matsubara_params(). if renorm:; norm_plus, norm_minus = self._calc_renorm_factors(); if stats:; stats.add_message('options', 'renormalisation', ss_conf); # Dimensions et by system; sup_dim = H_sys.dims[0][0]**2; unit_sys = qeye(H_sys.dims[0]). # Use shorthands (mainly as in referenced PRL); lam0 = self.coup_strength; gam = self.cut_freq; N_c = self.N_cut; N_m = self.N_exp; Q = coup_op # Q as shorthand for coupling operator; beta = 1.0/(self.boltzmann*self.temperature). # Ntot is the total number of ancillary elements in the hierarchy; # Ntot = factorial(N_c + N_m) / (factorial(N_c)*factorial(N_m)); # Turns out to be the same as nstates from state_number_enumerate; N_he, he2idx, idx2he = enr_state_dictionaries([N_c + 1]*N_m , N_c). unit_helems = fast_identity(N_he); if self.bnd_cut_approx:; # the Tanimura boundary cut off operator; if stats:; stats.add_message('options', 'boundary cutoff approx', ss_conf); op = -2*spre(",MatchSource.WIKI,docs/4.2/modules/qutip/nonmarkov/heom.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/nonmarkov/heom.html
https://qutip.org/docs/4.2/modules/qutip/nonmarkov/heom.html:10029,Modifiability,config,config,10029,"f.renorm = False; self.bnd_cut_approx = False. [docs] def configure(self, H_sys, coup_op, coup_strength, temperature,; N_cut, N_exp, cut_freq, planck=None, boltzmann=None,; renorm=None, bnd_cut_approx=None,; options=None, progress_bar=None, stats=None):; """"""; Calls configure from :class:`HEOMSolver` and sets any attributes; that are specific to this subclass; """"""; start_config = timeit.default_timer(). HEOMSolver.configure(self, H_sys, coup_op, coup_strength,; temperature, N_cut, N_exp,; planck=planck, boltzmann=boltzmann,; options=options, progress_bar=progress_bar, stats=stats); self.cut_freq = cut_freq; if renorm is not None: self.renorm = renorm; if bnd_cut_approx is not None: self.bnd_cut_approx = bnd_cut_approx. # Load local values for optional parameters; # Constants and Hamiltonian.; hbar = self.planck; options = self.options; progress_bar = self.progress_bar; stats = self.stats. if stats:; ss_conf = stats.sections.get('config'); if ss_conf is None:; ss_conf = stats.add_section('config'). c, nu = self._calc_matsubara_params(). if renorm:; norm_plus, norm_minus = self._calc_renorm_factors(); if stats:; stats.add_message('options', 'renormalisation', ss_conf); # Dimensions et by system; sup_dim = H_sys.dims[0][0]**2; unit_sys = qeye(H_sys.dims[0]). # Use shorthands (mainly as in referenced PRL); lam0 = self.coup_strength; gam = self.cut_freq; N_c = self.N_cut; N_m = self.N_exp; Q = coup_op # Q as shorthand for coupling operator; beta = 1.0/(self.boltzmann*self.temperature). # Ntot is the total number of ancillary elements in the hierarchy; # Ntot = factorial(N_c + N_m) / (factorial(N_c)*factorial(N_m)); # Turns out to be the same as nstates from state_number_enumerate; N_he, he2idx, idx2he = enr_state_dictionaries([N_c + 1]*N_m , N_c). unit_helems = fast_identity(N_he); if self.bnd_cut_approx:; # the Tanimura boundary cut off operator; if stats:; stats.add_message('options', 'boundary cutoff approx', ss_conf); op = -2*spre(Q)*spost(Q.dag()) + spre(Q.dag()*Q) +",MatchSource.WIKI,docs/4.2/modules/qutip/nonmarkov/heom.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/nonmarkov/heom.html
https://qutip.org/docs/4.2/modules/qutip/nonmarkov/heom.html:10467,Modifiability,coupling,coupling,10467,"_sys, coup_op, coup_strength,; temperature, N_cut, N_exp,; planck=planck, boltzmann=boltzmann,; options=options, progress_bar=progress_bar, stats=stats); self.cut_freq = cut_freq; if renorm is not None: self.renorm = renorm; if bnd_cut_approx is not None: self.bnd_cut_approx = bnd_cut_approx. # Load local values for optional parameters; # Constants and Hamiltonian.; hbar = self.planck; options = self.options; progress_bar = self.progress_bar; stats = self.stats. if stats:; ss_conf = stats.sections.get('config'); if ss_conf is None:; ss_conf = stats.add_section('config'). c, nu = self._calc_matsubara_params(). if renorm:; norm_plus, norm_minus = self._calc_renorm_factors(); if stats:; stats.add_message('options', 'renormalisation', ss_conf); # Dimensions et by system; sup_dim = H_sys.dims[0][0]**2; unit_sys = qeye(H_sys.dims[0]). # Use shorthands (mainly as in referenced PRL); lam0 = self.coup_strength; gam = self.cut_freq; N_c = self.N_cut; N_m = self.N_exp; Q = coup_op # Q as shorthand for coupling operator; beta = 1.0/(self.boltzmann*self.temperature). # Ntot is the total number of ancillary elements in the hierarchy; # Ntot = factorial(N_c + N_m) / (factorial(N_c)*factorial(N_m)); # Turns out to be the same as nstates from state_number_enumerate; N_he, he2idx, idx2he = enr_state_dictionaries([N_c + 1]*N_m , N_c). unit_helems = fast_identity(N_he); if self.bnd_cut_approx:; # the Tanimura boundary cut off operator; if stats:; stats.add_message('options', 'boundary cutoff approx', ss_conf); op = -2*spre(Q)*spost(Q.dag()) + spre(Q.dag()*Q) + spost(Q.dag()*Q). approx_factr = ((2*lam0 / (beta*gam*hbar)) - 1j*lam0) / hbar; for k in range(N_m):; approx_factr -= (c[k] / nu[k]); L_bnd = -approx_factr*op.data; L_helems = zcsr_kron(unit_helems, L_bnd); else:; L_helems = fast_csr_matrix(shape=(N_he*sup_dim, N_he*sup_dim)). # Build the hierarchy element interaction matrix; if stats: start_helem_constr = timeit.default_timer(). unit_sup = spre(unit_sys).data; spreQ = spre(Q).da",MatchSource.WIKI,docs/4.2/modules/qutip/nonmarkov/heom.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/nonmarkov/heom.html
https://qutip.org/docs/4.2/modules/qutip/nonmarkov/heom.html:14244,Modifiability,evolve,evolves,14244,"contruct',; timeit.default_timer() - start_louvillian,; ss_conf). if stats: start_integ_conf = timeit.default_timer(). r = scipy.integrate.ode(cy_ode_rhs). r.set_f_params(L_helems.data, L_helems.indices, L_helems.indptr); r.set_integrator('zvode', method=options.method, order=options.order,; atol=options.atol, rtol=options.rtol,; nsteps=options.nsteps, first_step=options.first_step,; min_step=options.min_step, max_step=options.max_step). if stats:; time_now = timeit.default_timer(); stats.add_timing('Liouvillian contruct',; time_now - start_integ_conf,; ss_conf); if ss_conf.total_time is None:; ss_conf.total_time = time_now - start_config; else:; ss_conf.total_time += time_now - start_config. self._ode = r; self._N_he = N_he; self._sup_dim = sup_dim; self._configured = True. [docs] def run(self, rho0, tlist):; """"""; Function to solve for an open quantum system using the; HEOM model. Parameters; ----------; rho0 : Qobj; Initial state (density matrix) of the system. tlist : list; Time over which system evolves. Returns; -------; results : :class:`qutip.solver.Result`; Object storing all results from the simulation.; """""". start_run = timeit.default_timer(). sup_dim = self._sup_dim; stats = self.stats; r = self._ode. if not self._configured:; raise RuntimeError(""Solver must be configured before it is run""); if stats:; ss_conf = stats.sections.get('config'); if ss_conf is None:; raise RuntimeError(""No config section for solver stats""); ss_run = stats.sections.get('run'); if ss_run is None:; ss_run = stats.add_section('run'). # Set up terms of the matsubara and tanimura boundaries; output = Result(); output.solver = ""hsolve""; output.times = tlist; output.states = []. if stats: start_init = timeit.default_timer(); output.states.append(Qobj(rho0)); rho0_flat = rho0.full().ravel('F') # Using 'F' effectively transposes; rho0_he = np.zeros([sup_dim*self._N_he], dtype=complex); rho0_he[:sup_dim] = rho0_flat; r.set_initial_value(rho0_he, tlist[0]). if stats:; stats.add_timing('in",MatchSource.WIKI,docs/4.2/modules/qutip/nonmarkov/heom.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/nonmarkov/heom.html
https://qutip.org/docs/4.2/modules/qutip/nonmarkov/heom.html:14522,Modifiability,config,configured,14522,"=options.atol, rtol=options.rtol,; nsteps=options.nsteps, first_step=options.first_step,; min_step=options.min_step, max_step=options.max_step). if stats:; time_now = timeit.default_timer(); stats.add_timing('Liouvillian contruct',; time_now - start_integ_conf,; ss_conf); if ss_conf.total_time is None:; ss_conf.total_time = time_now - start_config; else:; ss_conf.total_time += time_now - start_config. self._ode = r; self._N_he = N_he; self._sup_dim = sup_dim; self._configured = True. [docs] def run(self, rho0, tlist):; """"""; Function to solve for an open quantum system using the; HEOM model. Parameters; ----------; rho0 : Qobj; Initial state (density matrix) of the system. tlist : list; Time over which system evolves. Returns; -------; results : :class:`qutip.solver.Result`; Object storing all results from the simulation.; """""". start_run = timeit.default_timer(). sup_dim = self._sup_dim; stats = self.stats; r = self._ode. if not self._configured:; raise RuntimeError(""Solver must be configured before it is run""); if stats:; ss_conf = stats.sections.get('config'); if ss_conf is None:; raise RuntimeError(""No config section for solver stats""); ss_run = stats.sections.get('run'); if ss_run is None:; ss_run = stats.add_section('run'). # Set up terms of the matsubara and tanimura boundaries; output = Result(); output.solver = ""hsolve""; output.times = tlist; output.states = []. if stats: start_init = timeit.default_timer(); output.states.append(Qobj(rho0)); rho0_flat = rho0.full().ravel('F') # Using 'F' effectively transposes; rho0_he = np.zeros([sup_dim*self._N_he], dtype=complex); rho0_he[:sup_dim] = rho0_flat; r.set_initial_value(rho0_he, tlist[0]). if stats:; stats.add_timing('initialize',; timeit.default_timer() - start_init, ss_run); start_integ = timeit.default_timer(). dt = np.diff(tlist); n_tsteps = len(tlist); for t_idx, t in enumerate(tlist):; if t_idx < n_tsteps - 1:; r.integrate(r.t + dt[t_idx]); rho = Qobj(r.y[:sup_dim].reshape(rho0.shape), dims=rho0.dims); outp",MatchSource.WIKI,docs/4.2/modules/qutip/nonmarkov/heom.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/nonmarkov/heom.html
https://qutip.org/docs/4.2/modules/qutip/nonmarkov/heom.html:14594,Modifiability,config,config,14594,"max_step=options.max_step). if stats:; time_now = timeit.default_timer(); stats.add_timing('Liouvillian contruct',; time_now - start_integ_conf,; ss_conf); if ss_conf.total_time is None:; ss_conf.total_time = time_now - start_config; else:; ss_conf.total_time += time_now - start_config. self._ode = r; self._N_he = N_he; self._sup_dim = sup_dim; self._configured = True. [docs] def run(self, rho0, tlist):; """"""; Function to solve for an open quantum system using the; HEOM model. Parameters; ----------; rho0 : Qobj; Initial state (density matrix) of the system. tlist : list; Time over which system evolves. Returns; -------; results : :class:`qutip.solver.Result`; Object storing all results from the simulation.; """""". start_run = timeit.default_timer(). sup_dim = self._sup_dim; stats = self.stats; r = self._ode. if not self._configured:; raise RuntimeError(""Solver must be configured before it is run""); if stats:; ss_conf = stats.sections.get('config'); if ss_conf is None:; raise RuntimeError(""No config section for solver stats""); ss_run = stats.sections.get('run'); if ss_run is None:; ss_run = stats.add_section('run'). # Set up terms of the matsubara and tanimura boundaries; output = Result(); output.solver = ""hsolve""; output.times = tlist; output.states = []. if stats: start_init = timeit.default_timer(); output.states.append(Qobj(rho0)); rho0_flat = rho0.full().ravel('F') # Using 'F' effectively transposes; rho0_he = np.zeros([sup_dim*self._N_he], dtype=complex); rho0_he[:sup_dim] = rho0_flat; r.set_initial_value(rho0_he, tlist[0]). if stats:; stats.add_timing('initialize',; timeit.default_timer() - start_init, ss_run); start_integ = timeit.default_timer(). dt = np.diff(tlist); n_tsteps = len(tlist); for t_idx, t in enumerate(tlist):; if t_idx < n_tsteps - 1:; r.integrate(r.t + dt[t_idx]); rho = Qobj(r.y[:sup_dim].reshape(rho0.shape), dims=rho0.dims); output.states.append(rho). if stats:; time_now = timeit.default_timer(); stats.add_timing('integrate',; time_now - start_",MatchSource.WIKI,docs/4.2/modules/qutip/nonmarkov/heom.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/nonmarkov/heom.html
https://qutip.org/docs/4.2/modules/qutip/nonmarkov/heom.html:14648,Modifiability,config,config,14648,"max_step=options.max_step). if stats:; time_now = timeit.default_timer(); stats.add_timing('Liouvillian contruct',; time_now - start_integ_conf,; ss_conf); if ss_conf.total_time is None:; ss_conf.total_time = time_now - start_config; else:; ss_conf.total_time += time_now - start_config. self._ode = r; self._N_he = N_he; self._sup_dim = sup_dim; self._configured = True. [docs] def run(self, rho0, tlist):; """"""; Function to solve for an open quantum system using the; HEOM model. Parameters; ----------; rho0 : Qobj; Initial state (density matrix) of the system. tlist : list; Time over which system evolves. Returns; -------; results : :class:`qutip.solver.Result`; Object storing all results from the simulation.; """""". start_run = timeit.default_timer(). sup_dim = self._sup_dim; stats = self.stats; r = self._ode. if not self._configured:; raise RuntimeError(""Solver must be configured before it is run""); if stats:; ss_conf = stats.sections.get('config'); if ss_conf is None:; raise RuntimeError(""No config section for solver stats""); ss_run = stats.sections.get('run'); if ss_run is None:; ss_run = stats.add_section('run'). # Set up terms of the matsubara and tanimura boundaries; output = Result(); output.solver = ""hsolve""; output.times = tlist; output.states = []. if stats: start_init = timeit.default_timer(); output.states.append(Qobj(rho0)); rho0_flat = rho0.full().ravel('F') # Using 'F' effectively transposes; rho0_he = np.zeros([sup_dim*self._N_he], dtype=complex); rho0_he[:sup_dim] = rho0_flat; r.set_initial_value(rho0_he, tlist[0]). if stats:; stats.add_timing('initialize',; timeit.default_timer() - start_init, ss_run); start_integ = timeit.default_timer(). dt = np.diff(tlist); n_tsteps = len(tlist); for t_idx, t in enumerate(tlist):; if t_idx < n_tsteps - 1:; r.integrate(r.t + dt[t_idx]); rho = Qobj(r.y[:sup_dim].reshape(rho0.shape), dims=rho0.dims); output.states.append(rho). if stats:; time_now = timeit.default_timer(); stats.add_timing('integrate',; time_now - start_",MatchSource.WIKI,docs/4.2/modules/qutip/nonmarkov/heom.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/nonmarkov/heom.html
https://qutip.org/docs/4.2/modules/qutip/nonmarkov/heom.html:3872,Performance,perform,performance,3872,"n; from qutip.fastsparse import fast_csr_matrix, fast_identity. [docs]class HEOMSolver(object):; """"""; This is superclass for all solvers that use the HEOM method for; calculating the dynamics evolution. There are many references for this.; A good introduction, and perhaps closest to the notation used here is:; DOI:10.1103/PhysRevLett.104.250401; A more canonical reference, with full derivation is:; DOI: 10.1103/PhysRevA.41.6676; The method can compute open system dynamics without using any Markovian; or rotating wave approximation (RWA) for systems where the bath; correlations can be approximated to a sum of complex eponentials.; The method builds a matrix of linked differential equations, which are; then solved used the same ODE solvers as other qutip solvers (e.g. mesolve). This class should be treated as abstract. Currently the only subclass; implemented is that for the Drude-Lorentz spectral density. This covers; the majority of the work that has been done using this model, and there; are some performance advantages to assuming this model where it is; appropriate. There are opportunities to develop a more general spectral density code. Attributes; ----------; H_sys : Qobj; System Hamiltonian. coup_op : Qobj; Operator describing the coupling between system and bath. coup_strength : float; Coupling strength. temperature : float; Bath temperature, in units corresponding to planck. N_cut : int; Cutoff parameter for the bath. N_exp : int; Number of exponential terms used to approximate the bath correlation; functions. planck : float; reduced Planck constant. boltzmann : float; Boltzmann's constant. options : :class:`qutip.solver.Options`; Generic solver options.; If set to None the default options will be used. progress_bar: BaseProgressBar; Optional instance of BaseProgressBar, or a subclass thereof, for; showing the progress of the simulation. stats : :class:`qutip.solver.Stats`; optional container for holding performance statitics; If None is set, then statistics a",MatchSource.WIKI,docs/4.2/modules/qutip/nonmarkov/heom.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/nonmarkov/heom.html
https://qutip.org/docs/4.2/modules/qutip/nonmarkov/heom.html:4804,Performance,perform,performance,4804,"odel, and there; are some performance advantages to assuming this model where it is; appropriate. There are opportunities to develop a more general spectral density code. Attributes; ----------; H_sys : Qobj; System Hamiltonian. coup_op : Qobj; Operator describing the coupling between system and bath. coup_strength : float; Coupling strength. temperature : float; Bath temperature, in units corresponding to planck. N_cut : int; Cutoff parameter for the bath. N_exp : int; Number of exponential terms used to approximate the bath correlation; functions. planck : float; reduced Planck constant. boltzmann : float; Boltzmann's constant. options : :class:`qutip.solver.Options`; Generic solver options.; If set to None the default options will be used. progress_bar: BaseProgressBar; Optional instance of BaseProgressBar, or a subclass thereof, for; showing the progress of the simulation. stats : :class:`qutip.solver.Stats`; optional container for holding performance statitics; If None is set, then statistics are not collected; There may be an overhead in collecting statistics. exp_coeff : list of complex; Coefficients for the exponential series terms. exp_freq : list of complex; Frequencies for the exponential series terms; """"""; def __init__(self):; raise NotImplementedError(""This is a abstract class only. ""; ""Use a subclass, for example HSolverDL""). [docs] def reset(self):; """"""; Reset any attributes to default values; """"""; self.planck = 1.0; self.boltzmann = 1.0; self.H_sys = None; self.coup_op = None; self.coup_strength = 0.0; self.temperature = 1.0; self.N_cut = 10; self.N_exp = 2; self.N_he = 0. self.exp_coeff = None; self.exp_freq = None. self.options = None; self.progress_bar = None; self.stats = None. self.ode = None; self.configured = False. [docs] def configure(self, H_sys, coup_op, coup_strength, temperature,; N_cut, N_exp, planck=None, boltzmann=None,; renorm=None, bnd_cut_approx=None,; options=None, progress_bar=None, stats=None):; """"""; Configure the solver using th",MatchSource.WIKI,docs/4.2/modules/qutip/nonmarkov/heom.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/nonmarkov/heom.html
https://qutip.org/docs/4.2/modules/qutip/nonmarkov/heom.html:6442,Performance,perform,performance,6442,".exp_freq = None. self.options = None; self.progress_bar = None; self.stats = None. self.ode = None; self.configured = False. [docs] def configure(self, H_sys, coup_op, coup_strength, temperature,; N_cut, N_exp, planck=None, boltzmann=None,; renorm=None, bnd_cut_approx=None,; options=None, progress_bar=None, stats=None):; """"""; Configure the solver using the passed parameters; The parameters are described in the class attributes, unless there; is some specific behaviour. Parameters; ----------; options : :class:`qutip.solver.Options`; Generic solver options.; If set to None the default options will be used. progress_bar: BaseProgressBar; Optional instance of BaseProgressBar, or a subclass thereof, for; showing the progress of the simulation.; If set to None, then the default progress bar will be used; Set to False for no progress bar. stats: :class:`qutip.solver.Stats`; Optional instance of solver.Stats, or a subclass thereof, for; storing performance statistics for the solver; If set to True, then the default Stats for this class will be used; Set to False for no stats; """""". self.H_sys = H_sys; self.coup_op = coup_op; self.coup_strength = coup_strength; self.temperature = temperature; self.N_cut = N_cut; self.N_exp = N_exp; if planck: self.planck = planck; if boltzmann: self.boltzmann = boltzmann; if isinstance(options, Options): self.options = options; if isinstance(progress_bar, BaseProgressBar):; self.progress_bar = progress_bar; elif progress_bar == True:; self.progress_bar = TextProgressBar(); elif progress_bar == False:; self.progress_bar = None; if isinstance(stats, Stats):; self.stats = stats; elif stats == True:; self.stats = self.create_new_stats(); elif stats == False:; self.stats = None. [docs] def create_new_stats(self):; """"""; Creates a new stats object suitable for use with this solver; Note: this solver expects the stats object to have sections; config; integrate; """"""; stats = Stats(['config', 'run']); stats.header = ""Hierarchy Solver Stats""; return st",MatchSource.WIKI,docs/4.2/modules/qutip/nonmarkov/heom.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/nonmarkov/heom.html
https://qutip.org/docs/4.2/modules/qutip/nonmarkov/heom.html:6274,Usability,progress bar,progress bar,6274,"f.planck = 1.0; self.boltzmann = 1.0; self.H_sys = None; self.coup_op = None; self.coup_strength = 0.0; self.temperature = 1.0; self.N_cut = 10; self.N_exp = 2; self.N_he = 0. self.exp_coeff = None; self.exp_freq = None. self.options = None; self.progress_bar = None; self.stats = None. self.ode = None; self.configured = False. [docs] def configure(self, H_sys, coup_op, coup_strength, temperature,; N_cut, N_exp, planck=None, boltzmann=None,; renorm=None, bnd_cut_approx=None,; options=None, progress_bar=None, stats=None):; """"""; Configure the solver using the passed parameters; The parameters are described in the class attributes, unless there; is some specific behaviour. Parameters; ----------; options : :class:`qutip.solver.Options`; Generic solver options.; If set to None the default options will be used. progress_bar: BaseProgressBar; Optional instance of BaseProgressBar, or a subclass thereof, for; showing the progress of the simulation.; If set to None, then the default progress bar will be used; Set to False for no progress bar. stats: :class:`qutip.solver.Stats`; Optional instance of solver.Stats, or a subclass thereof, for; storing performance statistics for the solver; If set to True, then the default Stats for this class will be used; Set to False for no stats; """""". self.H_sys = H_sys; self.coup_op = coup_op; self.coup_strength = coup_strength; self.temperature = temperature; self.N_cut = N_cut; self.N_exp = N_exp; if planck: self.planck = planck; if boltzmann: self.boltzmann = boltzmann; if isinstance(options, Options): self.options = options; if isinstance(progress_bar, BaseProgressBar):; self.progress_bar = progress_bar; elif progress_bar == True:; self.progress_bar = TextProgressBar(); elif progress_bar == False:; self.progress_bar = None; if isinstance(stats, Stats):; self.stats = stats; elif stats == True:; self.stats = self.create_new_stats(); elif stats == False:; self.stats = None. [docs] def create_new_stats(self):; """"""; Creates a new stats object s",MatchSource.WIKI,docs/4.2/modules/qutip/nonmarkov/heom.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/nonmarkov/heom.html
https://qutip.org/docs/4.2/modules/qutip/nonmarkov/heom.html:6321,Usability,progress bar,progress bar,6321,"f.planck = 1.0; self.boltzmann = 1.0; self.H_sys = None; self.coup_op = None; self.coup_strength = 0.0; self.temperature = 1.0; self.N_cut = 10; self.N_exp = 2; self.N_he = 0. self.exp_coeff = None; self.exp_freq = None. self.options = None; self.progress_bar = None; self.stats = None. self.ode = None; self.configured = False. [docs] def configure(self, H_sys, coup_op, coup_strength, temperature,; N_cut, N_exp, planck=None, boltzmann=None,; renorm=None, bnd_cut_approx=None,; options=None, progress_bar=None, stats=None):; """"""; Configure the solver using the passed parameters; The parameters are described in the class attributes, unless there; is some specific behaviour. Parameters; ----------; options : :class:`qutip.solver.Options`; Generic solver options.; If set to None the default options will be used. progress_bar: BaseProgressBar; Optional instance of BaseProgressBar, or a subclass thereof, for; showing the progress of the simulation.; If set to None, then the default progress bar will be used; Set to False for no progress bar. stats: :class:`qutip.solver.Stats`; Optional instance of solver.Stats, or a subclass thereof, for; storing performance statistics for the solver; If set to True, then the default Stats for this class will be used; Set to False for no stats; """""". self.H_sys = H_sys; self.coup_op = coup_op; self.coup_strength = coup_strength; self.temperature = temperature; self.N_cut = N_cut; self.N_exp = N_exp; if planck: self.planck = planck; if boltzmann: self.boltzmann = boltzmann; if isinstance(options, Options): self.options = options; if isinstance(progress_bar, BaseProgressBar):; self.progress_bar = progress_bar; elif progress_bar == True:; self.progress_bar = TextProgressBar(); elif progress_bar == False:; self.progress_bar = None; if isinstance(stats, Stats):; self.stats = stats; elif stats == True:; self.stats = self.create_new_stats(); elif stats == False:; self.stats = None. [docs] def create_new_stats(self):; """"""; Creates a new stats object s",MatchSource.WIKI,docs/4.2/modules/qutip/nonmarkov/heom.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/nonmarkov/heom.html
https://qutip.org/docs/4.2/modules/qutip/nonmarkov/heom.html:17361,Usability,simpl,simple,17361,"c_renorm_factors(self):; """"""; Calculate the renormalisation factors. Returns; -------; norm_plus, norm_minus : array[N_c, N_m] of float; """"""; c = self.exp_coeff; N_m = self.N_exp; N_c = self.N_cut. norm_plus = np.empty((N_c+1, N_m)); norm_minus = np.empty((N_c+1, N_m)); for k in range(N_m):; for n in range(N_c+1):; norm_plus[n, k] = np.sqrt(abs(c[k])*(n + 1)); norm_minus[n, k] = np.sqrt(float(n)/abs(c[k])). return norm_plus, norm_minus. def _pad_csr(A, row_scale, col_scale, insertrow=0, insertcol=0):; """"""; Expand the input csr_matrix to a greater space as given by the scale.; Effectively inserting A into a larger matrix; zeros([A.shape[0]*row_scale, A.shape[1]*col_scale]; at the position [A.shape[0]*insertrow, A.shape[1]*insertcol]; The same could be achieved through using a kron with a matrix with; one element set to 1. However, this is more efficient; """""". # ajgpitch 2016-03-08:; # Clearly this is a very simple operation in dense matrices; # It seems strange that there is nothing equivalent in sparse however,; # after much searching most threads suggest directly addressing; # the underlying arrays, as done here.; # This certainly proved more efficient than other methods such as stacking; #TODO: Perhaps cythonize and move to spmatfuncs. if not isinstance(A, sp.csr_matrix):; raise TypeError(""First parameter must be a csr matrix""); nrowin = A.shape[0]; ncolin = A.shape[1]; nrowout = nrowin*row_scale; ncolout = ncolin*col_scale. A._shape = (nrowout, ncolout); if insertcol == 0:; pass; elif insertcol > 0 and insertcol < col_scale:; A.indices = A.indices + insertcol*ncolin; else:; raise ValueError(""insertcol must be >= 0 and < col_scale""). if insertrow == 0:; A.indptr = np.concatenate((A.indptr,; np.array([A.indptr[-1]]*(row_scale-1)*nrowin))); elif insertrow == row_scale-1:; A.indptr = np.concatenate((np.array([0]*(row_scale - 1)*nrowin),; A.indptr)); elif insertrow > 0 and insertrow < row_scale - 1:; A.indptr = np.concatenate((np.array([0]*insertrow*nrowin), A.indptr,;",MatchSource.WIKI,docs/4.2/modules/qutip/nonmarkov/heom.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/nonmarkov/heom.html
https://qutip.org/docs/4.2/modules/qutip/nonmarkov/memorycascade.html:3543,Deployability,integrat,integrator,3543,"s MemoryCascade:; """"""Class for running memory cascade simulations of open quantum systems; with time-delayed coherent feedback. Attributes; ----------; H_S : :class:`qutip.Qobj`; System Hamiltonian (can also be a Liouvillian). L1 : :class:`qutip.Qobj` / list of :class:`qutip.Qobj`; System operators coupling into the feedback loop. Can be a single; operator or a list of operators. L2 : :class:`qutip.Qobj` / list of :class:`qutip.Qobj`; System operators coupling out of the feedback loop. Can be a single; operator or a list of operators. L2 must have the same length as L1. S_matrix: *array*; S matrix describing which operators in L1 are coupled to which; operators in L2 by the feedback channel. Defaults to an n by n identity; matrix where n is the number of elements in L1/L2. c_ops_markov : :class:`qutip.Qobj` / list of :class:`qutip.Qobj`; Decay operators describing conventional Markovian decay channels.; Can be a single operator or a list of operators. integrator : str {'propagator', 'mesolve'}; Integrator method to use. Defaults to 'propagator' which tends to be ; faster for long times (i.e., large Hilbert space). parallel : bool; Run integrator in parallel if True. Only implemented for 'propagator'; as the integrator method. options : :class:`qutip.solver.Options`; Generic solver options.; """""". def __init__(self, H_S, L1, L2, S_matrix=None, c_ops_markov=None,; integrator='propagator', parallel=False, options=None):. if options is None:; self.options = qt.Options(); else:; self.options = options. self.H_S = H_S; self.sysdims = H_S.dims; if isinstance(L1, qt.Qobj):; self.L1 = [L1]; else:; self.L1 = L1; if isinstance(L2, qt.Qobj):; self.L2 = [L2]; else:; self.L2 = L2; if not len(self.L1) == len(self.L2):; raise ValueError('L1 and L2 has to be of equal length.'); if isinstance(c_ops_markov, qt.Qobj):; self.c_ops_markov = [c_ops_markov]; else:; self.c_ops_markov = c_ops_markov. if S_matrix is None:; self.S_matrix = np.identity(len(self.L1)); else:; self.S_matrix = S_mat",MatchSource.WIKI,docs/4.2/modules/qutip/nonmarkov/memorycascade.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/nonmarkov/memorycascade.html
https://qutip.org/docs/4.2/modules/qutip/nonmarkov/memorycascade.html:3730,Deployability,integrat,integrator,3730," :class:`qutip.Qobj`; System Hamiltonian (can also be a Liouvillian). L1 : :class:`qutip.Qobj` / list of :class:`qutip.Qobj`; System operators coupling into the feedback loop. Can be a single; operator or a list of operators. L2 : :class:`qutip.Qobj` / list of :class:`qutip.Qobj`; System operators coupling out of the feedback loop. Can be a single; operator or a list of operators. L2 must have the same length as L1. S_matrix: *array*; S matrix describing which operators in L1 are coupled to which; operators in L2 by the feedback channel. Defaults to an n by n identity; matrix where n is the number of elements in L1/L2. c_ops_markov : :class:`qutip.Qobj` / list of :class:`qutip.Qobj`; Decay operators describing conventional Markovian decay channels.; Can be a single operator or a list of operators. integrator : str {'propagator', 'mesolve'}; Integrator method to use. Defaults to 'propagator' which tends to be ; faster for long times (i.e., large Hilbert space). parallel : bool; Run integrator in parallel if True. Only implemented for 'propagator'; as the integrator method. options : :class:`qutip.solver.Options`; Generic solver options.; """""". def __init__(self, H_S, L1, L2, S_matrix=None, c_ops_markov=None,; integrator='propagator', parallel=False, options=None):. if options is None:; self.options = qt.Options(); else:; self.options = options. self.H_S = H_S; self.sysdims = H_S.dims; if isinstance(L1, qt.Qobj):; self.L1 = [L1]; else:; self.L1 = L1; if isinstance(L2, qt.Qobj):; self.L2 = [L2]; else:; self.L2 = L2; if not len(self.L1) == len(self.L2):; raise ValueError('L1 and L2 has to be of equal length.'); if isinstance(c_ops_markov, qt.Qobj):; self.c_ops_markov = [c_ops_markov]; else:; self.c_ops_markov = c_ops_markov. if S_matrix is None:; self.S_matrix = np.identity(len(self.L1)); else:; self.S_matrix = S_matrix; # create system identity superoperator; self.Id = qt.qeye(H_S.shape[0]); self.Id.dims = self.sysdims; self.Id = qt.sprepost(self.Id, self.Id); self.store",MatchSource.WIKI,docs/4.2/modules/qutip/nonmarkov/memorycascade.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/nonmarkov/memorycascade.html
https://qutip.org/docs/4.2/modules/qutip/nonmarkov/memorycascade.html:3804,Deployability,integrat,integrator,3804,"iouvillian). L1 : :class:`qutip.Qobj` / list of :class:`qutip.Qobj`; System operators coupling into the feedback loop. Can be a single; operator or a list of operators. L2 : :class:`qutip.Qobj` / list of :class:`qutip.Qobj`; System operators coupling out of the feedback loop. Can be a single; operator or a list of operators. L2 must have the same length as L1. S_matrix: *array*; S matrix describing which operators in L1 are coupled to which; operators in L2 by the feedback channel. Defaults to an n by n identity; matrix where n is the number of elements in L1/L2. c_ops_markov : :class:`qutip.Qobj` / list of :class:`qutip.Qobj`; Decay operators describing conventional Markovian decay channels.; Can be a single operator or a list of operators. integrator : str {'propagator', 'mesolve'}; Integrator method to use. Defaults to 'propagator' which tends to be ; faster for long times (i.e., large Hilbert space). parallel : bool; Run integrator in parallel if True. Only implemented for 'propagator'; as the integrator method. options : :class:`qutip.solver.Options`; Generic solver options.; """""". def __init__(self, H_S, L1, L2, S_matrix=None, c_ops_markov=None,; integrator='propagator', parallel=False, options=None):. if options is None:; self.options = qt.Options(); else:; self.options = options. self.H_S = H_S; self.sysdims = H_S.dims; if isinstance(L1, qt.Qobj):; self.L1 = [L1]; else:; self.L1 = L1; if isinstance(L2, qt.Qobj):; self.L2 = [L2]; else:; self.L2 = L2; if not len(self.L1) == len(self.L2):; raise ValueError('L1 and L2 has to be of equal length.'); if isinstance(c_ops_markov, qt.Qobj):; self.c_ops_markov = [c_ops_markov]; else:; self.c_ops_markov = c_ops_markov. if S_matrix is None:; self.S_matrix = np.identity(len(self.L1)); else:; self.S_matrix = S_matrix; # create system identity superoperator; self.Id = qt.qeye(H_S.shape[0]); self.Id.dims = self.sysdims; self.Id = qt.sprepost(self.Id, self.Id); self.store_states = self.options.store_states; self.integrator = in",MatchSource.WIKI,docs/4.2/modules/qutip/nonmarkov/memorycascade.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/nonmarkov/memorycascade.html
https://qutip.org/docs/4.2/modules/qutip/nonmarkov/memorycascade.html:3961,Deployability,integrat,integrator,3961,"ors. L2 : :class:`qutip.Qobj` / list of :class:`qutip.Qobj`; System operators coupling out of the feedback loop. Can be a single; operator or a list of operators. L2 must have the same length as L1. S_matrix: *array*; S matrix describing which operators in L1 are coupled to which; operators in L2 by the feedback channel. Defaults to an n by n identity; matrix where n is the number of elements in L1/L2. c_ops_markov : :class:`qutip.Qobj` / list of :class:`qutip.Qobj`; Decay operators describing conventional Markovian decay channels.; Can be a single operator or a list of operators. integrator : str {'propagator', 'mesolve'}; Integrator method to use. Defaults to 'propagator' which tends to be ; faster for long times (i.e., large Hilbert space). parallel : bool; Run integrator in parallel if True. Only implemented for 'propagator'; as the integrator method. options : :class:`qutip.solver.Options`; Generic solver options.; """""". def __init__(self, H_S, L1, L2, S_matrix=None, c_ops_markov=None,; integrator='propagator', parallel=False, options=None):. if options is None:; self.options = qt.Options(); else:; self.options = options. self.H_S = H_S; self.sysdims = H_S.dims; if isinstance(L1, qt.Qobj):; self.L1 = [L1]; else:; self.L1 = L1; if isinstance(L2, qt.Qobj):; self.L2 = [L2]; else:; self.L2 = L2; if not len(self.L1) == len(self.L2):; raise ValueError('L1 and L2 has to be of equal length.'); if isinstance(c_ops_markov, qt.Qobj):; self.c_ops_markov = [c_ops_markov]; else:; self.c_ops_markov = c_ops_markov. if S_matrix is None:; self.S_matrix = np.identity(len(self.L1)); else:; self.S_matrix = S_matrix; # create system identity superoperator; self.Id = qt.qeye(H_S.shape[0]); self.Id.dims = self.sysdims; self.Id = qt.sprepost(self.Id, self.Id); self.store_states = self.options.store_states; self.integrator = integrator; self.parallel = parallel. [docs] def propagator(self, t, tau, notrace=False):; """"""; Compute propagator for time t and time-delay tau. Parameters; -------",MatchSource.WIKI,docs/4.2/modules/qutip/nonmarkov/memorycascade.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/nonmarkov/memorycascade.html
https://qutip.org/docs/4.2/modules/qutip/nonmarkov/memorycascade.html:4777,Deployability,integrat,integrator,4777,"or'; as the integrator method. options : :class:`qutip.solver.Options`; Generic solver options.; """""". def __init__(self, H_S, L1, L2, S_matrix=None, c_ops_markov=None,; integrator='propagator', parallel=False, options=None):. if options is None:; self.options = qt.Options(); else:; self.options = options. self.H_S = H_S; self.sysdims = H_S.dims; if isinstance(L1, qt.Qobj):; self.L1 = [L1]; else:; self.L1 = L1; if isinstance(L2, qt.Qobj):; self.L2 = [L2]; else:; self.L2 = L2; if not len(self.L1) == len(self.L2):; raise ValueError('L1 and L2 has to be of equal length.'); if isinstance(c_ops_markov, qt.Qobj):; self.c_ops_markov = [c_ops_markov]; else:; self.c_ops_markov = c_ops_markov. if S_matrix is None:; self.S_matrix = np.identity(len(self.L1)); else:; self.S_matrix = S_matrix; # create system identity superoperator; self.Id = qt.qeye(H_S.shape[0]); self.Id.dims = self.sysdims; self.Id = qt.sprepost(self.Id, self.Id); self.store_states = self.options.store_states; self.integrator = integrator; self.parallel = parallel. [docs] def propagator(self, t, tau, notrace=False):; """"""; Compute propagator for time t and time-delay tau. Parameters; ----------; t : *float*; current time. tau : *float*; time-delay. notrace : *bool* {False}; If this optional is set to True, a propagator is returned for a; cascade of k systems, where :math:`(k-1) tau < t < k tau`.; If set to False (default), a generalized partial trace is performed; and a propagator for a single system is returned.; Returns; -------; : :class:`qutip.Qobj`; time-propagator for reduced system dynamics; """"""; k = int(t/tau)+1; s = t-(k-1)*tau; G1, E0 = _generator(k, self.H_S, self.L1, self.L2, self.S_matrix,; self.c_ops_markov); E = _integrate(G1, E0, 0., s, integrator=self.integrator,; parallel=self.parallel, opt=self.options); if k > 1:; G2, null = _generator(k-1, self.H_S, self.L1, self.L2,; self.S_matrix, self.c_ops_markov); G2 = qt.composite(G2, self.Id); E = _integrate(G2, E, s, tau, integrator=self.integrator, ",MatchSource.WIKI,docs/4.2/modules/qutip/nonmarkov/memorycascade.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/nonmarkov/memorycascade.html
https://qutip.org/docs/4.2/modules/qutip/nonmarkov/memorycascade.html:4790,Deployability,integrat,integrator,4790,"or'; as the integrator method. options : :class:`qutip.solver.Options`; Generic solver options.; """""". def __init__(self, H_S, L1, L2, S_matrix=None, c_ops_markov=None,; integrator='propagator', parallel=False, options=None):. if options is None:; self.options = qt.Options(); else:; self.options = options. self.H_S = H_S; self.sysdims = H_S.dims; if isinstance(L1, qt.Qobj):; self.L1 = [L1]; else:; self.L1 = L1; if isinstance(L2, qt.Qobj):; self.L2 = [L2]; else:; self.L2 = L2; if not len(self.L1) == len(self.L2):; raise ValueError('L1 and L2 has to be of equal length.'); if isinstance(c_ops_markov, qt.Qobj):; self.c_ops_markov = [c_ops_markov]; else:; self.c_ops_markov = c_ops_markov. if S_matrix is None:; self.S_matrix = np.identity(len(self.L1)); else:; self.S_matrix = S_matrix; # create system identity superoperator; self.Id = qt.qeye(H_S.shape[0]); self.Id.dims = self.sysdims; self.Id = qt.sprepost(self.Id, self.Id); self.store_states = self.options.store_states; self.integrator = integrator; self.parallel = parallel. [docs] def propagator(self, t, tau, notrace=False):; """"""; Compute propagator for time t and time-delay tau. Parameters; ----------; t : *float*; current time. tau : *float*; time-delay. notrace : *bool* {False}; If this optional is set to True, a propagator is returned for a; cascade of k systems, where :math:`(k-1) tau < t < k tau`.; If set to False (default), a generalized partial trace is performed; and a propagator for a single system is returned.; Returns; -------; : :class:`qutip.Qobj`; time-propagator for reduced system dynamics; """"""; k = int(t/tau)+1; s = t-(k-1)*tau; G1, E0 = _generator(k, self.H_S, self.L1, self.L2, self.S_matrix,; self.c_ops_markov); E = _integrate(G1, E0, 0., s, integrator=self.integrator,; parallel=self.parallel, opt=self.options); if k > 1:; G2, null = _generator(k-1, self.H_S, self.L1, self.L2,; self.S_matrix, self.c_ops_markov); G2 = qt.composite(G2, self.Id); E = _integrate(G2, E, s, tau, integrator=self.integrator, ",MatchSource.WIKI,docs/4.2/modules/qutip/nonmarkov/memorycascade.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/nonmarkov/memorycascade.html
https://qutip.org/docs/4.2/modules/qutip/nonmarkov/memorycascade.html:5528,Deployability,integrat,integrator,5528,"(len(self.L1)); else:; self.S_matrix = S_matrix; # create system identity superoperator; self.Id = qt.qeye(H_S.shape[0]); self.Id.dims = self.sysdims; self.Id = qt.sprepost(self.Id, self.Id); self.store_states = self.options.store_states; self.integrator = integrator; self.parallel = parallel. [docs] def propagator(self, t, tau, notrace=False):; """"""; Compute propagator for time t and time-delay tau. Parameters; ----------; t : *float*; current time. tau : *float*; time-delay. notrace : *bool* {False}; If this optional is set to True, a propagator is returned for a; cascade of k systems, where :math:`(k-1) tau < t < k tau`.; If set to False (default), a generalized partial trace is performed; and a propagator for a single system is returned.; Returns; -------; : :class:`qutip.Qobj`; time-propagator for reduced system dynamics; """"""; k = int(t/tau)+1; s = t-(k-1)*tau; G1, E0 = _generator(k, self.H_S, self.L1, self.L2, self.S_matrix,; self.c_ops_markov); E = _integrate(G1, E0, 0., s, integrator=self.integrator,; parallel=self.parallel, opt=self.options); if k > 1:; G2, null = _generator(k-1, self.H_S, self.L1, self.L2,; self.S_matrix, self.c_ops_markov); G2 = qt.composite(G2, self.Id); E = _integrate(G2, E, s, tau, integrator=self.integrator, ; parallel=self.parallel, opt=self.options); E.dims = E0.dims; if not notrace:; E = _genptrace(E, k); return E. [docs] def outfieldpropagator(self, blist, tlist, tau, c1=None, c2=None,; notrace=False):; """"""; Compute propagator for computing output field expectation values; <O_n(tn)...O_2(t2)O_1(t1)> for times t1,t2,... and; O_i = I, b_out, b_out^\dagger, b_loop, b_loop^\dagger. Parameters; ----------; blist : array_like; List of integers specifying the field operators:; 0: I (nothing); 1: b_out; 2: b_out^\dagger; 3: b_loop; 4: b_loop^\dagger. tlist : array_like; list of corresponding times t1,..,tn at which to evaluate the field; operators. tau : float; time-delay. c1 : :class:`qutip.Qobj`; system collapse operator that couples to t",MatchSource.WIKI,docs/4.2/modules/qutip/nonmarkov/memorycascade.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/nonmarkov/memorycascade.html
https://qutip.org/docs/4.2/modules/qutip/nonmarkov/memorycascade.html:5544,Deployability,integrat,integrator,5544,"elf.S_matrix = S_matrix; # create system identity superoperator; self.Id = qt.qeye(H_S.shape[0]); self.Id.dims = self.sysdims; self.Id = qt.sprepost(self.Id, self.Id); self.store_states = self.options.store_states; self.integrator = integrator; self.parallel = parallel. [docs] def propagator(self, t, tau, notrace=False):; """"""; Compute propagator for time t and time-delay tau. Parameters; ----------; t : *float*; current time. tau : *float*; time-delay. notrace : *bool* {False}; If this optional is set to True, a propagator is returned for a; cascade of k systems, where :math:`(k-1) tau < t < k tau`.; If set to False (default), a generalized partial trace is performed; and a propagator for a single system is returned.; Returns; -------; : :class:`qutip.Qobj`; time-propagator for reduced system dynamics; """"""; k = int(t/tau)+1; s = t-(k-1)*tau; G1, E0 = _generator(k, self.H_S, self.L1, self.L2, self.S_matrix,; self.c_ops_markov); E = _integrate(G1, E0, 0., s, integrator=self.integrator,; parallel=self.parallel, opt=self.options); if k > 1:; G2, null = _generator(k-1, self.H_S, self.L1, self.L2,; self.S_matrix, self.c_ops_markov); G2 = qt.composite(G2, self.Id); E = _integrate(G2, E, s, tau, integrator=self.integrator, ; parallel=self.parallel, opt=self.options); E.dims = E0.dims; if not notrace:; E = _genptrace(E, k); return E. [docs] def outfieldpropagator(self, blist, tlist, tau, c1=None, c2=None,; notrace=False):; """"""; Compute propagator for computing output field expectation values; <O_n(tn)...O_2(t2)O_1(t1)> for times t1,t2,... and; O_i = I, b_out, b_out^\dagger, b_loop, b_loop^\dagger. Parameters; ----------; blist : array_like; List of integers specifying the field operators:; 0: I (nothing); 1: b_out; 2: b_out^\dagger; 3: b_loop; 4: b_loop^\dagger. tlist : array_like; list of corresponding times t1,..,tn at which to evaluate the field; operators. tau : float; time-delay. c1 : :class:`qutip.Qobj`; system collapse operator that couples to the in-loop field in; que",MatchSource.WIKI,docs/4.2/modules/qutip/nonmarkov/memorycascade.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/nonmarkov/memorycascade.html
https://qutip.org/docs/4.2/modules/qutip/nonmarkov/memorycascade.html:5764,Deployability,integrat,integrator,5764,"ons.store_states; self.integrator = integrator; self.parallel = parallel. [docs] def propagator(self, t, tau, notrace=False):; """"""; Compute propagator for time t and time-delay tau. Parameters; ----------; t : *float*; current time. tau : *float*; time-delay. notrace : *bool* {False}; If this optional is set to True, a propagator is returned for a; cascade of k systems, where :math:`(k-1) tau < t < k tau`.; If set to False (default), a generalized partial trace is performed; and a propagator for a single system is returned.; Returns; -------; : :class:`qutip.Qobj`; time-propagator for reduced system dynamics; """"""; k = int(t/tau)+1; s = t-(k-1)*tau; G1, E0 = _generator(k, self.H_S, self.L1, self.L2, self.S_matrix,; self.c_ops_markov); E = _integrate(G1, E0, 0., s, integrator=self.integrator,; parallel=self.parallel, opt=self.options); if k > 1:; G2, null = _generator(k-1, self.H_S, self.L1, self.L2,; self.S_matrix, self.c_ops_markov); G2 = qt.composite(G2, self.Id); E = _integrate(G2, E, s, tau, integrator=self.integrator, ; parallel=self.parallel, opt=self.options); E.dims = E0.dims; if not notrace:; E = _genptrace(E, k); return E. [docs] def outfieldpropagator(self, blist, tlist, tau, c1=None, c2=None,; notrace=False):; """"""; Compute propagator for computing output field expectation values; <O_n(tn)...O_2(t2)O_1(t1)> for times t1,t2,... and; O_i = I, b_out, b_out^\dagger, b_loop, b_loop^\dagger. Parameters; ----------; blist : array_like; List of integers specifying the field operators:; 0: I (nothing); 1: b_out; 2: b_out^\dagger; 3: b_loop; 4: b_loop^\dagger. tlist : array_like; list of corresponding times t1,..,tn at which to evaluate the field; operators. tau : float; time-delay. c1 : :class:`qutip.Qobj`; system collapse operator that couples to the in-loop field in; question (only needs to be specified if self.L1 has more than one; element). c2 : :class:`qutip.Qobj`; system collapse operator that couples to the output field in; question (only needs to be specifie",MatchSource.WIKI,docs/4.2/modules/qutip/nonmarkov/memorycascade.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/nonmarkov/memorycascade.html
https://qutip.org/docs/4.2/modules/qutip/nonmarkov/memorycascade.html:5780,Deployability,integrat,integrator,5780,"grator; self.parallel = parallel. [docs] def propagator(self, t, tau, notrace=False):; """"""; Compute propagator for time t and time-delay tau. Parameters; ----------; t : *float*; current time. tau : *float*; time-delay. notrace : *bool* {False}; If this optional is set to True, a propagator is returned for a; cascade of k systems, where :math:`(k-1) tau < t < k tau`.; If set to False (default), a generalized partial trace is performed; and a propagator for a single system is returned.; Returns; -------; : :class:`qutip.Qobj`; time-propagator for reduced system dynamics; """"""; k = int(t/tau)+1; s = t-(k-1)*tau; G1, E0 = _generator(k, self.H_S, self.L1, self.L2, self.S_matrix,; self.c_ops_markov); E = _integrate(G1, E0, 0., s, integrator=self.integrator,; parallel=self.parallel, opt=self.options); if k > 1:; G2, null = _generator(k-1, self.H_S, self.L1, self.L2,; self.S_matrix, self.c_ops_markov); G2 = qt.composite(G2, self.Id); E = _integrate(G2, E, s, tau, integrator=self.integrator, ; parallel=self.parallel, opt=self.options); E.dims = E0.dims; if not notrace:; E = _genptrace(E, k); return E. [docs] def outfieldpropagator(self, blist, tlist, tau, c1=None, c2=None,; notrace=False):; """"""; Compute propagator for computing output field expectation values; <O_n(tn)...O_2(t2)O_1(t1)> for times t1,t2,... and; O_i = I, b_out, b_out^\dagger, b_loop, b_loop^\dagger. Parameters; ----------; blist : array_like; List of integers specifying the field operators:; 0: I (nothing); 1: b_out; 2: b_out^\dagger; 3: b_loop; 4: b_loop^\dagger. tlist : array_like; list of corresponding times t1,..,tn at which to evaluate the field; operators. tau : float; time-delay. c1 : :class:`qutip.Qobj`; system collapse operator that couples to the in-loop field in; question (only needs to be specified if self.L1 has more than one; element). c2 : :class:`qutip.Qobj`; system collapse operator that couples to the output field in; question (only needs to be specified if self.L2 has more than one; element",MatchSource.WIKI,docs/4.2/modules/qutip/nonmarkov/memorycascade.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/nonmarkov/memorycascade.html
https://qutip.org/docs/4.2/modules/qutip/nonmarkov/memorycascade.html:8003,Deployability,integrat,integrator,8003," generalized partial trace is performed; and a propagator for a single system is returned. Returns; -------; : :class:`qutip.Qobj`; time-propagator for computing field correlation function; """"""; if c1 is None and len(self.L1) == 1:; c1 = self.L1[0]; else:; raise ValueError('Argument c1 has to be specified when more than' +; 'one collapse operator couples to the feedback' +; 'loop.'); if c2 is None and len(self.L2) == 1:; c2 = self.L2[0]; else:; raise ValueError('Argument c1 has to be specified when more than' +; 'one collapse operator couples to the feedback' +; 'loop.'); klist = []; slist = []; for t in tlist:; klist.append(int(t/tau)+1); slist.append(t-(klist[-1]-1)*tau); kmax = max(klist); zipped = sorted(zip(slist, klist, blist)); slist = [s for (s, k, b) in zipped]; klist = [k for (s, k, b) in zipped]; blist = [b for (s, k, b) in zipped]. G1, E0 = _generator(kmax, self.H_S, self.L1, self.L2, self.S_matrix,; self.c_ops_markov); sprev = 0.; E = E0; for i, s in enumerate(slist):; E = _integrate(G1, E, sprev, s, integrator=self.integrator,; parallel=self.parallel, opt=self.options); if klist[i] == 1:; l1 = 0.*qt.Qobj(); else:; l1 = _localop(c1, klist[i]-1, kmax); l2 = _localop(c2, klist[i], kmax); if blist[i] == 0:; superop = self.Id; elif blist[i] == 1:; superop = qt.spre(l1+l2); elif blist[i] == 2:; superop = qt.spost(l1.dag()+l2.dag()); elif blist[i] == 3:; superop = qt.spre(l1); elif blist[i] == 4:; superop = qt.spost(l1.dag()); else:; raise ValueError('Allowed values in blist are 0, 1, 2, 3 ' +; 'and 4.'); superop.dims = E.dims; E = superop*E; sprev = s; E = _integrate(G1, E, slist[-1], tau, integrator=self.integrator,; parallel=self.parallel, opt=self.options). E.dims = E0.dims; if not notrace:; E = _genptrace(E, kmax); return E. [docs] def rhot(self, rho0, t, tau):; """"""; Compute the reduced system density matrix :math:`\\rho(t)`. Parameters; ----------; rho0 : :class:`qutip.Qobj`; initial density matrix or state vector (ket). t : float; current time. tau : fl",MatchSource.WIKI,docs/4.2/modules/qutip/nonmarkov/memorycascade.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/nonmarkov/memorycascade.html
https://qutip.org/docs/4.2/modules/qutip/nonmarkov/memorycascade.html:8019,Deployability,integrat,integrator,8019,"for a single system is returned. Returns; -------; : :class:`qutip.Qobj`; time-propagator for computing field correlation function; """"""; if c1 is None and len(self.L1) == 1:; c1 = self.L1[0]; else:; raise ValueError('Argument c1 has to be specified when more than' +; 'one collapse operator couples to the feedback' +; 'loop.'); if c2 is None and len(self.L2) == 1:; c2 = self.L2[0]; else:; raise ValueError('Argument c1 has to be specified when more than' +; 'one collapse operator couples to the feedback' +; 'loop.'); klist = []; slist = []; for t in tlist:; klist.append(int(t/tau)+1); slist.append(t-(klist[-1]-1)*tau); kmax = max(klist); zipped = sorted(zip(slist, klist, blist)); slist = [s for (s, k, b) in zipped]; klist = [k for (s, k, b) in zipped]; blist = [b for (s, k, b) in zipped]. G1, E0 = _generator(kmax, self.H_S, self.L1, self.L2, self.S_matrix,; self.c_ops_markov); sprev = 0.; E = E0; for i, s in enumerate(slist):; E = _integrate(G1, E, sprev, s, integrator=self.integrator,; parallel=self.parallel, opt=self.options); if klist[i] == 1:; l1 = 0.*qt.Qobj(); else:; l1 = _localop(c1, klist[i]-1, kmax); l2 = _localop(c2, klist[i], kmax); if blist[i] == 0:; superop = self.Id; elif blist[i] == 1:; superop = qt.spre(l1+l2); elif blist[i] == 2:; superop = qt.spost(l1.dag()+l2.dag()); elif blist[i] == 3:; superop = qt.spre(l1); elif blist[i] == 4:; superop = qt.spost(l1.dag()); else:; raise ValueError('Allowed values in blist are 0, 1, 2, 3 ' +; 'and 4.'); superop.dims = E.dims; E = superop*E; sprev = s; E = _integrate(G1, E, slist[-1], tau, integrator=self.integrator,; parallel=self.parallel, opt=self.options). E.dims = E0.dims; if not notrace:; E = _genptrace(E, kmax); return E. [docs] def rhot(self, rho0, t, tau):; """"""; Compute the reduced system density matrix :math:`\\rho(t)`. Parameters; ----------; rho0 : :class:`qutip.Qobj`; initial density matrix or state vector (ket). t : float; current time. tau : float; time-delay. Returns; -------; : :class:`qutip.Qobj`; ",MatchSource.WIKI,docs/4.2/modules/qutip/nonmarkov/memorycascade.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/nonmarkov/memorycascade.html
https://qutip.org/docs/4.2/modules/qutip/nonmarkov/memorycascade.html:8599,Deployability,integrat,integrator,8599," []; for t in tlist:; klist.append(int(t/tau)+1); slist.append(t-(klist[-1]-1)*tau); kmax = max(klist); zipped = sorted(zip(slist, klist, blist)); slist = [s for (s, k, b) in zipped]; klist = [k for (s, k, b) in zipped]; blist = [b for (s, k, b) in zipped]. G1, E0 = _generator(kmax, self.H_S, self.L1, self.L2, self.S_matrix,; self.c_ops_markov); sprev = 0.; E = E0; for i, s in enumerate(slist):; E = _integrate(G1, E, sprev, s, integrator=self.integrator,; parallel=self.parallel, opt=self.options); if klist[i] == 1:; l1 = 0.*qt.Qobj(); else:; l1 = _localop(c1, klist[i]-1, kmax); l2 = _localop(c2, klist[i], kmax); if blist[i] == 0:; superop = self.Id; elif blist[i] == 1:; superop = qt.spre(l1+l2); elif blist[i] == 2:; superop = qt.spost(l1.dag()+l2.dag()); elif blist[i] == 3:; superop = qt.spre(l1); elif blist[i] == 4:; superop = qt.spost(l1.dag()); else:; raise ValueError('Allowed values in blist are 0, 1, 2, 3 ' +; 'and 4.'); superop.dims = E.dims; E = superop*E; sprev = s; E = _integrate(G1, E, slist[-1], tau, integrator=self.integrator,; parallel=self.parallel, opt=self.options). E.dims = E0.dims; if not notrace:; E = _genptrace(E, kmax); return E. [docs] def rhot(self, rho0, t, tau):; """"""; Compute the reduced system density matrix :math:`\\rho(t)`. Parameters; ----------; rho0 : :class:`qutip.Qobj`; initial density matrix or state vector (ket). t : float; current time. tau : float; time-delay. Returns; -------; : :class:`qutip.Qobj`; density matrix at time :math:`t`; """"""; if qt.isket(rho0):; rho0 = qt.ket2dm(rho0). E = self.propagator(t, tau); rhovec = qt.operator_to_vector(rho0); return qt.vector_to_operator(E*rhovec). [docs] def outfieldcorr(self, rho0, blist, tlist, tau, c1=None, c2=None):; """"""; Compute output field expectation value; <O_n(tn)...O_2(t2)O_1(t1)> for times t1,t2,... and; O_i = I, b_out, b_out^\dagger, b_loop, b_loop^\dagger. Parameters; ----------; rho0 : :class:`qutip.Qobj`; initial density matrix or state vector (ket). blist : array_like; List",MatchSource.WIKI,docs/4.2/modules/qutip/nonmarkov/memorycascade.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/nonmarkov/memorycascade.html
https://qutip.org/docs/4.2/modules/qutip/nonmarkov/memorycascade.html:8615,Deployability,integrat,integrator,8615,"append(t-(klist[-1]-1)*tau); kmax = max(klist); zipped = sorted(zip(slist, klist, blist)); slist = [s for (s, k, b) in zipped]; klist = [k for (s, k, b) in zipped]; blist = [b for (s, k, b) in zipped]. G1, E0 = _generator(kmax, self.H_S, self.L1, self.L2, self.S_matrix,; self.c_ops_markov); sprev = 0.; E = E0; for i, s in enumerate(slist):; E = _integrate(G1, E, sprev, s, integrator=self.integrator,; parallel=self.parallel, opt=self.options); if klist[i] == 1:; l1 = 0.*qt.Qobj(); else:; l1 = _localop(c1, klist[i]-1, kmax); l2 = _localop(c2, klist[i], kmax); if blist[i] == 0:; superop = self.Id; elif blist[i] == 1:; superop = qt.spre(l1+l2); elif blist[i] == 2:; superop = qt.spost(l1.dag()+l2.dag()); elif blist[i] == 3:; superop = qt.spre(l1); elif blist[i] == 4:; superop = qt.spost(l1.dag()); else:; raise ValueError('Allowed values in blist are 0, 1, 2, 3 ' +; 'and 4.'); superop.dims = E.dims; E = superop*E; sprev = s; E = _integrate(G1, E, slist[-1], tau, integrator=self.integrator,; parallel=self.parallel, opt=self.options). E.dims = E0.dims; if not notrace:; E = _genptrace(E, kmax); return E. [docs] def rhot(self, rho0, t, tau):; """"""; Compute the reduced system density matrix :math:`\\rho(t)`. Parameters; ----------; rho0 : :class:`qutip.Qobj`; initial density matrix or state vector (ket). t : float; current time. tau : float; time-delay. Returns; -------; : :class:`qutip.Qobj`; density matrix at time :math:`t`; """"""; if qt.isket(rho0):; rho0 = qt.ket2dm(rho0). E = self.propagator(t, tau); rhovec = qt.operator_to_vector(rho0); return qt.vector_to_operator(E*rhovec). [docs] def outfieldcorr(self, rho0, blist, tlist, tau, c1=None, c2=None):; """"""; Compute output field expectation value; <O_n(tn)...O_2(t2)O_1(t1)> for times t1,t2,... and; O_i = I, b_out, b_out^\dagger, b_loop, b_loop^\dagger. Parameters; ----------; rho0 : :class:`qutip.Qobj`; initial density matrix or state vector (ket). blist : array_like; List of integers specifying the field operators:; 0: I (nothi",MatchSource.WIKI,docs/4.2/modules/qutip/nonmarkov/memorycascade.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/nonmarkov/memorycascade.html
https://qutip.org/docs/4.2/modules/qutip/nonmarkov/memorycascade.html:12210,Deployability,integrat,integrator,12210,"+1)); return E. def _generator(k, H, L1, L2, S=None, c_ops_markov=None):; """"""; Create a Liouvillian for a cascaded chain of k system copies; """"""; id = qt.qeye(H.dims[0][0]); Id = qt.sprepost(id, id); if S is None:; S = np.identity(len(L1)); # create Lindbladian; L = qt.Qobj(); E0 = Id; # first system; L += qt.liouvillian(None, [_localop(c, 1, k) for c in L2]); for l in range(1, k):; # Identiy superoperator; E0 = qt.composite(E0, Id); # Bare Hamiltonian; Hl = _localop(H, l, k); L += qt.liouvillian(Hl, []); # Markovian Decay channels; if c_ops_markov is not None:; for c in c_ops_markov:; cl = _localop(c, l, k); L += qt.liouvillian(None, [cl]); # Cascade coupling; c1 = np.array([_localop(c, l, k) for c in L1]); c2 = np.array([_localop(c, l+1, k) for c in L2]); c2dag = np.array([c.dag() for c in c2]); Hcasc = -0.5j*np.dot(c2dag, np.dot(S, c1)); Hcasc += Hcasc.dag(); Lvec = c2 + np.dot(S, c1); L += qt.liouvillian(Hcasc, [c for c in Lvec]); # last system; L += qt.liouvillian(_localop(H, k, k), [_localop(c, k, k) for c in L1]); if c_ops_markov is not None:; for c in c_ops_markov:; cl = _localop(c, k, k); L += qt.liouvillian(None, [cl]); E0.dims = L.dims; # return generator and identity superop E0; return L, E0. def _integrate(L, E0, ti, tf, integrator='propagator', parallel=False,; opt=qt.Options()):; """"""; Basic ode integrator; """"""; if tf > ti:; if integrator == 'mesolve':; if parallel:; warnings.warn('parallelization not implemented for ""mesolve""'); opt.store_final_state = True; sol = qt.mesolve(L, E0, [ti, tf], [], [], options=opt); return sol.final_state; elif integrator == 'propagator':; return qt.propagator(L, (tf-ti), [], [], parallel=parallel,; options=opt)*E0; else:; raise ValueError('integrator keyword must be either ""propagator""' +; 'or ""mesolve""'); else:; return E0. Â© Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, and A.L. Grimsmo.; Last updated on Jan 17, 2018. . Built with Sphinx using a theme provided by Read the Docs. . ",MatchSource.WIKI,docs/4.2/modules/qutip/nonmarkov/memorycascade.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/nonmarkov/memorycascade.html
https://qutip.org/docs/4.2/modules/qutip/nonmarkov/memorycascade.html:12287,Deployability,integrat,integrator,12287,"+1)); return E. def _generator(k, H, L1, L2, S=None, c_ops_markov=None):; """"""; Create a Liouvillian for a cascaded chain of k system copies; """"""; id = qt.qeye(H.dims[0][0]); Id = qt.sprepost(id, id); if S is None:; S = np.identity(len(L1)); # create Lindbladian; L = qt.Qobj(); E0 = Id; # first system; L += qt.liouvillian(None, [_localop(c, 1, k) for c in L2]); for l in range(1, k):; # Identiy superoperator; E0 = qt.composite(E0, Id); # Bare Hamiltonian; Hl = _localop(H, l, k); L += qt.liouvillian(Hl, []); # Markovian Decay channels; if c_ops_markov is not None:; for c in c_ops_markov:; cl = _localop(c, l, k); L += qt.liouvillian(None, [cl]); # Cascade coupling; c1 = np.array([_localop(c, l, k) for c in L1]); c2 = np.array([_localop(c, l+1, k) for c in L2]); c2dag = np.array([c.dag() for c in c2]); Hcasc = -0.5j*np.dot(c2dag, np.dot(S, c1)); Hcasc += Hcasc.dag(); Lvec = c2 + np.dot(S, c1); L += qt.liouvillian(Hcasc, [c for c in Lvec]); # last system; L += qt.liouvillian(_localop(H, k, k), [_localop(c, k, k) for c in L1]); if c_ops_markov is not None:; for c in c_ops_markov:; cl = _localop(c, k, k); L += qt.liouvillian(None, [cl]); E0.dims = L.dims; # return generator and identity superop E0; return L, E0. def _integrate(L, E0, ti, tf, integrator='propagator', parallel=False,; opt=qt.Options()):; """"""; Basic ode integrator; """"""; if tf > ti:; if integrator == 'mesolve':; if parallel:; warnings.warn('parallelization not implemented for ""mesolve""'); opt.store_final_state = True; sol = qt.mesolve(L, E0, [ti, tf], [], [], options=opt); return sol.final_state; elif integrator == 'propagator':; return qt.propagator(L, (tf-ti), [], [], parallel=parallel,; options=opt)*E0; else:; raise ValueError('integrator keyword must be either ""propagator""' +; 'or ""mesolve""'); else:; return E0. Â© Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, and A.L. Grimsmo.; Last updated on Jan 17, 2018. . Built with Sphinx using a theme provided by Read the Docs. . ",MatchSource.WIKI,docs/4.2/modules/qutip/nonmarkov/memorycascade.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/nonmarkov/memorycascade.html
https://qutip.org/docs/4.2/modules/qutip/nonmarkov/memorycascade.html:12320,Deployability,integrat,integrator,12320,"+1)); return E. def _generator(k, H, L1, L2, S=None, c_ops_markov=None):; """"""; Create a Liouvillian for a cascaded chain of k system copies; """"""; id = qt.qeye(H.dims[0][0]); Id = qt.sprepost(id, id); if S is None:; S = np.identity(len(L1)); # create Lindbladian; L = qt.Qobj(); E0 = Id; # first system; L += qt.liouvillian(None, [_localop(c, 1, k) for c in L2]); for l in range(1, k):; # Identiy superoperator; E0 = qt.composite(E0, Id); # Bare Hamiltonian; Hl = _localop(H, l, k); L += qt.liouvillian(Hl, []); # Markovian Decay channels; if c_ops_markov is not None:; for c in c_ops_markov:; cl = _localop(c, l, k); L += qt.liouvillian(None, [cl]); # Cascade coupling; c1 = np.array([_localop(c, l, k) for c in L1]); c2 = np.array([_localop(c, l+1, k) for c in L2]); c2dag = np.array([c.dag() for c in c2]); Hcasc = -0.5j*np.dot(c2dag, np.dot(S, c1)); Hcasc += Hcasc.dag(); Lvec = c2 + np.dot(S, c1); L += qt.liouvillian(Hcasc, [c for c in Lvec]); # last system; L += qt.liouvillian(_localop(H, k, k), [_localop(c, k, k) for c in L1]); if c_ops_markov is not None:; for c in c_ops_markov:; cl = _localop(c, k, k); L += qt.liouvillian(None, [cl]); E0.dims = L.dims; # return generator and identity superop E0; return L, E0. def _integrate(L, E0, ti, tf, integrator='propagator', parallel=False,; opt=qt.Options()):; """"""; Basic ode integrator; """"""; if tf > ti:; if integrator == 'mesolve':; if parallel:; warnings.warn('parallelization not implemented for ""mesolve""'); opt.store_final_state = True; sol = qt.mesolve(L, E0, [ti, tf], [], [], options=opt); return sol.final_state; elif integrator == 'propagator':; return qt.propagator(L, (tf-ti), [], [], parallel=parallel,; options=opt)*E0; else:; raise ValueError('integrator keyword must be either ""propagator""' +; 'or ""mesolve""'); else:; return E0. Â© Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, and A.L. Grimsmo.; Last updated on Jan 17, 2018. . Built with Sphinx using a theme provided by Read the Docs. . ",MatchSource.WIKI,docs/4.2/modules/qutip/nonmarkov/memorycascade.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/nonmarkov/memorycascade.html
https://qutip.org/docs/4.2/modules/qutip/nonmarkov/memorycascade.html:12539,Deployability,integrat,integrator,12539,"+1)); return E. def _generator(k, H, L1, L2, S=None, c_ops_markov=None):; """"""; Create a Liouvillian for a cascaded chain of k system copies; """"""; id = qt.qeye(H.dims[0][0]); Id = qt.sprepost(id, id); if S is None:; S = np.identity(len(L1)); # create Lindbladian; L = qt.Qobj(); E0 = Id; # first system; L += qt.liouvillian(None, [_localop(c, 1, k) for c in L2]); for l in range(1, k):; # Identiy superoperator; E0 = qt.composite(E0, Id); # Bare Hamiltonian; Hl = _localop(H, l, k); L += qt.liouvillian(Hl, []); # Markovian Decay channels; if c_ops_markov is not None:; for c in c_ops_markov:; cl = _localop(c, l, k); L += qt.liouvillian(None, [cl]); # Cascade coupling; c1 = np.array([_localop(c, l, k) for c in L1]); c2 = np.array([_localop(c, l+1, k) for c in L2]); c2dag = np.array([c.dag() for c in c2]); Hcasc = -0.5j*np.dot(c2dag, np.dot(S, c1)); Hcasc += Hcasc.dag(); Lvec = c2 + np.dot(S, c1); L += qt.liouvillian(Hcasc, [c for c in Lvec]); # last system; L += qt.liouvillian(_localop(H, k, k), [_localop(c, k, k) for c in L1]); if c_ops_markov is not None:; for c in c_ops_markov:; cl = _localop(c, k, k); L += qt.liouvillian(None, [cl]); E0.dims = L.dims; # return generator and identity superop E0; return L, E0. def _integrate(L, E0, ti, tf, integrator='propagator', parallel=False,; opt=qt.Options()):; """"""; Basic ode integrator; """"""; if tf > ti:; if integrator == 'mesolve':; if parallel:; warnings.warn('parallelization not implemented for ""mesolve""'); opt.store_final_state = True; sol = qt.mesolve(L, E0, [ti, tf], [], [], options=opt); return sol.final_state; elif integrator == 'propagator':; return qt.propagator(L, (tf-ti), [], [], parallel=parallel,; options=opt)*E0; else:; raise ValueError('integrator keyword must be either ""propagator""' +; 'or ""mesolve""'); else:; return E0. Â© Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, and A.L. Grimsmo.; Last updated on Jan 17, 2018. . Built with Sphinx using a theme provided by Read the Docs. . ",MatchSource.WIKI,docs/4.2/modules/qutip/nonmarkov/memorycascade.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/nonmarkov/memorycascade.html
https://qutip.org/docs/4.2/modules/qutip/nonmarkov/memorycascade.html:12671,Deployability,integrat,integrator,12671,"+1)); return E. def _generator(k, H, L1, L2, S=None, c_ops_markov=None):; """"""; Create a Liouvillian for a cascaded chain of k system copies; """"""; id = qt.qeye(H.dims[0][0]); Id = qt.sprepost(id, id); if S is None:; S = np.identity(len(L1)); # create Lindbladian; L = qt.Qobj(); E0 = Id; # first system; L += qt.liouvillian(None, [_localop(c, 1, k) for c in L2]); for l in range(1, k):; # Identiy superoperator; E0 = qt.composite(E0, Id); # Bare Hamiltonian; Hl = _localop(H, l, k); L += qt.liouvillian(Hl, []); # Markovian Decay channels; if c_ops_markov is not None:; for c in c_ops_markov:; cl = _localop(c, l, k); L += qt.liouvillian(None, [cl]); # Cascade coupling; c1 = np.array([_localop(c, l, k) for c in L1]); c2 = np.array([_localop(c, l+1, k) for c in L2]); c2dag = np.array([c.dag() for c in c2]); Hcasc = -0.5j*np.dot(c2dag, np.dot(S, c1)); Hcasc += Hcasc.dag(); Lvec = c2 + np.dot(S, c1); L += qt.liouvillian(Hcasc, [c for c in Lvec]); # last system; L += qt.liouvillian(_localop(H, k, k), [_localop(c, k, k) for c in L1]); if c_ops_markov is not None:; for c in c_ops_markov:; cl = _localop(c, k, k); L += qt.liouvillian(None, [cl]); E0.dims = L.dims; # return generator and identity superop E0; return L, E0. def _integrate(L, E0, ti, tf, integrator='propagator', parallel=False,; opt=qt.Options()):; """"""; Basic ode integrator; """"""; if tf > ti:; if integrator == 'mesolve':; if parallel:; warnings.warn('parallelization not implemented for ""mesolve""'); opt.store_final_state = True; sol = qt.mesolve(L, E0, [ti, tf], [], [], options=opt); return sol.final_state; elif integrator == 'propagator':; return qt.propagator(L, (tf-ti), [], [], parallel=parallel,; options=opt)*E0; else:; raise ValueError('integrator keyword must be either ""propagator""' +; 'or ""mesolve""'); else:; return E0. Â© Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, and A.L. Grimsmo.; Last updated on Jan 17, 2018. . Built with Sphinx using a theme provided by Read the Docs. . ",MatchSource.WIKI,docs/4.2/modules/qutip/nonmarkov/memorycascade.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/nonmarkov/memorycascade.html
https://qutip.org/docs/4.2/modules/qutip/nonmarkov/memorycascade.html:12868,Deployability,update,updated,12868,"+1)); return E. def _generator(k, H, L1, L2, S=None, c_ops_markov=None):; """"""; Create a Liouvillian for a cascaded chain of k system copies; """"""; id = qt.qeye(H.dims[0][0]); Id = qt.sprepost(id, id); if S is None:; S = np.identity(len(L1)); # create Lindbladian; L = qt.Qobj(); E0 = Id; # first system; L += qt.liouvillian(None, [_localop(c, 1, k) for c in L2]); for l in range(1, k):; # Identiy superoperator; E0 = qt.composite(E0, Id); # Bare Hamiltonian; Hl = _localop(H, l, k); L += qt.liouvillian(Hl, []); # Markovian Decay channels; if c_ops_markov is not None:; for c in c_ops_markov:; cl = _localop(c, l, k); L += qt.liouvillian(None, [cl]); # Cascade coupling; c1 = np.array([_localop(c, l, k) for c in L1]); c2 = np.array([_localop(c, l+1, k) for c in L2]); c2dag = np.array([c.dag() for c in c2]); Hcasc = -0.5j*np.dot(c2dag, np.dot(S, c1)); Hcasc += Hcasc.dag(); Lvec = c2 + np.dot(S, c1); L += qt.liouvillian(Hcasc, [c for c in Lvec]); # last system; L += qt.liouvillian(_localop(H, k, k), [_localop(c, k, k) for c in L1]); if c_ops_markov is not None:; for c in c_ops_markov:; cl = _localop(c, k, k); L += qt.liouvillian(None, [cl]); E0.dims = L.dims; # return generator and identity superop E0; return L, E0. def _integrate(L, E0, ti, tf, integrator='propagator', parallel=False,; opt=qt.Options()):; """"""; Basic ode integrator; """"""; if tf > ti:; if integrator == 'mesolve':; if parallel:; warnings.warn('parallelization not implemented for ""mesolve""'); opt.store_final_state = True; sol = qt.mesolve(L, E0, [ti, tf], [], [], options=opt); return sol.final_state; elif integrator == 'propagator':; return qt.propagator(L, (tf-ti), [], [], parallel=parallel,; options=opt)*E0; else:; raise ValueError('integrator keyword must be either ""propagator""' +; 'or ""mesolve""'); else:; return E0. Â© Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, and A.L. Grimsmo.; Last updated on Jan 17, 2018. . Built with Sphinx using a theme provided by Read the Docs. . ",MatchSource.WIKI,docs/4.2/modules/qutip/nonmarkov/memorycascade.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/nonmarkov/memorycascade.html
https://qutip.org/docs/4.2/modules/qutip/nonmarkov/memorycascade.html:5346,Energy Efficiency,reduce,reduced,5346,"ce(c_ops_markov, qt.Qobj):; self.c_ops_markov = [c_ops_markov]; else:; self.c_ops_markov = c_ops_markov. if S_matrix is None:; self.S_matrix = np.identity(len(self.L1)); else:; self.S_matrix = S_matrix; # create system identity superoperator; self.Id = qt.qeye(H_S.shape[0]); self.Id.dims = self.sysdims; self.Id = qt.sprepost(self.Id, self.Id); self.store_states = self.options.store_states; self.integrator = integrator; self.parallel = parallel. [docs] def propagator(self, t, tau, notrace=False):; """"""; Compute propagator for time t and time-delay tau. Parameters; ----------; t : *float*; current time. tau : *float*; time-delay. notrace : *bool* {False}; If this optional is set to True, a propagator is returned for a; cascade of k systems, where :math:`(k-1) tau < t < k tau`.; If set to False (default), a generalized partial trace is performed; and a propagator for a single system is returned.; Returns; -------; : :class:`qutip.Qobj`; time-propagator for reduced system dynamics; """"""; k = int(t/tau)+1; s = t-(k-1)*tau; G1, E0 = _generator(k, self.H_S, self.L1, self.L2, self.S_matrix,; self.c_ops_markov); E = _integrate(G1, E0, 0., s, integrator=self.integrator,; parallel=self.parallel, opt=self.options); if k > 1:; G2, null = _generator(k-1, self.H_S, self.L1, self.L2,; self.S_matrix, self.c_ops_markov); G2 = qt.composite(G2, self.Id); E = _integrate(G2, E, s, tau, integrator=self.integrator, ; parallel=self.parallel, opt=self.options); E.dims = E0.dims; if not notrace:; E = _genptrace(E, k); return E. [docs] def outfieldpropagator(self, blist, tlist, tau, c1=None, c2=None,; notrace=False):; """"""; Compute propagator for computing output field expectation values; <O_n(tn)...O_2(t2)O_1(t1)> for times t1,t2,... and; O_i = I, b_out, b_out^\dagger, b_loop, b_loop^\dagger. Parameters; ----------; blist : array_like; List of integers specifying the field operators:; 0: I (nothing); 1: b_out; 2: b_out^\dagger; 3: b_loop; 4: b_loop^\dagger. tlist : array_like; list of correspond",MatchSource.WIKI,docs/4.2/modules/qutip/nonmarkov/memorycascade.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/nonmarkov/memorycascade.html
https://qutip.org/docs/4.2/modules/qutip/nonmarkov/memorycascade.html:8796,Energy Efficiency,reduce,reduced,8796,"; blist = [b for (s, k, b) in zipped]. G1, E0 = _generator(kmax, self.H_S, self.L1, self.L2, self.S_matrix,; self.c_ops_markov); sprev = 0.; E = E0; for i, s in enumerate(slist):; E = _integrate(G1, E, sprev, s, integrator=self.integrator,; parallel=self.parallel, opt=self.options); if klist[i] == 1:; l1 = 0.*qt.Qobj(); else:; l1 = _localop(c1, klist[i]-1, kmax); l2 = _localop(c2, klist[i], kmax); if blist[i] == 0:; superop = self.Id; elif blist[i] == 1:; superop = qt.spre(l1+l2); elif blist[i] == 2:; superop = qt.spost(l1.dag()+l2.dag()); elif blist[i] == 3:; superop = qt.spre(l1); elif blist[i] == 4:; superop = qt.spost(l1.dag()); else:; raise ValueError('Allowed values in blist are 0, 1, 2, 3 ' +; 'and 4.'); superop.dims = E.dims; E = superop*E; sprev = s; E = _integrate(G1, E, slist[-1], tau, integrator=self.integrator,; parallel=self.parallel, opt=self.options). E.dims = E0.dims; if not notrace:; E = _genptrace(E, kmax); return E. [docs] def rhot(self, rho0, t, tau):; """"""; Compute the reduced system density matrix :math:`\\rho(t)`. Parameters; ----------; rho0 : :class:`qutip.Qobj`; initial density matrix or state vector (ket). t : float; current time. tau : float; time-delay. Returns; -------; : :class:`qutip.Qobj`; density matrix at time :math:`t`; """"""; if qt.isket(rho0):; rho0 = qt.ket2dm(rho0). E = self.propagator(t, tau); rhovec = qt.operator_to_vector(rho0); return qt.vector_to_operator(E*rhovec). [docs] def outfieldcorr(self, rho0, blist, tlist, tau, c1=None, c2=None):; """"""; Compute output field expectation value; <O_n(tn)...O_2(t2)O_1(t1)> for times t1,t2,... and; O_i = I, b_out, b_out^\dagger, b_loop, b_loop^\dagger. Parameters; ----------; rho0 : :class:`qutip.Qobj`; initial density matrix or state vector (ket). blist : array_like; List of integers specifying the field operators:; 0: I (nothing); 1: b_out; 2: b_out^\dagger; 3: b_loop; 4: b_loop^\dagger. tlist : array_like; list of corresponding times t1,..,tn at which to evaluate the field; operators. ",MatchSource.WIKI,docs/4.2/modules/qutip/nonmarkov/memorycascade.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/nonmarkov/memorycascade.html
https://qutip.org/docs/4.2/modules/qutip/nonmarkov/memorycascade.html:3543,Integrability,integrat,integrator,3543,"s MemoryCascade:; """"""Class for running memory cascade simulations of open quantum systems; with time-delayed coherent feedback. Attributes; ----------; H_S : :class:`qutip.Qobj`; System Hamiltonian (can also be a Liouvillian). L1 : :class:`qutip.Qobj` / list of :class:`qutip.Qobj`; System operators coupling into the feedback loop. Can be a single; operator or a list of operators. L2 : :class:`qutip.Qobj` / list of :class:`qutip.Qobj`; System operators coupling out of the feedback loop. Can be a single; operator or a list of operators. L2 must have the same length as L1. S_matrix: *array*; S matrix describing which operators in L1 are coupled to which; operators in L2 by the feedback channel. Defaults to an n by n identity; matrix where n is the number of elements in L1/L2. c_ops_markov : :class:`qutip.Qobj` / list of :class:`qutip.Qobj`; Decay operators describing conventional Markovian decay channels.; Can be a single operator or a list of operators. integrator : str {'propagator', 'mesolve'}; Integrator method to use. Defaults to 'propagator' which tends to be ; faster for long times (i.e., large Hilbert space). parallel : bool; Run integrator in parallel if True. Only implemented for 'propagator'; as the integrator method. options : :class:`qutip.solver.Options`; Generic solver options.; """""". def __init__(self, H_S, L1, L2, S_matrix=None, c_ops_markov=None,; integrator='propagator', parallel=False, options=None):. if options is None:; self.options = qt.Options(); else:; self.options = options. self.H_S = H_S; self.sysdims = H_S.dims; if isinstance(L1, qt.Qobj):; self.L1 = [L1]; else:; self.L1 = L1; if isinstance(L2, qt.Qobj):; self.L2 = [L2]; else:; self.L2 = L2; if not len(self.L1) == len(self.L2):; raise ValueError('L1 and L2 has to be of equal length.'); if isinstance(c_ops_markov, qt.Qobj):; self.c_ops_markov = [c_ops_markov]; else:; self.c_ops_markov = c_ops_markov. if S_matrix is None:; self.S_matrix = np.identity(len(self.L1)); else:; self.S_matrix = S_mat",MatchSource.WIKI,docs/4.2/modules/qutip/nonmarkov/memorycascade.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/nonmarkov/memorycascade.html
https://qutip.org/docs/4.2/modules/qutip/nonmarkov/memorycascade.html:3730,Integrability,integrat,integrator,3730," :class:`qutip.Qobj`; System Hamiltonian (can also be a Liouvillian). L1 : :class:`qutip.Qobj` / list of :class:`qutip.Qobj`; System operators coupling into the feedback loop. Can be a single; operator or a list of operators. L2 : :class:`qutip.Qobj` / list of :class:`qutip.Qobj`; System operators coupling out of the feedback loop. Can be a single; operator or a list of operators. L2 must have the same length as L1. S_matrix: *array*; S matrix describing which operators in L1 are coupled to which; operators in L2 by the feedback channel. Defaults to an n by n identity; matrix where n is the number of elements in L1/L2. c_ops_markov : :class:`qutip.Qobj` / list of :class:`qutip.Qobj`; Decay operators describing conventional Markovian decay channels.; Can be a single operator or a list of operators. integrator : str {'propagator', 'mesolve'}; Integrator method to use. Defaults to 'propagator' which tends to be ; faster for long times (i.e., large Hilbert space). parallel : bool; Run integrator in parallel if True. Only implemented for 'propagator'; as the integrator method. options : :class:`qutip.solver.Options`; Generic solver options.; """""". def __init__(self, H_S, L1, L2, S_matrix=None, c_ops_markov=None,; integrator='propagator', parallel=False, options=None):. if options is None:; self.options = qt.Options(); else:; self.options = options. self.H_S = H_S; self.sysdims = H_S.dims; if isinstance(L1, qt.Qobj):; self.L1 = [L1]; else:; self.L1 = L1; if isinstance(L2, qt.Qobj):; self.L2 = [L2]; else:; self.L2 = L2; if not len(self.L1) == len(self.L2):; raise ValueError('L1 and L2 has to be of equal length.'); if isinstance(c_ops_markov, qt.Qobj):; self.c_ops_markov = [c_ops_markov]; else:; self.c_ops_markov = c_ops_markov. if S_matrix is None:; self.S_matrix = np.identity(len(self.L1)); else:; self.S_matrix = S_matrix; # create system identity superoperator; self.Id = qt.qeye(H_S.shape[0]); self.Id.dims = self.sysdims; self.Id = qt.sprepost(self.Id, self.Id); self.store",MatchSource.WIKI,docs/4.2/modules/qutip/nonmarkov/memorycascade.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/nonmarkov/memorycascade.html
https://qutip.org/docs/4.2/modules/qutip/nonmarkov/memorycascade.html:3804,Integrability,integrat,integrator,3804,"iouvillian). L1 : :class:`qutip.Qobj` / list of :class:`qutip.Qobj`; System operators coupling into the feedback loop. Can be a single; operator or a list of operators. L2 : :class:`qutip.Qobj` / list of :class:`qutip.Qobj`; System operators coupling out of the feedback loop. Can be a single; operator or a list of operators. L2 must have the same length as L1. S_matrix: *array*; S matrix describing which operators in L1 are coupled to which; operators in L2 by the feedback channel. Defaults to an n by n identity; matrix where n is the number of elements in L1/L2. c_ops_markov : :class:`qutip.Qobj` / list of :class:`qutip.Qobj`; Decay operators describing conventional Markovian decay channels.; Can be a single operator or a list of operators. integrator : str {'propagator', 'mesolve'}; Integrator method to use. Defaults to 'propagator' which tends to be ; faster for long times (i.e., large Hilbert space). parallel : bool; Run integrator in parallel if True. Only implemented for 'propagator'; as the integrator method. options : :class:`qutip.solver.Options`; Generic solver options.; """""". def __init__(self, H_S, L1, L2, S_matrix=None, c_ops_markov=None,; integrator='propagator', parallel=False, options=None):. if options is None:; self.options = qt.Options(); else:; self.options = options. self.H_S = H_S; self.sysdims = H_S.dims; if isinstance(L1, qt.Qobj):; self.L1 = [L1]; else:; self.L1 = L1; if isinstance(L2, qt.Qobj):; self.L2 = [L2]; else:; self.L2 = L2; if not len(self.L1) == len(self.L2):; raise ValueError('L1 and L2 has to be of equal length.'); if isinstance(c_ops_markov, qt.Qobj):; self.c_ops_markov = [c_ops_markov]; else:; self.c_ops_markov = c_ops_markov. if S_matrix is None:; self.S_matrix = np.identity(len(self.L1)); else:; self.S_matrix = S_matrix; # create system identity superoperator; self.Id = qt.qeye(H_S.shape[0]); self.Id.dims = self.sysdims; self.Id = qt.sprepost(self.Id, self.Id); self.store_states = self.options.store_states; self.integrator = in",MatchSource.WIKI,docs/4.2/modules/qutip/nonmarkov/memorycascade.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/nonmarkov/memorycascade.html
https://qutip.org/docs/4.2/modules/qutip/nonmarkov/memorycascade.html:3961,Integrability,integrat,integrator,3961,"ors. L2 : :class:`qutip.Qobj` / list of :class:`qutip.Qobj`; System operators coupling out of the feedback loop. Can be a single; operator or a list of operators. L2 must have the same length as L1. S_matrix: *array*; S matrix describing which operators in L1 are coupled to which; operators in L2 by the feedback channel. Defaults to an n by n identity; matrix where n is the number of elements in L1/L2. c_ops_markov : :class:`qutip.Qobj` / list of :class:`qutip.Qobj`; Decay operators describing conventional Markovian decay channels.; Can be a single operator or a list of operators. integrator : str {'propagator', 'mesolve'}; Integrator method to use. Defaults to 'propagator' which tends to be ; faster for long times (i.e., large Hilbert space). parallel : bool; Run integrator in parallel if True. Only implemented for 'propagator'; as the integrator method. options : :class:`qutip.solver.Options`; Generic solver options.; """""". def __init__(self, H_S, L1, L2, S_matrix=None, c_ops_markov=None,; integrator='propagator', parallel=False, options=None):. if options is None:; self.options = qt.Options(); else:; self.options = options. self.H_S = H_S; self.sysdims = H_S.dims; if isinstance(L1, qt.Qobj):; self.L1 = [L1]; else:; self.L1 = L1; if isinstance(L2, qt.Qobj):; self.L2 = [L2]; else:; self.L2 = L2; if not len(self.L1) == len(self.L2):; raise ValueError('L1 and L2 has to be of equal length.'); if isinstance(c_ops_markov, qt.Qobj):; self.c_ops_markov = [c_ops_markov]; else:; self.c_ops_markov = c_ops_markov. if S_matrix is None:; self.S_matrix = np.identity(len(self.L1)); else:; self.S_matrix = S_matrix; # create system identity superoperator; self.Id = qt.qeye(H_S.shape[0]); self.Id.dims = self.sysdims; self.Id = qt.sprepost(self.Id, self.Id); self.store_states = self.options.store_states; self.integrator = integrator; self.parallel = parallel. [docs] def propagator(self, t, tau, notrace=False):; """"""; Compute propagator for time t and time-delay tau. Parameters; -------",MatchSource.WIKI,docs/4.2/modules/qutip/nonmarkov/memorycascade.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/nonmarkov/memorycascade.html
https://qutip.org/docs/4.2/modules/qutip/nonmarkov/memorycascade.html:4777,Integrability,integrat,integrator,4777,"or'; as the integrator method. options : :class:`qutip.solver.Options`; Generic solver options.; """""". def __init__(self, H_S, L1, L2, S_matrix=None, c_ops_markov=None,; integrator='propagator', parallel=False, options=None):. if options is None:; self.options = qt.Options(); else:; self.options = options. self.H_S = H_S; self.sysdims = H_S.dims; if isinstance(L1, qt.Qobj):; self.L1 = [L1]; else:; self.L1 = L1; if isinstance(L2, qt.Qobj):; self.L2 = [L2]; else:; self.L2 = L2; if not len(self.L1) == len(self.L2):; raise ValueError('L1 and L2 has to be of equal length.'); if isinstance(c_ops_markov, qt.Qobj):; self.c_ops_markov = [c_ops_markov]; else:; self.c_ops_markov = c_ops_markov. if S_matrix is None:; self.S_matrix = np.identity(len(self.L1)); else:; self.S_matrix = S_matrix; # create system identity superoperator; self.Id = qt.qeye(H_S.shape[0]); self.Id.dims = self.sysdims; self.Id = qt.sprepost(self.Id, self.Id); self.store_states = self.options.store_states; self.integrator = integrator; self.parallel = parallel. [docs] def propagator(self, t, tau, notrace=False):; """"""; Compute propagator for time t and time-delay tau. Parameters; ----------; t : *float*; current time. tau : *float*; time-delay. notrace : *bool* {False}; If this optional is set to True, a propagator is returned for a; cascade of k systems, where :math:`(k-1) tau < t < k tau`.; If set to False (default), a generalized partial trace is performed; and a propagator for a single system is returned.; Returns; -------; : :class:`qutip.Qobj`; time-propagator for reduced system dynamics; """"""; k = int(t/tau)+1; s = t-(k-1)*tau; G1, E0 = _generator(k, self.H_S, self.L1, self.L2, self.S_matrix,; self.c_ops_markov); E = _integrate(G1, E0, 0., s, integrator=self.integrator,; parallel=self.parallel, opt=self.options); if k > 1:; G2, null = _generator(k-1, self.H_S, self.L1, self.L2,; self.S_matrix, self.c_ops_markov); G2 = qt.composite(G2, self.Id); E = _integrate(G2, E, s, tau, integrator=self.integrator, ",MatchSource.WIKI,docs/4.2/modules/qutip/nonmarkov/memorycascade.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/nonmarkov/memorycascade.html
https://qutip.org/docs/4.2/modules/qutip/nonmarkov/memorycascade.html:4790,Integrability,integrat,integrator,4790,"or'; as the integrator method. options : :class:`qutip.solver.Options`; Generic solver options.; """""". def __init__(self, H_S, L1, L2, S_matrix=None, c_ops_markov=None,; integrator='propagator', parallel=False, options=None):. if options is None:; self.options = qt.Options(); else:; self.options = options. self.H_S = H_S; self.sysdims = H_S.dims; if isinstance(L1, qt.Qobj):; self.L1 = [L1]; else:; self.L1 = L1; if isinstance(L2, qt.Qobj):; self.L2 = [L2]; else:; self.L2 = L2; if not len(self.L1) == len(self.L2):; raise ValueError('L1 and L2 has to be of equal length.'); if isinstance(c_ops_markov, qt.Qobj):; self.c_ops_markov = [c_ops_markov]; else:; self.c_ops_markov = c_ops_markov. if S_matrix is None:; self.S_matrix = np.identity(len(self.L1)); else:; self.S_matrix = S_matrix; # create system identity superoperator; self.Id = qt.qeye(H_S.shape[0]); self.Id.dims = self.sysdims; self.Id = qt.sprepost(self.Id, self.Id); self.store_states = self.options.store_states; self.integrator = integrator; self.parallel = parallel. [docs] def propagator(self, t, tau, notrace=False):; """"""; Compute propagator for time t and time-delay tau. Parameters; ----------; t : *float*; current time. tau : *float*; time-delay. notrace : *bool* {False}; If this optional is set to True, a propagator is returned for a; cascade of k systems, where :math:`(k-1) tau < t < k tau`.; If set to False (default), a generalized partial trace is performed; and a propagator for a single system is returned.; Returns; -------; : :class:`qutip.Qobj`; time-propagator for reduced system dynamics; """"""; k = int(t/tau)+1; s = t-(k-1)*tau; G1, E0 = _generator(k, self.H_S, self.L1, self.L2, self.S_matrix,; self.c_ops_markov); E = _integrate(G1, E0, 0., s, integrator=self.integrator,; parallel=self.parallel, opt=self.options); if k > 1:; G2, null = _generator(k-1, self.H_S, self.L1, self.L2,; self.S_matrix, self.c_ops_markov); G2 = qt.composite(G2, self.Id); E = _integrate(G2, E, s, tau, integrator=self.integrator, ",MatchSource.WIKI,docs/4.2/modules/qutip/nonmarkov/memorycascade.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/nonmarkov/memorycascade.html
https://qutip.org/docs/4.2/modules/qutip/nonmarkov/memorycascade.html:5528,Integrability,integrat,integrator,5528,"(len(self.L1)); else:; self.S_matrix = S_matrix; # create system identity superoperator; self.Id = qt.qeye(H_S.shape[0]); self.Id.dims = self.sysdims; self.Id = qt.sprepost(self.Id, self.Id); self.store_states = self.options.store_states; self.integrator = integrator; self.parallel = parallel. [docs] def propagator(self, t, tau, notrace=False):; """"""; Compute propagator for time t and time-delay tau. Parameters; ----------; t : *float*; current time. tau : *float*; time-delay. notrace : *bool* {False}; If this optional is set to True, a propagator is returned for a; cascade of k systems, where :math:`(k-1) tau < t < k tau`.; If set to False (default), a generalized partial trace is performed; and a propagator for a single system is returned.; Returns; -------; : :class:`qutip.Qobj`; time-propagator for reduced system dynamics; """"""; k = int(t/tau)+1; s = t-(k-1)*tau; G1, E0 = _generator(k, self.H_S, self.L1, self.L2, self.S_matrix,; self.c_ops_markov); E = _integrate(G1, E0, 0., s, integrator=self.integrator,; parallel=self.parallel, opt=self.options); if k > 1:; G2, null = _generator(k-1, self.H_S, self.L1, self.L2,; self.S_matrix, self.c_ops_markov); G2 = qt.composite(G2, self.Id); E = _integrate(G2, E, s, tau, integrator=self.integrator, ; parallel=self.parallel, opt=self.options); E.dims = E0.dims; if not notrace:; E = _genptrace(E, k); return E. [docs] def outfieldpropagator(self, blist, tlist, tau, c1=None, c2=None,; notrace=False):; """"""; Compute propagator for computing output field expectation values; <O_n(tn)...O_2(t2)O_1(t1)> for times t1,t2,... and; O_i = I, b_out, b_out^\dagger, b_loop, b_loop^\dagger. Parameters; ----------; blist : array_like; List of integers specifying the field operators:; 0: I (nothing); 1: b_out; 2: b_out^\dagger; 3: b_loop; 4: b_loop^\dagger. tlist : array_like; list of corresponding times t1,..,tn at which to evaluate the field; operators. tau : float; time-delay. c1 : :class:`qutip.Qobj`; system collapse operator that couples to t",MatchSource.WIKI,docs/4.2/modules/qutip/nonmarkov/memorycascade.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/nonmarkov/memorycascade.html
https://qutip.org/docs/4.2/modules/qutip/nonmarkov/memorycascade.html:5544,Integrability,integrat,integrator,5544,"elf.S_matrix = S_matrix; # create system identity superoperator; self.Id = qt.qeye(H_S.shape[0]); self.Id.dims = self.sysdims; self.Id = qt.sprepost(self.Id, self.Id); self.store_states = self.options.store_states; self.integrator = integrator; self.parallel = parallel. [docs] def propagator(self, t, tau, notrace=False):; """"""; Compute propagator for time t and time-delay tau. Parameters; ----------; t : *float*; current time. tau : *float*; time-delay. notrace : *bool* {False}; If this optional is set to True, a propagator is returned for a; cascade of k systems, where :math:`(k-1) tau < t < k tau`.; If set to False (default), a generalized partial trace is performed; and a propagator for a single system is returned.; Returns; -------; : :class:`qutip.Qobj`; time-propagator for reduced system dynamics; """"""; k = int(t/tau)+1; s = t-(k-1)*tau; G1, E0 = _generator(k, self.H_S, self.L1, self.L2, self.S_matrix,; self.c_ops_markov); E = _integrate(G1, E0, 0., s, integrator=self.integrator,; parallel=self.parallel, opt=self.options); if k > 1:; G2, null = _generator(k-1, self.H_S, self.L1, self.L2,; self.S_matrix, self.c_ops_markov); G2 = qt.composite(G2, self.Id); E = _integrate(G2, E, s, tau, integrator=self.integrator, ; parallel=self.parallel, opt=self.options); E.dims = E0.dims; if not notrace:; E = _genptrace(E, k); return E. [docs] def outfieldpropagator(self, blist, tlist, tau, c1=None, c2=None,; notrace=False):; """"""; Compute propagator for computing output field expectation values; <O_n(tn)...O_2(t2)O_1(t1)> for times t1,t2,... and; O_i = I, b_out, b_out^\dagger, b_loop, b_loop^\dagger. Parameters; ----------; blist : array_like; List of integers specifying the field operators:; 0: I (nothing); 1: b_out; 2: b_out^\dagger; 3: b_loop; 4: b_loop^\dagger. tlist : array_like; list of corresponding times t1,..,tn at which to evaluate the field; operators. tau : float; time-delay. c1 : :class:`qutip.Qobj`; system collapse operator that couples to the in-loop field in; que",MatchSource.WIKI,docs/4.2/modules/qutip/nonmarkov/memorycascade.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/nonmarkov/memorycascade.html
https://qutip.org/docs/4.2/modules/qutip/nonmarkov/memorycascade.html:5764,Integrability,integrat,integrator,5764,"ons.store_states; self.integrator = integrator; self.parallel = parallel. [docs] def propagator(self, t, tau, notrace=False):; """"""; Compute propagator for time t and time-delay tau. Parameters; ----------; t : *float*; current time. tau : *float*; time-delay. notrace : *bool* {False}; If this optional is set to True, a propagator is returned for a; cascade of k systems, where :math:`(k-1) tau < t < k tau`.; If set to False (default), a generalized partial trace is performed; and a propagator for a single system is returned.; Returns; -------; : :class:`qutip.Qobj`; time-propagator for reduced system dynamics; """"""; k = int(t/tau)+1; s = t-(k-1)*tau; G1, E0 = _generator(k, self.H_S, self.L1, self.L2, self.S_matrix,; self.c_ops_markov); E = _integrate(G1, E0, 0., s, integrator=self.integrator,; parallel=self.parallel, opt=self.options); if k > 1:; G2, null = _generator(k-1, self.H_S, self.L1, self.L2,; self.S_matrix, self.c_ops_markov); G2 = qt.composite(G2, self.Id); E = _integrate(G2, E, s, tau, integrator=self.integrator, ; parallel=self.parallel, opt=self.options); E.dims = E0.dims; if not notrace:; E = _genptrace(E, k); return E. [docs] def outfieldpropagator(self, blist, tlist, tau, c1=None, c2=None,; notrace=False):; """"""; Compute propagator for computing output field expectation values; <O_n(tn)...O_2(t2)O_1(t1)> for times t1,t2,... and; O_i = I, b_out, b_out^\dagger, b_loop, b_loop^\dagger. Parameters; ----------; blist : array_like; List of integers specifying the field operators:; 0: I (nothing); 1: b_out; 2: b_out^\dagger; 3: b_loop; 4: b_loop^\dagger. tlist : array_like; list of corresponding times t1,..,tn at which to evaluate the field; operators. tau : float; time-delay. c1 : :class:`qutip.Qobj`; system collapse operator that couples to the in-loop field in; question (only needs to be specified if self.L1 has more than one; element). c2 : :class:`qutip.Qobj`; system collapse operator that couples to the output field in; question (only needs to be specifie",MatchSource.WIKI,docs/4.2/modules/qutip/nonmarkov/memorycascade.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/nonmarkov/memorycascade.html
https://qutip.org/docs/4.2/modules/qutip/nonmarkov/memorycascade.html:5780,Integrability,integrat,integrator,5780,"grator; self.parallel = parallel. [docs] def propagator(self, t, tau, notrace=False):; """"""; Compute propagator for time t and time-delay tau. Parameters; ----------; t : *float*; current time. tau : *float*; time-delay. notrace : *bool* {False}; If this optional is set to True, a propagator is returned for a; cascade of k systems, where :math:`(k-1) tau < t < k tau`.; If set to False (default), a generalized partial trace is performed; and a propagator for a single system is returned.; Returns; -------; : :class:`qutip.Qobj`; time-propagator for reduced system dynamics; """"""; k = int(t/tau)+1; s = t-(k-1)*tau; G1, E0 = _generator(k, self.H_S, self.L1, self.L2, self.S_matrix,; self.c_ops_markov); E = _integrate(G1, E0, 0., s, integrator=self.integrator,; parallel=self.parallel, opt=self.options); if k > 1:; G2, null = _generator(k-1, self.H_S, self.L1, self.L2,; self.S_matrix, self.c_ops_markov); G2 = qt.composite(G2, self.Id); E = _integrate(G2, E, s, tau, integrator=self.integrator, ; parallel=self.parallel, opt=self.options); E.dims = E0.dims; if not notrace:; E = _genptrace(E, k); return E. [docs] def outfieldpropagator(self, blist, tlist, tau, c1=None, c2=None,; notrace=False):; """"""; Compute propagator for computing output field expectation values; <O_n(tn)...O_2(t2)O_1(t1)> for times t1,t2,... and; O_i = I, b_out, b_out^\dagger, b_loop, b_loop^\dagger. Parameters; ----------; blist : array_like; List of integers specifying the field operators:; 0: I (nothing); 1: b_out; 2: b_out^\dagger; 3: b_loop; 4: b_loop^\dagger. tlist : array_like; list of corresponding times t1,..,tn at which to evaluate the field; operators. tau : float; time-delay. c1 : :class:`qutip.Qobj`; system collapse operator that couples to the in-loop field in; question (only needs to be specified if self.L1 has more than one; element). c2 : :class:`qutip.Qobj`; system collapse operator that couples to the output field in; question (only needs to be specified if self.L2 has more than one; element",MatchSource.WIKI,docs/4.2/modules/qutip/nonmarkov/memorycascade.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/nonmarkov/memorycascade.html
https://qutip.org/docs/4.2/modules/qutip/nonmarkov/memorycascade.html:8003,Integrability,integrat,integrator,8003," generalized partial trace is performed; and a propagator for a single system is returned. Returns; -------; : :class:`qutip.Qobj`; time-propagator for computing field correlation function; """"""; if c1 is None and len(self.L1) == 1:; c1 = self.L1[0]; else:; raise ValueError('Argument c1 has to be specified when more than' +; 'one collapse operator couples to the feedback' +; 'loop.'); if c2 is None and len(self.L2) == 1:; c2 = self.L2[0]; else:; raise ValueError('Argument c1 has to be specified when more than' +; 'one collapse operator couples to the feedback' +; 'loop.'); klist = []; slist = []; for t in tlist:; klist.append(int(t/tau)+1); slist.append(t-(klist[-1]-1)*tau); kmax = max(klist); zipped = sorted(zip(slist, klist, blist)); slist = [s for (s, k, b) in zipped]; klist = [k for (s, k, b) in zipped]; blist = [b for (s, k, b) in zipped]. G1, E0 = _generator(kmax, self.H_S, self.L1, self.L2, self.S_matrix,; self.c_ops_markov); sprev = 0.; E = E0; for i, s in enumerate(slist):; E = _integrate(G1, E, sprev, s, integrator=self.integrator,; parallel=self.parallel, opt=self.options); if klist[i] == 1:; l1 = 0.*qt.Qobj(); else:; l1 = _localop(c1, klist[i]-1, kmax); l2 = _localop(c2, klist[i], kmax); if blist[i] == 0:; superop = self.Id; elif blist[i] == 1:; superop = qt.spre(l1+l2); elif blist[i] == 2:; superop = qt.spost(l1.dag()+l2.dag()); elif blist[i] == 3:; superop = qt.spre(l1); elif blist[i] == 4:; superop = qt.spost(l1.dag()); else:; raise ValueError('Allowed values in blist are 0, 1, 2, 3 ' +; 'and 4.'); superop.dims = E.dims; E = superop*E; sprev = s; E = _integrate(G1, E, slist[-1], tau, integrator=self.integrator,; parallel=self.parallel, opt=self.options). E.dims = E0.dims; if not notrace:; E = _genptrace(E, kmax); return E. [docs] def rhot(self, rho0, t, tau):; """"""; Compute the reduced system density matrix :math:`\\rho(t)`. Parameters; ----------; rho0 : :class:`qutip.Qobj`; initial density matrix or state vector (ket). t : float; current time. tau : fl",MatchSource.WIKI,docs/4.2/modules/qutip/nonmarkov/memorycascade.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/nonmarkov/memorycascade.html
https://qutip.org/docs/4.2/modules/qutip/nonmarkov/memorycascade.html:8019,Integrability,integrat,integrator,8019,"for a single system is returned. Returns; -------; : :class:`qutip.Qobj`; time-propagator for computing field correlation function; """"""; if c1 is None and len(self.L1) == 1:; c1 = self.L1[0]; else:; raise ValueError('Argument c1 has to be specified when more than' +; 'one collapse operator couples to the feedback' +; 'loop.'); if c2 is None and len(self.L2) == 1:; c2 = self.L2[0]; else:; raise ValueError('Argument c1 has to be specified when more than' +; 'one collapse operator couples to the feedback' +; 'loop.'); klist = []; slist = []; for t in tlist:; klist.append(int(t/tau)+1); slist.append(t-(klist[-1]-1)*tau); kmax = max(klist); zipped = sorted(zip(slist, klist, blist)); slist = [s for (s, k, b) in zipped]; klist = [k for (s, k, b) in zipped]; blist = [b for (s, k, b) in zipped]. G1, E0 = _generator(kmax, self.H_S, self.L1, self.L2, self.S_matrix,; self.c_ops_markov); sprev = 0.; E = E0; for i, s in enumerate(slist):; E = _integrate(G1, E, sprev, s, integrator=self.integrator,; parallel=self.parallel, opt=self.options); if klist[i] == 1:; l1 = 0.*qt.Qobj(); else:; l1 = _localop(c1, klist[i]-1, kmax); l2 = _localop(c2, klist[i], kmax); if blist[i] == 0:; superop = self.Id; elif blist[i] == 1:; superop = qt.spre(l1+l2); elif blist[i] == 2:; superop = qt.spost(l1.dag()+l2.dag()); elif blist[i] == 3:; superop = qt.spre(l1); elif blist[i] == 4:; superop = qt.spost(l1.dag()); else:; raise ValueError('Allowed values in blist are 0, 1, 2, 3 ' +; 'and 4.'); superop.dims = E.dims; E = superop*E; sprev = s; E = _integrate(G1, E, slist[-1], tau, integrator=self.integrator,; parallel=self.parallel, opt=self.options). E.dims = E0.dims; if not notrace:; E = _genptrace(E, kmax); return E. [docs] def rhot(self, rho0, t, tau):; """"""; Compute the reduced system density matrix :math:`\\rho(t)`. Parameters; ----------; rho0 : :class:`qutip.Qobj`; initial density matrix or state vector (ket). t : float; current time. tau : float; time-delay. Returns; -------; : :class:`qutip.Qobj`; ",MatchSource.WIKI,docs/4.2/modules/qutip/nonmarkov/memorycascade.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/nonmarkov/memorycascade.html
https://qutip.org/docs/4.2/modules/qutip/nonmarkov/memorycascade.html:8599,Integrability,integrat,integrator,8599," []; for t in tlist:; klist.append(int(t/tau)+1); slist.append(t-(klist[-1]-1)*tau); kmax = max(klist); zipped = sorted(zip(slist, klist, blist)); slist = [s for (s, k, b) in zipped]; klist = [k for (s, k, b) in zipped]; blist = [b for (s, k, b) in zipped]. G1, E0 = _generator(kmax, self.H_S, self.L1, self.L2, self.S_matrix,; self.c_ops_markov); sprev = 0.; E = E0; for i, s in enumerate(slist):; E = _integrate(G1, E, sprev, s, integrator=self.integrator,; parallel=self.parallel, opt=self.options); if klist[i] == 1:; l1 = 0.*qt.Qobj(); else:; l1 = _localop(c1, klist[i]-1, kmax); l2 = _localop(c2, klist[i], kmax); if blist[i] == 0:; superop = self.Id; elif blist[i] == 1:; superop = qt.spre(l1+l2); elif blist[i] == 2:; superop = qt.spost(l1.dag()+l2.dag()); elif blist[i] == 3:; superop = qt.spre(l1); elif blist[i] == 4:; superop = qt.spost(l1.dag()); else:; raise ValueError('Allowed values in blist are 0, 1, 2, 3 ' +; 'and 4.'); superop.dims = E.dims; E = superop*E; sprev = s; E = _integrate(G1, E, slist[-1], tau, integrator=self.integrator,; parallel=self.parallel, opt=self.options). E.dims = E0.dims; if not notrace:; E = _genptrace(E, kmax); return E. [docs] def rhot(self, rho0, t, tau):; """"""; Compute the reduced system density matrix :math:`\\rho(t)`. Parameters; ----------; rho0 : :class:`qutip.Qobj`; initial density matrix or state vector (ket). t : float; current time. tau : float; time-delay. Returns; -------; : :class:`qutip.Qobj`; density matrix at time :math:`t`; """"""; if qt.isket(rho0):; rho0 = qt.ket2dm(rho0). E = self.propagator(t, tau); rhovec = qt.operator_to_vector(rho0); return qt.vector_to_operator(E*rhovec). [docs] def outfieldcorr(self, rho0, blist, tlist, tau, c1=None, c2=None):; """"""; Compute output field expectation value; <O_n(tn)...O_2(t2)O_1(t1)> for times t1,t2,... and; O_i = I, b_out, b_out^\dagger, b_loop, b_loop^\dagger. Parameters; ----------; rho0 : :class:`qutip.Qobj`; initial density matrix or state vector (ket). blist : array_like; List",MatchSource.WIKI,docs/4.2/modules/qutip/nonmarkov/memorycascade.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/nonmarkov/memorycascade.html
https://qutip.org/docs/4.2/modules/qutip/nonmarkov/memorycascade.html:8615,Integrability,integrat,integrator,8615,"append(t-(klist[-1]-1)*tau); kmax = max(klist); zipped = sorted(zip(slist, klist, blist)); slist = [s for (s, k, b) in zipped]; klist = [k for (s, k, b) in zipped]; blist = [b for (s, k, b) in zipped]. G1, E0 = _generator(kmax, self.H_S, self.L1, self.L2, self.S_matrix,; self.c_ops_markov); sprev = 0.; E = E0; for i, s in enumerate(slist):; E = _integrate(G1, E, sprev, s, integrator=self.integrator,; parallel=self.parallel, opt=self.options); if klist[i] == 1:; l1 = 0.*qt.Qobj(); else:; l1 = _localop(c1, klist[i]-1, kmax); l2 = _localop(c2, klist[i], kmax); if blist[i] == 0:; superop = self.Id; elif blist[i] == 1:; superop = qt.spre(l1+l2); elif blist[i] == 2:; superop = qt.spost(l1.dag()+l2.dag()); elif blist[i] == 3:; superop = qt.spre(l1); elif blist[i] == 4:; superop = qt.spost(l1.dag()); else:; raise ValueError('Allowed values in blist are 0, 1, 2, 3 ' +; 'and 4.'); superop.dims = E.dims; E = superop*E; sprev = s; E = _integrate(G1, E, slist[-1], tau, integrator=self.integrator,; parallel=self.parallel, opt=self.options). E.dims = E0.dims; if not notrace:; E = _genptrace(E, kmax); return E. [docs] def rhot(self, rho0, t, tau):; """"""; Compute the reduced system density matrix :math:`\\rho(t)`. Parameters; ----------; rho0 : :class:`qutip.Qobj`; initial density matrix or state vector (ket). t : float; current time. tau : float; time-delay. Returns; -------; : :class:`qutip.Qobj`; density matrix at time :math:`t`; """"""; if qt.isket(rho0):; rho0 = qt.ket2dm(rho0). E = self.propagator(t, tau); rhovec = qt.operator_to_vector(rho0); return qt.vector_to_operator(E*rhovec). [docs] def outfieldcorr(self, rho0, blist, tlist, tau, c1=None, c2=None):; """"""; Compute output field expectation value; <O_n(tn)...O_2(t2)O_1(t1)> for times t1,t2,... and; O_i = I, b_out, b_out^\dagger, b_loop, b_loop^\dagger. Parameters; ----------; rho0 : :class:`qutip.Qobj`; initial density matrix or state vector (ket). blist : array_like; List of integers specifying the field operators:; 0: I (nothi",MatchSource.WIKI,docs/4.2/modules/qutip/nonmarkov/memorycascade.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/nonmarkov/memorycascade.html
https://qutip.org/docs/4.2/modules/qutip/nonmarkov/memorycascade.html:12210,Integrability,integrat,integrator,12210,"+1)); return E. def _generator(k, H, L1, L2, S=None, c_ops_markov=None):; """"""; Create a Liouvillian for a cascaded chain of k system copies; """"""; id = qt.qeye(H.dims[0][0]); Id = qt.sprepost(id, id); if S is None:; S = np.identity(len(L1)); # create Lindbladian; L = qt.Qobj(); E0 = Id; # first system; L += qt.liouvillian(None, [_localop(c, 1, k) for c in L2]); for l in range(1, k):; # Identiy superoperator; E0 = qt.composite(E0, Id); # Bare Hamiltonian; Hl = _localop(H, l, k); L += qt.liouvillian(Hl, []); # Markovian Decay channels; if c_ops_markov is not None:; for c in c_ops_markov:; cl = _localop(c, l, k); L += qt.liouvillian(None, [cl]); # Cascade coupling; c1 = np.array([_localop(c, l, k) for c in L1]); c2 = np.array([_localop(c, l+1, k) for c in L2]); c2dag = np.array([c.dag() for c in c2]); Hcasc = -0.5j*np.dot(c2dag, np.dot(S, c1)); Hcasc += Hcasc.dag(); Lvec = c2 + np.dot(S, c1); L += qt.liouvillian(Hcasc, [c for c in Lvec]); # last system; L += qt.liouvillian(_localop(H, k, k), [_localop(c, k, k) for c in L1]); if c_ops_markov is not None:; for c in c_ops_markov:; cl = _localop(c, k, k); L += qt.liouvillian(None, [cl]); E0.dims = L.dims; # return generator and identity superop E0; return L, E0. def _integrate(L, E0, ti, tf, integrator='propagator', parallel=False,; opt=qt.Options()):; """"""; Basic ode integrator; """"""; if tf > ti:; if integrator == 'mesolve':; if parallel:; warnings.warn('parallelization not implemented for ""mesolve""'); opt.store_final_state = True; sol = qt.mesolve(L, E0, [ti, tf], [], [], options=opt); return sol.final_state; elif integrator == 'propagator':; return qt.propagator(L, (tf-ti), [], [], parallel=parallel,; options=opt)*E0; else:; raise ValueError('integrator keyword must be either ""propagator""' +; 'or ""mesolve""'); else:; return E0. Â© Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, and A.L. Grimsmo.; Last updated on Jan 17, 2018. . Built with Sphinx using a theme provided by Read the Docs. . ",MatchSource.WIKI,docs/4.2/modules/qutip/nonmarkov/memorycascade.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/nonmarkov/memorycascade.html
https://qutip.org/docs/4.2/modules/qutip/nonmarkov/memorycascade.html:12287,Integrability,integrat,integrator,12287,"+1)); return E. def _generator(k, H, L1, L2, S=None, c_ops_markov=None):; """"""; Create a Liouvillian for a cascaded chain of k system copies; """"""; id = qt.qeye(H.dims[0][0]); Id = qt.sprepost(id, id); if S is None:; S = np.identity(len(L1)); # create Lindbladian; L = qt.Qobj(); E0 = Id; # first system; L += qt.liouvillian(None, [_localop(c, 1, k) for c in L2]); for l in range(1, k):; # Identiy superoperator; E0 = qt.composite(E0, Id); # Bare Hamiltonian; Hl = _localop(H, l, k); L += qt.liouvillian(Hl, []); # Markovian Decay channels; if c_ops_markov is not None:; for c in c_ops_markov:; cl = _localop(c, l, k); L += qt.liouvillian(None, [cl]); # Cascade coupling; c1 = np.array([_localop(c, l, k) for c in L1]); c2 = np.array([_localop(c, l+1, k) for c in L2]); c2dag = np.array([c.dag() for c in c2]); Hcasc = -0.5j*np.dot(c2dag, np.dot(S, c1)); Hcasc += Hcasc.dag(); Lvec = c2 + np.dot(S, c1); L += qt.liouvillian(Hcasc, [c for c in Lvec]); # last system; L += qt.liouvillian(_localop(H, k, k), [_localop(c, k, k) for c in L1]); if c_ops_markov is not None:; for c in c_ops_markov:; cl = _localop(c, k, k); L += qt.liouvillian(None, [cl]); E0.dims = L.dims; # return generator and identity superop E0; return L, E0. def _integrate(L, E0, ti, tf, integrator='propagator', parallel=False,; opt=qt.Options()):; """"""; Basic ode integrator; """"""; if tf > ti:; if integrator == 'mesolve':; if parallel:; warnings.warn('parallelization not implemented for ""mesolve""'); opt.store_final_state = True; sol = qt.mesolve(L, E0, [ti, tf], [], [], options=opt); return sol.final_state; elif integrator == 'propagator':; return qt.propagator(L, (tf-ti), [], [], parallel=parallel,; options=opt)*E0; else:; raise ValueError('integrator keyword must be either ""propagator""' +; 'or ""mesolve""'); else:; return E0. Â© Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, and A.L. Grimsmo.; Last updated on Jan 17, 2018. . Built with Sphinx using a theme provided by Read the Docs. . ",MatchSource.WIKI,docs/4.2/modules/qutip/nonmarkov/memorycascade.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/nonmarkov/memorycascade.html
https://qutip.org/docs/4.2/modules/qutip/nonmarkov/memorycascade.html:12320,Integrability,integrat,integrator,12320,"+1)); return E. def _generator(k, H, L1, L2, S=None, c_ops_markov=None):; """"""; Create a Liouvillian for a cascaded chain of k system copies; """"""; id = qt.qeye(H.dims[0][0]); Id = qt.sprepost(id, id); if S is None:; S = np.identity(len(L1)); # create Lindbladian; L = qt.Qobj(); E0 = Id; # first system; L += qt.liouvillian(None, [_localop(c, 1, k) for c in L2]); for l in range(1, k):; # Identiy superoperator; E0 = qt.composite(E0, Id); # Bare Hamiltonian; Hl = _localop(H, l, k); L += qt.liouvillian(Hl, []); # Markovian Decay channels; if c_ops_markov is not None:; for c in c_ops_markov:; cl = _localop(c, l, k); L += qt.liouvillian(None, [cl]); # Cascade coupling; c1 = np.array([_localop(c, l, k) for c in L1]); c2 = np.array([_localop(c, l+1, k) for c in L2]); c2dag = np.array([c.dag() for c in c2]); Hcasc = -0.5j*np.dot(c2dag, np.dot(S, c1)); Hcasc += Hcasc.dag(); Lvec = c2 + np.dot(S, c1); L += qt.liouvillian(Hcasc, [c for c in Lvec]); # last system; L += qt.liouvillian(_localop(H, k, k), [_localop(c, k, k) for c in L1]); if c_ops_markov is not None:; for c in c_ops_markov:; cl = _localop(c, k, k); L += qt.liouvillian(None, [cl]); E0.dims = L.dims; # return generator and identity superop E0; return L, E0. def _integrate(L, E0, ti, tf, integrator='propagator', parallel=False,; opt=qt.Options()):; """"""; Basic ode integrator; """"""; if tf > ti:; if integrator == 'mesolve':; if parallel:; warnings.warn('parallelization not implemented for ""mesolve""'); opt.store_final_state = True; sol = qt.mesolve(L, E0, [ti, tf], [], [], options=opt); return sol.final_state; elif integrator == 'propagator':; return qt.propagator(L, (tf-ti), [], [], parallel=parallel,; options=opt)*E0; else:; raise ValueError('integrator keyword must be either ""propagator""' +; 'or ""mesolve""'); else:; return E0. Â© Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, and A.L. Grimsmo.; Last updated on Jan 17, 2018. . Built with Sphinx using a theme provided by Read the Docs. . ",MatchSource.WIKI,docs/4.2/modules/qutip/nonmarkov/memorycascade.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/nonmarkov/memorycascade.html
https://qutip.org/docs/4.2/modules/qutip/nonmarkov/memorycascade.html:12539,Integrability,integrat,integrator,12539,"+1)); return E. def _generator(k, H, L1, L2, S=None, c_ops_markov=None):; """"""; Create a Liouvillian for a cascaded chain of k system copies; """"""; id = qt.qeye(H.dims[0][0]); Id = qt.sprepost(id, id); if S is None:; S = np.identity(len(L1)); # create Lindbladian; L = qt.Qobj(); E0 = Id; # first system; L += qt.liouvillian(None, [_localop(c, 1, k) for c in L2]); for l in range(1, k):; # Identiy superoperator; E0 = qt.composite(E0, Id); # Bare Hamiltonian; Hl = _localop(H, l, k); L += qt.liouvillian(Hl, []); # Markovian Decay channels; if c_ops_markov is not None:; for c in c_ops_markov:; cl = _localop(c, l, k); L += qt.liouvillian(None, [cl]); # Cascade coupling; c1 = np.array([_localop(c, l, k) for c in L1]); c2 = np.array([_localop(c, l+1, k) for c in L2]); c2dag = np.array([c.dag() for c in c2]); Hcasc = -0.5j*np.dot(c2dag, np.dot(S, c1)); Hcasc += Hcasc.dag(); Lvec = c2 + np.dot(S, c1); L += qt.liouvillian(Hcasc, [c for c in Lvec]); # last system; L += qt.liouvillian(_localop(H, k, k), [_localop(c, k, k) for c in L1]); if c_ops_markov is not None:; for c in c_ops_markov:; cl = _localop(c, k, k); L += qt.liouvillian(None, [cl]); E0.dims = L.dims; # return generator and identity superop E0; return L, E0. def _integrate(L, E0, ti, tf, integrator='propagator', parallel=False,; opt=qt.Options()):; """"""; Basic ode integrator; """"""; if tf > ti:; if integrator == 'mesolve':; if parallel:; warnings.warn('parallelization not implemented for ""mesolve""'); opt.store_final_state = True; sol = qt.mesolve(L, E0, [ti, tf], [], [], options=opt); return sol.final_state; elif integrator == 'propagator':; return qt.propagator(L, (tf-ti), [], [], parallel=parallel,; options=opt)*E0; else:; raise ValueError('integrator keyword must be either ""propagator""' +; 'or ""mesolve""'); else:; return E0. Â© Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, and A.L. Grimsmo.; Last updated on Jan 17, 2018. . Built with Sphinx using a theme provided by Read the Docs. . ",MatchSource.WIKI,docs/4.2/modules/qutip/nonmarkov/memorycascade.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/nonmarkov/memorycascade.html
https://qutip.org/docs/4.2/modules/qutip/nonmarkov/memorycascade.html:12671,Integrability,integrat,integrator,12671,"+1)); return E. def _generator(k, H, L1, L2, S=None, c_ops_markov=None):; """"""; Create a Liouvillian for a cascaded chain of k system copies; """"""; id = qt.qeye(H.dims[0][0]); Id = qt.sprepost(id, id); if S is None:; S = np.identity(len(L1)); # create Lindbladian; L = qt.Qobj(); E0 = Id; # first system; L += qt.liouvillian(None, [_localop(c, 1, k) for c in L2]); for l in range(1, k):; # Identiy superoperator; E0 = qt.composite(E0, Id); # Bare Hamiltonian; Hl = _localop(H, l, k); L += qt.liouvillian(Hl, []); # Markovian Decay channels; if c_ops_markov is not None:; for c in c_ops_markov:; cl = _localop(c, l, k); L += qt.liouvillian(None, [cl]); # Cascade coupling; c1 = np.array([_localop(c, l, k) for c in L1]); c2 = np.array([_localop(c, l+1, k) for c in L2]); c2dag = np.array([c.dag() for c in c2]); Hcasc = -0.5j*np.dot(c2dag, np.dot(S, c1)); Hcasc += Hcasc.dag(); Lvec = c2 + np.dot(S, c1); L += qt.liouvillian(Hcasc, [c for c in Lvec]); # last system; L += qt.liouvillian(_localop(H, k, k), [_localop(c, k, k) for c in L1]); if c_ops_markov is not None:; for c in c_ops_markov:; cl = _localop(c, k, k); L += qt.liouvillian(None, [cl]); E0.dims = L.dims; # return generator and identity superop E0; return L, E0. def _integrate(L, E0, ti, tf, integrator='propagator', parallel=False,; opt=qt.Options()):; """"""; Basic ode integrator; """"""; if tf > ti:; if integrator == 'mesolve':; if parallel:; warnings.warn('parallelization not implemented for ""mesolve""'); opt.store_final_state = True; sol = qt.mesolve(L, E0, [ti, tf], [], [], options=opt); return sol.final_state; elif integrator == 'propagator':; return qt.propagator(L, (tf-ti), [], [], parallel=parallel,; options=opt)*E0; else:; raise ValueError('integrator keyword must be either ""propagator""' +; 'or ""mesolve""'); else:; return E0. Â© Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, and A.L. Grimsmo.; Last updated on Jan 17, 2018. . Built with Sphinx using a theme provided by Read the Docs. . ",MatchSource.WIKI,docs/4.2/modules/qutip/nonmarkov/memorycascade.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/nonmarkov/memorycascade.html
https://qutip.org/docs/4.2/modules/qutip/nonmarkov/memorycascade.html:2877,Modifiability,coupling,coupling,2877,"LUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE; # OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.; ###############################################################################. # @author: Arne L. Grimsmo; # @email1: arne.grimsmo@gmail.com; # @organization: University of Sherbrooke. """"""; This module is an implementation of the method introduced in [1], for; solving open quantum systems subject to coherent feedback with a single; discrete time-delay. This method is referred to as the ``memory cascade''; method in qutip. [1] Arne L. Grimsmo, Phys. Rev. Lett 115, 060402 (2015); """""". import numpy as np; import warnings. import qutip as qt. [docs]class MemoryCascade:; """"""Class for running memory cascade simulations of open quantum systems; with time-delayed coherent feedback. Attributes; ----------; H_S : :class:`qutip.Qobj`; System Hamiltonian (can also be a Liouvillian). L1 : :class:`qutip.Qobj` / list of :class:`qutip.Qobj`; System operators coupling into the feedback loop. Can be a single; operator or a list of operators. L2 : :class:`qutip.Qobj` / list of :class:`qutip.Qobj`; System operators coupling out of the feedback loop. Can be a single; operator or a list of operators. L2 must have the same length as L1. S_matrix: *array*; S matrix describing which operators in L1 are coupled to which; operators in L2 by the feedback channel. Defaults to an n by n identity; matrix where n is the number of elements in L1/L2. c_ops_markov : :class:`qutip.Qobj` / list of :class:`qutip.Qobj`; Decay operators describing conventional Markovian decay channels.; Can be a single operator or a list of operators. integrator : str {'propagator', 'mesolve'}; Integrator method to use. Defaults to 'propagator' which tends to be ; faster for long times (i.e., large Hilbert space). parallel : bool; Run integrator in parallel if True. Only implemented for 'propagator'; as the integrator method. options : :class:`qutip.solver.Options`; Generic solver op",MatchSource.WIKI,docs/4.2/modules/qutip/nonmarkov/memorycascade.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/nonmarkov/memorycascade.html
https://qutip.org/docs/4.2/modules/qutip/nonmarkov/memorycascade.html:3033,Modifiability,coupling,coupling,3033,"#############################################################. # @author: Arne L. Grimsmo; # @email1: arne.grimsmo@gmail.com; # @organization: University of Sherbrooke. """"""; This module is an implementation of the method introduced in [1], for; solving open quantum systems subject to coherent feedback with a single; discrete time-delay. This method is referred to as the ``memory cascade''; method in qutip. [1] Arne L. Grimsmo, Phys. Rev. Lett 115, 060402 (2015); """""". import numpy as np; import warnings. import qutip as qt. [docs]class MemoryCascade:; """"""Class for running memory cascade simulations of open quantum systems; with time-delayed coherent feedback. Attributes; ----------; H_S : :class:`qutip.Qobj`; System Hamiltonian (can also be a Liouvillian). L1 : :class:`qutip.Qobj` / list of :class:`qutip.Qobj`; System operators coupling into the feedback loop. Can be a single; operator or a list of operators. L2 : :class:`qutip.Qobj` / list of :class:`qutip.Qobj`; System operators coupling out of the feedback loop. Can be a single; operator or a list of operators. L2 must have the same length as L1. S_matrix: *array*; S matrix describing which operators in L1 are coupled to which; operators in L2 by the feedback channel. Defaults to an n by n identity; matrix where n is the number of elements in L1/L2. c_ops_markov : :class:`qutip.Qobj` / list of :class:`qutip.Qobj`; Decay operators describing conventional Markovian decay channels.; Can be a single operator or a list of operators. integrator : str {'propagator', 'mesolve'}; Integrator method to use. Defaults to 'propagator' which tends to be ; faster for long times (i.e., large Hilbert space). parallel : bool; Run integrator in parallel if True. Only implemented for 'propagator'; as the integrator method. options : :class:`qutip.solver.Options`; Generic solver options.; """""". def __init__(self, H_S, L1, L2, S_matrix=None, c_ops_markov=None,; integrator='propagator', parallel=False, options=None):. if options is None:;",MatchSource.WIKI,docs/4.2/modules/qutip/nonmarkov/memorycascade.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/nonmarkov/memorycascade.html
https://qutip.org/docs/4.2/modules/qutip/nonmarkov/memorycascade.html:11616,Modifiability,coupling,coupling,11616,".dims = op.dims; for i in range(1, l):; h = qt.tensor(I, h); for i in range(l+1, k+1):; h = qt.tensor(h, I); return h. def _genptrace(E, k):; """"""; Perform a gneralized partial trace on a superoperator E, tracing out all; subsystems but one.; """"""; for l in range(k-1):; nsys = len(E.dims[0][0]); E = qt.tensor_contract(E, (0, 2*nsys+1), (nsys, 3*nsys+1)); return E. def _generator(k, H, L1, L2, S=None, c_ops_markov=None):; """"""; Create a Liouvillian for a cascaded chain of k system copies; """"""; id = qt.qeye(H.dims[0][0]); Id = qt.sprepost(id, id); if S is None:; S = np.identity(len(L1)); # create Lindbladian; L = qt.Qobj(); E0 = Id; # first system; L += qt.liouvillian(None, [_localop(c, 1, k) for c in L2]); for l in range(1, k):; # Identiy superoperator; E0 = qt.composite(E0, Id); # Bare Hamiltonian; Hl = _localop(H, l, k); L += qt.liouvillian(Hl, []); # Markovian Decay channels; if c_ops_markov is not None:; for c in c_ops_markov:; cl = _localop(c, l, k); L += qt.liouvillian(None, [cl]); # Cascade coupling; c1 = np.array([_localop(c, l, k) for c in L1]); c2 = np.array([_localop(c, l+1, k) for c in L2]); c2dag = np.array([c.dag() for c in c2]); Hcasc = -0.5j*np.dot(c2dag, np.dot(S, c1)); Hcasc += Hcasc.dag(); Lvec = c2 + np.dot(S, c1); L += qt.liouvillian(Hcasc, [c for c in Lvec]); # last system; L += qt.liouvillian(_localop(H, k, k), [_localop(c, k, k) for c in L1]); if c_ops_markov is not None:; for c in c_ops_markov:; cl = _localop(c, k, k); L += qt.liouvillian(None, [cl]); E0.dims = L.dims; # return generator and identity superop E0; return L, E0. def _integrate(L, E0, ti, tf, integrator='propagator', parallel=False,; opt=qt.Options()):; """"""; Basic ode integrator; """"""; if tf > ti:; if integrator == 'mesolve':; if parallel:; warnings.warn('parallelization not implemented for ""mesolve""'); opt.store_final_state = True; sol = qt.mesolve(L, E0, [ti, tf], [], [], options=opt); return sol.final_state; elif integrator == 'propagator':; return qt.propagator(L, (tf-ti), [], [],",MatchSource.WIKI,docs/4.2/modules/qutip/nonmarkov/memorycascade.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/nonmarkov/memorycascade.html
https://qutip.org/docs/4.2/modules/qutip/nonmarkov/memorycascade.html:5223,Performance,perform,performed,5223," qt.Qobj):; self.L2 = [L2]; else:; self.L2 = L2; if not len(self.L1) == len(self.L2):; raise ValueError('L1 and L2 has to be of equal length.'); if isinstance(c_ops_markov, qt.Qobj):; self.c_ops_markov = [c_ops_markov]; else:; self.c_ops_markov = c_ops_markov. if S_matrix is None:; self.S_matrix = np.identity(len(self.L1)); else:; self.S_matrix = S_matrix; # create system identity superoperator; self.Id = qt.qeye(H_S.shape[0]); self.Id.dims = self.sysdims; self.Id = qt.sprepost(self.Id, self.Id); self.store_states = self.options.store_states; self.integrator = integrator; self.parallel = parallel. [docs] def propagator(self, t, tau, notrace=False):; """"""; Compute propagator for time t and time-delay tau. Parameters; ----------; t : *float*; current time. tau : *float*; time-delay. notrace : *bool* {False}; If this optional is set to True, a propagator is returned for a; cascade of k systems, where :math:`(k-1) tau < t < k tau`.; If set to False (default), a generalized partial trace is performed; and a propagator for a single system is returned.; Returns; -------; : :class:`qutip.Qobj`; time-propagator for reduced system dynamics; """"""; k = int(t/tau)+1; s = t-(k-1)*tau; G1, E0 = _generator(k, self.H_S, self.L1, self.L2, self.S_matrix,; self.c_ops_markov); E = _integrate(G1, E0, 0., s, integrator=self.integrator,; parallel=self.parallel, opt=self.options); if k > 1:; G2, null = _generator(k-1, self.H_S, self.L1, self.L2,; self.S_matrix, self.c_ops_markov); G2 = qt.composite(G2, self.Id); E = _integrate(G2, E, s, tau, integrator=self.integrator, ; parallel=self.parallel, opt=self.options); E.dims = E0.dims; if not notrace:; E = _genptrace(E, k); return E. [docs] def outfieldpropagator(self, blist, tlist, tau, c1=None, c2=None,; notrace=False):; """"""; Compute propagator for computing output field expectation values; <O_n(tn)...O_2(t2)O_1(t1)> for times t1,t2,... and; O_i = I, b_out, b_out^\dagger, b_loop, b_loop^\dagger. Parameters; ----------; blist : array_like; List o",MatchSource.WIKI,docs/4.2/modules/qutip/nonmarkov/memorycascade.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/nonmarkov/memorycascade.html
https://qutip.org/docs/4.2/modules/qutip/nonmarkov/memorycascade.html:7004,Performance,perform,performed,7004,"ute propagator for computing output field expectation values; <O_n(tn)...O_2(t2)O_1(t1)> for times t1,t2,... and; O_i = I, b_out, b_out^\dagger, b_loop, b_loop^\dagger. Parameters; ----------; blist : array_like; List of integers specifying the field operators:; 0: I (nothing); 1: b_out; 2: b_out^\dagger; 3: b_loop; 4: b_loop^\dagger. tlist : array_like; list of corresponding times t1,..,tn at which to evaluate the field; operators. tau : float; time-delay. c1 : :class:`qutip.Qobj`; system collapse operator that couples to the in-loop field in; question (only needs to be specified if self.L1 has more than one; element). c2 : :class:`qutip.Qobj`; system collapse operator that couples to the output field in; question (only needs to be specified if self.L2 has more than one; element). notrace : bool {False}; If this optional is set to True, a propagator is returned for a; cascade of k systems, where :math:`(k-1) tau < t < k tau`.; If set to False (default), a generalized partial trace is performed; and a propagator for a single system is returned. Returns; -------; : :class:`qutip.Qobj`; time-propagator for computing field correlation function; """"""; if c1 is None and len(self.L1) == 1:; c1 = self.L1[0]; else:; raise ValueError('Argument c1 has to be specified when more than' +; 'one collapse operator couples to the feedback' +; 'loop.'); if c2 is None and len(self.L2) == 1:; c2 = self.L2[0]; else:; raise ValueError('Argument c1 has to be specified when more than' +; 'one collapse operator couples to the feedback' +; 'loop.'); klist = []; slist = []; for t in tlist:; klist.append(int(t/tau)+1); slist.append(t-(klist[-1]-1)*tau); kmax = max(klist); zipped = sorted(zip(slist, klist, blist)); slist = [s for (s, k, b) in zipped]; klist = [k for (s, k, b) in zipped]; blist = [b for (s, k, b) in zipped]. G1, E0 = _generator(kmax, self.H_S, self.L1, self.L2, self.S_matrix,; self.c_ops_markov); sprev = 0.; E = E0; for i, s in enumerate(slist):; E = _integrate(G1, E, sprev, s, i",MatchSource.WIKI,docs/4.2/modules/qutip/nonmarkov/memorycascade.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/nonmarkov/memorycascade.html
https://qutip.org/docs/4.2/modules/qutip/nonmarkov/memorycascade.html:2332,Usability,feedback,feedback,2332,"TRIBUTORS; # ""AS IS"" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT; # LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A; # PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT; # HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,; # SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT; # LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,; # DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY; # THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT; # (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE; # OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.; ###############################################################################. # @author: Arne L. Grimsmo; # @email1: arne.grimsmo@gmail.com; # @organization: University of Sherbrooke. """"""; This module is an implementation of the method introduced in [1], for; solving open quantum systems subject to coherent feedback with a single; discrete time-delay. This method is referred to as the ``memory cascade''; method in qutip. [1] Arne L. Grimsmo, Phys. Rev. Lett 115, 060402 (2015); """""". import numpy as np; import warnings. import qutip as qt. [docs]class MemoryCascade:; """"""Class for running memory cascade simulations of open quantum systems; with time-delayed coherent feedback. Attributes; ----------; H_S : :class:`qutip.Qobj`; System Hamiltonian (can also be a Liouvillian). L1 : :class:`qutip.Qobj` / list of :class:`qutip.Qobj`; System operators coupling into the feedback loop. Can be a single; operator or a list of operators. L2 : :class:`qutip.Qobj` / list of :class:`qutip.Qobj`; System operators coupling out of the feedback loop. Can be a single; operator or a list of operators. L2 must have the same length as L1. S_matrix: *array*; S matrix describing which operators in L1 are coupled to which; operators in L2 by the feedback channel. Defaults to a",MatchSource.WIKI,docs/4.2/modules/qutip/nonmarkov/memorycascade.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/nonmarkov/memorycascade.html
https://qutip.org/docs/4.2/modules/qutip/nonmarkov/memorycascade.html:2695,Usability,feedback,feedback,2695,"S (INCLUDING, BUT NOT; # LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,; # DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY; # THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT; # (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE; # OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.; ###############################################################################. # @author: Arne L. Grimsmo; # @email1: arne.grimsmo@gmail.com; # @organization: University of Sherbrooke. """"""; This module is an implementation of the method introduced in [1], for; solving open quantum systems subject to coherent feedback with a single; discrete time-delay. This method is referred to as the ``memory cascade''; method in qutip. [1] Arne L. Grimsmo, Phys. Rev. Lett 115, 060402 (2015); """""". import numpy as np; import warnings. import qutip as qt. [docs]class MemoryCascade:; """"""Class for running memory cascade simulations of open quantum systems; with time-delayed coherent feedback. Attributes; ----------; H_S : :class:`qutip.Qobj`; System Hamiltonian (can also be a Liouvillian). L1 : :class:`qutip.Qobj` / list of :class:`qutip.Qobj`; System operators coupling into the feedback loop. Can be a single; operator or a list of operators. L2 : :class:`qutip.Qobj` / list of :class:`qutip.Qobj`; System operators coupling out of the feedback loop. Can be a single; operator or a list of operators. L2 must have the same length as L1. S_matrix: *array*; S matrix describing which operators in L1 are coupled to which; operators in L2 by the feedback channel. Defaults to an n by n identity; matrix where n is the number of elements in L1/L2. c_ops_markov : :class:`qutip.Qobj` / list of :class:`qutip.Qobj`; Decay operators describing conventional Markovian decay channels.; Can be a single operator or a list of operators. integrator : str {'propagator', 'mesolve'}; Integrator method to use. Defaults to 'propagato",MatchSource.WIKI,docs/4.2/modules/qutip/nonmarkov/memorycascade.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/nonmarkov/memorycascade.html
https://qutip.org/docs/4.2/modules/qutip/nonmarkov/memorycascade.html:2895,Usability,feedback,feedback,2895,"LUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE; # OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.; ###############################################################################. # @author: Arne L. Grimsmo; # @email1: arne.grimsmo@gmail.com; # @organization: University of Sherbrooke. """"""; This module is an implementation of the method introduced in [1], for; solving open quantum systems subject to coherent feedback with a single; discrete time-delay. This method is referred to as the ``memory cascade''; method in qutip. [1] Arne L. Grimsmo, Phys. Rev. Lett 115, 060402 (2015); """""". import numpy as np; import warnings. import qutip as qt. [docs]class MemoryCascade:; """"""Class for running memory cascade simulations of open quantum systems; with time-delayed coherent feedback. Attributes; ----------; H_S : :class:`qutip.Qobj`; System Hamiltonian (can also be a Liouvillian). L1 : :class:`qutip.Qobj` / list of :class:`qutip.Qobj`; System operators coupling into the feedback loop. Can be a single; operator or a list of operators. L2 : :class:`qutip.Qobj` / list of :class:`qutip.Qobj`; System operators coupling out of the feedback loop. Can be a single; operator or a list of operators. L2 must have the same length as L1. S_matrix: *array*; S matrix describing which operators in L1 are coupled to which; operators in L2 by the feedback channel. Defaults to an n by n identity; matrix where n is the number of elements in L1/L2. c_ops_markov : :class:`qutip.Qobj` / list of :class:`qutip.Qobj`; Decay operators describing conventional Markovian decay channels.; Can be a single operator or a list of operators. integrator : str {'propagator', 'mesolve'}; Integrator method to use. Defaults to 'propagator' which tends to be ; faster for long times (i.e., large Hilbert space). parallel : bool; Run integrator in parallel if True. Only implemented for 'propagator'; as the integrator method. options : :class:`qutip.solver.Options`; Generic solver op",MatchSource.WIKI,docs/4.2/modules/qutip/nonmarkov/memorycascade.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/nonmarkov/memorycascade.html
https://qutip.org/docs/4.2/modules/qutip/nonmarkov/memorycascade.html:3053,Usability,feedback,feedback,3053,"#############################################################. # @author: Arne L. Grimsmo; # @email1: arne.grimsmo@gmail.com; # @organization: University of Sherbrooke. """"""; This module is an implementation of the method introduced in [1], for; solving open quantum systems subject to coherent feedback with a single; discrete time-delay. This method is referred to as the ``memory cascade''; method in qutip. [1] Arne L. Grimsmo, Phys. Rev. Lett 115, 060402 (2015); """""". import numpy as np; import warnings. import qutip as qt. [docs]class MemoryCascade:; """"""Class for running memory cascade simulations of open quantum systems; with time-delayed coherent feedback. Attributes; ----------; H_S : :class:`qutip.Qobj`; System Hamiltonian (can also be a Liouvillian). L1 : :class:`qutip.Qobj` / list of :class:`qutip.Qobj`; System operators coupling into the feedback loop. Can be a single; operator or a list of operators. L2 : :class:`qutip.Qobj` / list of :class:`qutip.Qobj`; System operators coupling out of the feedback loop. Can be a single; operator or a list of operators. L2 must have the same length as L1. S_matrix: *array*; S matrix describing which operators in L1 are coupled to which; operators in L2 by the feedback channel. Defaults to an n by n identity; matrix where n is the number of elements in L1/L2. c_ops_markov : :class:`qutip.Qobj` / list of :class:`qutip.Qobj`; Decay operators describing conventional Markovian decay channels.; Can be a single operator or a list of operators. integrator : str {'propagator', 'mesolve'}; Integrator method to use. Defaults to 'propagator' which tends to be ; faster for long times (i.e., large Hilbert space). parallel : bool; Run integrator in parallel if True. Only implemented for 'propagator'; as the integrator method. options : :class:`qutip.solver.Options`; Generic solver options.; """""". def __init__(self, H_S, L1, L2, S_matrix=None, c_ops_markov=None,; integrator='propagator', parallel=False, options=None):. if options is None:;",MatchSource.WIKI,docs/4.2/modules/qutip/nonmarkov/memorycascade.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/nonmarkov/memorycascade.html
https://qutip.org/docs/4.2/modules/qutip/nonmarkov/memorycascade.html:3260,Usability,feedback,feedback,3260,"s module is an implementation of the method introduced in [1], for; solving open quantum systems subject to coherent feedback with a single; discrete time-delay. This method is referred to as the ``memory cascade''; method in qutip. [1] Arne L. Grimsmo, Phys. Rev. Lett 115, 060402 (2015); """""". import numpy as np; import warnings. import qutip as qt. [docs]class MemoryCascade:; """"""Class for running memory cascade simulations of open quantum systems; with time-delayed coherent feedback. Attributes; ----------; H_S : :class:`qutip.Qobj`; System Hamiltonian (can also be a Liouvillian). L1 : :class:`qutip.Qobj` / list of :class:`qutip.Qobj`; System operators coupling into the feedback loop. Can be a single; operator or a list of operators. L2 : :class:`qutip.Qobj` / list of :class:`qutip.Qobj`; System operators coupling out of the feedback loop. Can be a single; operator or a list of operators. L2 must have the same length as L1. S_matrix: *array*; S matrix describing which operators in L1 are coupled to which; operators in L2 by the feedback channel. Defaults to an n by n identity; matrix where n is the number of elements in L1/L2. c_ops_markov : :class:`qutip.Qobj` / list of :class:`qutip.Qobj`; Decay operators describing conventional Markovian decay channels.; Can be a single operator or a list of operators. integrator : str {'propagator', 'mesolve'}; Integrator method to use. Defaults to 'propagator' which tends to be ; faster for long times (i.e., large Hilbert space). parallel : bool; Run integrator in parallel if True. Only implemented for 'propagator'; as the integrator method. options : :class:`qutip.solver.Options`; Generic solver options.; """""". def __init__(self, H_S, L1, L2, S_matrix=None, c_ops_markov=None,; integrator='propagator', parallel=False, options=None):. if options is None:; self.options = qt.Options(); else:; self.options = options. self.H_S = H_S; self.sysdims = H_S.dims; if isinstance(L1, qt.Qobj):; self.L1 = [L1]; else:; self.L1 = L1; if isinst",MatchSource.WIKI,docs/4.2/modules/qutip/nonmarkov/memorycascade.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/nonmarkov/memorycascade.html
https://qutip.org/docs/4.2/modules/qutip/nonmarkov/memorycascade.html:7338,Usability,feedback,feedback,7338,"_out; 2: b_out^\dagger; 3: b_loop; 4: b_loop^\dagger. tlist : array_like; list of corresponding times t1,..,tn at which to evaluate the field; operators. tau : float; time-delay. c1 : :class:`qutip.Qobj`; system collapse operator that couples to the in-loop field in; question (only needs to be specified if self.L1 has more than one; element). c2 : :class:`qutip.Qobj`; system collapse operator that couples to the output field in; question (only needs to be specified if self.L2 has more than one; element). notrace : bool {False}; If this optional is set to True, a propagator is returned for a; cascade of k systems, where :math:`(k-1) tau < t < k tau`.; If set to False (default), a generalized partial trace is performed; and a propagator for a single system is returned. Returns; -------; : :class:`qutip.Qobj`; time-propagator for computing field correlation function; """"""; if c1 is None and len(self.L1) == 1:; c1 = self.L1[0]; else:; raise ValueError('Argument c1 has to be specified when more than' +; 'one collapse operator couples to the feedback' +; 'loop.'); if c2 is None and len(self.L2) == 1:; c2 = self.L2[0]; else:; raise ValueError('Argument c1 has to be specified when more than' +; 'one collapse operator couples to the feedback' +; 'loop.'); klist = []; slist = []; for t in tlist:; klist.append(int(t/tau)+1); slist.append(t-(klist[-1]-1)*tau); kmax = max(klist); zipped = sorted(zip(slist, klist, blist)); slist = [s for (s, k, b) in zipped]; klist = [k for (s, k, b) in zipped]; blist = [b for (s, k, b) in zipped]. G1, E0 = _generator(kmax, self.H_S, self.L1, self.L2, self.S_matrix,; self.c_ops_markov); sprev = 0.; E = E0; for i, s in enumerate(slist):; E = _integrate(G1, E, sprev, s, integrator=self.integrator,; parallel=self.parallel, opt=self.options); if klist[i] == 1:; l1 = 0.*qt.Qobj(); else:; l1 = _localop(c1, klist[i]-1, kmax); l2 = _localop(c2, klist[i], kmax); if blist[i] == 0:; superop = self.Id; elif blist[i] == 1:; superop = qt.spre(l1+l2); elif blist",MatchSource.WIKI,docs/4.2/modules/qutip/nonmarkov/memorycascade.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/nonmarkov/memorycascade.html
https://qutip.org/docs/4.2/modules/qutip/nonmarkov/memorycascade.html:7530,Usability,feedback,feedback,7530,"qutip.Qobj`; system collapse operator that couples to the in-loop field in; question (only needs to be specified if self.L1 has more than one; element). c2 : :class:`qutip.Qobj`; system collapse operator that couples to the output field in; question (only needs to be specified if self.L2 has more than one; element). notrace : bool {False}; If this optional is set to True, a propagator is returned for a; cascade of k systems, where :math:`(k-1) tau < t < k tau`.; If set to False (default), a generalized partial trace is performed; and a propagator for a single system is returned. Returns; -------; : :class:`qutip.Qobj`; time-propagator for computing field correlation function; """"""; if c1 is None and len(self.L1) == 1:; c1 = self.L1[0]; else:; raise ValueError('Argument c1 has to be specified when more than' +; 'one collapse operator couples to the feedback' +; 'loop.'); if c2 is None and len(self.L2) == 1:; c2 = self.L2[0]; else:; raise ValueError('Argument c1 has to be specified when more than' +; 'one collapse operator couples to the feedback' +; 'loop.'); klist = []; slist = []; for t in tlist:; klist.append(int(t/tau)+1); slist.append(t-(klist[-1]-1)*tau); kmax = max(klist); zipped = sorted(zip(slist, klist, blist)); slist = [s for (s, k, b) in zipped]; klist = [k for (s, k, b) in zipped]; blist = [b for (s, k, b) in zipped]. G1, E0 = _generator(kmax, self.H_S, self.L1, self.L2, self.S_matrix,; self.c_ops_markov); sprev = 0.; E = E0; for i, s in enumerate(slist):; E = _integrate(G1, E, sprev, s, integrator=self.integrator,; parallel=self.parallel, opt=self.options); if klist[i] == 1:; l1 = 0.*qt.Qobj(); else:; l1 = _localop(c1, klist[i]-1, kmax); l2 = _localop(c2, klist[i], kmax); if blist[i] == 0:; superop = self.Id; elif blist[i] == 1:; superop = qt.spre(l1+l2); elif blist[i] == 2:; superop = qt.spost(l1.dag()+l2.dag()); elif blist[i] == 3:; superop = qt.spre(l1); elif blist[i] == 4:; superop = qt.spost(l1.dag()); else:; raise ValueError('Allowed values in blis",MatchSource.WIKI,docs/4.2/modules/qutip/nonmarkov/memorycascade.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/nonmarkov/memorycascade.html
https://qutip.org/docs/4.2/modules/qutip/nonmarkov/transfertensor.html:8136,Deployability,update,updated,8136,"es. output.ttmconvergence = diff. if opt.store_states:; output.states = states. return output. def _generatetensors(dynmaps, learningtimes=None, **kwargs):; """"""; Generate the tensors :math:`T_1,\dots,T_K` from the dynamical maps; :math:`E(t_k)`. A stationary process is assumed, i.e., :math:`T_{n,k} = T_{n-k}`. Parameters; ----------; dynmaps : list of :class:`qutip.Qobj`; List of precomputed dynamical maps (superoperators) at the times; specified in `learningtimes`, or a callback function that returns the; superoperator at a given time. learningtimes : array_like; list of times :math:`t_k` to use if argument `dynmaps` is a callback; function. kwargs : dictionary; Optional keyword arguments. See; :class:`qutip.nonmarkov.ttm.TTMSolverOptions`. Returns; -------; Tlist: list of :class:`qutip.Qobj.`; A list of transfer tensors :math:`T_1,\dots,T_K`; """""". # Determine if dynmaps is callable or list-like; if callable(dynmaps):; if learningtimes is None:; raise TypeError(""Argument 'learnintimes' required when 'dynmaps'"" +; ""is a callback function.""). def dynmapfunc(n): return dynmaps(learningtimes[n]); Kmax = len(learningtimes); else:; try:; tmp = dynmaps[:]; del tmp. def dynmapfunc(n): return dynmaps[n]; Kmax = len(dynmaps); except TypeError:; raise TypeError(""Argument 'dynmaps' should be a callable or"" +; ""list-like.""). if ""opt"" not in kwargs:; opt = TTMSolverOptions(dynmaps=dynmaps, learningtimes=learningtimes,; **kwargs); else:; opt = kwargs['opt']. Tlist = []; diff = [0.0]; for n in range(Kmax):; T = dynmapfunc(n); for m in range(1, n):; T -= Tlist[n-m]*dynmapfunc(m); Tlist.append(T); if n > 1:; diff.append((Tlist[-1]-Tlist[-2]).norm()); if diff[-1] < opt.thres:; # Below threshold for truncation; print('breaking', (Tlist[-1]-Tlist[-2]).norm(), n); break; return Tlist, diff. Â© Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, and A.L. Grimsmo.; Last updated on Jan 17, 2018. . Built with Sphinx using a theme provided by Read the Docs. . ",MatchSource.WIKI,docs/4.2/modules/qutip/nonmarkov/transfertensor.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/nonmarkov/transfertensor.html
https://qutip.org/docs/4.2/modules/qutip/nonmarkov/transfertensor.html:2955,Usability,learn,learningtimes,2955,"AGE.; ###############################################################################. # @author: Arne L. Grimsmo; # @email1: arne.grimsmo@gmail.com; # @organization: University of Sherbrooke. """"""; This module contains an implementation of the non-Markovian transfer tensor; method (TTM), introduced in [1]. [1] Javier Cerrillo and Jianshu Cao, Phys. Rev. Lett 112, 110401 (2014); """""". import numpy as np. from qutip import (Options, spre, vector_to_operator, operator_to_vector,; ket2dm, isket); from qutip.solver import Result; from qutip.expect import expect_rho_vec. [docs]class TTMSolverOptions:; """"""Class of options for the Transfer Tensor Method solver. Attributes; ----------; dynmaps : list of :class:`qutip.Qobj`; List of precomputed dynamical maps (superoperators),; or a callback function that returns the; superoperator at a given time. times : array_like; List of times :math:`t_n` at which to calculate :math:`\\rho(t_n)`. learningtimes : array_like; List of times :math:`t_k` to use as learning times if argument; `dynmaps` is a callback function. thres : float; Threshold for halting. Halts if :math:`||T_{n}-T_{n-1}||` is below; treshold. options : :class:`qutip.solver.Options`; Generic solver options.; """""". def __init__(self, dynmaps=None, times=[], learningtimes=[],; thres=0.0, options=None):. if options is None:; options = Options(). self.dynmaps = dynmaps; self.times = times; self.learningtimes = learningtimes; self.thres = thres; self.store_states = options.store_states. [docs]def ttmsolve(dynmaps, rho0, times, e_ops=[], learningtimes=None, tensors=None,; **kwargs):; """"""; Solve time-evolution using the Transfer Tensor Method, based on a set of; precomputed dynamical maps. Parameters; ----------; dynmaps : list of :class:`qutip.Qobj`; List of precomputed dynamical maps (superoperators),; or a callback function that returns the; superoperator at a given time. rho0 : :class:`qutip.Qobj`; Initial density matrix or state vector (ket). times : array_like; list of tim",MatchSource.WIKI,docs/4.2/modules/qutip/nonmarkov/transfertensor.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/nonmarkov/transfertensor.html
https://qutip.org/docs/4.2/modules/qutip/nonmarkov/transfertensor.html:3019,Usability,learn,learning,3019,"AGE.; ###############################################################################. # @author: Arne L. Grimsmo; # @email1: arne.grimsmo@gmail.com; # @organization: University of Sherbrooke. """"""; This module contains an implementation of the non-Markovian transfer tensor; method (TTM), introduced in [1]. [1] Javier Cerrillo and Jianshu Cao, Phys. Rev. Lett 112, 110401 (2014); """""". import numpy as np. from qutip import (Options, spre, vector_to_operator, operator_to_vector,; ket2dm, isket); from qutip.solver import Result; from qutip.expect import expect_rho_vec. [docs]class TTMSolverOptions:; """"""Class of options for the Transfer Tensor Method solver. Attributes; ----------; dynmaps : list of :class:`qutip.Qobj`; List of precomputed dynamical maps (superoperators),; or a callback function that returns the; superoperator at a given time. times : array_like; List of times :math:`t_n` at which to calculate :math:`\\rho(t_n)`. learningtimes : array_like; List of times :math:`t_k` to use as learning times if argument; `dynmaps` is a callback function. thres : float; Threshold for halting. Halts if :math:`||T_{n}-T_{n-1}||` is below; treshold. options : :class:`qutip.solver.Options`; Generic solver options.; """""". def __init__(self, dynmaps=None, times=[], learningtimes=[],; thres=0.0, options=None):. if options is None:; options = Options(). self.dynmaps = dynmaps; self.times = times; self.learningtimes = learningtimes; self.thres = thres; self.store_states = options.store_states. [docs]def ttmsolve(dynmaps, rho0, times, e_ops=[], learningtimes=None, tensors=None,; **kwargs):; """"""; Solve time-evolution using the Transfer Tensor Method, based on a set of; precomputed dynamical maps. Parameters; ----------; dynmaps : list of :class:`qutip.Qobj`; List of precomputed dynamical maps (superoperators),; or a callback function that returns the; superoperator at a given time. rho0 : :class:`qutip.Qobj`; Initial density matrix or state vector (ket). times : array_like; list of tim",MatchSource.WIKI,docs/4.2/modules/qutip/nonmarkov/transfertensor.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/nonmarkov/transfertensor.html
https://qutip.org/docs/4.2/modules/qutip/nonmarkov/transfertensor.html:3288,Usability,learn,learningtimes,3288,"sfer tensor; method (TTM), introduced in [1]. [1] Javier Cerrillo and Jianshu Cao, Phys. Rev. Lett 112, 110401 (2014); """""". import numpy as np. from qutip import (Options, spre, vector_to_operator, operator_to_vector,; ket2dm, isket); from qutip.solver import Result; from qutip.expect import expect_rho_vec. [docs]class TTMSolverOptions:; """"""Class of options for the Transfer Tensor Method solver. Attributes; ----------; dynmaps : list of :class:`qutip.Qobj`; List of precomputed dynamical maps (superoperators),; or a callback function that returns the; superoperator at a given time. times : array_like; List of times :math:`t_n` at which to calculate :math:`\\rho(t_n)`. learningtimes : array_like; List of times :math:`t_k` to use as learning times if argument; `dynmaps` is a callback function. thres : float; Threshold for halting. Halts if :math:`||T_{n}-T_{n-1}||` is below; treshold. options : :class:`qutip.solver.Options`; Generic solver options.; """""". def __init__(self, dynmaps=None, times=[], learningtimes=[],; thres=0.0, options=None):. if options is None:; options = Options(). self.dynmaps = dynmaps; self.times = times; self.learningtimes = learningtimes; self.thres = thres; self.store_states = options.store_states. [docs]def ttmsolve(dynmaps, rho0, times, e_ops=[], learningtimes=None, tensors=None,; **kwargs):; """"""; Solve time-evolution using the Transfer Tensor Method, based on a set of; precomputed dynamical maps. Parameters; ----------; dynmaps : list of :class:`qutip.Qobj`; List of precomputed dynamical maps (superoperators),; or a callback function that returns the; superoperator at a given time. rho0 : :class:`qutip.Qobj`; Initial density matrix or state vector (ket). times : array_like; list of times :math:`t_n` at which to compute :math:`\\rho(t_n)`.; Must be uniformily spaced. e_ops : list of :class:`qutip.Qobj` / callback function; single operator or list of operators for which to evaluate; expectation values. learningtimes : array_like; list of times :",MatchSource.WIKI,docs/4.2/modules/qutip/nonmarkov/transfertensor.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/nonmarkov/transfertensor.html
https://qutip.org/docs/4.2/modules/qutip/nonmarkov/transfertensor.html:3425,Usability,learn,learningtimes,3425,"ptions, spre, vector_to_operator, operator_to_vector,; ket2dm, isket); from qutip.solver import Result; from qutip.expect import expect_rho_vec. [docs]class TTMSolverOptions:; """"""Class of options for the Transfer Tensor Method solver. Attributes; ----------; dynmaps : list of :class:`qutip.Qobj`; List of precomputed dynamical maps (superoperators),; or a callback function that returns the; superoperator at a given time. times : array_like; List of times :math:`t_n` at which to calculate :math:`\\rho(t_n)`. learningtimes : array_like; List of times :math:`t_k` to use as learning times if argument; `dynmaps` is a callback function. thres : float; Threshold for halting. Halts if :math:`||T_{n}-T_{n-1}||` is below; treshold. options : :class:`qutip.solver.Options`; Generic solver options.; """""". def __init__(self, dynmaps=None, times=[], learningtimes=[],; thres=0.0, options=None):. if options is None:; options = Options(). self.dynmaps = dynmaps; self.times = times; self.learningtimes = learningtimes; self.thres = thres; self.store_states = options.store_states. [docs]def ttmsolve(dynmaps, rho0, times, e_ops=[], learningtimes=None, tensors=None,; **kwargs):; """"""; Solve time-evolution using the Transfer Tensor Method, based on a set of; precomputed dynamical maps. Parameters; ----------; dynmaps : list of :class:`qutip.Qobj`; List of precomputed dynamical maps (superoperators),; or a callback function that returns the; superoperator at a given time. rho0 : :class:`qutip.Qobj`; Initial density matrix or state vector (ket). times : array_like; list of times :math:`t_n` at which to compute :math:`\\rho(t_n)`.; Must be uniformily spaced. e_ops : list of :class:`qutip.Qobj` / callback function; single operator or list of operators for which to evaluate; expectation values. learningtimes : array_like; list of times :math:`t_k` for which we have knowledge of the dynamical; maps :math:`E(t_k)`. tensors : array_like; optional list of precomputed tensors :math:`T_k`. kwargs : dict",MatchSource.WIKI,docs/4.2/modules/qutip/nonmarkov/transfertensor.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/nonmarkov/transfertensor.html
https://qutip.org/docs/4.2/modules/qutip/nonmarkov/transfertensor.html:3441,Usability,learn,learningtimes,3441,"ptions, spre, vector_to_operator, operator_to_vector,; ket2dm, isket); from qutip.solver import Result; from qutip.expect import expect_rho_vec. [docs]class TTMSolverOptions:; """"""Class of options for the Transfer Tensor Method solver. Attributes; ----------; dynmaps : list of :class:`qutip.Qobj`; List of precomputed dynamical maps (superoperators),; or a callback function that returns the; superoperator at a given time. times : array_like; List of times :math:`t_n` at which to calculate :math:`\\rho(t_n)`. learningtimes : array_like; List of times :math:`t_k` to use as learning times if argument; `dynmaps` is a callback function. thres : float; Threshold for halting. Halts if :math:`||T_{n}-T_{n-1}||` is below; treshold. options : :class:`qutip.solver.Options`; Generic solver options.; """""". def __init__(self, dynmaps=None, times=[], learningtimes=[],; thres=0.0, options=None):. if options is None:; options = Options(). self.dynmaps = dynmaps; self.times = times; self.learningtimes = learningtimes; self.thres = thres; self.store_states = options.store_states. [docs]def ttmsolve(dynmaps, rho0, times, e_ops=[], learningtimes=None, tensors=None,; **kwargs):; """"""; Solve time-evolution using the Transfer Tensor Method, based on a set of; precomputed dynamical maps. Parameters; ----------; dynmaps : list of :class:`qutip.Qobj`; List of precomputed dynamical maps (superoperators),; or a callback function that returns the; superoperator at a given time. rho0 : :class:`qutip.Qobj`; Initial density matrix or state vector (ket). times : array_like; list of times :math:`t_n` at which to compute :math:`\\rho(t_n)`.; Must be uniformily spaced. e_ops : list of :class:`qutip.Qobj` / callback function; single operator or list of operators for which to evaluate; expectation values. learningtimes : array_like; list of times :math:`t_k` for which we have knowledge of the dynamical; maps :math:`E(t_k)`. tensors : array_like; optional list of precomputed tensors :math:`T_k`. kwargs : dict",MatchSource.WIKI,docs/4.2/modules/qutip/nonmarkov/transfertensor.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/nonmarkov/transfertensor.html
https://qutip.org/docs/4.2/modules/qutip/nonmarkov/transfertensor.html:3569,Usability,learn,learningtimes,3569,"""""""Class of options for the Transfer Tensor Method solver. Attributes; ----------; dynmaps : list of :class:`qutip.Qobj`; List of precomputed dynamical maps (superoperators),; or a callback function that returns the; superoperator at a given time. times : array_like; List of times :math:`t_n` at which to calculate :math:`\\rho(t_n)`. learningtimes : array_like; List of times :math:`t_k` to use as learning times if argument; `dynmaps` is a callback function. thres : float; Threshold for halting. Halts if :math:`||T_{n}-T_{n-1}||` is below; treshold. options : :class:`qutip.solver.Options`; Generic solver options.; """""". def __init__(self, dynmaps=None, times=[], learningtimes=[],; thres=0.0, options=None):. if options is None:; options = Options(). self.dynmaps = dynmaps; self.times = times; self.learningtimes = learningtimes; self.thres = thres; self.store_states = options.store_states. [docs]def ttmsolve(dynmaps, rho0, times, e_ops=[], learningtimes=None, tensors=None,; **kwargs):; """"""; Solve time-evolution using the Transfer Tensor Method, based on a set of; precomputed dynamical maps. Parameters; ----------; dynmaps : list of :class:`qutip.Qobj`; List of precomputed dynamical maps (superoperators),; or a callback function that returns the; superoperator at a given time. rho0 : :class:`qutip.Qobj`; Initial density matrix or state vector (ket). times : array_like; list of times :math:`t_n` at which to compute :math:`\\rho(t_n)`.; Must be uniformily spaced. e_ops : list of :class:`qutip.Qobj` / callback function; single operator or list of operators for which to evaluate; expectation values. learningtimes : array_like; list of times :math:`t_k` for which we have knowledge of the dynamical; maps :math:`E(t_k)`. tensors : array_like; optional list of precomputed tensors :math:`T_k`. kwargs : dictionary; Optional keyword arguments. See; :class:`qutip.nonmarkov.ttm.TTMSolverOptions`. Returns; -------; output: :class:`qutip.solver.Result`; An instance of the class :class:`",MatchSource.WIKI,docs/4.2/modules/qutip/nonmarkov/transfertensor.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/nonmarkov/transfertensor.html
https://qutip.org/docs/4.2/modules/qutip/nonmarkov/transfertensor.html:4237,Usability,learn,learningtimes,4237,"times=[],; thres=0.0, options=None):. if options is None:; options = Options(). self.dynmaps = dynmaps; self.times = times; self.learningtimes = learningtimes; self.thres = thres; self.store_states = options.store_states. [docs]def ttmsolve(dynmaps, rho0, times, e_ops=[], learningtimes=None, tensors=None,; **kwargs):; """"""; Solve time-evolution using the Transfer Tensor Method, based on a set of; precomputed dynamical maps. Parameters; ----------; dynmaps : list of :class:`qutip.Qobj`; List of precomputed dynamical maps (superoperators),; or a callback function that returns the; superoperator at a given time. rho0 : :class:`qutip.Qobj`; Initial density matrix or state vector (ket). times : array_like; list of times :math:`t_n` at which to compute :math:`\\rho(t_n)`.; Must be uniformily spaced. e_ops : list of :class:`qutip.Qobj` / callback function; single operator or list of operators for which to evaluate; expectation values. learningtimes : array_like; list of times :math:`t_k` for which we have knowledge of the dynamical; maps :math:`E(t_k)`. tensors : array_like; optional list of precomputed tensors :math:`T_k`. kwargs : dictionary; Optional keyword arguments. See; :class:`qutip.nonmarkov.ttm.TTMSolverOptions`. Returns; -------; output: :class:`qutip.solver.Result`; An instance of the class :class:`qutip.solver.Result`.; """""". opt = TTMSolverOptions(dynmaps=dynmaps, times=times,; learningtimes=learningtimes, **kwargs). diff = None. if isket(rho0):; rho0 = ket2dm(rho0). output = Result(); e_sops_data = []. if callable(e_ops):; n_expt_op = 0; expt_callback = True. else:; try:; tmp = e_ops[:]; del tmp. n_expt_op = len(e_ops); expt_callback = False. if n_expt_op == 0:; # fall back on storing states; opt.store_states = True. for op in e_ops:; e_sops_data.append(spre(op).data); if op.isherm and rho0.isherm:; output.expect.append(np.zeros(len(times))); else:; output.expect.append(np.zeros(len(times), dtype=complex)); except TypeError:; raise TypeError(""Argument 'e_ops' s",MatchSource.WIKI,docs/4.2/modules/qutip/nonmarkov/transfertensor.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/nonmarkov/transfertensor.html
https://qutip.org/docs/4.2/modules/qutip/nonmarkov/transfertensor.html:4702,Usability,learn,learningtimes,4702," precomputed dynamical maps. Parameters; ----------; dynmaps : list of :class:`qutip.Qobj`; List of precomputed dynamical maps (superoperators),; or a callback function that returns the; superoperator at a given time. rho0 : :class:`qutip.Qobj`; Initial density matrix or state vector (ket). times : array_like; list of times :math:`t_n` at which to compute :math:`\\rho(t_n)`.; Must be uniformily spaced. e_ops : list of :class:`qutip.Qobj` / callback function; single operator or list of operators for which to evaluate; expectation values. learningtimes : array_like; list of times :math:`t_k` for which we have knowledge of the dynamical; maps :math:`E(t_k)`. tensors : array_like; optional list of precomputed tensors :math:`T_k`. kwargs : dictionary; Optional keyword arguments. See; :class:`qutip.nonmarkov.ttm.TTMSolverOptions`. Returns; -------; output: :class:`qutip.solver.Result`; An instance of the class :class:`qutip.solver.Result`.; """""". opt = TTMSolverOptions(dynmaps=dynmaps, times=times,; learningtimes=learningtimes, **kwargs). diff = None. if isket(rho0):; rho0 = ket2dm(rho0). output = Result(); e_sops_data = []. if callable(e_ops):; n_expt_op = 0; expt_callback = True. else:; try:; tmp = e_ops[:]; del tmp. n_expt_op = len(e_ops); expt_callback = False. if n_expt_op == 0:; # fall back on storing states; opt.store_states = True. for op in e_ops:; e_sops_data.append(spre(op).data); if op.isherm and rho0.isherm:; output.expect.append(np.zeros(len(times))); else:; output.expect.append(np.zeros(len(times), dtype=complex)); except TypeError:; raise TypeError(""Argument 'e_ops' should be a callable or"" +; ""list-like.""). if tensors is None:; tensors, diff = _generatetensors(dynmaps, learningtimes, opt=opt). if rho0.isoper:; # vectorize density matrix; rho0vec = operator_to_vector(rho0); else:; # rho0 might be a super in which case we should not vectorize; rho0vec = rho0. K = len(tensors); states = [rho0vec]; for n in range(1, len(times)):; states.append(None); for k in ",MatchSource.WIKI,docs/4.2/modules/qutip/nonmarkov/transfertensor.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/nonmarkov/transfertensor.html
https://qutip.org/docs/4.2/modules/qutip/nonmarkov/transfertensor.html:4716,Usability,learn,learningtimes,4716," precomputed dynamical maps. Parameters; ----------; dynmaps : list of :class:`qutip.Qobj`; List of precomputed dynamical maps (superoperators),; or a callback function that returns the; superoperator at a given time. rho0 : :class:`qutip.Qobj`; Initial density matrix or state vector (ket). times : array_like; list of times :math:`t_n` at which to compute :math:`\\rho(t_n)`.; Must be uniformily spaced. e_ops : list of :class:`qutip.Qobj` / callback function; single operator or list of operators for which to evaluate; expectation values. learningtimes : array_like; list of times :math:`t_k` for which we have knowledge of the dynamical; maps :math:`E(t_k)`. tensors : array_like; optional list of precomputed tensors :math:`T_k`. kwargs : dictionary; Optional keyword arguments. See; :class:`qutip.nonmarkov.ttm.TTMSolverOptions`. Returns; -------; output: :class:`qutip.solver.Result`; An instance of the class :class:`qutip.solver.Result`.; """""". opt = TTMSolverOptions(dynmaps=dynmaps, times=times,; learningtimes=learningtimes, **kwargs). diff = None. if isket(rho0):; rho0 = ket2dm(rho0). output = Result(); e_sops_data = []. if callable(e_ops):; n_expt_op = 0; expt_callback = True. else:; try:; tmp = e_ops[:]; del tmp. n_expt_op = len(e_ops); expt_callback = False. if n_expt_op == 0:; # fall back on storing states; opt.store_states = True. for op in e_ops:; e_sops_data.append(spre(op).data); if op.isherm and rho0.isherm:; output.expect.append(np.zeros(len(times))); else:; output.expect.append(np.zeros(len(times), dtype=complex)); except TypeError:; raise TypeError(""Argument 'e_ops' should be a callable or"" +; ""list-like.""). if tensors is None:; tensors, diff = _generatetensors(dynmaps, learningtimes, opt=opt). if rho0.isoper:; # vectorize density matrix; rho0vec = operator_to_vector(rho0); else:; # rho0 might be a super in which case we should not vectorize; rho0vec = rho0. K = len(tensors); states = [rho0vec]; for n in range(1, len(times)):; states.append(None); for k in ",MatchSource.WIKI,docs/4.2/modules/qutip/nonmarkov/transfertensor.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/nonmarkov/transfertensor.html
https://qutip.org/docs/4.2/modules/qutip/nonmarkov/transfertensor.html:5402,Usability,learn,learningtimes,5402,"tional list of precomputed tensors :math:`T_k`. kwargs : dictionary; Optional keyword arguments. See; :class:`qutip.nonmarkov.ttm.TTMSolverOptions`. Returns; -------; output: :class:`qutip.solver.Result`; An instance of the class :class:`qutip.solver.Result`.; """""". opt = TTMSolverOptions(dynmaps=dynmaps, times=times,; learningtimes=learningtimes, **kwargs). diff = None. if isket(rho0):; rho0 = ket2dm(rho0). output = Result(); e_sops_data = []. if callable(e_ops):; n_expt_op = 0; expt_callback = True. else:; try:; tmp = e_ops[:]; del tmp. n_expt_op = len(e_ops); expt_callback = False. if n_expt_op == 0:; # fall back on storing states; opt.store_states = True. for op in e_ops:; e_sops_data.append(spre(op).data); if op.isherm and rho0.isherm:; output.expect.append(np.zeros(len(times))); else:; output.expect.append(np.zeros(len(times), dtype=complex)); except TypeError:; raise TypeError(""Argument 'e_ops' should be a callable or"" +; ""list-like.""). if tensors is None:; tensors, diff = _generatetensors(dynmaps, learningtimes, opt=opt). if rho0.isoper:; # vectorize density matrix; rho0vec = operator_to_vector(rho0); else:; # rho0 might be a super in which case we should not vectorize; rho0vec = rho0. K = len(tensors); states = [rho0vec]; for n in range(1, len(times)):; states.append(None); for k in range(n):; if n-k < K:; states[-1] += tensors[n-k]*states[k]; for i, r in enumerate(states):; if opt.store_states or expt_callback:; if r.type == 'operator-ket':; states[i] = vector_to_operator(r); else:; states[i] = r; if expt_callback:; # use callback method; e_ops(times[i], states[i]); for m in range(n_expt_op):; if output.expect[m].dtype == complex:; output.expect[m][i] = expect_rho_vec(e_sops_data[m], r, 0); else:; output.expect[m][i] = expect_rho_vec(e_sops_data[m], r, 1). output.solver = ""ttmsolve""; output.times = times. output.ttmconvergence = diff. if opt.store_states:; output.states = states. return output. def _generatetensors(dynmaps, learningtimes=None, **kwargs):; """,MatchSource.WIKI,docs/4.2/modules/qutip/nonmarkov/transfertensor.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/nonmarkov/transfertensor.html
https://qutip.org/docs/4.2/modules/qutip/nonmarkov/transfertensor.html:6349,Usability,learn,learningtimes,6349,"dynmaps, learningtimes, opt=opt). if rho0.isoper:; # vectorize density matrix; rho0vec = operator_to_vector(rho0); else:; # rho0 might be a super in which case we should not vectorize; rho0vec = rho0. K = len(tensors); states = [rho0vec]; for n in range(1, len(times)):; states.append(None); for k in range(n):; if n-k < K:; states[-1] += tensors[n-k]*states[k]; for i, r in enumerate(states):; if opt.store_states or expt_callback:; if r.type == 'operator-ket':; states[i] = vector_to_operator(r); else:; states[i] = r; if expt_callback:; # use callback method; e_ops(times[i], states[i]); for m in range(n_expt_op):; if output.expect[m].dtype == complex:; output.expect[m][i] = expect_rho_vec(e_sops_data[m], r, 0); else:; output.expect[m][i] = expect_rho_vec(e_sops_data[m], r, 1). output.solver = ""ttmsolve""; output.times = times. output.ttmconvergence = diff. if opt.store_states:; output.states = states. return output. def _generatetensors(dynmaps, learningtimes=None, **kwargs):; """"""; Generate the tensors :math:`T_1,\dots,T_K` from the dynamical maps; :math:`E(t_k)`. A stationary process is assumed, i.e., :math:`T_{n,k} = T_{n-k}`. Parameters; ----------; dynmaps : list of :class:`qutip.Qobj`; List of precomputed dynamical maps (superoperators) at the times; specified in `learningtimes`, or a callback function that returns the; superoperator at a given time. learningtimes : array_like; list of times :math:`t_k` to use if argument `dynmaps` is a callback; function. kwargs : dictionary; Optional keyword arguments. See; :class:`qutip.nonmarkov.ttm.TTMSolverOptions`. Returns; -------; Tlist: list of :class:`qutip.Qobj.`; A list of transfer tensors :math:`T_1,\dots,T_K`; """""". # Determine if dynmaps is callable or list-like; if callable(dynmaps):; if learningtimes is None:; raise TypeError(""Argument 'learnintimes' required when 'dynmaps'"" +; ""is a callback function.""). def dynmapfunc(n): return dynmaps(learningtimes[n]); Kmax = len(learningtimes); else:; try:; tmp = dynmaps[:]; d",MatchSource.WIKI,docs/4.2/modules/qutip/nonmarkov/transfertensor.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/nonmarkov/transfertensor.html
https://qutip.org/docs/4.2/modules/qutip/nonmarkov/transfertensor.html:6679,Usability,learn,learningtimes,6679,"one); for k in range(n):; if n-k < K:; states[-1] += tensors[n-k]*states[k]; for i, r in enumerate(states):; if opt.store_states or expt_callback:; if r.type == 'operator-ket':; states[i] = vector_to_operator(r); else:; states[i] = r; if expt_callback:; # use callback method; e_ops(times[i], states[i]); for m in range(n_expt_op):; if output.expect[m].dtype == complex:; output.expect[m][i] = expect_rho_vec(e_sops_data[m], r, 0); else:; output.expect[m][i] = expect_rho_vec(e_sops_data[m], r, 1). output.solver = ""ttmsolve""; output.times = times. output.ttmconvergence = diff. if opt.store_states:; output.states = states. return output. def _generatetensors(dynmaps, learningtimes=None, **kwargs):; """"""; Generate the tensors :math:`T_1,\dots,T_K` from the dynamical maps; :math:`E(t_k)`. A stationary process is assumed, i.e., :math:`T_{n,k} = T_{n-k}`. Parameters; ----------; dynmaps : list of :class:`qutip.Qobj`; List of precomputed dynamical maps (superoperators) at the times; specified in `learningtimes`, or a callback function that returns the; superoperator at a given time. learningtimes : array_like; list of times :math:`t_k` to use if argument `dynmaps` is a callback; function. kwargs : dictionary; Optional keyword arguments. See; :class:`qutip.nonmarkov.ttm.TTMSolverOptions`. Returns; -------; Tlist: list of :class:`qutip.Qobj.`; A list of transfer tensors :math:`T_1,\dots,T_K`; """""". # Determine if dynmaps is callable or list-like; if callable(dynmaps):; if learningtimes is None:; raise TypeError(""Argument 'learnintimes' required when 'dynmaps'"" +; ""is a callback function.""). def dynmapfunc(n): return dynmaps(learningtimes[n]); Kmax = len(learningtimes); else:; try:; tmp = dynmaps[:]; del tmp. def dynmapfunc(n): return dynmaps[n]; Kmax = len(dynmaps); except TypeError:; raise TypeError(""Argument 'dynmaps' should be a callable or"" +; ""list-like.""). if ""opt"" not in kwargs:; opt = TTMSolverOptions(dynmaps=dynmaps, learningtimes=learningtimes,; **kwargs); else:; opt = k",MatchSource.WIKI,docs/4.2/modules/qutip/nonmarkov/transfertensor.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/nonmarkov/transfertensor.html
https://qutip.org/docs/4.2/modules/qutip/nonmarkov/transfertensor.html:6767,Usability,learn,learningtimes,6767,"back:; if r.type == 'operator-ket':; states[i] = vector_to_operator(r); else:; states[i] = r; if expt_callback:; # use callback method; e_ops(times[i], states[i]); for m in range(n_expt_op):; if output.expect[m].dtype == complex:; output.expect[m][i] = expect_rho_vec(e_sops_data[m], r, 0); else:; output.expect[m][i] = expect_rho_vec(e_sops_data[m], r, 1). output.solver = ""ttmsolve""; output.times = times. output.ttmconvergence = diff. if opt.store_states:; output.states = states. return output. def _generatetensors(dynmaps, learningtimes=None, **kwargs):; """"""; Generate the tensors :math:`T_1,\dots,T_K` from the dynamical maps; :math:`E(t_k)`. A stationary process is assumed, i.e., :math:`T_{n,k} = T_{n-k}`. Parameters; ----------; dynmaps : list of :class:`qutip.Qobj`; List of precomputed dynamical maps (superoperators) at the times; specified in `learningtimes`, or a callback function that returns the; superoperator at a given time. learningtimes : array_like; list of times :math:`t_k` to use if argument `dynmaps` is a callback; function. kwargs : dictionary; Optional keyword arguments. See; :class:`qutip.nonmarkov.ttm.TTMSolverOptions`. Returns; -------; Tlist: list of :class:`qutip.Qobj.`; A list of transfer tensors :math:`T_1,\dots,T_K`; """""". # Determine if dynmaps is callable or list-like; if callable(dynmaps):; if learningtimes is None:; raise TypeError(""Argument 'learnintimes' required when 'dynmaps'"" +; ""is a callback function.""). def dynmapfunc(n): return dynmaps(learningtimes[n]); Kmax = len(learningtimes); else:; try:; tmp = dynmaps[:]; del tmp. def dynmapfunc(n): return dynmaps[n]; Kmax = len(dynmaps); except TypeError:; raise TypeError(""Argument 'dynmaps' should be a callable or"" +; ""list-like.""). if ""opt"" not in kwargs:; opt = TTMSolverOptions(dynmaps=dynmaps, learningtimes=learningtimes,; **kwargs); else:; opt = kwargs['opt']. Tlist = []; diff = [0.0]; for n in range(Kmax):; T = dynmapfunc(n); for m in range(1, n):; T -= Tlist[n-m]*dynmapfunc(m); Tlist",MatchSource.WIKI,docs/4.2/modules/qutip/nonmarkov/transfertensor.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/nonmarkov/transfertensor.html
https://qutip.org/docs/4.2/modules/qutip/nonmarkov/transfertensor.html:7161,Usability,learn,learningtimes,7161,"put.solver = ""ttmsolve""; output.times = times. output.ttmconvergence = diff. if opt.store_states:; output.states = states. return output. def _generatetensors(dynmaps, learningtimes=None, **kwargs):; """"""; Generate the tensors :math:`T_1,\dots,T_K` from the dynamical maps; :math:`E(t_k)`. A stationary process is assumed, i.e., :math:`T_{n,k} = T_{n-k}`. Parameters; ----------; dynmaps : list of :class:`qutip.Qobj`; List of precomputed dynamical maps (superoperators) at the times; specified in `learningtimes`, or a callback function that returns the; superoperator at a given time. learningtimes : array_like; list of times :math:`t_k` to use if argument `dynmaps` is a callback; function. kwargs : dictionary; Optional keyword arguments. See; :class:`qutip.nonmarkov.ttm.TTMSolverOptions`. Returns; -------; Tlist: list of :class:`qutip.Qobj.`; A list of transfer tensors :math:`T_1,\dots,T_K`; """""". # Determine if dynmaps is callable or list-like; if callable(dynmaps):; if learningtimes is None:; raise TypeError(""Argument 'learnintimes' required when 'dynmaps'"" +; ""is a callback function.""). def dynmapfunc(n): return dynmaps(learningtimes[n]); Kmax = len(learningtimes); else:; try:; tmp = dynmaps[:]; del tmp. def dynmapfunc(n): return dynmaps[n]; Kmax = len(dynmaps); except TypeError:; raise TypeError(""Argument 'dynmaps' should be a callable or"" +; ""list-like.""). if ""opt"" not in kwargs:; opt = TTMSolverOptions(dynmaps=dynmaps, learningtimes=learningtimes,; **kwargs); else:; opt = kwargs['opt']. Tlist = []; diff = [0.0]; for n in range(Kmax):; T = dynmapfunc(n); for m in range(1, n):; T -= Tlist[n-m]*dynmapfunc(m); Tlist.append(T); if n > 1:; diff.append((Tlist[-1]-Tlist[-2]).norm()); if diff[-1] < opt.thres:; # Below threshold for truncation; print('breaking', (Tlist[-1]-Tlist[-2]).norm(), n); break; return Tlist, diff. Â© Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, and A.L. Grimsmo.; Last updated on Jan 17, 2018. . Built with Sphinx u",MatchSource.WIKI,docs/4.2/modules/qutip/nonmarkov/transfertensor.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/nonmarkov/transfertensor.html
https://qutip.org/docs/4.2/modules/qutip/nonmarkov/transfertensor.html:7212,Usability,learn,learnintimes,7212,"put.solver = ""ttmsolve""; output.times = times. output.ttmconvergence = diff. if opt.store_states:; output.states = states. return output. def _generatetensors(dynmaps, learningtimes=None, **kwargs):; """"""; Generate the tensors :math:`T_1,\dots,T_K` from the dynamical maps; :math:`E(t_k)`. A stationary process is assumed, i.e., :math:`T_{n,k} = T_{n-k}`. Parameters; ----------; dynmaps : list of :class:`qutip.Qobj`; List of precomputed dynamical maps (superoperators) at the times; specified in `learningtimes`, or a callback function that returns the; superoperator at a given time. learningtimes : array_like; list of times :math:`t_k` to use if argument `dynmaps` is a callback; function. kwargs : dictionary; Optional keyword arguments. See; :class:`qutip.nonmarkov.ttm.TTMSolverOptions`. Returns; -------; Tlist: list of :class:`qutip.Qobj.`; A list of transfer tensors :math:`T_1,\dots,T_K`; """""". # Determine if dynmaps is callable or list-like; if callable(dynmaps):; if learningtimes is None:; raise TypeError(""Argument 'learnintimes' required when 'dynmaps'"" +; ""is a callback function.""). def dynmapfunc(n): return dynmaps(learningtimes[n]); Kmax = len(learningtimes); else:; try:; tmp = dynmaps[:]; del tmp. def dynmapfunc(n): return dynmaps[n]; Kmax = len(dynmaps); except TypeError:; raise TypeError(""Argument 'dynmaps' should be a callable or"" +; ""list-like.""). if ""opt"" not in kwargs:; opt = TTMSolverOptions(dynmaps=dynmaps, learningtimes=learningtimes,; **kwargs); else:; opt = kwargs['opt']. Tlist = []; diff = [0.0]; for n in range(Kmax):; T = dynmapfunc(n); for m in range(1, n):; T -= Tlist[n-m]*dynmapfunc(m); Tlist.append(T); if n > 1:; diff.append((Tlist[-1]-Tlist[-2]).norm()); if diff[-1] < opt.thres:; # Below threshold for truncation; print('breaking', (Tlist[-1]-Tlist[-2]).norm(), n); break; return Tlist, diff. Â© Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, and A.L. Grimsmo.; Last updated on Jan 17, 2018. . Built with Sphinx u",MatchSource.WIKI,docs/4.2/modules/qutip/nonmarkov/transfertensor.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/nonmarkov/transfertensor.html
https://qutip.org/docs/4.2/modules/qutip/nonmarkov/transfertensor.html:7316,Usability,learn,learningtimes,7316,"es. output.ttmconvergence = diff. if opt.store_states:; output.states = states. return output. def _generatetensors(dynmaps, learningtimes=None, **kwargs):; """"""; Generate the tensors :math:`T_1,\dots,T_K` from the dynamical maps; :math:`E(t_k)`. A stationary process is assumed, i.e., :math:`T_{n,k} = T_{n-k}`. Parameters; ----------; dynmaps : list of :class:`qutip.Qobj`; List of precomputed dynamical maps (superoperators) at the times; specified in `learningtimes`, or a callback function that returns the; superoperator at a given time. learningtimes : array_like; list of times :math:`t_k` to use if argument `dynmaps` is a callback; function. kwargs : dictionary; Optional keyword arguments. See; :class:`qutip.nonmarkov.ttm.TTMSolverOptions`. Returns; -------; Tlist: list of :class:`qutip.Qobj.`; A list of transfer tensors :math:`T_1,\dots,T_K`; """""". # Determine if dynmaps is callable or list-like; if callable(dynmaps):; if learningtimes is None:; raise TypeError(""Argument 'learnintimes' required when 'dynmaps'"" +; ""is a callback function.""). def dynmapfunc(n): return dynmaps(learningtimes[n]); Kmax = len(learningtimes); else:; try:; tmp = dynmaps[:]; del tmp. def dynmapfunc(n): return dynmaps[n]; Kmax = len(dynmaps); except TypeError:; raise TypeError(""Argument 'dynmaps' should be a callable or"" +; ""list-like.""). if ""opt"" not in kwargs:; opt = TTMSolverOptions(dynmaps=dynmaps, learningtimes=learningtimes,; **kwargs); else:; opt = kwargs['opt']. Tlist = []; diff = [0.0]; for n in range(Kmax):; T = dynmapfunc(n); for m in range(1, n):; T -= Tlist[n-m]*dynmapfunc(m); Tlist.append(T); if n > 1:; diff.append((Tlist[-1]-Tlist[-2]).norm()); if diff[-1] < opt.thres:; # Below threshold for truncation; print('breaking', (Tlist[-1]-Tlist[-2]).norm(), n); break; return Tlist, diff. Â© Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, and A.L. Grimsmo.; Last updated on Jan 17, 2018. . Built with Sphinx using a theme provided by Read the Docs. . ",MatchSource.WIKI,docs/4.2/modules/qutip/nonmarkov/transfertensor.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/nonmarkov/transfertensor.html
https://qutip.org/docs/4.2/modules/qutip/nonmarkov/transfertensor.html:7346,Usability,learn,learningtimes,7346,"es. output.ttmconvergence = diff. if opt.store_states:; output.states = states. return output. def _generatetensors(dynmaps, learningtimes=None, **kwargs):; """"""; Generate the tensors :math:`T_1,\dots,T_K` from the dynamical maps; :math:`E(t_k)`. A stationary process is assumed, i.e., :math:`T_{n,k} = T_{n-k}`. Parameters; ----------; dynmaps : list of :class:`qutip.Qobj`; List of precomputed dynamical maps (superoperators) at the times; specified in `learningtimes`, or a callback function that returns the; superoperator at a given time. learningtimes : array_like; list of times :math:`t_k` to use if argument `dynmaps` is a callback; function. kwargs : dictionary; Optional keyword arguments. See; :class:`qutip.nonmarkov.ttm.TTMSolverOptions`. Returns; -------; Tlist: list of :class:`qutip.Qobj.`; A list of transfer tensors :math:`T_1,\dots,T_K`; """""". # Determine if dynmaps is callable or list-like; if callable(dynmaps):; if learningtimes is None:; raise TypeError(""Argument 'learnintimes' required when 'dynmaps'"" +; ""is a callback function.""). def dynmapfunc(n): return dynmaps(learningtimes[n]); Kmax = len(learningtimes); else:; try:; tmp = dynmaps[:]; del tmp. def dynmapfunc(n): return dynmaps[n]; Kmax = len(dynmaps); except TypeError:; raise TypeError(""Argument 'dynmaps' should be a callable or"" +; ""list-like.""). if ""opt"" not in kwargs:; opt = TTMSolverOptions(dynmaps=dynmaps, learningtimes=learningtimes,; **kwargs); else:; opt = kwargs['opt']. Tlist = []; diff = [0.0]; for n in range(Kmax):; T = dynmapfunc(n); for m in range(1, n):; T -= Tlist[n-m]*dynmapfunc(m); Tlist.append(T); if n > 1:; diff.append((Tlist[-1]-Tlist[-2]).norm()); if diff[-1] < opt.thres:; # Below threshold for truncation; print('breaking', (Tlist[-1]-Tlist[-2]).norm(), n); break; return Tlist, diff. Â© Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, and A.L. Grimsmo.; Last updated on Jan 17, 2018. . Built with Sphinx using a theme provided by Read the Docs. . ",MatchSource.WIKI,docs/4.2/modules/qutip/nonmarkov/transfertensor.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/nonmarkov/transfertensor.html
https://qutip.org/docs/4.2/modules/qutip/nonmarkov/transfertensor.html:7624,Usability,learn,learningtimes,7624,"es. output.ttmconvergence = diff. if opt.store_states:; output.states = states. return output. def _generatetensors(dynmaps, learningtimes=None, **kwargs):; """"""; Generate the tensors :math:`T_1,\dots,T_K` from the dynamical maps; :math:`E(t_k)`. A stationary process is assumed, i.e., :math:`T_{n,k} = T_{n-k}`. Parameters; ----------; dynmaps : list of :class:`qutip.Qobj`; List of precomputed dynamical maps (superoperators) at the times; specified in `learningtimes`, or a callback function that returns the; superoperator at a given time. learningtimes : array_like; list of times :math:`t_k` to use if argument `dynmaps` is a callback; function. kwargs : dictionary; Optional keyword arguments. See; :class:`qutip.nonmarkov.ttm.TTMSolverOptions`. Returns; -------; Tlist: list of :class:`qutip.Qobj.`; A list of transfer tensors :math:`T_1,\dots,T_K`; """""". # Determine if dynmaps is callable or list-like; if callable(dynmaps):; if learningtimes is None:; raise TypeError(""Argument 'learnintimes' required when 'dynmaps'"" +; ""is a callback function.""). def dynmapfunc(n): return dynmaps(learningtimes[n]); Kmax = len(learningtimes); else:; try:; tmp = dynmaps[:]; del tmp. def dynmapfunc(n): return dynmaps[n]; Kmax = len(dynmaps); except TypeError:; raise TypeError(""Argument 'dynmaps' should be a callable or"" +; ""list-like.""). if ""opt"" not in kwargs:; opt = TTMSolverOptions(dynmaps=dynmaps, learningtimes=learningtimes,; **kwargs); else:; opt = kwargs['opt']. Tlist = []; diff = [0.0]; for n in range(Kmax):; T = dynmapfunc(n); for m in range(1, n):; T -= Tlist[n-m]*dynmapfunc(m); Tlist.append(T); if n > 1:; diff.append((Tlist[-1]-Tlist[-2]).norm()); if diff[-1] < opt.thres:; # Below threshold for truncation; print('breaking', (Tlist[-1]-Tlist[-2]).norm(), n); break; return Tlist, diff. Â© Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, and A.L. Grimsmo.; Last updated on Jan 17, 2018. . Built with Sphinx using a theme provided by Read the Docs. . ",MatchSource.WIKI,docs/4.2/modules/qutip/nonmarkov/transfertensor.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/nonmarkov/transfertensor.html
https://qutip.org/docs/4.2/modules/qutip/nonmarkov/transfertensor.html:7638,Usability,learn,learningtimes,7638,"es. output.ttmconvergence = diff. if opt.store_states:; output.states = states. return output. def _generatetensors(dynmaps, learningtimes=None, **kwargs):; """"""; Generate the tensors :math:`T_1,\dots,T_K` from the dynamical maps; :math:`E(t_k)`. A stationary process is assumed, i.e., :math:`T_{n,k} = T_{n-k}`. Parameters; ----------; dynmaps : list of :class:`qutip.Qobj`; List of precomputed dynamical maps (superoperators) at the times; specified in `learningtimes`, or a callback function that returns the; superoperator at a given time. learningtimes : array_like; list of times :math:`t_k` to use if argument `dynmaps` is a callback; function. kwargs : dictionary; Optional keyword arguments. See; :class:`qutip.nonmarkov.ttm.TTMSolverOptions`. Returns; -------; Tlist: list of :class:`qutip.Qobj.`; A list of transfer tensors :math:`T_1,\dots,T_K`; """""". # Determine if dynmaps is callable or list-like; if callable(dynmaps):; if learningtimes is None:; raise TypeError(""Argument 'learnintimes' required when 'dynmaps'"" +; ""is a callback function.""). def dynmapfunc(n): return dynmaps(learningtimes[n]); Kmax = len(learningtimes); else:; try:; tmp = dynmaps[:]; del tmp. def dynmapfunc(n): return dynmaps[n]; Kmax = len(dynmaps); except TypeError:; raise TypeError(""Argument 'dynmaps' should be a callable or"" +; ""list-like.""). if ""opt"" not in kwargs:; opt = TTMSolverOptions(dynmaps=dynmaps, learningtimes=learningtimes,; **kwargs); else:; opt = kwargs['opt']. Tlist = []; diff = [0.0]; for n in range(Kmax):; T = dynmapfunc(n); for m in range(1, n):; T -= Tlist[n-m]*dynmapfunc(m); Tlist.append(T); if n > 1:; diff.append((Tlist[-1]-Tlist[-2]).norm()); if diff[-1] < opt.thres:; # Below threshold for truncation; print('breaking', (Tlist[-1]-Tlist[-2]).norm(), n); break; return Tlist, diff. Â© Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, and A.L. Grimsmo.; Last updated on Jan 17, 2018. . Built with Sphinx using a theme provided by Read the Docs. . ",MatchSource.WIKI,docs/4.2/modules/qutip/nonmarkov/transfertensor.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/nonmarkov/transfertensor.html
https://qutip.org/docs/4.2/modules/qutip/qip/circuit.html:32119,Deployability,update,updated,32119,"(r"" \qswap ""); else:; col.append(r"" \gate{%s} "" %; _gate_label(gate.name, gate.arg_label)). elif gate.controls and n in gate.controls:; m = (gate.targets[0] - n) * (-1 if self.reverse_states; else 1); if gate.name == ""SWAP"":; col.append(r"" \qswap \ctrl{%d} "" % m); else:; col.append(r"" \ctrl{%d} "" % m). elif (not gate.controls and not gate.targets):; # global gate; if ((self.reverse_states and n == self.N - 1); or (not self.reverse_states and n == 0)):; col.append(r"" \multigate{%d}{%s} "" %; (self.N - 1,; _gate_label(gate.name, gate.arg_label))); else:; col.append(r"" \ghost{%s} "" %; (_gate_label(gate.name, gate.arg_label))). else:; col.append(r"" \qw ""). col.append(r"" \qw ""); rows.append(col). input_states = [""\lstick{\ket{"" + x + ""}}"" if x is not None; else """" for x in self.input_states]. code = """"; n_iter = (reversed(range(self.N)) if self.reverse_states; else range(self.N)); for n in n_iter:; code += r"" & %s"" % input_states[n]; for m in range(len(gates)):; code += r"" & %s"" % rows[m][n]; code += r"" & \qw \\ "" + ""\n"". return code. def _repr_png_(self):; return _latex_compile(self.latex_code(), format=""png""). def _repr_svg_(self):; return _latex_compile(self.latex_code(), format=""svg""). @property; def png(self):; from IPython.display import Image; return Image(self._repr_png_(), embed=True). @property; def svg(self):; from IPython.display import SVG; return SVG(self._repr_svg_()). def qasm(self):. code = ""# qasm code generated by QuTiP\n\n"". for n in range(self.N):; code += ""\tqubit\tq%d\n"" % n. code += ""\n"". for gate in self.gates:; code += ""\t%s\t"" % gate.name; qtargets = [""q%d"" %; t for t in gate.targets] if gate.targets else []; qcontrols = ([""q%d"" % c for c in gate.controls] if gate.controls; else []); code += "","".join(qtargets + qcontrols); code += ""\n"". return code. Â© Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, and A.L. Grimsmo.; Last updated on Jan 17, 2018. . Built with Sphinx using a theme provided by Read the Docs. . ",MatchSource.WIKI,docs/4.2/modules/qutip/qip/circuit.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/qip/circuit.html
https://qutip.org/docs/4.2/modules/qutip/qip/circuit.html:7175,Modifiability,variab,variable,7175,"ult: ""input"". """"""; if state_type == ""input"":; for i in targets:; self.input_states[i] = state; if state_type == ""output"":; for i in targets:; self.output_states[i] = state. [docs] def add_gate(self, gate, targets=None, controls=None, arg_value=None,; arg_label=None):; """"""; Adds a gate with specified parameters to the circuit. Parameters; ----------; gate: String or `Gate`; Gate name. If gate is an instance of `Gate`, parameters are; unpacked and added.; targets: List; Gate targets.; controls: List; Gate controls.; arg_value: Float; Argument value(phi).; arg_label: String; Label for gate representation.; """"""; if isinstance(gate, Gate):; name = gate.name; targets = gate.targets; controls = gate.controls; arg_value = gate.arg_value; arg_label = gate.arg_label. else:; name = gate; self.gates.append(Gate(name, targets=targets, controls=controls,; arg_value=arg_value, arg_label=arg_label)). [docs] def add_1q_gate(self, name, start=0, end=None, qubits=None,; arg_value=None, arg_label=None):; """"""; Adds a single qubit gate with specified parameters on a variable; number of qubits in the circuit. By default, it applies the given gate; to all the qubits in the register. Parameters; ----------; name : String; Gate name.; start : Integer; Starting location of qubits.; end : Integer; Last qubit for the gate.; qubits : List; Specific qubits for applying gates.; arg_value : Float; Argument value(phi).; arg_label : String; Label for gate representation.; """"""; if name not in [""RX"", ""RY"", ""RZ"", ""SNOT"", ""SQRTNOT"", ""PHASEGATE""]:; raise ValueError(""%s is not a single qubit gate"" % name). if qubits is not None:; for i in range(len(qubits)):; self.gates.append(Gate(name, targets=qubits[i], controls=None,; arg_value=arg_value,; arg_label=arg_label)). else:; if end is None:; end = self.N - 1; for i in range(start, end):; self.gates.append(Gate(name, targets=i, controls=None,; arg_value=arg_value,; arg_label=arg_label)). [docs] def add_circuit(self, qc, start=0):; """"""; Adds a block of a qubit",MatchSource.WIKI,docs/4.2/modules/qutip/qip/circuit.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/qip/circuit.html
https://qutip.org/docs/4.2/modules/qutip/qip/gates.html:25515,Deployability,update,updated,25515,"]], p[1]. elif target == 1 and controls[1] == 0:; # target -> controls[1] -> controls[0] -> outside; p[2], p[1] = p[1], p[2]; p[2], p[0] = p[0], p[2]; p[2], p[controls[0]] = p[controls[0]], p[2]. elif target == 0 and controls[0] == 1:; # target -> controls[0] -> controls[1] -> outside; p[2], p[0] = p[0], p[2]; p[2], p[1] = p[1], p[2]; p[2], p[controls[1]] = p[controls[1]], p[2]. elif controls[0] == 0 and controls[1] == 2:; # controls[0] -> self, controls[1] -> target -> outside; p[1], p[2] = p[2], p[1]; p[1], p[target] = p[target], p[1]. elif controls[1] == 1 and controls[0] == 2:; # controls[1] -> self, controls[0] -> target -> outside; p[0], p[2] = p[2], p[0]; p[0], p[target] = p[target], p[0]. elif target == 2 and controls[0] == 1:; # target -> self, controls[0] -> controls[1] -> outside; p[0], p[1] = p[1], p[0]; p[0], p[controls[1]] = p[controls[1]], p[0]. #; # N > 4 cases; #. elif controls[0] == 1 and controls[1] > 2 and target > 2:; # controls[0] -> controls[1] -> outside, target -> outside; p[0], p[1] = p[1], p[0]; p[0], p[controls[1]] = p[controls[1]], p[0]; p[2], p[target] = p[target], p[2]. elif controls[0] == 2 and controls[1] > 2 and target > 2:; # controls[0] -> target -> outside, controls[1] -> outside; p[0], p[2] = p[2], p[0]; p[0], p[target] = p[target], p[0]; p[1], p[controls[1]] = p[controls[1]], p[1]. elif controls[1] == 2 and controls[0] > 2 and target > 2:; # controls[1] -> target -> outside, controls[0] -> outside; p[1], p[2] = p[2], p[1]; p[1], p[target] = p[target], p[1]; p[0], p[controls[0]] = p[controls[0]], p[0]. else:; p[0], p[controls[0]] = p[controls[0]], p[0]; p1[1], p1[controls[1]] = p1[controls[1]], p1[1]; p2[2], p2[target] = p2[target], p2[2]; p = [p[p1[p2[k]]] for k in range(N)]. return tensor([U] + [identity(2)] * (N - 3)).permute(p). Â© Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, and A.L. Grimsmo.; Last updated on Jan 17, 2018. . Built with Sphinx using a theme provided by Read the Docs. . ",MatchSource.WIKI,docs/4.2/modules/qutip/qip/gates.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/qip/gates.html
https://qutip.org/docs/4.2/modules/qutip/qip/gates.html:2348,Energy Efficiency,reduce,reduce,2348,"ITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A; # PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT; # HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,; # SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT; # LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,; # DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY; # THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT; # (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE; # OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.; ###############################################################################; from __future__ import division. import numpy as np; import scipy.sparse as sp; from qutip.qobj import Qobj; from qutip.operators import identity, qeye, sigmax; from qutip.tensor import tensor; from qutip.states import fock_dm. from itertools import product; from functools import partial, reduce; from operator import mul. __all__ = ['rx', 'ry', 'rz', 'sqrtnot', 'snot', 'phasegate', 'cphase', 'cnot',; 'csign', 'berkeley', 'swapalpha', 'swap', 'iswap', 'sqrtswap',; 'sqrtiswap', 'fredkin', 'toffoli', 'rotation', 'controlled_gate',; 'globalphase', 'hadamard_transform', 'gate_sequence_product',; 'gate_expand_1toN', 'gate_expand_2toN', 'gate_expand_3toN',; 'qubit_clifford_group']. #; # Single Qubit Gates; #. [docs]def rx(phi, N=None, target=0):; """"""Single-qubit rotation for operator sigmax with angle phi. Returns; -------; result : qobj; Quantum object for operator describing the rotation. """"""; if N is not None:; return gate_expand_1toN(rx(phi), N, target); else:; return Qobj([[np.cos(phi / 2), -1j * np.sin(phi / 2)],; [-1j * np.sin(phi / 2), np.cos(phi / 2)]]). [docs]def ry(phi, N=None, target=0):; """"""Single-qubit rotation for operator sigmay with angle phi. Returns; -------; result : qobj; Quantum object for operator describing the rotation. """"""; if N is not ",MatchSource.WIKI,docs/4.2/modules/qutip/qip/gates.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/qip/gates.html
https://qutip.org/docs/4.2/modules/qutip/qip/gates.html:17569,Energy Efficiency,power,powers,17569,"teger x.; """"""; tot = 0; while x:; tot += 1; x &= x - 1; return tot. [docs]def hadamard_transform(N=1):; """"""Quantum object representing the N-qubit Hadamard gate. Returns; -------; q : qobj; Quantum object representation of the N-qubit Hadamard gate. """"""; data = 2 ** (-N / 2) * np.array([[(-1) ** _hamming_distance(i & j); for i in range(2 ** N)]; for j in range(2 ** N)]). return Qobj(data, dims=[[2] * N, [2] * N]). [docs]def gate_sequence_product(U_list, left_to_right=True):; """"""; Calculate the overall unitary matrix for a given list of unitary operations. Parameters; ----------; U_list : list; List of gates implementing the quantum circuit. left_to_right : Boolean; Check if multiplication is to be done from left to right. Returns; -------; U_overall : qobj; Overall unitary matrix of a given quantum circuit. """"""; U_overall = 1; for U in U_list:; if left_to_right:; U_overall = U * U_overall; else:; U_overall = U_overall * U. return U_overall. def _powers(op, N):; """"""; Generator that yields powers of an operator `op`,; through to `N`.; """"""; acc = qeye(op.dims[0]); yield acc. for _ in range(N - 1):; acc *= op; yield acc. def qubit_clifford_group(N=None, target=0):; """"""; Generates the Clifford group on a single qubit,; using the presentation of the group given by Ross and Selinger; (http://www.mathstat.dal.ca/~selinger/newsynth/). Parameters; -----------. N : int or None; Number of qubits on which each operator is to be defined; (default: 1).; target : int; Index of the target qubit on which the single-qubit; Clifford operators are to act. Yields; ------. op : Qobj; Clifford operators, represented as Qobj instances. """""". # The Ross-Selinger presentation of the single-qubit Clifford; # group expresses each element in the form C_{ijk} = E^i X^j S^k; # for gates E, X and S, and for i in range(3), j in range(2) and; # k in range(4).; #; # We start by defining these gates. E is defined in terms of H,; # \omega and S, so we define \omega and H first.; w = np.exp(1j * 2 * np.pi ",MatchSource.WIKI,docs/4.2/modules/qutip/qip/gates.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/qip/gates.html
https://qutip.org/docs/4.2/modules/qutip/qip/gates.html:18674,Energy Efficiency,reduce,reduce,18674,"cc. def qubit_clifford_group(N=None, target=0):; """"""; Generates the Clifford group on a single qubit,; using the presentation of the group given by Ross and Selinger; (http://www.mathstat.dal.ca/~selinger/newsynth/). Parameters; -----------. N : int or None; Number of qubits on which each operator is to be defined; (default: 1).; target : int; Index of the target qubit on which the single-qubit; Clifford operators are to act. Yields; ------. op : Qobj; Clifford operators, represented as Qobj instances. """""". # The Ross-Selinger presentation of the single-qubit Clifford; # group expresses each element in the form C_{ijk} = E^i X^j S^k; # for gates E, X and S, and for i in range(3), j in range(2) and; # k in range(4).; #; # We start by defining these gates. E is defined in terms of H,; # \omega and S, so we define \omega and H first.; w = np.exp(1j * 2 * np.pi / 8); H = snot(). X = sigmax(); S = phasegate(np.pi / 2); E = H * (S ** 3) * w ** 3. for op in map(partial(reduce, mul), product(_powers(E, 3),; _powers(X, 2), _powers(S, 4))):. # partial(reduce, mul) returns a function that takes products; # of its argument, by analogy to sum. Note that by analogy,; # sum can be written as partial(reduce, add). # product(...) yields the Cartesian product of its arguments.; # Here, each element is a tuple (E**i, X**j, S**k) such that; # partial(reduce, mul) acting on the tuple yields E**i * X**j * S**k. # Finally, we optionally expand the gate.; if N is not None:; yield gate_expand_1toN(op, N, target); else:; yield op. #; # Gate Expand; #. [docs]def gate_expand_1toN(U, N, target):; """"""; Create a Qobj representing a one-qubit gate that act on a system with N; qubits. Parameters; ----------; U : Qobj; The one-qubit gate. N : integer; The number of qubits in the target space. target : integer; The index of the target qubit. Returns; -------; gate : qobj; Quantum object representation of N-qubit gate. """""". if N < 1:; raise ValueError(""integer N must be larger or equal to 1""). if targe",MatchSource.WIKI,docs/4.2/modules/qutip/qip/gates.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/qip/gates.html
https://qutip.org/docs/4.2/modules/qutip/qip/gates.html:18755,Energy Efficiency,reduce,reduce,18755,"bit,; using the presentation of the group given by Ross and Selinger; (http://www.mathstat.dal.ca/~selinger/newsynth/). Parameters; -----------. N : int or None; Number of qubits on which each operator is to be defined; (default: 1).; target : int; Index of the target qubit on which the single-qubit; Clifford operators are to act. Yields; ------. op : Qobj; Clifford operators, represented as Qobj instances. """""". # The Ross-Selinger presentation of the single-qubit Clifford; # group expresses each element in the form C_{ijk} = E^i X^j S^k; # for gates E, X and S, and for i in range(3), j in range(2) and; # k in range(4).; #; # We start by defining these gates. E is defined in terms of H,; # \omega and S, so we define \omega and H first.; w = np.exp(1j * 2 * np.pi / 8); H = snot(). X = sigmax(); S = phasegate(np.pi / 2); E = H * (S ** 3) * w ** 3. for op in map(partial(reduce, mul), product(_powers(E, 3),; _powers(X, 2), _powers(S, 4))):. # partial(reduce, mul) returns a function that takes products; # of its argument, by analogy to sum. Note that by analogy,; # sum can be written as partial(reduce, add). # product(...) yields the Cartesian product of its arguments.; # Here, each element is a tuple (E**i, X**j, S**k) such that; # partial(reduce, mul) acting on the tuple yields E**i * X**j * S**k. # Finally, we optionally expand the gate.; if N is not None:; yield gate_expand_1toN(op, N, target); else:; yield op. #; # Gate Expand; #. [docs]def gate_expand_1toN(U, N, target):; """"""; Create a Qobj representing a one-qubit gate that act on a system with N; qubits. Parameters; ----------; U : Qobj; The one-qubit gate. N : integer; The number of qubits in the target space. target : integer; The index of the target qubit. Returns; -------; gate : qobj; Quantum object representation of N-qubit gate. """""". if N < 1:; raise ValueError(""integer N must be larger or equal to 1""). if target >= N:; raise ValueError(""target must be integer < integer N""). return tensor([identity(2)] * (t",MatchSource.WIKI,docs/4.2/modules/qutip/qip/gates.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/qip/gates.html
https://qutip.org/docs/4.2/modules/qutip/qip/gates.html:18901,Energy Efficiency,reduce,reduce,18901,"hstat.dal.ca/~selinger/newsynth/). Parameters; -----------. N : int or None; Number of qubits on which each operator is to be defined; (default: 1).; target : int; Index of the target qubit on which the single-qubit; Clifford operators are to act. Yields; ------. op : Qobj; Clifford operators, represented as Qobj instances. """""". # The Ross-Selinger presentation of the single-qubit Clifford; # group expresses each element in the form C_{ijk} = E^i X^j S^k; # for gates E, X and S, and for i in range(3), j in range(2) and; # k in range(4).; #; # We start by defining these gates. E is defined in terms of H,; # \omega and S, so we define \omega and H first.; w = np.exp(1j * 2 * np.pi / 8); H = snot(). X = sigmax(); S = phasegate(np.pi / 2); E = H * (S ** 3) * w ** 3. for op in map(partial(reduce, mul), product(_powers(E, 3),; _powers(X, 2), _powers(S, 4))):. # partial(reduce, mul) returns a function that takes products; # of its argument, by analogy to sum. Note that by analogy,; # sum can be written as partial(reduce, add). # product(...) yields the Cartesian product of its arguments.; # Here, each element is a tuple (E**i, X**j, S**k) such that; # partial(reduce, mul) acting on the tuple yields E**i * X**j * S**k. # Finally, we optionally expand the gate.; if N is not None:; yield gate_expand_1toN(op, N, target); else:; yield op. #; # Gate Expand; #. [docs]def gate_expand_1toN(U, N, target):; """"""; Create a Qobj representing a one-qubit gate that act on a system with N; qubits. Parameters; ----------; U : Qobj; The one-qubit gate. N : integer; The number of qubits in the target space. target : integer; The index of the target qubit. Returns; -------; gate : qobj; Quantum object representation of N-qubit gate. """""". if N < 1:; raise ValueError(""integer N must be larger or equal to 1""). if target >= N:; raise ValueError(""target must be integer < integer N""). return tensor([identity(2)] * (target) + [U] +; [identity(2)] * (N - target - 1)). [docs]def gate_expand_2toN(U, N, c",MatchSource.WIKI,docs/4.2/modules/qutip/qip/gates.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/qip/gates.html
https://qutip.org/docs/4.2/modules/qutip/qip/gates.html:19050,Energy Efficiency,reduce,reduce,19050," Index of the target qubit on which the single-qubit; Clifford operators are to act. Yields; ------. op : Qobj; Clifford operators, represented as Qobj instances. """""". # The Ross-Selinger presentation of the single-qubit Clifford; # group expresses each element in the form C_{ijk} = E^i X^j S^k; # for gates E, X and S, and for i in range(3), j in range(2) and; # k in range(4).; #; # We start by defining these gates. E is defined in terms of H,; # \omega and S, so we define \omega and H first.; w = np.exp(1j * 2 * np.pi / 8); H = snot(). X = sigmax(); S = phasegate(np.pi / 2); E = H * (S ** 3) * w ** 3. for op in map(partial(reduce, mul), product(_powers(E, 3),; _powers(X, 2), _powers(S, 4))):. # partial(reduce, mul) returns a function that takes products; # of its argument, by analogy to sum. Note that by analogy,; # sum can be written as partial(reduce, add). # product(...) yields the Cartesian product of its arguments.; # Here, each element is a tuple (E**i, X**j, S**k) such that; # partial(reduce, mul) acting on the tuple yields E**i * X**j * S**k. # Finally, we optionally expand the gate.; if N is not None:; yield gate_expand_1toN(op, N, target); else:; yield op. #; # Gate Expand; #. [docs]def gate_expand_1toN(U, N, target):; """"""; Create a Qobj representing a one-qubit gate that act on a system with N; qubits. Parameters; ----------; U : Qobj; The one-qubit gate. N : integer; The number of qubits in the target space. target : integer; The index of the target qubit. Returns; -------; gate : qobj; Quantum object representation of N-qubit gate. """""". if N < 1:; raise ValueError(""integer N must be larger or equal to 1""). if target >= N:; raise ValueError(""target must be integer < integer N""). return tensor([identity(2)] * (target) + [U] +; [identity(2)] * (N - target - 1)). [docs]def gate_expand_2toN(U, N, control=None, target=None, targets=None):; """"""; Create a Qobj representing a two-qubit gate that act on a system with N; qubits. Parameters; ----------; U : Qobj; T",MatchSource.WIKI,docs/4.2/modules/qutip/qip/gates.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/qip/gates.html
https://qutip.org/docs/4.2/modules/qutip/qip/qubits.html:2794,Deployability,update,updated,2794,"laimer in the; # documentation and/or other materials provided with the distribution.; #; # 3. Neither the name of the QuTiP: Quantum Toolbox in Python nor the names; # of its contributors may be used to endorse or promote products derived; # from this software without specific prior written permission.; #; # THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS; # ""AS IS"" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT; # LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A; # PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT; # HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,; # SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT; # LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,; # DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY; # THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT; # (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE; # OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.; ###############################################################################. __all__ = ['qubit_states']. from qutip.tensor import tensor; from numpy import sqrt; from qutip.states import basis. [docs]def qubit_states(N=1, states=[0]):; """"""; Function to define initial state of the qubits. Parameters; ----------; N : Integer; Number of qubits in the register.; states : List; Initial state of each qubit. Returns; ----------; qstates : Qobj; List of qubits. """"""; state_list = []; for i in range(N):; if N > len(states) and i >= len(states):; state_list.append(0); else:; state_list.append(states[i]). return tensor([alpha * basis(2, 1) + sqrt(1 - alpha**2) * basis(2, 0); for alpha in state_list]). Â© Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, and A.L. Grimsmo.; Last updated on Jan 17, 2018. . Built with Sphinx using a theme provided by Read the Docs. . ",MatchSource.WIKI,docs/4.2/modules/qutip/qip/qubits.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/qip/qubits.html
https://qutip.org/docs/4.2/modules/qutip/qip/algorithms/qft.html:4592,Deployability,update,updated,4592,"i / N2; arr = np.arange(N2); L, M = np.meshgrid(arr, arr); L = phase * (L * M); L = np.exp(L); dims = [[2] * N, [2] * N]; return Qobj(1.0 / np.sqrt(N2) * L, dims=dims). [docs]def qft_steps(N=1, swapping=True):; """"""; Quantum Fourier Transform operator on N qubits returning the individual; steps as unitary matrices operating from left to right. Parameters; ----------; N: int; Number of qubits.; swap: boolean; Flag indicating sequence of swap gates to be applied at the end or not. Returns; -------; U_step_list: list of qobj; List of Hadamard and controlled rotation gates implementing QFT. """"""; if N < 1:; raise ValueError(""Minimum value of N can be 1""). U_step_list = []; if N == 1:; U_step_list.append(snot()); else:; for i in range(N):; for j in range(i):; U_step_list.append(cphase(np.pi / (2 ** (i - j)), N,; control=i, target=j)); U_step_list.append(snot(N, i)); if swapping:; for i in range(N // 2):; U_step_list.append(swap(N, [N - i - 1, i])). return U_step_list. [docs]def qft_gate_sequence(N=1, swapping=True):; """"""; Quantum Fourier Transform operator on N qubits returning the gate sequence. Parameters; ----------; N: int; Number of qubits.; swap: boolean; Flag indicating sequence of swap gates to be applied at the end or not. Returns; -------; qc: instance of QubitCircuit; Gate sequence of Hadamard and controlled rotation gates implementing; QFT.; """""". if N < 1:; raise ValueError(""Minimum value of N can be 1""). qc = QubitCircuit(N); if N == 1:; qc.add_gate(""SNOT"", targets=[0]); else:; for i in range(N):; for j in range(i):; qc.add_gate(""CPHASE"", targets=[j], controls=[i],; arg_label=r""{\pi/2^{%d}}"" % (i - j),; arg_value=np.pi / (2 ** (i - j))); qc.add_gate(""SNOT"", targets=[i]); if swapping:; for i in range(N // 2):; qc.add_gate(""SWAP"", targets=[N - i - 1, i]). return qc. Â© Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, and A.L. Grimsmo.; Last updated on Jan 17, 2018. . Built with Sphinx using a theme provided by Read the Docs. . ",MatchSource.WIKI,docs/4.2/modules/qutip/qip/algorithms/qft.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/qip/algorithms/qft.html
https://qutip.org/docs/4.2/modules/qutip/qip/models/circuitprocessor.html:7244,Deployability,update,updated,7244,"he propagator matrix obtained from the physical implementation.; """"""; if states is None:; raise NotImplementedError(""Qubit state not defined.""); if qc:; self.load_circuit(qc); U_list = [states]; H_ops, H_u = self.get_ops_and_u(). for n in range(len(self.T_list)):; H = sum([H_u[n, m] * H_ops[m] for m in range(len(H_ops))]); U = (-1j * H * self.T_list[n]).expm(); U = self.eliminate_auxillary_modes(U); U_list.append(U). if self.correct_global_phase and self.global_phase != 0:; U_list.append(globalphase(self.global_phase, N=self.N)). return U_list. [docs] def pulse_matrix(self):; """"""; Generates the pulse matrix for the desired physical system. Returns; --------; t, u, labels:; Returns the total time and label for every operation.; """"""; dt = 0.01; H_ops, H_u = self.get_ops_and_u(). t_tot = sum(self.T_list); n_t = int(np.ceil(t_tot / dt)); n_ops = len(H_ops). t = np.linspace(0, t_tot, n_t); u = np.zeros((n_ops, n_t)). t_start = 0; for n in range(len(self.T_list)):. t_idx_len = int(np.floor(self.T_list[n] / dt)). mm = 0; for m in range(len(H_ops)):; u[mm, t_start:(t_start + t_idx_len)] = (np.ones(t_idx_len) *; H_u[n, m]); mm += 1. t_start += t_idx_len. return t, u, self.get_ops_labels(). [docs] def plot_pulses(self):; """"""; Maps the physical interaction between the circuit components for the; desired physical system. Returns; --------; fig, ax: Figure; Maps the physical interaction between the circuit components.; """"""; import matplotlib.pyplot as plt; t, u, u_labels = self.pulse_matrix(); fig, ax = plt.subplots(1, 1, figsize=(12, 6)). for n, uu in enumerate(u):; ax.plot(t, u[n], label=u_labels[n]). ax.axis('tight'); ax.set_ylim(-1.5 * 2 * np.pi, 1.5 * 2 * np.pi); ax.legend(loc='center left',; bbox_to_anchor=(1, 0.5), ncol=(1 + len(u) // 16)); fig.tight_layout(). return fig, ax. Â© Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, and A.L. Grimsmo.; Last updated on Jan 17, 2018. . Built with Sphinx using a theme provided by Read the Docs. . ",MatchSource.WIKI,docs/4.2/modules/qutip/qip/models/circuitprocessor.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/qip/models/circuitprocessor.html
https://qutip.org/docs/4.2/modules/qutip/qip/models/cqed.html:9267,Deployability,update,updated,9267,"gate.targets[0]], None,; arg_value=-np.pi / 2,; arg_label=r""-\pi/2"")); qc.gates.append(Gate(""RZ"", [gate.targets[1]], None,; arg_value=-np.pi / 2,; arg_label=r""-\pi/2"")); qc.gates.append(Gate(""GLOBALPHASE"", None, None,; arg_value=-np.pi / 2,; arg_label=r""-\pi/2"")). return qc. def load_circuit(self, qc):. gates = self.optimize_circuit(qc).gates. self.global_phase = 0; self.sx_u = np.zeros((len(gates), len(self.sx_ops))); self.sz_u = np.zeros((len(gates), len(self.sz_ops))); self.g_u = np.zeros((len(gates), len(self.cavityqubit_ops))); self.T_list = []. n = 0; for gate in gates:. if gate.name == ""ISWAP"":; t0, t1 = gate.targets[0], gate.targets[1]; self.sz_u[n, t0] = self.wq[t0] - self.w0; self.sz_u[n, t1] = self.wq[t1] - self.w0; self.g_u[n, t0] = self.g[t0]; self.g_u[n, t1] = self.g[t1]. J = self.g[t0] * self.g[t1] * (1 / self.Delta[t0] +; 1 / self.Delta[t1]) / 2; T = (4 * np.pi / abs(J)) / 4; self.T_list.append(T); n += 1. elif gate.name == ""SQRTISWAP"":; t0, t1 = gate.targets[0], gate.targets[1]; self.sz_u[n, t0] = self.wq[t0] - self.w0; self.sz_u[n, t1] = self.wq[t1] - self.w0; self.g_u[n, t0] = self.g[t0]; self.g_u[n, t1] = self.g[t1]. J = self.g[t0] * self.g[t1] * (1 / self.Delta[t0] +; 1 / self.Delta[t1]) / 2; T = (4 * np.pi / abs(J)) / 8; self.T_list.append(T); n += 1. elif gate.name == ""RZ"":; g = self.sz_coeff[gate.targets[0]]; self.sz_u[n, gate.targets[0]] = np.sign(gate.arg_value) * g; T = abs(gate.arg_value) / (2 * g); self.T_list.append(T); n += 1. elif gate.name == ""RX"":; g = self.sx_coeff[gate.targets[0]]; self.sx_u[n, gate.targets[0]] = np.sign(gate.arg_value) * g; T = abs(gate.arg_value) / (2 * g); self.T_list.append(T); n += 1. elif gate.name == ""GLOBALPHASE"":; self.global_phase += gate.arg_value. else:; raise ValueError(""Unsupported gate %s"" % gate.name). Â© Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, and A.L. Grimsmo.; Last updated on Jan 17, 2018. . Built with Sphinx using a theme provided by Read the Docs. . ",MatchSource.WIKI,docs/4.2/modules/qutip/qip/models/cqed.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/qip/models/cqed.html
https://qutip.org/docs/4.2/modules/qutip/qip/models/cqed.html:2663,Energy Efficiency,energy,energy,2663,"MPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT; # LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,; # DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY; # THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT; # (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE; # OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.; ###############################################################################; import numpy as np; import warnings; from qutip import tensor, identity, destroy, sigmax, sigmaz, basis; from qutip.qip.circuit import QubitCircuit, Gate; from qutip.qip.models.circuitprocessor import CircuitProcessor. [docs]class DispersivecQED(CircuitProcessor):; """"""; Representation of the physical implementation of a quantum; program/algorithm on a dispersive cavity-QED system.; """""". def __init__(self, N, correct_global_phase=True, Nres=None, deltamax=None,; epsmax=None, w0=None, wq=None, eps=None, delta=None, g=None):; """"""; Parameters; ----------; Nres: Integer; The number of energy levels in the resonator. deltamax: Integer/List; The sigma-x coefficient for each of the qubits in the system. epsmax: Integer/List; The sigma-z coefficient for each of the qubits in the system. wo: Integer; The base frequency of the resonator. wq: Integer/List; The frequency of the qubits. eps: Integer/List; The epsilon for each of the qubits in the system. delta: Integer/List; The epsilon for each of the qubits in the system. g: Integer/List; The interaction strength for each of the qubit with the resonator.; """""". super(DispersivecQED, self).__init__(N, correct_global_phase). # user definable; if Nres is None:; self.Nres = 10; else:; self.Nres = Nres. if deltamax is None:; self.sx_coeff = np.array([1.0 * 2 * np.pi] * N); elif not isinstance(deltamax, list):; self.sx_coeff = np.array([deltamax * 2 * np.pi] * N); else:; self.sx_coeff = np.array(deltamax). if epsmax is None:; self.sz_coeff = np.arr",MatchSource.WIKI,docs/4.2/modules/qutip/qip/models/cqed.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/qip/models/cqed.html
https://qutip.org/docs/4.2/modules/qutip/qip/models/cqed.html:4892,Testability,test,tests,4892,"):; self.eps = np.array([eps * 2 * np.pi] * N); else:; self.eps = np.array(eps). if delta is None:; self.delta = np.array([0.0 * 2 * np.pi] * N); elif not isinstance(delta, list):; self.delta = np.array([delta * 2 * np.pi] * N); else:; self.delta = np.array(delta). if g is None:; self.g = np.array([0.01 * 2 * np.pi] * N); elif not isinstance(g, list):; self.g = np.array([g * 2 * np.pi] * N); else:; self.g = np.array(g). if wq is not None:; if not isinstance(wq, list):; self.wq = np.array([wq] * N); else:; self.wq = np.array(wq). if wq is None:; if eps is None:; self.eps = np.array([9.5 * 2 * np.pi] * N); elif not isinstance(eps, list):; self.eps = np.array([eps] * N); else:; self.eps = np.array(eps). if delta is None:; self.delta = np.array([0.0 * 2 * np.pi] * N); elif not isinstance(delta, list):; self.delta = np.array([delta] * N); else:; self.delta = np.array(delta). # computed; self.wq = np.sqrt(self.eps ** 2 + self.delta ** 2); self.Delta = self.wq - self.w0. # rwa/dispersive regime tests; if any(self.g / (self.w0 - self.wq) > 0.05):; warnings.warn(""Not in the dispersive regime""). if any((self.w0 - self.wq) / (self.w0 + self.wq) > 0.05):; warnings.warn(; ""The rotating-wave approximation might not be valid.""). self.sx_ops = [tensor([identity(self.Nres)] +; [sigmax() if m == n else identity(2); for n in range(N)]); for m in range(N)]; self.sz_ops = [tensor([identity(self.Nres)] +; [sigmaz() if m == n else identity(2); for n in range(N)]); for m in range(N)]. self.a = tensor([destroy(self.Nres)] + [identity(2) for n in range(N)]). self.cavityqubit_ops = []; for n in range(N):; sm = tensor([identity(self.Nres)] +; [destroy(2) if m == n else identity(2); for m in range(N)]); self.cavityqubit_ops.append(self.a.dag() * sm + self.a * sm.dag()). self.psi_proj = tensor([basis(self.Nres, 0)] +; [identity(2) for n in range(N)]). def get_ops_and_u(self):; H0 = self.a.dag() * self.a; return ([H0] + self.sx_ops + self.sz_ops + self.cavityqubit_ops,; np.hstack((self.w0 * np.ze",MatchSource.WIKI,docs/4.2/modules/qutip/qip/models/cqed.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/qip/models/cqed.html
https://qutip.org/docs/4.2/modules/qutip/qip/models/spinchain.html:12533,Deployability,update,updated,12533,"ed in a linear; formation. It is a sub-class of SpinChain.; """""". def __init__(self, N, correct_global_phase=True,; sx=None, sz=None, sxsy=None):. super(LinearSpinChain, self).__init__(N, correct_global_phase,; sx, sz, sxsy). def get_ops_labels(self):; return ([r""$\sigma_x^%d$"" % n for n in range(self.N)] +; [r""$\sigma_z^%d$"" % n for n in range(self.N)] +; [r""$\sigma_x^%d\sigma_x^{%d} + \sigma_y^%d\sigma_y^{%d}$""; % (n, n, n + 1, n + 1) for n in range(self.N - 1)]). def optimize_circuit(self, qc):; self.qc0 = qc; self.qc1 = self.adjacent_gates(self.qc0, ""linear""); self.qc2 = self.qc1.resolve_gates(basis=[""ISWAP"", ""RX"", ""RZ""]); return self.qc2. [docs]class CircularSpinChain(SpinChain):; """"""; Representation of the physical implementation of a quantum; program/algorithm on a spin chain qubit system arranged in a circular; formation. It is a sub-class of SpinChain.; """""". def __init__(self, N, correct_global_phase=True,; sx=None, sz=None, sxsy=None):. super(CircularSpinChain, self).__init__(N, correct_global_phase,; sx, sz, sxsy). x = [identity(2)] * N; x[0] = x[N - 1] = sigmax(); y = [identity(2)] * N; y[0] = y[N - 1] = sigmay(); self.sxsy_ops.append(tensor(x) + tensor(y)). if sxsy is None:; self.sxsy_coeff = [0.1 * 2 * np.pi] * N; elif not isinstance(sxsy, list):; self.sxsy_coeff = [sxsy * 2 * np.pi] * N; else:; self.sxsy_coeff = sxsy. def get_ops_labels(self):; return ([r""$\sigma_x^%d$"" % n for n in range(self.N)] +; [r""$\sigma_z^%d$"" % n for n in range(self.N)] +; [r""$\sigma_x^%d\sigma_x^{%d} + \sigma_y^%d\sigma_y^{%d}$""; % (n, n, (n + 1) % self.N, (n + 1) % self.N); for n in range(self.N)]). def optimize_circuit(self, qc):; self.qc0 = qc; self.qc1 = self.adjacent_gates(self.qc0, ""circular""); self.qc2 = self.qc1.resolve_gates(basis=[""ISWAP"", ""RX"", ""RZ""]); return self.qc2. Â© Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, and A.L. Grimsmo.; Last updated on Jan 17, 2018. . Built with Sphinx using a theme provided by Read the Docs. . ",MatchSource.WIKI,docs/4.2/modules/qutip/qip/models/spinchain.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/qip/models/spinchain.html
https://qutip.org/docs/4.3/apidoc/apidoc.html:1861,Deployability,update,updated,1861,". . API documentation â QuTiP 4.3 Documentation. QuTiP: Quantum Toolbox in Python; . ; . 4.3; . Frontmatter; Installation; Users Guide; API documentation; Classes; Functions. Change Log; Developers; Bibliography. QuTiP: Quantum Toolbox in Python. Docs Â»; API documentation. API documentationÂ¶; This chapter contains automatically generated API documentation, including a; complete list of QuTiPâs public classes and functions. Classes; Qobj; eseries; Bloch sphere; Cubic Spline; Non-Markovian Solvers; Solver Options and Results. Permutational Invariance; Distribution functions; Quantum information processing; Optimal control. Functions; Manipulation and Creation of States and Operators; Quantum States; Quantum Operators; Random Operators and States; Three-Level Atoms; Superoperators and Liouvillians; Superoperator Representations. Functions acting on states and operators; Expectation Values; Tensor; Partial Transpose; Entropy Functions; Density Matrix Metrics; Continuous Variables. Dynamics and Time-Evolution; SchrÃ¶dinger Equation; Master Equation; Monte Carlo Evolution; Exponential Series; Bloch-Redfield Master Equation; Floquet States and Floquet-Markov Master Equation; Stochastic SchrÃ¶dinger Equation and Master Equation; Correlation Functions; Steady-state Solvers; Propagators; Time-dependent problems; Scattering in Quantum Optical Systems; Permutational Invariance. Visualization; Pseudoprobability Functions; Graphs and Visualization; Quantum Process Tomography. Quantum Information Processing; Gates; Qubits; Algorithms. non-Markovian Solvers; Optimal control; GRAPE; CRAB. Utility Functions; Graph Theory Routines; Utility Functions; File I/O Functions; Parallelization; IPython Notebook Tools; Miscellaneous. Next ; Previous. Â© Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, and A.L. Grimsmo; Last updated on Feb 26, 2019. . Built with Sphinx using a theme provided by Read the Docs. . ",MatchSource.WIKI,docs/4.3/apidoc/apidoc.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/apidoc/apidoc.html
https://qutip.org/docs/4.3/apidoc/apidoc.html:1302,Integrability,depend,dependent,1302,". . API documentation â QuTiP 4.3 Documentation. QuTiP: Quantum Toolbox in Python; . ; . 4.3; . Frontmatter; Installation; Users Guide; API documentation; Classes; Functions. Change Log; Developers; Bibliography. QuTiP: Quantum Toolbox in Python. Docs Â»; API documentation. API documentationÂ¶; This chapter contains automatically generated API documentation, including a; complete list of QuTiPâs public classes and functions. Classes; Qobj; eseries; Bloch sphere; Cubic Spline; Non-Markovian Solvers; Solver Options and Results. Permutational Invariance; Distribution functions; Quantum information processing; Optimal control. Functions; Manipulation and Creation of States and Operators; Quantum States; Quantum Operators; Random Operators and States; Three-Level Atoms; Superoperators and Liouvillians; Superoperator Representations. Functions acting on states and operators; Expectation Values; Tensor; Partial Transpose; Entropy Functions; Density Matrix Metrics; Continuous Variables. Dynamics and Time-Evolution; SchrÃ¶dinger Equation; Master Equation; Monte Carlo Evolution; Exponential Series; Bloch-Redfield Master Equation; Floquet States and Floquet-Markov Master Equation; Stochastic SchrÃ¶dinger Equation and Master Equation; Correlation Functions; Steady-state Solvers; Propagators; Time-dependent problems; Scattering in Quantum Optical Systems; Permutational Invariance. Visualization; Pseudoprobability Functions; Graphs and Visualization; Quantum Process Tomography. Quantum Information Processing; Gates; Qubits; Algorithms. non-Markovian Solvers; Optimal control; GRAPE; CRAB. Utility Functions; Graph Theory Routines; Utility Functions; File I/O Functions; Parallelization; IPython Notebook Tools; Miscellaneous. Next ; Previous. Â© Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, and A.L. Grimsmo; Last updated on Feb 26, 2019. . Built with Sphinx using a theme provided by Read the Docs. . ",MatchSource.WIKI,docs/4.3/apidoc/apidoc.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/apidoc/apidoc.html
https://qutip.org/docs/4.3/apidoc/classes.html:6325,Availability,toler,tolerance,6325,"erwise complex values are returned. dnorm(B=None)[source]Â¶; Calculates the diamond norm, or the diamond distance to another; operator. Parameters:; B : Qobj or None; If B is not None, the diamond distance d(A, B) = dnorm(A - B) between; this operator and B is returned instead of the diamond norm. Returns:; d : float; Either the diamond norm of this operator, or the diamond distance; from this operator to B. dual_chan()[source]Â¶; Dual channel of quantum object representing a completely positive; map. eigenenergies(sparse=False, sort='low', eigvals=0, tol=0, maxiter=100000)[source]Â¶; Eigenenergies of a quantum object.; Eigenenergies (eigenvalues) are defined for operators or superoperators; only. Parameters:; sparse : bool; Use sparse Eigensolver. sort : str; Sort eigenvalues âlowâ to high, or âhighâ to low. eigvals : int; Number of requested eigenvalues. Default is all eigenvalues. tol : float; Tolerance used by sparse Eigensolver (0=machine precision).; The sparse solver may not converge if the tolerance is set too low. maxiter : int; Maximum number of iterations performed by sparse solver (if used). Returns:; eigvals : array; Array of eigenvalues for operator. Notes; The sparse eigensolver is much slower than the dense version.; Use sparse only if memory requirements demand it. eigenstates(sparse=False, sort='low', eigvals=0, tol=0, maxiter=100000)[source]Â¶; Eigenstates and eigenenergies.; Eigenstates and eigenenergies are defined for operators and; superoperators only. Parameters:; sparse : bool; Use sparse Eigensolver. sort : str; Sort eigenvalues (and vectors) âlowâ to high, or âhighâ to low. eigvals : int; Number of requested eigenvalues. Default is all eigenvalues. tol : float; Tolerance used by sparse Eigensolver (0 = machine precision).; The sparse solver may not converge if the tolerance is set too low. maxiter : int; Maximum number of iterations performed by sparse solver (if used). Returns:; eigvals : array; Array of eigenvalues for operator. eigvecs : arr",MatchSource.WIKI,docs/4.3/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/apidoc/classes.html
https://qutip.org/docs/4.3/apidoc/classes.html:7133,Availability,toler,tolerance,7133,"â to low. eigvals : int; Number of requested eigenvalues. Default is all eigenvalues. tol : float; Tolerance used by sparse Eigensolver (0=machine precision).; The sparse solver may not converge if the tolerance is set too low. maxiter : int; Maximum number of iterations performed by sparse solver (if used). Returns:; eigvals : array; Array of eigenvalues for operator. Notes; The sparse eigensolver is much slower than the dense version.; Use sparse only if memory requirements demand it. eigenstates(sparse=False, sort='low', eigvals=0, tol=0, maxiter=100000)[source]Â¶; Eigenstates and eigenenergies.; Eigenstates and eigenenergies are defined for operators and; superoperators only. Parameters:; sparse : bool; Use sparse Eigensolver. sort : str; Sort eigenvalues (and vectors) âlowâ to high, or âhighâ to low. eigvals : int; Number of requested eigenvalues. Default is all eigenvalues. tol : float; Tolerance used by sparse Eigensolver (0 = machine precision).; The sparse solver may not converge if the tolerance is set too low. maxiter : int; Maximum number of iterations performed by sparse solver (if used). Returns:; eigvals : array; Array of eigenvalues for operator. eigvecs : array; Array of quantum operators representing the oprator eigenkets.; Order of eigenkets is determined by order of eigenvalues. Notes; The sparse eigensolver is much slower than the dense version.; Use sparse only if memory requirements demand it. eliminate_states(states_inds, normalize=False)[source]Â¶; Creates a new quantum object with states in state_inds eliminated. Parameters:; states_inds : list of integer; The states that should be removed. normalize : True / False; Weather or not the new Qobj instance should be normalized (default; is False). For Qobjs that represents density matrices or state; vectors normalized should probably be set to True, but for Qobjs; that represents operators in for example an Hamiltonian, normalize; should be False. Returns:; q : Qobj; A new instance of qutip.Qobj t",MatchSource.WIKI,docs/4.3/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/apidoc/classes.html
https://qutip.org/docs/4.3/apidoc/classes.html:9136,Availability,avail,available,9136,"responding to indices that are not in state_inds. Notes; Experimental. static evaluate(qobj_list, t, args)[source]Â¶; Evaluate a time-dependent quantum object in list format. For; example,. qobj_list = [H0, [H1, func_t]]; is evaluated to. Qobj(t) = H0 + H1 * func_t(t, args); and. qobj_list = [H0, [H1, âsin(w * t)â]]; is evaluated to. Qobj(t) = H0 + H1 * sin(args[âwâ] * t). Parameters:; qobj_list : list; A nested list of Qobj instances and corresponding time-dependent; coefficients. t : float; The time for which to evaluate the time-dependent Qobj instance. args : dictionary; A dictionary with parameter values required to evaluate the; time-dependent Qobj intance. Returns:; output : Qobj; A Qobj instance that represents the value of qobj_list at time t. expm(method='dense')[source]Â¶; Matrix exponential of quantum operator.; Input operator must be square. Parameters:; method : str {âdenseâ, âsparseâ}; Use set method to use to calculate the matrix exponentiation. The; available choices includes âdenseâ and âsparseâ. Since the; exponential of a matrix is nearly always dense, method=âdenseâ; is set as default.s. Returns:; oper : qobj; Exponentiated quantum operator. Raises:; TypeError; Quantum operator is not square. extract_states(states_inds, normalize=False)[source]Â¶; Qobj with states in state_inds only. Parameters:; states_inds : list of integer; The states that should be kept. normalize : True / False; Weather or not the new Qobj instance should be normalized (default; is False). For Qobjs that represents density matrices or state; vectors normalized should probably be set to True, but for Qobjs; that represents operators in for example an Hamiltonian, normalize; should be False. Returns:; q : Qobj; A new instance of qutip.Qobj that contains only the states; corresponding to the indices in state_inds. Notes; Experimental. full(order='C', squeeze=False)[source]Â¶; Dense array from quantum object. Parameters:; order : str {âCâ, âFâ}; Return array in C (default) or Fortr",MatchSource.WIKI,docs/4.3/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/apidoc/classes.html
https://qutip.org/docs/4.3/apidoc/classes.html:10641,Availability,toler,tolerance,10641,"rmalized (default; is False). For Qobjs that represents density matrices or state; vectors normalized should probably be set to True, but for Qobjs; that represents operators in for example an Hamiltonian, normalize; should be False. Returns:; q : Qobj; A new instance of qutip.Qobj that contains only the states; corresponding to the indices in state_inds. Notes; Experimental. full(order='C', squeeze=False)[source]Â¶; Dense array from quantum object. Parameters:; order : str {âCâ, âFâ}; Return array in C (default) or Fortran ordering. squeeze : bool {False, True}; Squeeze output array. Returns:; data : array; Array of complex data from quantum objects data attribute. groundstate(sparse=False, tol=0, maxiter=100000, safe=True)[source]Â¶; Ground state Eigenvalue and Eigenvector.; Defined for quantum operators or superoperators only. Parameters:; sparse : bool; Use sparse Eigensolver. tol : float; Tolerance used by sparse Eigensolver (0 = machine precision).; The sparse solver may not converge if the tolerance is set too low. maxiter : int; Maximum number of iterations performed by sparse solver (if used). safe : bool (default=True); Check for degenerate ground state. Returns:; eigval : float; Eigenvalue for the ground state of quantum operator. eigvec : qobj; Eigenket for the ground state of quantum operator. Notes; The sparse eigensolver is much slower than the dense version.; Use sparse only if memory requirements demand it. matrix_element(bra, ket)[source]Â¶; Calculates a matrix element.; Gives the matrix element for the quantum object sandwiched between a; bra and ket vector. Parameters:; bra : qobj; Quantum object of type âbraâ or âketâ. ket : qobj; Quantum object of type âketâ. Returns:; elem : complex; Complex valued matrix element. norm(norm=None, sparse=False, tol=0, maxiter=100000)[source]Â¶; Norm of a quantum object.; Default norm is L2-norm for kets and trace-norm for operators.; Other ket and operator norms may be specified using the norm and; argument. Paramet",MatchSource.WIKI,docs/4.3/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/apidoc/classes.html
https://qutip.org/docs/4.3/apidoc/classes.html:12005,Availability,toler,tolerance,12005,"slower than the dense version.; Use sparse only if memory requirements demand it. matrix_element(bra, ket)[source]Â¶; Calculates a matrix element.; Gives the matrix element for the quantum object sandwiched between a; bra and ket vector. Parameters:; bra : qobj; Quantum object of type âbraâ or âketâ. ket : qobj; Quantum object of type âketâ. Returns:; elem : complex; Complex valued matrix element. norm(norm=None, sparse=False, tol=0, maxiter=100000)[source]Â¶; Norm of a quantum object.; Default norm is L2-norm for kets and trace-norm for operators.; Other ket and operator norms may be specified using the norm and; argument. Parameters:; norm : str; Which norm to use for ket/bra vectors: L2 âl2â, max norm âmaxâ,; or for operators: trace âtrâ, Frobius âfroâ, one âoneâ, or max; âmaxâ. sparse : bool; Use sparse eigenvalue solver for trace norm. Other norms are not; affected by this parameter. tol : float; Tolerance for sparse solver (if used) for trace norm. The sparse; solver may not converge if the tolerance is set too low. maxiter : int; Maximum number of iterations performed by sparse solver (if used); for trace norm. Returns:; norm : float; The requested norm of the operator or state quantum object. Notes; The sparse eigensolver is much slower than the dense version.; Use sparse only if memory requirements demand it. overlap(other)[source]Â¶; Overlap between two state vectors.; Gives the overlap (inner product) between the current bra or ket Qobj; and and another bra or ket Qobj. Parameters:; other : qobj; Quantum object for a state vector of type âketâ or âbraâ. Returns:; overlap : complex; Complex valued overlap. Raises:; TypeError; Can only calculate overlap between a bra and ket quantum objects. Notes; Since QuTiP mainly deals with ket vectors, the most efficient inner product; call is the ket-ket version that computes the product <self|other> with; both vectors expressed as kets. permute(order)[source]Â¶; Permutes a composite quantum object. Parameters:; order : li",MatchSource.WIKI,docs/4.3/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/apidoc/classes.html
https://qutip.org/docs/4.3/apidoc/classes.html:14434,Availability,toler,tolerance,14434,"presenting partial trace with selected components; remaining. Notes; This function is identical to the qutip.qobj.ptrace function; that has been deprecated. sinm()[source]Â¶; Sine of a quantum operator.; Operator must be square. Returns:; oper : qobj; Matrix sine of operator. Raises:; TypeError; Quantum object is not square. Notes; Uses the Q.expm() method. sqrtm(sparse=False, tol=0, maxiter=100000)[source]Â¶; Sqrt of a quantum operator.; Operator must be square. Parameters:; sparse : bool; Use sparse eigenvalue/vector solver. tol : float; Tolerance used by sparse solver (0 = machine precision). maxiter : int; Maximum number of iterations used by sparse solver. Returns:; oper : qobj; Matrix square root of operator. Raises:; TypeError; Quantum object is not square. Notes; The sparse eigensolver is much slower than the dense version.; Use sparse only if memory requirements demand it. tidyup(atol=1e-12)[source]Â¶; Removes small elements from the quantum object. Parameters:; atol : float; Absolute tolerance used by tidyup. Default is set; via qutip global settings parameters. Returns:; oper : qobj; Quantum object with small elements removed. tr()[source]Â¶; Trace of a quantum object. Returns:; trace : float; Returns real if operator is Hermitian, returns complex; otherwise. trans()[source]Â¶; Transposed operator. Returns:; oper : qobj; Transpose of input operator. transform(inpt, inverse=False, sparse=True)[source]Â¶; Basis transform defined by input array.; Input array can be a matrix defining the transformation,; or a list of kets that defines the new basis. Parameters:; inpt : array_like; A matrix or list of kets defining the transformation. inverse : bool; Whether to return inverse transformation. sparse : bool; Use sparse matrices when possible. Can be slower. Returns:; oper : qobj; Operator in new basis. Notes; This function is still in development. trunc_neg(method='clip')[source]Â¶; Truncates negative eigenvalues and renormalizes.; Returns a new Qobj by removing the ne",MatchSource.WIKI,docs/4.3/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/apidoc/classes.html
https://qutip.org/docs/4.3/apidoc/classes.html:33808,Availability,toler,tolerance,33808," callback function. thres : float; Threshold for halting. Halts if \(||T_{n}-T_{n-1}||\) is below; treshold. options : qutip.solver.Options; Generic solver options. Solver Options and ResultsÂ¶. class Options(atol=1e-08, rtol=1e-06, method='adams', order=12, nsteps=1000, first_step=0, max_step=0, min_step=0, average_expect=True, average_states=False, tidy=True, num_cpus=0, norm_tol=0.001, norm_steps=5, rhs_reuse=False, rhs_filename=None, ntraj=500, gui=False, rhs_with_state=False, store_final_state=False, store_states=False, seeds=None, steady_state_average=False, normalize_output=True, use_openmp=None, openmp_threads=None)[source]Â¶; Class of options for evolution solvers such as qutip.mesolve and; qutip.mcsolve. Options can be specified either as arguments to the; constructor:; opts = Options(order=10, ...). or by changing the class attributes after creation:; opts = Options(); opts.order = 10. Returns options class to be used as options in evolution solvers. Attributes:; atol : float {1e-8}; Absolute tolerance. rtol : float {1e-6}; Relative tolerance. method : str {âadamsâ,âbdfâ}; Integration method. order : int {12}; Order of integrator (<=12 âadamsâ, <=5 âbdfâ). nsteps : int {2500}; Max. number of internal steps/call. first_step : float {0}; Size of initial step (0 = automatic). min_step : float {0}; Minimum step size (0 = automatic). max_step : float {0}; Maximum step size (0 = automatic). tidy : bool {True,False}; Tidyup Hamiltonian and initial state by removing small terms. num_cpus : int; Number of cpus used by mcsolver (default = # of cpus). norm_tol : float; Tolerance used when finding wavefunction norm in mcsolve. norm_steps : int; Max. number of steps used to find wavefunction norm to within norm_tol; in mcsolve. average_states : bool {False}; Average states values over trajectories in stochastic solvers. average_expect : bool {True}; Average expectation values over trajectories for stochastic solvers. mc_corr_eps : float {1e-10}; Arbitrarily small value ",MatchSource.WIKI,docs/4.3/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/apidoc/classes.html
https://qutip.org/docs/4.3/apidoc/classes.html:33849,Availability,toler,tolerance,33849,"r halting. Halts if \(||T_{n}-T_{n-1}||\) is below; treshold. options : qutip.solver.Options; Generic solver options. Solver Options and ResultsÂ¶. class Options(atol=1e-08, rtol=1e-06, method='adams', order=12, nsteps=1000, first_step=0, max_step=0, min_step=0, average_expect=True, average_states=False, tidy=True, num_cpus=0, norm_tol=0.001, norm_steps=5, rhs_reuse=False, rhs_filename=None, ntraj=500, gui=False, rhs_with_state=False, store_final_state=False, store_states=False, seeds=None, steady_state_average=False, normalize_output=True, use_openmp=None, openmp_threads=None)[source]Â¶; Class of options for evolution solvers such as qutip.mesolve and; qutip.mcsolve. Options can be specified either as arguments to the; constructor:; opts = Options(order=10, ...). or by changing the class attributes after creation:; opts = Options(); opts.order = 10. Returns options class to be used as options in evolution solvers. Attributes:; atol : float {1e-8}; Absolute tolerance. rtol : float {1e-6}; Relative tolerance. method : str {âadamsâ,âbdfâ}; Integration method. order : int {12}; Order of integrator (<=12 âadamsâ, <=5 âbdfâ). nsteps : int {2500}; Max. number of internal steps/call. first_step : float {0}; Size of initial step (0 = automatic). min_step : float {0}; Minimum step size (0 = automatic). max_step : float {0}; Maximum step size (0 = automatic). tidy : bool {True,False}; Tidyup Hamiltonian and initial state by removing small terms. num_cpus : int; Number of cpus used by mcsolver (default = # of cpus). norm_tol : float; Tolerance used when finding wavefunction norm in mcsolve. norm_steps : int; Max. number of steps used to find wavefunction norm to within norm_tol; in mcsolve. average_states : bool {False}; Average states values over trajectories in stochastic solvers. average_expect : bool {True}; Average expectation values over trajectories for stochastic solvers. mc_corr_eps : float {1e-10}; Arbitrarily small value for eliminating any divide-by-zero errors in; co",MatchSource.WIKI,docs/4.3/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/apidoc/classes.html
https://qutip.org/docs/4.3/apidoc/classes.html:34826,Availability,error,errors,34826,"olerance. rtol : float {1e-6}; Relative tolerance. method : str {âadamsâ,âbdfâ}; Integration method. order : int {12}; Order of integrator (<=12 âadamsâ, <=5 âbdfâ). nsteps : int {2500}; Max. number of internal steps/call. first_step : float {0}; Size of initial step (0 = automatic). min_step : float {0}; Minimum step size (0 = automatic). max_step : float {0}; Maximum step size (0 = automatic). tidy : bool {True,False}; Tidyup Hamiltonian and initial state by removing small terms. num_cpus : int; Number of cpus used by mcsolver (default = # of cpus). norm_tol : float; Tolerance used when finding wavefunction norm in mcsolve. norm_steps : int; Max. number of steps used to find wavefunction norm to within norm_tol; in mcsolve. average_states : bool {False}; Average states values over trajectories in stochastic solvers. average_expect : bool {True}; Average expectation values over trajectories for stochastic solvers. mc_corr_eps : float {1e-10}; Arbitrarily small value for eliminating any divide-by-zero errors in; correlation calculations when using mcsolve. ntraj : int {500}; Number of trajectories in stochastic solvers. openmp_threads : int; Number of OPENMP threads to use. Default is number of cpu cores. rhs_reuse : bool {False,True}; Reuse Hamiltonian data. rhs_with_state : bool {False,True}; Whether or not to include the state in the Hamiltonian function; callback signature. rhs_filename : str; Name for compiled Cython file. seeds : ndarray; Array containing random number seeds for mcsolver. store_final_state : bool {False, True}; Whether or not to store the final state of the evolution in the; result class. store_states : bool {False, True}; Whether or not to store the state vectors or density matrices in the; result class, even if expectation values operators are given. If no; expectation are provided, then states are stored by default and this; option has no effect. use_openmp : bool {True, False}; Use OPENMP for sparse matrix vector multiplication. Default; N",MatchSource.WIKI,docs/4.3/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/apidoc/classes.html
https://qutip.org/docs/4.3/apidoc/classes.html:43186,Availability,toler,tolerance,43186,"eeded to explicitly; create an instance of this class. Attributes:; H : qutip.Qobj; System Hamiltonian. state0 : qutip.Qobj; Initial state vector (ket) or density matrix. times : list / array; List of times for \(t\). Must be uniformly spaced. c_ops : list of qutip.Qobj; List of deterministic collapse operators. sc_ops : list of qutip.Qobj; List of stochastic collapse operators. Each stochastic collapse; operator will give a deterministic and stochastic contribution; to the equation of motion according to how the d1 and d2 functions; are defined. e_ops : list of qutip.Qobj; Single operator or list of operators for which to evaluate; expectation values. m_ops : list of qutip.Qobj; List of operators representing the measurement operators. The expected; format is a nested list with one measurement operator for each; stochastic increament, for each stochastic collapse operator. args : dict / list; List of dictionary of additional problem-specific parameters.; Implicit methods can adjust tolerance via args = {âtolâ:value}. ntraj : int; Number of trajectors. nsubsteps : int; Number of sub steps between each time-spep given in times. d1 : function; Function for calculating the operator-valued coefficient to the; deterministic increment dt. d2 : function; Function for calculating the operator-valued coefficient to the; stochastic increment(s) dW_n, where n is in [0, d2_len[. d2_len : int (default 1); The number of stochastic increments in the process. dW_factors : array; Array of length d2_len, containing scaling factors for each; measurement operator in m_ops. rhs : function; Function for calculating the deterministic and stochastic contributions; to the right-hand side of the stochastic differential equation. This; only needs to be specified when implementing a custom SDE solver. generate_A_ops : function; Function that generates a list of pre-computed operators or super-; operators. These precomputed operators are used in some d1 and d2; functions. generate_noise : functi",MatchSource.WIKI,docs/4.3/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/apidoc/classes.html
https://qutip.org/docs/4.3/apidoc/classes.html:44889,Availability,toler,tolerance,44889,"ential equation. This; only needs to be specified when implementing a custom SDE solver. generate_A_ops : function; Function that generates a list of pre-computed operators or super-; operators. These precomputed operators are used in some d1 and d2; functions. generate_noise : function; Function for generate an array of pre-computed noise signal. homogeneous : bool (True); Wheter or not the stochastic process is homogenous. Inhomogenous; processes are only supported for poisson distributions. solver : string; Name of the solver method to use for solving the stochastic; equations. Valid values are:; 1/2 order algorithms: âeuler-maruyamaâ, âfast-euler-maruyamaâ,; âpc-eulerâ is a predictor-corrector method which is more; stable than explicit methods,; 1 order algorithms: âmilsteinâ, âfast-milsteinâ, âplatenâ,; âmilstein-impâ is semi-implicit Milstein method,; 3/2 order algorithms: âtaylor15â,; âtaylor15-impâ is semi-implicit Taylor 1.5 method.; Implicit methods can adjust tolerance via args = {âtolâ:value},; default is {âtolâ:1e-6}. method : string (âhomodyneâ, âheterodyneâ, âphotocurrentâ); The name of the type of measurement process that give rise to the; stochastic equation to solve. Specifying a method with this keyword; argument is a short-hand notation for using pre-defined d1 and d2; functions for the corresponding stochastic processes. distribution : string (ânormalâ, âpoissionâ); The name of the distribution used for the stochastic increments. store_measurements : bool (default False); Whether or not to store the measurement results in the; qutip.solver.SolverResult instance returned by the solver. noise : array; Vector specifying the noise. normalize : bool (default True); Whether or not to normalize the wave function during the evolution. options : qutip.solver.Options; Generic solver options. map_func: function; A map function or managing the calls to single-trajactory solvers. map_kwargs: dictionary; Optional keyword arguments to the map_func function func",MatchSource.WIKI,docs/4.3/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/apidoc/classes.html
https://qutip.org/docs/4.3/apidoc/classes.html:68371,Availability,error,error,68371,"rom the logger.; Options are attributes of qutip.logging_utils,; in decreasing levels of messaging, are:; DEBUG_INTENSE, DEBUG_VERBOSE, DEBUG, INFO, WARN, ERROR, CRITICAL; Anything WARN or above is effectively âquietâ execution,; assuming everything runs as expected.; The default NOTSET implies that the level will be taken from; the QuTiP settings file, which by default is WARN. params: Dictionary; The key value pairs are the attribute name and value; Note: attributes are created if they do not exist already,; and are overwritten if they do. alg : string; Algorithm to use in pulse optimisation.; Options are:. âGRAPEâ (default) - GRadient Ascent Pulse Engineering; âCRABâ - Chopped RAndom Basis. alg_params : Dictionary; options that are specific to the pulse optim algorithm; that is GRAPE or CRAB. disp_conv_msg : bool; Set true to display a convergence message; (for scipy.optimize.minimize methods anyway). optim_method : string; a scipy.optimize.minimize method that will be used to optimise; the pulse for minimum fidelity error. method_params : Dictionary; Options for the optim_method.; Note that where there is an equivalent attribute of this instance; or the termination_conditions (for example maxiter); it will override an value in these options. approx_grad : bool; If set True then the method will approximate the gradient itself; (if it has requirement and facility for this); This will mean that the fid_err_grad_wrapper will not get called; Note it should be left False when using the Dynamics; to calculate approximate gradients; Note it is set True automatically when the alg is CRAB. amp_lbound : float or list of floats; lower boundaries for the control amplitudes; Can be a scalar value applied to all controls; or a list of bounds for each control. amp_ubound : float or list of floats; upper boundaries for the control amplitudes; Can be a scalar value applied to all controls; or a list of bounds for each control. bounds : List of floats; Bounds for the parameters.; ",MatchSource.WIKI,docs/4.3/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/apidoc/classes.html
https://qutip.org/docs/4.3/apidoc/classes.html:72554,Availability,error,error,72554," matches an attribute of this object or the; termination conditions object, then the value of this attribute; is set. Otherwise it is assumed to a method_option for the; scipy.optimize.minimize function. apply_params(params=None)[source]Â¶; Set object attributes based on the dictionary (if any) passed in the; instantiation, or passed as a parameter; This is called during the instantiation automatically.; The key value pairs are the attribute name and value; Note: attributes are created if they do not exist already,; and are overwritten if they do. dumpingÂ¶. The level of data dumping that will occur during the optimisation. NONE : No processing data dumped (Default); SUMMARY : A summary at each iteration will be recorded; FULL : All logs will be generated and dumped; CUSTOM : Some customised level of dumping. When first set to CUSTOM this is equivalent to SUMMARY. It is then up; to the user to specify which logs are dumped. fid_err_func_wrapper(*args)[source]Â¶; Get the fidelity error achieved using the ctrl amplitudes passed; in as the first argument.; This is called by generic optimisation algorithm as the; func to the minimised. The argument is the current; variable values, i.e. control amplitudes, passed as; a flat array. Hence these are reshaped as [nTimeslots, n_ctrls]; and then used to update the stored ctrl values (if they have changed); The error is checked against the target, and the optimisation is; terminated if the target has been achieved. fid_err_grad_wrapper(*args)[source]Â¶; Get the gradient of the fidelity error with respect to all of the; variables, i.e. the ctrl amplidutes in each timeslot; This is called by generic optimisation algorithm as the gradients of; func to the minimised wrt the variables. The argument is the current; variable values, i.e. control amplitudes, passed as; a flat array. Hence these are reshaped as [nTimeslots, n_ctrls]; and then used to update the stored ctrl values (if they have changed); Although the optimisation algorithms ",MatchSource.WIKI,docs/4.3/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/apidoc/classes.html
https://qutip.org/docs/4.3/apidoc/classes.html:72932,Availability,error,error,72932," called during the instantiation automatically.; The key value pairs are the attribute name and value; Note: attributes are created if they do not exist already,; and are overwritten if they do. dumpingÂ¶. The level of data dumping that will occur during the optimisation. NONE : No processing data dumped (Default); SUMMARY : A summary at each iteration will be recorded; FULL : All logs will be generated and dumped; CUSTOM : Some customised level of dumping. When first set to CUSTOM this is equivalent to SUMMARY. It is then up; to the user to specify which logs are dumped. fid_err_func_wrapper(*args)[source]Â¶; Get the fidelity error achieved using the ctrl amplitudes passed; in as the first argument.; This is called by generic optimisation algorithm as the; func to the minimised. The argument is the current; variable values, i.e. control amplitudes, passed as; a flat array. Hence these are reshaped as [nTimeslots, n_ctrls]; and then used to update the stored ctrl values (if they have changed); The error is checked against the target, and the optimisation is; terminated if the target has been achieved. fid_err_grad_wrapper(*args)[source]Â¶; Get the gradient of the fidelity error with respect to all of the; variables, i.e. the ctrl amplidutes in each timeslot; This is called by generic optimisation algorithm as the gradients of; func to the minimised wrt the variables. The argument is the current; variable values, i.e. control amplitudes, passed as; a flat array. Hence these are reshaped as [nTimeslots, n_ctrls]; and then used to update the stored ctrl values (if they have changed); Although the optimisation algorithms have a check within them for; function convergence, i.e. local minima, the sum of the squares; of the normalised gradient is checked explicitly, and the; optimisation is terminated if this is below the min_gradient_norm; condition. init_optim(term_conds)[source]Â¶; Check optimiser attribute status and passed parameters before; running the optimisation.; Thi",MatchSource.WIKI,docs/4.3/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/apidoc/classes.html
https://qutip.org/docs/4.3/apidoc/classes.html:73109,Availability,error,error,73109,"written if they do. dumpingÂ¶. The level of data dumping that will occur during the optimisation. NONE : No processing data dumped (Default); SUMMARY : A summary at each iteration will be recorded; FULL : All logs will be generated and dumped; CUSTOM : Some customised level of dumping. When first set to CUSTOM this is equivalent to SUMMARY. It is then up; to the user to specify which logs are dumped. fid_err_func_wrapper(*args)[source]Â¶; Get the fidelity error achieved using the ctrl amplitudes passed; in as the first argument.; This is called by generic optimisation algorithm as the; func to the minimised. The argument is the current; variable values, i.e. control amplitudes, passed as; a flat array. Hence these are reshaped as [nTimeslots, n_ctrls]; and then used to update the stored ctrl values (if they have changed); The error is checked against the target, and the optimisation is; terminated if the target has been achieved. fid_err_grad_wrapper(*args)[source]Â¶; Get the gradient of the fidelity error with respect to all of the; variables, i.e. the ctrl amplidutes in each timeslot; This is called by generic optimisation algorithm as the gradients of; func to the minimised wrt the variables. The argument is the current; variable values, i.e. control amplitudes, passed as; a flat array. Hence these are reshaped as [nTimeslots, n_ctrls]; and then used to update the stored ctrl values (if they have changed); Although the optimisation algorithms have a check within them for; function convergence, i.e. local minima, the sum of the squares; of the normalised gradient is checked explicitly, and the; optimisation is terminated if this is below the min_gradient_norm; condition. init_optim(term_conds)[source]Â¶; Check optimiser attribute status and passed parameters before; running the optimisation.; This is called by run_optimization, but could called independently; to check the configuration. iter_step_callback_func(*args)[source]Â¶; Check the elapsed wall time for the optimi",MatchSource.WIKI,docs/4.3/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/apidoc/classes.html
https://qutip.org/docs/4.3/apidoc/classes.html:74357,Availability,error,error,74357,"ed as [nTimeslots, n_ctrls]; and then used to update the stored ctrl values (if they have changed); Although the optimisation algorithms have a check within them for; function convergence, i.e. local minima, the sum of the squares; of the normalised gradient is checked explicitly, and the; optimisation is terminated if this is below the min_gradient_norm; condition. init_optim(term_conds)[source]Â¶; Check optimiser attribute status and passed parameters before; running the optimisation.; This is called by run_optimization, but could called independently; to check the configuration. iter_step_callback_func(*args)[source]Â¶; Check the elapsed wall time for the optimisation run so far.; Terminate if this has exceeded the maximum allowed time. run_optimization(term_conds=None)[source]Â¶; This default function optimisation method is a wrapper to the; scipy.optimize.minimize function.; It will attempt to minimise the fidelity error with respect to some; parameters, which are determined by _get_optim_var_vals (see below); The optimisation end when one of the passed termination conditions; has been met, e.g. target achieved, wall time, or; function call or iteration count exceeded. Note these; conditions include gradient minimum met (local minima) for; methods that use a gradient.; The function minimisation method is taken from the optim_method; attribute. Note that not all of these methods have been tested.; Note that some of these use a gradient and some do not.; See the scipy documentation for details. Options specific to the; method can be passed setting the method_params attribute.; If the parameter term_conds=None, then the termination_conditions; attribute must already be set. It will be overwritten if the; parameter is not None; The result is returned in an OptimResult object, which includes; the final fidelity, time evolution, reason for termination etc. class OptimizerBFGS(config, dyn, params=None)[source]Â¶; Implements the run_optimization method using the BFGS algor",MatchSource.WIKI,docs/4.3/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/apidoc/classes.html
https://qutip.org/docs/4.3/apidoc/classes.html:75539,Availability,error,error,75539,"l time, or; function call or iteration count exceeded. Note these; conditions include gradient minimum met (local minima) for; methods that use a gradient.; The function minimisation method is taken from the optim_method; attribute. Note that not all of these methods have been tested.; Note that some of these use a gradient and some do not.; See the scipy documentation for details. Options specific to the; method can be passed setting the method_params attribute.; If the parameter term_conds=None, then the termination_conditions; attribute must already be set. It will be overwritten if the; parameter is not None; The result is returned in an OptimResult object, which includes; the final fidelity, time evolution, reason for termination etc. class OptimizerBFGS(config, dyn, params=None)[source]Â¶; Implements the run_optimization method using the BFGS algorithm. run_optimization(term_conds=None)[source]Â¶; Optimise the control pulse amplitudes to minimise the fidelity error; using the BFGS (BroydenâFletcherâGoldfarbâShanno) algorithm; The optimisation end when one of the passed termination conditions; has been met, e.g. target achieved, gradient minimum met; (local minima), wall time / iteration count exceeded.; Essentially this is wrapper to the:; scipy.optimize.fmin_bfgs; function; If the parameter term_conds=None, then the termination_conditions; attribute must already be set. It will be overwritten if the; parameter is not None; The result is returned in an OptimResult object, which includes; the final fidelity, time evolution, reason for termination etc. class OptimizerLBFGSB(config, dyn, params=None)[source]Â¶; Implements the run_optimization method using the L-BFGS-B algorithm. Attributes:; max_metric_corr : integer; The maximum number of variable metric corrections used to define; the limited memory matrix. That is the number of previous; gradient values that are used to approximate the Hessian; see the scipy.optimize.fmin_l_bfgs_b documentation for description; o",MatchSource.WIKI,docs/4.3/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/apidoc/classes.html
https://qutip.org/docs/4.3/apidoc/classes.html:76901,Availability,error,error,76901,"tribute must already be set. It will be overwritten if the; parameter is not None; The result is returned in an OptimResult object, which includes; the final fidelity, time evolution, reason for termination etc. class OptimizerLBFGSB(config, dyn, params=None)[source]Â¶; Implements the run_optimization method using the L-BFGS-B algorithm. Attributes:; max_metric_corr : integer; The maximum number of variable metric corrections used to define; the limited memory matrix. That is the number of previous; gradient values that are used to approximate the Hessian; see the scipy.optimize.fmin_l_bfgs_b documentation for description; of m argument. init_optim(term_conds)[source]Â¶; Check optimiser attribute status and passed parameters before; running the optimisation.; This is called by run_optimization, but could called independently; to check the configuration. run_optimization(term_conds=None)[source]Â¶; Optimise the control pulse amplitudes to minimise the fidelity error; using the L-BFGS-B algorithm, which is the constrained; (bounded amplitude values), limited memory, version of the; BroydenâFletcherâGoldfarbâShanno algorithm.; The optimisation end when one of the passed termination conditions; has been met, e.g. target achieved, gradient minimum met; (local minima), wall time / iteration count exceeded.; Essentially this is wrapper to the:; scipy.optimize.fmin_l_bfgs_b function; This in turn is a warpper for well established implementation of; the L-BFGS-B algorithm written in Fortran, which is therefore; very fast. See SciPy documentation for credit and details on; this function.; If the parameter term_conds=None, then the termination_conditions; attribute must already be set. It will be overwritten if the; parameter is not None; The result is returned in an OptimResult object, which includes; the final fidelity, time evolution, reason for termination etc. class OptimizerCrab(config, dyn, params=None)[source]Â¶; Optimises the pulse using the CRAB algorithm [1].; It uses t",MatchSource.WIKI,docs/4.3/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/apidoc/classes.html
https://qutip.org/docs/4.3/apidoc/classes.html:78094,Availability,error,error,78094,"f the passed termination conditions; has been met, e.g. target achieved, gradient minimum met; (local minima), wall time / iteration count exceeded.; Essentially this is wrapper to the:; scipy.optimize.fmin_l_bfgs_b function; This in turn is a warpper for well established implementation of; the L-BFGS-B algorithm written in Fortran, which is therefore; very fast. See SciPy documentation for credit and details on; this function.; If the parameter term_conds=None, then the termination_conditions; attribute must already be set. It will be overwritten if the; parameter is not None; The result is returned in an OptimResult object, which includes; the final fidelity, time evolution, reason for termination etc. class OptimizerCrab(config, dyn, params=None)[source]Â¶; Optimises the pulse using the CRAB algorithm [1].; It uses the scipy.optimize.minimize function with the method specified; by the optim_method attribute. See Optimizer.run_optimization for details; It minimises the fidelity error function with respect to the CRAB; basis function coefficients.; AJGP ToDo: Add citation here. init_optim(term_conds)[source]Â¶; Check optimiser attribute status and passed parameters before; running the optimisation.; This is called by run_optimization, but could called independently; to check the configuration. class OptimizerCrabFmin(config, dyn, params=None)[source]Â¶; Optimises the pulse using the CRAB algorithm [1, 2].; It uses the scipy.optimize.fmin function which is effectively a wrapper; for the Nelder-mead method.; It minimises the fidelity error function with respect to the CRAB; basis function coefficients.; This is the default Optimizer for CRAB.; Notes. [1] P. Doria, T. Calarco & S. Montangero. Phys. Rev. Lett. 106,; 190501 (2011). [2] T. Caneva, T. Calarco, & S. Montangero. Phys. Rev. A 84, 022326 (2011). run_optimization(term_conds=None)[source]Â¶; This function optimisation method is a wrapper to the; scipy.optimize.fmin function.; It will attempt to minimise the fidelity",MatchSource.WIKI,docs/4.3/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/apidoc/classes.html
https://qutip.org/docs/4.3/apidoc/classes.html:78656,Availability,error,error,78656,"ot None; The result is returned in an OptimResult object, which includes; the final fidelity, time evolution, reason for termination etc. class OptimizerCrab(config, dyn, params=None)[source]Â¶; Optimises the pulse using the CRAB algorithm [1].; It uses the scipy.optimize.minimize function with the method specified; by the optim_method attribute. See Optimizer.run_optimization for details; It minimises the fidelity error function with respect to the CRAB; basis function coefficients.; AJGP ToDo: Add citation here. init_optim(term_conds)[source]Â¶; Check optimiser attribute status and passed parameters before; running the optimisation.; This is called by run_optimization, but could called independently; to check the configuration. class OptimizerCrabFmin(config, dyn, params=None)[source]Â¶; Optimises the pulse using the CRAB algorithm [1, 2].; It uses the scipy.optimize.fmin function which is effectively a wrapper; for the Nelder-mead method.; It minimises the fidelity error function with respect to the CRAB; basis function coefficients.; This is the default Optimizer for CRAB.; Notes. [1] P. Doria, T. Calarco & S. Montangero. Phys. Rev. Lett. 106,; 190501 (2011). [2] T. Caneva, T. Calarco, & S. Montangero. Phys. Rev. A 84, 022326 (2011). run_optimization(term_conds=None)[source]Â¶; This function optimisation method is a wrapper to the; scipy.optimize.fmin function.; It will attempt to minimise the fidelity error with respect to some; parameters, which are determined by _get_optim_var_vals which; in the case of CRAB are the basis function coefficients; The optimisation end when one of the passed termination conditions; has been met, e.g. target achieved, wall time, or; function call or iteration count exceeded. Specifically to the fmin; method, the optimisation will stop when change parameter values; is less than xtol or the change in function value is below ftol.; If the parameter term_conds=None, then the termination_conditions; attribute must already be set. It will be",MatchSource.WIKI,docs/4.3/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/apidoc/classes.html
https://qutip.org/docs/4.3/apidoc/classes.html:79102,Availability,error,error,79102,"nit_optim(term_conds)[source]Â¶; Check optimiser attribute status and passed parameters before; running the optimisation.; This is called by run_optimization, but could called independently; to check the configuration. class OptimizerCrabFmin(config, dyn, params=None)[source]Â¶; Optimises the pulse using the CRAB algorithm [1, 2].; It uses the scipy.optimize.fmin function which is effectively a wrapper; for the Nelder-mead method.; It minimises the fidelity error function with respect to the CRAB; basis function coefficients.; This is the default Optimizer for CRAB.; Notes. [1] P. Doria, T. Calarco & S. Montangero. Phys. Rev. Lett. 106,; 190501 (2011). [2] T. Caneva, T. Calarco, & S. Montangero. Phys. Rev. A 84, 022326 (2011). run_optimization(term_conds=None)[source]Â¶; This function optimisation method is a wrapper to the; scipy.optimize.fmin function.; It will attempt to minimise the fidelity error with respect to some; parameters, which are determined by _get_optim_var_vals which; in the case of CRAB are the basis function coefficients; The optimisation end when one of the passed termination conditions; has been met, e.g. target achieved, wall time, or; function call or iteration count exceeded. Specifically to the fmin; method, the optimisation will stop when change parameter values; is less than xtol or the change in function value is below ftol.; If the parameter term_conds=None, then the termination_conditions; attribute must already be set. It will be overwritten if the; parameter is not None; The result is returned in an OptimResult object, which includes; the final fidelity, time evolution, reason for termination etc. class OptimIterSummary[source]Â¶; A summary of the most recent iteration of the pulse optimisation. Attributes:; iter_num : int; Iteration number of the pulse optimisation. fid_func_call_num : int; Fidelity function call number of the pulse optimisation. grad_func_call_num : int; Gradient function call number of the pulse optimisation. fid_err : ",MatchSource.WIKI,docs/4.3/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/apidoc/classes.html
https://qutip.org/docs/4.3/apidoc/classes.html:80213,Availability,error,error,80213,"se of CRAB are the basis function coefficients; The optimisation end when one of the passed termination conditions; has been met, e.g. target achieved, wall time, or; function call or iteration count exceeded. Specifically to the fmin; method, the optimisation will stop when change parameter values; is less than xtol or the change in function value is below ftol.; If the parameter term_conds=None, then the termination_conditions; attribute must already be set. It will be overwritten if the; parameter is not None; The result is returned in an OptimResult object, which includes; the final fidelity, time evolution, reason for termination etc. class OptimIterSummary[source]Â¶; A summary of the most recent iteration of the pulse optimisation. Attributes:; iter_num : int; Iteration number of the pulse optimisation. fid_func_call_num : int; Fidelity function call number of the pulse optimisation. grad_func_call_num : int; Gradient function call number of the pulse optimisation. fid_err : float; Fidelity error. grad_norm : float; fidelity gradient (wrt the control parameters) vector norm; that is the magnitude of the gradient. wall_time : float; Time spent computing the pulse optimisation so far; (in seconds of elapsed time). class TerminationConditions[source]Â¶; Base class for all termination conditions; Used to determine when to stop the optimisation algorithm; Note different subclasses should be used to match the type of; optimisation being used. Attributes:; fid_err_targ : float; Target fidelity error. fid_goal : float; goal fidelity, e.g. 1 - self.fid_err_targ; It its typical to set this for unitary systems. max_wall_time : float; # maximum time for optimisation (seconds). min_gradient_norm : float; Minimum normalised gradient after which optimisation will terminate. max_iterations : integer; Maximum iterations of the optimisation algorithm. max_fid_func_calls : integer; Maximum number of calls to the fidelity function during; the optimisation algorithm. accuracy_factor ",MatchSource.WIKI,docs/4.3/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/apidoc/classes.html
https://qutip.org/docs/4.3/apidoc/classes.html:80718,Availability,error,error,80718,"e; parameter is not None; The result is returned in an OptimResult object, which includes; the final fidelity, time evolution, reason for termination etc. class OptimIterSummary[source]Â¶; A summary of the most recent iteration of the pulse optimisation. Attributes:; iter_num : int; Iteration number of the pulse optimisation. fid_func_call_num : int; Fidelity function call number of the pulse optimisation. grad_func_call_num : int; Gradient function call number of the pulse optimisation. fid_err : float; Fidelity error. grad_norm : float; fidelity gradient (wrt the control parameters) vector norm; that is the magnitude of the gradient. wall_time : float; Time spent computing the pulse optimisation so far; (in seconds of elapsed time). class TerminationConditions[source]Â¶; Base class for all termination conditions; Used to determine when to stop the optimisation algorithm; Note different subclasses should be used to match the type of; optimisation being used. Attributes:; fid_err_targ : float; Target fidelity error. fid_goal : float; goal fidelity, e.g. 1 - self.fid_err_targ; It its typical to set this for unitary systems. max_wall_time : float; # maximum time for optimisation (seconds). min_gradient_norm : float; Minimum normalised gradient after which optimisation will terminate. max_iterations : integer; Maximum iterations of the optimisation algorithm. max_fid_func_calls : integer; Maximum number of calls to the fidelity function during; the optimisation algorithm. accuracy_factor : float; Determines the accuracy of the result.; Typical values for accuracy_factor are: 1e12 for low accuracy;; 1e7 for moderate accuracy; 10.0 for extremely high accuracy; scipy.optimize.fmin_l_bfgs_b factr argument.; Only set for specific methods (fmin_l_bfgs_b) that uses this; Otherwise the same thing is passed as method_option ftol; (although the scale is different); Hence it is not defined here, but may be set by the user. class OptimResult[source]Â¶; Attributes give the result of t",MatchSource.WIKI,docs/4.3/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/apidoc/classes.html
https://qutip.org/docs/4.3/apidoc/classes.html:81927,Availability,error,error,81927,"Minimum normalised gradient after which optimisation will terminate. max_iterations : integer; Maximum iterations of the optimisation algorithm. max_fid_func_calls : integer; Maximum number of calls to the fidelity function during; the optimisation algorithm. accuracy_factor : float; Determines the accuracy of the result.; Typical values for accuracy_factor are: 1e12 for low accuracy;; 1e7 for moderate accuracy; 10.0 for extremely high accuracy; scipy.optimize.fmin_l_bfgs_b factr argument.; Only set for specific methods (fmin_l_bfgs_b) that uses this; Otherwise the same thing is passed as method_option ftol; (although the scale is different); Hence it is not defined here, but may be set by the user. class OptimResult[source]Â¶; Attributes give the result of the pulse optimisation attempt. Attributes:; termination_reason : string; Description of the reason for terminating the optimisation. fidelity : float; final (normalised) fidelity that was achieved. initial_fid_err : float; fidelity error before optimisation starting. fid_err : float; final fidelity error that was achieved. goal_achieved : boolean; True is the fidely error achieved was below the target. grad_norm_final : float; Final value of the sum of the squares of the (normalised) fidelity; error gradients. grad_norm_min_reached : float; True if the optimisation terminated due to the minimum value; of the gradient being reached. num_iter : integer; Number of iterations of the optimisation algorithm completed. max_iter_exceeded : boolean; True if the iteration limit was reached. max_fid_func_exceeded : boolean; True if the fidelity function call limit was reached. wall_time : float; time elapsed during the optimisation. wall_time_limit_exceeded : boolean; True if the wall time limit was reached. time : array[num_tslots+1] of float; Time are the start of each timeslot; with the final value being the total evolution time. initial_amps : array[num_tslots, n_ctrls]; The amplitudes at the start of the optimisation. ",MatchSource.WIKI,docs/4.3/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/apidoc/classes.html
https://qutip.org/docs/4.3/apidoc/classes.html:81995,Availability,error,error,81995,"nate. max_iterations : integer; Maximum iterations of the optimisation algorithm. max_fid_func_calls : integer; Maximum number of calls to the fidelity function during; the optimisation algorithm. accuracy_factor : float; Determines the accuracy of the result.; Typical values for accuracy_factor are: 1e12 for low accuracy;; 1e7 for moderate accuracy; 10.0 for extremely high accuracy; scipy.optimize.fmin_l_bfgs_b factr argument.; Only set for specific methods (fmin_l_bfgs_b) that uses this; Otherwise the same thing is passed as method_option ftol; (although the scale is different); Hence it is not defined here, but may be set by the user. class OptimResult[source]Â¶; Attributes give the result of the pulse optimisation attempt. Attributes:; termination_reason : string; Description of the reason for terminating the optimisation. fidelity : float; final (normalised) fidelity that was achieved. initial_fid_err : float; fidelity error before optimisation starting. fid_err : float; final fidelity error that was achieved. goal_achieved : boolean; True is the fidely error achieved was below the target. grad_norm_final : float; Final value of the sum of the squares of the (normalised) fidelity; error gradients. grad_norm_min_reached : float; True if the optimisation terminated due to the minimum value; of the gradient being reached. num_iter : integer; Number of iterations of the optimisation algorithm completed. max_iter_exceeded : boolean; True if the iteration limit was reached. max_fid_func_exceeded : boolean; True if the fidelity function call limit was reached. wall_time : float; time elapsed during the optimisation. wall_time_limit_exceeded : boolean; True if the wall time limit was reached. time : array[num_tslots+1] of float; Time are the start of each timeslot; with the final value being the total evolution time. initial_amps : array[num_tslots, n_ctrls]; The amplitudes at the start of the optimisation. final_amps : array[num_tslots, n_ctrls]; The amplitudes at the e",MatchSource.WIKI,docs/4.3/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/apidoc/classes.html
https://qutip.org/docs/4.3/apidoc/classes.html:82064,Availability,error,error,82064,"n algorithm. max_fid_func_calls : integer; Maximum number of calls to the fidelity function during; the optimisation algorithm. accuracy_factor : float; Determines the accuracy of the result.; Typical values for accuracy_factor are: 1e12 for low accuracy;; 1e7 for moderate accuracy; 10.0 for extremely high accuracy; scipy.optimize.fmin_l_bfgs_b factr argument.; Only set for specific methods (fmin_l_bfgs_b) that uses this; Otherwise the same thing is passed as method_option ftol; (although the scale is different); Hence it is not defined here, but may be set by the user. class OptimResult[source]Â¶; Attributes give the result of the pulse optimisation attempt. Attributes:; termination_reason : string; Description of the reason for terminating the optimisation. fidelity : float; final (normalised) fidelity that was achieved. initial_fid_err : float; fidelity error before optimisation starting. fid_err : float; final fidelity error that was achieved. goal_achieved : boolean; True is the fidely error achieved was below the target. grad_norm_final : float; Final value of the sum of the squares of the (normalised) fidelity; error gradients. grad_norm_min_reached : float; True if the optimisation terminated due to the minimum value; of the gradient being reached. num_iter : integer; Number of iterations of the optimisation algorithm completed. max_iter_exceeded : boolean; True if the iteration limit was reached. max_fid_func_exceeded : boolean; True if the fidelity function call limit was reached. wall_time : float; time elapsed during the optimisation. wall_time_limit_exceeded : boolean; True if the wall time limit was reached. time : array[num_tslots+1] of float; Time are the start of each timeslot; with the final value being the total evolution time. initial_amps : array[num_tslots, n_ctrls]; The amplitudes at the start of the optimisation. final_amps : array[num_tslots, n_ctrls]; The amplitudes at the end of the optimisation. evo_full_final : Qobj; The evolution operator",MatchSource.WIKI,docs/4.3/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/apidoc/classes.html
https://qutip.org/docs/4.3/apidoc/classes.html:82194,Availability,error,error,82194,"ng; the optimisation algorithm. accuracy_factor : float; Determines the accuracy of the result.; Typical values for accuracy_factor are: 1e12 for low accuracy;; 1e7 for moderate accuracy; 10.0 for extremely high accuracy; scipy.optimize.fmin_l_bfgs_b factr argument.; Only set for specific methods (fmin_l_bfgs_b) that uses this; Otherwise the same thing is passed as method_option ftol; (although the scale is different); Hence it is not defined here, but may be set by the user. class OptimResult[source]Â¶; Attributes give the result of the pulse optimisation attempt. Attributes:; termination_reason : string; Description of the reason for terminating the optimisation. fidelity : float; final (normalised) fidelity that was achieved. initial_fid_err : float; fidelity error before optimisation starting. fid_err : float; final fidelity error that was achieved. goal_achieved : boolean; True is the fidely error achieved was below the target. grad_norm_final : float; Final value of the sum of the squares of the (normalised) fidelity; error gradients. grad_norm_min_reached : float; True if the optimisation terminated due to the minimum value; of the gradient being reached. num_iter : integer; Number of iterations of the optimisation algorithm completed. max_iter_exceeded : boolean; True if the iteration limit was reached. max_fid_func_exceeded : boolean; True if the fidelity function call limit was reached. wall_time : float; time elapsed during the optimisation. wall_time_limit_exceeded : boolean; True if the wall time limit was reached. time : array[num_tslots+1] of float; Time are the start of each timeslot; with the final value being the total evolution time. initial_amps : array[num_tslots, n_ctrls]; The amplitudes at the start of the optimisation. final_amps : array[num_tslots, n_ctrls]; The amplitudes at the end of the optimisation. evo_full_final : Qobj; The evolution operator from t=0 to t=T based on the final amps. evo_full_initial : Qobj; The evolution operator from ",MatchSource.WIKI,docs/4.3/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/apidoc/classes.html
https://qutip.org/docs/4.3/apidoc/classes.html:85275,Availability,error,error,85275,"_utils,; in decreasing levels of messaging, are:; DEBUG_INTENSE, DEBUG_VERBOSE, DEBUG, INFO, WARN, ERROR, CRITICAL; Anything WARN or above is effectively âquietâ execution,; assuming everything runs as expected.; The default NOTSET implies that the level will be taken from; the QuTiP settings file, which by default is WARN. params: Dictionary; The key value pairs are the attribute name and value; Note: attributes are created if they do not exist already,; and are overwritten if they do. stats : Stats; Attributes of which give performance stats for the optimisation; set to None to reduce overhead of calculating stats.; Note it is (usually) shared with the Optimizer object. tslot_computer : TimeslotComputer (subclass instance); Used to manage when the timeslot dynamics; generators, propagators, gradients etc are updated. prop_computer : PropagatorComputer (subclass instance); Used to compute the propagators and their gradients. fid_computer : FidelityComputer (subclass instance); Used to computer the fidelity error and the fidelity error; gradient. memory_optimization : int; Level of memory optimisation. Setting to 0 (default) means that; execution speed is prioritized over memory.; Setting to 1 means that some memory prioritisation steps will be; taken, for instance using Qobj (and hence sparse arrays) as the; the internal operator data type, and not caching some operators; Potentially further memory saving maybe made with; memory_optimization > 1.; The options are processed in _set_memory_optimizations, see; this for more information. Individual memory saving options can be; switched by settting them directly (see below). oper_dtype : type; Data type for internal dynamics generators, propagators and time; evolution operators. This can be ndarray or Qobj, or (in theory) any; other representaion that supports typical matrix methods (e.g. dot); ndarray performs best for smaller quantum systems.; Qobj may perform better for larger systems, and will also; perform better w",MatchSource.WIKI,docs/4.3/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/apidoc/classes.html
https://qutip.org/docs/4.3/apidoc/classes.html:85298,Availability,error,error,85298,"_utils,; in decreasing levels of messaging, are:; DEBUG_INTENSE, DEBUG_VERBOSE, DEBUG, INFO, WARN, ERROR, CRITICAL; Anything WARN or above is effectively âquietâ execution,; assuming everything runs as expected.; The default NOTSET implies that the level will be taken from; the QuTiP settings file, which by default is WARN. params: Dictionary; The key value pairs are the attribute name and value; Note: attributes are created if they do not exist already,; and are overwritten if they do. stats : Stats; Attributes of which give performance stats for the optimisation; set to None to reduce overhead of calculating stats.; Note it is (usually) shared with the Optimizer object. tslot_computer : TimeslotComputer (subclass instance); Used to manage when the timeslot dynamics; generators, propagators, gradients etc are updated. prop_computer : PropagatorComputer (subclass instance); Used to compute the propagators and their gradients. fid_computer : FidelityComputer (subclass instance); Used to computer the fidelity error and the fidelity error; gradient. memory_optimization : int; Level of memory optimisation. Setting to 0 (default) means that; execution speed is prioritized over memory.; Setting to 1 means that some memory prioritisation steps will be; taken, for instance using Qobj (and hence sparse arrays) as the; the internal operator data type, and not caching some operators; Potentially further memory saving maybe made with; memory_optimization > 1.; The options are processed in _set_memory_optimizations, see; this for more information. Individual memory saving options can be; switched by settting them directly (see below). oper_dtype : type; Data type for internal dynamics generators, propagators and time; evolution operators. This can be ndarray or Qobj, or (in theory) any; other representaion that supports typical matrix methods (e.g. dot); ndarray performs best for smaller quantum systems.; Qobj may perform better for larger systems, and will also; perform better w",MatchSource.WIKI,docs/4.3/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/apidoc/classes.html
https://qutip.org/docs/4.3/apidoc/classes.html:101384,Availability,error,error,101384,"utes:; log_level : integer; level of messaging output from the logger.; Options are attributes of qutip.logging_utils,; in decreasing levels of messaging, are:; DEBUG_INTENSE, DEBUG_VERBOSE, DEBUG, INFO, WARN, ERROR, CRITICAL; Anything WARN or above is effectively âquietâ execution,; assuming everything runs as expected.; The default NOTSET implies that the level will be taken from; the QuTiP settings file, which by default is WARN. dimensional_norm : float; Normalisation constant. fid_norm_func : function; Used to normalise the fidelity; See SU and PSU options for the unitary dynamics. grad_norm_func : function; Used to normalise the fidelity gradient; See SU and PSU options for the unitary dynamics. uses_onwd_evo : boolean; flag to specify whether the onwd_evo evolution operator; (see Dynamics) is used by the FidelityComputer. uses_onto_evo : boolean. flag to specify whether the onto_evo evolution operator; (see Dynamics) is used by the FidelityComputer. fid_err : float; Last computed value of the fidelity error. fidelity : float; Last computed value of the normalised fidelity. fidelity_current : boolean; flag to specify whether the fidelity / fid_err are based on the; current amplitude values. Set False when amplitudes change. fid_err_grad: array[num_tslot, num_ctrls] of float; Last computed values for the fidelity error gradients wrt the; control in the timeslot. grad_norm : float; Last computed value for the norm of the fidelity error gradients; (sqrt of the sum of the squares). fid_err_grad_current : boolean; flag to specify whether the fidelity / fid_err are based on the; current amplitude values. Set False when amplitudes change. apply_params(params=None)[source]Â¶; Set object attributes based on the dictionary (if any) passed in the; instantiation, or passed as a parameter; This is called during the instantiation automatically.; The key value pairs are the attribute name and value; Note: attributes are created if they do not exist already,; and are overwritt",MatchSource.WIKI,docs/4.3/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/apidoc/classes.html
https://qutip.org/docs/4.3/apidoc/classes.html:101700,Availability,error,error,101700,"ed.; The default NOTSET implies that the level will be taken from; the QuTiP settings file, which by default is WARN. dimensional_norm : float; Normalisation constant. fid_norm_func : function; Used to normalise the fidelity; See SU and PSU options for the unitary dynamics. grad_norm_func : function; Used to normalise the fidelity gradient; See SU and PSU options for the unitary dynamics. uses_onwd_evo : boolean; flag to specify whether the onwd_evo evolution operator; (see Dynamics) is used by the FidelityComputer. uses_onto_evo : boolean. flag to specify whether the onto_evo evolution operator; (see Dynamics) is used by the FidelityComputer. fid_err : float; Last computed value of the fidelity error. fidelity : float; Last computed value of the normalised fidelity. fidelity_current : boolean; flag to specify whether the fidelity / fid_err are based on the; current amplitude values. Set False when amplitudes change. fid_err_grad: array[num_tslot, num_ctrls] of float; Last computed values for the fidelity error gradients wrt the; control in the timeslot. grad_norm : float; Last computed value for the norm of the fidelity error gradients; (sqrt of the sum of the squares). fid_err_grad_current : boolean; flag to specify whether the fidelity / fid_err are based on the; current amplitude values. Set False when amplitudes change. apply_params(params=None)[source]Â¶; Set object attributes based on the dictionary (if any) passed in the; instantiation, or passed as a parameter; This is called during the instantiation automatically.; The key value pairs are the attribute name and value; Note: attributes are created if they do not exist already,; and are overwritten if they do. clear()[source]Â¶; clear any temporarily held status data. flag_system_changed()[source]Â¶; Flag fidelity and gradients as needing recalculation. get_fid_err()[source]Â¶; returns the absolute distance from the maximum achievable fidelity. get_fid_err_gradient()[source]Â¶; Returns the normalised gradient of ",MatchSource.WIKI,docs/4.3/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/apidoc/classes.html
https://qutip.org/docs/4.3/apidoc/classes.html:101818,Availability,error,error,101818,"_norm : float; Normalisation constant. fid_norm_func : function; Used to normalise the fidelity; See SU and PSU options for the unitary dynamics. grad_norm_func : function; Used to normalise the fidelity gradient; See SU and PSU options for the unitary dynamics. uses_onwd_evo : boolean; flag to specify whether the onwd_evo evolution operator; (see Dynamics) is used by the FidelityComputer. uses_onto_evo : boolean. flag to specify whether the onto_evo evolution operator; (see Dynamics) is used by the FidelityComputer. fid_err : float; Last computed value of the fidelity error. fidelity : float; Last computed value of the normalised fidelity. fidelity_current : boolean; flag to specify whether the fidelity / fid_err are based on the; current amplitude values. Set False when amplitudes change. fid_err_grad: array[num_tslot, num_ctrls] of float; Last computed values for the fidelity error gradients wrt the; control in the timeslot. grad_norm : float; Last computed value for the norm of the fidelity error gradients; (sqrt of the sum of the squares). fid_err_grad_current : boolean; flag to specify whether the fidelity / fid_err are based on the; current amplitude values. Set False when amplitudes change. apply_params(params=None)[source]Â¶; Set object attributes based on the dictionary (if any) passed in the; instantiation, or passed as a parameter; This is called during the instantiation automatically.; The key value pairs are the attribute name and value; Note: attributes are created if they do not exist already,; and are overwritten if they do. clear()[source]Â¶; clear any temporarily held status data. flag_system_changed()[source]Â¶; Flag fidelity and gradients as needing recalculation. get_fid_err()[source]Â¶; returns the absolute distance from the maximum achievable fidelity. get_fid_err_gradient()[source]Â¶; Returns the normalised gradient of the fidelity error; in a (nTimeslots x n_ctrls) array wrt the timeslot control amplitude. init_comp()[source]Â¶; initialises the co",MatchSource.WIKI,docs/4.3/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/apidoc/classes.html
https://qutip.org/docs/4.3/apidoc/classes.html:102692,Availability,error,error,102692,"e fidelity error gradients wrt the; control in the timeslot. grad_norm : float; Last computed value for the norm of the fidelity error gradients; (sqrt of the sum of the squares). fid_err_grad_current : boolean; flag to specify whether the fidelity / fid_err are based on the; current amplitude values. Set False when amplitudes change. apply_params(params=None)[source]Â¶; Set object attributes based on the dictionary (if any) passed in the; instantiation, or passed as a parameter; This is called during the instantiation automatically.; The key value pairs are the attribute name and value; Note: attributes are created if they do not exist already,; and are overwritten if they do. clear()[source]Â¶; clear any temporarily held status data. flag_system_changed()[source]Â¶; Flag fidelity and gradients as needing recalculation. get_fid_err()[source]Â¶; returns the absolute distance from the maximum achievable fidelity. get_fid_err_gradient()[source]Â¶; Returns the normalised gradient of the fidelity error; in a (nTimeslots x n_ctrls) array wrt the timeslot control amplitude. init_comp()[source]Â¶; initialises the computer based on the configuration of the Dynamics. reset()[source]Â¶; reset any configuration data and; clear any temporarily held status data. class FidCompUnitary(dynamics, params=None)[source]Â¶; Computes fidelity error and gradient assuming unitary dynamics, e.g.; closed qubit systems; Note fidelity and gradient calculations were taken from DYNAMO; (see file header). Attributes:; phase_option : string. determines how global phase is treated in fidelity calculations:; PSU - global phase ignored; SU - global phase included. fidelity_prenorm : complex; Last computed value of the fidelity before it is normalised; It is stored to use in the gradient normalisation calculation. fidelity_prenorm_current : boolean; flag to specify whether fidelity_prenorm are based on the; current amplitude values. Set False when amplitudes change. clear()[source]Â¶; clear any temporarily hel",MatchSource.WIKI,docs/4.3/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/apidoc/classes.html
https://qutip.org/docs/4.3/apidoc/classes.html:103024,Availability,error,error,103024,"itudes change. apply_params(params=None)[source]Â¶; Set object attributes based on the dictionary (if any) passed in the; instantiation, or passed as a parameter; This is called during the instantiation automatically.; The key value pairs are the attribute name and value; Note: attributes are created if they do not exist already,; and are overwritten if they do. clear()[source]Â¶; clear any temporarily held status data. flag_system_changed()[source]Â¶; Flag fidelity and gradients as needing recalculation. get_fid_err()[source]Â¶; returns the absolute distance from the maximum achievable fidelity. get_fid_err_gradient()[source]Â¶; Returns the normalised gradient of the fidelity error; in a (nTimeslots x n_ctrls) array wrt the timeslot control amplitude. init_comp()[source]Â¶; initialises the computer based on the configuration of the Dynamics. reset()[source]Â¶; reset any configuration data and; clear any temporarily held status data. class FidCompUnitary(dynamics, params=None)[source]Â¶; Computes fidelity error and gradient assuming unitary dynamics, e.g.; closed qubit systems; Note fidelity and gradient calculations were taken from DYNAMO; (see file header). Attributes:; phase_option : string. determines how global phase is treated in fidelity calculations:; PSU - global phase ignored; SU - global phase included. fidelity_prenorm : complex; Last computed value of the fidelity before it is normalised; It is stored to use in the gradient normalisation calculation. fidelity_prenorm_current : boolean; flag to specify whether fidelity_prenorm are based on the; current amplitude values. Set False when amplitudes change. clear()[source]Â¶; clear any temporarily held status data. compute_fid_grad()[source]Â¶; Calculates exact gradient of function wrt to each timeslot; control amplitudes. Note these gradients are not normalised; These are returned as a (nTimeslots x n_ctrls) array. flag_system_changed()[source]Â¶; Flag fidelity and gradients as needing recalculation. get_fid_err()[sour",MatchSource.WIKI,docs/4.3/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/apidoc/classes.html
https://qutip.org/docs/4.3/apidoc/classes.html:104036,Availability,error,error,104036,"rror and gradient assuming unitary dynamics, e.g.; closed qubit systems; Note fidelity and gradient calculations were taken from DYNAMO; (see file header). Attributes:; phase_option : string. determines how global phase is treated in fidelity calculations:; PSU - global phase ignored; SU - global phase included. fidelity_prenorm : complex; Last computed value of the fidelity before it is normalised; It is stored to use in the gradient normalisation calculation. fidelity_prenorm_current : boolean; flag to specify whether fidelity_prenorm are based on the; current amplitude values. Set False when amplitudes change. clear()[source]Â¶; clear any temporarily held status data. compute_fid_grad()[source]Â¶; Calculates exact gradient of function wrt to each timeslot; control amplitudes. Note these gradients are not normalised; These are returned as a (nTimeslots x n_ctrls) array. flag_system_changed()[source]Â¶; Flag fidelity and gradients as needing recalculation. get_fid_err()[source]Â¶; Gets the absolute error in the fidelity. get_fid_err_gradient()[source]Â¶; Returns the normalised gradient of the fidelity error; in a (nTimeslots x n_ctrls) array; The gradients are cached in case they are requested; mutliple times between control updates; (although this is not typically found to happen). get_fidelity()[source]Â¶; Gets the appropriately normalised fidelity value; The normalisation is determined by the fid_norm_func pointer; which should be set in the config. get_fidelity_prenorm()[source]Â¶; Gets the current fidelity value prior to normalisation; Note the gradient function uses this value; The value is cached, because it is used in the gradient calculation. init_comp()[source]Â¶; Check configuration and initialise the normalisation. init_normalization()[source]Â¶; Calc norm of <Ufinal | Ufinal> to scale subsequent norms; When considering unitary time evolution operators, this basically; results in calculating the trace of the identity matrix; and is hence equal to the size of the ",MatchSource.WIKI,docs/4.3/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/apidoc/classes.html
https://qutip.org/docs/4.3/apidoc/classes.html:104140,Availability,error,error,104140,":; phase_option : string. determines how global phase is treated in fidelity calculations:; PSU - global phase ignored; SU - global phase included. fidelity_prenorm : complex; Last computed value of the fidelity before it is normalised; It is stored to use in the gradient normalisation calculation. fidelity_prenorm_current : boolean; flag to specify whether fidelity_prenorm are based on the; current amplitude values. Set False when amplitudes change. clear()[source]Â¶; clear any temporarily held status data. compute_fid_grad()[source]Â¶; Calculates exact gradient of function wrt to each timeslot; control amplitudes. Note these gradients are not normalised; These are returned as a (nTimeslots x n_ctrls) array. flag_system_changed()[source]Â¶; Flag fidelity and gradients as needing recalculation. get_fid_err()[source]Â¶; Gets the absolute error in the fidelity. get_fid_err_gradient()[source]Â¶; Returns the normalised gradient of the fidelity error; in a (nTimeslots x n_ctrls) array; The gradients are cached in case they are requested; mutliple times between control updates; (although this is not typically found to happen). get_fidelity()[source]Â¶; Gets the appropriately normalised fidelity value; The normalisation is determined by the fid_norm_func pointer; which should be set in the config. get_fidelity_prenorm()[source]Â¶; Gets the current fidelity value prior to normalisation; Note the gradient function uses this value; The value is cached, because it is used in the gradient calculation. init_comp()[source]Â¶; Check configuration and initialise the normalisation. init_normalization()[source]Â¶; Calc norm of <Ufinal | Ufinal> to scale subsequent norms; When considering unitary time evolution operators, this basically; results in calculating the trace of the identity matrix; and is hence equal to the size of the target matrix; There may be situations where this is not the case, and hence it; is not assumed to be so.; The normalisation function called should be set to either ",MatchSource.WIKI,docs/4.3/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/apidoc/classes.html
https://qutip.org/docs/4.3/apidoc/classes.html:105891,Availability,error,error,105891,"f the identity matrix; and is hence equal to the size of the target matrix; There may be situations where this is not the case, and hence it; is not assumed to be so.; The normalisation function called should be set to either the; PSU - global phase ignored; SU - global phase respected. normalize_PSU(A)[source]Â¶. normalize_SU(A)[source]Â¶. normalize_gradient_PSU(grad)[source]Â¶; Normalise the gradient matrix passed as grad; This PSU version is independent of global phase. normalize_gradient_SU(grad)[source]Â¶; Normalise the gradient matrix passed as grad; This SU version respects global phase. reset()[source]Â¶; reset any configuration data and; clear any temporarily held status data. set_phase_option(phase_option=None)[source]Â¶; Deprecated - use phase_option; Phase options are; SU - global phase important; PSU - global phase is not important. class FidCompTraceDiff(dynamics, params=None)[source]Â¶; Computes fidelity error and gradient for general system dynamics; by calculating the the fidelity error as the trace of the overlap; of the difference between the target and evolution resulting from; the pulses with the transpose of the same.; This should provide a distance measure for dynamics described by matrices; Note the gradient calculation is taken from:; âRobust quantum gates for open systems via optimal control:; Markovian versus non-Markovian dynamicsâ; Frederik F Floether, Pierre de Fouquieres, and Sophie G Schirmer. Attributes:; scale_factor : float; The fidelity error calculated is of some arbitary scale. This; factor can be used to scale the fidelity error such that it may; represent some physical measure; If None is given then it is caculated as 1/2N, where N; is the dimension of the drift, when the Dynamics are initialised. compute_fid_err_grad()[source]Â¶; Calculate exact gradient of the fidelity error function; wrt to each timeslot control amplitudes.; Uses the trace difference norm fidelity; These are returned as a (nTimeslots x n_ctrls) array. get_fid_err()[",MatchSource.WIKI,docs/4.3/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/apidoc/classes.html
https://qutip.org/docs/4.3/apidoc/classes.html:105971,Availability,error,error,105971,"f the identity matrix; and is hence equal to the size of the target matrix; There may be situations where this is not the case, and hence it; is not assumed to be so.; The normalisation function called should be set to either the; PSU - global phase ignored; SU - global phase respected. normalize_PSU(A)[source]Â¶. normalize_SU(A)[source]Â¶. normalize_gradient_PSU(grad)[source]Â¶; Normalise the gradient matrix passed as grad; This PSU version is independent of global phase. normalize_gradient_SU(grad)[source]Â¶; Normalise the gradient matrix passed as grad; This SU version respects global phase. reset()[source]Â¶; reset any configuration data and; clear any temporarily held status data. set_phase_option(phase_option=None)[source]Â¶; Deprecated - use phase_option; Phase options are; SU - global phase important; PSU - global phase is not important. class FidCompTraceDiff(dynamics, params=None)[source]Â¶; Computes fidelity error and gradient for general system dynamics; by calculating the the fidelity error as the trace of the overlap; of the difference between the target and evolution resulting from; the pulses with the transpose of the same.; This should provide a distance measure for dynamics described by matrices; Note the gradient calculation is taken from:; âRobust quantum gates for open systems via optimal control:; Markovian versus non-Markovian dynamicsâ; Frederik F Floether, Pierre de Fouquieres, and Sophie G Schirmer. Attributes:; scale_factor : float; The fidelity error calculated is of some arbitary scale. This; factor can be used to scale the fidelity error such that it may; represent some physical measure; If None is given then it is caculated as 1/2N, where N; is the dimension of the drift, when the Dynamics are initialised. compute_fid_err_grad()[source]Â¶; Calculate exact gradient of the fidelity error function; wrt to each timeslot control amplitudes.; Uses the trace difference norm fidelity; These are returned as a (nTimeslots x n_ctrls) array. get_fid_err()[",MatchSource.WIKI,docs/4.3/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/apidoc/classes.html
https://qutip.org/docs/4.3/apidoc/classes.html:106455,Availability,error,error,106455,"adient_SU(grad)[source]Â¶; Normalise the gradient matrix passed as grad; This SU version respects global phase. reset()[source]Â¶; reset any configuration data and; clear any temporarily held status data. set_phase_option(phase_option=None)[source]Â¶; Deprecated - use phase_option; Phase options are; SU - global phase important; PSU - global phase is not important. class FidCompTraceDiff(dynamics, params=None)[source]Â¶; Computes fidelity error and gradient for general system dynamics; by calculating the the fidelity error as the trace of the overlap; of the difference between the target and evolution resulting from; the pulses with the transpose of the same.; This should provide a distance measure for dynamics described by matrices; Note the gradient calculation is taken from:; âRobust quantum gates for open systems via optimal control:; Markovian versus non-Markovian dynamicsâ; Frederik F Floether, Pierre de Fouquieres, and Sophie G Schirmer. Attributes:; scale_factor : float; The fidelity error calculated is of some arbitary scale. This; factor can be used to scale the fidelity error such that it may; represent some physical measure; If None is given then it is caculated as 1/2N, where N; is the dimension of the drift, when the Dynamics are initialised. compute_fid_err_grad()[source]Â¶; Calculate exact gradient of the fidelity error function; wrt to each timeslot control amplitudes.; Uses the trace difference norm fidelity; These are returned as a (nTimeslots x n_ctrls) array. get_fid_err()[source]Â¶; Gets the absolute error in the fidelity. get_fid_err_gradient()[source]Â¶; Returns the normalised gradient of the fidelity error; in a (nTimeslots x n_ctrls) array; The gradients are cached in case they are requested; mutliple times between control updates; (although this is not typically found to happen). init_comp()[source]Â¶; initialises the computer based on the configuration of the Dynamics; Calculates the scale_factor is not already set. reset()[source]Â¶; reset any co",MatchSource.WIKI,docs/4.3/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/apidoc/classes.html
https://qutip.org/docs/4.3/apidoc/classes.html:106546,Availability,error,error,106546,"nd; clear any temporarily held status data. set_phase_option(phase_option=None)[source]Â¶; Deprecated - use phase_option; Phase options are; SU - global phase important; PSU - global phase is not important. class FidCompTraceDiff(dynamics, params=None)[source]Â¶; Computes fidelity error and gradient for general system dynamics; by calculating the the fidelity error as the trace of the overlap; of the difference between the target and evolution resulting from; the pulses with the transpose of the same.; This should provide a distance measure for dynamics described by matrices; Note the gradient calculation is taken from:; âRobust quantum gates for open systems via optimal control:; Markovian versus non-Markovian dynamicsâ; Frederik F Floether, Pierre de Fouquieres, and Sophie G Schirmer. Attributes:; scale_factor : float; The fidelity error calculated is of some arbitary scale. This; factor can be used to scale the fidelity error such that it may; represent some physical measure; If None is given then it is caculated as 1/2N, where N; is the dimension of the drift, when the Dynamics are initialised. compute_fid_err_grad()[source]Â¶; Calculate exact gradient of the fidelity error function; wrt to each timeslot control amplitudes.; Uses the trace difference norm fidelity; These are returned as a (nTimeslots x n_ctrls) array. get_fid_err()[source]Â¶; Gets the absolute error in the fidelity. get_fid_err_gradient()[source]Â¶; Returns the normalised gradient of the fidelity error; in a (nTimeslots x n_ctrls) array; The gradients are cached in case they are requested; mutliple times between control updates; (although this is not typically found to happen). init_comp()[source]Â¶; initialises the computer based on the configuration of the Dynamics; Calculates the scale_factor is not already set. reset()[source]Â¶; reset any configuration data and; clear any temporarily held status data. class FidCompTraceDiffApprox(dynamics, params=None)[source]Â¶; As FidCompTraceDiff, except uses th",MatchSource.WIKI,docs/4.3/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/apidoc/classes.html
https://qutip.org/docs/4.3/apidoc/classes.html:106799,Availability,error,error,106799,"bal phase is not important. class FidCompTraceDiff(dynamics, params=None)[source]Â¶; Computes fidelity error and gradient for general system dynamics; by calculating the the fidelity error as the trace of the overlap; of the difference between the target and evolution resulting from; the pulses with the transpose of the same.; This should provide a distance measure for dynamics described by matrices; Note the gradient calculation is taken from:; âRobust quantum gates for open systems via optimal control:; Markovian versus non-Markovian dynamicsâ; Frederik F Floether, Pierre de Fouquieres, and Sophie G Schirmer. Attributes:; scale_factor : float; The fidelity error calculated is of some arbitary scale. This; factor can be used to scale the fidelity error such that it may; represent some physical measure; If None is given then it is caculated as 1/2N, where N; is the dimension of the drift, when the Dynamics are initialised. compute_fid_err_grad()[source]Â¶; Calculate exact gradient of the fidelity error function; wrt to each timeslot control amplitudes.; Uses the trace difference norm fidelity; These are returned as a (nTimeslots x n_ctrls) array. get_fid_err()[source]Â¶; Gets the absolute error in the fidelity. get_fid_err_gradient()[source]Â¶; Returns the normalised gradient of the fidelity error; in a (nTimeslots x n_ctrls) array; The gradients are cached in case they are requested; mutliple times between control updates; (although this is not typically found to happen). init_comp()[source]Â¶; initialises the computer based on the configuration of the Dynamics; Calculates the scale_factor is not already set. reset()[source]Â¶; reset any configuration data and; clear any temporarily held status data. class FidCompTraceDiffApprox(dynamics, params=None)[source]Â¶; As FidCompTraceDiff, except uses the finite difference method to; compute approximate gradients. Attributes:; epsilon : float; control amplitude offset to use when approximating the gradient wrt; a timeslot control",MatchSource.WIKI,docs/4.3/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/apidoc/classes.html
https://qutip.org/docs/4.3/apidoc/classes.html:106994,Availability,error,error,106994," trace of the overlap; of the difference between the target and evolution resulting from; the pulses with the transpose of the same.; This should provide a distance measure for dynamics described by matrices; Note the gradient calculation is taken from:; âRobust quantum gates for open systems via optimal control:; Markovian versus non-Markovian dynamicsâ; Frederik F Floether, Pierre de Fouquieres, and Sophie G Schirmer. Attributes:; scale_factor : float; The fidelity error calculated is of some arbitary scale. This; factor can be used to scale the fidelity error such that it may; represent some physical measure; If None is given then it is caculated as 1/2N, where N; is the dimension of the drift, when the Dynamics are initialised. compute_fid_err_grad()[source]Â¶; Calculate exact gradient of the fidelity error function; wrt to each timeslot control amplitudes.; Uses the trace difference norm fidelity; These are returned as a (nTimeslots x n_ctrls) array. get_fid_err()[source]Â¶; Gets the absolute error in the fidelity. get_fid_err_gradient()[source]Â¶; Returns the normalised gradient of the fidelity error; in a (nTimeslots x n_ctrls) array; The gradients are cached in case they are requested; mutliple times between control updates; (although this is not typically found to happen). init_comp()[source]Â¶; initialises the computer based on the configuration of the Dynamics; Calculates the scale_factor is not already set. reset()[source]Â¶; reset any configuration data and; clear any temporarily held status data. class FidCompTraceDiffApprox(dynamics, params=None)[source]Â¶; As FidCompTraceDiff, except uses the finite difference method to; compute approximate gradients. Attributes:; epsilon : float; control amplitude offset to use when approximating the gradient wrt; a timeslot control amplitude. compute_fid_err_grad()[source]Â¶; Calculates gradient of function wrt to each timeslot; control amplitudes. Note these gradients are not normalised; They are calulated; These are retu",MatchSource.WIKI,docs/4.3/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/apidoc/classes.html
https://qutip.org/docs/4.3/apidoc/classes.html:107098,Availability,error,error,107098,"easure for dynamics described by matrices; Note the gradient calculation is taken from:; âRobust quantum gates for open systems via optimal control:; Markovian versus non-Markovian dynamicsâ; Frederik F Floether, Pierre de Fouquieres, and Sophie G Schirmer. Attributes:; scale_factor : float; The fidelity error calculated is of some arbitary scale. This; factor can be used to scale the fidelity error such that it may; represent some physical measure; If None is given then it is caculated as 1/2N, where N; is the dimension of the drift, when the Dynamics are initialised. compute_fid_err_grad()[source]Â¶; Calculate exact gradient of the fidelity error function; wrt to each timeslot control amplitudes.; Uses the trace difference norm fidelity; These are returned as a (nTimeslots x n_ctrls) array. get_fid_err()[source]Â¶; Gets the absolute error in the fidelity. get_fid_err_gradient()[source]Â¶; Returns the normalised gradient of the fidelity error; in a (nTimeslots x n_ctrls) array; The gradients are cached in case they are requested; mutliple times between control updates; (although this is not typically found to happen). init_comp()[source]Â¶; initialises the computer based on the configuration of the Dynamics; Calculates the scale_factor is not already set. reset()[source]Â¶; reset any configuration data and; clear any temporarily held status data. class FidCompTraceDiffApprox(dynamics, params=None)[source]Â¶; As FidCompTraceDiff, except uses the finite difference method to; compute approximate gradients. Attributes:; epsilon : float; control amplitude offset to use when approximating the gradient wrt; a timeslot control amplitude. compute_fid_err_grad()[source]Â¶; Calculates gradient of function wrt to each timeslot; control amplitudes. Note these gradients are not normalised; They are calulated; These are returned as a (nTimeslots x n_ctrls) array. reset()[source]Â¶; reset any configuration data and; clear any temporarily held status data. class TimeslotComputer(dynamics, ",MatchSource.WIKI,docs/4.3/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/apidoc/classes.html
https://qutip.org/docs/4.3/apidoc/classes.html:121780,Availability,error,error,121780,"me for the optimisation. wall_time_optim_end : float; End time for the optimisation. wall_time_optim : float; Time elasped during the optimisation. wall_time_dyn_gen_compute : float; Total wall (elasped) time computing combined dynamics generator; (for example combining drift and control Hamiltonians). wall_time_prop_compute : float; Total wall (elasped) time computing propagators, that is the; time evolution from one timeslot to the next; Includes calculating the propagator gradient for exact gradients. wall_time_fwd_prop_compute : float; Total wall (elasped) time computing combined forward propagation,; that is the time evolution from the start to a specific timeslot.; Excludes calculating the propagators themselves. wall_time_onwd_prop_compute : float; Total wall (elasped) time computing combined onward propagation,; that is the time evolution from a specific timeslot to the end time.; Excludes calculating the propagators themselves. wall_time_gradient_compute : float; Total wall (elasped) time computing the fidelity error gradient.; Excludes calculating the propagator gradients (in exact gradient; methods). num_fidelity_func_calls : integer; Number of calls to fidelity function by the optimisation algorithm. num_grad_func_calls : integer; Number of calls to gradient function by the optimisation algorithm. num_tslot_recompute : integer; Number of time the timeslot evolution is recomputed; (It is only computed if any amplitudes changed since the last call). num_fidelity_computes : integer; Number of time the fidelity is computed; (It is only computed if any amplitudes changed since the last call). num_grad_computes : integer; Number of time the gradient is computed; (It is only computed if any amplitudes changed since the last call). num_ctrl_amp_updates : integer; Number of times the control amplitudes are updated. mean_num_ctrl_amp_updates_per_iter : float; Mean number of control amplitude updates per iteration. num_timeslot_changes : integer; Number of times the",MatchSource.WIKI,docs/4.3/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/apidoc/classes.html
https://qutip.org/docs/4.3/apidoc/classes.html:125650,Availability,error,error,125650," summary file.; default is a space. data_sep : str; delimiter for the data files (arrays saved to file).; default is a space. summary_file : str; File path for summary file.; Automatically generated. Can be set specifically. create_dump_dir()[source]Â¶; Checks dump directory exists, creates it if not. levelÂ¶. The level of data dumping that will occur. SUMMARY : A summary will be recorded; FULL : All possible dumping; CUSTOM : Some customised level of dumping. When first set to CUSTOM this is equivalent to SUMMARY. It is then up; to the user to specify what specifically is dumped. class OptimDump(optim, level='SUMMARY')[source]Â¶; A container for dumps of optimisation data generated during the pulse; optimisation. Attributes:; dump_summary : bool; When True summary items are appended to the iter_summary. iter_summary : list of optimizer.OptimIterSummary; Summary at each iteration. dump_fid_err : bool; When True values are appended to the fid_err_log. fid_err_log : list of float; Fidelity error at each call of the fid_err_func. dump_grad_norm : bool; When True values are appended to the fid_err_log. grad_norm_log : list of float; Gradient norm at each call of the grad_norm_log. dump_grad : bool; When True values are appended to the grad_log. grad_log : list of ndarray; Gradients at each call of the fid_grad_func. add_iter_summary()[source]Â¶; add copy of current optimizer iteration summary. dump_allÂ¶; True if everything (ignoring the summary) is to be dumped. dump_anyÂ¶; True if anything other than the summary is to be dumped. update_fid_err_log(fid_err)[source]Â¶; add an entry to the fid_err log. update_grad_log(grad)[source]Â¶; add an entry to the grad log. update_grad_norm_log(grad_norm)[source]Â¶; add an entry to the grad_norm log. writeout(f=None)[source]Â¶; write all the logs and the summary out to file(s). Parameters:; f : filename or filehandle; If specified then all summary and object data will go in one file.; If None is specified then type specific files will be ge",MatchSource.WIKI,docs/4.3/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/apidoc/classes.html
https://qutip.org/docs/4.3/apidoc/classes.html:26460,Deployability,integrat,integrate,26460,"tzmann=None, renorm=None, bnd_cut_approx=None, options=None, progress_bar=None, stats=None)[source]Â¶; Configure the solver using the passed parameters; The parameters are described in the class attributes, unless there; is some specific behaviour. Parameters:; options : qutip.solver.Options; Generic solver options.; If set to None the default options will be used. progress_bar: BaseProgressBar; Optional instance of BaseProgressBar, or a subclass thereof, for; showing the progress of the simulation.; If set to None, then the default progress bar will be used; Set to False for no progress bar. stats: :class:`qutip.solver.Stats`; Optional instance of solver.Stats, or a subclass thereof, for; storing performance statistics for the solver; If set to True, then the default Stats for this class will be used; Set to False for no stats. create_new_stats()[source]Â¶; Creates a new stats object suitable for use with this solver; Note: this solver expects the stats object to have sections. config; integrate. reset()[source]Â¶; Reset any attributes to default values. class HSolverDL(H_sys, coup_op, coup_strength, temperature, N_cut, N_exp, cut_freq, planck=1.0, boltzmann=1.0, renorm=True, bnd_cut_approx=True, options=None, progress_bar=None, stats=None)[source]Â¶; HEOM solver based on the Drude-Lorentz model for spectral density.; Drude-Lorentz bath the correlation functions can be exactly analytically; expressed as an infinite sum of exponentials which depend on the; temperature, these are called the Matsubara terms or Matsubara frequencies; For practical computation purposes an approximation must be used based; on a small number of Matsubara terms (typically < 4). Attributes:; cut_freq : float; Bath spectral density cutoff frequency. renorm : bool; Apply renormalisation to coupling terms; Can be useful if using SI units for planck and boltzmann. bnd_cut_approx : bool; Use boundary cut off approximation; Can be. configure(H_sys, coup_op, coup_strength, temperature, N_cut, N_exp, cu",MatchSource.WIKI,docs/4.3/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/apidoc/classes.html
https://qutip.org/docs/4.3/apidoc/classes.html:28107,Deployability,integrat,integrator,28107,"eq : float; Bath spectral density cutoff frequency. renorm : bool; Apply renormalisation to coupling terms; Can be useful if using SI units for planck and boltzmann. bnd_cut_approx : bool; Use boundary cut off approximation; Can be. configure(H_sys, coup_op, coup_strength, temperature, N_cut, N_exp, cut_freq, planck=None, boltzmann=None, renorm=None, bnd_cut_approx=None, options=None, progress_bar=None, stats=None)[source]Â¶; Calls configure from HEOMSolver and sets any attributes; that are specific to this subclass. reset()[source]Â¶; Reset any attributes to default values. run(rho0, tlist)[source]Â¶; Function to solve for an open quantum system using the; HEOM model. Parameters:; rho0 : Qobj; Initial state (density matrix) of the system. tlist : list; Time over which system evolves. Returns:; results : qutip.solver.Result; Object storing all results from the simulation. class MemoryCascade(H_S, L1, L2, S_matrix=None, c_ops_markov=None, integrator='propagator', parallel=False, options=None)[source]Â¶; Class for running memory cascade simulations of open quantum systems; with time-delayed coherent feedback. Attributes:; H_S : qutip.Qobj; System Hamiltonian (can also be a Liouvillian). L1 : qutip.Qobj / list of qutip.Qobj; System operators coupling into the feedback loop. Can be a single; operator or a list of operators. L2 : qutip.Qobj / list of qutip.Qobj; System operators coupling out of the feedback loop. Can be a single; operator or a list of operators. L2 must have the same length as L1. S_matrix: *array*; S matrix describing which operators in L1 are coupled to which; operators in L2 by the feedback channel. Defaults to an n by n identity; matrix where n is the number of elements in L1/L2. c_ops_markov : qutip.Qobj / list of qutip.Qobj; Decay operators describing conventional Markovian decay channels.; Can be a single operator or a list of operators. integrator : str {âpropagatorâ, âmesolveâ}; Integrator method to use. Defaults to âpropagatorâ which tends to be; fa",MatchSource.WIKI,docs/4.3/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/apidoc/classes.html
https://qutip.org/docs/4.3/apidoc/classes.html:29043,Deployability,integrat,integrator,29043,"trix=None, c_ops_markov=None, integrator='propagator', parallel=False, options=None)[source]Â¶; Class for running memory cascade simulations of open quantum systems; with time-delayed coherent feedback. Attributes:; H_S : qutip.Qobj; System Hamiltonian (can also be a Liouvillian). L1 : qutip.Qobj / list of qutip.Qobj; System operators coupling into the feedback loop. Can be a single; operator or a list of operators. L2 : qutip.Qobj / list of qutip.Qobj; System operators coupling out of the feedback loop. Can be a single; operator or a list of operators. L2 must have the same length as L1. S_matrix: *array*; S matrix describing which operators in L1 are coupled to which; operators in L2 by the feedback channel. Defaults to an n by n identity; matrix where n is the number of elements in L1/L2. c_ops_markov : qutip.Qobj / list of qutip.Qobj; Decay operators describing conventional Markovian decay channels.; Can be a single operator or a list of operators. integrator : str {âpropagatorâ, âmesolveâ}; Integrator method to use. Defaults to âpropagatorâ which tends to be; faster for long times (i.e., large Hilbert space). parallel : bool; Run integrator in parallel if True. Only implemented for âpropagatorâ; as the integrator method. options : qutip.solver.Options; Generic solver options. outfieldcorr(rho0, blist, tlist, tau, c1=None, c2=None)[source]Â¶; Compute output field expectation value; <O_n(tn)â¦O_2(t2)O_1(t1)> for times t1,t2,â¦ and; O_i = I, b_out, b_out^dagger, b_loop, b_loop^dagger. Parameters:; rho0 : qutip.Qobj; initial density matrix or state vector (ket). blist : array_like; List of integers specifying the field operators:; 0: I (nothing); 1: b_out; 2: b_out^dagger; 3: b_loop; 4: b_loop^dagger. tlist : array_like; list of corresponding times t1,..,tn at which to evaluate the field; operators. tau : float; time-delay. c1 : qutip.Qobj; system collapse operator that couples to the in-loop field in; question (only needs to be specified if self.L1 has more than one; ",MatchSource.WIKI,docs/4.3/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/apidoc/classes.html
https://qutip.org/docs/4.3/apidoc/classes.html:29229,Deployability,integrat,integrator,29229,"systems; with time-delayed coherent feedback. Attributes:; H_S : qutip.Qobj; System Hamiltonian (can also be a Liouvillian). L1 : qutip.Qobj / list of qutip.Qobj; System operators coupling into the feedback loop. Can be a single; operator or a list of operators. L2 : qutip.Qobj / list of qutip.Qobj; System operators coupling out of the feedback loop. Can be a single; operator or a list of operators. L2 must have the same length as L1. S_matrix: *array*; S matrix describing which operators in L1 are coupled to which; operators in L2 by the feedback channel. Defaults to an n by n identity; matrix where n is the number of elements in L1/L2. c_ops_markov : qutip.Qobj / list of qutip.Qobj; Decay operators describing conventional Markovian decay channels.; Can be a single operator or a list of operators. integrator : str {âpropagatorâ, âmesolveâ}; Integrator method to use. Defaults to âpropagatorâ which tends to be; faster for long times (i.e., large Hilbert space). parallel : bool; Run integrator in parallel if True. Only implemented for âpropagatorâ; as the integrator method. options : qutip.solver.Options; Generic solver options. outfieldcorr(rho0, blist, tlist, tau, c1=None, c2=None)[source]Â¶; Compute output field expectation value; <O_n(tn)â¦O_2(t2)O_1(t1)> for times t1,t2,â¦ and; O_i = I, b_out, b_out^dagger, b_loop, b_loop^dagger. Parameters:; rho0 : qutip.Qobj; initial density matrix or state vector (ket). blist : array_like; List of integers specifying the field operators:; 0: I (nothing); 1: b_out; 2: b_out^dagger; 3: b_loop; 4: b_loop^dagger. tlist : array_like; list of corresponding times t1,..,tn at which to evaluate the field; operators. tau : float; time-delay. c1 : qutip.Qobj; system collapse operator that couples to the in-loop field in; question (only needs to be specified if self.L1 has more than one; element). c2 : qutip.Qobj; system collapse operator that couples to the output field in; question (only needs to be specified if self.L2 has more than one; e",MatchSource.WIKI,docs/4.3/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/apidoc/classes.html
https://qutip.org/docs/4.3/apidoc/classes.html:29303,Deployability,integrat,integrator,29303,"; H_S : qutip.Qobj; System Hamiltonian (can also be a Liouvillian). L1 : qutip.Qobj / list of qutip.Qobj; System operators coupling into the feedback loop. Can be a single; operator or a list of operators. L2 : qutip.Qobj / list of qutip.Qobj; System operators coupling out of the feedback loop. Can be a single; operator or a list of operators. L2 must have the same length as L1. S_matrix: *array*; S matrix describing which operators in L1 are coupled to which; operators in L2 by the feedback channel. Defaults to an n by n identity; matrix where n is the number of elements in L1/L2. c_ops_markov : qutip.Qobj / list of qutip.Qobj; Decay operators describing conventional Markovian decay channels.; Can be a single operator or a list of operators. integrator : str {âpropagatorâ, âmesolveâ}; Integrator method to use. Defaults to âpropagatorâ which tends to be; faster for long times (i.e., large Hilbert space). parallel : bool; Run integrator in parallel if True. Only implemented for âpropagatorâ; as the integrator method. options : qutip.solver.Options; Generic solver options. outfieldcorr(rho0, blist, tlist, tau, c1=None, c2=None)[source]Â¶; Compute output field expectation value; <O_n(tn)â¦O_2(t2)O_1(t1)> for times t1,t2,â¦ and; O_i = I, b_out, b_out^dagger, b_loop, b_loop^dagger. Parameters:; rho0 : qutip.Qobj; initial density matrix or state vector (ket). blist : array_like; List of integers specifying the field operators:; 0: I (nothing); 1: b_out; 2: b_out^dagger; 3: b_loop; 4: b_loop^dagger. tlist : array_like; list of corresponding times t1,..,tn at which to evaluate the field; operators. tau : float; time-delay. c1 : qutip.Qobj; system collapse operator that couples to the in-loop field in; question (only needs to be specified if self.L1 has more than one; element). c2 : qutip.Qobj; system collapse operator that couples to the output field in; question (only needs to be specified if self.L2 has more than one; element). Returns:; : complex; expectation value of field ",MatchSource.WIKI,docs/4.3/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/apidoc/classes.html
https://qutip.org/docs/4.3/apidoc/classes.html:33937,Deployability,integrat,integrator,33937,"olver options. Solver Options and ResultsÂ¶. class Options(atol=1e-08, rtol=1e-06, method='adams', order=12, nsteps=1000, first_step=0, max_step=0, min_step=0, average_expect=True, average_states=False, tidy=True, num_cpus=0, norm_tol=0.001, norm_steps=5, rhs_reuse=False, rhs_filename=None, ntraj=500, gui=False, rhs_with_state=False, store_final_state=False, store_states=False, seeds=None, steady_state_average=False, normalize_output=True, use_openmp=None, openmp_threads=None)[source]Â¶; Class of options for evolution solvers such as qutip.mesolve and; qutip.mcsolve. Options can be specified either as arguments to the; constructor:; opts = Options(order=10, ...). or by changing the class attributes after creation:; opts = Options(); opts.order = 10. Returns options class to be used as options in evolution solvers. Attributes:; atol : float {1e-8}; Absolute tolerance. rtol : float {1e-6}; Relative tolerance. method : str {âadamsâ,âbdfâ}; Integration method. order : int {12}; Order of integrator (<=12 âadamsâ, <=5 âbdfâ). nsteps : int {2500}; Max. number of internal steps/call. first_step : float {0}; Size of initial step (0 = automatic). min_step : float {0}; Minimum step size (0 = automatic). max_step : float {0}; Maximum step size (0 = automatic). tidy : bool {True,False}; Tidyup Hamiltonian and initial state by removing small terms. num_cpus : int; Number of cpus used by mcsolver (default = # of cpus). norm_tol : float; Tolerance used when finding wavefunction norm in mcsolve. norm_steps : int; Max. number of steps used to find wavefunction norm to within norm_tol; in mcsolve. average_states : bool {False}; Average states values over trajectories in stochastic solvers. average_expect : bool {True}; Average expectation values over trajectories for stochastic solvers. mc_corr_eps : float {1e-10}; Arbitrarily small value for eliminating any divide-by-zero errors in; correlation calculations when using mcsolve. ntraj : int {500}; Number of trajectories in stochastic solv",MatchSource.WIKI,docs/4.3/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/apidoc/classes.html
https://qutip.org/docs/4.3/apidoc/classes.html:48935,Deployability,integrat,integrate,48935,"ce]Â¶; Build collapse operators in the full Hilbert space 2^N. Returns:; c_ops_list: list; The list with the collapse operators in the 2^N Hilbert space. coefficient_matrix()[source]Â¶; Build coefficient matrix for ODE for a diagonal problem. Returns:; M: ndarray; The matrix M of the coefficients for the ODE dp/dt = Mp.; p is the vector of the diagonal matrix elements; of the density matrix rho in the Dicke basis. lindbladian()[source]Â¶; Build the Lindbladian superoperator of the dissipative dynamics. Returns:; lindbladian: :class: qutip.Qobj; The Lindbladian matrix as a qutip.Qobj. liouvillian()[source]Â¶; Build the total Liouvillian using the Dicke basis. Returns:; liouv: :class: qutip.Qobj; The Liouvillian matrix for the system. pisolve(initial_state, tlist, options=None)[source]Â¶; Solve for diagonal Hamiltonians and initial states faster. Parameters:; initial_state: :class: qutip.Qobj; An initial state specified as a density matrix of; qutip.Qbj type. tlist: ndarray; A 1D numpy array of list of timesteps to integrate. options: :class: qutip.solver.Options; The options for the solver. Returns:; result: list; A dictionary of the type qutip.solver.Result which holds the; results of the evolution. prune_eigenstates(liouvillian)[source]Â¶; Remove spurious eigenvalues and eigenvectors of the Liouvillian.; Spurious means that the given eigenvector has elements outside of the; block-diagonal matrix. Parameters:; liouvillian_eigenstates: list; A list with the eigenvalues and eigenvectors of the Liouvillian; including spurious ones. Returns:; correct_eigenstates: list; The list with the correct eigenvalues and eigenvectors of the; Liouvillian. class Pim(N, emission=0.0, dephasing=0, pumping=0, collective_emission=0, collective_pumping=0, collective_dephasing=0)[source]Â¶; The Permutation Invariant Matrix class.; Initialize the class with the parameters for generating a Permutation; Invariant matrix which evolves a given diagonal initial state p as:. dp/dt = Mp. Parameters:; N:",MatchSource.WIKI,docs/4.3/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/apidoc/classes.html
https://qutip.org/docs/4.3/apidoc/classes.html:56273,Deployability,update,update,56273," dimensionality of the underlaying distribution.; Parameters:. fig : matplotlib Figure instance; If given, use this figure instance for the visualization,; ax : matplotlib Axes instance; If given, render the visualization using this axis instance.; figsize : tuple; Size of the new Figure instance, if one needs to be created.; colorbar: Bool; Whether or not the colorbar (in 2D visualization) should be used.; cmap: matplotlib colormap instance; If given, use this colormap for 2D visualizations.; style : string; Type of visualization: âcolormapâ (default) or âsurfaceâ. Returns:; fig, ax : tuple; A tuple of matplotlib figure and axes instances. class WignerDistribution(rho=None, extent=[[-5, 5], [-5, 5]], steps=250)[source]Â¶. class QDistribution(rho=None, extent=[[-5, 5], [-5, 5]], steps=250)[source]Â¶. class TwoModeQuadratureCorrelation(state=None, theta1=0.0, theta2=0.0, extent=[[-5, 5], [-5, 5]], steps=250)[source]Â¶. update(state)[source]Â¶; calculate probability distribution for quadrature measurement; outcomes given a two-mode wavefunction or density matrix. update_psi(psi)[source]Â¶; calculate probability distribution for quadrature measurement; outcomes given a two-mode wavefunction. update_rho(rho)[source]Â¶; calculate probability distribution for quadrature measurement; outcomes given a two-mode density matrix. class HarmonicOscillatorWaveFunction(psi=None, omega=1.0, extent=[-5, 5], steps=250)[source]Â¶. update(psi)[source]Â¶; Calculate the wavefunction for the given state of an harmonic; oscillator. class HarmonicOscillatorProbabilityFunction(rho=None, omega=1.0, extent=[-5, 5], steps=250)[source]Â¶. update(rho)[source]Â¶; Calculate the probability function for the given state of an harmonic; oscillator (as density matrix). Quantum information processingÂ¶. class Gate(name, targets=None, controls=None, arg_value=None, arg_label=None)[source]Â¶; Representation of a quantum gate, with its required parametrs, and target; and control qubits. class QubitCircuit(N, input_stat",MatchSource.WIKI,docs/4.3/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/apidoc/classes.html
https://qutip.org/docs/4.3/apidoc/classes.html:56773,Deployability,update,update,56773,"or 2D visualizations.; style : string; Type of visualization: âcolormapâ (default) or âsurfaceâ. Returns:; fig, ax : tuple; A tuple of matplotlib figure and axes instances. class WignerDistribution(rho=None, extent=[[-5, 5], [-5, 5]], steps=250)[source]Â¶. class QDistribution(rho=None, extent=[[-5, 5], [-5, 5]], steps=250)[source]Â¶. class TwoModeQuadratureCorrelation(state=None, theta1=0.0, theta2=0.0, extent=[[-5, 5], [-5, 5]], steps=250)[source]Â¶. update(state)[source]Â¶; calculate probability distribution for quadrature measurement; outcomes given a two-mode wavefunction or density matrix. update_psi(psi)[source]Â¶; calculate probability distribution for quadrature measurement; outcomes given a two-mode wavefunction. update_rho(rho)[source]Â¶; calculate probability distribution for quadrature measurement; outcomes given a two-mode density matrix. class HarmonicOscillatorWaveFunction(psi=None, omega=1.0, extent=[-5, 5], steps=250)[source]Â¶. update(psi)[source]Â¶; Calculate the wavefunction for the given state of an harmonic; oscillator. class HarmonicOscillatorProbabilityFunction(rho=None, omega=1.0, extent=[-5, 5], steps=250)[source]Â¶. update(rho)[source]Â¶; Calculate the probability function for the given state of an harmonic; oscillator (as density matrix). Quantum information processingÂ¶. class Gate(name, targets=None, controls=None, arg_value=None, arg_label=None)[source]Â¶; Representation of a quantum gate, with its required parametrs, and target; and control qubits. class QubitCircuit(N, input_states=None, output_states=None, reverse_states=True)[source]Â¶; Representation of a quantum program/algorithm, maintaining a sequence; of gates. add_1q_gate(name, start=0, end=None, qubits=None, arg_value=None, arg_label=None)[source]Â¶; Adds a single qubit gate with specified parameters on a variable; number of qubits in the circuit. By default, it applies the given gate; to all the qubits in the register. Parameters:; name : String; Gate name. start : Integer; Starting locat",MatchSource.WIKI,docs/4.3/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/apidoc/classes.html
https://qutip.org/docs/4.3/apidoc/classes.html:56972,Deployability,update,update,56972,"t=[[-5, 5], [-5, 5]], steps=250)[source]Â¶. class QDistribution(rho=None, extent=[[-5, 5], [-5, 5]], steps=250)[source]Â¶. class TwoModeQuadratureCorrelation(state=None, theta1=0.0, theta2=0.0, extent=[[-5, 5], [-5, 5]], steps=250)[source]Â¶. update(state)[source]Â¶; calculate probability distribution for quadrature measurement; outcomes given a two-mode wavefunction or density matrix. update_psi(psi)[source]Â¶; calculate probability distribution for quadrature measurement; outcomes given a two-mode wavefunction. update_rho(rho)[source]Â¶; calculate probability distribution for quadrature measurement; outcomes given a two-mode density matrix. class HarmonicOscillatorWaveFunction(psi=None, omega=1.0, extent=[-5, 5], steps=250)[source]Â¶. update(psi)[source]Â¶; Calculate the wavefunction for the given state of an harmonic; oscillator. class HarmonicOscillatorProbabilityFunction(rho=None, omega=1.0, extent=[-5, 5], steps=250)[source]Â¶. update(rho)[source]Â¶; Calculate the probability function for the given state of an harmonic; oscillator (as density matrix). Quantum information processingÂ¶. class Gate(name, targets=None, controls=None, arg_value=None, arg_label=None)[source]Â¶; Representation of a quantum gate, with its required parametrs, and target; and control qubits. class QubitCircuit(N, input_states=None, output_states=None, reverse_states=True)[source]Â¶; Representation of a quantum program/algorithm, maintaining a sequence; of gates. add_1q_gate(name, start=0, end=None, qubits=None, arg_value=None, arg_label=None)[source]Â¶; Adds a single qubit gate with specified parameters on a variable; number of qubits in the circuit. By default, it applies the given gate; to all the qubits in the register. Parameters:; name : String; Gate name. start : Integer; Starting location of qubits. end : Integer; Last qubit for the gate. qubits : List; Specific qubits for applying gates. arg_value : Float; Argument value(phi). arg_label : String; Label for gate representation. add_circuit(qc, ",MatchSource.WIKI,docs/4.3/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/apidoc/classes.html
https://qutip.org/docs/4.3/apidoc/classes.html:67158,Deployability,configurat,configuration,67158," by stacking; them together. get_ops_labels()[source]Â¶; Returns the Hamiltonian operators and corresponding labels by stacking; them together. load_circuit(qc)[source]Â¶; Translates an abstract quantum circuit to its corresponding Hamiltonian; for a specific model. Parameters:; qc: QubitCircuit; Takes the quantum circuit to be implemented. optimize_circuit(qc)[source]Â¶; Function to take a quantum circuit/algorithm and convert it into the; optimal form/basis for the desired physical system. Parameters:; qc: QubitCircuit; Takes the quantum circuit to be implemented. Returns:; qc: QubitCircuit; The optimal circuit representation. Optimal controlÂ¶. class Optimizer(config, dyn, params=None)[source]Â¶; Base class for all control pulse optimisers. This class should not be; instantiated, use its subclasses; This class implements the fidelity, gradient and interation callback; functions.; All subclass objects must be initialised with a. OptimConfig instance - various configuration options; Dynamics instance - describes the dynamics of the (quantum) system. to be control optimised. Attributes:; log_level : integer; level of messaging output from the logger.; Options are attributes of qutip.logging_utils,; in decreasing levels of messaging, are:; DEBUG_INTENSE, DEBUG_VERBOSE, DEBUG, INFO, WARN, ERROR, CRITICAL; Anything WARN or above is effectively âquietâ execution,; assuming everything runs as expected.; The default NOTSET implies that the level will be taken from; the QuTiP settings file, which by default is WARN. params: Dictionary; The key value pairs are the attribute name and value; Note: attributes are created if they do not exist already,; and are overwritten if they do. alg : string; Algorithm to use in pulse optimisation.; Options are:. âGRAPEâ (default) - GRadient Ascent Pulse Engineering; âCRABâ - Chopped RAndom Basis. alg_params : Dictionary; options that are specific to the pulse optim algorithm; that is GRAPE or CRAB. disp_conv_msg : bool; Set true to display a c",MatchSource.WIKI,docs/4.3/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/apidoc/classes.html
https://qutip.org/docs/4.3/apidoc/classes.html:69788,Deployability,configurat,configuration,69788,"lled; Note it should be left False when using the Dynamics; to calculate approximate gradients; Note it is set True automatically when the alg is CRAB. amp_lbound : float or list of floats; lower boundaries for the control amplitudes; Can be a scalar value applied to all controls; or a list of bounds for each control. amp_ubound : float or list of floats; upper boundaries for the control amplitudes; Can be a scalar value applied to all controls; or a list of bounds for each control. bounds : List of floats; Bounds for the parameters.; If not set before the run_optimization call then the list; is built automatically based on the amp_lbound and amp_ubound; attributes.; Setting this attribute directly allows specific bounds to be set; for individual parameters.; Note: Only some methods use bounds. dynamics : Dynamics (subclass instance); describes the dynamics of the (quantum) system to be control optimised; (see Dynamics classes for details). config : OptimConfig instance; various configuration options; (see OptimConfig for details). termination_conditions : TerminationCondition instance; attributes determine when the optimisation will end. pulse_generator : PulseGen (subclass instance); (can be) used to create initial pulses; not used by the class, but set by pulseoptim.create_pulse_optimizer. stats : Stats; attributes of which give performance stats for the optimisation; set to None to reduce overhead of calculating stats.; Note it is (usually) shared with the Dynamics instance. dump : dump.OptimDump; Container for data dumped during the optimisation.; Can be set by specifying the dumping level or set directly.; Note this is mainly intended for user and a development debugging; but could be used for status information during a long optimisation. dumping : string; The level of data dumping that will occur during the optimisation - NONE : No processing data dumped (Default) - SUMMARY : A summary at each iteration will be recorded - FULL : All logs will be generated and",MatchSource.WIKI,docs/4.3/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/apidoc/classes.html
https://qutip.org/docs/4.3/apidoc/classes.html:72874,Deployability,update,update,72874," called during the instantiation automatically.; The key value pairs are the attribute name and value; Note: attributes are created if they do not exist already,; and are overwritten if they do. dumpingÂ¶. The level of data dumping that will occur during the optimisation. NONE : No processing data dumped (Default); SUMMARY : A summary at each iteration will be recorded; FULL : All logs will be generated and dumped; CUSTOM : Some customised level of dumping. When first set to CUSTOM this is equivalent to SUMMARY. It is then up; to the user to specify which logs are dumped. fid_err_func_wrapper(*args)[source]Â¶; Get the fidelity error achieved using the ctrl amplitudes passed; in as the first argument.; This is called by generic optimisation algorithm as the; func to the minimised. The argument is the current; variable values, i.e. control amplitudes, passed as; a flat array. Hence these are reshaped as [nTimeslots, n_ctrls]; and then used to update the stored ctrl values (if they have changed); The error is checked against the target, and the optimisation is; terminated if the target has been achieved. fid_err_grad_wrapper(*args)[source]Â¶; Get the gradient of the fidelity error with respect to all of the; variables, i.e. the ctrl amplidutes in each timeslot; This is called by generic optimisation algorithm as the gradients of; func to the minimised wrt the variables. The argument is the current; variable values, i.e. control amplitudes, passed as; a flat array. Hence these are reshaped as [nTimeslots, n_ctrls]; and then used to update the stored ctrl values (if they have changed); Although the optimisation algorithms have a check within them for; function convergence, i.e. local minima, the sum of the squares; of the normalised gradient is checked explicitly, and the; optimisation is terminated if this is below the min_gradient_norm; condition. init_optim(term_conds)[source]Â¶; Check optimiser attribute status and passed parameters before; running the optimisation.; Thi",MatchSource.WIKI,docs/4.3/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/apidoc/classes.html
https://qutip.org/docs/4.3/apidoc/classes.html:73472,Deployability,update,update,73472,"c_wrapper(*args)[source]Â¶; Get the fidelity error achieved using the ctrl amplitudes passed; in as the first argument.; This is called by generic optimisation algorithm as the; func to the minimised. The argument is the current; variable values, i.e. control amplitudes, passed as; a flat array. Hence these are reshaped as [nTimeslots, n_ctrls]; and then used to update the stored ctrl values (if they have changed); The error is checked against the target, and the optimisation is; terminated if the target has been achieved. fid_err_grad_wrapper(*args)[source]Â¶; Get the gradient of the fidelity error with respect to all of the; variables, i.e. the ctrl amplidutes in each timeslot; This is called by generic optimisation algorithm as the gradients of; func to the minimised wrt the variables. The argument is the current; variable values, i.e. control amplitudes, passed as; a flat array. Hence these are reshaped as [nTimeslots, n_ctrls]; and then used to update the stored ctrl values (if they have changed); Although the optimisation algorithms have a check within them for; function convergence, i.e. local minima, the sum of the squares; of the normalised gradient is checked explicitly, and the; optimisation is terminated if this is below the min_gradient_norm; condition. init_optim(term_conds)[source]Â¶; Check optimiser attribute status and passed parameters before; running the optimisation.; This is called by run_optimization, but could called independently; to check the configuration. iter_step_callback_func(*args)[source]Â¶; Check the elapsed wall time for the optimisation run so far.; Terminate if this has exceeded the maximum allowed time. run_optimization(term_conds=None)[source]Â¶; This default function optimisation method is a wrapper to the; scipy.optimize.minimize function.; It will attempt to minimise the fidelity error with respect to some; parameters, which are determined by _get_optim_var_vals (see below); The optimisation end when one of the passed termination ",MatchSource.WIKI,docs/4.3/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/apidoc/classes.html
https://qutip.org/docs/4.3/apidoc/classes.html:73999,Deployability,configurat,configuration,73999,"get, and the optimisation is; terminated if the target has been achieved. fid_err_grad_wrapper(*args)[source]Â¶; Get the gradient of the fidelity error with respect to all of the; variables, i.e. the ctrl amplidutes in each timeslot; This is called by generic optimisation algorithm as the gradients of; func to the minimised wrt the variables. The argument is the current; variable values, i.e. control amplitudes, passed as; a flat array. Hence these are reshaped as [nTimeslots, n_ctrls]; and then used to update the stored ctrl values (if they have changed); Although the optimisation algorithms have a check within them for; function convergence, i.e. local minima, the sum of the squares; of the normalised gradient is checked explicitly, and the; optimisation is terminated if this is below the min_gradient_norm; condition. init_optim(term_conds)[source]Â¶; Check optimiser attribute status and passed parameters before; running the optimisation.; This is called by run_optimization, but could called independently; to check the configuration. iter_step_callback_func(*args)[source]Â¶; Check the elapsed wall time for the optimisation run so far.; Terminate if this has exceeded the maximum allowed time. run_optimization(term_conds=None)[source]Â¶; This default function optimisation method is a wrapper to the; scipy.optimize.minimize function.; It will attempt to minimise the fidelity error with respect to some; parameters, which are determined by _get_optim_var_vals (see below); The optimisation end when one of the passed termination conditions; has been met, e.g. target achieved, wall time, or; function call or iteration count exceeded. Note these; conditions include gradient minimum met (local minima) for; methods that use a gradient.; The function minimisation method is taken from the optim_method; attribute. Note that not all of these methods have been tested.; Note that some of these use a gradient and some do not.; See the scipy documentation for details. Options specific to",MatchSource.WIKI,docs/4.3/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/apidoc/classes.html
https://qutip.org/docs/4.3/apidoc/classes.html:76779,Deployability,configurat,configuration,76779,"ma), wall time / iteration count exceeded.; Essentially this is wrapper to the:; scipy.optimize.fmin_bfgs; function; If the parameter term_conds=None, then the termination_conditions; attribute must already be set. It will be overwritten if the; parameter is not None; The result is returned in an OptimResult object, which includes; the final fidelity, time evolution, reason for termination etc. class OptimizerLBFGSB(config, dyn, params=None)[source]Â¶; Implements the run_optimization method using the L-BFGS-B algorithm. Attributes:; max_metric_corr : integer; The maximum number of variable metric corrections used to define; the limited memory matrix. That is the number of previous; gradient values that are used to approximate the Hessian; see the scipy.optimize.fmin_l_bfgs_b documentation for description; of m argument. init_optim(term_conds)[source]Â¶; Check optimiser attribute status and passed parameters before; running the optimisation.; This is called by run_optimization, but could called independently; to check the configuration. run_optimization(term_conds=None)[source]Â¶; Optimise the control pulse amplitudes to minimise the fidelity error; using the L-BFGS-B algorithm, which is the constrained; (bounded amplitude values), limited memory, version of the; BroydenâFletcherâGoldfarbâShanno algorithm.; The optimisation end when one of the passed termination conditions; has been met, e.g. target achieved, gradient minimum met; (local minima), wall time / iteration count exceeded.; Essentially this is wrapper to the:; scipy.optimize.fmin_l_bfgs_b function; This in turn is a warpper for well established implementation of; the L-BFGS-B algorithm written in Fortran, which is therefore; very fast. See SciPy documentation for credit and details on; this function.; If the parameter term_conds=None, then the termination_conditions; attribute must already be set. It will be overwritten if the; parameter is not None; The result is returned in an OptimResult object, which inclu",MatchSource.WIKI,docs/4.3/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/apidoc/classes.html
https://qutip.org/docs/4.3/apidoc/classes.html:78399,Deployability,configurat,configuration,78399,"ablished implementation of; the L-BFGS-B algorithm written in Fortran, which is therefore; very fast. See SciPy documentation for credit and details on; this function.; If the parameter term_conds=None, then the termination_conditions; attribute must already be set. It will be overwritten if the; parameter is not None; The result is returned in an OptimResult object, which includes; the final fidelity, time evolution, reason for termination etc. class OptimizerCrab(config, dyn, params=None)[source]Â¶; Optimises the pulse using the CRAB algorithm [1].; It uses the scipy.optimize.minimize function with the method specified; by the optim_method attribute. See Optimizer.run_optimization for details; It minimises the fidelity error function with respect to the CRAB; basis function coefficients.; AJGP ToDo: Add citation here. init_optim(term_conds)[source]Â¶; Check optimiser attribute status and passed parameters before; running the optimisation.; This is called by run_optimization, but could called independently; to check the configuration. class OptimizerCrabFmin(config, dyn, params=None)[source]Â¶; Optimises the pulse using the CRAB algorithm [1, 2].; It uses the scipy.optimize.fmin function which is effectively a wrapper; for the Nelder-mead method.; It minimises the fidelity error function with respect to the CRAB; basis function coefficients.; This is the default Optimizer for CRAB.; Notes. [1] P. Doria, T. Calarco & S. Montangero. Phys. Rev. Lett. 106,; 190501 (2011). [2] T. Caneva, T. Calarco, & S. Montangero. Phys. Rev. A 84, 022326 (2011). run_optimization(term_conds=None)[source]Â¶; This function optimisation method is a wrapper to the; scipy.optimize.fmin function.; It will attempt to minimise the fidelity error with respect to some; parameters, which are determined by _get_optim_var_vals which; in the case of CRAB are the basis function coefficients; The optimisation end when one of the passed termination conditions; has been met, e.g. target achieved, wall time, ",MatchSource.WIKI,docs/4.3/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/apidoc/classes.html
https://qutip.org/docs/4.3/apidoc/classes.html:85074,Deployability,update,updated,85074,"for small systems at least, the optimisation; performance is much better using ndarrays to represent these operators.; However. Attributes:; log_level : integer; level of messaging output from the logger.; Options are attributes of qutip.logging_utils,; in decreasing levels of messaging, are:; DEBUG_INTENSE, DEBUG_VERBOSE, DEBUG, INFO, WARN, ERROR, CRITICAL; Anything WARN or above is effectively âquietâ execution,; assuming everything runs as expected.; The default NOTSET implies that the level will be taken from; the QuTiP settings file, which by default is WARN. params: Dictionary; The key value pairs are the attribute name and value; Note: attributes are created if they do not exist already,; and are overwritten if they do. stats : Stats; Attributes of which give performance stats for the optimisation; set to None to reduce overhead of calculating stats.; Note it is (usually) shared with the Optimizer object. tslot_computer : TimeslotComputer (subclass instance); Used to manage when the timeslot dynamics; generators, propagators, gradients etc are updated. prop_computer : PropagatorComputer (subclass instance); Used to compute the propagators and their gradients. fid_computer : FidelityComputer (subclass instance); Used to computer the fidelity error and the fidelity error; gradient. memory_optimization : int; Level of memory optimisation. Setting to 0 (default) means that; execution speed is prioritized over memory.; Setting to 1 means that some memory prioritisation steps will be; taken, for instance using Qobj (and hence sparse arrays) as the; the internal operator data type, and not caching some operators; Potentially further memory saving maybe made with; memory_optimization > 1.; The options are processed in _set_memory_optimizations, see; this for more information. Individual memory saving options can be; switched by settting them directly (see below). oper_dtype : type; Data type for internal dynamics generators, propagators and time; evolution operators.",MatchSource.WIKI,docs/4.3/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/apidoc/classes.html
https://qutip.org/docs/4.3/apidoc/classes.html:93551,Deployability,configurat,configuration,93551,"ion operators (Qobj) from the initial to the given; timeslot. get_ctrl_dyn_gen(j)[source]Â¶; Get the dynamics generator for the control; Not implemented in the base class. Choose a subclass. get_drift_dim()[source]Â¶; Returns the size of the matrix that defines the drift dynamics; that is assuming the drift is NxN, then this returns N. get_dyn_gen(k)[source]Â¶; Get the combined dynamics generator for the timeslot; Not implemented in the base class. Choose a subclass. get_num_ctrls()[source]Â¶; calculate the of controls from the length of the control list; sets the num_ctrls property, which can be used alternatively; subsequently. init_timeslots()[source]Â¶; Generate the timeslot duration array âtauâ based on the evo_time; and num_tslots attributes, unless the tau attribute is already set; in which case this step in ignored; Generate the cumulative time array âtimeâ based on the tau values. initialize_controls(amps, init_tslots=True)[source]Â¶; Set the initial control amplitudes and time slices; Note this must be called after the configuration is complete; before any dynamics can be calculated. num_ctrlsÂ¶; calculate the of controls from the length of the control list; sets the num_ctrls property, which can be used alternatively; subsequently. onto_evoÂ¶; List of evolution operators (Qobj) from the initial to the given; timeslot. onwd_evoÂ¶; List of evolution operators (Qobj) from the initial to the given; timeslot. phase_applicationÂ¶; phase_application â scalar(string), default=âpreopâ; Determines how the phase is applied to the dynamics generators. âpreopâ : P = expm(phase*dyn_gen); âpostopâ : P = expm(dyn_gen*phase); âcustomâ : Customised phase application. The âcustomâ option assumes that the _apply_phase method has been; set to a custom function. propÂ¶; List of propagators (Qobj) for each timeslot. prop_gradÂ¶; Array of propagator gradients (Qobj) for each timeslot, control. refresh_drift_attribs()[source]Â¶; Reset the dyn_shape, dyn_dims and time_depend_drift attribs. save",MatchSource.WIKI,docs/4.3/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/apidoc/classes.html
https://qutip.org/docs/4.3/apidoc/classes.html:96913,Deployability,configurat,configuration,96913,"by; unitary matrices. E.g. closed systems with Hermitian Hamiltonians; Note a matrix diagonalisation is used to compute the exponent; The eigen decomposition is also used to calculate the propagator gradient.; The method is taken from DYNAMO (see file header). Attributes:; drift_ham : Qobj; This is the drift Hamiltonian for unitary dynamics; It is mapped to drift_dyn_gen during initialize_controls. ctrl_ham : List of Qobj; These are the control Hamiltonians for unitary dynamics; It is mapped to ctrl_dyn_gen during initialize_controls. H : List of Qobj; The combined drift and control Hamiltonians for each timeslot; These are the dynamics generators for unitary dynamics.; It is mapped to dyn_gen during initialize_controls. check_unitarity()[source]Â¶; Checks whether all propagators are unitary; For propagators found not to be unitary, the potential underlying; causes are investigated. initialize_controls(amplitudes, init_tslots=True)[source]Â¶; Set the initial control amplitudes and time slices; Note this must be called after the configuration is complete; before any dynamics can be calculated. num_ctrlsÂ¶; calculate the of controls from the length of the control list; sets the num_ctrls property, which can be used alternatively; subsequently. class DynamicsSymplectic(optimconfig, params=None)[source]Â¶; Symplectic systems; This is the subclass to use for systems where the dynamics is described; by symplectic matrices, e.g. coupled oscillators, quantum optics. Attributes:; omega : array[drift_dyn_gen.shape]; matrix used in the calculation of propagators (time evolution); with symplectic systems. dyn_gen_phaseÂ¶; The phasing operator for the symplectic group generators; usually refered to as Omega; By default this is applied as âpostopâ dyn_gen*-Omega; If phase_application is âpreopâ it is applied as Omega*dyn_gen. class PropagatorComputer(dynamics, params=None)[source]Â¶; Base for all Propagator Computer classes; that are used to calculate the propagators,; and also the prop",MatchSource.WIKI,docs/4.3/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/apidoc/classes.html
https://qutip.org/docs/4.3/apidoc/classes.html:99177,Deployability,configurat,configuration,99177,"ributes:; log_level : integer; level of messaging output from the logger.; Options are attributes of qutip_utils.logging,; in decreasing levels of messaging, are:; DEBUG_INTENSE, DEBUG_VERBOSE, DEBUG, INFO, WARN, ERROR, CRITICAL; Anything WARN or above is effectively âquietâ execution,; assuming everything runs as expected.; The default NOTSET implies that the level will be taken from; the QuTiP settings file, which by default is WARN. grad_exact : boolean; indicates whether the computer class instance is capable; of computing propagator gradients. It is used to determine; whether to create the Dynamics prop_grad array. apply_params(params=None)[source]Â¶; Set object attributes based on the dictionary (if any) passed in the; instantiation, or passed as a parameter; This is called during the instantiation automatically.; The key value pairs are the attribute name and value; Note: attributes are created if they do not exist already,; and are overwritten if they do. reset()[source]Â¶; reset any configuration data. class PropCompApproxGrad(dynamics, params=None)[source]Â¶; This subclass can be used when the propagator is calculated simply; by expm of the dynamics generator, i.e. when gradients will be calculated; using approximate methods. reset()[source]Â¶; reset any configuration data. class PropCompDiag(dynamics, params=None)[source]Â¶; Coumputes the propagator exponentiation using diagonalisation of; of the dynamics generator. reset()[source]Â¶; reset any configuration data. class PropCompFrechet(dynamics, params=None)[source]Â¶. Frechet method for calculating the propagator:; exponentiating the combined dynamics generator. and the propagator gradient; It should work for all systems, e.g. unitary, open, symplectic; There are other PropagatorComputer subclasses that may be more efficient. reset()[source]Â¶; reset any configuration data. class FidelityComputer(dynamics, params=None)[source]Â¶; Base class for all Fidelity Computers.; This cannot be used directly. See subclass d",MatchSource.WIKI,docs/4.3/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/apidoc/classes.html
https://qutip.org/docs/4.3/apidoc/classes.html:99453,Deployability,configurat,configuration,99453,"execution,; assuming everything runs as expected.; The default NOTSET implies that the level will be taken from; the QuTiP settings file, which by default is WARN. grad_exact : boolean; indicates whether the computer class instance is capable; of computing propagator gradients. It is used to determine; whether to create the Dynamics prop_grad array. apply_params(params=None)[source]Â¶; Set object attributes based on the dictionary (if any) passed in the; instantiation, or passed as a parameter; This is called during the instantiation automatically.; The key value pairs are the attribute name and value; Note: attributes are created if they do not exist already,; and are overwritten if they do. reset()[source]Â¶; reset any configuration data. class PropCompApproxGrad(dynamics, params=None)[source]Â¶; This subclass can be used when the propagator is calculated simply; by expm of the dynamics generator, i.e. when gradients will be calculated; using approximate methods. reset()[source]Â¶; reset any configuration data. class PropCompDiag(dynamics, params=None)[source]Â¶; Coumputes the propagator exponentiation using diagonalisation of; of the dynamics generator. reset()[source]Â¶; reset any configuration data. class PropCompFrechet(dynamics, params=None)[source]Â¶. Frechet method for calculating the propagator:; exponentiating the combined dynamics generator. and the propagator gradient; It should work for all systems, e.g. unitary, open, symplectic; There are other PropagatorComputer subclasses that may be more efficient. reset()[source]Â¶; reset any configuration data. class FidelityComputer(dynamics, params=None)[source]Â¶; Base class for all Fidelity Computers.; This cannot be used directly. See subclass descriptions and choose; one appropriate for the application; Note: this must be instantiated with a Dynamics object, that is the; container for the data that the methods operate on. Attributes:; log_level : integer; level of messaging output from the logger.; Options are attr",MatchSource.WIKI,docs/4.3/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/apidoc/classes.html
https://qutip.org/docs/4.3/apidoc/classes.html:99646,Deployability,configurat,configuration,99646,"es whether the computer class instance is capable; of computing propagator gradients. It is used to determine; whether to create the Dynamics prop_grad array. apply_params(params=None)[source]Â¶; Set object attributes based on the dictionary (if any) passed in the; instantiation, or passed as a parameter; This is called during the instantiation automatically.; The key value pairs are the attribute name and value; Note: attributes are created if they do not exist already,; and are overwritten if they do. reset()[source]Â¶; reset any configuration data. class PropCompApproxGrad(dynamics, params=None)[source]Â¶; This subclass can be used when the propagator is calculated simply; by expm of the dynamics generator, i.e. when gradients will be calculated; using approximate methods. reset()[source]Â¶; reset any configuration data. class PropCompDiag(dynamics, params=None)[source]Â¶; Coumputes the propagator exponentiation using diagonalisation of; of the dynamics generator. reset()[source]Â¶; reset any configuration data. class PropCompFrechet(dynamics, params=None)[source]Â¶. Frechet method for calculating the propagator:; exponentiating the combined dynamics generator. and the propagator gradient; It should work for all systems, e.g. unitary, open, symplectic; There are other PropagatorComputer subclasses that may be more efficient. reset()[source]Â¶; reset any configuration data. class FidelityComputer(dynamics, params=None)[source]Â¶; Base class for all Fidelity Computers.; This cannot be used directly. See subclass descriptions and choose; one appropriate for the application; Note: this must be instantiated with a Dynamics object, that is the; container for the data that the methods operate on. Attributes:; log_level : integer; level of messaging output from the logger.; Options are attributes of qutip.logging_utils,; in decreasing levels of messaging, are:; DEBUG_INTENSE, DEBUG_VERBOSE, DEBUG, INFO, WARN, ERROR, CRITICAL; Anything WARN or above is effectively âquietâ executio",MatchSource.WIKI,docs/4.3/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/apidoc/classes.html
https://qutip.org/docs/4.3/apidoc/classes.html:100012,Deployability,configurat,configuration,100012,"key value pairs are the attribute name and value; Note: attributes are created if they do not exist already,; and are overwritten if they do. reset()[source]Â¶; reset any configuration data. class PropCompApproxGrad(dynamics, params=None)[source]Â¶; This subclass can be used when the propagator is calculated simply; by expm of the dynamics generator, i.e. when gradients will be calculated; using approximate methods. reset()[source]Â¶; reset any configuration data. class PropCompDiag(dynamics, params=None)[source]Â¶; Coumputes the propagator exponentiation using diagonalisation of; of the dynamics generator. reset()[source]Â¶; reset any configuration data. class PropCompFrechet(dynamics, params=None)[source]Â¶. Frechet method for calculating the propagator:; exponentiating the combined dynamics generator. and the propagator gradient; It should work for all systems, e.g. unitary, open, symplectic; There are other PropagatorComputer subclasses that may be more efficient. reset()[source]Â¶; reset any configuration data. class FidelityComputer(dynamics, params=None)[source]Â¶; Base class for all Fidelity Computers.; This cannot be used directly. See subclass descriptions and choose; one appropriate for the application; Note: this must be instantiated with a Dynamics object, that is the; container for the data that the methods operate on. Attributes:; log_level : integer; level of messaging output from the logger.; Options are attributes of qutip.logging_utils,; in decreasing levels of messaging, are:; DEBUG_INTENSE, DEBUG_VERBOSE, DEBUG, INFO, WARN, ERROR, CRITICAL; Anything WARN or above is effectively âquietâ execution,; assuming everything runs as expected.; The default NOTSET implies that the level will be taken from; the QuTiP settings file, which by default is WARN. dimensional_norm : float; Normalisation constant. fid_norm_func : function; Used to normalise the fidelity; See SU and PSU options for the unitary dynamics. grad_norm_func : function; Used to normalise the fide",MatchSource.WIKI,docs/4.3/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/apidoc/classes.html
https://qutip.org/docs/4.3/apidoc/classes.html:102829,Deployability,configurat,configuration,102829,"lity error gradients; (sqrt of the sum of the squares). fid_err_grad_current : boolean; flag to specify whether the fidelity / fid_err are based on the; current amplitude values. Set False when amplitudes change. apply_params(params=None)[source]Â¶; Set object attributes based on the dictionary (if any) passed in the; instantiation, or passed as a parameter; This is called during the instantiation automatically.; The key value pairs are the attribute name and value; Note: attributes are created if they do not exist already,; and are overwritten if they do. clear()[source]Â¶; clear any temporarily held status data. flag_system_changed()[source]Â¶; Flag fidelity and gradients as needing recalculation. get_fid_err()[source]Â¶; returns the absolute distance from the maximum achievable fidelity. get_fid_err_gradient()[source]Â¶; Returns the normalised gradient of the fidelity error; in a (nTimeslots x n_ctrls) array wrt the timeslot control amplitude. init_comp()[source]Â¶; initialises the computer based on the configuration of the Dynamics. reset()[source]Â¶; reset any configuration data and; clear any temporarily held status data. class FidCompUnitary(dynamics, params=None)[source]Â¶; Computes fidelity error and gradient assuming unitary dynamics, e.g.; closed qubit systems; Note fidelity and gradient calculations were taken from DYNAMO; (see file header). Attributes:; phase_option : string. determines how global phase is treated in fidelity calculations:; PSU - global phase ignored; SU - global phase included. fidelity_prenorm : complex; Last computed value of the fidelity before it is normalised; It is stored to use in the gradient normalisation calculation. fidelity_prenorm_current : boolean; flag to specify whether fidelity_prenorm are based on the; current amplitude values. Set False when amplitudes change. clear()[source]Â¶; clear any temporarily held status data. compute_fid_grad()[source]Â¶; Calculates exact gradient of function wrt to each timeslot; control amplitudes. N",MatchSource.WIKI,docs/4.3/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/apidoc/classes.html
https://qutip.org/docs/4.3/apidoc/classes.html:102888,Deployability,configurat,configuration,102888," to specify whether the fidelity / fid_err are based on the; current amplitude values. Set False when amplitudes change. apply_params(params=None)[source]Â¶; Set object attributes based on the dictionary (if any) passed in the; instantiation, or passed as a parameter; This is called during the instantiation automatically.; The key value pairs are the attribute name and value; Note: attributes are created if they do not exist already,; and are overwritten if they do. clear()[source]Â¶; clear any temporarily held status data. flag_system_changed()[source]Â¶; Flag fidelity and gradients as needing recalculation. get_fid_err()[source]Â¶; returns the absolute distance from the maximum achievable fidelity. get_fid_err_gradient()[source]Â¶; Returns the normalised gradient of the fidelity error; in a (nTimeslots x n_ctrls) array wrt the timeslot control amplitude. init_comp()[source]Â¶; initialises the computer based on the configuration of the Dynamics. reset()[source]Â¶; reset any configuration data and; clear any temporarily held status data. class FidCompUnitary(dynamics, params=None)[source]Â¶; Computes fidelity error and gradient assuming unitary dynamics, e.g.; closed qubit systems; Note fidelity and gradient calculations were taken from DYNAMO; (see file header). Attributes:; phase_option : string. determines how global phase is treated in fidelity calculations:; PSU - global phase ignored; SU - global phase included. fidelity_prenorm : complex; Last computed value of the fidelity before it is normalised; It is stored to use in the gradient normalisation calculation. fidelity_prenorm_current : boolean; flag to specify whether fidelity_prenorm are based on the; current amplitude values. Set False when amplitudes change. clear()[source]Â¶; clear any temporarily held status data. compute_fid_grad()[source]Â¶; Calculates exact gradient of function wrt to each timeslot; control amplitudes. Note these gradients are not normalised; These are returned as a (nTimeslots x n_ctrls) arra",MatchSource.WIKI,docs/4.3/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/apidoc/classes.html
https://qutip.org/docs/4.3/apidoc/classes.html:104266,Deployability,update,updates,104266,":; phase_option : string. determines how global phase is treated in fidelity calculations:; PSU - global phase ignored; SU - global phase included. fidelity_prenorm : complex; Last computed value of the fidelity before it is normalised; It is stored to use in the gradient normalisation calculation. fidelity_prenorm_current : boolean; flag to specify whether fidelity_prenorm are based on the; current amplitude values. Set False when amplitudes change. clear()[source]Â¶; clear any temporarily held status data. compute_fid_grad()[source]Â¶; Calculates exact gradient of function wrt to each timeslot; control amplitudes. Note these gradients are not normalised; These are returned as a (nTimeslots x n_ctrls) array. flag_system_changed()[source]Â¶; Flag fidelity and gradients as needing recalculation. get_fid_err()[source]Â¶; Gets the absolute error in the fidelity. get_fid_err_gradient()[source]Â¶; Returns the normalised gradient of the fidelity error; in a (nTimeslots x n_ctrls) array; The gradients are cached in case they are requested; mutliple times between control updates; (although this is not typically found to happen). get_fidelity()[source]Â¶; Gets the appropriately normalised fidelity value; The normalisation is determined by the fid_norm_func pointer; which should be set in the config. get_fidelity_prenorm()[source]Â¶; Gets the current fidelity value prior to normalisation; Note the gradient function uses this value; The value is cached, because it is used in the gradient calculation. init_comp()[source]Â¶; Check configuration and initialise the normalisation. init_normalization()[source]Â¶; Calc norm of <Ufinal | Ufinal> to scale subsequent norms; When considering unitary time evolution operators, this basically; results in calculating the trace of the identity matrix; and is hence equal to the size of the target matrix; There may be situations where this is not the case, and hence it; is not assumed to be so.; The normalisation function called should be set to either ",MatchSource.WIKI,docs/4.3/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/apidoc/classes.html
https://qutip.org/docs/4.3/apidoc/classes.html:104727,Deployability,configurat,configuration,104727,"culates exact gradient of function wrt to each timeslot; control amplitudes. Note these gradients are not normalised; These are returned as a (nTimeslots x n_ctrls) array. flag_system_changed()[source]Â¶; Flag fidelity and gradients as needing recalculation. get_fid_err()[source]Â¶; Gets the absolute error in the fidelity. get_fid_err_gradient()[source]Â¶; Returns the normalised gradient of the fidelity error; in a (nTimeslots x n_ctrls) array; The gradients are cached in case they are requested; mutliple times between control updates; (although this is not typically found to happen). get_fidelity()[source]Â¶; Gets the appropriately normalised fidelity value; The normalisation is determined by the fid_norm_func pointer; which should be set in the config. get_fidelity_prenorm()[source]Â¶; Gets the current fidelity value prior to normalisation; Note the gradient function uses this value; The value is cached, because it is used in the gradient calculation. init_comp()[source]Â¶; Check configuration and initialise the normalisation. init_normalization()[source]Â¶; Calc norm of <Ufinal | Ufinal> to scale subsequent norms; When considering unitary time evolution operators, this basically; results in calculating the trace of the identity matrix; and is hence equal to the size of the target matrix; There may be situations where this is not the case, and hence it; is not assumed to be so.; The normalisation function called should be set to either the; PSU - global phase ignored; SU - global phase respected. normalize_PSU(A)[source]Â¶. normalize_SU(A)[source]Â¶. normalize_gradient_PSU(grad)[source]Â¶; Normalise the gradient matrix passed as grad; This PSU version is independent of global phase. normalize_gradient_SU(grad)[source]Â¶; Normalise the gradient matrix passed as grad; This SU version respects global phase. reset()[source]Â¶; reset any configuration data and; clear any temporarily held status data. set_phase_option(phase_option=None)[source]Â¶; Deprecated - use phase_option; Phas",MatchSource.WIKI,docs/4.3/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/apidoc/classes.html
https://qutip.org/docs/4.3/apidoc/classes.html:105591,Deployability,configurat,configuration,105591,"tion uses this value; The value is cached, because it is used in the gradient calculation. init_comp()[source]Â¶; Check configuration and initialise the normalisation. init_normalization()[source]Â¶; Calc norm of <Ufinal | Ufinal> to scale subsequent norms; When considering unitary time evolution operators, this basically; results in calculating the trace of the identity matrix; and is hence equal to the size of the target matrix; There may be situations where this is not the case, and hence it; is not assumed to be so.; The normalisation function called should be set to either the; PSU - global phase ignored; SU - global phase respected. normalize_PSU(A)[source]Â¶. normalize_SU(A)[source]Â¶. normalize_gradient_PSU(grad)[source]Â¶; Normalise the gradient matrix passed as grad; This PSU version is independent of global phase. normalize_gradient_SU(grad)[source]Â¶; Normalise the gradient matrix passed as grad; This SU version respects global phase. reset()[source]Â¶; reset any configuration data and; clear any temporarily held status data. set_phase_option(phase_option=None)[source]Â¶; Deprecated - use phase_option; Phase options are; SU - global phase important; PSU - global phase is not important. class FidCompTraceDiff(dynamics, params=None)[source]Â¶; Computes fidelity error and gradient for general system dynamics; by calculating the the fidelity error as the trace of the overlap; of the difference between the target and evolution resulting from; the pulses with the transpose of the same.; This should provide a distance measure for dynamics described by matrices; Note the gradient calculation is taken from:; âRobust quantum gates for open systems via optimal control:; Markovian versus non-Markovian dynamicsâ; Frederik F Floether, Pierre de Fouquieres, and Sophie G Schirmer. Attributes:; scale_factor : float; The fidelity error calculated is of some arbitary scale. This; factor can be used to scale the fidelity error such that it may; represent some physical measure; If No",MatchSource.WIKI,docs/4.3/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/apidoc/classes.html
https://qutip.org/docs/4.3/apidoc/classes.html:107224,Deployability,update,updates,107224,"easure for dynamics described by matrices; Note the gradient calculation is taken from:; âRobust quantum gates for open systems via optimal control:; Markovian versus non-Markovian dynamicsâ; Frederik F Floether, Pierre de Fouquieres, and Sophie G Schirmer. Attributes:; scale_factor : float; The fidelity error calculated is of some arbitary scale. This; factor can be used to scale the fidelity error such that it may; represent some physical measure; If None is given then it is caculated as 1/2N, where N; is the dimension of the drift, when the Dynamics are initialised. compute_fid_err_grad()[source]Â¶; Calculate exact gradient of the fidelity error function; wrt to each timeslot control amplitudes.; Uses the trace difference norm fidelity; These are returned as a (nTimeslots x n_ctrls) array. get_fid_err()[source]Â¶; Gets the absolute error in the fidelity. get_fid_err_gradient()[source]Â¶; Returns the normalised gradient of the fidelity error; in a (nTimeslots x n_ctrls) array; The gradients are cached in case they are requested; mutliple times between control updates; (although this is not typically found to happen). init_comp()[source]Â¶; initialises the computer based on the configuration of the Dynamics; Calculates the scale_factor is not already set. reset()[source]Â¶; reset any configuration data and; clear any temporarily held status data. class FidCompTraceDiffApprox(dynamics, params=None)[source]Â¶; As FidCompTraceDiff, except uses the finite difference method to; compute approximate gradients. Attributes:; epsilon : float; control amplitude offset to use when approximating the gradient wrt; a timeslot control amplitude. compute_fid_err_grad()[source]Â¶; Calculates gradient of function wrt to each timeslot; control amplitudes. Note these gradients are not normalised; They are calulated; These are returned as a (nTimeslots x n_ctrls) array. reset()[source]Â¶; reset any configuration data and; clear any temporarily held status data. class TimeslotComputer(dynamics, ",MatchSource.WIKI,docs/4.3/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/apidoc/classes.html
https://qutip.org/docs/4.3/apidoc/classes.html:107343,Deployability,configurat,configuration,107343," Floether, Pierre de Fouquieres, and Sophie G Schirmer. Attributes:; scale_factor : float; The fidelity error calculated is of some arbitary scale. This; factor can be used to scale the fidelity error such that it may; represent some physical measure; If None is given then it is caculated as 1/2N, where N; is the dimension of the drift, when the Dynamics are initialised. compute_fid_err_grad()[source]Â¶; Calculate exact gradient of the fidelity error function; wrt to each timeslot control amplitudes.; Uses the trace difference norm fidelity; These are returned as a (nTimeslots x n_ctrls) array. get_fid_err()[source]Â¶; Gets the absolute error in the fidelity. get_fid_err_gradient()[source]Â¶; Returns the normalised gradient of the fidelity error; in a (nTimeslots x n_ctrls) array; The gradients are cached in case they are requested; mutliple times between control updates; (although this is not typically found to happen). init_comp()[source]Â¶; initialises the computer based on the configuration of the Dynamics; Calculates the scale_factor is not already set. reset()[source]Â¶; reset any configuration data and; clear any temporarily held status data. class FidCompTraceDiffApprox(dynamics, params=None)[source]Â¶; As FidCompTraceDiff, except uses the finite difference method to; compute approximate gradients. Attributes:; epsilon : float; control amplitude offset to use when approximating the gradient wrt; a timeslot control amplitude. compute_fid_err_grad()[source]Â¶; Calculates gradient of function wrt to each timeslot; control amplitudes. Note these gradients are not normalised; They are calulated; These are returned as a (nTimeslots x n_ctrls) array. reset()[source]Â¶; reset any configuration data and; clear any temporarily held status data. class TimeslotComputer(dynamics, params=None)[source]Â¶; Base class for all Timeslot Computers; Note: this must be instantiated with a Dynamics object, that is the; container for the data that the methods operate on. Attributes:; log_lev",MatchSource.WIKI,docs/4.3/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/apidoc/classes.html
https://qutip.org/docs/4.3/apidoc/classes.html:107450,Deployability,configurat,configuration,107450,"ated is of some arbitary scale. This; factor can be used to scale the fidelity error such that it may; represent some physical measure; If None is given then it is caculated as 1/2N, where N; is the dimension of the drift, when the Dynamics are initialised. compute_fid_err_grad()[source]Â¶; Calculate exact gradient of the fidelity error function; wrt to each timeslot control amplitudes.; Uses the trace difference norm fidelity; These are returned as a (nTimeslots x n_ctrls) array. get_fid_err()[source]Â¶; Gets the absolute error in the fidelity. get_fid_err_gradient()[source]Â¶; Returns the normalised gradient of the fidelity error; in a (nTimeslots x n_ctrls) array; The gradients are cached in case they are requested; mutliple times between control updates; (although this is not typically found to happen). init_comp()[source]Â¶; initialises the computer based on the configuration of the Dynamics; Calculates the scale_factor is not already set. reset()[source]Â¶; reset any configuration data and; clear any temporarily held status data. class FidCompTraceDiffApprox(dynamics, params=None)[source]Â¶; As FidCompTraceDiff, except uses the finite difference method to; compute approximate gradients. Attributes:; epsilon : float; control amplitude offset to use when approximating the gradient wrt; a timeslot control amplitude. compute_fid_err_grad()[source]Â¶; Calculates gradient of function wrt to each timeslot; control amplitudes. Note these gradients are not normalised; They are calulated; These are returned as a (nTimeslots x n_ctrls) array. reset()[source]Â¶; reset any configuration data and; clear any temporarily held status data. class TimeslotComputer(dynamics, params=None)[source]Â¶; Base class for all Timeslot Computers; Note: this must be instantiated with a Dynamics object, that is the; container for the data that the methods operate on. Attributes:; log_level : integer; level of messaging output from the logger.; Options are attributes of qutip.logging_utils,; in decrea",MatchSource.WIKI,docs/4.3/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/apidoc/classes.html
https://qutip.org/docs/4.3/apidoc/classes.html:108052,Deployability,configurat,configuration,108052,"sed gradient of the fidelity error; in a (nTimeslots x n_ctrls) array; The gradients are cached in case they are requested; mutliple times between control updates; (although this is not typically found to happen). init_comp()[source]Â¶; initialises the computer based on the configuration of the Dynamics; Calculates the scale_factor is not already set. reset()[source]Â¶; reset any configuration data and; clear any temporarily held status data. class FidCompTraceDiffApprox(dynamics, params=None)[source]Â¶; As FidCompTraceDiff, except uses the finite difference method to; compute approximate gradients. Attributes:; epsilon : float; control amplitude offset to use when approximating the gradient wrt; a timeslot control amplitude. compute_fid_err_grad()[source]Â¶; Calculates gradient of function wrt to each timeslot; control amplitudes. Note these gradients are not normalised; They are calulated; These are returned as a (nTimeslots x n_ctrls) array. reset()[source]Â¶; reset any configuration data and; clear any temporarily held status data. class TimeslotComputer(dynamics, params=None)[source]Â¶; Base class for all Timeslot Computers; Note: this must be instantiated with a Dynamics object, that is the; container for the data that the methods operate on. Attributes:; log_level : integer; level of messaging output from the logger.; Options are attributes of qutip.logging_utils,; in decreasing levels of messaging, are:; DEBUG_INTENSE, DEBUG_VERBOSE, DEBUG, INFO, WARN, ERROR, CRITICAL; Anything WARN or above is effectively âquietâ execution,; assuming everything runs as expected.; The default NOTSET implies that the level will be taken from; the QuTiP settings file, which by default is WARN. evo_comp_summary : EvoCompSummary; A summary of the most recent evolution computation; Used in the stats and dump; Will be set to None if neither stats or dump are set. apply_params(params=None)[source]Â¶; Set object attributes based on the dictionary (if any) passed in the; instantiation, or p",MatchSource.WIKI,docs/4.3/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/apidoc/classes.html
https://qutip.org/docs/4.3/apidoc/classes.html:109538,Deployability,update,updated,109538,"ls,; in decreasing levels of messaging, are:; DEBUG_INTENSE, DEBUG_VERBOSE, DEBUG, INFO, WARN, ERROR, CRITICAL; Anything WARN or above is effectively âquietâ execution,; assuming everything runs as expected.; The default NOTSET implies that the level will be taken from; the QuTiP settings file, which by default is WARN. evo_comp_summary : EvoCompSummary; A summary of the most recent evolution computation; Used in the stats and dump; Will be set to None if neither stats or dump are set. apply_params(params=None)[source]Â¶; Set object attributes based on the dictionary (if any) passed in the; instantiation, or passed as a parameter; This is called during the instantiation automatically.; The key value pairs are the attribute name and value; Note: attributes are created if they do not exist already,; and are overwritten if they do. dump_current()[source]Â¶; Store a copy of the current time evolution. class TSlotCompUpdateAll(dynamics, params=None)[source]Â¶; Timeslot Computer - Update All; Updates all dynamics generators, propagators and evolutions when; ctrl amplitudes are updated. compare_amps(new_amps)[source]Â¶; Determine if any amplitudes have changed. If so, then mark the; timeslots as needing recalculation; Returns: True if amplitudes are the same, False if they have changed. get_timeslot_for_fidelity_calc()[source]Â¶; Returns the timeslot index that will be used calculate current fidelity; value.; This (default) method simply returns the last timeslot. recompute_evolution()[source]Â¶; Recalculates the evolution operators.; Dynamics generators (e.g. Hamiltonian) and; prop (propagators) are calculated as necessary. class PulseGen(dyn=None, params=None)[source]Â¶; Pulse generator; Base class for all Pulse generators; The object can optionally be instantiated with a Dynamics object,; in which case the timeslots and amplitude scaling and offset; are copied from that.; Otherwise the class can be used independently by setting:; tau (array of timeslot durations); or; num_tslot",MatchSource.WIKI,docs/4.3/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/apidoc/classes.html
https://qutip.org/docs/4.3/apidoc/classes.html:120283,Deployability,configurat,configurations,120283,"on method; Typically this will be the basis coefficients. class PulseGenCrabFourier(dyn=None, num_coeffs=None, params=None)[source]Â¶; Generates a pulse using the Fourier basis functions, i.e. sin and cos. Attributes:; freqs : float array[num_coeffs]; Frequencies for the basis functions. randomize_freqs : bool; If True (default) the some random offset is applied to the frequencies. gen_pulse(coeffs=None)[source]Â¶; Generate a pulse using the Fourier basis with the freqs and; coeffs attributes. Parameters:; coeffs : float array[num_coeffs, num_basis_funcs]; The basis coefficient values; If given this overides the default and sets the attribute; of the same name. init_freqs()[source]Â¶; Generate the frequencies; These are the Fourier harmonics with a uniformly distributed; random offset. init_pulse(num_coeffs=None)[source]Â¶; Set the initial freq and coefficient values. reset()[source]Â¶; reset attributes to default values. class Stats[source]Â¶; Base class for all optimisation statistics; Used for configurations where all timeslots are updated each iteration; e.g. exact gradients; Note that all times are generated using timeit.default_timer() and are; in seconds. Attributes:; dyn_gen_name : string; Text used in some report functions.; Makes sense to set it to âHamiltonianâ when using unitary dynamics; Default is simply âdynamics generatorâ. num_iter : integer; Number of iterations of the optimisation algorithm. wall_time_optim_start : float; Start time for the optimisation. wall_time_optim_end : float; End time for the optimisation. wall_time_optim : float; Time elasped during the optimisation. wall_time_dyn_gen_compute : float; Total wall (elasped) time computing combined dynamics generator; (for example combining drift and control Hamiltonians). wall_time_prop_compute : float; Total wall (elasped) time computing propagators, that is the; time evolution from one timeslot to the next; Includes calculating the propagator gradient for exact gradients. wall_time_fwd_prop_compu",MatchSource.WIKI,docs/4.3/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/apidoc/classes.html
https://qutip.org/docs/4.3/apidoc/classes.html:120322,Deployability,update,updated,120322,"on method; Typically this will be the basis coefficients. class PulseGenCrabFourier(dyn=None, num_coeffs=None, params=None)[source]Â¶; Generates a pulse using the Fourier basis functions, i.e. sin and cos. Attributes:; freqs : float array[num_coeffs]; Frequencies for the basis functions. randomize_freqs : bool; If True (default) the some random offset is applied to the frequencies. gen_pulse(coeffs=None)[source]Â¶; Generate a pulse using the Fourier basis with the freqs and; coeffs attributes. Parameters:; coeffs : float array[num_coeffs, num_basis_funcs]; The basis coefficient values; If given this overides the default and sets the attribute; of the same name. init_freqs()[source]Â¶; Generate the frequencies; These are the Fourier harmonics with a uniformly distributed; random offset. init_pulse(num_coeffs=None)[source]Â¶; Set the initial freq and coefficient values. reset()[source]Â¶; reset attributes to default values. class Stats[source]Â¶; Base class for all optimisation statistics; Used for configurations where all timeslots are updated each iteration; e.g. exact gradients; Note that all times are generated using timeit.default_timer() and are; in seconds. Attributes:; dyn_gen_name : string; Text used in some report functions.; Makes sense to set it to âHamiltonianâ when using unitary dynamics; Default is simply âdynamics generatorâ. num_iter : integer; Number of iterations of the optimisation algorithm. wall_time_optim_start : float; Start time for the optimisation. wall_time_optim_end : float; End time for the optimisation. wall_time_optim : float; Time elasped during the optimisation. wall_time_dyn_gen_compute : float; Total wall (elasped) time computing combined dynamics generator; (for example combining drift and control Hamiltonians). wall_time_prop_compute : float; Total wall (elasped) time computing propagators, that is the; time evolution from one timeslot to the next; Includes calculating the propagator gradient for exact gradients. wall_time_fwd_prop_compu",MatchSource.WIKI,docs/4.3/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/apidoc/classes.html
https://qutip.org/docs/4.3/apidoc/classes.html:122585,Deployability,update,updated,122585,"ned onward propagation,; that is the time evolution from a specific timeslot to the end time.; Excludes calculating the propagators themselves. wall_time_gradient_compute : float; Total wall (elasped) time computing the fidelity error gradient.; Excludes calculating the propagator gradients (in exact gradient; methods). num_fidelity_func_calls : integer; Number of calls to fidelity function by the optimisation algorithm. num_grad_func_calls : integer; Number of calls to gradient function by the optimisation algorithm. num_tslot_recompute : integer; Number of time the timeslot evolution is recomputed; (It is only computed if any amplitudes changed since the last call). num_fidelity_computes : integer; Number of time the fidelity is computed; (It is only computed if any amplitudes changed since the last call). num_grad_computes : integer; Number of time the gradient is computed; (It is only computed if any amplitudes changed since the last call). num_ctrl_amp_updates : integer; Number of times the control amplitudes are updated. mean_num_ctrl_amp_updates_per_iter : float; Mean number of control amplitude updates per iteration. num_timeslot_changes : integer; Number of times the amplitudes of a any control in a timeslot changes. mean_num_timeslot_changes_per_update : float; Mean average number of timeslot amplitudes that are changed per update. num_ctrl_amp_changes : integer; Number of times individual control amplitudes that are changed. mean_num_ctrl_amp_changes_per_update : float; Mean average number of control amplitudes that are changed per update. calculate()[source]Â¶; Perform the calculations (e.g. averages) that are required on the stats; Should be called before calling report. report()[source]Â¶; Print a report of the stats to the console. class Dump[source]Â¶; A container for dump items.; The lists for dump items is depends on the type; Note: abstract class. Attributes:; parent : some control object (Dynamics or Optimizer); aka the host. Object that generates t",MatchSource.WIKI,docs/4.3/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/apidoc/classes.html
https://qutip.org/docs/4.3/apidoc/classes.html:122671,Deployability,update,updates,122671,.; Excludes calculating the propagators themselves. wall_time_gradient_compute : float; Total wall (elasped) time computing the fidelity error gradient.; Excludes calculating the propagator gradients (in exact gradient; methods). num_fidelity_func_calls : integer; Number of calls to fidelity function by the optimisation algorithm. num_grad_func_calls : integer; Number of calls to gradient function by the optimisation algorithm. num_tslot_recompute : integer; Number of time the timeslot evolution is recomputed; (It is only computed if any amplitudes changed since the last call). num_fidelity_computes : integer; Number of time the fidelity is computed; (It is only computed if any amplitudes changed since the last call). num_grad_computes : integer; Number of time the gradient is computed; (It is only computed if any amplitudes changed since the last call). num_ctrl_amp_updates : integer; Number of times the control amplitudes are updated. mean_num_ctrl_amp_updates_per_iter : float; Mean number of control amplitude updates per iteration. num_timeslot_changes : integer; Number of times the amplitudes of a any control in a timeslot changes. mean_num_timeslot_changes_per_update : float; Mean average number of timeslot amplitudes that are changed per update. num_ctrl_amp_changes : integer; Number of times individual control amplitudes that are changed. mean_num_ctrl_amp_changes_per_update : float; Mean average number of control amplitudes that are changed per update. calculate()[source]Â¶; Perform the calculations (e.g. averages) that are required on the stats; Should be called before calling report. report()[source]Â¶; Print a report of the stats to the console. class Dump[source]Â¶; A container for dump items.; The lists for dump items is depends on the type; Note: abstract class. Attributes:; parent : some control object (Dynamics or Optimizer); aka the host. Object that generates the data that is dumped and is; host to this dump object. dump_dir : str; directory where fil,MatchSource.WIKI,docs/4.3/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/apidoc/classes.html
https://qutip.org/docs/4.3/apidoc/classes.html:122907,Deployability,update,update,122907,adient; methods). num_fidelity_func_calls : integer; Number of calls to fidelity function by the optimisation algorithm. num_grad_func_calls : integer; Number of calls to gradient function by the optimisation algorithm. num_tslot_recompute : integer; Number of time the timeslot evolution is recomputed; (It is only computed if any amplitudes changed since the last call). num_fidelity_computes : integer; Number of time the fidelity is computed; (It is only computed if any amplitudes changed since the last call). num_grad_computes : integer; Number of time the gradient is computed; (It is only computed if any amplitudes changed since the last call). num_ctrl_amp_updates : integer; Number of times the control amplitudes are updated. mean_num_ctrl_amp_updates_per_iter : float; Mean number of control amplitude updates per iteration. num_timeslot_changes : integer; Number of times the amplitudes of a any control in a timeslot changes. mean_num_timeslot_changes_per_update : float; Mean average number of timeslot amplitudes that are changed per update. num_ctrl_amp_changes : integer; Number of times individual control amplitudes that are changed. mean_num_ctrl_amp_changes_per_update : float; Mean average number of control amplitudes that are changed per update. calculate()[source]Â¶; Perform the calculations (e.g. averages) that are required on the stats; Should be called before calling report. report()[source]Â¶; Print a report of the stats to the console. class Dump[source]Â¶; A container for dump items.; The lists for dump items is depends on the type; Note: abstract class. Attributes:; parent : some control object (Dynamics or Optimizer); aka the host. Object that generates the data that is dumped and is; host to this dump object. dump_dir : str; directory where files (if any) will be written out; the path and be relative or absolute; use ~/ to specify user home directory; Note: files are only written when write_to_file is True; of writeout is called explicitly; Defaults to,MatchSource.WIKI,docs/4.3/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/apidoc/classes.html
https://qutip.org/docs/4.3/apidoc/classes.html:123120,Deployability,update,update,123120,rithm. num_tslot_recompute : integer; Number of time the timeslot evolution is recomputed; (It is only computed if any amplitudes changed since the last call). num_fidelity_computes : integer; Number of time the fidelity is computed; (It is only computed if any amplitudes changed since the last call). num_grad_computes : integer; Number of time the gradient is computed; (It is only computed if any amplitudes changed since the last call). num_ctrl_amp_updates : integer; Number of times the control amplitudes are updated. mean_num_ctrl_amp_updates_per_iter : float; Mean number of control amplitude updates per iteration. num_timeslot_changes : integer; Number of times the amplitudes of a any control in a timeslot changes. mean_num_timeslot_changes_per_update : float; Mean average number of timeslot amplitudes that are changed per update. num_ctrl_amp_changes : integer; Number of times individual control amplitudes that are changed. mean_num_ctrl_amp_changes_per_update : float; Mean average number of control amplitudes that are changed per update. calculate()[source]Â¶; Perform the calculations (e.g. averages) that are required on the stats; Should be called before calling report. report()[source]Â¶; Print a report of the stats to the console. class Dump[source]Â¶; A container for dump items.; The lists for dump items is depends on the type; Note: abstract class. Attributes:; parent : some control object (Dynamics or Optimizer); aka the host. Object that generates the data that is dumped and is; host to this dump object. dump_dir : str; directory where files (if any) will be written out; the path and be relative or absolute; use ~/ to specify user home directory; Note: files are only written when write_to_file is True; of writeout is called explicitly; Defaults to ~/.qtrl_dump. level : string; The level of data dumping that will occur - SUMMARY : A summary will be recorded - FULL : All possible dumping - CUSTOM : Some customised level of dumping When first set to CUSTOM thi,MatchSource.WIKI,docs/4.3/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/apidoc/classes.html
https://qutip.org/docs/4.3/apidoc/classes.html:129305,Deployability,update,updated,129305,"o : bool; If True forward evolution operators are dumped. dump_onwd_evo : bool; If True onward evolution operators are dumped. dump_onto_evo : bool; If True onto (or backward) evolution operators are dumped. evo_dumps : list of EvoCompDumpItem; A new dump item is appended at each recomputation of the evolution.; That is if any of the calculation objects are to be dumped. add_evo_comp_summary(dump_item_idx=None)[source]Â¶; add copy of current evo comp summary. add_evo_dump()[source]Â¶; Add dump of current time evolution generating objects. dump_allÂ¶; True if all of the calculation objects are to be dumped. dump_anyÂ¶; True if any of the calculation objects are to be dumped. writeout(f=None)[source]Â¶; write all the dump items and the summary out to file(s); :param f: If specified then all summary and object data will go in one file. If None is specified then type specific files will be generated; in the dump_dir; If a filehandle is specified then it must be a byte mode file; as numpy.savetxt is used, and requires this. class DumpItem[source]Â¶; An item in a dump list. class EvoCompDumpItem(dump)[source]Â¶; A copy of all objects generated to calculate one time evolution; Note the attributes are only set if the corresponding; DynamicsDump dump_ attribute is set. writeout(f=None)[source]Â¶; write all the objects out to files. Parameters:; f : filename or filehandle; If specified then all object data will go in one file.; If None is specified then type specific files will be generated; in the dump_dir; If a filehandle is specified then it must be a byte mode file; as numpy.savetxt is used, and requires this. class DumpSummaryItem[source]Â¶; A summary of the most recent iteration; Abstract class only; Attributes:; idx : int. Index in the summary list in which this is stored. Previous. Â© Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, and A.L. Grimsmo; Last updated on Feb 26, 2019. . Built with Sphinx using a theme provided by Read the Docs. . ",MatchSource.WIKI,docs/4.3/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/apidoc/classes.html
https://qutip.org/docs/4.3/apidoc/classes.html:12781,Energy Efficiency,efficient,efficient,12781,"envalue solver for trace norm. Other norms are not; affected by this parameter. tol : float; Tolerance for sparse solver (if used) for trace norm. The sparse; solver may not converge if the tolerance is set too low. maxiter : int; Maximum number of iterations performed by sparse solver (if used); for trace norm. Returns:; norm : float; The requested norm of the operator or state quantum object. Notes; The sparse eigensolver is much slower than the dense version.; Use sparse only if memory requirements demand it. overlap(other)[source]Â¶; Overlap between two state vectors.; Gives the overlap (inner product) between the current bra or ket Qobj; and and another bra or ket Qobj. Parameters:; other : qobj; Quantum object for a state vector of type âketâ or âbraâ. Returns:; overlap : complex; Complex valued overlap. Raises:; TypeError; Can only calculate overlap between a bra and ket quantum objects. Notes; Since QuTiP mainly deals with ket vectors, the most efficient inner product; call is the ket-ket version that computes the product <self|other> with; both vectors expressed as kets. permute(order)[source]Â¶; Permutes a composite quantum object. Parameters:; order : list/array; List specifying new tensor order. Returns:; P : qobj; Permuted quantum object. proj()[source]Â¶; Form the projector from a given ket or bra vector. Parameters:; Q : Qobj; Input bra or ket vector. Returns:; P : Qobj; Projection operator. ptrace(sel)[source]Â¶; Partial trace of the quantum object. Parameters:; sel : int/list; An int or list of components to keep after partial trace. Returns:; oper : qobj; Quantum object representing partial trace with selected components; remaining. Notes; This function is identical to the qutip.qobj.ptrace function; that has been deprecated. sinm()[source]Â¶; Sine of a quantum operator.; Operator must be square. Returns:; oper : qobj; Matrix sine of operator. Raises:; TypeError; Quantum object is not square. Notes; Uses the Q.expm() method. sqrtm(sparse=False, tol=0, ma",MatchSource.WIKI,docs/4.3/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/apidoc/classes.html
https://qutip.org/docs/4.3/apidoc/classes.html:24733,Energy Efficiency,reduce,reduced,24733,"ms where the bath; correlations can be approximated to a sum of complex eponentials.; The method builds a matrix of linked differential equations, which are; then solved used the same ODE solvers as other qutip solvers (e.g. mesolve); This class should be treated as abstract. Currently the only subclass; implemented is that for the Drude-Lorentz spectral density. This covers; the majority of the work that has been done using this model, and there; are some performance advantages to assuming this model where it is; appropriate.; There are opportunities to develop a more general spectral density code. Attributes:; H_sys : Qobj; System Hamiltonian. coup_op : Qobj; Operator describing the coupling between system and bath. coup_strength : float; Coupling strength. temperature : float; Bath temperature, in units corresponding to planck. N_cut : int; Cutoff parameter for the bath. N_exp : int; Number of exponential terms used to approximate the bath correlation; functions. planck : float; reduced Planck constant. boltzmann : float; Boltzmannâs constant. options : qutip.solver.Options; Generic solver options.; If set to None the default options will be used. progress_bar: BaseProgressBar; Optional instance of BaseProgressBar, or a subclass thereof, for; showing the progress of the simulation. stats : qutip.solver.Stats; optional container for holding performance statitics; If None is set, then statistics are not collected; There may be an overhead in collecting statistics. exp_coeff : list of complex; Coefficients for the exponential series terms. exp_freq : list of complex; Frequencies for the exponential series terms. configure(H_sys, coup_op, coup_strength, temperature, N_cut, N_exp, planck=None, boltzmann=None, renorm=None, bnd_cut_approx=None, options=None, progress_bar=None, stats=None)[source]Â¶; Configure the solver using the passed parameters; The parameters are described in the class attributes, unless there; is some specific behaviour. Parameters:; options : qutip.",MatchSource.WIKI,docs/4.3/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/apidoc/classes.html
https://qutip.org/docs/4.3/apidoc/classes.html:31987,Energy Efficiency,reduce,reduced,31987,"e; element). c2 : qutip.Qobj; system collapse operator that couples to the output field in; question (only needs to be specified if self.L2 has more than one; element). notrace : bool {False}; If this optional is set to True, a propagator is returned for a; cascade of k systems, where \((k-1) tau < t < k tau\).; If set to False (default), a generalized partial trace is performed; and a propagator for a single system is returned. Returns:; : :class:`qutip.Qobj`; time-propagator for computing field correlation function. propagator(t, tau, notrace=False)[source]Â¶; Compute propagator for time t and time-delay tau. Parameters:; t : float; current time. tau : float; time-delay. notrace : bool {False}; If this optional is set to True, a propagator is returned for a; cascade of k systems, where \((k-1) tau < t < k tau\).; If set to False (default), a generalized partial trace is performed; and a propagator for a single system is returned. Returns. ââ-. : :class:`qutip.Qobj`; time-propagator for reduced system dynamics. rhot(rho0, t, tau)[source]Â¶; Compute the reduced system density matrix \(\rho(t)\). Parameters:; rho0 : qutip.Qobj; initial density matrix or state vector (ket). t : float; current time. tau : float; time-delay. Returns:; : :class:`qutip.Qobj`; density matrix at time \(t\). class TTMSolverOptions(dynmaps=None, times=[], learningtimes=[], thres=0.0, options=None)[source]Â¶; Class of options for the Transfer Tensor Method solver. Attributes:; dynmaps : list of qutip.Qobj; List of precomputed dynamical maps (superoperators),; or a callback function that returns the; superoperator at a given time. times : array_like; List of times \(t_n\) at which to calculate \(\rho(t_n)\). learningtimes : array_like; List of times \(t_k\) to use as learning times if argument; dynmaps is a callback function. thres : float; Threshold for halting. Halts if \(||T_{n}-T_{n-1}||\) is below; treshold. options : qutip.solver.Options; Generic solver options. Solver Options and ResultsÂ¶. c",MatchSource.WIKI,docs/4.3/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/apidoc/classes.html
https://qutip.org/docs/4.3/apidoc/classes.html:32053,Energy Efficiency,reduce,reduced,32053,"to the output field in; question (only needs to be specified if self.L2 has more than one; element). notrace : bool {False}; If this optional is set to True, a propagator is returned for a; cascade of k systems, where \((k-1) tau < t < k tau\).; If set to False (default), a generalized partial trace is performed; and a propagator for a single system is returned. Returns:; : :class:`qutip.Qobj`; time-propagator for computing field correlation function. propagator(t, tau, notrace=False)[source]Â¶; Compute propagator for time t and time-delay tau. Parameters:; t : float; current time. tau : float; time-delay. notrace : bool {False}; If this optional is set to True, a propagator is returned for a; cascade of k systems, where \((k-1) tau < t < k tau\).; If set to False (default), a generalized partial trace is performed; and a propagator for a single system is returned. Returns. ââ-. : :class:`qutip.Qobj`; time-propagator for reduced system dynamics. rhot(rho0, t, tau)[source]Â¶; Compute the reduced system density matrix \(\rho(t)\). Parameters:; rho0 : qutip.Qobj; initial density matrix or state vector (ket). t : float; current time. tau : float; time-delay. Returns:; : :class:`qutip.Qobj`; density matrix at time \(t\). class TTMSolverOptions(dynmaps=None, times=[], learningtimes=[], thres=0.0, options=None)[source]Â¶; Class of options for the Transfer Tensor Method solver. Attributes:; dynmaps : list of qutip.Qobj; List of precomputed dynamical maps (superoperators),; or a callback function that returns the; superoperator at a given time. times : array_like; List of times \(t_n\) at which to calculate \(\rho(t_n)\). learningtimes : array_like; List of times \(t_k\) to use as learning times if argument; dynmaps is a callback function. thres : float; Threshold for halting. Halts if \(||T_{n}-T_{n-1}||\) is below; treshold. options : qutip.solver.Options; Generic solver options. Solver Options and ResultsÂ¶. class Options(atol=1e-08, rtol=1e-06, method='adams', order=12, nste",MatchSource.WIKI,docs/4.3/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/apidoc/classes.html
https://qutip.org/docs/4.3/apidoc/classes.html:54491,Energy Efficiency,reduce,reduced,54491,"valid; taus for this row and column of the Dicke space element. Distribution functionsÂ¶. class Distribution(data=None, xvecs=[], xlabels=[])[source]Â¶; A class for representation spatial distribution functions.; The Distribution class can be used to prepresent spatial distribution; functions of arbitray dimension (although only 1D and 2D distributions; are used so far).; It is indented as a base class for specific distribution function, and; provide implementation of basic functions that are shared among all; Distribution functions, such as visualization, calculating marginal; distributions, etc. Parameters:; data : array_like; Data for the distribution. The dimensions must match the lengths of; the coordinate arrays in xvecs. xvecs : list; List of arrays that spans the space for each coordinate. xlabels : list; List of labels for each coordinate. marginal(dim=0)[source]Â¶; Calculate the marginal distribution function along the dimension; dim. Return a new Distribution instance describing this reduced-; dimensionality distribution. Parameters:; dim : int; The dimension (coordinate index) along which to obtain the; marginal distribution. Returns:; d : Distributions; A new instances of Distribution that describes the marginal; distribution. project(dim=0)[source]Â¶; Calculate the projection (max value) distribution function along the; dimension dim. Return a new Distribution instance describing this; reduced-dimensionality distribution. Parameters:; dim : int; The dimension (coordinate index) along which to obtain the; projected distribution. Returns:; d : Distributions; A new instances of Distribution that describes the projection. visualize(fig=None, ax=None, figsize=(8, 6), colorbar=True, cmap=None, style='colormap', show_xlabel=True, show_ylabel=True)[source]Â¶; Visualize the data of the distribution in 1D or 2D, depending; on the dimensionality of the underlaying distribution.; Parameters:. fig : matplotlib Figure instance; If given, use this figure instance for the ",MatchSource.WIKI,docs/4.3/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/apidoc/classes.html
https://qutip.org/docs/4.3/apidoc/classes.html:54903,Energy Efficiency,reduce,reduced-dimensionality,54903,"ecific distribution function, and; provide implementation of basic functions that are shared among all; Distribution functions, such as visualization, calculating marginal; distributions, etc. Parameters:; data : array_like; Data for the distribution. The dimensions must match the lengths of; the coordinate arrays in xvecs. xvecs : list; List of arrays that spans the space for each coordinate. xlabels : list; List of labels for each coordinate. marginal(dim=0)[source]Â¶; Calculate the marginal distribution function along the dimension; dim. Return a new Distribution instance describing this reduced-; dimensionality distribution. Parameters:; dim : int; The dimension (coordinate index) along which to obtain the; marginal distribution. Returns:; d : Distributions; A new instances of Distribution that describes the marginal; distribution. project(dim=0)[source]Â¶; Calculate the projection (max value) distribution function along the; dimension dim. Return a new Distribution instance describing this; reduced-dimensionality distribution. Parameters:; dim : int; The dimension (coordinate index) along which to obtain the; projected distribution. Returns:; d : Distributions; A new instances of Distribution that describes the projection. visualize(fig=None, ax=None, figsize=(8, 6), colorbar=True, cmap=None, style='colormap', show_xlabel=True, show_ylabel=True)[source]Â¶; Visualize the data of the distribution in 1D or 2D, depending; on the dimensionality of the underlaying distribution.; Parameters:. fig : matplotlib Figure instance; If given, use this figure instance for the visualization,; ax : matplotlib Axes instance; If given, render the visualization using this axis instance.; figsize : tuple; Size of the new Figure instance, if one needs to be created.; colorbar: Bool; Whether or not the colorbar (in 2D visualization) should be used.; cmap: matplotlib colormap instance; If given, use this colormap for 2D visualizations.; style : string; Type of visualization: âcolormapâ (d",MatchSource.WIKI,docs/4.3/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/apidoc/classes.html
https://qutip.org/docs/4.3/apidoc/classes.html:70203,Energy Efficiency,reduce,reduce,70203,"the control amplitudes; Can be a scalar value applied to all controls; or a list of bounds for each control. bounds : List of floats; Bounds for the parameters.; If not set before the run_optimization call then the list; is built automatically based on the amp_lbound and amp_ubound; attributes.; Setting this attribute directly allows specific bounds to be set; for individual parameters.; Note: Only some methods use bounds. dynamics : Dynamics (subclass instance); describes the dynamics of the (quantum) system to be control optimised; (see Dynamics classes for details). config : OptimConfig instance; various configuration options; (see OptimConfig for details). termination_conditions : TerminationCondition instance; attributes determine when the optimisation will end. pulse_generator : PulseGen (subclass instance); (can be) used to create initial pulses; not used by the class, but set by pulseoptim.create_pulse_optimizer. stats : Stats; attributes of which give performance stats for the optimisation; set to None to reduce overhead of calculating stats.; Note it is (usually) shared with the Dynamics instance. dump : dump.OptimDump; Container for data dumped during the optimisation.; Can be set by specifying the dumping level or set directly.; Note this is mainly intended for user and a development debugging; but could be used for status information during a long optimisation. dumping : string; The level of data dumping that will occur during the optimisation - NONE : No processing data dumped (Default) - SUMMARY : A summary at each iteration will be recorded - FULL : All logs will be generated and dumped - CUSTOM : Some customised level of dumping When first set to CUSTOM this is equivalent to SUMMARY. dump_to_file : bool; If set True then data will be dumped to file during the optimisation; dumping will be set to SUMMARY during init_optim; if dump_to_file is True and dumping not set.; Default is False. dump_dir : string; Basically a link to dump.dump_dir. Exists so th",MatchSource.WIKI,docs/4.3/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/apidoc/classes.html
https://qutip.org/docs/4.3/apidoc/classes.html:84839,Energy Efficiency,reduce,reduce,84839,"dynamics generators; (Hamiltonians, Lindbladians etc), the propagators from one timeslot to; the next, and the evolution operators. Due to the large number of matrix; additions and multiplications, for small systems at least, the optimisation; performance is much better using ndarrays to represent these operators.; However. Attributes:; log_level : integer; level of messaging output from the logger.; Options are attributes of qutip.logging_utils,; in decreasing levels of messaging, are:; DEBUG_INTENSE, DEBUG_VERBOSE, DEBUG, INFO, WARN, ERROR, CRITICAL; Anything WARN or above is effectively âquietâ execution,; assuming everything runs as expected.; The default NOTSET implies that the level will be taken from; the QuTiP settings file, which by default is WARN. params: Dictionary; The key value pairs are the attribute name and value; Note: attributes are created if they do not exist already,; and are overwritten if they do. stats : Stats; Attributes of which give performance stats for the optimisation; set to None to reduce overhead of calculating stats.; Note it is (usually) shared with the Optimizer object. tslot_computer : TimeslotComputer (subclass instance); Used to manage when the timeslot dynamics; generators, propagators, gradients etc are updated. prop_computer : PropagatorComputer (subclass instance); Used to compute the propagators and their gradients. fid_computer : FidelityComputer (subclass instance); Used to computer the fidelity error and the fidelity error; gradient. memory_optimization : int; Level of memory optimisation. Setting to 0 (default) means that; execution speed is prioritized over memory.; Setting to 1 means that some memory prioritisation steps will be; taken, for instance using Qobj (and hence sparse arrays) as the; the internal operator data type, and not caching some operators; Potentially further memory saving maybe made with; memory_optimization > 1.; The options are processed in _set_memory_optimizations, see; this for more informatio",MatchSource.WIKI,docs/4.3/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/apidoc/classes.html
https://qutip.org/docs/4.3/apidoc/classes.html:99973,Energy Efficiency,efficient,efficient,99973,"s a parameter; This is called during the instantiation automatically.; The key value pairs are the attribute name and value; Note: attributes are created if they do not exist already,; and are overwritten if they do. reset()[source]Â¶; reset any configuration data. class PropCompApproxGrad(dynamics, params=None)[source]Â¶; This subclass can be used when the propagator is calculated simply; by expm of the dynamics generator, i.e. when gradients will be calculated; using approximate methods. reset()[source]Â¶; reset any configuration data. class PropCompDiag(dynamics, params=None)[source]Â¶; Coumputes the propagator exponentiation using diagonalisation of; of the dynamics generator. reset()[source]Â¶; reset any configuration data. class PropCompFrechet(dynamics, params=None)[source]Â¶. Frechet method for calculating the propagator:; exponentiating the combined dynamics generator. and the propagator gradient; It should work for all systems, e.g. unitary, open, symplectic; There are other PropagatorComputer subclasses that may be more efficient. reset()[source]Â¶; reset any configuration data. class FidelityComputer(dynamics, params=None)[source]Â¶; Base class for all Fidelity Computers.; This cannot be used directly. See subclass descriptions and choose; one appropriate for the application; Note: this must be instantiated with a Dynamics object, that is the; container for the data that the methods operate on. Attributes:; log_level : integer; level of messaging output from the logger.; Options are attributes of qutip.logging_utils,; in decreasing levels of messaging, are:; DEBUG_INTENSE, DEBUG_VERBOSE, DEBUG, INFO, WARN, ERROR, CRITICAL; Anything WARN or above is effectively âquietâ execution,; assuming everything runs as expected.; The default NOTSET implies that the level will be taken from; the QuTiP settings file, which by default is WARN. dimensional_norm : float; Normalisation constant. fid_norm_func : function; Used to normalise the fidelity; See SU and PSU options for t",MatchSource.WIKI,docs/4.3/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/apidoc/classes.html
https://qutip.org/docs/4.3/apidoc/classes.html:8290,Integrability,depend,dependent,8290,"igenvalues for operator. eigvecs : array; Array of quantum operators representing the oprator eigenkets.; Order of eigenkets is determined by order of eigenvalues. Notes; The sparse eigensolver is much slower than the dense version.; Use sparse only if memory requirements demand it. eliminate_states(states_inds, normalize=False)[source]Â¶; Creates a new quantum object with states in state_inds eliminated. Parameters:; states_inds : list of integer; The states that should be removed. normalize : True / False; Weather or not the new Qobj instance should be normalized (default; is False). For Qobjs that represents density matrices or state; vectors normalized should probably be set to True, but for Qobjs; that represents operators in for example an Hamiltonian, normalize; should be False. Returns:; q : Qobj; A new instance of qutip.Qobj that contains only the states; corresponding to indices that are not in state_inds. Notes; Experimental. static evaluate(qobj_list, t, args)[source]Â¶; Evaluate a time-dependent quantum object in list format. For; example,. qobj_list = [H0, [H1, func_t]]; is evaluated to. Qobj(t) = H0 + H1 * func_t(t, args); and. qobj_list = [H0, [H1, âsin(w * t)â]]; is evaluated to. Qobj(t) = H0 + H1 * sin(args[âwâ] * t). Parameters:; qobj_list : list; A nested list of Qobj instances and corresponding time-dependent; coefficients. t : float; The time for which to evaluate the time-dependent Qobj instance. args : dictionary; A dictionary with parameter values required to evaluate the; time-dependent Qobj intance. Returns:; output : Qobj; A Qobj instance that represents the value of qobj_list at time t. expm(method='dense')[source]Â¶; Matrix exponential of quantum operator.; Input operator must be square. Parameters:; method : str {âdenseâ, âsparseâ}; Use set method to use to calculate the matrix exponentiation. The; available choices includes âdenseâ and âsparseâ. Since the; exponential of a matrix is nearly always dense, method=âdenseâ; is set as default.s",MatchSource.WIKI,docs/4.3/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/apidoc/classes.html
https://qutip.org/docs/4.3/apidoc/classes.html:8618,Integrability,depend,dependent,8618,"inds, normalize=False)[source]Â¶; Creates a new quantum object with states in state_inds eliminated. Parameters:; states_inds : list of integer; The states that should be removed. normalize : True / False; Weather or not the new Qobj instance should be normalized (default; is False). For Qobjs that represents density matrices or state; vectors normalized should probably be set to True, but for Qobjs; that represents operators in for example an Hamiltonian, normalize; should be False. Returns:; q : Qobj; A new instance of qutip.Qobj that contains only the states; corresponding to indices that are not in state_inds. Notes; Experimental. static evaluate(qobj_list, t, args)[source]Â¶; Evaluate a time-dependent quantum object in list format. For; example,. qobj_list = [H0, [H1, func_t]]; is evaluated to. Qobj(t) = H0 + H1 * func_t(t, args); and. qobj_list = [H0, [H1, âsin(w * t)â]]; is evaluated to. Qobj(t) = H0 + H1 * sin(args[âwâ] * t). Parameters:; qobj_list : list; A nested list of Qobj instances and corresponding time-dependent; coefficients. t : float; The time for which to evaluate the time-dependent Qobj instance. args : dictionary; A dictionary with parameter values required to evaluate the; time-dependent Qobj intance. Returns:; output : Qobj; A Qobj instance that represents the value of qobj_list at time t. expm(method='dense')[source]Â¶; Matrix exponential of quantum operator.; Input operator must be square. Parameters:; method : str {âdenseâ, âsparseâ}; Use set method to use to calculate the matrix exponentiation. The; available choices includes âdenseâ and âsparseâ. Since the; exponential of a matrix is nearly always dense, method=âdenseâ; is set as default.s. Returns:; oper : qobj; Exponentiated quantum operator. Raises:; TypeError; Quantum operator is not square. extract_states(states_inds, normalize=False)[source]Â¶; Qobj with states in state_inds only. Parameters:; states_inds : list of integer; The states that should be kept. normalize : True / False; Weath",MatchSource.WIKI,docs/4.3/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/apidoc/classes.html
https://qutip.org/docs/4.3/apidoc/classes.html:8694,Integrability,depend,dependent,8694,"ated. Parameters:; states_inds : list of integer; The states that should be removed. normalize : True / False; Weather or not the new Qobj instance should be normalized (default; is False). For Qobjs that represents density matrices or state; vectors normalized should probably be set to True, but for Qobjs; that represents operators in for example an Hamiltonian, normalize; should be False. Returns:; q : Qobj; A new instance of qutip.Qobj that contains only the states; corresponding to indices that are not in state_inds. Notes; Experimental. static evaluate(qobj_list, t, args)[source]Â¶; Evaluate a time-dependent quantum object in list format. For; example,. qobj_list = [H0, [H1, func_t]]; is evaluated to. Qobj(t) = H0 + H1 * func_t(t, args); and. qobj_list = [H0, [H1, âsin(w * t)â]]; is evaluated to. Qobj(t) = H0 + H1 * sin(args[âwâ] * t). Parameters:; qobj_list : list; A nested list of Qobj instances and corresponding time-dependent; coefficients. t : float; The time for which to evaluate the time-dependent Qobj instance. args : dictionary; A dictionary with parameter values required to evaluate the; time-dependent Qobj intance. Returns:; output : Qobj; A Qobj instance that represents the value of qobj_list at time t. expm(method='dense')[source]Â¶; Matrix exponential of quantum operator.; Input operator must be square. Parameters:; method : str {âdenseâ, âsparseâ}; Use set method to use to calculate the matrix exponentiation. The; available choices includes âdenseâ and âsparseâ. Since the; exponential of a matrix is nearly always dense, method=âdenseâ; is set as default.s. Returns:; oper : qobj; Exponentiated quantum operator. Raises:; TypeError; Quantum operator is not square. extract_states(states_inds, normalize=False)[source]Â¶; Qobj with states in state_inds only. Parameters:; states_inds : list of integer; The states that should be kept. normalize : True / False; Weather or not the new Qobj instance should be normalized (default; is False). For Qobjs that repr",MatchSource.WIKI,docs/4.3/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/apidoc/classes.html
https://qutip.org/docs/4.3/apidoc/classes.html:8804,Integrability,depend,dependent,8804,"ze : True / False; Weather or not the new Qobj instance should be normalized (default; is False). For Qobjs that represents density matrices or state; vectors normalized should probably be set to True, but for Qobjs; that represents operators in for example an Hamiltonian, normalize; should be False. Returns:; q : Qobj; A new instance of qutip.Qobj that contains only the states; corresponding to indices that are not in state_inds. Notes; Experimental. static evaluate(qobj_list, t, args)[source]Â¶; Evaluate a time-dependent quantum object in list format. For; example,. qobj_list = [H0, [H1, func_t]]; is evaluated to. Qobj(t) = H0 + H1 * func_t(t, args); and. qobj_list = [H0, [H1, âsin(w * t)â]]; is evaluated to. Qobj(t) = H0 + H1 * sin(args[âwâ] * t). Parameters:; qobj_list : list; A nested list of Qobj instances and corresponding time-dependent; coefficients. t : float; The time for which to evaluate the time-dependent Qobj instance. args : dictionary; A dictionary with parameter values required to evaluate the; time-dependent Qobj intance. Returns:; output : Qobj; A Qobj instance that represents the value of qobj_list at time t. expm(method='dense')[source]Â¶; Matrix exponential of quantum operator.; Input operator must be square. Parameters:; method : str {âdenseâ, âsparseâ}; Use set method to use to calculate the matrix exponentiation. The; available choices includes âdenseâ and âsparseâ. Since the; exponential of a matrix is nearly always dense, method=âdenseâ; is set as default.s. Returns:; oper : qobj; Exponentiated quantum operator. Raises:; TypeError; Quantum operator is not square. extract_states(states_inds, normalize=False)[source]Â¶; Qobj with states in state_inds only. Parameters:; states_inds : list of integer; The states that should be kept. normalize : True / False; Weather or not the new Qobj instance should be normalized (default; is False). For Qobjs that represents density matrices or state; vectors normalized should probably be set to True, but for ",MatchSource.WIKI,docs/4.3/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/apidoc/classes.html
https://qutip.org/docs/4.3/apidoc/classes.html:16525,Integrability,depend,dependent,16525," then renormalizing to obtain a valid density; operator. Parameters:; method : str; Algorithm to use to remove negative eigenvalues. âclipâ; simply discards negative eigenvalues, then renormalizes.; âsgsâ uses the SGS algorithm (doi:10/bb76) to find the; positive operator that is nearest in the Shatten 2-norm. Returns:; oper : qobj; A valid density operator. unit(inplace=False, norm=None, sparse=False, tol=0, maxiter=100000)[source]Â¶; Operator or state normalized to unity.; Uses norm from Qobj.norm(). Parameters:; inplace : bool; Do an in-place normalization. norm : str; Requested norm for states / operators. sparse : bool; Use sparse eigensolver for trace norm. Does not affect other norms. tol : float; Tolerance used by sparse eigensolver. maxiter : int; Number of maximum iterations performed by sparse eigensolver. Returns:; oper : qobj; Normalized quantum object if not in-place,; else None. eseriesÂ¶. class eseries(q=array([], dtype=object), s=array([], dtype=float64))[source]Â¶; Class representation of an exponential-series expansion of; time-dependent quantum objects. Attributes:; ampl : ndarray; Array of amplitudes for exponential series. rates : ndarray; Array of rates for exponential series. dims : list; Dimensions of exponential series components. shape : list; Shape corresponding to exponential series components. Methods. value(tlist); Evaluate an exponential series at the times listed in tlist. spec(wlist); Evaluate the spectrum of an exponential series at frequencies in wlist. tidyup(); Returns a tidier version of the exponential series. spec(wlist)[source]Â¶; Evaluate the spectrum of an exponential series at frequencies; in wlist. Parameters:; wlist : array_like; Array/list of frequenies. Returns:; val_list : ndarray; Values of exponential series at frequencies in wlist. tidyup(*args)[source]Â¶; Returns a tidier version of exponential series. value(tlist)[source]Â¶; Evaluates an exponential series at the times listed in tlist. Parameters:; tlist : ndarray; Tim",MatchSource.WIKI,docs/4.3/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/apidoc/classes.html
https://qutip.org/docs/4.3/apidoc/classes.html:26460,Integrability,integrat,integrate,26460,"tzmann=None, renorm=None, bnd_cut_approx=None, options=None, progress_bar=None, stats=None)[source]Â¶; Configure the solver using the passed parameters; The parameters are described in the class attributes, unless there; is some specific behaviour. Parameters:; options : qutip.solver.Options; Generic solver options.; If set to None the default options will be used. progress_bar: BaseProgressBar; Optional instance of BaseProgressBar, or a subclass thereof, for; showing the progress of the simulation.; If set to None, then the default progress bar will be used; Set to False for no progress bar. stats: :class:`qutip.solver.Stats`; Optional instance of solver.Stats, or a subclass thereof, for; storing performance statistics for the solver; If set to True, then the default Stats for this class will be used; Set to False for no stats. create_new_stats()[source]Â¶; Creates a new stats object suitable for use with this solver; Note: this solver expects the stats object to have sections. config; integrate. reset()[source]Â¶; Reset any attributes to default values. class HSolverDL(H_sys, coup_op, coup_strength, temperature, N_cut, N_exp, cut_freq, planck=1.0, boltzmann=1.0, renorm=True, bnd_cut_approx=True, options=None, progress_bar=None, stats=None)[source]Â¶; HEOM solver based on the Drude-Lorentz model for spectral density.; Drude-Lorentz bath the correlation functions can be exactly analytically; expressed as an infinite sum of exponentials which depend on the; temperature, these are called the Matsubara terms or Matsubara frequencies; For practical computation purposes an approximation must be used based; on a small number of Matsubara terms (typically < 4). Attributes:; cut_freq : float; Bath spectral density cutoff frequency. renorm : bool; Apply renormalisation to coupling terms; Can be useful if using SI units for planck and boltzmann. bnd_cut_approx : bool; Use boundary cut off approximation; Can be. configure(H_sys, coup_op, coup_strength, temperature, N_cut, N_exp, cu",MatchSource.WIKI,docs/4.3/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/apidoc/classes.html
https://qutip.org/docs/4.3/apidoc/classes.html:26922,Integrability,depend,depend,26922,"f set to None, then the default progress bar will be used; Set to False for no progress bar. stats: :class:`qutip.solver.Stats`; Optional instance of solver.Stats, or a subclass thereof, for; storing performance statistics for the solver; If set to True, then the default Stats for this class will be used; Set to False for no stats. create_new_stats()[source]Â¶; Creates a new stats object suitable for use with this solver; Note: this solver expects the stats object to have sections. config; integrate. reset()[source]Â¶; Reset any attributes to default values. class HSolverDL(H_sys, coup_op, coup_strength, temperature, N_cut, N_exp, cut_freq, planck=1.0, boltzmann=1.0, renorm=True, bnd_cut_approx=True, options=None, progress_bar=None, stats=None)[source]Â¶; HEOM solver based on the Drude-Lorentz model for spectral density.; Drude-Lorentz bath the correlation functions can be exactly analytically; expressed as an infinite sum of exponentials which depend on the; temperature, these are called the Matsubara terms or Matsubara frequencies; For practical computation purposes an approximation must be used based; on a small number of Matsubara terms (typically < 4). Attributes:; cut_freq : float; Bath spectral density cutoff frequency. renorm : bool; Apply renormalisation to coupling terms; Can be useful if using SI units for planck and boltzmann. bnd_cut_approx : bool; Use boundary cut off approximation; Can be. configure(H_sys, coup_op, coup_strength, temperature, N_cut, N_exp, cut_freq, planck=None, boltzmann=None, renorm=None, bnd_cut_approx=None, options=None, progress_bar=None, stats=None)[source]Â¶; Calls configure from HEOMSolver and sets any attributes; that are specific to this subclass. reset()[source]Â¶; Reset any attributes to default values. run(rho0, tlist)[source]Â¶; Function to solve for an open quantum system using the; HEOM model. Parameters:; rho0 : Qobj; Initial state (density matrix) of the system. tlist : list; Time over which system evolves. Returns:; result",MatchSource.WIKI,docs/4.3/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/apidoc/classes.html
https://qutip.org/docs/4.3/apidoc/classes.html:28107,Integrability,integrat,integrator,28107,"eq : float; Bath spectral density cutoff frequency. renorm : bool; Apply renormalisation to coupling terms; Can be useful if using SI units for planck and boltzmann. bnd_cut_approx : bool; Use boundary cut off approximation; Can be. configure(H_sys, coup_op, coup_strength, temperature, N_cut, N_exp, cut_freq, planck=None, boltzmann=None, renorm=None, bnd_cut_approx=None, options=None, progress_bar=None, stats=None)[source]Â¶; Calls configure from HEOMSolver and sets any attributes; that are specific to this subclass. reset()[source]Â¶; Reset any attributes to default values. run(rho0, tlist)[source]Â¶; Function to solve for an open quantum system using the; HEOM model. Parameters:; rho0 : Qobj; Initial state (density matrix) of the system. tlist : list; Time over which system evolves. Returns:; results : qutip.solver.Result; Object storing all results from the simulation. class MemoryCascade(H_S, L1, L2, S_matrix=None, c_ops_markov=None, integrator='propagator', parallel=False, options=None)[source]Â¶; Class for running memory cascade simulations of open quantum systems; with time-delayed coherent feedback. Attributes:; H_S : qutip.Qobj; System Hamiltonian (can also be a Liouvillian). L1 : qutip.Qobj / list of qutip.Qobj; System operators coupling into the feedback loop. Can be a single; operator or a list of operators. L2 : qutip.Qobj / list of qutip.Qobj; System operators coupling out of the feedback loop. Can be a single; operator or a list of operators. L2 must have the same length as L1. S_matrix: *array*; S matrix describing which operators in L1 are coupled to which; operators in L2 by the feedback channel. Defaults to an n by n identity; matrix where n is the number of elements in L1/L2. c_ops_markov : qutip.Qobj / list of qutip.Qobj; Decay operators describing conventional Markovian decay channels.; Can be a single operator or a list of operators. integrator : str {âpropagatorâ, âmesolveâ}; Integrator method to use. Defaults to âpropagatorâ which tends to be; fa",MatchSource.WIKI,docs/4.3/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/apidoc/classes.html
https://qutip.org/docs/4.3/apidoc/classes.html:29043,Integrability,integrat,integrator,29043,"trix=None, c_ops_markov=None, integrator='propagator', parallel=False, options=None)[source]Â¶; Class for running memory cascade simulations of open quantum systems; with time-delayed coherent feedback. Attributes:; H_S : qutip.Qobj; System Hamiltonian (can also be a Liouvillian). L1 : qutip.Qobj / list of qutip.Qobj; System operators coupling into the feedback loop. Can be a single; operator or a list of operators. L2 : qutip.Qobj / list of qutip.Qobj; System operators coupling out of the feedback loop. Can be a single; operator or a list of operators. L2 must have the same length as L1. S_matrix: *array*; S matrix describing which operators in L1 are coupled to which; operators in L2 by the feedback channel. Defaults to an n by n identity; matrix where n is the number of elements in L1/L2. c_ops_markov : qutip.Qobj / list of qutip.Qobj; Decay operators describing conventional Markovian decay channels.; Can be a single operator or a list of operators. integrator : str {âpropagatorâ, âmesolveâ}; Integrator method to use. Defaults to âpropagatorâ which tends to be; faster for long times (i.e., large Hilbert space). parallel : bool; Run integrator in parallel if True. Only implemented for âpropagatorâ; as the integrator method. options : qutip.solver.Options; Generic solver options. outfieldcorr(rho0, blist, tlist, tau, c1=None, c2=None)[source]Â¶; Compute output field expectation value; <O_n(tn)â¦O_2(t2)O_1(t1)> for times t1,t2,â¦ and; O_i = I, b_out, b_out^dagger, b_loop, b_loop^dagger. Parameters:; rho0 : qutip.Qobj; initial density matrix or state vector (ket). blist : array_like; List of integers specifying the field operators:; 0: I (nothing); 1: b_out; 2: b_out^dagger; 3: b_loop; 4: b_loop^dagger. tlist : array_like; list of corresponding times t1,..,tn at which to evaluate the field; operators. tau : float; time-delay. c1 : qutip.Qobj; system collapse operator that couples to the in-loop field in; question (only needs to be specified if self.L1 has more than one; ",MatchSource.WIKI,docs/4.3/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/apidoc/classes.html
https://qutip.org/docs/4.3/apidoc/classes.html:29229,Integrability,integrat,integrator,29229,"systems; with time-delayed coherent feedback. Attributes:; H_S : qutip.Qobj; System Hamiltonian (can also be a Liouvillian). L1 : qutip.Qobj / list of qutip.Qobj; System operators coupling into the feedback loop. Can be a single; operator or a list of operators. L2 : qutip.Qobj / list of qutip.Qobj; System operators coupling out of the feedback loop. Can be a single; operator or a list of operators. L2 must have the same length as L1. S_matrix: *array*; S matrix describing which operators in L1 are coupled to which; operators in L2 by the feedback channel. Defaults to an n by n identity; matrix where n is the number of elements in L1/L2. c_ops_markov : qutip.Qobj / list of qutip.Qobj; Decay operators describing conventional Markovian decay channels.; Can be a single operator or a list of operators. integrator : str {âpropagatorâ, âmesolveâ}; Integrator method to use. Defaults to âpropagatorâ which tends to be; faster for long times (i.e., large Hilbert space). parallel : bool; Run integrator in parallel if True. Only implemented for âpropagatorâ; as the integrator method. options : qutip.solver.Options; Generic solver options. outfieldcorr(rho0, blist, tlist, tau, c1=None, c2=None)[source]Â¶; Compute output field expectation value; <O_n(tn)â¦O_2(t2)O_1(t1)> for times t1,t2,â¦ and; O_i = I, b_out, b_out^dagger, b_loop, b_loop^dagger. Parameters:; rho0 : qutip.Qobj; initial density matrix or state vector (ket). blist : array_like; List of integers specifying the field operators:; 0: I (nothing); 1: b_out; 2: b_out^dagger; 3: b_loop; 4: b_loop^dagger. tlist : array_like; list of corresponding times t1,..,tn at which to evaluate the field; operators. tau : float; time-delay. c1 : qutip.Qobj; system collapse operator that couples to the in-loop field in; question (only needs to be specified if self.L1 has more than one; element). c2 : qutip.Qobj; system collapse operator that couples to the output field in; question (only needs to be specified if self.L2 has more than one; e",MatchSource.WIKI,docs/4.3/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/apidoc/classes.html
https://qutip.org/docs/4.3/apidoc/classes.html:29303,Integrability,integrat,integrator,29303,"; H_S : qutip.Qobj; System Hamiltonian (can also be a Liouvillian). L1 : qutip.Qobj / list of qutip.Qobj; System operators coupling into the feedback loop. Can be a single; operator or a list of operators. L2 : qutip.Qobj / list of qutip.Qobj; System operators coupling out of the feedback loop. Can be a single; operator or a list of operators. L2 must have the same length as L1. S_matrix: *array*; S matrix describing which operators in L1 are coupled to which; operators in L2 by the feedback channel. Defaults to an n by n identity; matrix where n is the number of elements in L1/L2. c_ops_markov : qutip.Qobj / list of qutip.Qobj; Decay operators describing conventional Markovian decay channels.; Can be a single operator or a list of operators. integrator : str {âpropagatorâ, âmesolveâ}; Integrator method to use. Defaults to âpropagatorâ which tends to be; faster for long times (i.e., large Hilbert space). parallel : bool; Run integrator in parallel if True. Only implemented for âpropagatorâ; as the integrator method. options : qutip.solver.Options; Generic solver options. outfieldcorr(rho0, blist, tlist, tau, c1=None, c2=None)[source]Â¶; Compute output field expectation value; <O_n(tn)â¦O_2(t2)O_1(t1)> for times t1,t2,â¦ and; O_i = I, b_out, b_out^dagger, b_loop, b_loop^dagger. Parameters:; rho0 : qutip.Qobj; initial density matrix or state vector (ket). blist : array_like; List of integers specifying the field operators:; 0: I (nothing); 1: b_out; 2: b_out^dagger; 3: b_loop; 4: b_loop^dagger. tlist : array_like; list of corresponding times t1,..,tn at which to evaluate the field; operators. tau : float; time-delay. c1 : qutip.Qobj; system collapse operator that couples to the in-loop field in; question (only needs to be specified if self.L1 has more than one; element). c2 : qutip.Qobj; system collapse operator that couples to the output field in; question (only needs to be specified if self.L2 has more than one; element). Returns:; : complex; expectation value of field ",MatchSource.WIKI,docs/4.3/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/apidoc/classes.html
https://qutip.org/docs/4.3/apidoc/classes.html:33937,Integrability,integrat,integrator,33937,"olver options. Solver Options and ResultsÂ¶. class Options(atol=1e-08, rtol=1e-06, method='adams', order=12, nsteps=1000, first_step=0, max_step=0, min_step=0, average_expect=True, average_states=False, tidy=True, num_cpus=0, norm_tol=0.001, norm_steps=5, rhs_reuse=False, rhs_filename=None, ntraj=500, gui=False, rhs_with_state=False, store_final_state=False, store_states=False, seeds=None, steady_state_average=False, normalize_output=True, use_openmp=None, openmp_threads=None)[source]Â¶; Class of options for evolution solvers such as qutip.mesolve and; qutip.mcsolve. Options can be specified either as arguments to the; constructor:; opts = Options(order=10, ...). or by changing the class attributes after creation:; opts = Options(); opts.order = 10. Returns options class to be used as options in evolution solvers. Attributes:; atol : float {1e-8}; Absolute tolerance. rtol : float {1e-6}; Relative tolerance. method : str {âadamsâ,âbdfâ}; Integration method. order : int {12}; Order of integrator (<=12 âadamsâ, <=5 âbdfâ). nsteps : int {2500}; Max. number of internal steps/call. first_step : float {0}; Size of initial step (0 = automatic). min_step : float {0}; Minimum step size (0 = automatic). max_step : float {0}; Maximum step size (0 = automatic). tidy : bool {True,False}; Tidyup Hamiltonian and initial state by removing small terms. num_cpus : int; Number of cpus used by mcsolver (default = # of cpus). norm_tol : float; Tolerance used when finding wavefunction norm in mcsolve. norm_steps : int; Max. number of steps used to find wavefunction norm to within norm_tol; in mcsolve. average_states : bool {False}; Average states values over trajectories in stochastic solvers. average_expect : bool {True}; Average expectation values over trajectories for stochastic solvers. mc_corr_eps : float {1e-10}; Arbitrarily small value for eliminating any divide-by-zero errors in; correlation calculations when using mcsolve. ntraj : int {500}; Number of trajectories in stochastic solv",MatchSource.WIKI,docs/4.3/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/apidoc/classes.html
https://qutip.org/docs/4.3/apidoc/classes.html:37942,Integrability,message,message,37942,"are given in the the contructor, then all statistics; will be added to one section âmainâ. Parameters:; section_names : list; list of keys that will be used as keys for the sections; These keys will also be used as names for the sections; The text in the output can be overidden by setting the header property; of the section; If no names are given then one section called âmainâ is created. Attributes:; sections : OrderedDict of _StatsSection; These are the sections that are created automatically on instantiation; or added using add_section. header : string; Some text that will be used as the heading in the report; By default there is None. total_time : float; Time in seconds for the solver to complete processing; Can be None, meaning that total timing percentages will be reported. Methods. add_section(name); Add another section with the given name. add_count(key,Â value[,Â section]); Add value to count. add_timing(key,Â value[,Â section]); Add value to timing. add_message(key,Â value[,Â section,Â sep]); Add value to message. report:; Output the statistics report to console or file. add_count(key, value, section=None)[source]Â¶; Add value to count. If key does not already exist in section then; it is created with this value.; If key already exists it is increased by the give value; value is expected to be an integer. Parameters:; key : string; key for the section.counts dictionary; reusing a key will result in numerical addition of value. value : int; Initial value of the count, or added to an existing count. section: string or `class` : _StatsSection; Section which to add the count to.; If None given, the default (first) section will be used. add_message(key, value, section=None, sep=';')[source]Â¶; Add value to message. If key does not already exist in section then; it is created with this value.; If key already exists the value is added to the message; The value will be converted to a string. Parameters:; key : string; key for the section.messages dictionary; reusing a key w",MatchSource.WIKI,docs/4.3/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/apidoc/classes.html
https://qutip.org/docs/4.3/apidoc/classes.html:38650,Integrability,message,message,38650," complete processing; Can be None, meaning that total timing percentages will be reported. Methods. add_section(name); Add another section with the given name. add_count(key,Â value[,Â section]); Add value to count. add_timing(key,Â value[,Â section]); Add value to timing. add_message(key,Â value[,Â section,Â sep]); Add value to message. report:; Output the statistics report to console or file. add_count(key, value, section=None)[source]Â¶; Add value to count. If key does not already exist in section then; it is created with this value.; If key already exists it is increased by the give value; value is expected to be an integer. Parameters:; key : string; key for the section.counts dictionary; reusing a key will result in numerical addition of value. value : int; Initial value of the count, or added to an existing count. section: string or `class` : _StatsSection; Section which to add the count to.; If None given, the default (first) section will be used. add_message(key, value, section=None, sep=';')[source]Â¶; Add value to message. If key does not already exist in section then; it is created with this value.; If key already exists the value is added to the message; The value will be converted to a string. Parameters:; key : string; key for the section.messages dictionary; reusing a key will result in concatenation of value. value : int; Initial value of the message, or added to an existing message. sep : string; Message will be prefixed with this string when concatenating. section: string or `class` : _StatsSection; Section which to add the message to.; If None given, the default (first) section will be used. add_section(name)[source]Â¶; Add another section with the given name. Parameters:; name : string; will be used as key for sections dict; will also be the header for the section. Returns:; section : class; The new section. add_timing(key, value, section=None)[source]Â¶; Add value to timing. If key does not already exist in section then; it is created with this value.; If ",MatchSource.WIKI,docs/4.3/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/apidoc/classes.html
https://qutip.org/docs/4.3/apidoc/classes.html:38786,Integrability,message,message,38786,"nt(key,Â value[,Â section]); Add value to count. add_timing(key,Â value[,Â section]); Add value to timing. add_message(key,Â value[,Â section,Â sep]); Add value to message. report:; Output the statistics report to console or file. add_count(key, value, section=None)[source]Â¶; Add value to count. If key does not already exist in section then; it is created with this value.; If key already exists it is increased by the give value; value is expected to be an integer. Parameters:; key : string; key for the section.counts dictionary; reusing a key will result in numerical addition of value. value : int; Initial value of the count, or added to an existing count. section: string or `class` : _StatsSection; Section which to add the count to.; If None given, the default (first) section will be used. add_message(key, value, section=None, sep=';')[source]Â¶; Add value to message. If key does not already exist in section then; it is created with this value.; If key already exists the value is added to the message; The value will be converted to a string. Parameters:; key : string; key for the section.messages dictionary; reusing a key will result in concatenation of value. value : int; Initial value of the message, or added to an existing message. sep : string; Message will be prefixed with this string when concatenating. section: string or `class` : _StatsSection; Section which to add the message to.; If None given, the default (first) section will be used. add_section(name)[source]Â¶; Add another section with the given name. Parameters:; name : string; will be used as key for sections dict; will also be the header for the section. Returns:; section : class; The new section. add_timing(key, value, section=None)[source]Â¶; Add value to timing. If key does not already exist in section then; it is created with this value.; If key already exists it is increased by the give value; value is expected to be a float, and given in seconds. Parameters:; key : string; key for the section.timings dic",MatchSource.WIKI,docs/4.3/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/apidoc/classes.html
https://qutip.org/docs/4.3/apidoc/classes.html:38883,Integrability,message,messages,38883,"n,Â sep]); Add value to message. report:; Output the statistics report to console or file. add_count(key, value, section=None)[source]Â¶; Add value to count. If key does not already exist in section then; it is created with this value.; If key already exists it is increased by the give value; value is expected to be an integer. Parameters:; key : string; key for the section.counts dictionary; reusing a key will result in numerical addition of value. value : int; Initial value of the count, or added to an existing count. section: string or `class` : _StatsSection; Section which to add the count to.; If None given, the default (first) section will be used. add_message(key, value, section=None, sep=';')[source]Â¶; Add value to message. If key does not already exist in section then; it is created with this value.; If key already exists the value is added to the message; The value will be converted to a string. Parameters:; key : string; key for the section.messages dictionary; reusing a key will result in concatenation of value. value : int; Initial value of the message, or added to an existing message. sep : string; Message will be prefixed with this string when concatenating. section: string or `class` : _StatsSection; Section which to add the message to.; If None given, the default (first) section will be used. add_section(name)[source]Â¶; Add another section with the given name. Parameters:; name : string; will be used as key for sections dict; will also be the header for the section. Returns:; section : class; The new section. add_timing(key, value, section=None)[source]Â¶; Add value to timing. If key does not already exist in section then; it is created with this value.; If key already exists it is increased by the give value; value is expected to be a float, and given in seconds. Parameters:; key : string; key for the section.timings dictionary; reusing a key will result in numerical addition of value. value : int; Initial value of the timing, or added to an existing t",MatchSource.WIKI,docs/4.3/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/apidoc/classes.html
https://qutip.org/docs/4.3/apidoc/classes.html:38991,Integrability,message,message,38991,"nsole or file. add_count(key, value, section=None)[source]Â¶; Add value to count. If key does not already exist in section then; it is created with this value.; If key already exists it is increased by the give value; value is expected to be an integer. Parameters:; key : string; key for the section.counts dictionary; reusing a key will result in numerical addition of value. value : int; Initial value of the count, or added to an existing count. section: string or `class` : _StatsSection; Section which to add the count to.; If None given, the default (first) section will be used. add_message(key, value, section=None, sep=';')[source]Â¶; Add value to message. If key does not already exist in section then; it is created with this value.; If key already exists the value is added to the message; The value will be converted to a string. Parameters:; key : string; key for the section.messages dictionary; reusing a key will result in concatenation of value. value : int; Initial value of the message, or added to an existing message. sep : string; Message will be prefixed with this string when concatenating. section: string or `class` : _StatsSection; Section which to add the message to.; If None given, the default (first) section will be used. add_section(name)[source]Â¶; Add another section with the given name. Parameters:; name : string; will be used as key for sections dict; will also be the header for the section. Returns:; section : class; The new section. add_timing(key, value, section=None)[source]Â¶; Add value to timing. If key does not already exist in section then; it is created with this value.; If key already exists it is increased by the give value; value is expected to be a float, and given in seconds. Parameters:; key : string; key for the section.timings dictionary; reusing a key will result in numerical addition of value. value : int; Initial value of the timing, or added to an existing timing. section: string or `class` : _StatsSection; Section which to add th",MatchSource.WIKI,docs/4.3/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/apidoc/classes.html
https://qutip.org/docs/4.3/apidoc/classes.html:39024,Integrability,message,message,39024,"nsole or file. add_count(key, value, section=None)[source]Â¶; Add value to count. If key does not already exist in section then; it is created with this value.; If key already exists it is increased by the give value; value is expected to be an integer. Parameters:; key : string; key for the section.counts dictionary; reusing a key will result in numerical addition of value. value : int; Initial value of the count, or added to an existing count. section: string or `class` : _StatsSection; Section which to add the count to.; If None given, the default (first) section will be used. add_message(key, value, section=None, sep=';')[source]Â¶; Add value to message. If key does not already exist in section then; it is created with this value.; If key already exists the value is added to the message; The value will be converted to a string. Parameters:; key : string; key for the section.messages dictionary; reusing a key will result in concatenation of value. value : int; Initial value of the message, or added to an existing message. sep : string; Message will be prefixed with this string when concatenating. section: string or `class` : _StatsSection; Section which to add the message to.; If None given, the default (first) section will be used. add_section(name)[source]Â¶; Add another section with the given name. Parameters:; name : string; will be used as key for sections dict; will also be the header for the section. Returns:; section : class; The new section. add_timing(key, value, section=None)[source]Â¶; Add value to timing. If key does not already exist in section then; it is created with this value.; If key already exists it is increased by the give value; value is expected to be a float, and given in seconds. Parameters:; key : string; key for the section.timings dictionary; reusing a key will result in numerical addition of value. value : int; Initial value of the timing, or added to an existing timing. section: string or `class` : _StatsSection; Section which to add th",MatchSource.WIKI,docs/4.3/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/apidoc/classes.html
https://qutip.org/docs/4.3/apidoc/classes.html:39178,Integrability,message,message,39178,"lue.; If key already exists it is increased by the give value; value is expected to be an integer. Parameters:; key : string; key for the section.counts dictionary; reusing a key will result in numerical addition of value. value : int; Initial value of the count, or added to an existing count. section: string or `class` : _StatsSection; Section which to add the count to.; If None given, the default (first) section will be used. add_message(key, value, section=None, sep=';')[source]Â¶; Add value to message. If key does not already exist in section then; it is created with this value.; If key already exists the value is added to the message; The value will be converted to a string. Parameters:; key : string; key for the section.messages dictionary; reusing a key will result in concatenation of value. value : int; Initial value of the message, or added to an existing message. sep : string; Message will be prefixed with this string when concatenating. section: string or `class` : _StatsSection; Section which to add the message to.; If None given, the default (first) section will be used. add_section(name)[source]Â¶; Add another section with the given name. Parameters:; name : string; will be used as key for sections dict; will also be the header for the section. Returns:; section : class; The new section. add_timing(key, value, section=None)[source]Â¶; Add value to timing. If key does not already exist in section then; it is created with this value.; If key already exists it is increased by the give value; value is expected to be a float, and given in seconds. Parameters:; key : string; key for the section.timings dictionary; reusing a key will result in numerical addition of value. value : int; Initial value of the timing, or added to an existing timing. section: string or `class` : _StatsSection; Section which to add the timing to.; If None given, the default (first) section will be used. clear()[source]Â¶; Clear counts, timings and messages from all sections. report(outpu",MatchSource.WIKI,docs/4.3/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/apidoc/classes.html
https://qutip.org/docs/4.3/apidoc/classes.html:40109,Integrability,message,messages,40109,"enating. section: string or `class` : _StatsSection; Section which to add the message to.; If None given, the default (first) section will be used. add_section(name)[source]Â¶; Add another section with the given name. Parameters:; name : string; will be used as key for sections dict; will also be the header for the section. Returns:; section : class; The new section. add_timing(key, value, section=None)[source]Â¶; Add value to timing. If key does not already exist in section then; it is created with this value.; If key already exists it is increased by the give value; value is expected to be a float, and given in seconds. Parameters:; key : string; key for the section.timings dictionary; reusing a key will result in numerical addition of value. value : int; Initial value of the timing, or added to an existing timing. section: string or `class` : _StatsSection; Section which to add the timing to.; If None given, the default (first) section will be used. clear()[source]Â¶; Clear counts, timings and messages from all sections. report(output=<_io.TextIOWrapper name='<stdout>' mode='w' encoding='UTF-8'>)[source]Â¶; Report the counts, timings and messages from the sections.; Sections are reported in the order that the names were supplied; in the constructor.; The counts, timings and messages are reported in the order that they; are added to the sections; The output can be written to anything that supports a write method,; e.g. a file or the console (default); The output is intended to in markdown format. Parameters:; output : stream; file or console stream - anything that support write - where; the output will be written. set_total_time(value, section=None)[source]Â¶; Sets the total time for the complete solve or for a specific section; value is expected to be a float, and given in seconds. Parameters:; value : float; Time in seconds to complete the solver section. section : string or class; Section which to set the total_time for; If None given, the total_time for complete so",MatchSource.WIKI,docs/4.3/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/apidoc/classes.html
https://qutip.org/docs/4.3/apidoc/classes.html:40255,Integrability,message,messages,40255,"first) section will be used. add_section(name)[source]Â¶; Add another section with the given name. Parameters:; name : string; will be used as key for sections dict; will also be the header for the section. Returns:; section : class; The new section. add_timing(key, value, section=None)[source]Â¶; Add value to timing. If key does not already exist in section then; it is created with this value.; If key already exists it is increased by the give value; value is expected to be a float, and given in seconds. Parameters:; key : string; key for the section.timings dictionary; reusing a key will result in numerical addition of value. value : int; Initial value of the timing, or added to an existing timing. section: string or `class` : _StatsSection; Section which to add the timing to.; If None given, the default (first) section will be used. clear()[source]Â¶; Clear counts, timings and messages from all sections. report(output=<_io.TextIOWrapper name='<stdout>' mode='w' encoding='UTF-8'>)[source]Â¶; Report the counts, timings and messages from the sections.; Sections are reported in the order that the names were supplied; in the constructor.; The counts, timings and messages are reported in the order that they; are added to the sections; The output can be written to anything that supports a write method,; e.g. a file or the console (default); The output is intended to in markdown format. Parameters:; output : stream; file or console stream - anything that support write - where; the output will be written. set_total_time(value, section=None)[source]Â¶; Sets the total time for the complete solve or for a specific section; value is expected to be a float, and given in seconds. Parameters:; value : float; Time in seconds to complete the solver section. section : string or class; Section which to set the total_time for; If None given, the total_time for complete solve is set. class StochasticSolverOptions(H=None, state0=None, times=None, c_ops=[], sc_ops=[], e_ops=[], m_ops=None, a",MatchSource.WIKI,docs/4.3/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/apidoc/classes.html
https://qutip.org/docs/4.3/apidoc/classes.html:40394,Integrability,message,messages,40394,"he new section. add_timing(key, value, section=None)[source]Â¶; Add value to timing. If key does not already exist in section then; it is created with this value.; If key already exists it is increased by the give value; value is expected to be a float, and given in seconds. Parameters:; key : string; key for the section.timings dictionary; reusing a key will result in numerical addition of value. value : int; Initial value of the timing, or added to an existing timing. section: string or `class` : _StatsSection; Section which to add the timing to.; If None given, the default (first) section will be used. clear()[source]Â¶; Clear counts, timings and messages from all sections. report(output=<_io.TextIOWrapper name='<stdout>' mode='w' encoding='UTF-8'>)[source]Â¶; Report the counts, timings and messages from the sections.; Sections are reported in the order that the names were supplied; in the constructor.; The counts, timings and messages are reported in the order that they; are added to the sections; The output can be written to anything that supports a write method,; e.g. a file or the console (default); The output is intended to in markdown format. Parameters:; output : stream; file or console stream - anything that support write - where; the output will be written. set_total_time(value, section=None)[source]Â¶; Sets the total time for the complete solve or for a specific section; value is expected to be a float, and given in seconds. Parameters:; value : float; Time in seconds to complete the solver section. section : string or class; Section which to set the total_time for; If None given, the total_time for complete solve is set. class StochasticSolverOptions(H=None, state0=None, times=None, c_ops=[], sc_ops=[], e_ops=[], m_ops=None, args=None, ntraj=1, nsubsteps=1, d1=None, d2=None, d2_len=1, dW_factors=None, rhs=None, generate_A_ops=None, generate_noise=None, homogeneous=True, solver=None, method=None, distribution='normal', store_measurement=False, noise=None, n",MatchSource.WIKI,docs/4.3/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/apidoc/classes.html
https://qutip.org/docs/4.3/apidoc/classes.html:48935,Integrability,integrat,integrate,48935,"ce]Â¶; Build collapse operators in the full Hilbert space 2^N. Returns:; c_ops_list: list; The list with the collapse operators in the 2^N Hilbert space. coefficient_matrix()[source]Â¶; Build coefficient matrix for ODE for a diagonal problem. Returns:; M: ndarray; The matrix M of the coefficients for the ODE dp/dt = Mp.; p is the vector of the diagonal matrix elements; of the density matrix rho in the Dicke basis. lindbladian()[source]Â¶; Build the Lindbladian superoperator of the dissipative dynamics. Returns:; lindbladian: :class: qutip.Qobj; The Lindbladian matrix as a qutip.Qobj. liouvillian()[source]Â¶; Build the total Liouvillian using the Dicke basis. Returns:; liouv: :class: qutip.Qobj; The Liouvillian matrix for the system. pisolve(initial_state, tlist, options=None)[source]Â¶; Solve for diagonal Hamiltonians and initial states faster. Parameters:; initial_state: :class: qutip.Qobj; An initial state specified as a density matrix of; qutip.Qbj type. tlist: ndarray; A 1D numpy array of list of timesteps to integrate. options: :class: qutip.solver.Options; The options for the solver. Returns:; result: list; A dictionary of the type qutip.solver.Result which holds the; results of the evolution. prune_eigenstates(liouvillian)[source]Â¶; Remove spurious eigenvalues and eigenvectors of the Liouvillian.; Spurious means that the given eigenvector has elements outside of the; block-diagonal matrix. Parameters:; liouvillian_eigenstates: list; A list with the eigenvalues and eigenvectors of the Liouvillian; including spurious ones. Returns:; correct_eigenstates: list; The list with the correct eigenvalues and eigenvectors of the; Liouvillian. class Pim(N, emission=0.0, dephasing=0, pumping=0, collective_emission=0, collective_pumping=0, collective_dephasing=0)[source]Â¶; The Permutation Invariant Matrix class.; Initialize the class with the parameters for generating a Permutation; Invariant matrix which evolves a given diagonal initial state p as:. dp/dt = Mp. Parameters:; N:",MatchSource.WIKI,docs/4.3/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/apidoc/classes.html
https://qutip.org/docs/4.3/apidoc/classes.html:55327,Integrability,depend,depending,55327,"pace for each coordinate. xlabels : list; List of labels for each coordinate. marginal(dim=0)[source]Â¶; Calculate the marginal distribution function along the dimension; dim. Return a new Distribution instance describing this reduced-; dimensionality distribution. Parameters:; dim : int; The dimension (coordinate index) along which to obtain the; marginal distribution. Returns:; d : Distributions; A new instances of Distribution that describes the marginal; distribution. project(dim=0)[source]Â¶; Calculate the projection (max value) distribution function along the; dimension dim. Return a new Distribution instance describing this; reduced-dimensionality distribution. Parameters:; dim : int; The dimension (coordinate index) along which to obtain the; projected distribution. Returns:; d : Distributions; A new instances of Distribution that describes the projection. visualize(fig=None, ax=None, figsize=(8, 6), colorbar=True, cmap=None, style='colormap', show_xlabel=True, show_ylabel=True)[source]Â¶; Visualize the data of the distribution in 1D or 2D, depending; on the dimensionality of the underlaying distribution.; Parameters:. fig : matplotlib Figure instance; If given, use this figure instance for the visualization,; ax : matplotlib Axes instance; If given, render the visualization using this axis instance.; figsize : tuple; Size of the new Figure instance, if one needs to be created.; colorbar: Bool; Whether or not the colorbar (in 2D visualization) should be used.; cmap: matplotlib colormap instance; If given, use this colormap for 2D visualizations.; style : string; Type of visualization: âcolormapâ (default) or âsurfaceâ. Returns:; fig, ax : tuple; A tuple of matplotlib figure and axes instances. class WignerDistribution(rho=None, extent=[[-5, 5], [-5, 5]], steps=250)[source]Â¶. class QDistribution(rho=None, extent=[[-5, 5], [-5, 5]], steps=250)[source]Â¶. class TwoModeQuadratureCorrelation(state=None, theta1=0.0, theta2=0.0, extent=[[-5, 5], [-5, 5]], steps=250)[sou",MatchSource.WIKI,docs/4.3/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/apidoc/classes.html
https://qutip.org/docs/4.3/apidoc/classes.html:68198,Integrability,message,message,68198,"; Dynamics instance - describes the dynamics of the (quantum) system. to be control optimised. Attributes:; log_level : integer; level of messaging output from the logger.; Options are attributes of qutip.logging_utils,; in decreasing levels of messaging, are:; DEBUG_INTENSE, DEBUG_VERBOSE, DEBUG, INFO, WARN, ERROR, CRITICAL; Anything WARN or above is effectively âquietâ execution,; assuming everything runs as expected.; The default NOTSET implies that the level will be taken from; the QuTiP settings file, which by default is WARN. params: Dictionary; The key value pairs are the attribute name and value; Note: attributes are created if they do not exist already,; and are overwritten if they do. alg : string; Algorithm to use in pulse optimisation.; Options are:. âGRAPEâ (default) - GRadient Ascent Pulse Engineering; âCRABâ - Chopped RAndom Basis. alg_params : Dictionary; options that are specific to the pulse optim algorithm; that is GRAPE or CRAB. disp_conv_msg : bool; Set true to display a convergence message; (for scipy.optimize.minimize methods anyway). optim_method : string; a scipy.optimize.minimize method that will be used to optimise; the pulse for minimum fidelity error. method_params : Dictionary; Options for the optim_method.; Note that where there is an equivalent attribute of this instance; or the termination_conditions (for example maxiter); it will override an value in these options. approx_grad : bool; If set True then the method will approximate the gradient itself; (if it has requirement and facility for this); This will mean that the fid_err_grad_wrapper will not get called; Note it should be left False when using the Dynamics; to calculate approximate gradients; Note it is set True automatically when the alg is CRAB. amp_lbound : float or list of floats; lower boundaries for the control amplitudes; Can be a scalar value applied to all controls; or a list of bounds for each control. amp_ubound : float or list of floats; upper boundaries for the con",MatchSource.WIKI,docs/4.3/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/apidoc/classes.html
https://qutip.org/docs/4.3/apidoc/classes.html:74265,Integrability,wrap,wrapper,74265,"ation algorithm as the gradients of; func to the minimised wrt the variables. The argument is the current; variable values, i.e. control amplitudes, passed as; a flat array. Hence these are reshaped as [nTimeslots, n_ctrls]; and then used to update the stored ctrl values (if they have changed); Although the optimisation algorithms have a check within them for; function convergence, i.e. local minima, the sum of the squares; of the normalised gradient is checked explicitly, and the; optimisation is terminated if this is below the min_gradient_norm; condition. init_optim(term_conds)[source]Â¶; Check optimiser attribute status and passed parameters before; running the optimisation.; This is called by run_optimization, but could called independently; to check the configuration. iter_step_callback_func(*args)[source]Â¶; Check the elapsed wall time for the optimisation run so far.; Terminate if this has exceeded the maximum allowed time. run_optimization(term_conds=None)[source]Â¶; This default function optimisation method is a wrapper to the; scipy.optimize.minimize function.; It will attempt to minimise the fidelity error with respect to some; parameters, which are determined by _get_optim_var_vals (see below); The optimisation end when one of the passed termination conditions; has been met, e.g. target achieved, wall time, or; function call or iteration count exceeded. Note these; conditions include gradient minimum met (local minima) for; methods that use a gradient.; The function minimisation method is taken from the optim_method; attribute. Note that not all of these methods have been tested.; Note that some of these use a gradient and some do not.; See the scipy documentation for details. Options specific to the; method can be passed setting the method_params attribute.; If the parameter term_conds=None, then the termination_conditions; attribute must already be set. It will be overwritten if the; parameter is not None; The result is returned in an OptimResult object,",MatchSource.WIKI,docs/4.3/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/apidoc/classes.html
https://qutip.org/docs/4.3/apidoc/classes.html:75808,Integrability,wrap,wrapper,75808,"all of these methods have been tested.; Note that some of these use a gradient and some do not.; See the scipy documentation for details. Options specific to the; method can be passed setting the method_params attribute.; If the parameter term_conds=None, then the termination_conditions; attribute must already be set. It will be overwritten if the; parameter is not None; The result is returned in an OptimResult object, which includes; the final fidelity, time evolution, reason for termination etc. class OptimizerBFGS(config, dyn, params=None)[source]Â¶; Implements the run_optimization method using the BFGS algorithm. run_optimization(term_conds=None)[source]Â¶; Optimise the control pulse amplitudes to minimise the fidelity error; using the BFGS (BroydenâFletcherâGoldfarbâShanno) algorithm; The optimisation end when one of the passed termination conditions; has been met, e.g. target achieved, gradient minimum met; (local minima), wall time / iteration count exceeded.; Essentially this is wrapper to the:; scipy.optimize.fmin_bfgs; function; If the parameter term_conds=None, then the termination_conditions; attribute must already be set. It will be overwritten if the; parameter is not None; The result is returned in an OptimResult object, which includes; the final fidelity, time evolution, reason for termination etc. class OptimizerLBFGSB(config, dyn, params=None)[source]Â¶; Implements the run_optimization method using the L-BFGS-B algorithm. Attributes:; max_metric_corr : integer; The maximum number of variable metric corrections used to define; the limited memory matrix. That is the number of previous; gradient values that are used to approximate the Hessian; see the scipy.optimize.fmin_l_bfgs_b documentation for description; of m argument. init_optim(term_conds)[source]Â¶; Check optimiser attribute status and passed parameters before; running the optimisation.; This is called by run_optimization, but could called independently; to check the configuration. run_optimizatio",MatchSource.WIKI,docs/4.3/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/apidoc/classes.html
https://qutip.org/docs/4.3/apidoc/classes.html:77270,Integrability,wrap,wrapper,77270,"ttributes:; max_metric_corr : integer; The maximum number of variable metric corrections used to define; the limited memory matrix. That is the number of previous; gradient values that are used to approximate the Hessian; see the scipy.optimize.fmin_l_bfgs_b documentation for description; of m argument. init_optim(term_conds)[source]Â¶; Check optimiser attribute status and passed parameters before; running the optimisation.; This is called by run_optimization, but could called independently; to check the configuration. run_optimization(term_conds=None)[source]Â¶; Optimise the control pulse amplitudes to minimise the fidelity error; using the L-BFGS-B algorithm, which is the constrained; (bounded amplitude values), limited memory, version of the; BroydenâFletcherâGoldfarbâShanno algorithm.; The optimisation end when one of the passed termination conditions; has been met, e.g. target achieved, gradient minimum met; (local minima), wall time / iteration count exceeded.; Essentially this is wrapper to the:; scipy.optimize.fmin_l_bfgs_b function; This in turn is a warpper for well established implementation of; the L-BFGS-B algorithm written in Fortran, which is therefore; very fast. See SciPy documentation for credit and details on; this function.; If the parameter term_conds=None, then the termination_conditions; attribute must already be set. It will be overwritten if the; parameter is not None; The result is returned in an OptimResult object, which includes; the final fidelity, time evolution, reason for termination etc. class OptimizerCrab(config, dyn, params=None)[source]Â¶; Optimises the pulse using the CRAB algorithm [1].; It uses the scipy.optimize.minimize function with the method specified; by the optim_method attribute. See Optimizer.run_optimization for details; It minimises the fidelity error function with respect to the CRAB; basis function coefficients.; AJGP ToDo: Add citation here. init_optim(term_conds)[source]Â¶; Check optimiser attribute status and passed",MatchSource.WIKI,docs/4.3/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/apidoc/classes.html
https://qutip.org/docs/4.3/apidoc/classes.html:78592,Integrability,wrap,wrapper,78592,"ditions; attribute must already be set. It will be overwritten if the; parameter is not None; The result is returned in an OptimResult object, which includes; the final fidelity, time evolution, reason for termination etc. class OptimizerCrab(config, dyn, params=None)[source]Â¶; Optimises the pulse using the CRAB algorithm [1].; It uses the scipy.optimize.minimize function with the method specified; by the optim_method attribute. See Optimizer.run_optimization for details; It minimises the fidelity error function with respect to the CRAB; basis function coefficients.; AJGP ToDo: Add citation here. init_optim(term_conds)[source]Â¶; Check optimiser attribute status and passed parameters before; running the optimisation.; This is called by run_optimization, but could called independently; to check the configuration. class OptimizerCrabFmin(config, dyn, params=None)[source]Â¶; Optimises the pulse using the CRAB algorithm [1, 2].; It uses the scipy.optimize.fmin function which is effectively a wrapper; for the Nelder-mead method.; It minimises the fidelity error function with respect to the CRAB; basis function coefficients.; This is the default Optimizer for CRAB.; Notes. [1] P. Doria, T. Calarco & S. Montangero. Phys. Rev. Lett. 106,; 190501 (2011). [2] T. Caneva, T. Calarco, & S. Montangero. Phys. Rev. A 84, 022326 (2011). run_optimization(term_conds=None)[source]Â¶; This function optimisation method is a wrapper to the; scipy.optimize.fmin function.; It will attempt to minimise the fidelity error with respect to some; parameters, which are determined by _get_optim_var_vals which; in the case of CRAB are the basis function coefficients; The optimisation end when one of the passed termination conditions; has been met, e.g. target achieved, wall time, or; function call or iteration count exceeded. Specifically to the fmin; method, the optimisation will stop when change parameter values; is less than xtol or the change in function value is below ftol.; If the parameter term_c",MatchSource.WIKI,docs/4.3/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/apidoc/classes.html
https://qutip.org/docs/4.3/apidoc/classes.html:79014,Integrability,wrap,wrapper,79014,"pecified; by the optim_method attribute. See Optimizer.run_optimization for details; It minimises the fidelity error function with respect to the CRAB; basis function coefficients.; AJGP ToDo: Add citation here. init_optim(term_conds)[source]Â¶; Check optimiser attribute status and passed parameters before; running the optimisation.; This is called by run_optimization, but could called independently; to check the configuration. class OptimizerCrabFmin(config, dyn, params=None)[source]Â¶; Optimises the pulse using the CRAB algorithm [1, 2].; It uses the scipy.optimize.fmin function which is effectively a wrapper; for the Nelder-mead method.; It minimises the fidelity error function with respect to the CRAB; basis function coefficients.; This is the default Optimizer for CRAB.; Notes. [1] P. Doria, T. Calarco & S. Montangero. Phys. Rev. Lett. 106,; 190501 (2011). [2] T. Caneva, T. Calarco, & S. Montangero. Phys. Rev. A 84, 022326 (2011). run_optimization(term_conds=None)[source]Â¶; This function optimisation method is a wrapper to the; scipy.optimize.fmin function.; It will attempt to minimise the fidelity error with respect to some; parameters, which are determined by _get_optim_var_vals which; in the case of CRAB are the basis function coefficients; The optimisation end when one of the passed termination conditions; has been met, e.g. target achieved, wall time, or; function call or iteration count exceeded. Specifically to the fmin; method, the optimisation will stop when change parameter values; is less than xtol or the change in function value is below ftol.; If the parameter term_conds=None, then the termination_conditions; attribute must already be set. It will be overwritten if the; parameter is not None; The result is returned in an OptimResult object, which includes; the final fidelity, time evolution, reason for termination etc. class OptimIterSummary[source]Â¶; A summary of the most recent iteration of the pulse optimisation. Attributes:; iter_num : int; Itera",MatchSource.WIKI,docs/4.3/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/apidoc/classes.html
https://qutip.org/docs/4.3/apidoc/classes.html:95193,Integrability,message,message,95193,"ation. The âcustomâ option assumes that the _apply_phase method has been; set to a custom function. propÂ¶; List of propagators (Qobj) for each timeslot. prop_gradÂ¶; Array of propagator gradients (Qobj) for each timeslot, control. refresh_drift_attribs()[source]Â¶; Reset the dyn_shape, dyn_dims and time_depend_drift attribs. save_amps(file_name=None, times=None, amps=None, verbose=False)[source]Â¶; Save a file with the current control amplitudes in each timeslot; The first column in the file will be the start time of the slot. Parameters:; file_name : string; Name of the file; If None given the def_amps_fname attribuite will be used. times : List type (or string); List / array of the start times for each slot; If None given this will be retrieved through get_amp_times(); If âexcludeâ then times will not be saved in the file, just; the amplitudes. amps : Array[num_tslots, num_ctrls]; Amplitudes to be saved; If None given the ctrl_amps attribute will be used. verbose : Boolean; If True then an info message will be logged. unitarity_check()[source]Â¶; Checks whether all propagators are unitary. update_ctrl_amps(new_amps)[source]Â¶; Determine if any amplitudes have changed. If so, then mark the; timeslots as needing recalculation; The actual work is completed by the compare_amps method of the; timeslot computer. class DynamicsGenMat(optimconfig, params=None)[source]Â¶; This sub class can be used for any system where no additional; operator is applied to the dynamics generator before calculating; the propagator, e.g. classical dynamics, Lindbladian. class DynamicsUnitary(optimconfig, params=None)[source]Â¶; This is the subclass to use for systems with dynamics described by; unitary matrices. E.g. closed systems with Hermitian Hamiltonians; Note a matrix diagonalisation is used to compute the exponent; The eigen decomposition is also used to calculate the propagator gradient.; The method is taken from DYNAMO (see file header). Attributes:; drift_ham : Qobj; This is the drift Ham",MatchSource.WIKI,docs/4.3/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/apidoc/classes.html
https://qutip.org/docs/4.3/apidoc/classes.html:123404,Integrability,depend,depends,123404,time the gradient is computed; (It is only computed if any amplitudes changed since the last call). num_ctrl_amp_updates : integer; Number of times the control amplitudes are updated. mean_num_ctrl_amp_updates_per_iter : float; Mean number of control amplitude updates per iteration. num_timeslot_changes : integer; Number of times the amplitudes of a any control in a timeslot changes. mean_num_timeslot_changes_per_update : float; Mean average number of timeslot amplitudes that are changed per update. num_ctrl_amp_changes : integer; Number of times individual control amplitudes that are changed. mean_num_ctrl_amp_changes_per_update : float; Mean average number of control amplitudes that are changed per update. calculate()[source]Â¶; Perform the calculations (e.g. averages) that are required on the stats; Should be called before calling report. report()[source]Â¶; Print a report of the stats to the console. class Dump[source]Â¶; A container for dump items.; The lists for dump items is depends on the type; Note: abstract class. Attributes:; parent : some control object (Dynamics or Optimizer); aka the host. Object that generates the data that is dumped and is; host to this dump object. dump_dir : str; directory where files (if any) will be written out; the path and be relative or absolute; use ~/ to specify user home directory; Note: files are only written when write_to_file is True; of writeout is called explicitly; Defaults to ~/.qtrl_dump. level : string; The level of data dumping that will occur - SUMMARY : A summary will be recorded - FULL : All possible dumping - CUSTOM : Some customised level of dumping When first set to CUSTOM this is equivalent to SUMMARY. write_to_file : bool; When set True data and summaries (as configured) will be written; interactively to file during the processing; Set during instantiation by the host based on its dump_to_file attrib. dump_file_ext : str; Default file extension for any file names that are auto generated. fname_base : str; Fir,MatchSource.WIKI,docs/4.3/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/apidoc/classes.html
https://qutip.org/docs/4.3/apidoc/classes.html:24430,Modifiability,coupling,coupling,24430,"good introduction, and perhaps closest to the notation used here is:; DOI:10.1103/PhysRevLett.104.250401; A more canonical reference, with full derivation is:; DOI: 10.1103/PhysRevA.41.6676; The method can compute open system dynamics without using any Markovian; or rotating wave approximation (RWA) for systems where the bath; correlations can be approximated to a sum of complex eponentials.; The method builds a matrix of linked differential equations, which are; then solved used the same ODE solvers as other qutip solvers (e.g. mesolve); This class should be treated as abstract. Currently the only subclass; implemented is that for the Drude-Lorentz spectral density. This covers; the majority of the work that has been done using this model, and there; are some performance advantages to assuming this model where it is; appropriate.; There are opportunities to develop a more general spectral density code. Attributes:; H_sys : Qobj; System Hamiltonian. coup_op : Qobj; Operator describing the coupling between system and bath. coup_strength : float; Coupling strength. temperature : float; Bath temperature, in units corresponding to planck. N_cut : int; Cutoff parameter for the bath. N_exp : int; Number of exponential terms used to approximate the bath correlation; functions. planck : float; reduced Planck constant. boltzmann : float; Boltzmannâs constant. options : qutip.solver.Options; Generic solver options.; If set to None the default options will be used. progress_bar: BaseProgressBar; Optional instance of BaseProgressBar, or a subclass thereof, for; showing the progress of the simulation. stats : qutip.solver.Stats; optional container for holding performance statitics; If None is set, then statistics are not collected; There may be an overhead in collecting statistics. exp_coeff : list of complex; Coefficients for the exponential series terms. exp_freq : list of complex; Frequencies for the exponential series terms. configure(H_sys, coup_op, coup_strength, temperatu",MatchSource.WIKI,docs/4.3/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/apidoc/classes.html
https://qutip.org/docs/4.3/apidoc/classes.html:25376,Modifiability,config,configure,25376,"re, in units corresponding to planck. N_cut : int; Cutoff parameter for the bath. N_exp : int; Number of exponential terms used to approximate the bath correlation; functions. planck : float; reduced Planck constant. boltzmann : float; Boltzmannâs constant. options : qutip.solver.Options; Generic solver options.; If set to None the default options will be used. progress_bar: BaseProgressBar; Optional instance of BaseProgressBar, or a subclass thereof, for; showing the progress of the simulation. stats : qutip.solver.Stats; optional container for holding performance statitics; If None is set, then statistics are not collected; There may be an overhead in collecting statistics. exp_coeff : list of complex; Coefficients for the exponential series terms. exp_freq : list of complex; Frequencies for the exponential series terms. configure(H_sys, coup_op, coup_strength, temperature, N_cut, N_exp, planck=None, boltzmann=None, renorm=None, bnd_cut_approx=None, options=None, progress_bar=None, stats=None)[source]Â¶; Configure the solver using the passed parameters; The parameters are described in the class attributes, unless there; is some specific behaviour. Parameters:; options : qutip.solver.Options; Generic solver options.; If set to None the default options will be used. progress_bar: BaseProgressBar; Optional instance of BaseProgressBar, or a subclass thereof, for; showing the progress of the simulation.; If set to None, then the default progress bar will be used; Set to False for no progress bar. stats: :class:`qutip.solver.Stats`; Optional instance of solver.Stats, or a subclass thereof, for; storing performance statistics for the solver; If set to True, then the default Stats for this class will be used; Set to False for no stats. create_new_stats()[source]Â¶; Creates a new stats object suitable for use with this solver; Note: this solver expects the stats object to have sections. config; integrate. reset()[source]Â¶; Reset any attributes to default values. class HSolve",MatchSource.WIKI,docs/4.3/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/apidoc/classes.html
https://qutip.org/docs/4.3/apidoc/classes.html:26452,Modifiability,config,config,26452,"tzmann=None, renorm=None, bnd_cut_approx=None, options=None, progress_bar=None, stats=None)[source]Â¶; Configure the solver using the passed parameters; The parameters are described in the class attributes, unless there; is some specific behaviour. Parameters:; options : qutip.solver.Options; Generic solver options.; If set to None the default options will be used. progress_bar: BaseProgressBar; Optional instance of BaseProgressBar, or a subclass thereof, for; showing the progress of the simulation.; If set to None, then the default progress bar will be used; Set to False for no progress bar. stats: :class:`qutip.solver.Stats`; Optional instance of solver.Stats, or a subclass thereof, for; storing performance statistics for the solver; If set to True, then the default Stats for this class will be used; Set to False for no stats. create_new_stats()[source]Â¶; Creates a new stats object suitable for use with this solver; Note: this solver expects the stats object to have sections. config; integrate. reset()[source]Â¶; Reset any attributes to default values. class HSolverDL(H_sys, coup_op, coup_strength, temperature, N_cut, N_exp, cut_freq, planck=1.0, boltzmann=1.0, renorm=True, bnd_cut_approx=True, options=None, progress_bar=None, stats=None)[source]Â¶; HEOM solver based on the Drude-Lorentz model for spectral density.; Drude-Lorentz bath the correlation functions can be exactly analytically; expressed as an infinite sum of exponentials which depend on the; temperature, these are called the Matsubara terms or Matsubara frequencies; For practical computation purposes an approximation must be used based; on a small number of Matsubara terms (typically < 4). Attributes:; cut_freq : float; Bath spectral density cutoff frequency. renorm : bool; Apply renormalisation to coupling terms; Can be useful if using SI units for planck and boltzmann. bnd_cut_approx : bool; Use boundary cut off approximation; Can be. configure(H_sys, coup_op, coup_strength, temperature, N_cut, N_exp, cu",MatchSource.WIKI,docs/4.3/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/apidoc/classes.html
https://qutip.org/docs/4.3/apidoc/classes.html:27250,Modifiability,coupling,coupling,27250," used; Set to False for no stats. create_new_stats()[source]Â¶; Creates a new stats object suitable for use with this solver; Note: this solver expects the stats object to have sections. config; integrate. reset()[source]Â¶; Reset any attributes to default values. class HSolverDL(H_sys, coup_op, coup_strength, temperature, N_cut, N_exp, cut_freq, planck=1.0, boltzmann=1.0, renorm=True, bnd_cut_approx=True, options=None, progress_bar=None, stats=None)[source]Â¶; HEOM solver based on the Drude-Lorentz model for spectral density.; Drude-Lorentz bath the correlation functions can be exactly analytically; expressed as an infinite sum of exponentials which depend on the; temperature, these are called the Matsubara terms or Matsubara frequencies; For practical computation purposes an approximation must be used based; on a small number of Matsubara terms (typically < 4). Attributes:; cut_freq : float; Bath spectral density cutoff frequency. renorm : bool; Apply renormalisation to coupling terms; Can be useful if using SI units for planck and boltzmann. bnd_cut_approx : bool; Use boundary cut off approximation; Can be. configure(H_sys, coup_op, coup_strength, temperature, N_cut, N_exp, cut_freq, planck=None, boltzmann=None, renorm=None, bnd_cut_approx=None, options=None, progress_bar=None, stats=None)[source]Â¶; Calls configure from HEOMSolver and sets any attributes; that are specific to this subclass. reset()[source]Â¶; Reset any attributes to default values. run(rho0, tlist)[source]Â¶; Function to solve for an open quantum system using the; HEOM model. Parameters:; rho0 : Qobj; Initial state (density matrix) of the system. tlist : list; Time over which system evolves. Returns:; results : qutip.solver.Result; Object storing all results from the simulation. class MemoryCascade(H_S, L1, L2, S_matrix=None, c_ops_markov=None, integrator='propagator', parallel=False, options=None)[source]Â¶; Class for running memory cascade simulations of open quantum systems; with time-delayed cohere",MatchSource.WIKI,docs/4.3/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/apidoc/classes.html
https://qutip.org/docs/4.3/apidoc/classes.html:27391,Modifiability,config,configure,27391," HSolverDL(H_sys, coup_op, coup_strength, temperature, N_cut, N_exp, cut_freq, planck=1.0, boltzmann=1.0, renorm=True, bnd_cut_approx=True, options=None, progress_bar=None, stats=None)[source]Â¶; HEOM solver based on the Drude-Lorentz model for spectral density.; Drude-Lorentz bath the correlation functions can be exactly analytically; expressed as an infinite sum of exponentials which depend on the; temperature, these are called the Matsubara terms or Matsubara frequencies; For practical computation purposes an approximation must be used based; on a small number of Matsubara terms (typically < 4). Attributes:; cut_freq : float; Bath spectral density cutoff frequency. renorm : bool; Apply renormalisation to coupling terms; Can be useful if using SI units for planck and boltzmann. bnd_cut_approx : bool; Use boundary cut off approximation; Can be. configure(H_sys, coup_op, coup_strength, temperature, N_cut, N_exp, cut_freq, planck=None, boltzmann=None, renorm=None, bnd_cut_approx=None, options=None, progress_bar=None, stats=None)[source]Â¶; Calls configure from HEOMSolver and sets any attributes; that are specific to this subclass. reset()[source]Â¶; Reset any attributes to default values. run(rho0, tlist)[source]Â¶; Function to solve for an open quantum system using the; HEOM model. Parameters:; rho0 : Qobj; Initial state (density matrix) of the system. tlist : list; Time over which system evolves. Returns:; results : qutip.solver.Result; Object storing all results from the simulation. class MemoryCascade(H_S, L1, L2, S_matrix=None, c_ops_markov=None, integrator='propagator', parallel=False, options=None)[source]Â¶; Class for running memory cascade simulations of open quantum systems; with time-delayed coherent feedback. Attributes:; H_S : qutip.Qobj; System Hamiltonian (can also be a Liouvillian). L1 : qutip.Qobj / list of qutip.Qobj; System operators coupling into the feedback loop. Can be a single; operator or a list of operators. L2 : qutip.Qobj / list of qutip.Qobj; S",MatchSource.WIKI,docs/4.3/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/apidoc/classes.html
https://qutip.org/docs/4.3/apidoc/classes.html:27593,Modifiability,config,configure,27593," HSolverDL(H_sys, coup_op, coup_strength, temperature, N_cut, N_exp, cut_freq, planck=1.0, boltzmann=1.0, renorm=True, bnd_cut_approx=True, options=None, progress_bar=None, stats=None)[source]Â¶; HEOM solver based on the Drude-Lorentz model for spectral density.; Drude-Lorentz bath the correlation functions can be exactly analytically; expressed as an infinite sum of exponentials which depend on the; temperature, these are called the Matsubara terms or Matsubara frequencies; For practical computation purposes an approximation must be used based; on a small number of Matsubara terms (typically < 4). Attributes:; cut_freq : float; Bath spectral density cutoff frequency. renorm : bool; Apply renormalisation to coupling terms; Can be useful if using SI units for planck and boltzmann. bnd_cut_approx : bool; Use boundary cut off approximation; Can be. configure(H_sys, coup_op, coup_strength, temperature, N_cut, N_exp, cut_freq, planck=None, boltzmann=None, renorm=None, bnd_cut_approx=None, options=None, progress_bar=None, stats=None)[source]Â¶; Calls configure from HEOMSolver and sets any attributes; that are specific to this subclass. reset()[source]Â¶; Reset any attributes to default values. run(rho0, tlist)[source]Â¶; Function to solve for an open quantum system using the; HEOM model. Parameters:; rho0 : Qobj; Initial state (density matrix) of the system. tlist : list; Time over which system evolves. Returns:; results : qutip.solver.Result; Object storing all results from the simulation. class MemoryCascade(H_S, L1, L2, S_matrix=None, c_ops_markov=None, integrator='propagator', parallel=False, options=None)[source]Â¶; Class for running memory cascade simulations of open quantum systems; with time-delayed coherent feedback. Attributes:; H_S : qutip.Qobj; System Hamiltonian (can also be a Liouvillian). L1 : qutip.Qobj / list of qutip.Qobj; System operators coupling into the feedback loop. Can be a single; operator or a list of operators. L2 : qutip.Qobj / list of qutip.Qobj; S",MatchSource.WIKI,docs/4.3/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/apidoc/classes.html
https://qutip.org/docs/4.3/apidoc/classes.html:27942,Modifiability,evolve,evolves,27942,"d on the; temperature, these are called the Matsubara terms or Matsubara frequencies; For practical computation purposes an approximation must be used based; on a small number of Matsubara terms (typically < 4). Attributes:; cut_freq : float; Bath spectral density cutoff frequency. renorm : bool; Apply renormalisation to coupling terms; Can be useful if using SI units for planck and boltzmann. bnd_cut_approx : bool; Use boundary cut off approximation; Can be. configure(H_sys, coup_op, coup_strength, temperature, N_cut, N_exp, cut_freq, planck=None, boltzmann=None, renorm=None, bnd_cut_approx=None, options=None, progress_bar=None, stats=None)[source]Â¶; Calls configure from HEOMSolver and sets any attributes; that are specific to this subclass. reset()[source]Â¶; Reset any attributes to default values. run(rho0, tlist)[source]Â¶; Function to solve for an open quantum system using the; HEOM model. Parameters:; rho0 : Qobj; Initial state (density matrix) of the system. tlist : list; Time over which system evolves. Returns:; results : qutip.solver.Result; Object storing all results from the simulation. class MemoryCascade(H_S, L1, L2, S_matrix=None, c_ops_markov=None, integrator='propagator', parallel=False, options=None)[source]Â¶; Class for running memory cascade simulations of open quantum systems; with time-delayed coherent feedback. Attributes:; H_S : qutip.Qobj; System Hamiltonian (can also be a Liouvillian). L1 : qutip.Qobj / list of qutip.Qobj; System operators coupling into the feedback loop. Can be a single; operator or a list of operators. L2 : qutip.Qobj / list of qutip.Qobj; System operators coupling out of the feedback loop. Can be a single; operator or a list of operators. L2 must have the same length as L1. S_matrix: *array*; S matrix describing which operators in L1 are coupled to which; operators in L2 by the feedback channel. Defaults to an n by n identity; matrix where n is the number of elements in L1/L2. c_ops_markov : qutip.Qobj / list of qutip.Qobj; ",MatchSource.WIKI,docs/4.3/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/apidoc/classes.html
https://qutip.org/docs/4.3/apidoc/classes.html:28413,Modifiability,coupling,coupling,28413,"coup_strength, temperature, N_cut, N_exp, cut_freq, planck=None, boltzmann=None, renorm=None, bnd_cut_approx=None, options=None, progress_bar=None, stats=None)[source]Â¶; Calls configure from HEOMSolver and sets any attributes; that are specific to this subclass. reset()[source]Â¶; Reset any attributes to default values. run(rho0, tlist)[source]Â¶; Function to solve for an open quantum system using the; HEOM model. Parameters:; rho0 : Qobj; Initial state (density matrix) of the system. tlist : list; Time over which system evolves. Returns:; results : qutip.solver.Result; Object storing all results from the simulation. class MemoryCascade(H_S, L1, L2, S_matrix=None, c_ops_markov=None, integrator='propagator', parallel=False, options=None)[source]Â¶; Class for running memory cascade simulations of open quantum systems; with time-delayed coherent feedback. Attributes:; H_S : qutip.Qobj; System Hamiltonian (can also be a Liouvillian). L1 : qutip.Qobj / list of qutip.Qobj; System operators coupling into the feedback loop. Can be a single; operator or a list of operators. L2 : qutip.Qobj / list of qutip.Qobj; System operators coupling out of the feedback loop. Can be a single; operator or a list of operators. L2 must have the same length as L1. S_matrix: *array*; S matrix describing which operators in L1 are coupled to which; operators in L2 by the feedback channel. Defaults to an n by n identity; matrix where n is the number of elements in L1/L2. c_ops_markov : qutip.Qobj / list of qutip.Qobj; Decay operators describing conventional Markovian decay channels.; Can be a single operator or a list of operators. integrator : str {âpropagatorâ, âmesolveâ}; Integrator method to use. Defaults to âpropagatorâ which tends to be; faster for long times (i.e., large Hilbert space). parallel : bool; Run integrator in parallel if True. Only implemented for âpropagatorâ; as the integrator method. options : qutip.solver.Options; Generic solver options. outfieldcorr(rho0, blist, tlist, tau, c1",MatchSource.WIKI,docs/4.3/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/apidoc/classes.html
https://qutip.org/docs/4.3/apidoc/classes.html:28551,Modifiability,coupling,coupling,28551,"ar=None, stats=None)[source]Â¶; Calls configure from HEOMSolver and sets any attributes; that are specific to this subclass. reset()[source]Â¶; Reset any attributes to default values. run(rho0, tlist)[source]Â¶; Function to solve for an open quantum system using the; HEOM model. Parameters:; rho0 : Qobj; Initial state (density matrix) of the system. tlist : list; Time over which system evolves. Returns:; results : qutip.solver.Result; Object storing all results from the simulation. class MemoryCascade(H_S, L1, L2, S_matrix=None, c_ops_markov=None, integrator='propagator', parallel=False, options=None)[source]Â¶; Class for running memory cascade simulations of open quantum systems; with time-delayed coherent feedback. Attributes:; H_S : qutip.Qobj; System Hamiltonian (can also be a Liouvillian). L1 : qutip.Qobj / list of qutip.Qobj; System operators coupling into the feedback loop. Can be a single; operator or a list of operators. L2 : qutip.Qobj / list of qutip.Qobj; System operators coupling out of the feedback loop. Can be a single; operator or a list of operators. L2 must have the same length as L1. S_matrix: *array*; S matrix describing which operators in L1 are coupled to which; operators in L2 by the feedback channel. Defaults to an n by n identity; matrix where n is the number of elements in L1/L2. c_ops_markov : qutip.Qobj / list of qutip.Qobj; Decay operators describing conventional Markovian decay channels.; Can be a single operator or a list of operators. integrator : str {âpropagatorâ, âmesolveâ}; Integrator method to use. Defaults to âpropagatorâ which tends to be; faster for long times (i.e., large Hilbert space). parallel : bool; Run integrator in parallel if True. Only implemented for âpropagatorâ; as the integrator method. options : qutip.solver.Options; Generic solver options. outfieldcorr(rho0, blist, tlist, tau, c1=None, c2=None)[source]Â¶; Compute output field expectation value; <O_n(tn)â¦O_2(t2)O_1(t1)> for times t1,t2,â¦ and; O_i = I, b_out, b_out^dag",MatchSource.WIKI,docs/4.3/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/apidoc/classes.html
https://qutip.org/docs/4.3/apidoc/classes.html:49838,Modifiability,evolve,evolves,49838,"n initial state specified as a density matrix of; qutip.Qbj type. tlist: ndarray; A 1D numpy array of list of timesteps to integrate. options: :class: qutip.solver.Options; The options for the solver. Returns:; result: list; A dictionary of the type qutip.solver.Result which holds the; results of the evolution. prune_eigenstates(liouvillian)[source]Â¶; Remove spurious eigenvalues and eigenvectors of the Liouvillian.; Spurious means that the given eigenvector has elements outside of the; block-diagonal matrix. Parameters:; liouvillian_eigenstates: list; A list with the eigenvalues and eigenvectors of the Liouvillian; including spurious ones. Returns:; correct_eigenstates: list; The list with the correct eigenvalues and eigenvectors of the; Liouvillian. class Pim(N, emission=0.0, dephasing=0, pumping=0, collective_emission=0, collective_pumping=0, collective_dephasing=0)[source]Â¶; The Permutation Invariant Matrix class.; Initialize the class with the parameters for generating a Permutation; Invariant matrix which evolves a given diagonal initial state p as:. dp/dt = Mp. Parameters:; N: int; The number of two-level systems. emission: float; Incoherent emission coefficient (also nonradiative emission).; default: 0.0. dephasing: float; Local dephasing coefficient.; default: 0.0. pumping: float; Incoherent pumping coefficient.; default: 0.0. collective_emission: float; Collective (superradiant) emmission coefficient.; default: 0.0. collective_pumping: float; Collective pumping coefficient.; default: 0.0. collective_dephasing: float; Collective dephasing coefficient.; default: 0.0. Attributes:; N: int; The number of two-level systems. emission: float; Incoherent emission coefficient (also nonradiative emission).; default: 0.0. dephasing: float; Local dephasing coefficient.; default: 0.0. pumping: float; Incoherent pumping coefficient.; default: 0.0. collective_emission: float; Collective (superradiant) emmission coefficient.; default: 0.0. collective_dephasing: float; Collec",MatchSource.WIKI,docs/4.3/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/apidoc/classes.html
https://qutip.org/docs/4.3/apidoc/classes.html:57634,Modifiability,variab,variable,57634,"te probability distribution for quadrature measurement; outcomes given a two-mode density matrix. class HarmonicOscillatorWaveFunction(psi=None, omega=1.0, extent=[-5, 5], steps=250)[source]Â¶. update(psi)[source]Â¶; Calculate the wavefunction for the given state of an harmonic; oscillator. class HarmonicOscillatorProbabilityFunction(rho=None, omega=1.0, extent=[-5, 5], steps=250)[source]Â¶. update(rho)[source]Â¶; Calculate the probability function for the given state of an harmonic; oscillator (as density matrix). Quantum information processingÂ¶. class Gate(name, targets=None, controls=None, arg_value=None, arg_label=None)[source]Â¶; Representation of a quantum gate, with its required parametrs, and target; and control qubits. class QubitCircuit(N, input_states=None, output_states=None, reverse_states=True)[source]Â¶; Representation of a quantum program/algorithm, maintaining a sequence; of gates. add_1q_gate(name, start=0, end=None, qubits=None, arg_value=None, arg_label=None)[source]Â¶; Adds a single qubit gate with specified parameters on a variable; number of qubits in the circuit. By default, it applies the given gate; to all the qubits in the register. Parameters:; name : String; Gate name. start : Integer; Starting location of qubits. end : Integer; Last qubit for the gate. qubits : List; Specific qubits for applying gates. arg_value : Float; Argument value(phi). arg_label : String; Label for gate representation. add_circuit(qc, start=0)[source]Â¶; Adds a block of a qubit circuit to the main circuit.; Globalphase gates are not added. Parameters:; qc : QubitCircuit; The circuit block to be added to the main circuit. start : Integer; The qubit on which the first gate is applied. add_gate(gate, targets=None, controls=None, arg_value=None, arg_label=None)[source]Â¶; Adds a gate with specified parameters to the circuit. Parameters:; gate: String or `Gate`; Gate name. If gate is an instance of Gate, parameters are; unpacked and added. targets: List; Gate targets. controls: ",MatchSource.WIKI,docs/4.3/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/apidoc/classes.html
https://qutip.org/docs/4.3/apidoc/classes.html:66855,Modifiability,config,config,66855,"; qc: Qobj; The circular spin chain circuit to be resolved. rwa: Boolean; Specify if RWA is used or not. Returns:; qc: QubitCircuit; Returns QubitCircuit of resolved gates for the qubit circuit in the; desired basis. get_ops_and_u()[source]Â¶; Returns the Hamiltonian operators and corresponding values by stacking; them together. get_ops_labels()[source]Â¶; Returns the Hamiltonian operators and corresponding labels by stacking; them together. load_circuit(qc)[source]Â¶; Translates an abstract quantum circuit to its corresponding Hamiltonian; for a specific model. Parameters:; qc: QubitCircuit; Takes the quantum circuit to be implemented. optimize_circuit(qc)[source]Â¶; Function to take a quantum circuit/algorithm and convert it into the; optimal form/basis for the desired physical system. Parameters:; qc: QubitCircuit; Takes the quantum circuit to be implemented. Returns:; qc: QubitCircuit; The optimal circuit representation. Optimal controlÂ¶. class Optimizer(config, dyn, params=None)[source]Â¶; Base class for all control pulse optimisers. This class should not be; instantiated, use its subclasses; This class implements the fidelity, gradient and interation callback; functions.; All subclass objects must be initialised with a. OptimConfig instance - various configuration options; Dynamics instance - describes the dynamics of the (quantum) system. to be control optimised. Attributes:; log_level : integer; level of messaging output from the logger.; Options are attributes of qutip.logging_utils,; in decreasing levels of messaging, are:; DEBUG_INTENSE, DEBUG_VERBOSE, DEBUG, INFO, WARN, ERROR, CRITICAL; Anything WARN or above is effectively âquietâ execution,; assuming everything runs as expected.; The default NOTSET implies that the level will be taken from; the QuTiP settings file, which by default is WARN. params: Dictionary; The key value pairs are the attribute name and value; Note: attributes are created if they do not exist already,; and are overwritten if they do. alg ",MatchSource.WIKI,docs/4.3/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/apidoc/classes.html
https://qutip.org/docs/4.3/apidoc/classes.html:67158,Modifiability,config,configuration,67158," by stacking; them together. get_ops_labels()[source]Â¶; Returns the Hamiltonian operators and corresponding labels by stacking; them together. load_circuit(qc)[source]Â¶; Translates an abstract quantum circuit to its corresponding Hamiltonian; for a specific model. Parameters:; qc: QubitCircuit; Takes the quantum circuit to be implemented. optimize_circuit(qc)[source]Â¶; Function to take a quantum circuit/algorithm and convert it into the; optimal form/basis for the desired physical system. Parameters:; qc: QubitCircuit; Takes the quantum circuit to be implemented. Returns:; qc: QubitCircuit; The optimal circuit representation. Optimal controlÂ¶. class Optimizer(config, dyn, params=None)[source]Â¶; Base class for all control pulse optimisers. This class should not be; instantiated, use its subclasses; This class implements the fidelity, gradient and interation callback; functions.; All subclass objects must be initialised with a. OptimConfig instance - various configuration options; Dynamics instance - describes the dynamics of the (quantum) system. to be control optimised. Attributes:; log_level : integer; level of messaging output from the logger.; Options are attributes of qutip.logging_utils,; in decreasing levels of messaging, are:; DEBUG_INTENSE, DEBUG_VERBOSE, DEBUG, INFO, WARN, ERROR, CRITICAL; Anything WARN or above is effectively âquietâ execution,; assuming everything runs as expected.; The default NOTSET implies that the level will be taken from; the QuTiP settings file, which by default is WARN. params: Dictionary; The key value pairs are the attribute name and value; Note: attributes are created if they do not exist already,; and are overwritten if they do. alg : string; Algorithm to use in pulse optimisation.; Options are:. âGRAPEâ (default) - GRadient Ascent Pulse Engineering; âCRABâ - Chopped RAndom Basis. alg_params : Dictionary; options that are specific to the pulse optim algorithm; that is GRAPE or CRAB. disp_conv_msg : bool; Set true to display a c",MatchSource.WIKI,docs/4.3/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/apidoc/classes.html
https://qutip.org/docs/4.3/apidoc/classes.html:69749,Modifiability,config,config,69749,"lled; Note it should be left False when using the Dynamics; to calculate approximate gradients; Note it is set True automatically when the alg is CRAB. amp_lbound : float or list of floats; lower boundaries for the control amplitudes; Can be a scalar value applied to all controls; or a list of bounds for each control. amp_ubound : float or list of floats; upper boundaries for the control amplitudes; Can be a scalar value applied to all controls; or a list of bounds for each control. bounds : List of floats; Bounds for the parameters.; If not set before the run_optimization call then the list; is built automatically based on the amp_lbound and amp_ubound; attributes.; Setting this attribute directly allows specific bounds to be set; for individual parameters.; Note: Only some methods use bounds. dynamics : Dynamics (subclass instance); describes the dynamics of the (quantum) system to be control optimised; (see Dynamics classes for details). config : OptimConfig instance; various configuration options; (see OptimConfig for details). termination_conditions : TerminationCondition instance; attributes determine when the optimisation will end. pulse_generator : PulseGen (subclass instance); (can be) used to create initial pulses; not used by the class, but set by pulseoptim.create_pulse_optimizer. stats : Stats; attributes of which give performance stats for the optimisation; set to None to reduce overhead of calculating stats.; Note it is (usually) shared with the Dynamics instance. dump : dump.OptimDump; Container for data dumped during the optimisation.; Can be set by specifying the dumping level or set directly.; Note this is mainly intended for user and a development debugging; but could be used for status information during a long optimisation. dumping : string; The level of data dumping that will occur during the optimisation - NONE : No processing data dumped (Default) - SUMMARY : A summary at each iteration will be recorded - FULL : All logs will be generated and",MatchSource.WIKI,docs/4.3/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/apidoc/classes.html
https://qutip.org/docs/4.3/apidoc/classes.html:69788,Modifiability,config,configuration,69788,"lled; Note it should be left False when using the Dynamics; to calculate approximate gradients; Note it is set True automatically when the alg is CRAB. amp_lbound : float or list of floats; lower boundaries for the control amplitudes; Can be a scalar value applied to all controls; or a list of bounds for each control. amp_ubound : float or list of floats; upper boundaries for the control amplitudes; Can be a scalar value applied to all controls; or a list of bounds for each control. bounds : List of floats; Bounds for the parameters.; If not set before the run_optimization call then the list; is built automatically based on the amp_lbound and amp_ubound; attributes.; Setting this attribute directly allows specific bounds to be set; for individual parameters.; Note: Only some methods use bounds. dynamics : Dynamics (subclass instance); describes the dynamics of the (quantum) system to be control optimised; (see Dynamics classes for details). config : OptimConfig instance; various configuration options; (see OptimConfig for details). termination_conditions : TerminationCondition instance; attributes determine when the optimisation will end. pulse_generator : PulseGen (subclass instance); (can be) used to create initial pulses; not used by the class, but set by pulseoptim.create_pulse_optimizer. stats : Stats; attributes of which give performance stats for the optimisation; set to None to reduce overhead of calculating stats.; Note it is (usually) shared with the Dynamics instance. dump : dump.OptimDump; Container for data dumped during the optimisation.; Can be set by specifying the dumping level or set directly.; Note this is mainly intended for user and a development debugging; but could be used for status information during a long optimisation. dumping : string; The level of data dumping that will occur during the optimisation - NONE : No processing data dumped (Default) - SUMMARY : A summary at each iteration will be recorded - FULL : All logs will be generated and",MatchSource.WIKI,docs/4.3/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/apidoc/classes.html
https://qutip.org/docs/4.3/apidoc/classes.html:72739,Modifiability,variab,variable,72739,"scipy.optimize.minimize function. apply_params(params=None)[source]Â¶; Set object attributes based on the dictionary (if any) passed in the; instantiation, or passed as a parameter; This is called during the instantiation automatically.; The key value pairs are the attribute name and value; Note: attributes are created if they do not exist already,; and are overwritten if they do. dumpingÂ¶. The level of data dumping that will occur during the optimisation. NONE : No processing data dumped (Default); SUMMARY : A summary at each iteration will be recorded; FULL : All logs will be generated and dumped; CUSTOM : Some customised level of dumping. When first set to CUSTOM this is equivalent to SUMMARY. It is then up; to the user to specify which logs are dumped. fid_err_func_wrapper(*args)[source]Â¶; Get the fidelity error achieved using the ctrl amplitudes passed; in as the first argument.; This is called by generic optimisation algorithm as the; func to the minimised. The argument is the current; variable values, i.e. control amplitudes, passed as; a flat array. Hence these are reshaped as [nTimeslots, n_ctrls]; and then used to update the stored ctrl values (if they have changed); The error is checked against the target, and the optimisation is; terminated if the target has been achieved. fid_err_grad_wrapper(*args)[source]Â¶; Get the gradient of the fidelity error with respect to all of the; variables, i.e. the ctrl amplidutes in each timeslot; This is called by generic optimisation algorithm as the gradients of; func to the minimised wrt the variables. The argument is the current; variable values, i.e. control amplitudes, passed as; a flat array. Hence these are reshaped as [nTimeslots, n_ctrls]; and then used to update the stored ctrl values (if they have changed); Although the optimisation algorithms have a check within them for; function convergence, i.e. local minima, the sum of the squares; of the normalised gradient is checked explicitly, and the; optimisation is t",MatchSource.WIKI,docs/4.3/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/apidoc/classes.html
https://qutip.org/docs/4.3/apidoc/classes.html:73143,Modifiability,variab,variables,73143,"written if they do. dumpingÂ¶. The level of data dumping that will occur during the optimisation. NONE : No processing data dumped (Default); SUMMARY : A summary at each iteration will be recorded; FULL : All logs will be generated and dumped; CUSTOM : Some customised level of dumping. When first set to CUSTOM this is equivalent to SUMMARY. It is then up; to the user to specify which logs are dumped. fid_err_func_wrapper(*args)[source]Â¶; Get the fidelity error achieved using the ctrl amplitudes passed; in as the first argument.; This is called by generic optimisation algorithm as the; func to the minimised. The argument is the current; variable values, i.e. control amplitudes, passed as; a flat array. Hence these are reshaped as [nTimeslots, n_ctrls]; and then used to update the stored ctrl values (if they have changed); The error is checked against the target, and the optimisation is; terminated if the target has been achieved. fid_err_grad_wrapper(*args)[source]Â¶; Get the gradient of the fidelity error with respect to all of the; variables, i.e. the ctrl amplidutes in each timeslot; This is called by generic optimisation algorithm as the gradients of; func to the minimised wrt the variables. The argument is the current; variable values, i.e. control amplitudes, passed as; a flat array. Hence these are reshaped as [nTimeslots, n_ctrls]; and then used to update the stored ctrl values (if they have changed); Although the optimisation algorithms have a check within them for; function convergence, i.e. local minima, the sum of the squares; of the normalised gradient is checked explicitly, and the; optimisation is terminated if this is below the min_gradient_norm; condition. init_optim(term_conds)[source]Â¶; Check optimiser attribute status and passed parameters before; running the optimisation.; This is called by run_optimization, but could called independently; to check the configuration. iter_step_callback_func(*args)[source]Â¶; Check the elapsed wall time for the optimi",MatchSource.WIKI,docs/4.3/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/apidoc/classes.html
https://qutip.org/docs/4.3/apidoc/classes.html:73297,Modifiability,variab,variables,73297,"lt); SUMMARY : A summary at each iteration will be recorded; FULL : All logs will be generated and dumped; CUSTOM : Some customised level of dumping. When first set to CUSTOM this is equivalent to SUMMARY. It is then up; to the user to specify which logs are dumped. fid_err_func_wrapper(*args)[source]Â¶; Get the fidelity error achieved using the ctrl amplitudes passed; in as the first argument.; This is called by generic optimisation algorithm as the; func to the minimised. The argument is the current; variable values, i.e. control amplitudes, passed as; a flat array. Hence these are reshaped as [nTimeslots, n_ctrls]; and then used to update the stored ctrl values (if they have changed); The error is checked against the target, and the optimisation is; terminated if the target has been achieved. fid_err_grad_wrapper(*args)[source]Â¶; Get the gradient of the fidelity error with respect to all of the; variables, i.e. the ctrl amplidutes in each timeslot; This is called by generic optimisation algorithm as the gradients of; func to the minimised wrt the variables. The argument is the current; variable values, i.e. control amplitudes, passed as; a flat array. Hence these are reshaped as [nTimeslots, n_ctrls]; and then used to update the stored ctrl values (if they have changed); Although the optimisation algorithms have a check within them for; function convergence, i.e. local minima, the sum of the squares; of the normalised gradient is checked explicitly, and the; optimisation is terminated if this is below the min_gradient_norm; condition. init_optim(term_conds)[source]Â¶; Check optimiser attribute status and passed parameters before; running the optimisation.; This is called by run_optimization, but could called independently; to check the configuration. iter_step_callback_func(*args)[source]Â¶; Check the elapsed wall time for the optimisation run so far.; Terminate if this has exceeded the maximum allowed time. run_optimization(term_conds=None)[source]Â¶; This default fu",MatchSource.WIKI,docs/4.3/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/apidoc/classes.html
https://qutip.org/docs/4.3/apidoc/classes.html:73337,Modifiability,variab,variable,73337,"dumped; CUSTOM : Some customised level of dumping. When first set to CUSTOM this is equivalent to SUMMARY. It is then up; to the user to specify which logs are dumped. fid_err_func_wrapper(*args)[source]Â¶; Get the fidelity error achieved using the ctrl amplitudes passed; in as the first argument.; This is called by generic optimisation algorithm as the; func to the minimised. The argument is the current; variable values, i.e. control amplitudes, passed as; a flat array. Hence these are reshaped as [nTimeslots, n_ctrls]; and then used to update the stored ctrl values (if they have changed); The error is checked against the target, and the optimisation is; terminated if the target has been achieved. fid_err_grad_wrapper(*args)[source]Â¶; Get the gradient of the fidelity error with respect to all of the; variables, i.e. the ctrl amplidutes in each timeslot; This is called by generic optimisation algorithm as the gradients of; func to the minimised wrt the variables. The argument is the current; variable values, i.e. control amplitudes, passed as; a flat array. Hence these are reshaped as [nTimeslots, n_ctrls]; and then used to update the stored ctrl values (if they have changed); Although the optimisation algorithms have a check within them for; function convergence, i.e. local minima, the sum of the squares; of the normalised gradient is checked explicitly, and the; optimisation is terminated if this is below the min_gradient_norm; condition. init_optim(term_conds)[source]Â¶; Check optimiser attribute status and passed parameters before; running the optimisation.; This is called by run_optimization, but could called independently; to check the configuration. iter_step_callback_func(*args)[source]Â¶; Check the elapsed wall time for the optimisation run so far.; Terminate if this has exceeded the maximum allowed time. run_optimization(term_conds=None)[source]Â¶; This default function optimisation method is a wrapper to the; scipy.optimize.minimize function.; It will attempt ",MatchSource.WIKI,docs/4.3/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/apidoc/classes.html
https://qutip.org/docs/4.3/apidoc/classes.html:73999,Modifiability,config,configuration,73999,"get, and the optimisation is; terminated if the target has been achieved. fid_err_grad_wrapper(*args)[source]Â¶; Get the gradient of the fidelity error with respect to all of the; variables, i.e. the ctrl amplidutes in each timeslot; This is called by generic optimisation algorithm as the gradients of; func to the minimised wrt the variables. The argument is the current; variable values, i.e. control amplitudes, passed as; a flat array. Hence these are reshaped as [nTimeslots, n_ctrls]; and then used to update the stored ctrl values (if they have changed); Although the optimisation algorithms have a check within them for; function convergence, i.e. local minima, the sum of the squares; of the normalised gradient is checked explicitly, and the; optimisation is terminated if this is below the min_gradient_norm; condition. init_optim(term_conds)[source]Â¶; Check optimiser attribute status and passed parameters before; running the optimisation.; This is called by run_optimization, but could called independently; to check the configuration. iter_step_callback_func(*args)[source]Â¶; Check the elapsed wall time for the optimisation run so far.; Terminate if this has exceeded the maximum allowed time. run_optimization(term_conds=None)[source]Â¶; This default function optimisation method is a wrapper to the; scipy.optimize.minimize function.; It will attempt to minimise the fidelity error with respect to some; parameters, which are determined by _get_optim_var_vals (see below); The optimisation end when one of the passed termination conditions; has been met, e.g. target achieved, wall time, or; function call or iteration count exceeded. Note these; conditions include gradient minimum met (local minima) for; methods that use a gradient.; The function minimisation method is taken from the optim_method; attribute. Note that not all of these methods have been tested.; Note that some of these use a gradient and some do not.; See the scipy documentation for details. Options specific to",MatchSource.WIKI,docs/4.3/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/apidoc/classes.html
https://qutip.org/docs/4.3/apidoc/classes.html:75331,Modifiability,config,config,75331,"spect to some; parameters, which are determined by _get_optim_var_vals (see below); The optimisation end when one of the passed termination conditions; has been met, e.g. target achieved, wall time, or; function call or iteration count exceeded. Note these; conditions include gradient minimum met (local minima) for; methods that use a gradient.; The function minimisation method is taken from the optim_method; attribute. Note that not all of these methods have been tested.; Note that some of these use a gradient and some do not.; See the scipy documentation for details. Options specific to the; method can be passed setting the method_params attribute.; If the parameter term_conds=None, then the termination_conditions; attribute must already be set. It will be overwritten if the; parameter is not None; The result is returned in an OptimResult object, which includes; the final fidelity, time evolution, reason for termination etc. class OptimizerBFGS(config, dyn, params=None)[source]Â¶; Implements the run_optimization method using the BFGS algorithm. run_optimization(term_conds=None)[source]Â¶; Optimise the control pulse amplitudes to minimise the fidelity error; using the BFGS (BroydenâFletcherâGoldfarbâShanno) algorithm; The optimisation end when one of the passed termination conditions; has been met, e.g. target achieved, gradient minimum met; (local minima), wall time / iteration count exceeded.; Essentially this is wrapper to the:; scipy.optimize.fmin_bfgs; function; If the parameter term_conds=None, then the termination_conditions; attribute must already be set. It will be overwritten if the; parameter is not None; The result is returned in an OptimResult object, which includes; the final fidelity, time evolution, reason for termination etc. class OptimizerLBFGSB(config, dyn, params=None)[source]Â¶; Implements the run_optimization method using the L-BFGS-B algorithm. Attributes:; max_metric_corr : integer; The maximum number of variable metric corrections used to defi",MatchSource.WIKI,docs/4.3/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/apidoc/classes.html
https://qutip.org/docs/4.3/apidoc/classes.html:76164,Modifiability,config,config,76164," in an OptimResult object, which includes; the final fidelity, time evolution, reason for termination etc. class OptimizerBFGS(config, dyn, params=None)[source]Â¶; Implements the run_optimization method using the BFGS algorithm. run_optimization(term_conds=None)[source]Â¶; Optimise the control pulse amplitudes to minimise the fidelity error; using the BFGS (BroydenâFletcherâGoldfarbâShanno) algorithm; The optimisation end when one of the passed termination conditions; has been met, e.g. target achieved, gradient minimum met; (local minima), wall time / iteration count exceeded.; Essentially this is wrapper to the:; scipy.optimize.fmin_bfgs; function; If the parameter term_conds=None, then the termination_conditions; attribute must already be set. It will be overwritten if the; parameter is not None; The result is returned in an OptimResult object, which includes; the final fidelity, time evolution, reason for termination etc. class OptimizerLBFGSB(config, dyn, params=None)[source]Â¶; Implements the run_optimization method using the L-BFGS-B algorithm. Attributes:; max_metric_corr : integer; The maximum number of variable metric corrections used to define; the limited memory matrix. That is the number of previous; gradient values that are used to approximate the Hessian; see the scipy.optimize.fmin_l_bfgs_b documentation for description; of m argument. init_optim(term_conds)[source]Â¶; Check optimiser attribute status and passed parameters before; running the optimisation.; This is called by run_optimization, but could called independently; to check the configuration. run_optimization(term_conds=None)[source]Â¶; Optimise the control pulse amplitudes to minimise the fidelity error; using the L-BFGS-B algorithm, which is the constrained; (bounded amplitude values), limited memory, version of the; BroydenâFletcherâGoldfarbâShanno algorithm.; The optimisation end when one of the passed termination conditions; has been met, e.g. target achieved, gradient minimum met; (local min",MatchSource.WIKI,docs/4.3/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/apidoc/classes.html
https://qutip.org/docs/4.3/apidoc/classes.html:76331,Modifiability,variab,variable,76331,"fig, dyn, params=None)[source]Â¶; Implements the run_optimization method using the BFGS algorithm. run_optimization(term_conds=None)[source]Â¶; Optimise the control pulse amplitudes to minimise the fidelity error; using the BFGS (BroydenâFletcherâGoldfarbâShanno) algorithm; The optimisation end when one of the passed termination conditions; has been met, e.g. target achieved, gradient minimum met; (local minima), wall time / iteration count exceeded.; Essentially this is wrapper to the:; scipy.optimize.fmin_bfgs; function; If the parameter term_conds=None, then the termination_conditions; attribute must already be set. It will be overwritten if the; parameter is not None; The result is returned in an OptimResult object, which includes; the final fidelity, time evolution, reason for termination etc. class OptimizerLBFGSB(config, dyn, params=None)[source]Â¶; Implements the run_optimization method using the L-BFGS-B algorithm. Attributes:; max_metric_corr : integer; The maximum number of variable metric corrections used to define; the limited memory matrix. That is the number of previous; gradient values that are used to approximate the Hessian; see the scipy.optimize.fmin_l_bfgs_b documentation for description; of m argument. init_optim(term_conds)[source]Â¶; Check optimiser attribute status and passed parameters before; running the optimisation.; This is called by run_optimization, but could called independently; to check the configuration. run_optimization(term_conds=None)[source]Â¶; Optimise the control pulse amplitudes to minimise the fidelity error; using the L-BFGS-B algorithm, which is the constrained; (bounded amplitude values), limited memory, version of the; BroydenâFletcherâGoldfarbâShanno algorithm.; The optimisation end when one of the passed termination conditions; has been met, e.g. target achieved, gradient minimum met; (local minima), wall time / iteration count exceeded.; Essentially this is wrapper to the:; scipy.optimize.fmin_l_bfgs_b function; This in t",MatchSource.WIKI,docs/4.3/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/apidoc/classes.html
https://qutip.org/docs/4.3/apidoc/classes.html:76779,Modifiability,config,configuration,76779,"ma), wall time / iteration count exceeded.; Essentially this is wrapper to the:; scipy.optimize.fmin_bfgs; function; If the parameter term_conds=None, then the termination_conditions; attribute must already be set. It will be overwritten if the; parameter is not None; The result is returned in an OptimResult object, which includes; the final fidelity, time evolution, reason for termination etc. class OptimizerLBFGSB(config, dyn, params=None)[source]Â¶; Implements the run_optimization method using the L-BFGS-B algorithm. Attributes:; max_metric_corr : integer; The maximum number of variable metric corrections used to define; the limited memory matrix. That is the number of previous; gradient values that are used to approximate the Hessian; see the scipy.optimize.fmin_l_bfgs_b documentation for description; of m argument. init_optim(term_conds)[source]Â¶; Check optimiser attribute status and passed parameters before; running the optimisation.; This is called by run_optimization, but could called independently; to check the configuration. run_optimization(term_conds=None)[source]Â¶; Optimise the control pulse amplitudes to minimise the fidelity error; using the L-BFGS-B algorithm, which is the constrained; (bounded amplitude values), limited memory, version of the; BroydenâFletcherâGoldfarbâShanno algorithm.; The optimisation end when one of the passed termination conditions; has been met, e.g. target achieved, gradient minimum met; (local minima), wall time / iteration count exceeded.; Essentially this is wrapper to the:; scipy.optimize.fmin_l_bfgs_b function; This in turn is a warpper for well established implementation of; the L-BFGS-B algorithm written in Fortran, which is therefore; very fast. See SciPy documentation for credit and details on; this function.; If the parameter term_conds=None, then the termination_conditions; attribute must already be set. It will be overwritten if the; parameter is not None; The result is returned in an OptimResult object, which inclu",MatchSource.WIKI,docs/4.3/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/apidoc/classes.html
https://qutip.org/docs/4.3/apidoc/classes.html:77834,Modifiability,config,config,77834,"mplitudes to minimise the fidelity error; using the L-BFGS-B algorithm, which is the constrained; (bounded amplitude values), limited memory, version of the; BroydenâFletcherâGoldfarbâShanno algorithm.; The optimisation end when one of the passed termination conditions; has been met, e.g. target achieved, gradient minimum met; (local minima), wall time / iteration count exceeded.; Essentially this is wrapper to the:; scipy.optimize.fmin_l_bfgs_b function; This in turn is a warpper for well established implementation of; the L-BFGS-B algorithm written in Fortran, which is therefore; very fast. See SciPy documentation for credit and details on; this function.; If the parameter term_conds=None, then the termination_conditions; attribute must already be set. It will be overwritten if the; parameter is not None; The result is returned in an OptimResult object, which includes; the final fidelity, time evolution, reason for termination etc. class OptimizerCrab(config, dyn, params=None)[source]Â¶; Optimises the pulse using the CRAB algorithm [1].; It uses the scipy.optimize.minimize function with the method specified; by the optim_method attribute. See Optimizer.run_optimization for details; It minimises the fidelity error function with respect to the CRAB; basis function coefficients.; AJGP ToDo: Add citation here. init_optim(term_conds)[source]Â¶; Check optimiser attribute status and passed parameters before; running the optimisation.; This is called by run_optimization, but could called independently; to check the configuration. class OptimizerCrabFmin(config, dyn, params=None)[source]Â¶; Optimises the pulse using the CRAB algorithm [1, 2].; It uses the scipy.optimize.fmin function which is effectively a wrapper; for the Nelder-mead method.; It minimises the fidelity error function with respect to the CRAB; basis function coefficients.; This is the default Optimizer for CRAB.; Notes. [1] P. Doria, T. Calarco & S. Montangero. Phys. Rev. Lett. 106,; 190501 (2011). [2] T. Cane",MatchSource.WIKI,docs/4.3/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/apidoc/classes.html
https://qutip.org/docs/4.3/apidoc/classes.html:78399,Modifiability,config,configuration,78399,"ablished implementation of; the L-BFGS-B algorithm written in Fortran, which is therefore; very fast. See SciPy documentation for credit and details on; this function.; If the parameter term_conds=None, then the termination_conditions; attribute must already be set. It will be overwritten if the; parameter is not None; The result is returned in an OptimResult object, which includes; the final fidelity, time evolution, reason for termination etc. class OptimizerCrab(config, dyn, params=None)[source]Â¶; Optimises the pulse using the CRAB algorithm [1].; It uses the scipy.optimize.minimize function with the method specified; by the optim_method attribute. See Optimizer.run_optimization for details; It minimises the fidelity error function with respect to the CRAB; basis function coefficients.; AJGP ToDo: Add citation here. init_optim(term_conds)[source]Â¶; Check optimiser attribute status and passed parameters before; running the optimisation.; This is called by run_optimization, but could called independently; to check the configuration. class OptimizerCrabFmin(config, dyn, params=None)[source]Â¶; Optimises the pulse using the CRAB algorithm [1, 2].; It uses the scipy.optimize.fmin function which is effectively a wrapper; for the Nelder-mead method.; It minimises the fidelity error function with respect to the CRAB; basis function coefficients.; This is the default Optimizer for CRAB.; Notes. [1] P. Doria, T. Calarco & S. Montangero. Phys. Rev. Lett. 106,; 190501 (2011). [2] T. Caneva, T. Calarco, & S. Montangero. Phys. Rev. A 84, 022326 (2011). run_optimization(term_conds=None)[source]Â¶; This function optimisation method is a wrapper to the; scipy.optimize.fmin function.; It will attempt to minimise the fidelity error with respect to some; parameters, which are determined by _get_optim_var_vals which; in the case of CRAB are the basis function coefficients; The optimisation end when one of the passed termination conditions; has been met, e.g. target achieved, wall time, ",MatchSource.WIKI,docs/4.3/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/apidoc/classes.html
https://qutip.org/docs/4.3/apidoc/classes.html:78438,Modifiability,config,config,78438," SciPy documentation for credit and details on; this function.; If the parameter term_conds=None, then the termination_conditions; attribute must already be set. It will be overwritten if the; parameter is not None; The result is returned in an OptimResult object, which includes; the final fidelity, time evolution, reason for termination etc. class OptimizerCrab(config, dyn, params=None)[source]Â¶; Optimises the pulse using the CRAB algorithm [1].; It uses the scipy.optimize.minimize function with the method specified; by the optim_method attribute. See Optimizer.run_optimization for details; It minimises the fidelity error function with respect to the CRAB; basis function coefficients.; AJGP ToDo: Add citation here. init_optim(term_conds)[source]Â¶; Check optimiser attribute status and passed parameters before; running the optimisation.; This is called by run_optimization, but could called independently; to check the configuration. class OptimizerCrabFmin(config, dyn, params=None)[source]Â¶; Optimises the pulse using the CRAB algorithm [1, 2].; It uses the scipy.optimize.fmin function which is effectively a wrapper; for the Nelder-mead method.; It minimises the fidelity error function with respect to the CRAB; basis function coefficients.; This is the default Optimizer for CRAB.; Notes. [1] P. Doria, T. Calarco & S. Montangero. Phys. Rev. Lett. 106,; 190501 (2011). [2] T. Caneva, T. Calarco, & S. Montangero. Phys. Rev. A 84, 022326 (2011). run_optimization(term_conds=None)[source]Â¶; This function optimisation method is a wrapper to the; scipy.optimize.fmin function.; It will attempt to minimise the fidelity error with respect to some; parameters, which are determined by _get_optim_var_vals which; in the case of CRAB are the basis function coefficients; The optimisation end when one of the passed termination conditions; has been met, e.g. target achieved, wall time, or; function call or iteration count exceeded. Specifically to the fmin; method, the optimisation will st",MatchSource.WIKI,docs/4.3/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/apidoc/classes.html
https://qutip.org/docs/4.3/apidoc/classes.html:93551,Modifiability,config,configuration,93551,"ion operators (Qobj) from the initial to the given; timeslot. get_ctrl_dyn_gen(j)[source]Â¶; Get the dynamics generator for the control; Not implemented in the base class. Choose a subclass. get_drift_dim()[source]Â¶; Returns the size of the matrix that defines the drift dynamics; that is assuming the drift is NxN, then this returns N. get_dyn_gen(k)[source]Â¶; Get the combined dynamics generator for the timeslot; Not implemented in the base class. Choose a subclass. get_num_ctrls()[source]Â¶; calculate the of controls from the length of the control list; sets the num_ctrls property, which can be used alternatively; subsequently. init_timeslots()[source]Â¶; Generate the timeslot duration array âtauâ based on the evo_time; and num_tslots attributes, unless the tau attribute is already set; in which case this step in ignored; Generate the cumulative time array âtimeâ based on the tau values. initialize_controls(amps, init_tslots=True)[source]Â¶; Set the initial control amplitudes and time slices; Note this must be called after the configuration is complete; before any dynamics can be calculated. num_ctrlsÂ¶; calculate the of controls from the length of the control list; sets the num_ctrls property, which can be used alternatively; subsequently. onto_evoÂ¶; List of evolution operators (Qobj) from the initial to the given; timeslot. onwd_evoÂ¶; List of evolution operators (Qobj) from the initial to the given; timeslot. phase_applicationÂ¶; phase_application â scalar(string), default=âpreopâ; Determines how the phase is applied to the dynamics generators. âpreopâ : P = expm(phase*dyn_gen); âpostopâ : P = expm(dyn_gen*phase); âcustomâ : Customised phase application. The âcustomâ option assumes that the _apply_phase method has been; set to a custom function. propÂ¶; List of propagators (Qobj) for each timeslot. prop_gradÂ¶; Array of propagator gradients (Qobj) for each timeslot, control. refresh_drift_attribs()[source]Â¶; Reset the dyn_shape, dyn_dims and time_depend_drift attribs. save",MatchSource.WIKI,docs/4.3/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/apidoc/classes.html
https://qutip.org/docs/4.3/apidoc/classes.html:96913,Modifiability,config,configuration,96913,"by; unitary matrices. E.g. closed systems with Hermitian Hamiltonians; Note a matrix diagonalisation is used to compute the exponent; The eigen decomposition is also used to calculate the propagator gradient.; The method is taken from DYNAMO (see file header). Attributes:; drift_ham : Qobj; This is the drift Hamiltonian for unitary dynamics; It is mapped to drift_dyn_gen during initialize_controls. ctrl_ham : List of Qobj; These are the control Hamiltonians for unitary dynamics; It is mapped to ctrl_dyn_gen during initialize_controls. H : List of Qobj; The combined drift and control Hamiltonians for each timeslot; These are the dynamics generators for unitary dynamics.; It is mapped to dyn_gen during initialize_controls. check_unitarity()[source]Â¶; Checks whether all propagators are unitary; For propagators found not to be unitary, the potential underlying; causes are investigated. initialize_controls(amplitudes, init_tslots=True)[source]Â¶; Set the initial control amplitudes and time slices; Note this must be called after the configuration is complete; before any dynamics can be calculated. num_ctrlsÂ¶; calculate the of controls from the length of the control list; sets the num_ctrls property, which can be used alternatively; subsequently. class DynamicsSymplectic(optimconfig, params=None)[source]Â¶; Symplectic systems; This is the subclass to use for systems where the dynamics is described; by symplectic matrices, e.g. coupled oscillators, quantum optics. Attributes:; omega : array[drift_dyn_gen.shape]; matrix used in the calculation of propagators (time evolution); with symplectic systems. dyn_gen_phaseÂ¶; The phasing operator for the symplectic group generators; usually refered to as Omega; By default this is applied as âpostopâ dyn_gen*-Omega; If phase_application is âpreopâ it is applied as Omega*dyn_gen. class PropagatorComputer(dynamics, params=None)[source]Â¶; Base for all Propagator Computer classes; that are used to calculate the propagators,; and also the prop",MatchSource.WIKI,docs/4.3/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/apidoc/classes.html
https://qutip.org/docs/4.3/apidoc/classes.html:99177,Modifiability,config,configuration,99177,"ributes:; log_level : integer; level of messaging output from the logger.; Options are attributes of qutip_utils.logging,; in decreasing levels of messaging, are:; DEBUG_INTENSE, DEBUG_VERBOSE, DEBUG, INFO, WARN, ERROR, CRITICAL; Anything WARN or above is effectively âquietâ execution,; assuming everything runs as expected.; The default NOTSET implies that the level will be taken from; the QuTiP settings file, which by default is WARN. grad_exact : boolean; indicates whether the computer class instance is capable; of computing propagator gradients. It is used to determine; whether to create the Dynamics prop_grad array. apply_params(params=None)[source]Â¶; Set object attributes based on the dictionary (if any) passed in the; instantiation, or passed as a parameter; This is called during the instantiation automatically.; The key value pairs are the attribute name and value; Note: attributes are created if they do not exist already,; and are overwritten if they do. reset()[source]Â¶; reset any configuration data. class PropCompApproxGrad(dynamics, params=None)[source]Â¶; This subclass can be used when the propagator is calculated simply; by expm of the dynamics generator, i.e. when gradients will be calculated; using approximate methods. reset()[source]Â¶; reset any configuration data. class PropCompDiag(dynamics, params=None)[source]Â¶; Coumputes the propagator exponentiation using diagonalisation of; of the dynamics generator. reset()[source]Â¶; reset any configuration data. class PropCompFrechet(dynamics, params=None)[source]Â¶. Frechet method for calculating the propagator:; exponentiating the combined dynamics generator. and the propagator gradient; It should work for all systems, e.g. unitary, open, symplectic; There are other PropagatorComputer subclasses that may be more efficient. reset()[source]Â¶; reset any configuration data. class FidelityComputer(dynamics, params=None)[source]Â¶; Base class for all Fidelity Computers.; This cannot be used directly. See subclass d",MatchSource.WIKI,docs/4.3/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/apidoc/classes.html
https://qutip.org/docs/4.3/apidoc/classes.html:99453,Modifiability,config,configuration,99453,"execution,; assuming everything runs as expected.; The default NOTSET implies that the level will be taken from; the QuTiP settings file, which by default is WARN. grad_exact : boolean; indicates whether the computer class instance is capable; of computing propagator gradients. It is used to determine; whether to create the Dynamics prop_grad array. apply_params(params=None)[source]Â¶; Set object attributes based on the dictionary (if any) passed in the; instantiation, or passed as a parameter; This is called during the instantiation automatically.; The key value pairs are the attribute name and value; Note: attributes are created if they do not exist already,; and are overwritten if they do. reset()[source]Â¶; reset any configuration data. class PropCompApproxGrad(dynamics, params=None)[source]Â¶; This subclass can be used when the propagator is calculated simply; by expm of the dynamics generator, i.e. when gradients will be calculated; using approximate methods. reset()[source]Â¶; reset any configuration data. class PropCompDiag(dynamics, params=None)[source]Â¶; Coumputes the propagator exponentiation using diagonalisation of; of the dynamics generator. reset()[source]Â¶; reset any configuration data. class PropCompFrechet(dynamics, params=None)[source]Â¶. Frechet method for calculating the propagator:; exponentiating the combined dynamics generator. and the propagator gradient; It should work for all systems, e.g. unitary, open, symplectic; There are other PropagatorComputer subclasses that may be more efficient. reset()[source]Â¶; reset any configuration data. class FidelityComputer(dynamics, params=None)[source]Â¶; Base class for all Fidelity Computers.; This cannot be used directly. See subclass descriptions and choose; one appropriate for the application; Note: this must be instantiated with a Dynamics object, that is the; container for the data that the methods operate on. Attributes:; log_level : integer; level of messaging output from the logger.; Options are attr",MatchSource.WIKI,docs/4.3/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/apidoc/classes.html
https://qutip.org/docs/4.3/apidoc/classes.html:99646,Modifiability,config,configuration,99646,"es whether the computer class instance is capable; of computing propagator gradients. It is used to determine; whether to create the Dynamics prop_grad array. apply_params(params=None)[source]Â¶; Set object attributes based on the dictionary (if any) passed in the; instantiation, or passed as a parameter; This is called during the instantiation automatically.; The key value pairs are the attribute name and value; Note: attributes are created if they do not exist already,; and are overwritten if they do. reset()[source]Â¶; reset any configuration data. class PropCompApproxGrad(dynamics, params=None)[source]Â¶; This subclass can be used when the propagator is calculated simply; by expm of the dynamics generator, i.e. when gradients will be calculated; using approximate methods. reset()[source]Â¶; reset any configuration data. class PropCompDiag(dynamics, params=None)[source]Â¶; Coumputes the propagator exponentiation using diagonalisation of; of the dynamics generator. reset()[source]Â¶; reset any configuration data. class PropCompFrechet(dynamics, params=None)[source]Â¶. Frechet method for calculating the propagator:; exponentiating the combined dynamics generator. and the propagator gradient; It should work for all systems, e.g. unitary, open, symplectic; There are other PropagatorComputer subclasses that may be more efficient. reset()[source]Â¶; reset any configuration data. class FidelityComputer(dynamics, params=None)[source]Â¶; Base class for all Fidelity Computers.; This cannot be used directly. See subclass descriptions and choose; one appropriate for the application; Note: this must be instantiated with a Dynamics object, that is the; container for the data that the methods operate on. Attributes:; log_level : integer; level of messaging output from the logger.; Options are attributes of qutip.logging_utils,; in decreasing levels of messaging, are:; DEBUG_INTENSE, DEBUG_VERBOSE, DEBUG, INFO, WARN, ERROR, CRITICAL; Anything WARN or above is effectively âquietâ executio",MatchSource.WIKI,docs/4.3/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/apidoc/classes.html
https://qutip.org/docs/4.3/apidoc/classes.html:100012,Modifiability,config,configuration,100012,"key value pairs are the attribute name and value; Note: attributes are created if they do not exist already,; and are overwritten if they do. reset()[source]Â¶; reset any configuration data. class PropCompApproxGrad(dynamics, params=None)[source]Â¶; This subclass can be used when the propagator is calculated simply; by expm of the dynamics generator, i.e. when gradients will be calculated; using approximate methods. reset()[source]Â¶; reset any configuration data. class PropCompDiag(dynamics, params=None)[source]Â¶; Coumputes the propagator exponentiation using diagonalisation of; of the dynamics generator. reset()[source]Â¶; reset any configuration data. class PropCompFrechet(dynamics, params=None)[source]Â¶. Frechet method for calculating the propagator:; exponentiating the combined dynamics generator. and the propagator gradient; It should work for all systems, e.g. unitary, open, symplectic; There are other PropagatorComputer subclasses that may be more efficient. reset()[source]Â¶; reset any configuration data. class FidelityComputer(dynamics, params=None)[source]Â¶; Base class for all Fidelity Computers.; This cannot be used directly. See subclass descriptions and choose; one appropriate for the application; Note: this must be instantiated with a Dynamics object, that is the; container for the data that the methods operate on. Attributes:; log_level : integer; level of messaging output from the logger.; Options are attributes of qutip.logging_utils,; in decreasing levels of messaging, are:; DEBUG_INTENSE, DEBUG_VERBOSE, DEBUG, INFO, WARN, ERROR, CRITICAL; Anything WARN or above is effectively âquietâ execution,; assuming everything runs as expected.; The default NOTSET implies that the level will be taken from; the QuTiP settings file, which by default is WARN. dimensional_norm : float; Normalisation constant. fid_norm_func : function; Used to normalise the fidelity; See SU and PSU options for the unitary dynamics. grad_norm_func : function; Used to normalise the fide",MatchSource.WIKI,docs/4.3/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/apidoc/classes.html
https://qutip.org/docs/4.3/apidoc/classes.html:102829,Modifiability,config,configuration,102829,"lity error gradients; (sqrt of the sum of the squares). fid_err_grad_current : boolean; flag to specify whether the fidelity / fid_err are based on the; current amplitude values. Set False when amplitudes change. apply_params(params=None)[source]Â¶; Set object attributes based on the dictionary (if any) passed in the; instantiation, or passed as a parameter; This is called during the instantiation automatically.; The key value pairs are the attribute name and value; Note: attributes are created if they do not exist already,; and are overwritten if they do. clear()[source]Â¶; clear any temporarily held status data. flag_system_changed()[source]Â¶; Flag fidelity and gradients as needing recalculation. get_fid_err()[source]Â¶; returns the absolute distance from the maximum achievable fidelity. get_fid_err_gradient()[source]Â¶; Returns the normalised gradient of the fidelity error; in a (nTimeslots x n_ctrls) array wrt the timeslot control amplitude. init_comp()[source]Â¶; initialises the computer based on the configuration of the Dynamics. reset()[source]Â¶; reset any configuration data and; clear any temporarily held status data. class FidCompUnitary(dynamics, params=None)[source]Â¶; Computes fidelity error and gradient assuming unitary dynamics, e.g.; closed qubit systems; Note fidelity and gradient calculations were taken from DYNAMO; (see file header). Attributes:; phase_option : string. determines how global phase is treated in fidelity calculations:; PSU - global phase ignored; SU - global phase included. fidelity_prenorm : complex; Last computed value of the fidelity before it is normalised; It is stored to use in the gradient normalisation calculation. fidelity_prenorm_current : boolean; flag to specify whether fidelity_prenorm are based on the; current amplitude values. Set False when amplitudes change. clear()[source]Â¶; clear any temporarily held status data. compute_fid_grad()[source]Â¶; Calculates exact gradient of function wrt to each timeslot; control amplitudes. N",MatchSource.WIKI,docs/4.3/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/apidoc/classes.html
https://qutip.org/docs/4.3/apidoc/classes.html:102888,Modifiability,config,configuration,102888," to specify whether the fidelity / fid_err are based on the; current amplitude values. Set False when amplitudes change. apply_params(params=None)[source]Â¶; Set object attributes based on the dictionary (if any) passed in the; instantiation, or passed as a parameter; This is called during the instantiation automatically.; The key value pairs are the attribute name and value; Note: attributes are created if they do not exist already,; and are overwritten if they do. clear()[source]Â¶; clear any temporarily held status data. flag_system_changed()[source]Â¶; Flag fidelity and gradients as needing recalculation. get_fid_err()[source]Â¶; returns the absolute distance from the maximum achievable fidelity. get_fid_err_gradient()[source]Â¶; Returns the normalised gradient of the fidelity error; in a (nTimeslots x n_ctrls) array wrt the timeslot control amplitude. init_comp()[source]Â¶; initialises the computer based on the configuration of the Dynamics. reset()[source]Â¶; reset any configuration data and; clear any temporarily held status data. class FidCompUnitary(dynamics, params=None)[source]Â¶; Computes fidelity error and gradient assuming unitary dynamics, e.g.; closed qubit systems; Note fidelity and gradient calculations were taken from DYNAMO; (see file header). Attributes:; phase_option : string. determines how global phase is treated in fidelity calculations:; PSU - global phase ignored; SU - global phase included. fidelity_prenorm : complex; Last computed value of the fidelity before it is normalised; It is stored to use in the gradient normalisation calculation. fidelity_prenorm_current : boolean; flag to specify whether fidelity_prenorm are based on the; current amplitude values. Set False when amplitudes change. clear()[source]Â¶; clear any temporarily held status data. compute_fid_grad()[source]Â¶; Calculates exact gradient of function wrt to each timeslot; control amplitudes. Note these gradients are not normalised; These are returned as a (nTimeslots x n_ctrls) arra",MatchSource.WIKI,docs/4.3/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/apidoc/classes.html
https://qutip.org/docs/4.3/apidoc/classes.html:104489,Modifiability,config,config,104489,"it is normalised; It is stored to use in the gradient normalisation calculation. fidelity_prenorm_current : boolean; flag to specify whether fidelity_prenorm are based on the; current amplitude values. Set False when amplitudes change. clear()[source]Â¶; clear any temporarily held status data. compute_fid_grad()[source]Â¶; Calculates exact gradient of function wrt to each timeslot; control amplitudes. Note these gradients are not normalised; These are returned as a (nTimeslots x n_ctrls) array. flag_system_changed()[source]Â¶; Flag fidelity and gradients as needing recalculation. get_fid_err()[source]Â¶; Gets the absolute error in the fidelity. get_fid_err_gradient()[source]Â¶; Returns the normalised gradient of the fidelity error; in a (nTimeslots x n_ctrls) array; The gradients are cached in case they are requested; mutliple times between control updates; (although this is not typically found to happen). get_fidelity()[source]Â¶; Gets the appropriately normalised fidelity value; The normalisation is determined by the fid_norm_func pointer; which should be set in the config. get_fidelity_prenorm()[source]Â¶; Gets the current fidelity value prior to normalisation; Note the gradient function uses this value; The value is cached, because it is used in the gradient calculation. init_comp()[source]Â¶; Check configuration and initialise the normalisation. init_normalization()[source]Â¶; Calc norm of <Ufinal | Ufinal> to scale subsequent norms; When considering unitary time evolution operators, this basically; results in calculating the trace of the identity matrix; and is hence equal to the size of the target matrix; There may be situations where this is not the case, and hence it; is not assumed to be so.; The normalisation function called should be set to either the; PSU - global phase ignored; SU - global phase respected. normalize_PSU(A)[source]Â¶. normalize_SU(A)[source]Â¶. normalize_gradient_PSU(grad)[source]Â¶; Normalise the gradient matrix passed as grad; This PSU version is",MatchSource.WIKI,docs/4.3/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/apidoc/classes.html
https://qutip.org/docs/4.3/apidoc/classes.html:104727,Modifiability,config,configuration,104727,"culates exact gradient of function wrt to each timeslot; control amplitudes. Note these gradients are not normalised; These are returned as a (nTimeslots x n_ctrls) array. flag_system_changed()[source]Â¶; Flag fidelity and gradients as needing recalculation. get_fid_err()[source]Â¶; Gets the absolute error in the fidelity. get_fid_err_gradient()[source]Â¶; Returns the normalised gradient of the fidelity error; in a (nTimeslots x n_ctrls) array; The gradients are cached in case they are requested; mutliple times between control updates; (although this is not typically found to happen). get_fidelity()[source]Â¶; Gets the appropriately normalised fidelity value; The normalisation is determined by the fid_norm_func pointer; which should be set in the config. get_fidelity_prenorm()[source]Â¶; Gets the current fidelity value prior to normalisation; Note the gradient function uses this value; The value is cached, because it is used in the gradient calculation. init_comp()[source]Â¶; Check configuration and initialise the normalisation. init_normalization()[source]Â¶; Calc norm of <Ufinal | Ufinal> to scale subsequent norms; When considering unitary time evolution operators, this basically; results in calculating the trace of the identity matrix; and is hence equal to the size of the target matrix; There may be situations where this is not the case, and hence it; is not assumed to be so.; The normalisation function called should be set to either the; PSU - global phase ignored; SU - global phase respected. normalize_PSU(A)[source]Â¶. normalize_SU(A)[source]Â¶. normalize_gradient_PSU(grad)[source]Â¶; Normalise the gradient matrix passed as grad; This PSU version is independent of global phase. normalize_gradient_SU(grad)[source]Â¶; Normalise the gradient matrix passed as grad; This SU version respects global phase. reset()[source]Â¶; reset any configuration data and; clear any temporarily held status data. set_phase_option(phase_option=None)[source]Â¶; Deprecated - use phase_option; Phas",MatchSource.WIKI,docs/4.3/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/apidoc/classes.html
https://qutip.org/docs/4.3/apidoc/classes.html:105591,Modifiability,config,configuration,105591,"tion uses this value; The value is cached, because it is used in the gradient calculation. init_comp()[source]Â¶; Check configuration and initialise the normalisation. init_normalization()[source]Â¶; Calc norm of <Ufinal | Ufinal> to scale subsequent norms; When considering unitary time evolution operators, this basically; results in calculating the trace of the identity matrix; and is hence equal to the size of the target matrix; There may be situations where this is not the case, and hence it; is not assumed to be so.; The normalisation function called should be set to either the; PSU - global phase ignored; SU - global phase respected. normalize_PSU(A)[source]Â¶. normalize_SU(A)[source]Â¶. normalize_gradient_PSU(grad)[source]Â¶; Normalise the gradient matrix passed as grad; This PSU version is independent of global phase. normalize_gradient_SU(grad)[source]Â¶; Normalise the gradient matrix passed as grad; This SU version respects global phase. reset()[source]Â¶; reset any configuration data and; clear any temporarily held status data. set_phase_option(phase_option=None)[source]Â¶; Deprecated - use phase_option; Phase options are; SU - global phase important; PSU - global phase is not important. class FidCompTraceDiff(dynamics, params=None)[source]Â¶; Computes fidelity error and gradient for general system dynamics; by calculating the the fidelity error as the trace of the overlap; of the difference between the target and evolution resulting from; the pulses with the transpose of the same.; This should provide a distance measure for dynamics described by matrices; Note the gradient calculation is taken from:; âRobust quantum gates for open systems via optimal control:; Markovian versus non-Markovian dynamicsâ; Frederik F Floether, Pierre de Fouquieres, and Sophie G Schirmer. Attributes:; scale_factor : float; The fidelity error calculated is of some arbitary scale. This; factor can be used to scale the fidelity error such that it may; represent some physical measure; If No",MatchSource.WIKI,docs/4.3/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/apidoc/classes.html
https://qutip.org/docs/4.3/apidoc/classes.html:107343,Modifiability,config,configuration,107343," Floether, Pierre de Fouquieres, and Sophie G Schirmer. Attributes:; scale_factor : float; The fidelity error calculated is of some arbitary scale. This; factor can be used to scale the fidelity error such that it may; represent some physical measure; If None is given then it is caculated as 1/2N, where N; is the dimension of the drift, when the Dynamics are initialised. compute_fid_err_grad()[source]Â¶; Calculate exact gradient of the fidelity error function; wrt to each timeslot control amplitudes.; Uses the trace difference norm fidelity; These are returned as a (nTimeslots x n_ctrls) array. get_fid_err()[source]Â¶; Gets the absolute error in the fidelity. get_fid_err_gradient()[source]Â¶; Returns the normalised gradient of the fidelity error; in a (nTimeslots x n_ctrls) array; The gradients are cached in case they are requested; mutliple times between control updates; (although this is not typically found to happen). init_comp()[source]Â¶; initialises the computer based on the configuration of the Dynamics; Calculates the scale_factor is not already set. reset()[source]Â¶; reset any configuration data and; clear any temporarily held status data. class FidCompTraceDiffApprox(dynamics, params=None)[source]Â¶; As FidCompTraceDiff, except uses the finite difference method to; compute approximate gradients. Attributes:; epsilon : float; control amplitude offset to use when approximating the gradient wrt; a timeslot control amplitude. compute_fid_err_grad()[source]Â¶; Calculates gradient of function wrt to each timeslot; control amplitudes. Note these gradients are not normalised; They are calulated; These are returned as a (nTimeslots x n_ctrls) array. reset()[source]Â¶; reset any configuration data and; clear any temporarily held status data. class TimeslotComputer(dynamics, params=None)[source]Â¶; Base class for all Timeslot Computers; Note: this must be instantiated with a Dynamics object, that is the; container for the data that the methods operate on. Attributes:; log_lev",MatchSource.WIKI,docs/4.3/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/apidoc/classes.html
https://qutip.org/docs/4.3/apidoc/classes.html:107450,Modifiability,config,configuration,107450,"ated is of some arbitary scale. This; factor can be used to scale the fidelity error such that it may; represent some physical measure; If None is given then it is caculated as 1/2N, where N; is the dimension of the drift, when the Dynamics are initialised. compute_fid_err_grad()[source]Â¶; Calculate exact gradient of the fidelity error function; wrt to each timeslot control amplitudes.; Uses the trace difference norm fidelity; These are returned as a (nTimeslots x n_ctrls) array. get_fid_err()[source]Â¶; Gets the absolute error in the fidelity. get_fid_err_gradient()[source]Â¶; Returns the normalised gradient of the fidelity error; in a (nTimeslots x n_ctrls) array; The gradients are cached in case they are requested; mutliple times between control updates; (although this is not typically found to happen). init_comp()[source]Â¶; initialises the computer based on the configuration of the Dynamics; Calculates the scale_factor is not already set. reset()[source]Â¶; reset any configuration data and; clear any temporarily held status data. class FidCompTraceDiffApprox(dynamics, params=None)[source]Â¶; As FidCompTraceDiff, except uses the finite difference method to; compute approximate gradients. Attributes:; epsilon : float; control amplitude offset to use when approximating the gradient wrt; a timeslot control amplitude. compute_fid_err_grad()[source]Â¶; Calculates gradient of function wrt to each timeslot; control amplitudes. Note these gradients are not normalised; They are calulated; These are returned as a (nTimeslots x n_ctrls) array. reset()[source]Â¶; reset any configuration data and; clear any temporarily held status data. class TimeslotComputer(dynamics, params=None)[source]Â¶; Base class for all Timeslot Computers; Note: this must be instantiated with a Dynamics object, that is the; container for the data that the methods operate on. Attributes:; log_level : integer; level of messaging output from the logger.; Options are attributes of qutip.logging_utils,; in decrea",MatchSource.WIKI,docs/4.3/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/apidoc/classes.html
https://qutip.org/docs/4.3/apidoc/classes.html:108052,Modifiability,config,configuration,108052,"sed gradient of the fidelity error; in a (nTimeslots x n_ctrls) array; The gradients are cached in case they are requested; mutliple times between control updates; (although this is not typically found to happen). init_comp()[source]Â¶; initialises the computer based on the configuration of the Dynamics; Calculates the scale_factor is not already set. reset()[source]Â¶; reset any configuration data and; clear any temporarily held status data. class FidCompTraceDiffApprox(dynamics, params=None)[source]Â¶; As FidCompTraceDiff, except uses the finite difference method to; compute approximate gradients. Attributes:; epsilon : float; control amplitude offset to use when approximating the gradient wrt; a timeslot control amplitude. compute_fid_err_grad()[source]Â¶; Calculates gradient of function wrt to each timeslot; control amplitudes. Note these gradients are not normalised; They are calulated; These are returned as a (nTimeslots x n_ctrls) array. reset()[source]Â¶; reset any configuration data and; clear any temporarily held status data. class TimeslotComputer(dynamics, params=None)[source]Â¶; Base class for all Timeslot Computers; Note: this must be instantiated with a Dynamics object, that is the; container for the data that the methods operate on. Attributes:; log_level : integer; level of messaging output from the logger.; Options are attributes of qutip.logging_utils,; in decreasing levels of messaging, are:; DEBUG_INTENSE, DEBUG_VERBOSE, DEBUG, INFO, WARN, ERROR, CRITICAL; Anything WARN or above is effectively âquietâ execution,; assuming everything runs as expected.; The default NOTSET implies that the level will be taken from; the QuTiP settings file, which by default is WARN. evo_comp_summary : EvoCompSummary; A summary of the most recent evolution computation; Used in the stats and dump; Will be set to None if neither stats or dump are set. apply_params(params=None)[source]Â¶; Set object attributes based on the dictionary (if any) passed in the; instantiation, or p",MatchSource.WIKI,docs/4.3/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/apidoc/classes.html
https://qutip.org/docs/4.3/apidoc/classes.html:120283,Modifiability,config,configurations,120283,"on method; Typically this will be the basis coefficients. class PulseGenCrabFourier(dyn=None, num_coeffs=None, params=None)[source]Â¶; Generates a pulse using the Fourier basis functions, i.e. sin and cos. Attributes:; freqs : float array[num_coeffs]; Frequencies for the basis functions. randomize_freqs : bool; If True (default) the some random offset is applied to the frequencies. gen_pulse(coeffs=None)[source]Â¶; Generate a pulse using the Fourier basis with the freqs and; coeffs attributes. Parameters:; coeffs : float array[num_coeffs, num_basis_funcs]; The basis coefficient values; If given this overides the default and sets the attribute; of the same name. init_freqs()[source]Â¶; Generate the frequencies; These are the Fourier harmonics with a uniformly distributed; random offset. init_pulse(num_coeffs=None)[source]Â¶; Set the initial freq and coefficient values. reset()[source]Â¶; reset attributes to default values. class Stats[source]Â¶; Base class for all optimisation statistics; Used for configurations where all timeslots are updated each iteration; e.g. exact gradients; Note that all times are generated using timeit.default_timer() and are; in seconds. Attributes:; dyn_gen_name : string; Text used in some report functions.; Makes sense to set it to âHamiltonianâ when using unitary dynamics; Default is simply âdynamics generatorâ. num_iter : integer; Number of iterations of the optimisation algorithm. wall_time_optim_start : float; Start time for the optimisation. wall_time_optim_end : float; End time for the optimisation. wall_time_optim : float; Time elasped during the optimisation. wall_time_dyn_gen_compute : float; Total wall (elasped) time computing combined dynamics generator; (for example combining drift and control Hamiltonians). wall_time_prop_compute : float; Total wall (elasped) time computing propagators, that is the; time evolution from one timeslot to the next; Includes calculating the propagator gradient for exact gradients. wall_time_fwd_prop_compu",MatchSource.WIKI,docs/4.3/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/apidoc/classes.html
https://qutip.org/docs/4.3/apidoc/classes.html:124156,Modifiability,config,configured,124156,"e required on the stats; Should be called before calling report. report()[source]Â¶; Print a report of the stats to the console. class Dump[source]Â¶; A container for dump items.; The lists for dump items is depends on the type; Note: abstract class. Attributes:; parent : some control object (Dynamics or Optimizer); aka the host. Object that generates the data that is dumped and is; host to this dump object. dump_dir : str; directory where files (if any) will be written out; the path and be relative or absolute; use ~/ to specify user home directory; Note: files are only written when write_to_file is True; of writeout is called explicitly; Defaults to ~/.qtrl_dump. level : string; The level of data dumping that will occur - SUMMARY : A summary will be recorded - FULL : All possible dumping - CUSTOM : Some customised level of dumping When first set to CUSTOM this is equivalent to SUMMARY. write_to_file : bool; When set True data and summaries (as configured) will be written; interactively to file during the processing; Set during instantiation by the host based on its dump_to_file attrib. dump_file_ext : str; Default file extension for any file names that are auto generated. fname_base : str; First part of any auto generated file names.; This is usually overridden in the subclass. dump_summary : bool; If True a summary is recorded each time a new item is added to the; the dump.; Default is True. summary_sep : str; delimiter for the summary file.; default is a space. data_sep : str; delimiter for the data files (arrays saved to file).; default is a space. summary_file : str; File path for summary file.; Automatically generated. Can be set specifically. create_dump_dir()[source]Â¶; Checks dump directory exists, creates it if not. levelÂ¶. The level of data dumping that will occur. SUMMARY : A summary will be recorded; FULL : All possible dumping; CUSTOM : Some customised level of dumping. When first set to CUSTOM this is equivalent to SUMMARY. It is then up; to the user to",MatchSource.WIKI,docs/4.3/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/apidoc/classes.html
https://qutip.org/docs/4.3/apidoc/classes.html:4095,Performance,perform,performing,4095,"; Adjoint (dagger) of quantum object. dnorm(); Diamond norm of quantum operator. dual_chan(); Dual channel of quantum object representing a CP map. eigenenergies(sparse=False, sort=âlowâ, eigvals=0, tol=0, maxiter=100000); Returns eigenenergies (eigenvalues) of a quantum object. eigenstates(sparse=False, sort=âlowâ, eigvals=0, tol=0, maxiter=100000); Returns eigenenergies and eigenstates of quantum object. expm(); Matrix exponential of quantum object. full(order=âCâ); Returns dense array of quantum object data attribute. groundstate(sparse=False, tol=0, maxiter=100000); Returns eigenvalue and eigenket for the groundstate of a quantum object. matrix_element(bra, ket); Returns the matrix element of operator between bra and ket vectors. norm(norm=âtrâ, sparse=False, tol=0, maxiter=100000); Returns norm of a ket or an operator. permute(order); Returns composite qobj with indices reordered. proj(); Computes the projector for a ket or bra vector. ptrace(sel); Returns quantum object for selected dimensions after performing partial trace. sinm(); Sine of quantum object. sqrtm(); Matrix square root of quantum object. tidyup(atol=1e-12); Removes small elements from quantum object. tr(); Trace of quantum object. trans(); Transpose of quantum object. transform(inpt, inverse=False); Performs a basis transformation defined by inpt matrix. trunc_neg(method=âclipâ); Removes negative eigenvalues and returns a new Qobj that is a valid density operator. unit(norm=âtrâ, sparse=False, tol=0, maxiter=100000); Returns normalized quantum object. check_herm()[source]Â¶; Check if the quantum object is hermitian. Returns:; isherm : bool; Returns the new value of isherm property. check_isunitary()[source]Â¶; Checks whether qobj is a unitary matrix. conj()[source]Â¶; Conjugate operator of quantum object. copy()[source]Â¶; Create identical copy. cosm()[source]Â¶; Cosine of a quantum operator.; Operator must be square. Returns:; oper : qobj; Matrix cosine of operator. Raises:; TypeError; Quantum objec",MatchSource.WIKI,docs/4.3/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/apidoc/classes.html
https://qutip.org/docs/4.3/apidoc/classes.html:6395,Performance,perform,performed,6395,"iamond norm, or the diamond distance to another; operator. Parameters:; B : Qobj or None; If B is not None, the diamond distance d(A, B) = dnorm(A - B) between; this operator and B is returned instead of the diamond norm. Returns:; d : float; Either the diamond norm of this operator, or the diamond distance; from this operator to B. dual_chan()[source]Â¶; Dual channel of quantum object representing a completely positive; map. eigenenergies(sparse=False, sort='low', eigvals=0, tol=0, maxiter=100000)[source]Â¶; Eigenenergies of a quantum object.; Eigenenergies (eigenvalues) are defined for operators or superoperators; only. Parameters:; sparse : bool; Use sparse Eigensolver. sort : str; Sort eigenvalues âlowâ to high, or âhighâ to low. eigvals : int; Number of requested eigenvalues. Default is all eigenvalues. tol : float; Tolerance used by sparse Eigensolver (0=machine precision).; The sparse solver may not converge if the tolerance is set too low. maxiter : int; Maximum number of iterations performed by sparse solver (if used). Returns:; eigvals : array; Array of eigenvalues for operator. Notes; The sparse eigensolver is much slower than the dense version.; Use sparse only if memory requirements demand it. eigenstates(sparse=False, sort='low', eigvals=0, tol=0, maxiter=100000)[source]Â¶; Eigenstates and eigenenergies.; Eigenstates and eigenenergies are defined for operators and; superoperators only. Parameters:; sparse : bool; Use sparse Eigensolver. sort : str; Sort eigenvalues (and vectors) âlowâ to high, or âhighâ to low. eigvals : int; Number of requested eigenvalues. Default is all eigenvalues. tol : float; Tolerance used by sparse Eigensolver (0 = machine precision).; The sparse solver may not converge if the tolerance is set too low. maxiter : int; Maximum number of iterations performed by sparse solver (if used). Returns:; eigvals : array; Array of eigenvalues for operator. eigvecs : array; Array of quantum operators representing the oprator eigenkets.; Order o",MatchSource.WIKI,docs/4.3/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/apidoc/classes.html
https://qutip.org/docs/4.3/apidoc/classes.html:7203,Performance,perform,performed,7203,"envalues. tol : float; Tolerance used by sparse Eigensolver (0=machine precision).; The sparse solver may not converge if the tolerance is set too low. maxiter : int; Maximum number of iterations performed by sparse solver (if used). Returns:; eigvals : array; Array of eigenvalues for operator. Notes; The sparse eigensolver is much slower than the dense version.; Use sparse only if memory requirements demand it. eigenstates(sparse=False, sort='low', eigvals=0, tol=0, maxiter=100000)[source]Â¶; Eigenstates and eigenenergies.; Eigenstates and eigenenergies are defined for operators and; superoperators only. Parameters:; sparse : bool; Use sparse Eigensolver. sort : str; Sort eigenvalues (and vectors) âlowâ to high, or âhighâ to low. eigvals : int; Number of requested eigenvalues. Default is all eigenvalues. tol : float; Tolerance used by sparse Eigensolver (0 = machine precision).; The sparse solver may not converge if the tolerance is set too low. maxiter : int; Maximum number of iterations performed by sparse solver (if used). Returns:; eigvals : array; Array of eigenvalues for operator. eigvecs : array; Array of quantum operators representing the oprator eigenkets.; Order of eigenkets is determined by order of eigenvalues. Notes; The sparse eigensolver is much slower than the dense version.; Use sparse only if memory requirements demand it. eliminate_states(states_inds, normalize=False)[source]Â¶; Creates a new quantum object with states in state_inds eliminated. Parameters:; states_inds : list of integer; The states that should be removed. normalize : True / False; Weather or not the new Qobj instance should be normalized (default; is False). For Qobjs that represents density matrices or state; vectors normalized should probably be set to True, but for Qobjs; that represents operators in for example an Hamiltonian, normalize; should be False. Returns:; q : Qobj; A new instance of qutip.Qobj that contains only the states; corresponding to indices that are not in stat",MatchSource.WIKI,docs/4.3/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/apidoc/classes.html
https://qutip.org/docs/4.3/apidoc/classes.html:10711,Performance,perform,performed,10711,"state; vectors normalized should probably be set to True, but for Qobjs; that represents operators in for example an Hamiltonian, normalize; should be False. Returns:; q : Qobj; A new instance of qutip.Qobj that contains only the states; corresponding to the indices in state_inds. Notes; Experimental. full(order='C', squeeze=False)[source]Â¶; Dense array from quantum object. Parameters:; order : str {âCâ, âFâ}; Return array in C (default) or Fortran ordering. squeeze : bool {False, True}; Squeeze output array. Returns:; data : array; Array of complex data from quantum objects data attribute. groundstate(sparse=False, tol=0, maxiter=100000, safe=True)[source]Â¶; Ground state Eigenvalue and Eigenvector.; Defined for quantum operators or superoperators only. Parameters:; sparse : bool; Use sparse Eigensolver. tol : float; Tolerance used by sparse Eigensolver (0 = machine precision).; The sparse solver may not converge if the tolerance is set too low. maxiter : int; Maximum number of iterations performed by sparse solver (if used). safe : bool (default=True); Check for degenerate ground state. Returns:; eigval : float; Eigenvalue for the ground state of quantum operator. eigvec : qobj; Eigenket for the ground state of quantum operator. Notes; The sparse eigensolver is much slower than the dense version.; Use sparse only if memory requirements demand it. matrix_element(bra, ket)[source]Â¶; Calculates a matrix element.; Gives the matrix element for the quantum object sandwiched between a; bra and ket vector. Parameters:; bra : qobj; Quantum object of type âbraâ or âketâ. ket : qobj; Quantum object of type âketâ. Returns:; elem : complex; Complex valued matrix element. norm(norm=None, sparse=False, tol=0, maxiter=100000)[source]Â¶; Norm of a quantum object.; Default norm is L2-norm for kets and trace-norm for operators.; Other ket and operator norms may be specified using the norm and; argument. Parameters:; norm : str; Which norm to use for ket/bra vectors: L2 âl2â, max norm ",MatchSource.WIKI,docs/4.3/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/apidoc/classes.html
https://qutip.org/docs/4.3/apidoc/classes.html:12075,Performance,perform,performed,12075,"trix_element(bra, ket)[source]Â¶; Calculates a matrix element.; Gives the matrix element for the quantum object sandwiched between a; bra and ket vector. Parameters:; bra : qobj; Quantum object of type âbraâ or âketâ. ket : qobj; Quantum object of type âketâ. Returns:; elem : complex; Complex valued matrix element. norm(norm=None, sparse=False, tol=0, maxiter=100000)[source]Â¶; Norm of a quantum object.; Default norm is L2-norm for kets and trace-norm for operators.; Other ket and operator norms may be specified using the norm and; argument. Parameters:; norm : str; Which norm to use for ket/bra vectors: L2 âl2â, max norm âmaxâ,; or for operators: trace âtrâ, Frobius âfroâ, one âoneâ, or max; âmaxâ. sparse : bool; Use sparse eigenvalue solver for trace norm. Other norms are not; affected by this parameter. tol : float; Tolerance for sparse solver (if used) for trace norm. The sparse; solver may not converge if the tolerance is set too low. maxiter : int; Maximum number of iterations performed by sparse solver (if used); for trace norm. Returns:; norm : float; The requested norm of the operator or state quantum object. Notes; The sparse eigensolver is much slower than the dense version.; Use sparse only if memory requirements demand it. overlap(other)[source]Â¶; Overlap between two state vectors.; Gives the overlap (inner product) between the current bra or ket Qobj; and and another bra or ket Qobj. Parameters:; other : qobj; Quantum object for a state vector of type âketâ or âbraâ. Returns:; overlap : complex; Complex valued overlap. Raises:; TypeError; Can only calculate overlap between a bra and ket quantum objects. Notes; Since QuTiP mainly deals with ket vectors, the most efficient inner product; call is the ket-ket version that computes the product <self|other> with; both vectors expressed as kets. permute(order)[source]Â¶; Permutes a composite quantum object. Parameters:; order : list/array; List specifying new tensor order. Returns:; P : qobj; Permuted quantum ob",MatchSource.WIKI,docs/4.3/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/apidoc/classes.html
https://qutip.org/docs/4.3/apidoc/classes.html:16260,Performance,perform,performed,16260,"basis. Notes; This function is still in development. trunc_neg(method='clip')[source]Â¶; Truncates negative eigenvalues and renormalizes.; Returns a new Qobj by removing the negative eigenvalues; of this instance, then renormalizing to obtain a valid density; operator. Parameters:; method : str; Algorithm to use to remove negative eigenvalues. âclipâ; simply discards negative eigenvalues, then renormalizes.; âsgsâ uses the SGS algorithm (doi:10/bb76) to find the; positive operator that is nearest in the Shatten 2-norm. Returns:; oper : qobj; A valid density operator. unit(inplace=False, norm=None, sparse=False, tol=0, maxiter=100000)[source]Â¶; Operator or state normalized to unity.; Uses norm from Qobj.norm(). Parameters:; inplace : bool; Do an in-place normalization. norm : str; Requested norm for states / operators. sparse : bool; Use sparse eigensolver for trace norm. Does not affect other norms. tol : float; Tolerance used by sparse eigensolver. maxiter : int; Number of maximum iterations performed by sparse eigensolver. Returns:; oper : qobj; Normalized quantum object if not in-place,; else None. eseriesÂ¶. class eseries(q=array([], dtype=object), s=array([], dtype=float64))[source]Â¶; Class representation of an exponential-series expansion of; time-dependent quantum objects. Attributes:; ampl : ndarray; Array of amplitudes for exponential series. rates : ndarray; Array of rates for exponential series. dims : list; Dimensions of exponential series components. shape : list; Shape corresponding to exponential series components. Methods. value(tlist); Evaluate an exponential series at the times listed in tlist. spec(wlist); Evaluate the spectrum of an exponential series at frequencies in wlist. tidyup(); Returns a tidier version of the exponential series. spec(wlist)[source]Â¶; Evaluate the spectrum of an exponential series at frequencies; in wlist. Parameters:; wlist : array_like; Array/list of frequenies. Returns:; val_list : ndarray; Values of exponential series at ",MatchSource.WIKI,docs/4.3/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/apidoc/classes.html
https://qutip.org/docs/4.3/apidoc/classes.html:24197,Performance,perform,performance,24197,"array; Array of coeffcients defining cubic spline. Non-Markovian SolversÂ¶. class HEOMSolver[source]Â¶; This is superclass for all solvers that use the HEOM method for; calculating the dynamics evolution. There are many references for this.; A good introduction, and perhaps closest to the notation used here is:; DOI:10.1103/PhysRevLett.104.250401; A more canonical reference, with full derivation is:; DOI: 10.1103/PhysRevA.41.6676; The method can compute open system dynamics without using any Markovian; or rotating wave approximation (RWA) for systems where the bath; correlations can be approximated to a sum of complex eponentials.; The method builds a matrix of linked differential equations, which are; then solved used the same ODE solvers as other qutip solvers (e.g. mesolve); This class should be treated as abstract. Currently the only subclass; implemented is that for the Drude-Lorentz spectral density. This covers; the majority of the work that has been done using this model, and there; are some performance advantages to assuming this model where it is; appropriate.; There are opportunities to develop a more general spectral density code. Attributes:; H_sys : Qobj; System Hamiltonian. coup_op : Qobj; Operator describing the coupling between system and bath. coup_strength : float; Coupling strength. temperature : float; Bath temperature, in units corresponding to planck. N_cut : int; Cutoff parameter for the bath. N_exp : int; Number of exponential terms used to approximate the bath correlation; functions. planck : float; reduced Planck constant. boltzmann : float; Boltzmannâs constant. options : qutip.solver.Options; Generic solver options.; If set to None the default options will be used. progress_bar: BaseProgressBar; Optional instance of BaseProgressBar, or a subclass thereof, for; showing the progress of the simulation. stats : qutip.solver.Stats; optional container for holding performance statitics; If None is set, then statistics are not collected; There may ",MatchSource.WIKI,docs/4.3/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/apidoc/classes.html
https://qutip.org/docs/4.3/apidoc/classes.html:25101,Performance,perform,performance,25101," has been done using this model, and there; are some performance advantages to assuming this model where it is; appropriate.; There are opportunities to develop a more general spectral density code. Attributes:; H_sys : Qobj; System Hamiltonian. coup_op : Qobj; Operator describing the coupling between system and bath. coup_strength : float; Coupling strength. temperature : float; Bath temperature, in units corresponding to planck. N_cut : int; Cutoff parameter for the bath. N_exp : int; Number of exponential terms used to approximate the bath correlation; functions. planck : float; reduced Planck constant. boltzmann : float; Boltzmannâs constant. options : qutip.solver.Options; Generic solver options.; If set to None the default options will be used. progress_bar: BaseProgressBar; Optional instance of BaseProgressBar, or a subclass thereof, for; showing the progress of the simulation. stats : qutip.solver.Stats; optional container for holding performance statitics; If None is set, then statistics are not collected; There may be an overhead in collecting statistics. exp_coeff : list of complex; Coefficients for the exponential series terms. exp_freq : list of complex; Frequencies for the exponential series terms. configure(H_sys, coup_op, coup_strength, temperature, N_cut, N_exp, planck=None, boltzmann=None, renorm=None, bnd_cut_approx=None, options=None, progress_bar=None, stats=None)[source]Â¶; Configure the solver using the passed parameters; The parameters are described in the class attributes, unless there; is some specific behaviour. Parameters:; options : qutip.solver.Options; Generic solver options.; If set to None the default options will be used. progress_bar: BaseProgressBar; Optional instance of BaseProgressBar, or a subclass thereof, for; showing the progress of the simulation.; If set to None, then the default progress bar will be used; Set to False for no progress bar. stats: :class:`qutip.solver.Stats`; Optional instance of solver.Stats, or a subclass ",MatchSource.WIKI,docs/4.3/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/apidoc/classes.html
https://qutip.org/docs/4.3/apidoc/classes.html:26166,Performance,perform,performance,26166,"ng statistics. exp_coeff : list of complex; Coefficients for the exponential series terms. exp_freq : list of complex; Frequencies for the exponential series terms. configure(H_sys, coup_op, coup_strength, temperature, N_cut, N_exp, planck=None, boltzmann=None, renorm=None, bnd_cut_approx=None, options=None, progress_bar=None, stats=None)[source]Â¶; Configure the solver using the passed parameters; The parameters are described in the class attributes, unless there; is some specific behaviour. Parameters:; options : qutip.solver.Options; Generic solver options.; If set to None the default options will be used. progress_bar: BaseProgressBar; Optional instance of BaseProgressBar, or a subclass thereof, for; showing the progress of the simulation.; If set to None, then the default progress bar will be used; Set to False for no progress bar. stats: :class:`qutip.solver.Stats`; Optional instance of solver.Stats, or a subclass thereof, for; storing performance statistics for the solver; If set to True, then the default Stats for this class will be used; Set to False for no stats. create_new_stats()[source]Â¶; Creates a new stats object suitable for use with this solver; Note: this solver expects the stats object to have sections. config; integrate. reset()[source]Â¶; Reset any attributes to default values. class HSolverDL(H_sys, coup_op, coup_strength, temperature, N_cut, N_exp, cut_freq, planck=1.0, boltzmann=1.0, renorm=True, bnd_cut_approx=True, options=None, progress_bar=None, stats=None)[source]Â¶; HEOM solver based on the Drude-Lorentz model for spectral density.; Drude-Lorentz bath the correlation functions can be exactly analytically; expressed as an infinite sum of exponentials which depend on the; temperature, these are called the Matsubara terms or Matsubara frequencies; For practical computation purposes an approximation must be used based; on a small number of Matsubara terms (typically < 4). Attributes:; cut_freq : float; Bath spectral density cutoff frequency. r",MatchSource.WIKI,docs/4.3/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/apidoc/classes.html
https://qutip.org/docs/4.3/apidoc/classes.html:31357,Performance,perform,performed,31357,"e, c2=None, notrace=False)[source]Â¶; Compute propagator for computing output field expectation values; <O_n(tn)â¦O_2(t2)O_1(t1)> for times t1,t2,â¦ and; O_i = I, b_out, b_out^dagger, b_loop, b_loop^dagger. Parameters:; blist : array_like; List of integers specifying the field operators:; 0: I (nothing); 1: b_out; 2: b_out^dagger; 3: b_loop; 4: b_loop^dagger. tlist : array_like; list of corresponding times t1,..,tn at which to evaluate the field; operators. tau : float; time-delay. c1 : qutip.Qobj; system collapse operator that couples to the in-loop field in; question (only needs to be specified if self.L1 has more than one; element). c2 : qutip.Qobj; system collapse operator that couples to the output field in; question (only needs to be specified if self.L2 has more than one; element). notrace : bool {False}; If this optional is set to True, a propagator is returned for a; cascade of k systems, where \((k-1) tau < t < k tau\).; If set to False (default), a generalized partial trace is performed; and a propagator for a single system is returned. Returns:; : :class:`qutip.Qobj`; time-propagator for computing field correlation function. propagator(t, tau, notrace=False)[source]Â¶; Compute propagator for time t and time-delay tau. Parameters:; t : float; current time. tau : float; time-delay. notrace : bool {False}; If this optional is set to True, a propagator is returned for a; cascade of k systems, where \((k-1) tau < t < k tau\).; If set to False (default), a generalized partial trace is performed; and a propagator for a single system is returned. Returns. ââ-. : :class:`qutip.Qobj`; time-propagator for reduced system dynamics. rhot(rho0, t, tau)[source]Â¶; Compute the reduced system density matrix \(\rho(t)\). Parameters:; rho0 : qutip.Qobj; initial density matrix or state vector (ket). t : float; current time. tau : float; time-delay. Returns:; : :class:`qutip.Qobj`; density matrix at time \(t\). class TTMSolverOptions(dynmaps=None, times=[], learningtimes=[], thres",MatchSource.WIKI,docs/4.3/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/apidoc/classes.html
https://qutip.org/docs/4.3/apidoc/classes.html:31869,Performance,perform,performed,31869,"apse operator that couples to the in-loop field in; question (only needs to be specified if self.L1 has more than one; element). c2 : qutip.Qobj; system collapse operator that couples to the output field in; question (only needs to be specified if self.L2 has more than one; element). notrace : bool {False}; If this optional is set to True, a propagator is returned for a; cascade of k systems, where \((k-1) tau < t < k tau\).; If set to False (default), a generalized partial trace is performed; and a propagator for a single system is returned. Returns:; : :class:`qutip.Qobj`; time-propagator for computing field correlation function. propagator(t, tau, notrace=False)[source]Â¶; Compute propagator for time t and time-delay tau. Parameters:; t : float; current time. tau : float; time-delay. notrace : bool {False}; If this optional is set to True, a propagator is returned for a; cascade of k systems, where \((k-1) tau < t < k tau\).; If set to False (default), a generalized partial trace is performed; and a propagator for a single system is returned. Returns. ââ-. : :class:`qutip.Qobj`; time-propagator for reduced system dynamics. rhot(rho0, t, tau)[source]Â¶; Compute the reduced system density matrix \(\rho(t)\). Parameters:; rho0 : qutip.Qobj; initial density matrix or state vector (ket). t : float; current time. tau : float; time-delay. Returns:; : :class:`qutip.Qobj`; density matrix at time \(t\). class TTMSolverOptions(dynmaps=None, times=[], learningtimes=[], thres=0.0, options=None)[source]Â¶; Class of options for the Transfer Tensor Method solver. Attributes:; dynmaps : list of qutip.Qobj; List of precomputed dynamical maps (superoperators),; or a callback function that returns the; superoperator at a given time. times : array_like; List of times \(t_n\) at which to calculate \(\rho(t_n)\). learningtimes : array_like; List of times \(t_k\) to use as learning times if argument; dynmaps is a callback function. thres : float; Threshold for halting. Halts if \(||T_{n}-T",MatchSource.WIKI,docs/4.3/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/apidoc/classes.html
https://qutip.org/docs/4.3/apidoc/classes.html:36843,Performance,perform,performance,36843,". class Result[source]Â¶; Class for storing simulation results from any of the dynamics solvers. Attributes:; solver : str; Which solver was used [e.g., âmesolveâ, âmcsolveâ, âbrmesolveâ, â¦]. times : list/array; Times at which simulation data was collected. expect : list/array; Expectation values (if requested) for simulation. states : array; State of the simulation (density matrix or ket) evaluated at times. num_expect : int; Number of expectation value operators in simulation. num_collapse : int; Number of collapse operators in simualation. ntraj : int/list; Number of trajectories (for stochastic solvers). A list indicates; that averaging of expectation values was done over a subset of total; number of trajectories. col_times : list; Times at which state collpase occurred. Only for Monte Carlo solver. col_which : list; Which collapse operator was responsible for each collapse in; col_times. Only for Monte Carlo solver. class Stats(section_names=None)[source]Â¶; Statistical information on the solver performance; Statistics can be grouped into sections.; If no section names are given in the the contructor, then all statistics; will be added to one section âmainâ. Parameters:; section_names : list; list of keys that will be used as keys for the sections; These keys will also be used as names for the sections; The text in the output can be overidden by setting the header property; of the section; If no names are given then one section called âmainâ is created. Attributes:; sections : OrderedDict of _StatsSection; These are the sections that are created automatically on instantiation; or added using add_section. header : string; Some text that will be used as the heading in the report; By default there is None. total_time : float; Time in seconds for the solver to complete processing; Can be None, meaning that total timing percentages will be reported. Methods. add_section(name); Add another section with the given name. add_count(key,Â value[,Â section]); Add value to coun",MatchSource.WIKI,docs/4.3/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/apidoc/classes.html
https://qutip.org/docs/4.3/apidoc/classes.html:68218,Performance,optimiz,optimize,68218,"s of the (quantum) system. to be control optimised. Attributes:; log_level : integer; level of messaging output from the logger.; Options are attributes of qutip.logging_utils,; in decreasing levels of messaging, are:; DEBUG_INTENSE, DEBUG_VERBOSE, DEBUG, INFO, WARN, ERROR, CRITICAL; Anything WARN or above is effectively âquietâ execution,; assuming everything runs as expected.; The default NOTSET implies that the level will be taken from; the QuTiP settings file, which by default is WARN. params: Dictionary; The key value pairs are the attribute name and value; Note: attributes are created if they do not exist already,; and are overwritten if they do. alg : string; Algorithm to use in pulse optimisation.; Options are:. âGRAPEâ (default) - GRadient Ascent Pulse Engineering; âCRABâ - Chopped RAndom Basis. alg_params : Dictionary; options that are specific to the pulse optim algorithm; that is GRAPE or CRAB. disp_conv_msg : bool; Set true to display a convergence message; (for scipy.optimize.minimize methods anyway). optim_method : string; a scipy.optimize.minimize method that will be used to optimise; the pulse for minimum fidelity error. method_params : Dictionary; Options for the optim_method.; Note that where there is an equivalent attribute of this instance; or the termination_conditions (for example maxiter); it will override an value in these options. approx_grad : bool; If set True then the method will approximate the gradient itself; (if it has requirement and facility for this); This will mean that the fid_err_grad_wrapper will not get called; Note it should be left False when using the Dynamics; to calculate approximate gradients; Note it is set True automatically when the alg is CRAB. amp_lbound : float or list of floats; lower boundaries for the control amplitudes; Can be a scalar value applied to all controls; or a list of bounds for each control. amp_ubound : float or list of floats; upper boundaries for the control amplitudes; Can be a scalar value appl",MatchSource.WIKI,docs/4.3/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/apidoc/classes.html
https://qutip.org/docs/4.3/apidoc/classes.html:68284,Performance,optimiz,optimize,68284,"og_level : integer; level of messaging output from the logger.; Options are attributes of qutip.logging_utils,; in decreasing levels of messaging, are:; DEBUG_INTENSE, DEBUG_VERBOSE, DEBUG, INFO, WARN, ERROR, CRITICAL; Anything WARN or above is effectively âquietâ execution,; assuming everything runs as expected.; The default NOTSET implies that the level will be taken from; the QuTiP settings file, which by default is WARN. params: Dictionary; The key value pairs are the attribute name and value; Note: attributes are created if they do not exist already,; and are overwritten if they do. alg : string; Algorithm to use in pulse optimisation.; Options are:. âGRAPEâ (default) - GRadient Ascent Pulse Engineering; âCRABâ - Chopped RAndom Basis. alg_params : Dictionary; options that are specific to the pulse optim algorithm; that is GRAPE or CRAB. disp_conv_msg : bool; Set true to display a convergence message; (for scipy.optimize.minimize methods anyway). optim_method : string; a scipy.optimize.minimize method that will be used to optimise; the pulse for minimum fidelity error. method_params : Dictionary; Options for the optim_method.; Note that where there is an equivalent attribute of this instance; or the termination_conditions (for example maxiter); it will override an value in these options. approx_grad : bool; If set True then the method will approximate the gradient itself; (if it has requirement and facility for this); This will mean that the fid_err_grad_wrapper will not get called; Note it should be left False when using the Dynamics; to calculate approximate gradients; Note it is set True automatically when the alg is CRAB. amp_lbound : float or list of floats; lower boundaries for the control amplitudes; Can be a scalar value applied to all controls; or a list of bounds for each control. amp_ubound : float or list of floats; upper boundaries for the control amplitudes; Can be a scalar value applied to all controls; or a list of bounds for each control. bounds ",MatchSource.WIKI,docs/4.3/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/apidoc/classes.html
https://qutip.org/docs/4.3/apidoc/classes.html:70148,Performance,perform,performance,70148,"the control amplitudes; Can be a scalar value applied to all controls; or a list of bounds for each control. bounds : List of floats; Bounds for the parameters.; If not set before the run_optimization call then the list; is built automatically based on the amp_lbound and amp_ubound; attributes.; Setting this attribute directly allows specific bounds to be set; for individual parameters.; Note: Only some methods use bounds. dynamics : Dynamics (subclass instance); describes the dynamics of the (quantum) system to be control optimised; (see Dynamics classes for details). config : OptimConfig instance; various configuration options; (see OptimConfig for details). termination_conditions : TerminationCondition instance; attributes determine when the optimisation will end. pulse_generator : PulseGen (subclass instance); (can be) used to create initial pulses; not used by the class, but set by pulseoptim.create_pulse_optimizer. stats : Stats; attributes of which give performance stats for the optimisation; set to None to reduce overhead of calculating stats.; Note it is (usually) shared with the Dynamics instance. dump : dump.OptimDump; Container for data dumped during the optimisation.; Can be set by specifying the dumping level or set directly.; Note this is mainly intended for user and a development debugging; but could be used for status information during a long optimisation. dumping : string; The level of data dumping that will occur during the optimisation - NONE : No processing data dumped (Default) - SUMMARY : A summary at each iteration will be recorded - FULL : All logs will be generated and dumped - CUSTOM : Some customised level of dumping When first set to CUSTOM this is equivalent to SUMMARY. dump_to_file : bool; If set True then data will be dumped to file during the optimisation; dumping will be set to SUMMARY during init_optim; if dump_to_file is True and dumping not set.; Default is False. dump_dir : string; Basically a link to dump.dump_dir. Exists so th",MatchSource.WIKI,docs/4.3/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/apidoc/classes.html
https://qutip.org/docs/4.3/apidoc/classes.html:71739,Performance,optimiz,optimize,71739," be recorded - FULL : All logs will be generated and dumped - CUSTOM : Some customised level of dumping When first set to CUSTOM this is equivalent to SUMMARY. dump_to_file : bool; If set True then data will be dumped to file during the optimisation; dumping will be set to SUMMARY during init_optim; if dump_to_file is True and dumping not set.; Default is False. dump_dir : string; Basically a link to dump.dump_dir. Exists so that it can be set through; optim_params.; If dump is None then will return None or will set dumping to SUMMARY; when setting a path. iter_summary : OptimIterSummary; Summary of the most recent iteration.; Note this is only set if dummping is on. apply_method_params(params=None)[source]Â¶; Loops through all the method_params; (either passed here or the method_params attribute); If the name matches an attribute of this object or the; termination conditions object, then the value of this attribute; is set. Otherwise it is assumed to a method_option for the; scipy.optimize.minimize function. apply_params(params=None)[source]Â¶; Set object attributes based on the dictionary (if any) passed in the; instantiation, or passed as a parameter; This is called during the instantiation automatically.; The key value pairs are the attribute name and value; Note: attributes are created if they do not exist already,; and are overwritten if they do. dumpingÂ¶. The level of data dumping that will occur during the optimisation. NONE : No processing data dumped (Default); SUMMARY : A summary at each iteration will be recorded; FULL : All logs will be generated and dumped; CUSTOM : Some customised level of dumping. When first set to CUSTOM this is equivalent to SUMMARY. It is then up; to the user to specify which logs are dumped. fid_err_func_wrapper(*args)[source]Â¶; Get the fidelity error achieved using the ctrl amplitudes passed; in as the first argument.; This is called by generic optimisation algorithm as the; func to the minimised. The argument is the current; varia",MatchSource.WIKI,docs/4.3/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/apidoc/classes.html
https://qutip.org/docs/4.3/apidoc/classes.html:74287,Performance,optimiz,optimize,74287,"t the variables. The argument is the current; variable values, i.e. control amplitudes, passed as; a flat array. Hence these are reshaped as [nTimeslots, n_ctrls]; and then used to update the stored ctrl values (if they have changed); Although the optimisation algorithms have a check within them for; function convergence, i.e. local minima, the sum of the squares; of the normalised gradient is checked explicitly, and the; optimisation is terminated if this is below the min_gradient_norm; condition. init_optim(term_conds)[source]Â¶; Check optimiser attribute status and passed parameters before; running the optimisation.; This is called by run_optimization, but could called independently; to check the configuration. iter_step_callback_func(*args)[source]Â¶; Check the elapsed wall time for the optimisation run so far.; Terminate if this has exceeded the maximum allowed time. run_optimization(term_conds=None)[source]Â¶; This default function optimisation method is a wrapper to the; scipy.optimize.minimize function.; It will attempt to minimise the fidelity error with respect to some; parameters, which are determined by _get_optim_var_vals (see below); The optimisation end when one of the passed termination conditions; has been met, e.g. target achieved, wall time, or; function call or iteration count exceeded. Note these; conditions include gradient minimum met (local minima) for; methods that use a gradient.; The function minimisation method is taken from the optim_method; attribute. Note that not all of these methods have been tested.; Note that some of these use a gradient and some do not.; See the scipy documentation for details. Options specific to the; method can be passed setting the method_params attribute.; If the parameter term_conds=None, then the termination_conditions; attribute must already be set. It will be overwritten if the; parameter is not None; The result is returned in an OptimResult object, which includes; the final fidelity, time evolution, reason fo",MatchSource.WIKI,docs/4.3/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/apidoc/classes.html
https://qutip.org/docs/4.3/apidoc/classes.html:75831,Performance,optimiz,optimize,75831,"een tested.; Note that some of these use a gradient and some do not.; See the scipy documentation for details. Options specific to the; method can be passed setting the method_params attribute.; If the parameter term_conds=None, then the termination_conditions; attribute must already be set. It will be overwritten if the; parameter is not None; The result is returned in an OptimResult object, which includes; the final fidelity, time evolution, reason for termination etc. class OptimizerBFGS(config, dyn, params=None)[source]Â¶; Implements the run_optimization method using the BFGS algorithm. run_optimization(term_conds=None)[source]Â¶; Optimise the control pulse amplitudes to minimise the fidelity error; using the BFGS (BroydenâFletcherâGoldfarbâShanno) algorithm; The optimisation end when one of the passed termination conditions; has been met, e.g. target achieved, gradient minimum met; (local minima), wall time / iteration count exceeded.; Essentially this is wrapper to the:; scipy.optimize.fmin_bfgs; function; If the parameter term_conds=None, then the termination_conditions; attribute must already be set. It will be overwritten if the; parameter is not None; The result is returned in an OptimResult object, which includes; the final fidelity, time evolution, reason for termination etc. class OptimizerLBFGSB(config, dyn, params=None)[source]Â¶; Implements the run_optimization method using the L-BFGS-B algorithm. Attributes:; max_metric_corr : integer; The maximum number of variable metric corrections used to define; the limited memory matrix. That is the number of previous; gradient values that are used to approximate the Hessian; see the scipy.optimize.fmin_l_bfgs_b documentation for description; of m argument. init_optim(term_conds)[source]Â¶; Check optimiser attribute status and passed parameters before; running the optimisation.; This is called by run_optimization, but could called independently; to check the configuration. run_optimization(term_conds=None)[source]Â¶",MatchSource.WIKI,docs/4.3/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/apidoc/classes.html
https://qutip.org/docs/4.3/apidoc/classes.html:76506,Performance,optimiz,optimize,76506,"des to minimise the fidelity error; using the BFGS (BroydenâFletcherâGoldfarbâShanno) algorithm; The optimisation end when one of the passed termination conditions; has been met, e.g. target achieved, gradient minimum met; (local minima), wall time / iteration count exceeded.; Essentially this is wrapper to the:; scipy.optimize.fmin_bfgs; function; If the parameter term_conds=None, then the termination_conditions; attribute must already be set. It will be overwritten if the; parameter is not None; The result is returned in an OptimResult object, which includes; the final fidelity, time evolution, reason for termination etc. class OptimizerLBFGSB(config, dyn, params=None)[source]Â¶; Implements the run_optimization method using the L-BFGS-B algorithm. Attributes:; max_metric_corr : integer; The maximum number of variable metric corrections used to define; the limited memory matrix. That is the number of previous; gradient values that are used to approximate the Hessian; see the scipy.optimize.fmin_l_bfgs_b documentation for description; of m argument. init_optim(term_conds)[source]Â¶; Check optimiser attribute status and passed parameters before; running the optimisation.; This is called by run_optimization, but could called independently; to check the configuration. run_optimization(term_conds=None)[source]Â¶; Optimise the control pulse amplitudes to minimise the fidelity error; using the L-BFGS-B algorithm, which is the constrained; (bounded amplitude values), limited memory, version of the; BroydenâFletcherâGoldfarbâShanno algorithm.; The optimisation end when one of the passed termination conditions; has been met, e.g. target achieved, gradient minimum met; (local minima), wall time / iteration count exceeded.; Essentially this is wrapper to the:; scipy.optimize.fmin_l_bfgs_b function; This in turn is a warpper for well established implementation of; the L-BFGS-B algorithm written in Fortran, which is therefore; very fast. See SciPy documentation for credit and detail",MatchSource.WIKI,docs/4.3/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/apidoc/classes.html
https://qutip.org/docs/4.3/apidoc/classes.html:77293,Performance,optimiz,optimize,77293," : integer; The maximum number of variable metric corrections used to define; the limited memory matrix. That is the number of previous; gradient values that are used to approximate the Hessian; see the scipy.optimize.fmin_l_bfgs_b documentation for description; of m argument. init_optim(term_conds)[source]Â¶; Check optimiser attribute status and passed parameters before; running the optimisation.; This is called by run_optimization, but could called independently; to check the configuration. run_optimization(term_conds=None)[source]Â¶; Optimise the control pulse amplitudes to minimise the fidelity error; using the L-BFGS-B algorithm, which is the constrained; (bounded amplitude values), limited memory, version of the; BroydenâFletcherâGoldfarbâShanno algorithm.; The optimisation end when one of the passed termination conditions; has been met, e.g. target achieved, gradient minimum met; (local minima), wall time / iteration count exceeded.; Essentially this is wrapper to the:; scipy.optimize.fmin_l_bfgs_b function; This in turn is a warpper for well established implementation of; the L-BFGS-B algorithm written in Fortran, which is therefore; very fast. See SciPy documentation for credit and details on; this function.; If the parameter term_conds=None, then the termination_conditions; attribute must already be set. It will be overwritten if the; parameter is not None; The result is returned in an OptimResult object, which includes; the final fidelity, time evolution, reason for termination etc. class OptimizerCrab(config, dyn, params=None)[source]Â¶; Optimises the pulse using the CRAB algorithm [1].; It uses the scipy.optimize.minimize function with the method specified; by the optim_method attribute. See Optimizer.run_optimization for details; It minimises the fidelity error function with respect to the CRAB; basis function coefficients.; AJGP ToDo: Add citation here. init_optim(term_conds)[source]Â¶; Check optimiser attribute status and passed parameters before; running",MatchSource.WIKI,docs/4.3/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/apidoc/classes.html
https://qutip.org/docs/4.3/apidoc/classes.html:77939,Performance,optimiz,optimize,77939," is the constrained; (bounded amplitude values), limited memory, version of the; BroydenâFletcherâGoldfarbâShanno algorithm.; The optimisation end when one of the passed termination conditions; has been met, e.g. target achieved, gradient minimum met; (local minima), wall time / iteration count exceeded.; Essentially this is wrapper to the:; scipy.optimize.fmin_l_bfgs_b function; This in turn is a warpper for well established implementation of; the L-BFGS-B algorithm written in Fortran, which is therefore; very fast. See SciPy documentation for credit and details on; this function.; If the parameter term_conds=None, then the termination_conditions; attribute must already be set. It will be overwritten if the; parameter is not None; The result is returned in an OptimResult object, which includes; the final fidelity, time evolution, reason for termination etc. class OptimizerCrab(config, dyn, params=None)[source]Â¶; Optimises the pulse using the CRAB algorithm [1].; It uses the scipy.optimize.minimize function with the method specified; by the optim_method attribute. See Optimizer.run_optimization for details; It minimises the fidelity error function with respect to the CRAB; basis function coefficients.; AJGP ToDo: Add citation here. init_optim(term_conds)[source]Â¶; Check optimiser attribute status and passed parameters before; running the optimisation.; This is called by run_optimization, but could called independently; to check the configuration. class OptimizerCrabFmin(config, dyn, params=None)[source]Â¶; Optimises the pulse using the CRAB algorithm [1, 2].; It uses the scipy.optimize.fmin function which is effectively a wrapper; for the Nelder-mead method.; It minimises the fidelity error function with respect to the CRAB; basis function coefficients.; This is the default Optimizer for CRAB.; Notes. [1] P. Doria, T. Calarco & S. Montangero. Phys. Rev. Lett. 106,; 190501 (2011). [2] T. Caneva, T. Calarco, & S. Montangero. Phys. Rev. A 84, 022326 (2011). run_optimizat",MatchSource.WIKI,docs/4.3/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/apidoc/classes.html
https://qutip.org/docs/4.3/apidoc/classes.html:78546,Performance,optimiz,optimize,78546,"term_conds=None, then the termination_conditions; attribute must already be set. It will be overwritten if the; parameter is not None; The result is returned in an OptimResult object, which includes; the final fidelity, time evolution, reason for termination etc. class OptimizerCrab(config, dyn, params=None)[source]Â¶; Optimises the pulse using the CRAB algorithm [1].; It uses the scipy.optimize.minimize function with the method specified; by the optim_method attribute. See Optimizer.run_optimization for details; It minimises the fidelity error function with respect to the CRAB; basis function coefficients.; AJGP ToDo: Add citation here. init_optim(term_conds)[source]Â¶; Check optimiser attribute status and passed parameters before; running the optimisation.; This is called by run_optimization, but could called independently; to check the configuration. class OptimizerCrabFmin(config, dyn, params=None)[source]Â¶; Optimises the pulse using the CRAB algorithm [1, 2].; It uses the scipy.optimize.fmin function which is effectively a wrapper; for the Nelder-mead method.; It minimises the fidelity error function with respect to the CRAB; basis function coefficients.; This is the default Optimizer for CRAB.; Notes. [1] P. Doria, T. Calarco & S. Montangero. Phys. Rev. Lett. 106,; 190501 (2011). [2] T. Caneva, T. Calarco, & S. Montangero. Phys. Rev. A 84, 022326 (2011). run_optimization(term_conds=None)[source]Â¶; This function optimisation method is a wrapper to the; scipy.optimize.fmin function.; It will attempt to minimise the fidelity error with respect to some; parameters, which are determined by _get_optim_var_vals which; in the case of CRAB are the basis function coefficients; The optimisation end when one of the passed termination conditions; has been met, e.g. target achieved, wall time, or; function call or iteration count exceeded. Specifically to the fmin; method, the optimisation will stop when change parameter values; is less than xtol or the change in function valu",MatchSource.WIKI,docs/4.3/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/apidoc/classes.html
https://qutip.org/docs/4.3/apidoc/classes.html:79036,Performance,optimiz,optimize,79036,"n_optimization for details; It minimises the fidelity error function with respect to the CRAB; basis function coefficients.; AJGP ToDo: Add citation here. init_optim(term_conds)[source]Â¶; Check optimiser attribute status and passed parameters before; running the optimisation.; This is called by run_optimization, but could called independently; to check the configuration. class OptimizerCrabFmin(config, dyn, params=None)[source]Â¶; Optimises the pulse using the CRAB algorithm [1, 2].; It uses the scipy.optimize.fmin function which is effectively a wrapper; for the Nelder-mead method.; It minimises the fidelity error function with respect to the CRAB; basis function coefficients.; This is the default Optimizer for CRAB.; Notes. [1] P. Doria, T. Calarco & S. Montangero. Phys. Rev. Lett. 106,; 190501 (2011). [2] T. Caneva, T. Calarco, & S. Montangero. Phys. Rev. A 84, 022326 (2011). run_optimization(term_conds=None)[source]Â¶; This function optimisation method is a wrapper to the; scipy.optimize.fmin function.; It will attempt to minimise the fidelity error with respect to some; parameters, which are determined by _get_optim_var_vals which; in the case of CRAB are the basis function coefficients; The optimisation end when one of the passed termination conditions; has been met, e.g. target achieved, wall time, or; function call or iteration count exceeded. Specifically to the fmin; method, the optimisation will stop when change parameter values; is less than xtol or the change in function value is below ftol.; If the parameter term_conds=None, then the termination_conditions; attribute must already be set. It will be overwritten if the; parameter is not None; The result is returned in an OptimResult object, which includes; the final fidelity, time evolution, reason for termination etc. class OptimIterSummary[source]Â¶; A summary of the most recent iteration of the pulse optimisation. Attributes:; iter_num : int; Iteration number of the pulse optimisation. fid_func_call_num :",MatchSource.WIKI,docs/4.3/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/apidoc/classes.html
https://qutip.org/docs/4.3/apidoc/classes.html:81383,Performance,optimiz,optimize,81383," optimisation so far; (in seconds of elapsed time). class TerminationConditions[source]Â¶; Base class for all termination conditions; Used to determine when to stop the optimisation algorithm; Note different subclasses should be used to match the type of; optimisation being used. Attributes:; fid_err_targ : float; Target fidelity error. fid_goal : float; goal fidelity, e.g. 1 - self.fid_err_targ; It its typical to set this for unitary systems. max_wall_time : float; # maximum time for optimisation (seconds). min_gradient_norm : float; Minimum normalised gradient after which optimisation will terminate. max_iterations : integer; Maximum iterations of the optimisation algorithm. max_fid_func_calls : integer; Maximum number of calls to the fidelity function during; the optimisation algorithm. accuracy_factor : float; Determines the accuracy of the result.; Typical values for accuracy_factor are: 1e12 for low accuracy;; 1e7 for moderate accuracy; 10.0 for extremely high accuracy; scipy.optimize.fmin_l_bfgs_b factr argument.; Only set for specific methods (fmin_l_bfgs_b) that uses this; Otherwise the same thing is passed as method_option ftol; (although the scale is different); Hence it is not defined here, but may be set by the user. class OptimResult[source]Â¶; Attributes give the result of the pulse optimisation attempt. Attributes:; termination_reason : string; Description of the reason for terminating the optimisation. fidelity : float; final (normalised) fidelity that was achieved. initial_fid_err : float; fidelity error before optimisation starting. fid_err : float; final fidelity error that was achieved. goal_achieved : boolean; True is the fidely error achieved was below the target. grad_norm_final : float; Final value of the sum of the squares of the (normalised) fidelity; error gradients. grad_norm_min_reached : float; True if the optimisation terminated due to the minimum value; of the gradient being reached. num_iter : integer; Number of iterations of the optim",MatchSource.WIKI,docs/4.3/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/apidoc/classes.html
https://qutip.org/docs/4.3/apidoc/classes.html:83267,Performance,optimiz,optimizer,83267,"f the gradient being reached. num_iter : integer; Number of iterations of the optimisation algorithm completed. max_iter_exceeded : boolean; True if the iteration limit was reached. max_fid_func_exceeded : boolean; True if the fidelity function call limit was reached. wall_time : float; time elapsed during the optimisation. wall_time_limit_exceeded : boolean; True if the wall time limit was reached. time : array[num_tslots+1] of float; Time are the start of each timeslot; with the final value being the total evolution time. initial_amps : array[num_tslots, n_ctrls]; The amplitudes at the start of the optimisation. final_amps : array[num_tslots, n_ctrls]; The amplitudes at the end of the optimisation. evo_full_final : Qobj; The evolution operator from t=0 to t=T based on the final amps. evo_full_initial : Qobj; The evolution operator from t=0 to t=T based on the initial amps. stats : Stats; Object contaning the stats for the run (if any collected). optimizer : Optimizer; Instance of the Optimizer used to generate the result. class Dynamics(optimconfig, params=None)[source]Â¶; This is a base class only. See subclass descriptions and choose an; appropriate one for the application.; Note that initialize_controls must be called before most of the methods; can be used. init_timeslots can be called sometimes earlier in order; to access timeslot related attributes; This acts as a container for the operators that are used to calculate; time evolution of the system under study. That is the dynamics generators; (Hamiltonians, Lindbladians etc), the propagators from one timeslot to; the next, and the evolution operators. Due to the large number of matrix; additions and multiplications, for small systems at least, the optimisation; performance is much better using ndarrays to represent these operators.; However. Attributes:; log_level : integer; level of messaging output from the logger.; Options are attributes of qutip.logging_utils,; in decreasing levels of messaging, are:; DEB",MatchSource.WIKI,docs/4.3/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/apidoc/classes.html
https://qutip.org/docs/4.3/apidoc/classes.html:84053,Performance,perform,performance,84053,"Qobj; The evolution operator from t=0 to t=T based on the final amps. evo_full_initial : Qobj; The evolution operator from t=0 to t=T based on the initial amps. stats : Stats; Object contaning the stats for the run (if any collected). optimizer : Optimizer; Instance of the Optimizer used to generate the result. class Dynamics(optimconfig, params=None)[source]Â¶; This is a base class only. See subclass descriptions and choose an; appropriate one for the application.; Note that initialize_controls must be called before most of the methods; can be used. init_timeslots can be called sometimes earlier in order; to access timeslot related attributes; This acts as a container for the operators that are used to calculate; time evolution of the system under study. That is the dynamics generators; (Hamiltonians, Lindbladians etc), the propagators from one timeslot to; the next, and the evolution operators. Due to the large number of matrix; additions and multiplications, for small systems at least, the optimisation; performance is much better using ndarrays to represent these operators.; However. Attributes:; log_level : integer; level of messaging output from the logger.; Options are attributes of qutip.logging_utils,; in decreasing levels of messaging, are:; DEBUG_INTENSE, DEBUG_VERBOSE, DEBUG, INFO, WARN, ERROR, CRITICAL; Anything WARN or above is effectively âquietâ execution,; assuming everything runs as expected.; The default NOTSET implies that the level will be taken from; the QuTiP settings file, which by default is WARN. params: Dictionary; The key value pairs are the attribute name and value; Note: attributes are created if they do not exist already,; and are overwritten if they do. stats : Stats; Attributes of which give performance stats for the optimisation; set to None to reduce overhead of calculating stats.; Note it is (usually) shared with the Optimizer object. tslot_computer : TimeslotComputer (subclass instance); Used to manage when the timeslot dynamics; g",MatchSource.WIKI,docs/4.3/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/apidoc/classes.html
https://qutip.org/docs/4.3/apidoc/classes.html:84784,Performance,perform,performance,84784,"dynamics generators; (Hamiltonians, Lindbladians etc), the propagators from one timeslot to; the next, and the evolution operators. Due to the large number of matrix; additions and multiplications, for small systems at least, the optimisation; performance is much better using ndarrays to represent these operators.; However. Attributes:; log_level : integer; level of messaging output from the logger.; Options are attributes of qutip.logging_utils,; in decreasing levels of messaging, are:; DEBUG_INTENSE, DEBUG_VERBOSE, DEBUG, INFO, WARN, ERROR, CRITICAL; Anything WARN or above is effectively âquietâ execution,; assuming everything runs as expected.; The default NOTSET implies that the level will be taken from; the QuTiP settings file, which by default is WARN. params: Dictionary; The key value pairs are the attribute name and value; Note: attributes are created if they do not exist already,; and are overwritten if they do. stats : Stats; Attributes of which give performance stats for the optimisation; set to None to reduce overhead of calculating stats.; Note it is (usually) shared with the Optimizer object. tslot_computer : TimeslotComputer (subclass instance); Used to manage when the timeslot dynamics; generators, propagators, gradients etc are updated. prop_computer : PropagatorComputer (subclass instance); Used to compute the propagators and their gradients. fid_computer : FidelityComputer (subclass instance); Used to computer the fidelity error and the fidelity error; gradient. memory_optimization : int; Level of memory optimisation. Setting to 0 (default) means that; execution speed is prioritized over memory.; Setting to 1 means that some memory prioritisation steps will be; taken, for instance using Qobj (and hence sparse arrays) as the; the internal operator data type, and not caching some operators; Potentially further memory saving maybe made with; memory_optimization > 1.; The options are processed in _set_memory_optimizations, see; this for more informatio",MatchSource.WIKI,docs/4.3/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/apidoc/classes.html
https://qutip.org/docs/4.3/apidoc/classes.html:86134,Performance,perform,performs,86134,"compute the propagators and their gradients. fid_computer : FidelityComputer (subclass instance); Used to computer the fidelity error and the fidelity error; gradient. memory_optimization : int; Level of memory optimisation. Setting to 0 (default) means that; execution speed is prioritized over memory.; Setting to 1 means that some memory prioritisation steps will be; taken, for instance using Qobj (and hence sparse arrays) as the; the internal operator data type, and not caching some operators; Potentially further memory saving maybe made with; memory_optimization > 1.; The options are processed in _set_memory_optimizations, see; this for more information. Individual memory saving options can be; switched by settting them directly (see below). oper_dtype : type; Data type for internal dynamics generators, propagators and time; evolution operators. This can be ndarray or Qobj, or (in theory) any; other representaion that supports typical matrix methods (e.g. dot); ndarray performs best for smaller quantum systems.; Qobj may perform better for larger systems, and will also; perform better when (custom) fidelity measures use Qobj methods; such as partial trace.; See _choose_oper_dtype for how this is chosen when not specified. cache_phased_dyn_gen : bool; If True then the dynamics generators will be saved with and; without the propagation prefactor (if there is one); Defaults to True when memory_optimization=0, otherwise False. cache_prop_grad : bool; If the True then the propagator gradients (for exact gradients) will; be computed when the propagator are computed and cache until; the are used by the fidelity computer. If False then the; fidelity computer will calculate them as needed.; Defaults to True when memory_optimization=0, otherwise False. cache_dyn_gen_eigenvectors_adj: bool; If True then DynamicsUnitary will cached the adjoint of; the Hamiltion eignvector matrix; Defaults to True when memory_optimization=0, otherwise False. sparse_eigen_decomp: bool; If True ",MatchSource.WIKI,docs/4.3/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/apidoc/classes.html
https://qutip.org/docs/4.3/apidoc/classes.html:86187,Performance,perform,perform,86187,"to computer the fidelity error and the fidelity error; gradient. memory_optimization : int; Level of memory optimisation. Setting to 0 (default) means that; execution speed is prioritized over memory.; Setting to 1 means that some memory prioritisation steps will be; taken, for instance using Qobj (and hence sparse arrays) as the; the internal operator data type, and not caching some operators; Potentially further memory saving maybe made with; memory_optimization > 1.; The options are processed in _set_memory_optimizations, see; this for more information. Individual memory saving options can be; switched by settting them directly (see below). oper_dtype : type; Data type for internal dynamics generators, propagators and time; evolution operators. This can be ndarray or Qobj, or (in theory) any; other representaion that supports typical matrix methods (e.g. dot); ndarray performs best for smaller quantum systems.; Qobj may perform better for larger systems, and will also; perform better when (custom) fidelity measures use Qobj methods; such as partial trace.; See _choose_oper_dtype for how this is chosen when not specified. cache_phased_dyn_gen : bool; If True then the dynamics generators will be saved with and; without the propagation prefactor (if there is one); Defaults to True when memory_optimization=0, otherwise False. cache_prop_grad : bool; If the True then the propagator gradients (for exact gradients) will; be computed when the propagator are computed and cache until; the are used by the fidelity computer. If False then the; fidelity computer will calculate them as needed.; Defaults to True when memory_optimization=0, otherwise False. cache_dyn_gen_eigenvectors_adj: bool; If True then DynamicsUnitary will cached the adjoint of; the Hamiltion eignvector matrix; Defaults to True when memory_optimization=0, otherwise False. sparse_eigen_decomp: bool; If True then DynamicsUnitary will use the sparse eigenvalue; decomposition.; Defaults to True when memory_opti",MatchSource.WIKI,docs/4.3/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/apidoc/classes.html
https://qutip.org/docs/4.3/apidoc/classes.html:86237,Performance,perform,perform,86237,"to computer the fidelity error and the fidelity error; gradient. memory_optimization : int; Level of memory optimisation. Setting to 0 (default) means that; execution speed is prioritized over memory.; Setting to 1 means that some memory prioritisation steps will be; taken, for instance using Qobj (and hence sparse arrays) as the; the internal operator data type, and not caching some operators; Potentially further memory saving maybe made with; memory_optimization > 1.; The options are processed in _set_memory_optimizations, see; this for more information. Individual memory saving options can be; switched by settting them directly (see below). oper_dtype : type; Data type for internal dynamics generators, propagators and time; evolution operators. This can be ndarray or Qobj, or (in theory) any; other representaion that supports typical matrix methods (e.g. dot); ndarray performs best for smaller quantum systems.; Qobj may perform better for larger systems, and will also; perform better when (custom) fidelity measures use Qobj methods; such as partial trace.; See _choose_oper_dtype for how this is chosen when not specified. cache_phased_dyn_gen : bool; If True then the dynamics generators will be saved with and; without the propagation prefactor (if there is one); Defaults to True when memory_optimization=0, otherwise False. cache_prop_grad : bool; If the True then the propagator gradients (for exact gradients) will; be computed when the propagator are computed and cache until; the are used by the fidelity computer. If False then the; fidelity computer will calculate them as needed.; Defaults to True when memory_optimization=0, otherwise False. cache_dyn_gen_eigenvectors_adj: bool; If True then DynamicsUnitary will cached the adjoint of; the Hamiltion eignvector matrix; Defaults to True when memory_optimization=0, otherwise False. sparse_eigen_decomp: bool; If True then DynamicsUnitary will use the sparse eigenvalue; decomposition.; Defaults to True when memory_opti",MatchSource.WIKI,docs/4.3/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/apidoc/classes.html
https://qutip.org/docs/4.3/apidoc/classes.html:86740,Performance,cache,cache,86740,"with; memory_optimization > 1.; The options are processed in _set_memory_optimizations, see; this for more information. Individual memory saving options can be; switched by settting them directly (see below). oper_dtype : type; Data type for internal dynamics generators, propagators and time; evolution operators. This can be ndarray or Qobj, or (in theory) any; other representaion that supports typical matrix methods (e.g. dot); ndarray performs best for smaller quantum systems.; Qobj may perform better for larger systems, and will also; perform better when (custom) fidelity measures use Qobj methods; such as partial trace.; See _choose_oper_dtype for how this is chosen when not specified. cache_phased_dyn_gen : bool; If True then the dynamics generators will be saved with and; without the propagation prefactor (if there is one); Defaults to True when memory_optimization=0, otherwise False. cache_prop_grad : bool; If the True then the propagator gradients (for exact gradients) will; be computed when the propagator are computed and cache until; the are used by the fidelity computer. If False then the; fidelity computer will calculate them as needed.; Defaults to True when memory_optimization=0, otherwise False. cache_dyn_gen_eigenvectors_adj: bool; If True then DynamicsUnitary will cached the adjoint of; the Hamiltion eignvector matrix; Defaults to True when memory_optimization=0, otherwise False. sparse_eigen_decomp: bool; If True then DynamicsUnitary will use the sparse eigenvalue; decomposition.; Defaults to True when memory_optimization<=1, otherwise False. num_tslots : integer; Number of timeslots (aka timeslices). num_ctrls : integer; calculate the of controls from the length of the control list. evo_time : float; Total time for the evolution. tau : array[num_tslots] of float; Duration of each timeslot; Note that if this is set before initialize_controls is called; then num_tslots and evo_time are calculated from tau, otherwise; tau is generated from num_tslots ",MatchSource.WIKI,docs/4.3/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/apidoc/classes.html
https://qutip.org/docs/4.3/apidoc/classes.html:86995,Performance,cache,cached,86995,"be ndarray or Qobj, or (in theory) any; other representaion that supports typical matrix methods (e.g. dot); ndarray performs best for smaller quantum systems.; Qobj may perform better for larger systems, and will also; perform better when (custom) fidelity measures use Qobj methods; such as partial trace.; See _choose_oper_dtype for how this is chosen when not specified. cache_phased_dyn_gen : bool; If True then the dynamics generators will be saved with and; without the propagation prefactor (if there is one); Defaults to True when memory_optimization=0, otherwise False. cache_prop_grad : bool; If the True then the propagator gradients (for exact gradients) will; be computed when the propagator are computed and cache until; the are used by the fidelity computer. If False then the; fidelity computer will calculate them as needed.; Defaults to True when memory_optimization=0, otherwise False. cache_dyn_gen_eigenvectors_adj: bool; If True then DynamicsUnitary will cached the adjoint of; the Hamiltion eignvector matrix; Defaults to True when memory_optimization=0, otherwise False. sparse_eigen_decomp: bool; If True then DynamicsUnitary will use the sparse eigenvalue; decomposition.; Defaults to True when memory_optimization<=1, otherwise False. num_tslots : integer; Number of timeslots (aka timeslices). num_ctrls : integer; calculate the of controls from the length of the control list. evo_time : float; Total time for the evolution. tau : array[num_tslots] of float; Duration of each timeslot; Note that if this is set before initialize_controls is called; then num_tslots and evo_time are calculated from tau, otherwise; tau is generated from num_tslots and evo_time, that is; equal size time slices. time : array[num_tslots+1] of float; Cumulative time for the evolution, that is the time at the start; of each time slice. drift_dyn_gen : Qobj or list of Qobj; Drift or system dynamics generator (Hamiltonian); Matrix defining the underlying dynamics of the system; Can also b",MatchSource.WIKI,docs/4.3/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/apidoc/classes.html
https://qutip.org/docs/4.3/apidoc/classes.html:104200,Performance,cache,cached,104200,":; phase_option : string. determines how global phase is treated in fidelity calculations:; PSU - global phase ignored; SU - global phase included. fidelity_prenorm : complex; Last computed value of the fidelity before it is normalised; It is stored to use in the gradient normalisation calculation. fidelity_prenorm_current : boolean; flag to specify whether fidelity_prenorm are based on the; current amplitude values. Set False when amplitudes change. clear()[source]Â¶; clear any temporarily held status data. compute_fid_grad()[source]Â¶; Calculates exact gradient of function wrt to each timeslot; control amplitudes. Note these gradients are not normalised; These are returned as a (nTimeslots x n_ctrls) array. flag_system_changed()[source]Â¶; Flag fidelity and gradients as needing recalculation. get_fid_err()[source]Â¶; Gets the absolute error in the fidelity. get_fid_err_gradient()[source]Â¶; Returns the normalised gradient of the fidelity error; in a (nTimeslots x n_ctrls) array; The gradients are cached in case they are requested; mutliple times between control updates; (although this is not typically found to happen). get_fidelity()[source]Â¶; Gets the appropriately normalised fidelity value; The normalisation is determined by the fid_norm_func pointer; which should be set in the config. get_fidelity_prenorm()[source]Â¶; Gets the current fidelity value prior to normalisation; Note the gradient function uses this value; The value is cached, because it is used in the gradient calculation. init_comp()[source]Â¶; Check configuration and initialise the normalisation. init_normalization()[source]Â¶; Calc norm of <Ufinal | Ufinal> to scale subsequent norms; When considering unitary time evolution operators, this basically; results in calculating the trace of the identity matrix; and is hence equal to the size of the target matrix; There may be situations where this is not the case, and hence it; is not assumed to be so.; The normalisation function called should be set to either ",MatchSource.WIKI,docs/4.3/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/apidoc/classes.html
https://qutip.org/docs/4.3/apidoc/classes.html:104643,Performance,cache,cached,104643,"litude values. Set False when amplitudes change. clear()[source]Â¶; clear any temporarily held status data. compute_fid_grad()[source]Â¶; Calculates exact gradient of function wrt to each timeslot; control amplitudes. Note these gradients are not normalised; These are returned as a (nTimeslots x n_ctrls) array. flag_system_changed()[source]Â¶; Flag fidelity and gradients as needing recalculation. get_fid_err()[source]Â¶; Gets the absolute error in the fidelity. get_fid_err_gradient()[source]Â¶; Returns the normalised gradient of the fidelity error; in a (nTimeslots x n_ctrls) array; The gradients are cached in case they are requested; mutliple times between control updates; (although this is not typically found to happen). get_fidelity()[source]Â¶; Gets the appropriately normalised fidelity value; The normalisation is determined by the fid_norm_func pointer; which should be set in the config. get_fidelity_prenorm()[source]Â¶; Gets the current fidelity value prior to normalisation; Note the gradient function uses this value; The value is cached, because it is used in the gradient calculation. init_comp()[source]Â¶; Check configuration and initialise the normalisation. init_normalization()[source]Â¶; Calc norm of <Ufinal | Ufinal> to scale subsequent norms; When considering unitary time evolution operators, this basically; results in calculating the trace of the identity matrix; and is hence equal to the size of the target matrix; There may be situations where this is not the case, and hence it; is not assumed to be so.; The normalisation function called should be set to either the; PSU - global phase ignored; SU - global phase respected. normalize_PSU(A)[source]Â¶. normalize_SU(A)[source]Â¶. normalize_gradient_PSU(grad)[source]Â¶; Normalise the gradient matrix passed as grad; This PSU version is independent of global phase. normalize_gradient_SU(grad)[source]Â¶; Normalise the gradient matrix passed as grad; This SU version respects global phase. reset()[source]Â¶; reset any config",MatchSource.WIKI,docs/4.3/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/apidoc/classes.html
https://qutip.org/docs/4.3/apidoc/classes.html:107158,Performance,cache,cached,107158,"easure for dynamics described by matrices; Note the gradient calculation is taken from:; âRobust quantum gates for open systems via optimal control:; Markovian versus non-Markovian dynamicsâ; Frederik F Floether, Pierre de Fouquieres, and Sophie G Schirmer. Attributes:; scale_factor : float; The fidelity error calculated is of some arbitary scale. This; factor can be used to scale the fidelity error such that it may; represent some physical measure; If None is given then it is caculated as 1/2N, where N; is the dimension of the drift, when the Dynamics are initialised. compute_fid_err_grad()[source]Â¶; Calculate exact gradient of the fidelity error function; wrt to each timeslot control amplitudes.; Uses the trace difference norm fidelity; These are returned as a (nTimeslots x n_ctrls) array. get_fid_err()[source]Â¶; Gets the absolute error in the fidelity. get_fid_err_gradient()[source]Â¶; Returns the normalised gradient of the fidelity error; in a (nTimeslots x n_ctrls) array; The gradients are cached in case they are requested; mutliple times between control updates; (although this is not typically found to happen). init_comp()[source]Â¶; initialises the computer based on the configuration of the Dynamics; Calculates the scale_factor is not already set. reset()[source]Â¶; reset any configuration data and; clear any temporarily held status data. class FidCompTraceDiffApprox(dynamics, params=None)[source]Â¶; As FidCompTraceDiff, except uses the finite difference method to; compute approximate gradients. Attributes:; epsilon : float; control amplitude offset to use when approximating the gradient wrt; a timeslot control amplitude. compute_fid_err_grad()[source]Â¶; Calculates gradient of function wrt to each timeslot; control amplitudes. Note these gradients are not normalised; They are calulated; These are returned as a (nTimeslots x n_ctrls) array. reset()[source]Â¶; reset any configuration data and; clear any temporarily held status data. class TimeslotComputer(dynamics, ",MatchSource.WIKI,docs/4.3/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/apidoc/classes.html
https://qutip.org/docs/4.3/apidoc/classes.html:125486,Performance,optimiz,optimizer,125486," in the subclass. dump_summary : bool; If True a summary is recorded each time a new item is added to the; the dump.; Default is True. summary_sep : str; delimiter for the summary file.; default is a space. data_sep : str; delimiter for the data files (arrays saved to file).; default is a space. summary_file : str; File path for summary file.; Automatically generated. Can be set specifically. create_dump_dir()[source]Â¶; Checks dump directory exists, creates it if not. levelÂ¶. The level of data dumping that will occur. SUMMARY : A summary will be recorded; FULL : All possible dumping; CUSTOM : Some customised level of dumping. When first set to CUSTOM this is equivalent to SUMMARY. It is then up; to the user to specify what specifically is dumped. class OptimDump(optim, level='SUMMARY')[source]Â¶; A container for dumps of optimisation data generated during the pulse; optimisation. Attributes:; dump_summary : bool; When True summary items are appended to the iter_summary. iter_summary : list of optimizer.OptimIterSummary; Summary at each iteration. dump_fid_err : bool; When True values are appended to the fid_err_log. fid_err_log : list of float; Fidelity error at each call of the fid_err_func. dump_grad_norm : bool; When True values are appended to the fid_err_log. grad_norm_log : list of float; Gradient norm at each call of the grad_norm_log. dump_grad : bool; When True values are appended to the grad_log. grad_log : list of ndarray; Gradients at each call of the fid_grad_func. add_iter_summary()[source]Â¶; add copy of current optimizer iteration summary. dump_allÂ¶; True if everything (ignoring the summary) is to be dumped. dump_anyÂ¶; True if anything other than the summary is to be dumped. update_fid_err_log(fid_err)[source]Â¶; add an entry to the fid_err log. update_grad_log(grad)[source]Â¶; add an entry to the grad log. update_grad_norm_log(grad_norm)[source]Â¶; add an entry to the grad_norm log. writeout(f=None)[source]Â¶; write all the logs and the summary out to fil",MatchSource.WIKI,docs/4.3/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/apidoc/classes.html
https://qutip.org/docs/4.3/apidoc/classes.html:126030,Performance,optimiz,optimizer,126030,"ary will be recorded; FULL : All possible dumping; CUSTOM : Some customised level of dumping. When first set to CUSTOM this is equivalent to SUMMARY. It is then up; to the user to specify what specifically is dumped. class OptimDump(optim, level='SUMMARY')[source]Â¶; A container for dumps of optimisation data generated during the pulse; optimisation. Attributes:; dump_summary : bool; When True summary items are appended to the iter_summary. iter_summary : list of optimizer.OptimIterSummary; Summary at each iteration. dump_fid_err : bool; When True values are appended to the fid_err_log. fid_err_log : list of float; Fidelity error at each call of the fid_err_func. dump_grad_norm : bool; When True values are appended to the fid_err_log. grad_norm_log : list of float; Gradient norm at each call of the grad_norm_log. dump_grad : bool; When True values are appended to the grad_log. grad_log : list of ndarray; Gradients at each call of the fid_grad_func. add_iter_summary()[source]Â¶; add copy of current optimizer iteration summary. dump_allÂ¶; True if everything (ignoring the summary) is to be dumped. dump_anyÂ¶; True if anything other than the summary is to be dumped. update_fid_err_log(fid_err)[source]Â¶; add an entry to the fid_err log. update_grad_log(grad)[source]Â¶; add an entry to the grad log. update_grad_norm_log(grad_norm)[source]Â¶; add an entry to the grad_norm log. writeout(f=None)[source]Â¶; write all the logs and the summary out to file(s). Parameters:; f : filename or filehandle; If specified then all summary and object data will go in one file.; If None is specified then type specific files will be generated; in the dump_dir; If a filehandle is specified then it must be a byte mode file; as numpy.savetxt is used, and requires this. class DynamicsDump(dynamics, level='SUMMARY')[source]Â¶; A container for dumps of dynamics data.; Mainly time evolution calculations. Attributes:; dump_summary : bool; If True a summary is recorded. evo_summary : list of :class:`tslotco",MatchSource.WIKI,docs/4.3/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/apidoc/classes.html
https://qutip.org/docs/4.3/apidoc/classes.html:10354,Safety,safe,safe,10354,"ntum operator is not square. extract_states(states_inds, normalize=False)[source]Â¶; Qobj with states in state_inds only. Parameters:; states_inds : list of integer; The states that should be kept. normalize : True / False; Weather or not the new Qobj instance should be normalized (default; is False). For Qobjs that represents density matrices or state; vectors normalized should probably be set to True, but for Qobjs; that represents operators in for example an Hamiltonian, normalize; should be False. Returns:; q : Qobj; A new instance of qutip.Qobj that contains only the states; corresponding to the indices in state_inds. Notes; Experimental. full(order='C', squeeze=False)[source]Â¶; Dense array from quantum object. Parameters:; order : str {âCâ, âFâ}; Return array in C (default) or Fortran ordering. squeeze : bool {False, True}; Squeeze output array. Returns:; data : array; Array of complex data from quantum objects data attribute. groundstate(sparse=False, tol=0, maxiter=100000, safe=True)[source]Â¶; Ground state Eigenvalue and Eigenvector.; Defined for quantum operators or superoperators only. Parameters:; sparse : bool; Use sparse Eigensolver. tol : float; Tolerance used by sparse Eigensolver (0 = machine precision).; The sparse solver may not converge if the tolerance is set too low. maxiter : int; Maximum number of iterations performed by sparse solver (if used). safe : bool (default=True); Check for degenerate ground state. Returns:; eigval : float; Eigenvalue for the ground state of quantum operator. eigvec : qobj; Eigenket for the ground state of quantum operator. Notes; The sparse eigensolver is much slower than the dense version.; Use sparse only if memory requirements demand it. matrix_element(bra, ket)[source]Â¶; Calculates a matrix element.; Gives the matrix element for the quantum object sandwiched between a; bra and ket vector. Parameters:; bra : qobj; Quantum object of type âbraâ or âketâ. ket : qobj; Quantum object of type âketâ. Returns:; elem : compl",MatchSource.WIKI,docs/4.3/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/apidoc/classes.html
https://qutip.org/docs/4.3/apidoc/classes.html:10749,Safety,safe,safe,10749," that represents operators in for example an Hamiltonian, normalize; should be False. Returns:; q : Qobj; A new instance of qutip.Qobj that contains only the states; corresponding to the indices in state_inds. Notes; Experimental. full(order='C', squeeze=False)[source]Â¶; Dense array from quantum object. Parameters:; order : str {âCâ, âFâ}; Return array in C (default) or Fortran ordering. squeeze : bool {False, True}; Squeeze output array. Returns:; data : array; Array of complex data from quantum objects data attribute. groundstate(sparse=False, tol=0, maxiter=100000, safe=True)[source]Â¶; Ground state Eigenvalue and Eigenvector.; Defined for quantum operators or superoperators only. Parameters:; sparse : bool; Use sparse Eigensolver. tol : float; Tolerance used by sparse Eigensolver (0 = machine precision).; The sparse solver may not converge if the tolerance is set too low. maxiter : int; Maximum number of iterations performed by sparse solver (if used). safe : bool (default=True); Check for degenerate ground state. Returns:; eigval : float; Eigenvalue for the ground state of quantum operator. eigvec : qobj; Eigenket for the ground state of quantum operator. Notes; The sparse eigensolver is much slower than the dense version.; Use sparse only if memory requirements demand it. matrix_element(bra, ket)[source]Â¶; Calculates a matrix element.; Gives the matrix element for the quantum object sandwiched between a; bra and ket vector. Parameters:; bra : qobj; Quantum object of type âbraâ or âketâ. ket : qobj; Quantum object of type âketâ. Returns:; elem : complex; Complex valued matrix element. norm(norm=None, sparse=False, tol=0, maxiter=100000)[source]Â¶; Norm of a quantum object.; Default norm is L2-norm for kets and trace-norm for operators.; Other ket and operator norms may be specified using the norm and; argument. Parameters:; norm : str; Which norm to use for ket/bra vectors: L2 âl2â, max norm âmaxâ,; or for operators: trace âtrâ, Frobius âfroâ, one âoneâ, or max; â",MatchSource.WIKI,docs/4.3/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/apidoc/classes.html
https://qutip.org/docs/4.3/apidoc/classes.html:44591,Safety,predict,predictor-corrector,44591,"rray; Array of length d2_len, containing scaling factors for each; measurement operator in m_ops. rhs : function; Function for calculating the deterministic and stochastic contributions; to the right-hand side of the stochastic differential equation. This; only needs to be specified when implementing a custom SDE solver. generate_A_ops : function; Function that generates a list of pre-computed operators or super-; operators. These precomputed operators are used in some d1 and d2; functions. generate_noise : function; Function for generate an array of pre-computed noise signal. homogeneous : bool (True); Wheter or not the stochastic process is homogenous. Inhomogenous; processes are only supported for poisson distributions. solver : string; Name of the solver method to use for solving the stochastic; equations. Valid values are:; 1/2 order algorithms: âeuler-maruyamaâ, âfast-euler-maruyamaâ,; âpc-eulerâ is a predictor-corrector method which is more; stable than explicit methods,; 1 order algorithms: âmilsteinâ, âfast-milsteinâ, âplatenâ,; âmilstein-impâ is semi-implicit Milstein method,; 3/2 order algorithms: âtaylor15â,; âtaylor15-impâ is semi-implicit Taylor 1.5 method.; Implicit methods can adjust tolerance via args = {âtolâ:value},; default is {âtolâ:1e-6}. method : string (âhomodyneâ, âheterodyneâ, âphotocurrentâ); The name of the type of measurement process that give rise to the; stochastic equation to solve. Specifying a method with this keyword; argument is a short-hand notation for using pre-defined d1 and d2; functions for the corresponding stochastic processes. distribution : string (ânormalâ, âpoissionâ); The name of the distribution used for the stochastic increments. store_measurements : bool (default False); Whether or not to store the measurement results in the; qutip.solver.SolverResult instance returned by the solver. noise : array; Vector specifying the noise. normalize : bool (default True); Whether or not to normalize the wave function during the ",MatchSource.WIKI,docs/4.3/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/apidoc/classes.html
https://qutip.org/docs/4.3/apidoc/classes.html:83648,Security,access,access,83648,"mit was reached. time : array[num_tslots+1] of float; Time are the start of each timeslot; with the final value being the total evolution time. initial_amps : array[num_tslots, n_ctrls]; The amplitudes at the start of the optimisation. final_amps : array[num_tslots, n_ctrls]; The amplitudes at the end of the optimisation. evo_full_final : Qobj; The evolution operator from t=0 to t=T based on the final amps. evo_full_initial : Qobj; The evolution operator from t=0 to t=T based on the initial amps. stats : Stats; Object contaning the stats for the run (if any collected). optimizer : Optimizer; Instance of the Optimizer used to generate the result. class Dynamics(optimconfig, params=None)[source]Â¶; This is a base class only. See subclass descriptions and choose an; appropriate one for the application.; Note that initialize_controls must be called before most of the methods; can be used. init_timeslots can be called sometimes earlier in order; to access timeslot related attributes; This acts as a container for the operators that are used to calculate; time evolution of the system under study. That is the dynamics generators; (Hamiltonians, Lindbladians etc), the propagators from one timeslot to; the next, and the evolution operators. Due to the large number of matrix; additions and multiplications, for small systems at least, the optimisation; performance is much better using ndarrays to represent these operators.; However. Attributes:; log_level : integer; level of messaging output from the logger.; Options are attributes of qutip.logging_utils,; in decreasing levels of messaging, are:; DEBUG_INTENSE, DEBUG_VERBOSE, DEBUG, INFO, WARN, ERROR, CRITICAL; Anything WARN or above is effectively âquietâ execution,; assuming everything runs as expected.; The default NOTSET implies that the level will be taken from; the QuTiP settings file, which by default is WARN. params: Dictionary; The key value pairs are the attribute name and value; Note: attributes are created if they do ",MatchSource.WIKI,docs/4.3/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/apidoc/classes.html
https://qutip.org/docs/4.3/apidoc/classes.html:67343,Testability,log,logger,67343,"ng; them together. load_circuit(qc)[source]Â¶; Translates an abstract quantum circuit to its corresponding Hamiltonian; for a specific model. Parameters:; qc: QubitCircuit; Takes the quantum circuit to be implemented. optimize_circuit(qc)[source]Â¶; Function to take a quantum circuit/algorithm and convert it into the; optimal form/basis for the desired physical system. Parameters:; qc: QubitCircuit; Takes the quantum circuit to be implemented. Returns:; qc: QubitCircuit; The optimal circuit representation. Optimal controlÂ¶. class Optimizer(config, dyn, params=None)[source]Â¶; Base class for all control pulse optimisers. This class should not be; instantiated, use its subclasses; This class implements the fidelity, gradient and interation callback; functions.; All subclass objects must be initialised with a. OptimConfig instance - various configuration options; Dynamics instance - describes the dynamics of the (quantum) system. to be control optimised. Attributes:; log_level : integer; level of messaging output from the logger.; Options are attributes of qutip.logging_utils,; in decreasing levels of messaging, are:; DEBUG_INTENSE, DEBUG_VERBOSE, DEBUG, INFO, WARN, ERROR, CRITICAL; Anything WARN or above is effectively âquietâ execution,; assuming everything runs as expected.; The default NOTSET implies that the level will be taken from; the QuTiP settings file, which by default is WARN. params: Dictionary; The key value pairs are the attribute name and value; Note: attributes are created if they do not exist already,; and are overwritten if they do. alg : string; Algorithm to use in pulse optimisation.; Options are:. âGRAPEâ (default) - GRadient Ascent Pulse Engineering; âCRABâ - Chopped RAndom Basis. alg_params : Dictionary; options that are specific to the pulse optim algorithm; that is GRAPE or CRAB. disp_conv_msg : bool; Set true to display a convergence message; (for scipy.optimize.minimize methods anyway). optim_method : string; a scipy.optimize.minimize method tha",MatchSource.WIKI,docs/4.3/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/apidoc/classes.html
https://qutip.org/docs/4.3/apidoc/classes.html:70769,Testability,log,logs,70769,"for details). config : OptimConfig instance; various configuration options; (see OptimConfig for details). termination_conditions : TerminationCondition instance; attributes determine when the optimisation will end. pulse_generator : PulseGen (subclass instance); (can be) used to create initial pulses; not used by the class, but set by pulseoptim.create_pulse_optimizer. stats : Stats; attributes of which give performance stats for the optimisation; set to None to reduce overhead of calculating stats.; Note it is (usually) shared with the Dynamics instance. dump : dump.OptimDump; Container for data dumped during the optimisation.; Can be set by specifying the dumping level or set directly.; Note this is mainly intended for user and a development debugging; but could be used for status information during a long optimisation. dumping : string; The level of data dumping that will occur during the optimisation - NONE : No processing data dumped (Default) - SUMMARY : A summary at each iteration will be recorded - FULL : All logs will be generated and dumped - CUSTOM : Some customised level of dumping When first set to CUSTOM this is equivalent to SUMMARY. dump_to_file : bool; If set True then data will be dumped to file during the optimisation; dumping will be set to SUMMARY during init_optim; if dump_to_file is True and dumping not set.; Default is False. dump_dir : string; Basically a link to dump.dump_dir. Exists so that it can be set through; optim_params.; If dump is None then will return None or will set dumping to SUMMARY; when setting a path. iter_summary : OptimIterSummary; Summary of the most recent iteration.; Note this is only set if dummping is on. apply_method_params(params=None)[source]Â¶; Loops through all the method_params; (either passed here or the method_params attribute); If the name matches an attribute of this object or the; termination conditions object, then the value of this attribute; is set. Otherwise it is assumed to a method_option for the; sci",MatchSource.WIKI,docs/4.3/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/apidoc/classes.html
https://qutip.org/docs/4.3/apidoc/classes.html:72304,Testability,log,logs,72304,"hen setting a path. iter_summary : OptimIterSummary; Summary of the most recent iteration.; Note this is only set if dummping is on. apply_method_params(params=None)[source]Â¶; Loops through all the method_params; (either passed here or the method_params attribute); If the name matches an attribute of this object or the; termination conditions object, then the value of this attribute; is set. Otherwise it is assumed to a method_option for the; scipy.optimize.minimize function. apply_params(params=None)[source]Â¶; Set object attributes based on the dictionary (if any) passed in the; instantiation, or passed as a parameter; This is called during the instantiation automatically.; The key value pairs are the attribute name and value; Note: attributes are created if they do not exist already,; and are overwritten if they do. dumpingÂ¶. The level of data dumping that will occur during the optimisation. NONE : No processing data dumped (Default); SUMMARY : A summary at each iteration will be recorded; FULL : All logs will be generated and dumped; CUSTOM : Some customised level of dumping. When first set to CUSTOM this is equivalent to SUMMARY. It is then up; to the user to specify which logs are dumped. fid_err_func_wrapper(*args)[source]Â¶; Get the fidelity error achieved using the ctrl amplitudes passed; in as the first argument.; This is called by generic optimisation algorithm as the; func to the minimised. The argument is the current; variable values, i.e. control amplitudes, passed as; a flat array. Hence these are reshaped as [nTimeslots, n_ctrls]; and then used to update the stored ctrl values (if they have changed); The error is checked against the target, and the optimisation is; terminated if the target has been achieved. fid_err_grad_wrapper(*args)[source]Â¶; Get the gradient of the fidelity error with respect to all of the; variables, i.e. the ctrl amplidutes in each timeslot; This is called by generic optimisation algorithm as the gradients of; func to the minimise",MatchSource.WIKI,docs/4.3/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/apidoc/classes.html
https://qutip.org/docs/4.3/apidoc/classes.html:72482,Testability,log,logs,72482," through all the method_params; (either passed here or the method_params attribute); If the name matches an attribute of this object or the; termination conditions object, then the value of this attribute; is set. Otherwise it is assumed to a method_option for the; scipy.optimize.minimize function. apply_params(params=None)[source]Â¶; Set object attributes based on the dictionary (if any) passed in the; instantiation, or passed as a parameter; This is called during the instantiation automatically.; The key value pairs are the attribute name and value; Note: attributes are created if they do not exist already,; and are overwritten if they do. dumpingÂ¶. The level of data dumping that will occur during the optimisation. NONE : No processing data dumped (Default); SUMMARY : A summary at each iteration will be recorded; FULL : All logs will be generated and dumped; CUSTOM : Some customised level of dumping. When first set to CUSTOM this is equivalent to SUMMARY. It is then up; to the user to specify which logs are dumped. fid_err_func_wrapper(*args)[source]Â¶; Get the fidelity error achieved using the ctrl amplitudes passed; in as the first argument.; This is called by generic optimisation algorithm as the; func to the minimised. The argument is the current; variable values, i.e. control amplitudes, passed as; a flat array. Hence these are reshaped as [nTimeslots, n_ctrls]; and then used to update the stored ctrl values (if they have changed); The error is checked against the target, and the optimisation is; terminated if the target has been achieved. fid_err_grad_wrapper(*args)[source]Â¶; Get the gradient of the fidelity error with respect to all of the; variables, i.e. the ctrl amplidutes in each timeslot; This is called by generic optimisation algorithm as the gradients of; func to the minimised wrt the variables. The argument is the current; variable values, i.e. control amplitudes, passed as; a flat array. Hence these are reshaped as [nTimeslots, n_ctrls]; and then used",MatchSource.WIKI,docs/4.3/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/apidoc/classes.html
https://qutip.org/docs/4.3/apidoc/classes.html:74839,Testability,test,tested,74839,"ource]Â¶; Check optimiser attribute status and passed parameters before; running the optimisation.; This is called by run_optimization, but could called independently; to check the configuration. iter_step_callback_func(*args)[source]Â¶; Check the elapsed wall time for the optimisation run so far.; Terminate if this has exceeded the maximum allowed time. run_optimization(term_conds=None)[source]Â¶; This default function optimisation method is a wrapper to the; scipy.optimize.minimize function.; It will attempt to minimise the fidelity error with respect to some; parameters, which are determined by _get_optim_var_vals (see below); The optimisation end when one of the passed termination conditions; has been met, e.g. target achieved, wall time, or; function call or iteration count exceeded. Note these; conditions include gradient minimum met (local minima) for; methods that use a gradient.; The function minimisation method is taken from the optim_method; attribute. Note that not all of these methods have been tested.; Note that some of these use a gradient and some do not.; See the scipy documentation for details. Options specific to the; method can be passed setting the method_params attribute.; If the parameter term_conds=None, then the termination_conditions; attribute must already be set. It will be overwritten if the; parameter is not None; The result is returned in an OptimResult object, which includes; the final fidelity, time evolution, reason for termination etc. class OptimizerBFGS(config, dyn, params=None)[source]Â¶; Implements the run_optimization method using the BFGS algorithm. run_optimization(term_conds=None)[source]Â¶; Optimise the control pulse amplitudes to minimise the fidelity error; using the BFGS (BroydenâFletcherâGoldfarbâShanno) algorithm; The optimisation end when one of the passed termination conditions; has been met, e.g. target achieved, gradient minimum met; (local minima), wall time / iteration count exceeded.; Essentially this is wrapper to t",MatchSource.WIKI,docs/4.3/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/apidoc/classes.html
https://qutip.org/docs/4.3/apidoc/classes.html:84204,Testability,log,logger,84204,"on the initial amps. stats : Stats; Object contaning the stats for the run (if any collected). optimizer : Optimizer; Instance of the Optimizer used to generate the result. class Dynamics(optimconfig, params=None)[source]Â¶; This is a base class only. See subclass descriptions and choose an; appropriate one for the application.; Note that initialize_controls must be called before most of the methods; can be used. init_timeslots can be called sometimes earlier in order; to access timeslot related attributes; This acts as a container for the operators that are used to calculate; time evolution of the system under study. That is the dynamics generators; (Hamiltonians, Lindbladians etc), the propagators from one timeslot to; the next, and the evolution operators. Due to the large number of matrix; additions and multiplications, for small systems at least, the optimisation; performance is much better using ndarrays to represent these operators.; However. Attributes:; log_level : integer; level of messaging output from the logger.; Options are attributes of qutip.logging_utils,; in decreasing levels of messaging, are:; DEBUG_INTENSE, DEBUG_VERBOSE, DEBUG, INFO, WARN, ERROR, CRITICAL; Anything WARN or above is effectively âquietâ execution,; assuming everything runs as expected.; The default NOTSET implies that the level will be taken from; the QuTiP settings file, which by default is WARN. params: Dictionary; The key value pairs are the attribute name and value; Note: attributes are created if they do not exist already,; and are overwritten if they do. stats : Stats; Attributes of which give performance stats for the optimisation; set to None to reduce overhead of calculating stats.; Note it is (usually) shared with the Optimizer object. tslot_computer : TimeslotComputer (subclass instance); Used to manage when the timeslot dynamics; generators, propagators, gradients etc are updated. prop_computer : PropagatorComputer (subclass instance); Used to compute the propagators an",MatchSource.WIKI,docs/4.3/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/apidoc/classes.html
https://qutip.org/docs/4.3/apidoc/classes.html:95209,Testability,log,logged,95209,"ation. The âcustomâ option assumes that the _apply_phase method has been; set to a custom function. propÂ¶; List of propagators (Qobj) for each timeslot. prop_gradÂ¶; Array of propagator gradients (Qobj) for each timeslot, control. refresh_drift_attribs()[source]Â¶; Reset the dyn_shape, dyn_dims and time_depend_drift attribs. save_amps(file_name=None, times=None, amps=None, verbose=False)[source]Â¶; Save a file with the current control amplitudes in each timeslot; The first column in the file will be the start time of the slot. Parameters:; file_name : string; Name of the file; If None given the def_amps_fname attribuite will be used. times : List type (or string); List / array of the start times for each slot; If None given this will be retrieved through get_amp_times(); If âexcludeâ then times will not be saved in the file, just; the amplitudes. amps : Array[num_tslots, num_ctrls]; Amplitudes to be saved; If None given the ctrl_amps attribute will be used. verbose : Boolean; If True then an info message will be logged. unitarity_check()[source]Â¶; Checks whether all propagators are unitary. update_ctrl_amps(new_amps)[source]Â¶; Determine if any amplitudes have changed. If so, then mark the; timeslots as needing recalculation; The actual work is completed by the compare_amps method of the; timeslot computer. class DynamicsGenMat(optimconfig, params=None)[source]Â¶; This sub class can be used for any system where no additional; operator is applied to the dynamics generator before calculating; the propagator, e.g. classical dynamics, Lindbladian. class DynamicsUnitary(optimconfig, params=None)[source]Â¶; This is the subclass to use for systems with dynamics described by; unitary matrices. E.g. closed systems with Hermitian Hamiltonians; Note a matrix diagonalisation is used to compute the exponent; The eigen decomposition is also used to calculate the propagator gradient.; The method is taken from DYNAMO (see file header). Attributes:; drift_ham : Qobj; This is the drift Ham",MatchSource.WIKI,docs/4.3/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/apidoc/classes.html
https://qutip.org/docs/4.3/apidoc/classes.html:98238,Testability,log,logger,98238,"ems; This is the subclass to use for systems where the dynamics is described; by symplectic matrices, e.g. coupled oscillators, quantum optics. Attributes:; omega : array[drift_dyn_gen.shape]; matrix used in the calculation of propagators (time evolution); with symplectic systems. dyn_gen_phaseÂ¶; The phasing operator for the symplectic group generators; usually refered to as Omega; By default this is applied as âpostopâ dyn_gen*-Omega; If phase_application is âpreopâ it is applied as Omega*dyn_gen. class PropagatorComputer(dynamics, params=None)[source]Â¶; Base for all Propagator Computer classes; that are used to calculate the propagators,; and also the propagator gradient when exact gradient methods are used; Note: they must be instantiated with a Dynamics object, that is the; container for the data that the functions operate on; This base class cannot be used directly. See subclass descriptions; and choose the appropriate one for the application. Attributes:; log_level : integer; level of messaging output from the logger.; Options are attributes of qutip_utils.logging,; in decreasing levels of messaging, are:; DEBUG_INTENSE, DEBUG_VERBOSE, DEBUG, INFO, WARN, ERROR, CRITICAL; Anything WARN or above is effectively âquietâ execution,; assuming everything runs as expected.; The default NOTSET implies that the level will be taken from; the QuTiP settings file, which by default is WARN. grad_exact : boolean; indicates whether the computer class instance is capable; of computing propagator gradients. It is used to determine; whether to create the Dynamics prop_grad array. apply_params(params=None)[source]Â¶; Set object attributes based on the dictionary (if any) passed in the; instantiation, or passed as a parameter; This is called during the instantiation automatically.; The key value pairs are the attribute name and value; Note: attributes are created if they do not exist already,; and are overwritten if they do. reset()[source]Â¶; reset any configuration data. class Prop",MatchSource.WIKI,docs/4.3/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/apidoc/classes.html
https://qutip.org/docs/4.3/apidoc/classes.html:98285,Testability,log,logging,98285,"shape]; matrix used in the calculation of propagators (time evolution); with symplectic systems. dyn_gen_phaseÂ¶; The phasing operator for the symplectic group generators; usually refered to as Omega; By default this is applied as âpostopâ dyn_gen*-Omega; If phase_application is âpreopâ it is applied as Omega*dyn_gen. class PropagatorComputer(dynamics, params=None)[source]Â¶; Base for all Propagator Computer classes; that are used to calculate the propagators,; and also the propagator gradient when exact gradient methods are used; Note: they must be instantiated with a Dynamics object, that is the; container for the data that the functions operate on; This base class cannot be used directly. See subclass descriptions; and choose the appropriate one for the application. Attributes:; log_level : integer; level of messaging output from the logger.; Options are attributes of qutip_utils.logging,; in decreasing levels of messaging, are:; DEBUG_INTENSE, DEBUG_VERBOSE, DEBUG, INFO, WARN, ERROR, CRITICAL; Anything WARN or above is effectively âquietâ execution,; assuming everything runs as expected.; The default NOTSET implies that the level will be taken from; the QuTiP settings file, which by default is WARN. grad_exact : boolean; indicates whether the computer class instance is capable; of computing propagator gradients. It is used to determine; whether to create the Dynamics prop_grad array. apply_params(params=None)[source]Â¶; Set object attributes based on the dictionary (if any) passed in the; instantiation, or passed as a parameter; This is called during the instantiation automatically.; The key value pairs are the attribute name and value; Note: attributes are created if they do not exist already,; and are overwritten if they do. reset()[source]Â¶; reset any configuration data. class PropCompApproxGrad(dynamics, params=None)[source]Â¶; This subclass can be used when the propagator is calculated simply; by expm of the dynamics generator, i.e. when gradients will be calcu",MatchSource.WIKI,docs/4.3/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/apidoc/classes.html
https://qutip.org/docs/4.3/apidoc/classes.html:100423,Testability,log,logger,100423,"lated; using approximate methods. reset()[source]Â¶; reset any configuration data. class PropCompDiag(dynamics, params=None)[source]Â¶; Coumputes the propagator exponentiation using diagonalisation of; of the dynamics generator. reset()[source]Â¶; reset any configuration data. class PropCompFrechet(dynamics, params=None)[source]Â¶. Frechet method for calculating the propagator:; exponentiating the combined dynamics generator. and the propagator gradient; It should work for all systems, e.g. unitary, open, symplectic; There are other PropagatorComputer subclasses that may be more efficient. reset()[source]Â¶; reset any configuration data. class FidelityComputer(dynamics, params=None)[source]Â¶; Base class for all Fidelity Computers.; This cannot be used directly. See subclass descriptions and choose; one appropriate for the application; Note: this must be instantiated with a Dynamics object, that is the; container for the data that the methods operate on. Attributes:; log_level : integer; level of messaging output from the logger.; Options are attributes of qutip.logging_utils,; in decreasing levels of messaging, are:; DEBUG_INTENSE, DEBUG_VERBOSE, DEBUG, INFO, WARN, ERROR, CRITICAL; Anything WARN or above is effectively âquietâ execution,; assuming everything runs as expected.; The default NOTSET implies that the level will be taken from; the QuTiP settings file, which by default is WARN. dimensional_norm : float; Normalisation constant. fid_norm_func : function; Used to normalise the fidelity; See SU and PSU options for the unitary dynamics. grad_norm_func : function; Used to normalise the fidelity gradient; See SU and PSU options for the unitary dynamics. uses_onwd_evo : boolean; flag to specify whether the onwd_evo evolution operator; (see Dynamics) is used by the FidelityComputer. uses_onto_evo : boolean. flag to specify whether the onto_evo evolution operator; (see Dynamics) is used by the FidelityComputer. fid_err : float; Last computed value of the fidelity error. f",MatchSource.WIKI,docs/4.3/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/apidoc/classes.html
https://qutip.org/docs/4.3/apidoc/classes.html:108401,Testability,log,logger,108401,"ics; Calculates the scale_factor is not already set. reset()[source]Â¶; reset any configuration data and; clear any temporarily held status data. class FidCompTraceDiffApprox(dynamics, params=None)[source]Â¶; As FidCompTraceDiff, except uses the finite difference method to; compute approximate gradients. Attributes:; epsilon : float; control amplitude offset to use when approximating the gradient wrt; a timeslot control amplitude. compute_fid_err_grad()[source]Â¶; Calculates gradient of function wrt to each timeslot; control amplitudes. Note these gradients are not normalised; They are calulated; These are returned as a (nTimeslots x n_ctrls) array. reset()[source]Â¶; reset any configuration data and; clear any temporarily held status data. class TimeslotComputer(dynamics, params=None)[source]Â¶; Base class for all Timeslot Computers; Note: this must be instantiated with a Dynamics object, that is the; container for the data that the methods operate on. Attributes:; log_level : integer; level of messaging output from the logger.; Options are attributes of qutip.logging_utils,; in decreasing levels of messaging, are:; DEBUG_INTENSE, DEBUG_VERBOSE, DEBUG, INFO, WARN, ERROR, CRITICAL; Anything WARN or above is effectively âquietâ execution,; assuming everything runs as expected.; The default NOTSET implies that the level will be taken from; the QuTiP settings file, which by default is WARN. evo_comp_summary : EvoCompSummary; A summary of the most recent evolution computation; Used in the stats and dump; Will be set to None if neither stats or dump are set. apply_params(params=None)[source]Â¶; Set object attributes based on the dictionary (if any) passed in the; instantiation, or passed as a parameter; This is called during the instantiation automatically.; The key value pairs are the attribute name and value; Note: attributes are created if they do not exist already,; and are overwritten if they do. dump_current()[source]Â¶; Store a copy of the current time evolution. class TS",MatchSource.WIKI,docs/4.3/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/apidoc/classes.html
https://qutip.org/docs/4.3/apidoc/classes.html:111747,Testability,log,logger,111747,"caling applied to the pulse; (copied from Dynamics.initial_ctrl_scaling if given). offset : float; linear offset applied to the pulse; (copied from Dynamics.initial_ctrl_offset if given). tau : array[num_tslots] of float; Duration of each timeslot; (copied from Dynamics if given). lbound : float; Lower boundary for the pulse amplitudes; Note that the scaling and offset attributes can be used to fully; bound the pulse for all generators except some of the random ones; This bound (if set) may result in additional shifting / scaling; Default is -Inf. ubound : float; Upper boundary for the pulse amplitudes; Note that the scaling and offset attributes can be used to fully; bound the pulse for all generators except some of the random ones; This bound (if set) may result in additional shifting / scaling; Default is Inf. periodic : boolean; True if the pulse generator produces periodic pulses. random : boolean; True if the pulse generator produces random pulses. log_level : integer; level of messaging output from the logger.; Options are attributes of qutip.logging_utils,; in decreasing levels of messaging, are:; DEBUG_INTENSE, DEBUG_VERBOSE, DEBUG, INFO, WARN, ERROR, CRITICAL; Anything WARN or above is effectively âquietâ execution,; assuming everything runs as expected.; The default NOTSET implies that the level will be taken from; the QuTiP settings file, which by default is WARN. apply_params(params=None)[source]Â¶; Set object attributes based on the dictionary (if any) passed in the; instantiation, or passed as a parameter; This is called during the instantiation automatically.; The key value pairs are the attribute name and value. gen_pulse()[source]Â¶; returns the pulse as an array of vales for each timeslot; Must be implemented by subclass. init_pulse()[source]Â¶; Initialise the pulse parameters. reset()[source]Â¶; reset attributes to default values. class PulseGenRandom(dyn=None, params=None)[source]Â¶; Generates random pulses as simply random values for each timeslot. ",MatchSource.WIKI,docs/4.3/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/apidoc/classes.html
https://qutip.org/docs/4.3/apidoc/classes.html:126263,Testability,log,log,126263,"ped. class OptimDump(optim, level='SUMMARY')[source]Â¶; A container for dumps of optimisation data generated during the pulse; optimisation. Attributes:; dump_summary : bool; When True summary items are appended to the iter_summary. iter_summary : list of optimizer.OptimIterSummary; Summary at each iteration. dump_fid_err : bool; When True values are appended to the fid_err_log. fid_err_log : list of float; Fidelity error at each call of the fid_err_func. dump_grad_norm : bool; When True values are appended to the fid_err_log. grad_norm_log : list of float; Gradient norm at each call of the grad_norm_log. dump_grad : bool; When True values are appended to the grad_log. grad_log : list of ndarray; Gradients at each call of the fid_grad_func. add_iter_summary()[source]Â¶; add copy of current optimizer iteration summary. dump_allÂ¶; True if everything (ignoring the summary) is to be dumped. dump_anyÂ¶; True if anything other than the summary is to be dumped. update_fid_err_log(fid_err)[source]Â¶; add an entry to the fid_err log. update_grad_log(grad)[source]Â¶; add an entry to the grad log. update_grad_norm_log(grad_norm)[source]Â¶; add an entry to the grad_norm log. writeout(f=None)[source]Â¶; write all the logs and the summary out to file(s). Parameters:; f : filename or filehandle; If specified then all summary and object data will go in one file.; If None is specified then type specific files will be generated; in the dump_dir; If a filehandle is specified then it must be a byte mode file; as numpy.savetxt is used, and requires this. class DynamicsDump(dynamics, level='SUMMARY')[source]Â¶; A container for dumps of dynamics data.; Mainly time evolution calculations. Attributes:; dump_summary : bool; If True a summary is recorded. evo_summary : list of :class:`tslotcomp.EvoCompSummaryâ; Summary items are appended if dump_summary is True; at each recomputation of the evolution. dump_amps : bool; If True control amplitudes are dumped. dump_dyn_gen : bool; If True the dynamics ge",MatchSource.WIKI,docs/4.3/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/apidoc/classes.html
https://qutip.org/docs/4.3/apidoc/classes.html:126325,Testability,log,log,126325,"for dumps of optimisation data generated during the pulse; optimisation. Attributes:; dump_summary : bool; When True summary items are appended to the iter_summary. iter_summary : list of optimizer.OptimIterSummary; Summary at each iteration. dump_fid_err : bool; When True values are appended to the fid_err_log. fid_err_log : list of float; Fidelity error at each call of the fid_err_func. dump_grad_norm : bool; When True values are appended to the fid_err_log. grad_norm_log : list of float; Gradient norm at each call of the grad_norm_log. dump_grad : bool; When True values are appended to the grad_log. grad_log : list of ndarray; Gradients at each call of the fid_grad_func. add_iter_summary()[source]Â¶; add copy of current optimizer iteration summary. dump_allÂ¶; True if everything (ignoring the summary) is to be dumped. dump_anyÂ¶; True if anything other than the summary is to be dumped. update_fid_err_log(fid_err)[source]Â¶; add an entry to the fid_err log. update_grad_log(grad)[source]Â¶; add an entry to the grad log. update_grad_norm_log(grad_norm)[source]Â¶; add an entry to the grad_norm log. writeout(f=None)[source]Â¶; write all the logs and the summary out to file(s). Parameters:; f : filename or filehandle; If specified then all summary and object data will go in one file.; If None is specified then type specific files will be generated; in the dump_dir; If a filehandle is specified then it must be a byte mode file; as numpy.savetxt is used, and requires this. class DynamicsDump(dynamics, level='SUMMARY')[source]Â¶; A container for dumps of dynamics data.; Mainly time evolution calculations. Attributes:; dump_summary : bool; If True a summary is recorded. evo_summary : list of :class:`tslotcomp.EvoCompSummaryâ; Summary items are appended if dump_summary is True; at each recomputation of the evolution. dump_amps : bool; If True control amplitudes are dumped. dump_dyn_gen : bool; If True the dynamics generators (Hamiltonians) are dumped. dump_prop : bool; If True prop",MatchSource.WIKI,docs/4.3/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/apidoc/classes.html
https://qutip.org/docs/4.3/apidoc/classes.html:126402,Testability,log,log,126402,"on. Attributes:; dump_summary : bool; When True summary items are appended to the iter_summary. iter_summary : list of optimizer.OptimIterSummary; Summary at each iteration. dump_fid_err : bool; When True values are appended to the fid_err_log. fid_err_log : list of float; Fidelity error at each call of the fid_err_func. dump_grad_norm : bool; When True values are appended to the fid_err_log. grad_norm_log : list of float; Gradient norm at each call of the grad_norm_log. dump_grad : bool; When True values are appended to the grad_log. grad_log : list of ndarray; Gradients at each call of the fid_grad_func. add_iter_summary()[source]Â¶; add copy of current optimizer iteration summary. dump_allÂ¶; True if everything (ignoring the summary) is to be dumped. dump_anyÂ¶; True if anything other than the summary is to be dumped. update_fid_err_log(fid_err)[source]Â¶; add an entry to the fid_err log. update_grad_log(grad)[source]Â¶; add an entry to the grad log. update_grad_norm_log(grad_norm)[source]Â¶; add an entry to the grad_norm log. writeout(f=None)[source]Â¶; write all the logs and the summary out to file(s). Parameters:; f : filename or filehandle; If specified then all summary and object data will go in one file.; If None is specified then type specific files will be generated; in the dump_dir; If a filehandle is specified then it must be a byte mode file; as numpy.savetxt is used, and requires this. class DynamicsDump(dynamics, level='SUMMARY')[source]Â¶; A container for dumps of dynamics data.; Mainly time evolution calculations. Attributes:; dump_summary : bool; If True a summary is recorded. evo_summary : list of :class:`tslotcomp.EvoCompSummaryâ; Summary items are appended if dump_summary is True; at each recomputation of the evolution. dump_amps : bool; If True control amplitudes are dumped. dump_dyn_gen : bool; If True the dynamics generators (Hamiltonians) are dumped. dump_prop : bool; If True propagators are dumped. dump_prop_grad : bool; If True propagator gradient",MatchSource.WIKI,docs/4.3/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/apidoc/classes.html
https://qutip.org/docs/4.3/apidoc/classes.html:126448,Testability,log,logs,126448,"the iter_summary. iter_summary : list of optimizer.OptimIterSummary; Summary at each iteration. dump_fid_err : bool; When True values are appended to the fid_err_log. fid_err_log : list of float; Fidelity error at each call of the fid_err_func. dump_grad_norm : bool; When True values are appended to the fid_err_log. grad_norm_log : list of float; Gradient norm at each call of the grad_norm_log. dump_grad : bool; When True values are appended to the grad_log. grad_log : list of ndarray; Gradients at each call of the fid_grad_func. add_iter_summary()[source]Â¶; add copy of current optimizer iteration summary. dump_allÂ¶; True if everything (ignoring the summary) is to be dumped. dump_anyÂ¶; True if anything other than the summary is to be dumped. update_fid_err_log(fid_err)[source]Â¶; add an entry to the fid_err log. update_grad_log(grad)[source]Â¶; add an entry to the grad log. update_grad_norm_log(grad_norm)[source]Â¶; add an entry to the grad_norm log. writeout(f=None)[source]Â¶; write all the logs and the summary out to file(s). Parameters:; f : filename or filehandle; If specified then all summary and object data will go in one file.; If None is specified then type specific files will be generated; in the dump_dir; If a filehandle is specified then it must be a byte mode file; as numpy.savetxt is used, and requires this. class DynamicsDump(dynamics, level='SUMMARY')[source]Â¶; A container for dumps of dynamics data.; Mainly time evolution calculations. Attributes:; dump_summary : bool; If True a summary is recorded. evo_summary : list of :class:`tslotcomp.EvoCompSummaryâ; Summary items are appended if dump_summary is True; at each recomputation of the evolution. dump_amps : bool; If True control amplitudes are dumped. dump_dyn_gen : bool; If True the dynamics generators (Hamiltonians) are dumped. dump_prop : bool; If True propagators are dumped. dump_prop_grad : bool; If True propagator gradients are dumped. dump_fwd_evo : bool; If True forward evolution operators are du",MatchSource.WIKI,docs/4.3/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/apidoc/classes.html
https://qutip.org/docs/4.3/apidoc/classes.html:15606,Usability,simpl,simply,15606,"s:; trace : float; Returns real if operator is Hermitian, returns complex; otherwise. trans()[source]Â¶; Transposed operator. Returns:; oper : qobj; Transpose of input operator. transform(inpt, inverse=False, sparse=True)[source]Â¶; Basis transform defined by input array.; Input array can be a matrix defining the transformation,; or a list of kets that defines the new basis. Parameters:; inpt : array_like; A matrix or list of kets defining the transformation. inverse : bool; Whether to return inverse transformation. sparse : bool; Use sparse matrices when possible. Can be slower. Returns:; oper : qobj; Operator in new basis. Notes; This function is still in development. trunc_neg(method='clip')[source]Â¶; Truncates negative eigenvalues and renormalizes.; Returns a new Qobj by removing the negative eigenvalues; of this instance, then renormalizing to obtain a valid density; operator. Parameters:; method : str; Algorithm to use to remove negative eigenvalues. âclipâ; simply discards negative eigenvalues, then renormalizes.; âsgsâ uses the SGS algorithm (doi:10/bb76) to find the; positive operator that is nearest in the Shatten 2-norm. Returns:; oper : qobj; A valid density operator. unit(inplace=False, norm=None, sparse=False, tol=0, maxiter=100000)[source]Â¶; Operator or state normalized to unity.; Uses norm from Qobj.norm(). Parameters:; inplace : bool; Do an in-place normalization. norm : str; Requested norm for states / operators. sparse : bool; Use sparse eigensolver for trace norm. Does not affect other norms. tol : float; Tolerance used by sparse eigensolver. maxiter : int; Number of maximum iterations performed by sparse eigensolver. Returns:; oper : qobj; Normalized quantum object if not in-place,; else None. eseriesÂ¶. class eseries(q=array([], dtype=object), s=array([], dtype=float64))[source]Â¶; Class representation of an exponential-series expansion of; time-dependent quantum objects. Attributes:; ampl : ndarray; Array of amplitudes for exponential series. rates",MatchSource.WIKI,docs/4.3/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/apidoc/classes.html
https://qutip.org/docs/4.3/apidoc/classes.html:19106,Usability,simpl,simple,19106,"{0.1}; Sets transparency of Bloch sphere frame. frame_color : str {âgrayâ}; Color of sphere wireframe. frame_width : int {1}; Width of wireframe. point_color : list {[âbâ,ârâ,âgâ,â#CC6600â]}; List of colors for Bloch sphere point markers to cycle through.; i.e. By default, points 0 and 4 will both be blue (âbâ). point_marker : list {[âoâ,âsâ,âdâ,â^â]}; List of point marker shapes to cycle through. point_size : list {[25,32,35,45]}; List of point marker sizes. Note, not all point markers look; the same size when plotted!. sphere_alpha : float {0.2}; Transparency of Bloch sphere itself. sphere_color : str {â#FFDDDDâ}; Color of Bloch sphere. figsize : list {[7,7]}; Figure size of Bloch sphere plot. Best to have both numbers the same;; otherwise you will have a Bloch sphere that looks like a football. vector_color : list {[âgâ,â#CC6600â,âbâ,ârâ]}; List of vector colors to cycle through. vector_width : int {5}; Width of displayed vectors. vector_style : str {â-|>â, âsimpleâ, âfancyâ, ââ}; Vector arrowhead style (from matplotlibâs arrow style). vector_mutation : int {20}; Width of vectors arrowhead. view : list {[-60,30]}; Azimuthal and Elevation viewing angles. xlabel : list {[â$x$â,ââ]}; List of strings corresponding to +x and -x axes labels, respectively. xlpos : list {[1.1,-1.1]}; Positions of +x and -x labels respectively. ylabel : list {[â$y$â,ââ]}; List of strings corresponding to +y and -y axes labels, respectively. ylpos : list {[1.2,-1.2]}; Positions of +y and -y labels respectively. zlabel : list {[râ$\left|0\right>$â,râ$\left|1\right>$â]}; List of strings corresponding to +z and -z axes labels, respectively. zlpos : list {[1.2,-1.2]}; Positions of +z and -z labels respectively. add_annotation(state_or_vector, text, **kwargs)[source]Â¶; Add a text or LaTeX annotation to Bloch sphere,; parametrized by a qubit state or a vector. Parameters:; state_or_vector : Qobj/array/list/tuple; Position for the annotaion.; Qobj of a qubit or a vector of 3 elements. text : str/u",MatchSource.WIKI,docs/4.3/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/apidoc/classes.html
https://qutip.org/docs/4.3/apidoc/classes.html:21000,Usability,clear,clear,21000,"/array/list/tuple; Position for the annotaion.; Qobj of a qubit or a vector of 3 elements. text : str/unicode; Annotation text.; You can use LaTeX, but remember to use raw string; e.g. râ$langle x rangle$â; or escape backslashes; e.g. â$\langle x \rangle$â. **kwargs :; Options as for mplot3d.axes3d.text, including:; fontsize, color, horizontalalignment, verticalalignment. add_points(points, meth='s')[source]Â¶; Add a list of data points to bloch sphere. Parameters:; points : array/list; Collection of data points. meth : str {âsâ, âmâ, âlâ}; Type of points to plot, use âmâ for multicolored, âlâ for points; connected with a line. add_states(state, kind='vector')[source]Â¶; Add a state vector Qobj to Bloch sphere. Parameters:; state : qobj; Input state vector. kind : str {âvectorâ,âpointâ}; Type of object to plot. add_vectors(vectors)[source]Â¶; Add a list of vectors to Bloch sphere. Parameters:; vectors : array_like; Array with vectors of unit length or smaller. clear()[source]Â¶; Resets Bloch sphere data sets to empty. make_sphere()[source]Â¶; Plots Bloch sphere and data sets. render(fig=None, axes=None)[source]Â¶; Render the Bloch sphere and its data sets in on given figure and axes. save(name=None, format='png', dirc=None)[source]Â¶; Saves Bloch sphere to file of type format in directory dirc. Parameters:; name : str; Name of saved image. Must include path and format as well.; i.e. â/Users/Paul/Desktop/bloch.pngâ; This overrides the âformatâ and âdircâ arguments. format : str; Format of output image. dirc : str; Directory for output images. Defaults to current working directory. Returns:; File containing plot of Bloch sphere. set_label_convention(convention)[source]Â¶; Set x, y and z labels according to one of conventions. Parameters:; convention : string; One of the following:. âoriginalâ; âxyzâ; âsx sy szâ; â01â; âpolarization jonesâ; âpolarization jones lettersâ; see also: http://en.wikipedia.org/wiki/Jones_calculus; âpolarization stokesâ; see also: http://en.wikipedia.",MatchSource.WIKI,docs/4.3/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/apidoc/classes.html
https://qutip.org/docs/4.3/apidoc/classes.html:22256,Usability,simpl,simple,22256,"ave(name=None, format='png', dirc=None)[source]Â¶; Saves Bloch sphere to file of type format in directory dirc. Parameters:; name : str; Name of saved image. Must include path and format as well.; i.e. â/Users/Paul/Desktop/bloch.pngâ; This overrides the âformatâ and âdircâ arguments. format : str; Format of output image. dirc : str; Directory for output images. Defaults to current working directory. Returns:; File containing plot of Bloch sphere. set_label_convention(convention)[source]Â¶; Set x, y and z labels according to one of conventions. Parameters:; convention : string; One of the following:. âoriginalâ; âxyzâ; âsx sy szâ; â01â; âpolarization jonesâ; âpolarization jones lettersâ; see also: http://en.wikipedia.org/wiki/Jones_calculus; âpolarization stokesâ; see also: http://en.wikipedia.org/wiki/Stokes_parameters. show()[source]Â¶; Display Bloch sphere and corresponding data sets. vector_mutation = NoneÂ¶; Sets the width of the vectors arrowhead. vector_style = NoneÂ¶; Style of Bloch vectors, default = â-|>â (or âsimpleâ). vector_width = NoneÂ¶; Width of Bloch vectors, default = 5. Cubic SplineÂ¶. class Cubic_Spline(a, b, y, alpha=0, beta=0)[source]Â¶; Calculates coefficients for a cubic spline; interpolation of a given data set.; This function assumes that the data is sampled; uniformly over a given interval. Parameters:; a : float; Lower bound of the interval. b : float; Upper bound of the interval. y : ndarray; Function values at interval points. alpha : float; Second-order derivative at a. Default is 0. beta : float; Second-order derivative at b. Default is 0. Notes; This object can be called like a normal function with a; single or array of input points at which to evaluate; the interplating function.; Habermann & Kindermann, âMultidimensional Spline Interpolation:; Theory and Applicationsâ, Comput Econ 30, 153 (2007). Attributes:; a : float; Lower bound of the interval. b : float; Upper bound of the interval. coeffs : ndarray; Array of coeffcients defining cubic ",MatchSource.WIKI,docs/4.3/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/apidoc/classes.html
https://qutip.org/docs/4.3/apidoc/classes.html:25998,Usability,progress bar,progress bar,25998,"the progress of the simulation. stats : qutip.solver.Stats; optional container for holding performance statitics; If None is set, then statistics are not collected; There may be an overhead in collecting statistics. exp_coeff : list of complex; Coefficients for the exponential series terms. exp_freq : list of complex; Frequencies for the exponential series terms. configure(H_sys, coup_op, coup_strength, temperature, N_cut, N_exp, planck=None, boltzmann=None, renorm=None, bnd_cut_approx=None, options=None, progress_bar=None, stats=None)[source]Â¶; Configure the solver using the passed parameters; The parameters are described in the class attributes, unless there; is some specific behaviour. Parameters:; options : qutip.solver.Options; Generic solver options.; If set to None the default options will be used. progress_bar: BaseProgressBar; Optional instance of BaseProgressBar, or a subclass thereof, for; showing the progress of the simulation.; If set to None, then the default progress bar will be used; Set to False for no progress bar. stats: :class:`qutip.solver.Stats`; Optional instance of solver.Stats, or a subclass thereof, for; storing performance statistics for the solver; If set to True, then the default Stats for this class will be used; Set to False for no stats. create_new_stats()[source]Â¶; Creates a new stats object suitable for use with this solver; Note: this solver expects the stats object to have sections. config; integrate. reset()[source]Â¶; Reset any attributes to default values. class HSolverDL(H_sys, coup_op, coup_strength, temperature, N_cut, N_exp, cut_freq, planck=1.0, boltzmann=1.0, renorm=True, bnd_cut_approx=True, options=None, progress_bar=None, stats=None)[source]Â¶; HEOM solver based on the Drude-Lorentz model for spectral density.; Drude-Lorentz bath the correlation functions can be exactly analytically; expressed as an infinite sum of exponentials which depend on the; temperature, these are called the Matsubara terms or Matsubara frequencies",MatchSource.WIKI,docs/4.3/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/apidoc/classes.html
https://qutip.org/docs/4.3/apidoc/classes.html:26045,Usability,progress bar,progress bar,26045,"the progress of the simulation. stats : qutip.solver.Stats; optional container for holding performance statitics; If None is set, then statistics are not collected; There may be an overhead in collecting statistics. exp_coeff : list of complex; Coefficients for the exponential series terms. exp_freq : list of complex; Frequencies for the exponential series terms. configure(H_sys, coup_op, coup_strength, temperature, N_cut, N_exp, planck=None, boltzmann=None, renorm=None, bnd_cut_approx=None, options=None, progress_bar=None, stats=None)[source]Â¶; Configure the solver using the passed parameters; The parameters are described in the class attributes, unless there; is some specific behaviour. Parameters:; options : qutip.solver.Options; Generic solver options.; If set to None the default options will be used. progress_bar: BaseProgressBar; Optional instance of BaseProgressBar, or a subclass thereof, for; showing the progress of the simulation.; If set to None, then the default progress bar will be used; Set to False for no progress bar. stats: :class:`qutip.solver.Stats`; Optional instance of solver.Stats, or a subclass thereof, for; storing performance statistics for the solver; If set to True, then the default Stats for this class will be used; Set to False for no stats. create_new_stats()[source]Â¶; Creates a new stats object suitable for use with this solver; Note: this solver expects the stats object to have sections. config; integrate. reset()[source]Â¶; Reset any attributes to default values. class HSolverDL(H_sys, coup_op, coup_strength, temperature, N_cut, N_exp, cut_freq, planck=1.0, boltzmann=1.0, renorm=True, bnd_cut_approx=True, options=None, progress_bar=None, stats=None)[source]Â¶; HEOM solver based on the Drude-Lorentz model for spectral density.; Drude-Lorentz bath the correlation functions can be exactly analytically; expressed as an infinite sum of exponentials which depend on the; temperature, these are called the Matsubara terms or Matsubara frequencies",MatchSource.WIKI,docs/4.3/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/apidoc/classes.html
https://qutip.org/docs/4.3/apidoc/classes.html:28269,Usability,feedback,feedback,28269,"eq : float; Bath spectral density cutoff frequency. renorm : bool; Apply renormalisation to coupling terms; Can be useful if using SI units for planck and boltzmann. bnd_cut_approx : bool; Use boundary cut off approximation; Can be. configure(H_sys, coup_op, coup_strength, temperature, N_cut, N_exp, cut_freq, planck=None, boltzmann=None, renorm=None, bnd_cut_approx=None, options=None, progress_bar=None, stats=None)[source]Â¶; Calls configure from HEOMSolver and sets any attributes; that are specific to this subclass. reset()[source]Â¶; Reset any attributes to default values. run(rho0, tlist)[source]Â¶; Function to solve for an open quantum system using the; HEOM model. Parameters:; rho0 : Qobj; Initial state (density matrix) of the system. tlist : list; Time over which system evolves. Returns:; results : qutip.solver.Result; Object storing all results from the simulation. class MemoryCascade(H_S, L1, L2, S_matrix=None, c_ops_markov=None, integrator='propagator', parallel=False, options=None)[source]Â¶; Class for running memory cascade simulations of open quantum systems; with time-delayed coherent feedback. Attributes:; H_S : qutip.Qobj; System Hamiltonian (can also be a Liouvillian). L1 : qutip.Qobj / list of qutip.Qobj; System operators coupling into the feedback loop. Can be a single; operator or a list of operators. L2 : qutip.Qobj / list of qutip.Qobj; System operators coupling out of the feedback loop. Can be a single; operator or a list of operators. L2 must have the same length as L1. S_matrix: *array*; S matrix describing which operators in L1 are coupled to which; operators in L2 by the feedback channel. Defaults to an n by n identity; matrix where n is the number of elements in L1/L2. c_ops_markov : qutip.Qobj / list of qutip.Qobj; Decay operators describing conventional Markovian decay channels.; Can be a single operator or a list of operators. integrator : str {âpropagatorâ, âmesolveâ}; Integrator method to use. Defaults to âpropagatorâ which tends to be; fa",MatchSource.WIKI,docs/4.3/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/apidoc/classes.html
https://qutip.org/docs/4.3/apidoc/classes.html:28431,Usability,feedback,feedback,28431,"coup_strength, temperature, N_cut, N_exp, cut_freq, planck=None, boltzmann=None, renorm=None, bnd_cut_approx=None, options=None, progress_bar=None, stats=None)[source]Â¶; Calls configure from HEOMSolver and sets any attributes; that are specific to this subclass. reset()[source]Â¶; Reset any attributes to default values. run(rho0, tlist)[source]Â¶; Function to solve for an open quantum system using the; HEOM model. Parameters:; rho0 : Qobj; Initial state (density matrix) of the system. tlist : list; Time over which system evolves. Returns:; results : qutip.solver.Result; Object storing all results from the simulation. class MemoryCascade(H_S, L1, L2, S_matrix=None, c_ops_markov=None, integrator='propagator', parallel=False, options=None)[source]Â¶; Class for running memory cascade simulations of open quantum systems; with time-delayed coherent feedback. Attributes:; H_S : qutip.Qobj; System Hamiltonian (can also be a Liouvillian). L1 : qutip.Qobj / list of qutip.Qobj; System operators coupling into the feedback loop. Can be a single; operator or a list of operators. L2 : qutip.Qobj / list of qutip.Qobj; System operators coupling out of the feedback loop. Can be a single; operator or a list of operators. L2 must have the same length as L1. S_matrix: *array*; S matrix describing which operators in L1 are coupled to which; operators in L2 by the feedback channel. Defaults to an n by n identity; matrix where n is the number of elements in L1/L2. c_ops_markov : qutip.Qobj / list of qutip.Qobj; Decay operators describing conventional Markovian decay channels.; Can be a single operator or a list of operators. integrator : str {âpropagatorâ, âmesolveâ}; Integrator method to use. Defaults to âpropagatorâ which tends to be; faster for long times (i.e., large Hilbert space). parallel : bool; Run integrator in parallel if True. Only implemented for âpropagatorâ; as the integrator method. options : qutip.solver.Options; Generic solver options. outfieldcorr(rho0, blist, tlist, tau, c1",MatchSource.WIKI,docs/4.3/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/apidoc/classes.html
https://qutip.org/docs/4.3/apidoc/classes.html:28571,Usability,feedback,feedback,28571,"ar=None, stats=None)[source]Â¶; Calls configure from HEOMSolver and sets any attributes; that are specific to this subclass. reset()[source]Â¶; Reset any attributes to default values. run(rho0, tlist)[source]Â¶; Function to solve for an open quantum system using the; HEOM model. Parameters:; rho0 : Qobj; Initial state (density matrix) of the system. tlist : list; Time over which system evolves. Returns:; results : qutip.solver.Result; Object storing all results from the simulation. class MemoryCascade(H_S, L1, L2, S_matrix=None, c_ops_markov=None, integrator='propagator', parallel=False, options=None)[source]Â¶; Class for running memory cascade simulations of open quantum systems; with time-delayed coherent feedback. Attributes:; H_S : qutip.Qobj; System Hamiltonian (can also be a Liouvillian). L1 : qutip.Qobj / list of qutip.Qobj; System operators coupling into the feedback loop. Can be a single; operator or a list of operators. L2 : qutip.Qobj / list of qutip.Qobj; System operators coupling out of the feedback loop. Can be a single; operator or a list of operators. L2 must have the same length as L1. S_matrix: *array*; S matrix describing which operators in L1 are coupled to which; operators in L2 by the feedback channel. Defaults to an n by n identity; matrix where n is the number of elements in L1/L2. c_ops_markov : qutip.Qobj / list of qutip.Qobj; Decay operators describing conventional Markovian decay channels.; Can be a single operator or a list of operators. integrator : str {âpropagatorâ, âmesolveâ}; Integrator method to use. Defaults to âpropagatorâ which tends to be; faster for long times (i.e., large Hilbert space). parallel : bool; Run integrator in parallel if True. Only implemented for âpropagatorâ; as the integrator method. options : qutip.solver.Options; Generic solver options. outfieldcorr(rho0, blist, tlist, tau, c1=None, c2=None)[source]Â¶; Compute output field expectation value; <O_n(tn)â¦O_2(t2)O_1(t1)> for times t1,t2,â¦ and; O_i = I, b_out, b_out^dag",MatchSource.WIKI,docs/4.3/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/apidoc/classes.html
https://qutip.org/docs/4.3/apidoc/classes.html:28778,Usability,feedback,feedback,28778,"ues. run(rho0, tlist)[source]Â¶; Function to solve for an open quantum system using the; HEOM model. Parameters:; rho0 : Qobj; Initial state (density matrix) of the system. tlist : list; Time over which system evolves. Returns:; results : qutip.solver.Result; Object storing all results from the simulation. class MemoryCascade(H_S, L1, L2, S_matrix=None, c_ops_markov=None, integrator='propagator', parallel=False, options=None)[source]Â¶; Class for running memory cascade simulations of open quantum systems; with time-delayed coherent feedback. Attributes:; H_S : qutip.Qobj; System Hamiltonian (can also be a Liouvillian). L1 : qutip.Qobj / list of qutip.Qobj; System operators coupling into the feedback loop. Can be a single; operator or a list of operators. L2 : qutip.Qobj / list of qutip.Qobj; System operators coupling out of the feedback loop. Can be a single; operator or a list of operators. L2 must have the same length as L1. S_matrix: *array*; S matrix describing which operators in L1 are coupled to which; operators in L2 by the feedback channel. Defaults to an n by n identity; matrix where n is the number of elements in L1/L2. c_ops_markov : qutip.Qobj / list of qutip.Qobj; Decay operators describing conventional Markovian decay channels.; Can be a single operator or a list of operators. integrator : str {âpropagatorâ, âmesolveâ}; Integrator method to use. Defaults to âpropagatorâ which tends to be; faster for long times (i.e., large Hilbert space). parallel : bool; Run integrator in parallel if True. Only implemented for âpropagatorâ; as the integrator method. options : qutip.solver.Options; Generic solver options. outfieldcorr(rho0, blist, tlist, tau, c1=None, c2=None)[source]Â¶; Compute output field expectation value; <O_n(tn)â¦O_2(t2)O_1(t1)> for times t1,t2,â¦ and; O_i = I, b_out, b_out^dagger, b_loop, b_loop^dagger. Parameters:; rho0 : qutip.Qobj; initial density matrix or state vector (ket). blist : array_like; List of integers specifying the field operators:; ",MatchSource.WIKI,docs/4.3/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/apidoc/classes.html
https://qutip.org/docs/4.3/apidoc/classes.html:32334,Usability,learn,learningtimes,32334,"), a generalized partial trace is performed; and a propagator for a single system is returned. Returns:; : :class:`qutip.Qobj`; time-propagator for computing field correlation function. propagator(t, tau, notrace=False)[source]Â¶; Compute propagator for time t and time-delay tau. Parameters:; t : float; current time. tau : float; time-delay. notrace : bool {False}; If this optional is set to True, a propagator is returned for a; cascade of k systems, where \((k-1) tau < t < k tau\).; If set to False (default), a generalized partial trace is performed; and a propagator for a single system is returned. Returns. ââ-. : :class:`qutip.Qobj`; time-propagator for reduced system dynamics. rhot(rho0, t, tau)[source]Â¶; Compute the reduced system density matrix \(\rho(t)\). Parameters:; rho0 : qutip.Qobj; initial density matrix or state vector (ket). t : float; current time. tau : float; time-delay. Returns:; : :class:`qutip.Qobj`; density matrix at time \(t\). class TTMSolverOptions(dynmaps=None, times=[], learningtimes=[], thres=0.0, options=None)[source]Â¶; Class of options for the Transfer Tensor Method solver. Attributes:; dynmaps : list of qutip.Qobj; List of precomputed dynamical maps (superoperators),; or a callback function that returns the; superoperator at a given time. times : array_like; List of times \(t_n\) at which to calculate \(\rho(t_n)\). learningtimes : array_like; List of times \(t_k\) to use as learning times if argument; dynmaps is a callback function. thres : float; Threshold for halting. Halts if \(||T_{n}-T_{n-1}||\) is below; treshold. options : qutip.solver.Options; Generic solver options. Solver Options and ResultsÂ¶. class Options(atol=1e-08, rtol=1e-06, method='adams', order=12, nsteps=1000, first_step=0, max_step=0, min_step=0, average_expect=True, average_states=False, tidy=True, num_cpus=0, norm_tol=0.001, norm_steps=5, rhs_reuse=False, rhs_filename=None, ntraj=500, gui=False, rhs_with_state=False, store_final_state=False, store_states=False, se",MatchSource.WIKI,docs/4.3/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/apidoc/classes.html
https://qutip.org/docs/4.3/apidoc/classes.html:32691,Usability,learn,learningtimes,32691,"r a; cascade of k systems, where \((k-1) tau < t < k tau\).; If set to False (default), a generalized partial trace is performed; and a propagator for a single system is returned. Returns. ââ-. : :class:`qutip.Qobj`; time-propagator for reduced system dynamics. rhot(rho0, t, tau)[source]Â¶; Compute the reduced system density matrix \(\rho(t)\). Parameters:; rho0 : qutip.Qobj; initial density matrix or state vector (ket). t : float; current time. tau : float; time-delay. Returns:; : :class:`qutip.Qobj`; density matrix at time \(t\). class TTMSolverOptions(dynmaps=None, times=[], learningtimes=[], thres=0.0, options=None)[source]Â¶; Class of options for the Transfer Tensor Method solver. Attributes:; dynmaps : list of qutip.Qobj; List of precomputed dynamical maps (superoperators),; or a callback function that returns the; superoperator at a given time. times : array_like; List of times \(t_n\) at which to calculate \(\rho(t_n)\). learningtimes : array_like; List of times \(t_k\) to use as learning times if argument; dynmaps is a callback function. thres : float; Threshold for halting. Halts if \(||T_{n}-T_{n-1}||\) is below; treshold. options : qutip.solver.Options; Generic solver options. Solver Options and ResultsÂ¶. class Options(atol=1e-08, rtol=1e-06, method='adams', order=12, nsteps=1000, first_step=0, max_step=0, min_step=0, average_expect=True, average_states=False, tidy=True, num_cpus=0, norm_tol=0.001, norm_steps=5, rhs_reuse=False, rhs_filename=None, ntraj=500, gui=False, rhs_with_state=False, store_final_state=False, store_states=False, seeds=None, steady_state_average=False, normalize_output=True, use_openmp=None, openmp_threads=None)[source]Â¶; Class of options for evolution solvers such as qutip.mesolve and; qutip.mcsolve. Options can be specified either as arguments to the; constructor:; opts = Options(order=10, ...). or by changing the class attributes after creation:; opts = Options(); opts.order = 10. Returns options class to be used as options in evol",MatchSource.WIKI,docs/4.3/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/apidoc/classes.html
https://qutip.org/docs/4.3/apidoc/classes.html:32751,Usability,learn,learning,32751,"r a; cascade of k systems, where \((k-1) tau < t < k tau\).; If set to False (default), a generalized partial trace is performed; and a propagator for a single system is returned. Returns. ââ-. : :class:`qutip.Qobj`; time-propagator for reduced system dynamics. rhot(rho0, t, tau)[source]Â¶; Compute the reduced system density matrix \(\rho(t)\). Parameters:; rho0 : qutip.Qobj; initial density matrix or state vector (ket). t : float; current time. tau : float; time-delay. Returns:; : :class:`qutip.Qobj`; density matrix at time \(t\). class TTMSolverOptions(dynmaps=None, times=[], learningtimes=[], thres=0.0, options=None)[source]Â¶; Class of options for the Transfer Tensor Method solver. Attributes:; dynmaps : list of qutip.Qobj; List of precomputed dynamical maps (superoperators),; or a callback function that returns the; superoperator at a given time. times : array_like; List of times \(t_n\) at which to calculate \(\rho(t_n)\). learningtimes : array_like; List of times \(t_k\) to use as learning times if argument; dynmaps is a callback function. thres : float; Threshold for halting. Halts if \(||T_{n}-T_{n-1}||\) is below; treshold. options : qutip.solver.Options; Generic solver options. Solver Options and ResultsÂ¶. class Options(atol=1e-08, rtol=1e-06, method='adams', order=12, nsteps=1000, first_step=0, max_step=0, min_step=0, average_expect=True, average_states=False, tidy=True, num_cpus=0, norm_tol=0.001, norm_steps=5, rhs_reuse=False, rhs_filename=None, ntraj=500, gui=False, rhs_with_state=False, store_final_state=False, store_states=False, seeds=None, steady_state_average=False, normalize_output=True, use_openmp=None, openmp_threads=None)[source]Â¶; Class of options for evolution solvers such as qutip.mesolve and; qutip.mcsolve. Options can be specified either as arguments to the; constructor:; opts = Options(order=10, ...). or by changing the class attributes after creation:; opts = Options(); opts.order = 10. Returns options class to be used as options in evol",MatchSource.WIKI,docs/4.3/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/apidoc/classes.html
https://qutip.org/docs/4.3/apidoc/classes.html:40065,Usability,clear,clear,40065,"enating. section: string or `class` : _StatsSection; Section which to add the message to.; If None given, the default (first) section will be used. add_section(name)[source]Â¶; Add another section with the given name. Parameters:; name : string; will be used as key for sections dict; will also be the header for the section. Returns:; section : class; The new section. add_timing(key, value, section=None)[source]Â¶; Add value to timing. If key does not already exist in section then; it is created with this value.; If key already exists it is increased by the give value; value is expected to be a float, and given in seconds. Parameters:; key : string; key for the section.timings dictionary; reusing a key will result in numerical addition of value. value : int; Initial value of the timing, or added to an existing timing. section: string or `class` : _StatsSection; Section which to add the timing to.; If None given, the default (first) section will be used. clear()[source]Â¶; Clear counts, timings and messages from all sections. report(output=<_io.TextIOWrapper name='<stdout>' mode='w' encoding='UTF-8'>)[source]Â¶; Report the counts, timings and messages from the sections.; Sections are reported in the order that the names were supplied; in the constructor.; The counts, timings and messages are reported in the order that they; are added to the sections; The output can be written to anything that supports a write method,; e.g. a file or the console (default); The output is intended to in markdown format. Parameters:; output : stream; file or console stream - anything that support write - where; the output will be written. set_total_time(value, section=None)[source]Â¶; Sets the total time for the complete solve or for a specific section; value is expected to be a float, and given in seconds. Parameters:; value : float; Time in seconds to complete the solver section. section : string or class; Section which to set the total_time for; If None given, the total_time for complete so",MatchSource.WIKI,docs/4.3/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/apidoc/classes.html
https://qutip.org/docs/4.3/apidoc/classes.html:45961,Usability,progress bar,progress bar,45961,"ring (âhomodyneâ, âheterodyneâ, âphotocurrentâ); The name of the type of measurement process that give rise to the; stochastic equation to solve. Specifying a method with this keyword; argument is a short-hand notation for using pre-defined d1 and d2; functions for the corresponding stochastic processes. distribution : string (ânormalâ, âpoissionâ); The name of the distribution used for the stochastic increments. store_measurements : bool (default False); Whether or not to store the measurement results in the; qutip.solver.SolverResult instance returned by the solver. noise : array; Vector specifying the noise. normalize : bool (default True); Whether or not to normalize the wave function during the evolution. options : qutip.solver.Options; Generic solver options. map_func: function; A map function or managing the calls to single-trajactory solvers. map_kwargs: dictionary; Optional keyword arguments to the map_func function function. progress_bar : qutip.ui.BaseProgressBar; Optional progress bar class instance. Permutational InvarianceÂ¶. class Dicke(N, hamiltonian=None, emission=0.0, dephasing=0.0, pumping=0.0, collective_emission=0.0, collective_dephasing=0.0, collective_pumping=0.0)[source]Â¶; The Dicke class which builds the Lindbladian and Liouvillian matrix. Parameters:; N: int; The number of two-level systems. hamiltonian: :class: qutip.Qobj; A Hamiltonian in the Dicke basis.; The matrix dimensions are (nds, nds),; with nds being the number of Dicke states.; The Hamiltonian can be built with the operators; given by the jspin functions. emission: float; Incoherent emission coefficient (also nonradiative emission).; default: 0.0. dephasing: float; Local dephasing coefficient.; default: 0.0. pumping: float; Incoherent pumping coefficient.; default: 0.0. collective_emission: float; Collective (superradiant) emmission coefficient.; default: 0.0. collective_pumping: float; Collective pumping coefficient.; default: 0.0. collective_dephasing: float; Collective dephasi",MatchSource.WIKI,docs/4.3/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/apidoc/classes.html
https://qutip.org/docs/4.3/apidoc/classes.html:51778,Usability,simpl,simple,51778,"iant) emmission coefficient.; default: 0.0. collective_dephasing: float; Collective dephasing coefficient.; default: 0.0. collective_pumping: float; Collective pumping coefficient.; default: 0.0. M: dict; A nested dictionary of the structure {row: {col: val}} which holds; non zero elements of the matrix M. calculate_j_m(dicke_row, dicke_col)[source]Â¶; Get the value of j and m for the particular Dicke space element. Parameters:; dicke_row, dicke_col: int; The row and column from the Dicke space matrix. Returns:; j, m: float; The j and m values. calculate_k(dicke_row, dicke_col)[source]Â¶; Get k value from the current row and column element in the Dicke space. Parameters:; dicke_row, dicke_col: int; The row and column from the Dicke space matrix. Returns. ââ-. k: int; The row index for the matrix M for given Dicke space; element. coefficient_matrix()[source]Â¶; Generate the matrix M governing the dynamics for diagonal cases.; If the initial density matrix and the Hamiltonian is diagonal, the; evolution of the system is given by the simple ODE: dp/dt = Mp. isdicke(dicke_row, dicke_col)[source]Â¶; Check if an element in a matrix is a valid element in the Dicke space.; Dicke row: j value index. Dicke column: m value index.; The function returns True if the element exists in the Dicke space and; False otherwise. Parameters:; dicke_row, dicke_col : int; Index of the element in Dicke space which needs to be checked. solve(rho0, tlist, options=None)[source]Â¶; Solve the ODE for the evolution of diagonal states and Hamiltonians. tau1(j, m)[source]Â¶; Calculate coefficient matrix element relative to (j, m, m). tau2(j, m)[source]Â¶; Calculate coefficient matrix element relative to (j, m+1, m+1). tau3(j, m)[source]Â¶; Calculate coefficient matrix element relative to (j+1, m+1, m+1). tau4(j, m)[source]Â¶; Calculate coefficient matrix element relative to (j-1, m+1, m+1). tau5(j, m)[source]Â¶; Calculate coefficient matrix element relative to (j+1, m, m). tau6(j, m)[source]Â¶; Calculate coeffi",MatchSource.WIKI,docs/4.3/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/apidoc/classes.html
https://qutip.org/docs/4.3/apidoc/classes.html:99315,Usability,simpl,simply,99315,"_utils.logging,; in decreasing levels of messaging, are:; DEBUG_INTENSE, DEBUG_VERBOSE, DEBUG, INFO, WARN, ERROR, CRITICAL; Anything WARN or above is effectively âquietâ execution,; assuming everything runs as expected.; The default NOTSET implies that the level will be taken from; the QuTiP settings file, which by default is WARN. grad_exact : boolean; indicates whether the computer class instance is capable; of computing propagator gradients. It is used to determine; whether to create the Dynamics prop_grad array. apply_params(params=None)[source]Â¶; Set object attributes based on the dictionary (if any) passed in the; instantiation, or passed as a parameter; This is called during the instantiation automatically.; The key value pairs are the attribute name and value; Note: attributes are created if they do not exist already,; and are overwritten if they do. reset()[source]Â¶; reset any configuration data. class PropCompApproxGrad(dynamics, params=None)[source]Â¶; This subclass can be used when the propagator is calculated simply; by expm of the dynamics generator, i.e. when gradients will be calculated; using approximate methods. reset()[source]Â¶; reset any configuration data. class PropCompDiag(dynamics, params=None)[source]Â¶; Coumputes the propagator exponentiation using diagonalisation of; of the dynamics generator. reset()[source]Â¶; reset any configuration data. class PropCompFrechet(dynamics, params=None)[source]Â¶. Frechet method for calculating the propagator:; exponentiating the combined dynamics generator. and the propagator gradient; It should work for all systems, e.g. unitary, open, symplectic; There are other PropagatorComputer subclasses that may be more efficient. reset()[source]Â¶; reset any configuration data. class FidelityComputer(dynamics, params=None)[source]Â¶; Base class for all Fidelity Computers.; This cannot be used directly. See subclass descriptions and choose; one appropriate for the application; Note: this must be instantiated with a Dynami",MatchSource.WIKI,docs/4.3/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/apidoc/classes.html
https://qutip.org/docs/4.3/apidoc/classes.html:102375,Usability,clear,clear,102375,"loat; Last computed value of the normalised fidelity. fidelity_current : boolean; flag to specify whether the fidelity / fid_err are based on the; current amplitude values. Set False when amplitudes change. fid_err_grad: array[num_tslot, num_ctrls] of float; Last computed values for the fidelity error gradients wrt the; control in the timeslot. grad_norm : float; Last computed value for the norm of the fidelity error gradients; (sqrt of the sum of the squares). fid_err_grad_current : boolean; flag to specify whether the fidelity / fid_err are based on the; current amplitude values. Set False when amplitudes change. apply_params(params=None)[source]Â¶; Set object attributes based on the dictionary (if any) passed in the; instantiation, or passed as a parameter; This is called during the instantiation automatically.; The key value pairs are the attribute name and value; Note: attributes are created if they do not exist already,; and are overwritten if they do. clear()[source]Â¶; clear any temporarily held status data. flag_system_changed()[source]Â¶; Flag fidelity and gradients as needing recalculation. get_fid_err()[source]Â¶; returns the absolute distance from the maximum achievable fidelity. get_fid_err_gradient()[source]Â¶; Returns the normalised gradient of the fidelity error; in a (nTimeslots x n_ctrls) array wrt the timeslot control amplitude. init_comp()[source]Â¶; initialises the computer based on the configuration of the Dynamics. reset()[source]Â¶; reset any configuration data and; clear any temporarily held status data. class FidCompUnitary(dynamics, params=None)[source]Â¶; Computes fidelity error and gradient assuming unitary dynamics, e.g.; closed qubit systems; Note fidelity and gradient calculations were taken from DYNAMO; (see file header). Attributes:; phase_option : string. determines how global phase is treated in fidelity calculations:; PSU - global phase ignored; SU - global phase included. fidelity_prenorm : complex; Last computed value of the fidelity ",MatchSource.WIKI,docs/4.3/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/apidoc/classes.html
https://qutip.org/docs/4.3/apidoc/classes.html:102393,Usability,clear,clear,102393,"loat; Last computed value of the normalised fidelity. fidelity_current : boolean; flag to specify whether the fidelity / fid_err are based on the; current amplitude values. Set False when amplitudes change. fid_err_grad: array[num_tslot, num_ctrls] of float; Last computed values for the fidelity error gradients wrt the; control in the timeslot. grad_norm : float; Last computed value for the norm of the fidelity error gradients; (sqrt of the sum of the squares). fid_err_grad_current : boolean; flag to specify whether the fidelity / fid_err are based on the; current amplitude values. Set False when amplitudes change. apply_params(params=None)[source]Â¶; Set object attributes based on the dictionary (if any) passed in the; instantiation, or passed as a parameter; This is called during the instantiation automatically.; The key value pairs are the attribute name and value; Note: attributes are created if they do not exist already,; and are overwritten if they do. clear()[source]Â¶; clear any temporarily held status data. flag_system_changed()[source]Â¶; Flag fidelity and gradients as needing recalculation. get_fid_err()[source]Â¶; returns the absolute distance from the maximum achievable fidelity. get_fid_err_gradient()[source]Â¶; Returns the normalised gradient of the fidelity error; in a (nTimeslots x n_ctrls) array wrt the timeslot control amplitude. init_comp()[source]Â¶; initialises the computer based on the configuration of the Dynamics. reset()[source]Â¶; reset any configuration data and; clear any temporarily held status data. class FidCompUnitary(dynamics, params=None)[source]Â¶; Computes fidelity error and gradient assuming unitary dynamics, e.g.; closed qubit systems; Note fidelity and gradient calculations were taken from DYNAMO; (see file header). Attributes:; phase_option : string. determines how global phase is treated in fidelity calculations:; PSU - global phase ignored; SU - global phase included. fidelity_prenorm : complex; Last computed value of the fidelity ",MatchSource.WIKI,docs/4.3/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/apidoc/classes.html
https://qutip.org/docs/4.3/apidoc/classes.html:102912,Usability,clear,clear,102912," to specify whether the fidelity / fid_err are based on the; current amplitude values. Set False when amplitudes change. apply_params(params=None)[source]Â¶; Set object attributes based on the dictionary (if any) passed in the; instantiation, or passed as a parameter; This is called during the instantiation automatically.; The key value pairs are the attribute name and value; Note: attributes are created if they do not exist already,; and are overwritten if they do. clear()[source]Â¶; clear any temporarily held status data. flag_system_changed()[source]Â¶; Flag fidelity and gradients as needing recalculation. get_fid_err()[source]Â¶; returns the absolute distance from the maximum achievable fidelity. get_fid_err_gradient()[source]Â¶; Returns the normalised gradient of the fidelity error; in a (nTimeslots x n_ctrls) array wrt the timeslot control amplitude. init_comp()[source]Â¶; initialises the computer based on the configuration of the Dynamics. reset()[source]Â¶; reset any configuration data and; clear any temporarily held status data. class FidCompUnitary(dynamics, params=None)[source]Â¶; Computes fidelity error and gradient assuming unitary dynamics, e.g.; closed qubit systems; Note fidelity and gradient calculations were taken from DYNAMO; (see file header). Attributes:; phase_option : string. determines how global phase is treated in fidelity calculations:; PSU - global phase ignored; SU - global phase included. fidelity_prenorm : complex; Last computed value of the fidelity before it is normalised; It is stored to use in the gradient normalisation calculation. fidelity_prenorm_current : boolean; flag to specify whether fidelity_prenorm are based on the; current amplitude values. Set False when amplitudes change. clear()[source]Â¶; clear any temporarily held status data. compute_fid_grad()[source]Â¶; Calculates exact gradient of function wrt to each timeslot; control amplitudes. Note these gradients are not normalised; These are returned as a (nTimeslots x n_ctrls) arra",MatchSource.WIKI,docs/4.3/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/apidoc/classes.html
https://qutip.org/docs/4.3/apidoc/classes.html:103646,Usability,clear,clear,103646,"t of the fidelity error; in a (nTimeslots x n_ctrls) array wrt the timeslot control amplitude. init_comp()[source]Â¶; initialises the computer based on the configuration of the Dynamics. reset()[source]Â¶; reset any configuration data and; clear any temporarily held status data. class FidCompUnitary(dynamics, params=None)[source]Â¶; Computes fidelity error and gradient assuming unitary dynamics, e.g.; closed qubit systems; Note fidelity and gradient calculations were taken from DYNAMO; (see file header). Attributes:; phase_option : string. determines how global phase is treated in fidelity calculations:; PSU - global phase ignored; SU - global phase included. fidelity_prenorm : complex; Last computed value of the fidelity before it is normalised; It is stored to use in the gradient normalisation calculation. fidelity_prenorm_current : boolean; flag to specify whether fidelity_prenorm are based on the; current amplitude values. Set False when amplitudes change. clear()[source]Â¶; clear any temporarily held status data. compute_fid_grad()[source]Â¶; Calculates exact gradient of function wrt to each timeslot; control amplitudes. Note these gradients are not normalised; These are returned as a (nTimeslots x n_ctrls) array. flag_system_changed()[source]Â¶; Flag fidelity and gradients as needing recalculation. get_fid_err()[source]Â¶; Gets the absolute error in the fidelity. get_fid_err_gradient()[source]Â¶; Returns the normalised gradient of the fidelity error; in a (nTimeslots x n_ctrls) array; The gradients are cached in case they are requested; mutliple times between control updates; (although this is not typically found to happen). get_fidelity()[source]Â¶; Gets the appropriately normalised fidelity value; The normalisation is determined by the fid_norm_func pointer; which should be set in the config. get_fidelity_prenorm()[source]Â¶; Gets the current fidelity value prior to normalisation; Note the gradient function uses this value; The value is cached, because it is used in t",MatchSource.WIKI,docs/4.3/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/apidoc/classes.html
https://qutip.org/docs/4.3/apidoc/classes.html:103664,Usability,clear,clear,103664,"t of the fidelity error; in a (nTimeslots x n_ctrls) array wrt the timeslot control amplitude. init_comp()[source]Â¶; initialises the computer based on the configuration of the Dynamics. reset()[source]Â¶; reset any configuration data and; clear any temporarily held status data. class FidCompUnitary(dynamics, params=None)[source]Â¶; Computes fidelity error and gradient assuming unitary dynamics, e.g.; closed qubit systems; Note fidelity and gradient calculations were taken from DYNAMO; (see file header). Attributes:; phase_option : string. determines how global phase is treated in fidelity calculations:; PSU - global phase ignored; SU - global phase included. fidelity_prenorm : complex; Last computed value of the fidelity before it is normalised; It is stored to use in the gradient normalisation calculation. fidelity_prenorm_current : boolean; flag to specify whether fidelity_prenorm are based on the; current amplitude values. Set False when amplitudes change. clear()[source]Â¶; clear any temporarily held status data. compute_fid_grad()[source]Â¶; Calculates exact gradient of function wrt to each timeslot; control amplitudes. Note these gradients are not normalised; These are returned as a (nTimeslots x n_ctrls) array. flag_system_changed()[source]Â¶; Flag fidelity and gradients as needing recalculation. get_fid_err()[source]Â¶; Gets the absolute error in the fidelity. get_fid_err_gradient()[source]Â¶; Returns the normalised gradient of the fidelity error; in a (nTimeslots x n_ctrls) array; The gradients are cached in case they are requested; mutliple times between control updates; (although this is not typically found to happen). get_fidelity()[source]Â¶; Gets the appropriately normalised fidelity value; The normalisation is determined by the fid_norm_func pointer; which should be set in the config. get_fidelity_prenorm()[source]Â¶; Gets the current fidelity value prior to normalisation; Note the gradient function uses this value; The value is cached, because it is used in t",MatchSource.WIKI,docs/4.3/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/apidoc/classes.html
https://qutip.org/docs/4.3/apidoc/classes.html:105615,Usability,clear,clear,105615,"tion uses this value; The value is cached, because it is used in the gradient calculation. init_comp()[source]Â¶; Check configuration and initialise the normalisation. init_normalization()[source]Â¶; Calc norm of <Ufinal | Ufinal> to scale subsequent norms; When considering unitary time evolution operators, this basically; results in calculating the trace of the identity matrix; and is hence equal to the size of the target matrix; There may be situations where this is not the case, and hence it; is not assumed to be so.; The normalisation function called should be set to either the; PSU - global phase ignored; SU - global phase respected. normalize_PSU(A)[source]Â¶. normalize_SU(A)[source]Â¶. normalize_gradient_PSU(grad)[source]Â¶; Normalise the gradient matrix passed as grad; This PSU version is independent of global phase. normalize_gradient_SU(grad)[source]Â¶; Normalise the gradient matrix passed as grad; This SU version respects global phase. reset()[source]Â¶; reset any configuration data and; clear any temporarily held status data. set_phase_option(phase_option=None)[source]Â¶; Deprecated - use phase_option; Phase options are; SU - global phase important; PSU - global phase is not important. class FidCompTraceDiff(dynamics, params=None)[source]Â¶; Computes fidelity error and gradient for general system dynamics; by calculating the the fidelity error as the trace of the overlap; of the difference between the target and evolution resulting from; the pulses with the transpose of the same.; This should provide a distance measure for dynamics described by matrices; Note the gradient calculation is taken from:; âRobust quantum gates for open systems via optimal control:; Markovian versus non-Markovian dynamicsâ; Frederik F Floether, Pierre de Fouquieres, and Sophie G Schirmer. Attributes:; scale_factor : float; The fidelity error calculated is of some arbitary scale. This; factor can be used to scale the fidelity error such that it may; represent some physical measure; If No",MatchSource.WIKI,docs/4.3/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/apidoc/classes.html
https://qutip.org/docs/4.3/apidoc/classes.html:107474,Usability,clear,clear,107474,"ated is of some arbitary scale. This; factor can be used to scale the fidelity error such that it may; represent some physical measure; If None is given then it is caculated as 1/2N, where N; is the dimension of the drift, when the Dynamics are initialised. compute_fid_err_grad()[source]Â¶; Calculate exact gradient of the fidelity error function; wrt to each timeslot control amplitudes.; Uses the trace difference norm fidelity; These are returned as a (nTimeslots x n_ctrls) array. get_fid_err()[source]Â¶; Gets the absolute error in the fidelity. get_fid_err_gradient()[source]Â¶; Returns the normalised gradient of the fidelity error; in a (nTimeslots x n_ctrls) array; The gradients are cached in case they are requested; mutliple times between control updates; (although this is not typically found to happen). init_comp()[source]Â¶; initialises the computer based on the configuration of the Dynamics; Calculates the scale_factor is not already set. reset()[source]Â¶; reset any configuration data and; clear any temporarily held status data. class FidCompTraceDiffApprox(dynamics, params=None)[source]Â¶; As FidCompTraceDiff, except uses the finite difference method to; compute approximate gradients. Attributes:; epsilon : float; control amplitude offset to use when approximating the gradient wrt; a timeslot control amplitude. compute_fid_err_grad()[source]Â¶; Calculates gradient of function wrt to each timeslot; control amplitudes. Note these gradients are not normalised; They are calulated; These are returned as a (nTimeslots x n_ctrls) array. reset()[source]Â¶; reset any configuration data and; clear any temporarily held status data. class TimeslotComputer(dynamics, params=None)[source]Â¶; Base class for all Timeslot Computers; Note: this must be instantiated with a Dynamics object, that is the; container for the data that the methods operate on. Attributes:; log_level : integer; level of messaging output from the logger.; Options are attributes of qutip.logging_utils,; in decrea",MatchSource.WIKI,docs/4.3/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/apidoc/classes.html
https://qutip.org/docs/4.3/apidoc/classes.html:108076,Usability,clear,clear,108076,"sed gradient of the fidelity error; in a (nTimeslots x n_ctrls) array; The gradients are cached in case they are requested; mutliple times between control updates; (although this is not typically found to happen). init_comp()[source]Â¶; initialises the computer based on the configuration of the Dynamics; Calculates the scale_factor is not already set. reset()[source]Â¶; reset any configuration data and; clear any temporarily held status data. class FidCompTraceDiffApprox(dynamics, params=None)[source]Â¶; As FidCompTraceDiff, except uses the finite difference method to; compute approximate gradients. Attributes:; epsilon : float; control amplitude offset to use when approximating the gradient wrt; a timeslot control amplitude. compute_fid_err_grad()[source]Â¶; Calculates gradient of function wrt to each timeslot; control amplitudes. Note these gradients are not normalised; They are calulated; These are returned as a (nTimeslots x n_ctrls) array. reset()[source]Â¶; reset any configuration data and; clear any temporarily held status data. class TimeslotComputer(dynamics, params=None)[source]Â¶; Base class for all Timeslot Computers; Note: this must be instantiated with a Dynamics object, that is the; container for the data that the methods operate on. Attributes:; log_level : integer; level of messaging output from the logger.; Options are attributes of qutip.logging_utils,; in decreasing levels of messaging, are:; DEBUG_INTENSE, DEBUG_VERBOSE, DEBUG, INFO, WARN, ERROR, CRITICAL; Anything WARN or above is effectively âquietâ execution,; assuming everything runs as expected.; The default NOTSET implies that the level will be taken from; the QuTiP settings file, which by default is WARN. evo_comp_summary : EvoCompSummary; A summary of the most recent evolution computation; Used in the stats and dump; Will be set to None if neither stats or dump are set. apply_params(params=None)[source]Â¶; Set object attributes based on the dictionary (if any) passed in the; instantiation, or p",MatchSource.WIKI,docs/4.3/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/apidoc/classes.html
https://qutip.org/docs/4.3/apidoc/classes.html:109896,Usability,simpl,simply,109896,"t to None if neither stats or dump are set. apply_params(params=None)[source]Â¶; Set object attributes based on the dictionary (if any) passed in the; instantiation, or passed as a parameter; This is called during the instantiation automatically.; The key value pairs are the attribute name and value; Note: attributes are created if they do not exist already,; and are overwritten if they do. dump_current()[source]Â¶; Store a copy of the current time evolution. class TSlotCompUpdateAll(dynamics, params=None)[source]Â¶; Timeslot Computer - Update All; Updates all dynamics generators, propagators and evolutions when; ctrl amplitudes are updated. compare_amps(new_amps)[source]Â¶; Determine if any amplitudes have changed. If so, then mark the; timeslots as needing recalculation; Returns: True if amplitudes are the same, False if they have changed. get_timeslot_for_fidelity_calc()[source]Â¶; Returns the timeslot index that will be used calculate current fidelity; value.; This (default) method simply returns the last timeslot. recompute_evolution()[source]Â¶; Recalculates the evolution operators.; Dynamics generators (e.g. Hamiltonian) and; prop (propagators) are calculated as necessary. class PulseGen(dyn=None, params=None)[source]Â¶; Pulse generator; Base class for all Pulse generators; The object can optionally be instantiated with a Dynamics object,; in which case the timeslots and amplitude scaling and offset; are copied from that.; Otherwise the class can be used independently by setting:; tau (array of timeslot durations); or; num_tslots and pulse_time for equally spaced timeslots. Attributes:; num_tslots : integer; Number of timeslots, aka timeslices; (copied from Dynamics if given). pulse_time : float; total duration of the pulse; (copied from Dynamics.evo_time if given). scaling : float; linear scaling applied to the pulse; (copied from Dynamics.initial_ctrl_scaling if given). offset : float; linear offset applied to the pulse; (copied from Dynamics.initial_ctrl_offset if",MatchSource.WIKI,docs/4.3/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/apidoc/classes.html
https://qutip.org/docs/4.3/apidoc/classes.html:112682,Usability,simpl,simply,112682,"erator produces random pulses. log_level : integer; level of messaging output from the logger.; Options are attributes of qutip.logging_utils,; in decreasing levels of messaging, are:; DEBUG_INTENSE, DEBUG_VERBOSE, DEBUG, INFO, WARN, ERROR, CRITICAL; Anything WARN or above is effectively âquietâ execution,; assuming everything runs as expected.; The default NOTSET implies that the level will be taken from; the QuTiP settings file, which by default is WARN. apply_params(params=None)[source]Â¶; Set object attributes based on the dictionary (if any) passed in the; instantiation, or passed as a parameter; This is called during the instantiation automatically.; The key value pairs are the attribute name and value. gen_pulse()[source]Â¶; returns the pulse as an array of vales for each timeslot; Must be implemented by subclass. init_pulse()[source]Â¶; Initialise the pulse parameters. reset()[source]Â¶; reset attributes to default values. class PulseGenRandom(dyn=None, params=None)[source]Â¶; Generates random pulses as simply random values for each timeslot. gen_pulse()[source]Â¶; Generate a pulse of random values between 1 and -1; Values are scaled using the scaling property; and shifted using the offset property; Returns the pulse as an array of vales for each timeslot. reset()[source]Â¶; reset attributes to default values. class PulseGenZero(dyn=None, params=None)[source]Â¶; Generates a flat pulse. gen_pulse()[source]Â¶; Generate a pulse with the same value in every timeslot.; The value will be zero, unless the offset is not zero,; in which case it will be the offset. class PulseGenLinear(dyn=None, params=None)[source]Â¶; Generates linear pulses. Attributes:; gradient : float; Gradient of the line.; Note this is calculated from the start_val and end_val if these; are given. start_val : float; Start point of the line. That is the starting amplitude. end_val : float; End point of the line.; That is the amplitude at the start of the last timeslot. gen_pulse(gradient=None, start_val=No",MatchSource.WIKI,docs/4.3/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/apidoc/classes.html
https://qutip.org/docs/4.3/apidoc/classes.html:120604,Usability,simpl,simply,120604,"eqs : bool; If True (default) the some random offset is applied to the frequencies. gen_pulse(coeffs=None)[source]Â¶; Generate a pulse using the Fourier basis with the freqs and; coeffs attributes. Parameters:; coeffs : float array[num_coeffs, num_basis_funcs]; The basis coefficient values; If given this overides the default and sets the attribute; of the same name. init_freqs()[source]Â¶; Generate the frequencies; These are the Fourier harmonics with a uniformly distributed; random offset. init_pulse(num_coeffs=None)[source]Â¶; Set the initial freq and coefficient values. reset()[source]Â¶; reset attributes to default values. class Stats[source]Â¶; Base class for all optimisation statistics; Used for configurations where all timeslots are updated each iteration; e.g. exact gradients; Note that all times are generated using timeit.default_timer() and are; in seconds. Attributes:; dyn_gen_name : string; Text used in some report functions.; Makes sense to set it to âHamiltonianâ when using unitary dynamics; Default is simply âdynamics generatorâ. num_iter : integer; Number of iterations of the optimisation algorithm. wall_time_optim_start : float; Start time for the optimisation. wall_time_optim_end : float; End time for the optimisation. wall_time_optim : float; Time elasped during the optimisation. wall_time_dyn_gen_compute : float; Total wall (elasped) time computing combined dynamics generator; (for example combining drift and control Hamiltonians). wall_time_prop_compute : float; Total wall (elasped) time computing propagators, that is the; time evolution from one timeslot to the next; Includes calculating the propagator gradient for exact gradients. wall_time_fwd_prop_compute : float; Total wall (elasped) time computing combined forward propagation,; that is the time evolution from the start to a specific timeslot.; Excludes calculating the propagators themselves. wall_time_onwd_prop_compute : float; Total wall (elasped) time computing combined onward propagation,; th",MatchSource.WIKI,docs/4.3/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/apidoc/classes.html
https://qutip.org/docs/4.3/apidoc/functions.html:2867,Availability,down,down,2867,"e requested number state |n>. Notes; A subtle incompatibility with the quantum optics toolbox: In QuTiP:; basis(N, 0) = ground state. but in the qotoolbox:; basis(N, 1) = ground state. Examples; >>> basis(5,2); Quantum object: dims = [[5], [1]], shape = [5, 1], type = ket; Qobj data =; [[ 0.+0.j]; [ 0.+0.j]; [ 1.+0.j]; [ 0.+0.j]; [ 0.+0.j]]. bell_state(state='00')[source]Â¶; Returns the Bell state:. |B00> = 1 / sqrt(2)*[|0>|0>+|1>|1>]; |B01> = 1 / sqrt(2)*[|0>|0>-|1>|1>]; |B10> = 1 / sqrt(2)*[|0>|1>+|1>|0>]; |B11> = 1 / sqrt(2)*[|0>|1>-|1>|0>]. Returns:; Bell_state : qobj; Bell state. bra(seq, dim=2)[source]Â¶; Produces a multiparticle bra state for a list or string,; where each element stands for state of the respective particle. Parameters:; seq : str / list of ints or characters; Each element defines state of the respective particle.; (e.g. [1,1,0,1] or a string â1101â).; For qubits it is also possible to use the following conventions:; - âgâ/âeâ (ground and excited state); - âuâ/âdâ (spin up and down); - âHâ/âVâ (horizontal and vertical polarization); Note: for dimension > 9 you need to use a list. dim : int (default: 2) / list of ints; Space dimension for each particle:; int if there are the same, list if they are different. Returns:; bra : qobj. Examples; >>> bra(""10""); Quantum object: dims = [[1, 1], [2, 2]], shape = [1, 4], type = bra; Qobj data =; [[ 0. 0. 1. 0.]]. >>> bra(""Hue""); Quantum object: dims = [[1, 1, 1], [2, 2, 2]], shape = [1, 8], type = bra; Qobj data =; [[ 0. 1. 0. 0. 0. 0. 0. 0.]]. >>> bra(""12"", 3); Quantum object: dims = [[1, 1], [3, 3]], shape = [1, 9], type = bra; Qobj data =; [[ 0. 0. 0. 0. 0. 1. 0. 0. 0.]]. >>> bra(""31"", [5, 2]); Quantum object: dims = [[1, 1], [5, 2]], shape = [1, 10], type = bra; Qobj data =; [[ 0. 0. 0. 0. 0. 0. 0. 1. 0. 0.]]. coherent(N, alpha, offset=0, method='operator')[source]Â¶; Generates a coherent state with eigenvalue alpha.; Constructed using displacement operator on vacuum state. Parameters:; N : int; Number of",MatchSource.WIKI,docs/4.3/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/apidoc/functions.html
https://qutip.org/docs/4.3/apidoc/functions.html:10857,Availability,down,down,10857,"Fock state. Examples; >>> fock_dm(3,1); Quantum object: dims = [[3], [3]], shape = [3, 3], type = oper, isHerm = True; Qobj data =; [[ 0.+0.j 0.+0.j 0.+0.j]; [ 0.+0.j 1.+0.j 0.+0.j]; [ 0.+0.j 0.+0.j 0.+0.j]]. ghz_state(N=3)[source]Â¶; Returns the N-qubit GHZ-state. Parameters:; N : int (default=3); Number of qubits in state. Returns:; G : qobj; N-qubit GHZ-state. maximally_mixed_dm(N)[source]Â¶; Returns the maximally mixed density matrix for a Hilbert space of; dimension N. Parameters:; N : int; Number of basis states in Hilbert space. Returns:; dm : qobj; Thermal state density matrix. ket(seq, dim=2)[source]Â¶; Produces a multiparticle ket state for a list or string,; where each element stands for state of the respective particle. Parameters:; seq : str / list of ints or characters; Each element defines state of the respective particle.; (e.g. [1,1,0,1] or a string â1101â).; For qubits it is also possible to use the following conventions:; - âgâ/âeâ (ground and excited state); - âuâ/âdâ (spin up and down); - âHâ/âVâ (horizontal and vertical polarization); Note: for dimension > 9 you need to use a list. dim : int (default: 2) / list of ints; Space dimension for each particle:; int if there are the same, list if they are different. Returns:; ket : qobj. Examples; >>> ket(""10""); Quantum object: dims = [[2, 2], [1, 1]], shape = [4, 1], type = ket; Qobj data =; [[ 0.]; [ 0.]; [ 1.]; [ 0.]]. >>> ket(""Hue""); Quantum object: dims = [[2, 2, 2], [1, 1, 1]], shape = [8, 1], type = ket; Qobj data =; [[ 0.]; [ 1.]; [ 0.]; [ 0.]; [ 0.]; [ 0.]; [ 0.]; [ 0.]]. >>> ket(""12"", 3); Quantum object: dims = [[3, 3], [1, 1]], shape = [9, 1], type = ket; Qobj data =; [[ 0.]; [ 0.]; [ 0.]; [ 0.]; [ 0.]; [ 1.]; [ 0.]; [ 0.]; [ 0.]]. >>> ket(""31"", [5, 2]); Quantum object: dims = [[5, 2], [1, 1]], shape = [10, 1], type = ket; Qobj data =; [[ 0.]; [ 0.]; [ 0.]; [ 0.]; [ 0.]; [ 0.]; [ 0.]; [ 1.]; [ 0.]; [ 0.]]. ket2dm(Q)[source]Â¶; Takes input ket or bra vector and returns density matrix; formed by o",MatchSource.WIKI,docs/4.3/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/apidoc/functions.html
https://qutip.org/docs/4.3/apidoc/functions.html:30525,Availability,error,error,30525,"erator with elements of the form; \(\sum |N><N+m| + |N+m><N|\). Parameters:; N : int; Number of basis states in Hilbert space. m : int (default = 1); Number of excitations in tunneling event. Returns:; T : Qobj; Tunneling operator. Notes. New in version 3.2. Random Operators and StatesÂ¶; This module is a collection of random state and operator generators.; The sparsity of the ouput Qobjâs is controlled by varing the; density parameter. rand_dm(N, density=0.75, pure=False, dims=None)[source]Â¶; Creates a random NxN density matrix. Parameters:; N : int, ndarray, list; If int, then shape of output operator. If list/ndarray then eigenvalues; of generated density matrix. density : float; Density between [0,1] of output density matrix. dims : list; Dimensions of quantum object. Used for specifying; tensor structure. Default is dims=[[N],[N]]. Returns:; oper : qobj; NxN density matrix quantum operator. Notes; For small density matrices., choosing a low density will result in an error; as no diagonal elements will be generated such that \(Tr(\rho)=1\). rand_dm_ginibre(N=2, rank=None, dims=None)[source]Â¶; Returns a Ginibre random density operator of dimension; dim and rank rank by using the algorithm of; [BCSZ08]. If rank is None, a full-rank; (Hilbert-Schmidt ensemble) random density operator will be; returned. Parameters:; N : int; Dimension of the density operator to be returned. dims : list; Dimensions of quantum object. Used for specifying; tensor structure. Default is dims=[[N],[N]]. rank : int or None; Rank of the sampled density operator. If None, a full-rank; density operator is generated. Returns:; rho : Qobj; An N Ã N density operator sampled from the Ginibre; or Hilbert-Schmidt distribution. rand_dm_hs(N=2, dims=None)[source]Â¶; Returns a Hilbert-Schmidt random density operator of dimension; dim and rank rank by using the algorithm of; [BCSZ08]. Parameters:; N : int; Dimension of the density operator to be returned. dims : list; Dimensions of quantum object. Used fo",MatchSource.WIKI,docs/4.3/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/apidoc/functions.html
https://qutip.org/docs/4.3/apidoc/functions.html:43246,Availability,mask,mask,43246,"rgument.; For ordinary operators and vectors, this is the tensor product,; while for superoperators and vectorized operators, this is; the column-reshuffled tensor product.; If a mix of Qobjs supported on Hilbert and Liouville spaces; are passed in, the former are promoted. Ordinary operators; are assumed to be unitaries, and are promoted using to_super,; while kets and bras are promoted by taking their projectors and; using operator_to_vector(ket2dm(arg)). tensor_contract(qobj, *pairs)[source]Â¶; Contracts a qobj along one or more index pairs.; Note that this uses dense representations and thus; should not be used for very large Qobjs. Parameters:; pairs : tuple; One or more tuples (i, j) indicating that the; i and j dimensions of the original qobj; should be contracted. Returns:; cqobj : Qobj; The original Qobj with all named index pairs contracted; away. Partial TransposeÂ¶. partial_transpose(rho, mask, method='dense')[source]Â¶; Return the partial transpose of a Qobj instance rho,; where mask is an array/list with length that equals; the number of components of rho (that is, the length of; rho.dims[0]), and the values in mask indicates whether; or not the corresponding subsystem is to be transposed.; The elements in mask can be boolean or integers 0 or 1,; where True/1 indicates that the corresponding subsystem; should be tranposed. Parameters:; rho : qutip.qobj; A density matrix. mask : list / array; A mask that selects which subsystems should be transposed. method : str; choice of method, dense or sparse. The default method; is dense. The sparse implementation can be faster for; large and sparse systems (hundreds of quantum states). Returns:; rho_pr: :class:`qutip.qobj`; A density matrix with the selected subsystems transposed. Entropy FunctionsÂ¶. concurrence(rho)[source]Â¶; Calculate the concurrence entanglement measure for a two-qubit state. Parameters:; state : qobj; Ket, bra, or density matrix for a two-qubit state. Returns:; concur : float; Concurrence. Refer",MatchSource.WIKI,docs/4.3/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/apidoc/functions.html
https://qutip.org/docs/4.3/apidoc/functions.html:43338,Availability,mask,mask,43338,"rgument.; For ordinary operators and vectors, this is the tensor product,; while for superoperators and vectorized operators, this is; the column-reshuffled tensor product.; If a mix of Qobjs supported on Hilbert and Liouville spaces; are passed in, the former are promoted. Ordinary operators; are assumed to be unitaries, and are promoted using to_super,; while kets and bras are promoted by taking their projectors and; using operator_to_vector(ket2dm(arg)). tensor_contract(qobj, *pairs)[source]Â¶; Contracts a qobj along one or more index pairs.; Note that this uses dense representations and thus; should not be used for very large Qobjs. Parameters:; pairs : tuple; One or more tuples (i, j) indicating that the; i and j dimensions of the original qobj; should be contracted. Returns:; cqobj : Qobj; The original Qobj with all named index pairs contracted; away. Partial TransposeÂ¶. partial_transpose(rho, mask, method='dense')[source]Â¶; Return the partial transpose of a Qobj instance rho,; where mask is an array/list with length that equals; the number of components of rho (that is, the length of; rho.dims[0]), and the values in mask indicates whether; or not the corresponding subsystem is to be transposed.; The elements in mask can be boolean or integers 0 or 1,; where True/1 indicates that the corresponding subsystem; should be tranposed. Parameters:; rho : qutip.qobj; A density matrix. mask : list / array; A mask that selects which subsystems should be transposed. method : str; choice of method, dense or sparse. The default method; is dense. The sparse implementation can be faster for; large and sparse systems (hundreds of quantum states). Returns:; rho_pr: :class:`qutip.qobj`; A density matrix with the selected subsystems transposed. Entropy FunctionsÂ¶. concurrence(rho)[source]Â¶; Calculate the concurrence entanglement measure for a two-qubit state. Parameters:; state : qobj; Ket, bra, or density matrix for a two-qubit state. Returns:; concur : float; Concurrence. Refer",MatchSource.WIKI,docs/4.3/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/apidoc/functions.html
https://qutip.org/docs/4.3/apidoc/functions.html:43474,Availability,mask,mask,43474,"roduct.; If a mix of Qobjs supported on Hilbert and Liouville spaces; are passed in, the former are promoted. Ordinary operators; are assumed to be unitaries, and are promoted using to_super,; while kets and bras are promoted by taking their projectors and; using operator_to_vector(ket2dm(arg)). tensor_contract(qobj, *pairs)[source]Â¶; Contracts a qobj along one or more index pairs.; Note that this uses dense representations and thus; should not be used for very large Qobjs. Parameters:; pairs : tuple; One or more tuples (i, j) indicating that the; i and j dimensions of the original qobj; should be contracted. Returns:; cqobj : Qobj; The original Qobj with all named index pairs contracted; away. Partial TransposeÂ¶. partial_transpose(rho, mask, method='dense')[source]Â¶; Return the partial transpose of a Qobj instance rho,; where mask is an array/list with length that equals; the number of components of rho (that is, the length of; rho.dims[0]), and the values in mask indicates whether; or not the corresponding subsystem is to be transposed.; The elements in mask can be boolean or integers 0 or 1,; where True/1 indicates that the corresponding subsystem; should be tranposed. Parameters:; rho : qutip.qobj; A density matrix. mask : list / array; A mask that selects which subsystems should be transposed. method : str; choice of method, dense or sparse. The default method; is dense. The sparse implementation can be faster for; large and sparse systems (hundreds of quantum states). Returns:; rho_pr: :class:`qutip.qobj`; A density matrix with the selected subsystems transposed. Entropy FunctionsÂ¶. concurrence(rho)[source]Â¶; Calculate the concurrence entanglement measure for a two-qubit state. Parameters:; state : qobj; Ket, bra, or density matrix for a two-qubit state. Returns:; concur : float; Concurrence. References. [1]http://en.wikipedia.org/wiki/Concurrence_(quantum_computing). entropy_conditional(rho, selB, base=2.718281828459045, sparse=False)[source]Â¶; Calculates the ",MatchSource.WIKI,docs/4.3/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/apidoc/functions.html
https://qutip.org/docs/4.3/apidoc/functions.html:43571,Availability,mask,mask,43571,"rators; are assumed to be unitaries, and are promoted using to_super,; while kets and bras are promoted by taking their projectors and; using operator_to_vector(ket2dm(arg)). tensor_contract(qobj, *pairs)[source]Â¶; Contracts a qobj along one or more index pairs.; Note that this uses dense representations and thus; should not be used for very large Qobjs. Parameters:; pairs : tuple; One or more tuples (i, j) indicating that the; i and j dimensions of the original qobj; should be contracted. Returns:; cqobj : Qobj; The original Qobj with all named index pairs contracted; away. Partial TransposeÂ¶. partial_transpose(rho, mask, method='dense')[source]Â¶; Return the partial transpose of a Qobj instance rho,; where mask is an array/list with length that equals; the number of components of rho (that is, the length of; rho.dims[0]), and the values in mask indicates whether; or not the corresponding subsystem is to be transposed.; The elements in mask can be boolean or integers 0 or 1,; where True/1 indicates that the corresponding subsystem; should be tranposed. Parameters:; rho : qutip.qobj; A density matrix. mask : list / array; A mask that selects which subsystems should be transposed. method : str; choice of method, dense or sparse. The default method; is dense. The sparse implementation can be faster for; large and sparse systems (hundreds of quantum states). Returns:; rho_pr: :class:`qutip.qobj`; A density matrix with the selected subsystems transposed. Entropy FunctionsÂ¶. concurrence(rho)[source]Â¶; Calculate the concurrence entanglement measure for a two-qubit state. Parameters:; state : qobj; Ket, bra, or density matrix for a two-qubit state. Returns:; concur : float; Concurrence. References. [1]http://en.wikipedia.org/wiki/Concurrence_(quantum_computing). entropy_conditional(rho, selB, base=2.718281828459045, sparse=False)[source]Â¶; Calculates the conditional entropy \(S(A|B)=S(A,B)-S(B)\); of a selected density matrix component. Parameters:; rho : qobj; Density matr",MatchSource.WIKI,docs/4.3/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/apidoc/functions.html
https://qutip.org/docs/4.3/apidoc/functions.html:43739,Availability,mask,mask,43739,"tor(ket2dm(arg)). tensor_contract(qobj, *pairs)[source]Â¶; Contracts a qobj along one or more index pairs.; Note that this uses dense representations and thus; should not be used for very large Qobjs. Parameters:; pairs : tuple; One or more tuples (i, j) indicating that the; i and j dimensions of the original qobj; should be contracted. Returns:; cqobj : Qobj; The original Qobj with all named index pairs contracted; away. Partial TransposeÂ¶. partial_transpose(rho, mask, method='dense')[source]Â¶; Return the partial transpose of a Qobj instance rho,; where mask is an array/list with length that equals; the number of components of rho (that is, the length of; rho.dims[0]), and the values in mask indicates whether; or not the corresponding subsystem is to be transposed.; The elements in mask can be boolean or integers 0 or 1,; where True/1 indicates that the corresponding subsystem; should be tranposed. Parameters:; rho : qutip.qobj; A density matrix. mask : list / array; A mask that selects which subsystems should be transposed. method : str; choice of method, dense or sparse. The default method; is dense. The sparse implementation can be faster for; large and sparse systems (hundreds of quantum states). Returns:; rho_pr: :class:`qutip.qobj`; A density matrix with the selected subsystems transposed. Entropy FunctionsÂ¶. concurrence(rho)[source]Â¶; Calculate the concurrence entanglement measure for a two-qubit state. Parameters:; state : qobj; Ket, bra, or density matrix for a two-qubit state. Returns:; concur : float; Concurrence. References. [1]http://en.wikipedia.org/wiki/Concurrence_(quantum_computing). entropy_conditional(rho, selB, base=2.718281828459045, sparse=False)[source]Â¶; Calculates the conditional entropy \(S(A|B)=S(A,B)-S(B)\); of a selected density matrix component. Parameters:; rho : qobj; Density matrix of composite object. selB : int/list; Selected components for density matrix B. base : {e,2}; Base of logarithm. sparse : {False,True}; Use sparse eigenso",MatchSource.WIKI,docs/4.3/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/apidoc/functions.html
https://qutip.org/docs/4.3/apidoc/functions.html:43762,Availability,mask,mask,43762,"tor(ket2dm(arg)). tensor_contract(qobj, *pairs)[source]Â¶; Contracts a qobj along one or more index pairs.; Note that this uses dense representations and thus; should not be used for very large Qobjs. Parameters:; pairs : tuple; One or more tuples (i, j) indicating that the; i and j dimensions of the original qobj; should be contracted. Returns:; cqobj : Qobj; The original Qobj with all named index pairs contracted; away. Partial TransposeÂ¶. partial_transpose(rho, mask, method='dense')[source]Â¶; Return the partial transpose of a Qobj instance rho,; where mask is an array/list with length that equals; the number of components of rho (that is, the length of; rho.dims[0]), and the values in mask indicates whether; or not the corresponding subsystem is to be transposed.; The elements in mask can be boolean or integers 0 or 1,; where True/1 indicates that the corresponding subsystem; should be tranposed. Parameters:; rho : qutip.qobj; A density matrix. mask : list / array; A mask that selects which subsystems should be transposed. method : str; choice of method, dense or sparse. The default method; is dense. The sparse implementation can be faster for; large and sparse systems (hundreds of quantum states). Returns:; rho_pr: :class:`qutip.qobj`; A density matrix with the selected subsystems transposed. Entropy FunctionsÂ¶. concurrence(rho)[source]Â¶; Calculate the concurrence entanglement measure for a two-qubit state. Parameters:; state : qobj; Ket, bra, or density matrix for a two-qubit state. Returns:; concur : float; Concurrence. References. [1]http://en.wikipedia.org/wiki/Concurrence_(quantum_computing). entropy_conditional(rho, selB, base=2.718281828459045, sparse=False)[source]Â¶; Calculates the conditional entropy \(S(A|B)=S(A,B)-S(B)\); of a selected density matrix component. Parameters:; rho : qobj; Density matrix of composite object. selB : int/list; Selected components for density matrix B. base : {e,2}; Base of logarithm. sparse : {False,True}; Use sparse eigenso",MatchSource.WIKI,docs/4.3/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/apidoc/functions.html
https://qutip.org/docs/4.3/apidoc/functions.html:82249,Availability,error,errors,82249,"ady-stateâ is only implemented; for the me and es solvers. tlist : array_like; list of times for \(t\). tlist must be positive and contain the; element 0. When taking steady-steady correlations only one tlist; value is necessary, i.e. when \(t \rightarrow \infty\); here; tlist is automatically set, ignoring user input. taulist : array_like; list of times for \(\tau\). taulist must be positive and contain; the element 0. c_ops : list; list of collapse operators, may be time-dependent for solver choice of; me or mc. a_op : Qobj; operator A. b_op : Qobj; operator B. reverse : bool; If True, calculate \(\left<A(t)B(t+\tau)\right>\) instead of; \(\left<A(t+\tau)B(t)\right>\). solver : str; choice of solver (me for master-equation, mc for Monte Carlo, and; es for exponential series). options : Options; solver options class. ntraj is taken as a two-element list because; the mc correlator calls mcsolve() recursively; by default,; ntraj=[20, 100]. mc_corr_eps prevents divide-by-zero errors in; the mc correlator; by default, mc_corr_eps=1e-10. Returns:; corr_mat : array; An 2-dimensional array (matrix) of correlation values for the times; specified by tlist (first index) and taulist (second index). If; tlist is None, then a 1-dimensional array of correlation values; is returned instead. References; See, Gardiner, Quantum Noise, Section 5.2. correlation_ss(H, taulist, c_ops, a_op, b_op, solver='me', reverse=False, args={}, options=<qutip.solver.Options object>)[source]Â¶; Calculate the two-operator two-time correlation function:. \[\lim_{t \to \infty} \left<A(t+\tau)B(t)\right>\]; along one time axis (given steady-state initial conditions) using the; quantum regression theorem and the evolution solver indicated by the; solver parameter. Parameters:; H : Qobj; system Hamiltonian. taulist : array_like; list of times for \(\tau\). taulist must be positive and contain; the element 0. c_ops : list; list of collapse operators. a_op : Qobj; operator A. b_op : Qobj; operator B. reverse ",MatchSource.WIKI,docs/4.3/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/apidoc/functions.html
https://qutip.org/docs/4.3/apidoc/functions.html:83692,Availability,error,errors,83692,"=<qutip.solver.Options object>)[source]Â¶; Calculate the two-operator two-time correlation function:. \[\lim_{t \to \infty} \left<A(t+\tau)B(t)\right>\]; along one time axis (given steady-state initial conditions) using the; quantum regression theorem and the evolution solver indicated by the; solver parameter. Parameters:; H : Qobj; system Hamiltonian. taulist : array_like; list of times for \(\tau\). taulist must be positive and contain; the element 0. c_ops : list; list of collapse operators. a_op : Qobj; operator A. b_op : Qobj; operator B. reverse : bool; If True, calculate; \(\lim_{t \to \infty} \left<A(t)B(t+\tau)\right>\) instead of; \(\lim_{t \to \infty} \left<A(t+\tau)B(t)\right>\). solver : str; choice of solver (me for master-equation and; es for exponential series). options : Options; solver options class. ntraj is taken as a two-element list because; the mc correlator calls mcsolve() recursively; by default,; ntraj=[20, 100]. mc_corr_eps prevents divide-by-zero errors in; the mc correlator; by default, mc_corr_eps=1e-10. Returns:; corr_vec : array; An array of correlation values for the times specified by tlist. References; See, Gardiner, Quantum Noise, Section 5.2. correlation_2op_1t(H, state0, taulist, c_ops, a_op, b_op, solver='me', reverse=False, args={}, options=<qutip.solver.Options object>)[source]Â¶; Calculate the two-operator two-time correlation function:; \(\left<A(t+\tau)B(t)\right>\); along one time axis using the quantum regression theorem and the evolution; solver indicated by the solver parameter. Parameters:; H : Qobj; system Hamiltonian, may be time-dependent for solver choice of me or; mc. state0 : Qobj; Initial state density matrix \(\rho(t_0)\) or state vector; \(\psi(t_0)\). If âstate0â is âNoneâ, then the steady state will; be used as the initial state. The âsteady-stateâ is only implemented; for the me and es solvers. taulist : array_like; list of times for \(\tau\). taulist must be positive and contain; the element 0. c_ops : list",MatchSource.WIKI,docs/4.3/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/apidoc/functions.html
https://qutip.org/docs/4.3/apidoc/functions.html:85290,Availability,error,errors,85290,"be time-dependent for solver choice of me or; mc. state0 : Qobj; Initial state density matrix \(\rho(t_0)\) or state vector; \(\psi(t_0)\). If âstate0â is âNoneâ, then the steady state will; be used as the initial state. The âsteady-stateâ is only implemented; for the me and es solvers. taulist : array_like; list of times for \(\tau\). taulist must be positive and contain; the element 0. c_ops : list; list of collapse operators, may be time-dependent for solver choice of; me or mc. a_op : Qobj; operator A. b_op : Qobj; operator B. reverse : bool {False, True}; If True, calculate \(\left<A(t)B(t+\tau)\right>\) instead of; \(\left<A(t+\tau)B(t)\right>\). solver : str {âmeâ, âmcâ, âesâ}; choice of solver (me for master-equation, mc for Monte Carlo, and; es for exponential series). options : Options; Solver options class. ntraj is taken as a two-element list because; the mc correlator calls mcsolve() recursively; by default,; ntraj=[20, 100]. mc_corr_eps prevents divide-by-zero errors in; the mc correlator; by default, mc_corr_eps=1e-10. Returns:; corr_vec : ndarray; An array of correlation values for the times specified by tlist. References; See, Gardiner, Quantum Noise, Section 5.2. correlation_2op_2t(H, state0, tlist, taulist, c_ops, a_op, b_op, solver='me', reverse=False, args={}, options=<qutip.solver.Options object>)[source]Â¶; Calculate the two-operator two-time correlation function:; \(\left<A(t+\tau)B(t)\right>\); along two time axes using the quantum regression theorem and the; evolution solver indicated by the solver parameter. Parameters:; H : Qobj; system Hamiltonian, may be time-dependent for solver choice of me or; mc. state0 : Qobj; Initial state density matrix \(\rho_0\) or state vector; \(\psi_0\). If âstate0â is âNoneâ, then the steady state will; be used as the initial state. The âsteady-stateâ is only implemented; for the me and es solvers. tlist : array_like; list of times for \(t\). tlist must be positive and contain the; element 0. When taking stea",MatchSource.WIKI,docs/4.3/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/apidoc/functions.html
https://qutip.org/docs/4.3/apidoc/functions.html:87134,Availability,error,errors,87134,"only implemented; for the me and es solvers. tlist : array_like; list of times for \(t\). tlist must be positive and contain the; element 0. When taking steady-steady correlations only one tlist; value is necessary, i.e. when \(t \rightarrow \infty\); here; tlist is automatically set, ignoring user input. taulist : array_like; list of times for \(\tau\). taulist must be positive and contain; the element 0. c_ops : list; list of collapse operators, may be time-dependent for solver choice of; me or mc. a_op : Qobj; operator A. b_op : Qobj; operator B. reverse : bool {False, True}; If True, calculate \(\left<A(t)B(t+\tau)\right>\) instead of; \(\left<A(t+\tau)B(t)\right>\). solver : str; choice of solver (me for master-equation, mc for Monte Carlo, and; es for exponential series). options : Options; solver options class. ntraj is taken as a two-element list because; the mc correlator calls mcsolve() recursively; by default,; ntraj=[20, 100]. mc_corr_eps prevents divide-by-zero errors in; the mc correlator; by default, mc_corr_eps=1e-10. Returns:; corr_mat : ndarray; An 2-dimensional array (matrix) of correlation values for the times; specified by tlist (first index) and taulist (second index). If; tlist is None, then a 1-dimensional array of correlation values; is returned instead. References; See, Gardiner, Quantum Noise, Section 5.2. correlation_3op_1t(H, state0, taulist, c_ops, a_op, b_op, c_op, solver='me', args={}, options=<qutip.solver.Options object>)[source]Â¶; Calculate the three-operator two-time correlation function:; \(\left<A(t)B(t+\tau)C(t)\right>\); along one time axis using the quantum regression theorem and the; evolution solver indicated by the solver parameter.; Note: it is not possibly to calculate a physically meaningful correlation; of this form where \(\tau<0\). Parameters:; H : Qobj; system Hamiltonian, may be time-dependent for solver choice of me or; mc. rho0 : Qobj; Initial state density matrix \(\rho(t_0)\) or state vector; \(\psi(t_0)\). If â",MatchSource.WIKI,docs/4.3/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/apidoc/functions.html
https://qutip.org/docs/4.3/apidoc/functions.html:88873,Availability,error,errors,88873,"late a physically meaningful correlation; of this form where \(\tau<0\). Parameters:; H : Qobj; system Hamiltonian, may be time-dependent for solver choice of me or; mc. rho0 : Qobj; Initial state density matrix \(\rho(t_0)\) or state vector; \(\psi(t_0)\). If âstate0â is âNoneâ, then the steady state will; be used as the initial state. The âsteady-stateâ is only implemented; for the me and es solvers. taulist : array_like; list of times for \(\tau\). taulist must be positive and contain; the element 0. c_ops : list; list of collapse operators, may be time-dependent for solver choice of; me or mc. a_op : Qobj; operator A. b_op : Qobj; operator B. c_op : Qobj; operator C. solver : str; choice of solver (me for master-equation, mc for Monte Carlo, and; es for exponential series). options : Options; solver options class. ntraj is taken as a two-element list because; the mc correlator calls mcsolve() recursively; by default,; ntraj=[20, 100]. mc_corr_eps prevents divide-by-zero errors in; the mc correlator; by default, mc_corr_eps=1e-10. Returns:; corr_vec : array; An array of correlation values for the times specified by taulist. References; See, Gardiner, Quantum Noise, Section 5.2. correlation_3op_2t(H, state0, tlist, taulist, c_ops, a_op, b_op, c_op, solver='me', args={}, options=<qutip.solver.Options object>)[source]Â¶; Calculate the three-operator two-time correlation function:; \(\left<A(t)B(t+\tau)C(t)\right>\); along two time axes using the quantum regression theorem and the; evolution solver indicated by the solver parameter.; Note: it is not possibly to calculate a physically meaningful correlation; of this form where \(\tau<0\). Parameters:; H : Qobj; system Hamiltonian, may be time-dependent for solver choice of me or; mc. rho0 : Qobj; Initial state density matrix \(\rho_0\) or state vector; \(\psi_0\). If âstate0â is âNoneâ, then the steady state will; be used as the initial state. The âsteady-stateâ is only implemented; for the me and es solvers. tlist : ar",MatchSource.WIKI,docs/4.3/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/apidoc/functions.html
https://qutip.org/docs/4.3/apidoc/functions.html:90720,Availability,error,errors,90720,"state0â is âNoneâ, then the steady state will; be used as the initial state. The âsteady-stateâ is only implemented; for the me and es solvers. tlist : array_like; list of times for \(t\). tlist must be positive and contain the; element 0. When taking steady-steady correlations only one tlist; value is necessary, i.e. when \(t \rightarrow \infty\); here; tlist is automatically set, ignoring user input. taulist : array_like; list of times for \(\tau\). taulist must be positive and contain; the element 0. c_ops : list; list of collapse operators, may be time-dependent for solver choice of; me or mc. a_op : Qobj; operator A. b_op : Qobj; operator B. c_op : Qobj; operator C. solver : str; choice of solver (me for master-equation, mc for Monte Carlo, and; es for exponential series). options : Options; solver options class. ntraj is taken as a two-element list because; the mc correlator calls mcsolve() recursively; by default,; ntraj=[20, 100]. mc_corr_eps prevents divide-by-zero errors in; the mc correlator; by default, mc_corr_eps=1e-10. Returns:; corr_mat : array; An 2-dimensional array (matrix) of correlation values for the times; specified by tlist (first index) and taulist (second index). If; tlist is None, then a 1-dimensional array of correlation values; is returned instead. References; See, Gardiner, Quantum Noise, Section 5.2. correlation_4op_1t(H, state0, taulist, c_ops, a_op, b_op, c_op, d_op, solver='me', args={}, options=<qutip.solver.Options object>)[source]Â¶; Calculate the four-operator two-time correlation function:; \(\left<A(t)B(t+\tau)C(t+\tau)D(t)\right>\); along one time axis using the quantum regression theorem and the; evolution solver indicated by the solver parameter.; Note: it is not possibly to calculate a physically meaningful correlation; of this form where \(\tau<0\). Parameters:; H : Qobj; system Hamiltonian, may be time-dependent for solver choice of me or; mc. rho0 : Qobj; Initial state density matrix \(\rho(t_0)\) or state vector; \(\psi(",MatchSource.WIKI,docs/4.3/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/apidoc/functions.html
https://qutip.org/docs/4.3/apidoc/functions.html:92496,Availability,error,errors,92496,"ful correlation; of this form where \(\tau<0\). Parameters:; H : Qobj; system Hamiltonian, may be time-dependent for solver choice of me or; mc. rho0 : Qobj; Initial state density matrix \(\rho(t_0)\) or state vector; \(\psi(t_0)\). If âstate0â is âNoneâ, then the steady state will; be used as the initial state. The âsteady-stateâ is only implemented; for the me and es solvers. taulist : array_like; list of times for \(\tau\). taulist must be positive and contain; the element 0. c_ops : list; list of collapse operators, may be time-dependent for solver choice of; me or mc. a_op : Qobj; operator A. b_op : Qobj; operator B. c_op : Qobj; operator C. d_op : Qobj; operator D. solver : str; choice of solver (me for master-equation, mc for Monte Carlo, and; es for exponential series). options : Options; solver options class. ntraj is taken as a two-element list because; the mc correlator calls mcsolve() recursively; by default,; ntraj=[20, 100]. mc_corr_eps prevents divide-by-zero errors in; the mc correlator; by default, mc_corr_eps=1e-10. Returns:; corr_vec : array; An array of correlation values for the times specified by taulist. References; See, Gardiner, Quantum Noise, Section 5.2. Note; Deprecated in QuTiP 3.1; Use correlation_3op_1t() instead. correlation_4op_2t(H, state0, tlist, taulist, c_ops, a_op, b_op, c_op, d_op, solver='me', args={}, options=<qutip.solver.Options object>)[source]Â¶; Calculate the four-operator two-time correlation function:; \(\left<A(t)B(t+\tau)C(t+\tau)D(t)\right>\); along two time axes using the quantum regression theorem and the; evolution solver indicated by the solver parameter.; Note: it is not possibly to calculate a physically meaningful correlation; of this form where \(\tau<0\). Parameters:; H : Qobj; system Hamiltonian, may be time-dependent for solver choice of me or; mc. rho0 : Qobj; Initial state density matrix \(\rho_0\) or state vector; \(\psi_0\). If âstate0â is âNoneâ, then the steady state will; be used as the initial state",MatchSource.WIKI,docs/4.3/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/apidoc/functions.html
https://qutip.org/docs/4.3/apidoc/functions.html:94447,Availability,error,errors,94447,"he steady state will; be used as the initial state. The âsteady-stateâ is only implemented; for the me and es solvers. tlist : array_like; list of times for \(t\). tlist must be positive and contain the; element 0. When taking steady-steady correlations only one tlist; value is necessary, i.e. when \(t \rightarrow \infty\); here; tlist is automatically set, ignoring user input. taulist : array_like; list of times for \(\tau\). taulist must be positive and contain; the element 0. c_ops : list; list of collapse operators, may be time-dependent for solver choice of; me or mc. a_op : Qobj; operator A. b_op : Qobj; operator B. c_op : Qobj; operator C. d_op : Qobj; operator D. solver : str; choice of solver (me for master-equation, mc for Monte Carlo, and; es for exponential series). options : Options; solver options class. ntraj is taken as a two-element list because; the mc correlator calls mcsolve() recursively; by default,; ntraj=[20, 100]. mc_corr_eps prevents divide-by-zero errors in; the mc correlator; by default, mc_corr_eps=1e-10. Returns:; corr_mat : array; An 2-dimensional array (matrix) of correlation values for the times; specified by tlist (first index) and taulist (second index). If; tlist is None, then a 1-dimensional array of correlation values; is returned instead. References; See, Gardiner, Quantum Noise, Section 5.2. spectrum(H, wlist, c_ops, a_op, b_op, solver='es', use_pinv=False)[source]Â¶; Calculate the spectrum of the correlation function; \(\lim_{t \to \infty} \left<A(t+\tau)B(t)\right>\),; i.e., the Fourier transform of the correlation function:. \[S(\omega) = \int_{-\infty}^{\infty}; \lim_{t \to \infty} \left<A(t+\tau)B(t)\right>; e^{-i\omega\tau} d\tau.\]; using the solver indicated by the solver parameter. Note: this spectrum; is only defined for stationary statistics (uses steady state rho0). Parameters:; H : qutip.qobj; system Hamiltonian. wlist : array_like; list of frequencies for \(\omega\). c_ops : list; list of collapse operators. a_op :",MatchSource.WIKI,docs/4.3/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/apidoc/functions.html
https://qutip.org/docs/4.3/apidoc/functions.html:99393,Availability,error,errors,99393,"angle; \langle A^\dagger(0)A(0)\rangle}}\]; using the quantum regression theorem and the evolution solver indicated by; the solver parameter. Parameters:; H : Qobj; system Hamiltonian, may be time-dependent for solver choice of me or; mc. state0 : Qobj; Initial state density matrix \(\rho(t_0)\) or state vector; \(\psi(t_0)\). If âstate0â is âNoneâ, then the steady state will; be used as the initial state. The âsteady-stateâ is only implemented; for the me and es solvers. taulist : array_like; list of times for \(\tau\). taulist must be positive and contain; the element 0. c_ops : list; list of collapse operators, may be time-dependent for solver choice of; me or mc. a_op : Qobj; operator A. solver : str; choice of solver (me for master-equation and; es for exponential series). options : Options; solver options class. ntraj is taken as a two-element list because; the mc correlator calls mcsolve() recursively; by default,; ntraj=[20, 100]. mc_corr_eps prevents divide-by-zero errors in; the mc correlator; by default, mc_corr_eps=1e-10. Returns:; g1, G1 : tuple; The normalized and unnormalized second-order coherence function. coherence_function_g2(H, state0, taulist, c_ops, a_op, solver='me', args={}, options=<qutip.solver.Options object>)[source]Â¶; Calculate the normalized second-order quantum coherence function:. \[ g^{(2)}(\tau) =; \frac{\langle A^\dagger(0)A^\dagger(\tau)A(\tau)A(0)\rangle}; {\langle A^\dagger(\tau)A(\tau)\rangle; \langle A^\dagger(0)A(0)\rangle}\]; using the quantum regression theorem and the evolution solver indicated by; the solver parameter. Parameters:; H : Qobj; system Hamiltonian, may be time-dependent for solver choice of me or; mc. state0 : Qobj; Initial state density matrix \(\rho(t_0)\) or state vector; \(\psi(t_0)\). If âstate0â is âNoneâ, then the steady state will; be used as the initial state. The âsteady-stateâ is only implemented; for the me and es solvers. taulist : array_like; list of times for \(\tau\). taulist must be positive a",MatchSource.WIKI,docs/4.3/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/apidoc/functions.html
https://qutip.org/docs/4.3/apidoc/functions.html:100902,Availability,error,errors,100902," regression theorem and the evolution solver indicated by; the solver parameter. Parameters:; H : Qobj; system Hamiltonian, may be time-dependent for solver choice of me or; mc. state0 : Qobj; Initial state density matrix \(\rho(t_0)\) or state vector; \(\psi(t_0)\). If âstate0â is âNoneâ, then the steady state will; be used as the initial state. The âsteady-stateâ is only implemented; for the me and es solvers. taulist : array_like; list of times for \(\tau\). taulist must be positive and contain; the element 0. c_ops : list; list of collapse operators, may be time-dependent for solver choice of; me or mc. a_op : Qobj; operator A. args : dict; Dictionary of arguments to be passed to solver. solver : str; choice of solver (me for master-equation and; es for exponential series). options : Options; solver options class. ntraj is taken as a two-element list because; the mc correlator calls mcsolve() recursively; by default,; ntraj=[20, 100]. mc_corr_eps prevents divide-by-zero errors in; the mc correlator; by default, mc_corr_eps=1e-10. Returns:; g2, G2 : tuple; The normalized and unnormalized second-order coherence function. Steady-state SolversÂ¶; Module contains functions for solving for the steady state density matrix of; open quantum systems defined by a Liouvillian or Hamiltonian and a list of; collapse operators. steadystate(A, c_op_list=[], method='direct', solver=None, **kwargs)[source]Â¶; Calculates the steady state for quantum evolution subject to the; supplied Hamiltonian or Liouvillian operator and (if given a Hamiltonian) a; list of collapse operators.; If the user passes a Hamiltonian then it, along with the list of collapse; operators, will be converted into a Liouvillian operator in Lindblad form. Parameters:; A : qobj; A Hamiltonian or Liouvillian operator. c_op_list : list; A list of collapse operators. solver : str {None, âscipyâ, âmklâ}; Selects the sparse solver to use. Default is auto-select; based on the availability of the MKL library. method : st",MatchSource.WIKI,docs/4.3/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/apidoc/functions.html
https://qutip.org/docs/4.3/apidoc/functions.html:101870,Availability,avail,availability,101870,"c_corr_eps prevents divide-by-zero errors in; the mc correlator; by default, mc_corr_eps=1e-10. Returns:; g2, G2 : tuple; The normalized and unnormalized second-order coherence function. Steady-state SolversÂ¶; Module contains functions for solving for the steady state density matrix of; open quantum systems defined by a Liouvillian or Hamiltonian and a list of; collapse operators. steadystate(A, c_op_list=[], method='direct', solver=None, **kwargs)[source]Â¶; Calculates the steady state for quantum evolution subject to the; supplied Hamiltonian or Liouvillian operator and (if given a Hamiltonian) a; list of collapse operators.; If the user passes a Hamiltonian then it, along with the list of collapse; operators, will be converted into a Liouvillian operator in Lindblad form. Parameters:; A : qobj; A Hamiltonian or Liouvillian operator. c_op_list : list; A list of collapse operators. solver : str {None, âscipyâ, âmklâ}; Selects the sparse solver to use. Default is auto-select; based on the availability of the MKL library. method : str {âdirectâ, âeigenâ, âiterative-gmresâ,. âiterative-lgmresâ, âiterative-bicgstabâ, âsvdâ, âpowerâ,; âpower-gmresâ, âpower-lgmresâ, âpower-bicgstabâ}. Method for solving the underlying linear equation. Direct LU solver; âdirectâ (default), sparse eigenvalue problem âeigenâ,; iterative GMRES method âiterative-gmresâ, iterative LGMRES method; âiterative-lgmresâ, iterative BICGSTAB method âiterative-bicgstabâ,; SVD âsvdâ (dense), or inverse-power method âpowerâ. The iterative; power methods âpower-gmresâ, âpower-lgmresâ, âpower-bicgstabâ use; the same solvers as their direct counterparts. return_info : bool, optional, default = False; Return a dictionary of solver-specific infomation about the; solution and how it was obtained. sparse : bool, optional, default = True; Solve for the steady state using sparse algorithms. If set to False,; the underlying Liouvillian operator will be converted into a dense; matrix. Use only for âsmallerâ systems.",MatchSource.WIKI,docs/4.3/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/apidoc/functions.html
https://qutip.org/docs/4.3/apidoc/functions.html:104236,Availability,toler,tolerance,104236,"onditioner. weight : float, optional; Sets the size of the elements used for adding the unity trace condition; to the linear solvers. This is set to the average abs value of the; Liouvillian elements if not specified by the user. max_iter_refine : int {10}; MKL ONLY. Max. number of iterative refinements to perform. scaling_vectors : bool {True, False}; MKL ONLY. Scale matrix to unit norm columns and rows. weighted_matching : bool {True, False}; MKL ONLY. Use weighted matching to better condition diagonal. x0 : ndarray, optional; ITERATIVE ONLY. Initial guess for solution vector. maxiter : int, optional, default=1000; ITERATIVE ONLY. Maximum number of iterations to perform. tol : float, optional, default=1e-12; ITERATIVE ONLY. Tolerance used for terminating solver. mtol : float, optional, default=None; ITERATIVE âpowerâ methods ONLY. Tolerance for lu solve method.; If None given then max(0.1*tol, 1e-15) is used. matol : float, optional, default=1e-15; ITERATIVE ONLY. Absolute tolerance for lu solve method. permc_spec : str, optional, default=âCOLAMDâ; ITERATIVE ONLY. Column ordering used internally by superLU for the; âdirectâ LU decomposition method. Options include âCOLAMDâ and; âNATURALâ. If using RCM then this is set to âNATURALâ automatically; unless explicitly specified. use_precond : bool optional, default = False; ITERATIVE ONLY. Use an incomplete sparse LU decomposition as a; preconditioner for the âiterativeâ GMRES and BICG solvers.; Speeds up convergence time by orders of magnitude in many cases. M : {sparse matrix, dense matrix, LinearOperator}, optional; ITERATIVE ONLY. Preconditioner for A. The preconditioner should; approximate the inverse of A. Effective preconditioning can; dramatically improve the rate of convergence for iterative methods.; If no preconditioner is given and use_precond = True, then one; is generated automatically. fill_factor : float, optional, default = 100; ITERATIVE ONLY. Specifies the fill ratio upper bound (>=1) of the iLU; pre",MatchSource.WIKI,docs/4.3/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/apidoc/functions.html
https://qutip.org/docs/4.3/apidoc/functions.html:111362,Availability,error,error,111362,"TextProgressBar will be used. Returns:; a : qobj; Instance representing the propagator \(U(t)\). propagator_steadystate(U)[source]Â¶; Find the steady state for successive applications of the propagator; \(U\). Parameters:; U : qobj; Operator representing the propagator. Returns:; a : qobj; Instance representing the steady-state density matrix. Time-dependent problemsÂ¶. rhs_generate(H, c_ops, args={}, options=<qutip.solver.Options object>, name=None, cleanup=True)[source]Â¶; Generates the Cython functions needed for solving the dynamics of a; given system using the mesolve function inside a parfor loop. Parameters:; H : qobj; System Hamiltonian. c_ops : list; list of collapse operators. args : dict; Arguments for time-dependent Hamiltonian and collapse operator terms. options : Options; Instance of ODE solver options. name: str; Name of generated RHS. cleanup: bool; Whether the generated cython file should be automatically removed or; not. Notes; Using this function with any solver other than the mesolve function; will result in an error. rhs_clear()[source]Â¶; Resets the string-format time-dependent Hamiltonian parameters. Returns:; Nothing, just clears data from internal config module. Scattering in Quantum Optical SystemsÂ¶; Photon scattering in quantum optical systems; This module includes a collection of functions for numerically computing photon; scattering in driven arbitrary systems coupled to some configuration of output; waveguides. The implementation of these functions closely follows the; mathematical treatment given in K.A. Fischer, et. al., Scattering of Coherent; Pulses from Quantum Optical Systems (2017, arXiv:1710.02875). temporal_basis_vector(waveguide_emission_indices, n_time_bins)[source]Â¶; Generate a temporal basis vector for emissions at specified time bins into; specified waveguides. Parameters:; waveguide_emission_indices : list or tuple; List of indices where photon emission occurs for each waveguide,; e.g. [[t1_wg1], [t1_wg2, t2_wg2], [], [t1_wg4",MatchSource.WIKI,docs/4.3/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/apidoc/functions.html
https://qutip.org/docs/4.3/apidoc/functions.html:156602,Availability,error,error,156602,"unction that returns the; superoperator at a given time. rho0 : qutip.Qobj; Initial density matrix or state vector (ket). times : array_like; list of times \(t_n\) at which to compute \(\rho(t_n)\).; Must be uniformily spaced. e_ops : list of qutip.Qobj / callback function; single operator or list of operators for which to evaluate; expectation values. learningtimes : array_like; list of times \(t_k\) for which we have knowledge of the dynamical; maps \(E(t_k)\). tensors : array_like; optional list of precomputed tensors \(T_k\). kwargs : dictionary; Optional keyword arguments. See; qutip.nonmarkov.ttm.TTMSolverOptions. Returns:; output: :class:`qutip.solver.Result`; An instance of the class qutip.solver.Result. Optimal controlÂ¶; Wrapper functions that will manage the creation of the objects,; build the configuration, and execute the algorithm required to optimise; a set of ctrl pulses for a given (quantum) system.; The fidelity error is some measure of distance of the system evolution; from the given target evolution in the time allowed for the evolution.; The functions minimise this fidelity error wrt the piecewise control; amplitudes in the timeslots; There are currently two quantum control pulse optmisations algorithms; implemented in this library. There are accessible through the methods; in this module. Both the algorithms use the scipy.optimize methods; to minimise the fidelity error with respect to to variables that define; the pulse. GRAPEÂ¶; The default algorithm (as it was implemented here first) is GRAPE; GRadient Ascent Pulse Engineering [1][2]. It uses a gradient based method such; as BFGS to minimise the fidelity error. This makes convergence very quick; when an exact gradient can be calculated, but this limits the factors that can; taken into account in the fidelity. CRABÂ¶; The CRAB [3][4] algorithm was developed at the University of Ulm.; In full it is the Chopped RAndom Basis algorithm.; The main difference is that it reduces the number of optimisat",MatchSource.WIKI,docs/4.3/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/apidoc/functions.html
https://qutip.org/docs/4.3/apidoc/functions.html:156770,Availability,error,error,156770," to compute \(\rho(t_n)\).; Must be uniformily spaced. e_ops : list of qutip.Qobj / callback function; single operator or list of operators for which to evaluate; expectation values. learningtimes : array_like; list of times \(t_k\) for which we have knowledge of the dynamical; maps \(E(t_k)\). tensors : array_like; optional list of precomputed tensors \(T_k\). kwargs : dictionary; Optional keyword arguments. See; qutip.nonmarkov.ttm.TTMSolverOptions. Returns:; output: :class:`qutip.solver.Result`; An instance of the class qutip.solver.Result. Optimal controlÂ¶; Wrapper functions that will manage the creation of the objects,; build the configuration, and execute the algorithm required to optimise; a set of ctrl pulses for a given (quantum) system.; The fidelity error is some measure of distance of the system evolution; from the given target evolution in the time allowed for the evolution.; The functions minimise this fidelity error wrt the piecewise control; amplitudes in the timeslots; There are currently two quantum control pulse optmisations algorithms; implemented in this library. There are accessible through the methods; in this module. Both the algorithms use the scipy.optimize methods; to minimise the fidelity error with respect to to variables that define; the pulse. GRAPEÂ¶; The default algorithm (as it was implemented here first) is GRAPE; GRadient Ascent Pulse Engineering [1][2]. It uses a gradient based method such; as BFGS to minimise the fidelity error. This makes convergence very quick; when an exact gradient can be calculated, but this limits the factors that can; taken into account in the fidelity. CRABÂ¶; The CRAB [3][4] algorithm was developed at the University of Ulm.; In full it is the Chopped RAndom Basis algorithm.; The main difference is that it reduces the number of optimisation variables; by defining the control pulses by expansions of basis functions,; where the variables are the coefficients. Typically a Fourier series is chosen,; i.e. the v",MatchSource.WIKI,docs/4.3/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/apidoc/functions.html
https://qutip.org/docs/4.3/apidoc/functions.html:157067,Availability,error,error,157067,"we have knowledge of the dynamical; maps \(E(t_k)\). tensors : array_like; optional list of precomputed tensors \(T_k\). kwargs : dictionary; Optional keyword arguments. See; qutip.nonmarkov.ttm.TTMSolverOptions. Returns:; output: :class:`qutip.solver.Result`; An instance of the class qutip.solver.Result. Optimal controlÂ¶; Wrapper functions that will manage the creation of the objects,; build the configuration, and execute the algorithm required to optimise; a set of ctrl pulses for a given (quantum) system.; The fidelity error is some measure of distance of the system evolution; from the given target evolution in the time allowed for the evolution.; The functions minimise this fidelity error wrt the piecewise control; amplitudes in the timeslots; There are currently two quantum control pulse optmisations algorithms; implemented in this library. There are accessible through the methods; in this module. Both the algorithms use the scipy.optimize methods; to minimise the fidelity error with respect to to variables that define; the pulse. GRAPEÂ¶; The default algorithm (as it was implemented here first) is GRAPE; GRadient Ascent Pulse Engineering [1][2]. It uses a gradient based method such; as BFGS to minimise the fidelity error. This makes convergence very quick; when an exact gradient can be calculated, but this limits the factors that can; taken into account in the fidelity. CRABÂ¶; The CRAB [3][4] algorithm was developed at the University of Ulm.; In full it is the Chopped RAndom Basis algorithm.; The main difference is that it reduces the number of optimisation variables; by defining the control pulses by expansions of basis functions,; where the variables are the coefficients. Typically a Fourier series is chosen,; i.e. the variables are the Fourier coefficients.; Therefore it does not need to compute an explicit gradient.; By default it uses the Nelder-Mead method for fidelity error minimisation.; References. N Khaneja et. al.; Optimal control of coupled spin dyna",MatchSource.WIKI,docs/4.3/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/apidoc/functions.html
https://qutip.org/docs/4.3/apidoc/functions.html:157314,Availability,error,error,157314,"ions. Returns:; output: :class:`qutip.solver.Result`; An instance of the class qutip.solver.Result. Optimal controlÂ¶; Wrapper functions that will manage the creation of the objects,; build the configuration, and execute the algorithm required to optimise; a set of ctrl pulses for a given (quantum) system.; The fidelity error is some measure of distance of the system evolution; from the given target evolution in the time allowed for the evolution.; The functions minimise this fidelity error wrt the piecewise control; amplitudes in the timeslots; There are currently two quantum control pulse optmisations algorithms; implemented in this library. There are accessible through the methods; in this module. Both the algorithms use the scipy.optimize methods; to minimise the fidelity error with respect to to variables that define; the pulse. GRAPEÂ¶; The default algorithm (as it was implemented here first) is GRAPE; GRadient Ascent Pulse Engineering [1][2]. It uses a gradient based method such; as BFGS to minimise the fidelity error. This makes convergence very quick; when an exact gradient can be calculated, but this limits the factors that can; taken into account in the fidelity. CRABÂ¶; The CRAB [3][4] algorithm was developed at the University of Ulm.; In full it is the Chopped RAndom Basis algorithm.; The main difference is that it reduces the number of optimisation variables; by defining the control pulses by expansions of basis functions,; where the variables are the coefficients. Typically a Fourier series is chosen,; i.e. the variables are the Fourier coefficients.; Therefore it does not need to compute an explicit gradient.; By default it uses the Nelder-Mead method for fidelity error minimisation.; References. N Khaneja et. al.; Optimal control of coupled spin dynamics: Design of NMR pulse sequences; by gradient ascent algorithms. J. Magn. Reson. 172, 296â305 (2005).; Shai Machnes et.al; DYNAMO - Dynamic Framework for Quantum Optimal Control; arXiv.1011.4874; Doria, ",MatchSource.WIKI,docs/4.3/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/apidoc/functions.html
https://qutip.org/docs/4.3/apidoc/functions.html:157987,Availability,error,error,157987,"hods; in this module. Both the algorithms use the scipy.optimize methods; to minimise the fidelity error with respect to to variables that define; the pulse. GRAPEÂ¶; The default algorithm (as it was implemented here first) is GRAPE; GRadient Ascent Pulse Engineering [1][2]. It uses a gradient based method such; as BFGS to minimise the fidelity error. This makes convergence very quick; when an exact gradient can be calculated, but this limits the factors that can; taken into account in the fidelity. CRABÂ¶; The CRAB [3][4] algorithm was developed at the University of Ulm.; In full it is the Chopped RAndom Basis algorithm.; The main difference is that it reduces the number of optimisation variables; by defining the control pulses by expansions of basis functions,; where the variables are the coefficients. Typically a Fourier series is chosen,; i.e. the variables are the Fourier coefficients.; Therefore it does not need to compute an explicit gradient.; By default it uses the Nelder-Mead method for fidelity error minimisation.; References. N Khaneja et. al.; Optimal control of coupled spin dynamics: Design of NMR pulse sequences; by gradient ascent algorithms. J. Magn. Reson. 172, 296â305 (2005).; Shai Machnes et.al; DYNAMO - Dynamic Framework for Quantum Optimal Control; arXiv.1011.4874; Doria, P., Calarco, T. & Montangero, S.; Optimal Control Technique for Many-Body Quantum Dynamics.; Phys. Rev. Lett. 106, 1â4 (2011).; Caneva, T., Calarco, T. & Montangero, S.; Chopped random-basis quantum optimization.; Phys. Rev. A - At. Mol. Opt. Phys. 84, (2011). optimize_pulse(drift, ctrls, initial, target, num_tslots=None, evo_time=None, tau=None, amp_lbound=None, amp_ubound=None, fid_err_targ=1e-10, min_grad=1e-10, max_iter=500, max_wall_time=180, alg='GRAPE', alg_params=None, optim_params=None, optim_method='DEF', method_params=None, optim_alg=None, max_metric_corr=None, accuracy_factor=None, dyn_type='GEN_MAT', dyn_params=None, prop_type='DEF', prop_params=None, fid_type='DEF'",MatchSource.WIKI,docs/4.3/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/apidoc/functions.html
https://qutip.org/docs/4.3/apidoc/functions.html:159337,Availability,error,error,159337,"rXiv.1011.4874; Doria, P., Calarco, T. & Montangero, S.; Optimal Control Technique for Many-Body Quantum Dynamics.; Phys. Rev. Lett. 106, 1â4 (2011).; Caneva, T., Calarco, T. & Montangero, S.; Chopped random-basis quantum optimization.; Phys. Rev. A - At. Mol. Opt. Phys. 84, (2011). optimize_pulse(drift, ctrls, initial, target, num_tslots=None, evo_time=None, tau=None, amp_lbound=None, amp_ubound=None, fid_err_targ=1e-10, min_grad=1e-10, max_iter=500, max_wall_time=180, alg='GRAPE', alg_params=None, optim_params=None, optim_method='DEF', method_params=None, optim_alg=None, max_metric_corr=None, accuracy_factor=None, dyn_type='GEN_MAT', dyn_params=None, prop_type='DEF', prop_params=None, fid_type='DEF', fid_params=None, phase_option=None, fid_err_scale_factor=None, tslot_type='DEF', tslot_params=None, amp_update_mode=None, init_pulse_type='DEF', init_pulse_params=None, pulse_scaling=1.0, pulse_offset=0.0, ramping_pulse_type=None, ramping_pulse_params=None, log_level=0, out_file_ext=None, gen_stats=False)[source]Â¶; Optimise a control pulse to minimise the fidelity error.; The dynamics of the system in any given timeslot are governed; by the combined dynamics generator,; i.e. the sum of the drift+ctrl_amp[j]*ctrls[j]; The control pulse is an [n_ts, n_ctrls)] array of piecewise amplitudes; Starting from an intital (typically random) pulse,; a multivariable optimisation algorithm attempts to determines the; optimal values for the control pulse to minimise the fidelity error; The fidelity error is some measure of distance of the system evolution; from the given target evolution in the time allowed for the evolution. Parameters:; drift : Qobj or list of Qobj; the underlying dynamics generator of the system; can provide list (of length num_tslots) for time dependent drift. ctrls : List of Qobj or array like [num_tslots, evo_time]; a list of control dynamics generators. These are scaled by; the amplitudes to alter the overall dynamics; Array like imput can be provided for ti",MatchSource.WIKI,docs/4.3/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/apidoc/functions.html
https://qutip.org/docs/4.3/apidoc/functions.html:159746,Availability,error,error,159746,"targ=1e-10, min_grad=1e-10, max_iter=500, max_wall_time=180, alg='GRAPE', alg_params=None, optim_params=None, optim_method='DEF', method_params=None, optim_alg=None, max_metric_corr=None, accuracy_factor=None, dyn_type='GEN_MAT', dyn_params=None, prop_type='DEF', prop_params=None, fid_type='DEF', fid_params=None, phase_option=None, fid_err_scale_factor=None, tslot_type='DEF', tslot_params=None, amp_update_mode=None, init_pulse_type='DEF', init_pulse_params=None, pulse_scaling=1.0, pulse_offset=0.0, ramping_pulse_type=None, ramping_pulse_params=None, log_level=0, out_file_ext=None, gen_stats=False)[source]Â¶; Optimise a control pulse to minimise the fidelity error.; The dynamics of the system in any given timeslot are governed; by the combined dynamics generator,; i.e. the sum of the drift+ctrl_amp[j]*ctrls[j]; The control pulse is an [n_ts, n_ctrls)] array of piecewise amplitudes; Starting from an intital (typically random) pulse,; a multivariable optimisation algorithm attempts to determines the; optimal values for the control pulse to minimise the fidelity error; The fidelity error is some measure of distance of the system evolution; from the given target evolution in the time allowed for the evolution. Parameters:; drift : Qobj or list of Qobj; the underlying dynamics generator of the system; can provide list (of length num_tslots) for time dependent drift. ctrls : List of Qobj or array like [num_tslots, evo_time]; a list of control dynamics generators. These are scaled by; the amplitudes to alter the overall dynamics; Array like imput can be provided for time dependent control generators. initial : Qobj; starting point for the evolution.; Typically the identity matrix. target : Qobj; target transformation, e.g. gate or state, for the time evolution. num_tslots : integer or None; number of timeslots.; None implies that timeslots will be given in the tau array. evo_time : float or None; total time for the evolution; None implies that timeslots will be given in the ",MatchSource.WIKI,docs/4.3/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/apidoc/functions.html
https://qutip.org/docs/4.3/apidoc/functions.html:159766,Availability,error,error,159766,"targ=1e-10, min_grad=1e-10, max_iter=500, max_wall_time=180, alg='GRAPE', alg_params=None, optim_params=None, optim_method='DEF', method_params=None, optim_alg=None, max_metric_corr=None, accuracy_factor=None, dyn_type='GEN_MAT', dyn_params=None, prop_type='DEF', prop_params=None, fid_type='DEF', fid_params=None, phase_option=None, fid_err_scale_factor=None, tslot_type='DEF', tslot_params=None, amp_update_mode=None, init_pulse_type='DEF', init_pulse_params=None, pulse_scaling=1.0, pulse_offset=0.0, ramping_pulse_type=None, ramping_pulse_params=None, log_level=0, out_file_ext=None, gen_stats=False)[source]Â¶; Optimise a control pulse to minimise the fidelity error.; The dynamics of the system in any given timeslot are governed; by the combined dynamics generator,; i.e. the sum of the drift+ctrl_amp[j]*ctrls[j]; The control pulse is an [n_ts, n_ctrls)] array of piecewise amplitudes; Starting from an intital (typically random) pulse,; a multivariable optimisation algorithm attempts to determines the; optimal values for the control pulse to minimise the fidelity error; The fidelity error is some measure of distance of the system evolution; from the given target evolution in the time allowed for the evolution. Parameters:; drift : Qobj or list of Qobj; the underlying dynamics generator of the system; can provide list (of length num_tslots) for time dependent drift. ctrls : List of Qobj or array like [num_tslots, evo_time]; a list of control dynamics generators. These are scaled by; the amplitudes to alter the overall dynamics; Array like imput can be provided for time dependent control generators. initial : Qobj; starting point for the evolution.; Typically the identity matrix. target : Qobj; target transformation, e.g. gate or state, for the time evolution. num_tslots : integer or None; number of timeslots.; None implies that timeslots will be given in the tau array. evo_time : float or None; total time for the evolution; None implies that timeslots will be given in the ",MatchSource.WIKI,docs/4.3/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/apidoc/functions.html
https://qutip.org/docs/4.3/apidoc/functions.html:161283,Availability,error,error,161283,"ntrol generators. initial : Qobj; starting point for the evolution.; Typically the identity matrix. target : Qobj; target transformation, e.g. gate or state, for the time evolution. num_tslots : integer or None; number of timeslots.; None implies that timeslots will be given in the tau array. evo_time : float or None; total time for the evolution; None implies that timeslots will be given in the tau array. tau : array[num_tslots] of floats or None; durations for the timeslots.; if this is given then num_tslots and evo_time are dervived; from it; None implies that timeslot durations will be equal and; calculated as evo_time/num_tslots. amp_lbound : float or list of floats; lower boundaries for the control amplitudes; Can be a scalar value applied to all controls; or a list of bounds for each control. amp_ubound : float or list of floats; upper boundaries for the control amplitudes; Can be a scalar value applied to all controls; or a list of bounds for each control. fid_err_targ : float; Fidelity error target. Pulse optimisation will; terminate when the fidelity error falls below this value. mim_grad : float; Minimum gradient. When the sum of the squares of the; gradients wrt to the control amplitudes falls below this; value, the optimisation terminates, assuming local minima. max_iter : integer; Maximum number of iterations of the optimisation algorithm. max_wall_time : float; Maximum allowed elapsed time for the optimisation algorithm. alg : string; Algorithm to use in pulse optimisation.; Options are:. âGRAPEâ (default) - GRadient Ascent Pulse Engineering; âCRABâ - Chopped RAndom Basis. alg_params : Dictionary; options that are specific to the algorithm see above. optim_params : Dictionary; The key value pairs are the attribute name and value; used to set attribute values; Note: attributes are created if they do not exist already,; and are overwritten if they do.; Note: method_params are applied afterwards and so may override these. optim_method : string; a scipy.op",MatchSource.WIKI,docs/4.3/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/apidoc/functions.html
https://qutip.org/docs/4.3/apidoc/functions.html:161350,Availability,error,error,161350,"on.; Typically the identity matrix. target : Qobj; target transformation, e.g. gate or state, for the time evolution. num_tslots : integer or None; number of timeslots.; None implies that timeslots will be given in the tau array. evo_time : float or None; total time for the evolution; None implies that timeslots will be given in the tau array. tau : array[num_tslots] of floats or None; durations for the timeslots.; if this is given then num_tslots and evo_time are dervived; from it; None implies that timeslot durations will be equal and; calculated as evo_time/num_tslots. amp_lbound : float or list of floats; lower boundaries for the control amplitudes; Can be a scalar value applied to all controls; or a list of bounds for each control. amp_ubound : float or list of floats; upper boundaries for the control amplitudes; Can be a scalar value applied to all controls; or a list of bounds for each control. fid_err_targ : float; Fidelity error target. Pulse optimisation will; terminate when the fidelity error falls below this value. mim_grad : float; Minimum gradient. When the sum of the squares of the; gradients wrt to the control amplitudes falls below this; value, the optimisation terminates, assuming local minima. max_iter : integer; Maximum number of iterations of the optimisation algorithm. max_wall_time : float; Maximum allowed elapsed time for the optimisation algorithm. alg : string; Algorithm to use in pulse optimisation.; Options are:. âGRAPEâ (default) - GRadient Ascent Pulse Engineering; âCRABâ - Chopped RAndom Basis. alg_params : Dictionary; options that are specific to the algorithm see above. optim_params : Dictionary; The key value pairs are the attribute name and value; used to set attribute values; Note: attributes are created if they do not exist already,; and are overwritten if they do.; Note: method_params are applied afterwards and so may override these. optim_method : string; a scipy.optimize.minimize method that will be used to optimise; the pulse ",MatchSource.WIKI,docs/4.3/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/apidoc/functions.html
https://qutip.org/docs/4.3/apidoc/functions.html:162359,Availability,error,error,162359,"his value. mim_grad : float; Minimum gradient. When the sum of the squares of the; gradients wrt to the control amplitudes falls below this; value, the optimisation terminates, assuming local minima. max_iter : integer; Maximum number of iterations of the optimisation algorithm. max_wall_time : float; Maximum allowed elapsed time for the optimisation algorithm. alg : string; Algorithm to use in pulse optimisation.; Options are:. âGRAPEâ (default) - GRadient Ascent Pulse Engineering; âCRABâ - Chopped RAndom Basis. alg_params : Dictionary; options that are specific to the algorithm see above. optim_params : Dictionary; The key value pairs are the attribute name and value; used to set attribute values; Note: attributes are created if they do not exist already,; and are overwritten if they do.; Note: method_params are applied afterwards and so may override these. optim_method : string; a scipy.optimize.minimize method that will be used to optimise; the pulse for minimum fidelity error; Note that FMIN, FMIN_BFGS & FMIN_L_BFGS_B will all result; in calling these specific scipy.optimize methods; Note the LBFGSB is equivalent to FMIN_L_BFGS_B for backwards; capatibility reasons.; Supplying DEF will given alg dependent result:. GRAPE - Default optim_method is FMIN_L_BFGS_B; CRAB - Default optim_method is FMIN. method_params : dict; Parameters for the optim_method.; Note that where there is an attribute of the; Optimizer object or the termination_conditions matching the key; that attribute. Otherwise, and in some case also,; they are assumed to be method_options; for the scipy.optimize.minimize method. optim_alg : string; Deprecated. Use optim_method. max_metric_corr : integer; Deprecated. Use method_params instead. accuracy_factor : float; Deprecated. Use method_params instead. dyn_type : string; Dynamics type, i.e. the type of matrix used to describe; the dynamics. Options are UNIT, GEN_MAT, SYMPL; (see Dynamics classes for details). dyn_params : dict; Parameters for the Dy",MatchSource.WIKI,docs/4.3/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/apidoc/functions.html
https://qutip.org/docs/4.3/apidoc/functions.html:163969,Availability,error,error,163969,"rr : integer; Deprecated. Use method_params instead. accuracy_factor : float; Deprecated. Use method_params instead. dyn_type : string; Dynamics type, i.e. the type of matrix used to describe; the dynamics. Options are UNIT, GEN_MAT, SYMPL; (see Dynamics classes for details). dyn_params : dict; Parameters for the Dynamics object; The key value pairs are assumed to be attribute name value pairs; They applied after the object is created. prop_type : string; Propagator type i.e. the method used to calculate the; propagtors and propagtor gradient for each timeslot; options are DEF, APPROX, DIAG, FRECHET, AUG_MAT; DEF will use the default for the specific dyn_type; (see PropagatorComputer classes for details). prop_params : dict; Parameters for the PropagatorComputer object; The key value pairs are assumed to be attribute name value pairs; They applied after the object is created. fid_type : string; Fidelity error (and fidelity error gradient) computation method; Options are DEF, UNIT, TRACEDIFF, TD_APPROX; DEF will use the default for the specific dyn_type; (See FidelityComputer classes for details). fid_params : dict; Parameters for the FidelityComputer object; The key value pairs are assumed to be attribute name value pairs; They applied after the object is created. phase_option : string; Deprecated. Pass in fid_params instead. fid_err_scale_factor : float; Deprecated. Use scale_factor key in fid_params instead. tslot_type : string; Method for computing the dynamics generators, propagators and; evolution in the timeslots.; Options: DEF, UPDATE_ALL, DYNAMIC; UPDATE_ALL is the only one that currently works; (See TimeslotComputer classes for details). tslot_params : dict; Parameters for the TimeslotComputer object; The key value pairs are assumed to be attribute name value pairs; They applied after the object is created. amp_update_mode : string; Deprecated. Use tslot_type instead. init_pulse_type : string; type / shape of pulse(s) used to initialise the; the control ampl",MatchSource.WIKI,docs/4.3/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/apidoc/functions.html
https://qutip.org/docs/4.3/apidoc/functions.html:163989,Availability,error,error,163989,"rr : integer; Deprecated. Use method_params instead. accuracy_factor : float; Deprecated. Use method_params instead. dyn_type : string; Dynamics type, i.e. the type of matrix used to describe; the dynamics. Options are UNIT, GEN_MAT, SYMPL; (see Dynamics classes for details). dyn_params : dict; Parameters for the Dynamics object; The key value pairs are assumed to be attribute name value pairs; They applied after the object is created. prop_type : string; Propagator type i.e. the method used to calculate the; propagtors and propagtor gradient for each timeslot; options are DEF, APPROX, DIAG, FRECHET, AUG_MAT; DEF will use the default for the specific dyn_type; (see PropagatorComputer classes for details). prop_params : dict; Parameters for the PropagatorComputer object; The key value pairs are assumed to be attribute name value pairs; They applied after the object is created. fid_type : string; Fidelity error (and fidelity error gradient) computation method; Options are DEF, UNIT, TRACEDIFF, TD_APPROX; DEF will use the default for the specific dyn_type; (See FidelityComputer classes for details). fid_params : dict; Parameters for the FidelityComputer object; The key value pairs are assumed to be attribute name value pairs; They applied after the object is created. phase_option : string; Deprecated. Pass in fid_params instead. fid_err_scale_factor : float; Deprecated. Use scale_factor key in fid_params instead. tslot_type : string; Method for computing the dynamics generators, propagators and; evolution in the timeslots.; Options: DEF, UPDATE_ALL, DYNAMIC; UPDATE_ALL is the only one that currently works; (See TimeslotComputer classes for details). tslot_params : dict; Parameters for the TimeslotComputer object; The key value pairs are assumed to be attribute name value pairs; They applied after the object is created. amp_update_mode : string; Deprecated. Use tslot_type instead. init_pulse_type : string; type / shape of pulse(s) used to initialise the; the control ampl",MatchSource.WIKI,docs/4.3/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/apidoc/functions.html
https://qutip.org/docs/4.3/apidoc/functions.html:167156,Availability,error,error,167156,"med to be attribute name value pairs; They applied after the object is created. log_level : integer; level of messaging output from the logger.; Options are attributes of qutip.logging_utils,; in decreasing levels of messaging, are:; DEBUG_INTENSE, DEBUG_VERBOSE, DEBUG, INFO, WARN, ERROR, CRITICAL; Anything WARN or above is effectively âquietâ execution,; assuming everything runs as expected.; The default NOTSET implies that the level will be taken from; the QuTiP settings file, which by default is WARN. out_file_ext : string or None; files containing the initial and final control pulse; amplitudes are saved to the current directory.; The default name will be postfixed with this extension; Setting this to None will suppress the output of files. gen_stats : boolean; if set to True then statistics for the optimisation; run will be generated - accessible through attributes; of the stats object. Returns:; opt : OptimResult; Returns instance of OptimResult, which has attributes giving the; reason for termination, final fidelity error, final evolution; final amplitudes, statistics etc. optimize_pulse_unitary(H_d, H_c, U_0, U_targ, num_tslots=None, evo_time=None, tau=None, amp_lbound=None, amp_ubound=None, fid_err_targ=1e-10, min_grad=1e-10, max_iter=500, max_wall_time=180, alg='GRAPE', alg_params=None, optim_params=None, optim_method='DEF', method_params=None, optim_alg=None, max_metric_corr=None, accuracy_factor=None, phase_option='PSU', dyn_params=None, prop_params=None, fid_params=None, tslot_type='DEF', tslot_params=None, amp_update_mode=None, init_pulse_type='DEF', init_pulse_params=None, pulse_scaling=1.0, pulse_offset=0.0, ramping_pulse_type=None, ramping_pulse_params=None, log_level=0, out_file_ext=None, gen_stats=False)[source]Â¶; Optimise a control pulse to minimise the fidelity error, assuming that; the dynamics of the system are generated by unitary operators.; This function is simply a wrapper for optimize_pulse, where the; appropriate options for unitary dyna",MatchSource.WIKI,docs/4.3/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/apidoc/functions.html
https://qutip.org/docs/4.3/apidoc/functions.html:167930,Availability,error,error,167930,"n; if set to True then statistics for the optimisation; run will be generated - accessible through attributes; of the stats object. Returns:; opt : OptimResult; Returns instance of OptimResult, which has attributes giving the; reason for termination, final fidelity error, final evolution; final amplitudes, statistics etc. optimize_pulse_unitary(H_d, H_c, U_0, U_targ, num_tslots=None, evo_time=None, tau=None, amp_lbound=None, amp_ubound=None, fid_err_targ=1e-10, min_grad=1e-10, max_iter=500, max_wall_time=180, alg='GRAPE', alg_params=None, optim_params=None, optim_method='DEF', method_params=None, optim_alg=None, max_metric_corr=None, accuracy_factor=None, phase_option='PSU', dyn_params=None, prop_params=None, fid_params=None, tslot_type='DEF', tslot_params=None, amp_update_mode=None, init_pulse_type='DEF', init_pulse_params=None, pulse_scaling=1.0, pulse_offset=0.0, ramping_pulse_type=None, ramping_pulse_params=None, log_level=0, out_file_ext=None, gen_stats=False)[source]Â¶; Optimise a control pulse to minimise the fidelity error, assuming that; the dynamics of the system are generated by unitary operators.; This function is simply a wrapper for optimize_pulse, where the; appropriate options for unitary dynamics are chosen and the parameter; names are in the format familiar to unitary dynamics; The dynamics of the system in any given timeslot are governed; by the combined Hamiltonian,; i.e. the sum of the H_d + ctrl_amp[j]*H_c[j]; The control pulse is an [n_ts, n_ctrls] array of piecewise amplitudes; Starting from an intital (typically random) pulse,; a multivariable optimisation algorithm attempts to determines the; optimal values for the control pulse to minimise the fidelity error; The maximum fidelity for a unitary system is 1, i.e. when the; time evolution resulting from the pulse is equivalent to the target.; And therefore the fidelity error is 1 - fidelity. Parameters:; H_d : Qobj or list of Qobj; Drift (aka system) the underlying Hamiltonian of the system; c",MatchSource.WIKI,docs/4.3/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/apidoc/functions.html
https://qutip.org/docs/4.3/apidoc/functions.html:168597,Availability,error,error,168597,"od_params=None, optim_alg=None, max_metric_corr=None, accuracy_factor=None, phase_option='PSU', dyn_params=None, prop_params=None, fid_params=None, tslot_type='DEF', tslot_params=None, amp_update_mode=None, init_pulse_type='DEF', init_pulse_params=None, pulse_scaling=1.0, pulse_offset=0.0, ramping_pulse_type=None, ramping_pulse_params=None, log_level=0, out_file_ext=None, gen_stats=False)[source]Â¶; Optimise a control pulse to minimise the fidelity error, assuming that; the dynamics of the system are generated by unitary operators.; This function is simply a wrapper for optimize_pulse, where the; appropriate options for unitary dynamics are chosen and the parameter; names are in the format familiar to unitary dynamics; The dynamics of the system in any given timeslot are governed; by the combined Hamiltonian,; i.e. the sum of the H_d + ctrl_amp[j]*H_c[j]; The control pulse is an [n_ts, n_ctrls] array of piecewise amplitudes; Starting from an intital (typically random) pulse,; a multivariable optimisation algorithm attempts to determines the; optimal values for the control pulse to minimise the fidelity error; The maximum fidelity for a unitary system is 1, i.e. when the; time evolution resulting from the pulse is equivalent to the target.; And therefore the fidelity error is 1 - fidelity. Parameters:; H_d : Qobj or list of Qobj; Drift (aka system) the underlying Hamiltonian of the system; can provide list (of length num_tslots) for time dependent drift. H_c : List of Qobj or array like [num_tslots, evo_time]; a list of control Hamiltonians. These are scaled by; the amplitudes to alter the overall dynamics; Array like imput can be provided for time dependent control generators. U_0 : Qobj; starting point for the evolution.; Typically the identity matrix. U_targ : Qobj; target transformation, e.g. gate or state, for the time evolution. num_tslots : integer or None; number of timeslots.; None implies that timeslots will be given in the tau array. evo_time : float or None",MatchSource.WIKI,docs/4.3/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/apidoc/functions.html
https://qutip.org/docs/4.3/apidoc/functions.html:168764,Availability,error,error,168764,"set=0.0, ramping_pulse_type=None, ramping_pulse_params=None, log_level=0, out_file_ext=None, gen_stats=False)[source]Â¶; Optimise a control pulse to minimise the fidelity error, assuming that; the dynamics of the system are generated by unitary operators.; This function is simply a wrapper for optimize_pulse, where the; appropriate options for unitary dynamics are chosen and the parameter; names are in the format familiar to unitary dynamics; The dynamics of the system in any given timeslot are governed; by the combined Hamiltonian,; i.e. the sum of the H_d + ctrl_amp[j]*H_c[j]; The control pulse is an [n_ts, n_ctrls] array of piecewise amplitudes; Starting from an intital (typically random) pulse,; a multivariable optimisation algorithm attempts to determines the; optimal values for the control pulse to minimise the fidelity error; The maximum fidelity for a unitary system is 1, i.e. when the; time evolution resulting from the pulse is equivalent to the target.; And therefore the fidelity error is 1 - fidelity. Parameters:; H_d : Qobj or list of Qobj; Drift (aka system) the underlying Hamiltonian of the system; can provide list (of length num_tslots) for time dependent drift. H_c : List of Qobj or array like [num_tslots, evo_time]; a list of control Hamiltonians. These are scaled by; the amplitudes to alter the overall dynamics; Array like imput can be provided for time dependent control generators. U_0 : Qobj; starting point for the evolution.; Typically the identity matrix. U_targ : Qobj; target transformation, e.g. gate or state, for the time evolution. num_tslots : integer or None; number of timeslots.; None implies that timeslots will be given in the tau array. evo_time : float or None; total time for the evolution; None implies that timeslots will be given in the tau array. tau : array[num_tslots] of floats or None; durations for the timeslots.; if this is given then num_tslots and evo_time are dervived; from it; None implies that timeslot durations will be equ",MatchSource.WIKI,docs/4.3/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/apidoc/functions.html
https://qutip.org/docs/4.3/apidoc/functions.html:170171,Availability,error,error,170171,"t control generators. U_0 : Qobj; starting point for the evolution.; Typically the identity matrix. U_targ : Qobj; target transformation, e.g. gate or state, for the time evolution. num_tslots : integer or None; number of timeslots.; None implies that timeslots will be given in the tau array. evo_time : float or None; total time for the evolution; None implies that timeslots will be given in the tau array. tau : array[num_tslots] of floats or None; durations for the timeslots.; if this is given then num_tslots and evo_time are dervived; from it; None implies that timeslot durations will be equal and; calculated as evo_time/num_tslots. amp_lbound : float or list of floats; lower boundaries for the control amplitudes; Can be a scalar value applied to all controls; or a list of bounds for each control. amp_ubound : float or list of floats; upper boundaries for the control amplitudes; Can be a scalar value applied to all controls; or a list of bounds for each control. fid_err_targ : float; Fidelity error target. Pulse optimisation will; terminate when the fidelity error falls below this value. mim_grad : float; Minimum gradient. When the sum of the squares of the; gradients wrt to the control amplitudes falls below this; value, the optimisation terminates, assuming local minima. max_iter : integer; Maximum number of iterations of the optimisation algorithm. max_wall_time : float; Maximum allowed elapsed time for the optimisation algorithm. alg : string; Algorithm to use in pulse optimisation.; Options are:. âGRAPEâ (default) - GRadient Ascent Pulse Engineering; âCRABâ - Chopped RAndom Basis. alg_params : Dictionary; options that are specific to the algorithm see above. optim_params : Dictionary; The key value pairs are the attribute name and value; used to set attribute values; Note: attributes are created if they do not exist already,; and are overwritten if they do.; Note: method_params are applied afterwards and so may override these. optim_method : string; a scipy.op",MatchSource.WIKI,docs/4.3/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/apidoc/functions.html
https://qutip.org/docs/4.3/apidoc/functions.html:170238,Availability,error,error,170238,"on.; Typically the identity matrix. U_targ : Qobj; target transformation, e.g. gate or state, for the time evolution. num_tslots : integer or None; number of timeslots.; None implies that timeslots will be given in the tau array. evo_time : float or None; total time for the evolution; None implies that timeslots will be given in the tau array. tau : array[num_tslots] of floats or None; durations for the timeslots.; if this is given then num_tslots and evo_time are dervived; from it; None implies that timeslot durations will be equal and; calculated as evo_time/num_tslots. amp_lbound : float or list of floats; lower boundaries for the control amplitudes; Can be a scalar value applied to all controls; or a list of bounds for each control. amp_ubound : float or list of floats; upper boundaries for the control amplitudes; Can be a scalar value applied to all controls; or a list of bounds for each control. fid_err_targ : float; Fidelity error target. Pulse optimisation will; terminate when the fidelity error falls below this value. mim_grad : float; Minimum gradient. When the sum of the squares of the; gradients wrt to the control amplitudes falls below this; value, the optimisation terminates, assuming local minima. max_iter : integer; Maximum number of iterations of the optimisation algorithm. max_wall_time : float; Maximum allowed elapsed time for the optimisation algorithm. alg : string; Algorithm to use in pulse optimisation.; Options are:. âGRAPEâ (default) - GRadient Ascent Pulse Engineering; âCRABâ - Chopped RAndom Basis. alg_params : Dictionary; options that are specific to the algorithm see above. optim_params : Dictionary; The key value pairs are the attribute name and value; used to set attribute values; Note: attributes are created if they do not exist already,; and are overwritten if they do.; Note: method_params are applied afterwards and so may override these. optim_method : string; a scipy.optimize.minimize method that will be used to optimise; the pulse ",MatchSource.WIKI,docs/4.3/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/apidoc/functions.html
https://qutip.org/docs/4.3/apidoc/functions.html:171247,Availability,error,error,171247,"his value. mim_grad : float; Minimum gradient. When the sum of the squares of the; gradients wrt to the control amplitudes falls below this; value, the optimisation terminates, assuming local minima. max_iter : integer; Maximum number of iterations of the optimisation algorithm. max_wall_time : float; Maximum allowed elapsed time for the optimisation algorithm. alg : string; Algorithm to use in pulse optimisation.; Options are:. âGRAPEâ (default) - GRadient Ascent Pulse Engineering; âCRABâ - Chopped RAndom Basis. alg_params : Dictionary; options that are specific to the algorithm see above. optim_params : Dictionary; The key value pairs are the attribute name and value; used to set attribute values; Note: attributes are created if they do not exist already,; and are overwritten if they do.; Note: method_params are applied afterwards and so may override these. optim_method : string; a scipy.optimize.minimize method that will be used to optimise; the pulse for minimum fidelity error; Note that FMIN, FMIN_BFGS & FMIN_L_BFGS_B will all result; in calling these specific scipy.optimize methods; Note the LBFGSB is equivalent to FMIN_L_BFGS_B for backwards; capatibility reasons.; Supplying DEF will given alg dependent result:. GRAPE - Default optim_method is FMIN_L_BFGS_B; CRAB - Default optim_method is FMIN. method_params : dict; Parameters for the optim_method.; Note that where there is an attribute of the; Optimizer object or the termination_conditions matching the key; that attribute. Otherwise, and in some case also,; they are assumed to be method_options; for the scipy.optimize.minimize method. optim_alg : string; Deprecated. Use optim_method. max_metric_corr : integer; Deprecated. Use method_params instead. accuracy_factor : float; Deprecated. Use method_params instead. phase_option : string; determines how global phase is treated in fidelity; calculations (fid_type=âUNITâ only). Options:. PSU - global phase ignored; SU - global phase included. dyn_params : dict; Par",MatchSource.WIKI,docs/4.3/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/apidoc/functions.html
https://qutip.org/docs/4.3/apidoc/functions.html:175413,Availability,error,error,175413,"med to be attribute name value pairs; They applied after the object is created. log_level : integer; level of messaging output from the logger.; Options are attributes of qutip.logging_utils,; in decreasing levels of messaging, are:; DEBUG_INTENSE, DEBUG_VERBOSE, DEBUG, INFO, WARN, ERROR, CRITICAL; Anything WARN or above is effectively âquietâ execution,; assuming everything runs as expected.; The default NOTSET implies that the level will be taken from; the QuTiP settings file, which by default is WARN. out_file_ext : string or None; files containing the initial and final control pulse; amplitudes are saved to the current directory.; The default name will be postfixed with this extension; Setting this to None will suppress the output of files. gen_stats : boolean; if set to True then statistics for the optimisation; run will be generated - accessible through attributes; of the stats object. Returns:; opt : OptimResult; Returns instance of OptimResult, which has attributes giving the; reason for termination, final fidelity error, final evolution; final amplitudes, statistics etc. create_pulse_optimizer(drift, ctrls, initial, target, num_tslots=None, evo_time=None, tau=None, amp_lbound=None, amp_ubound=None, fid_err_targ=1e-10, min_grad=1e-10, max_iter=500, max_wall_time=180, alg='GRAPE', alg_params=None, optim_params=None, optim_method='DEF', method_params=None, optim_alg=None, max_metric_corr=None, accuracy_factor=None, dyn_type='GEN_MAT', dyn_params=None, prop_type='DEF', prop_params=None, fid_type='DEF', fid_params=None, phase_option=None, fid_err_scale_factor=None, tslot_type='DEF', tslot_params=None, amp_update_mode=None, init_pulse_type='DEF', init_pulse_params=None, pulse_scaling=1.0, pulse_offset=0.0, ramping_pulse_type=None, ramping_pulse_params=None, log_level=0, gen_stats=False)[source]Â¶; Generate the objects of the appropriate subclasses; required for the pulse optmisation based on the parameters given; Note this method may be preferable to calling optim",MatchSource.WIKI,docs/4.3/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/apidoc/functions.html
https://qutip.org/docs/4.3/apidoc/functions.html:177987,Availability,error,error,177987,"ntrol generators. initial : Qobj; starting point for the evolution.; Typically the identity matrix. target : Qobj; target transformation, e.g. gate or state, for the time evolution. num_tslots : integer or None; number of timeslots.; None implies that timeslots will be given in the tau array. evo_time : float or None; total time for the evolution; None implies that timeslots will be given in the tau array. tau : array[num_tslots] of floats or None; durations for the timeslots.; if this is given then num_tslots and evo_time are dervived; from it; None implies that timeslot durations will be equal and; calculated as evo_time/num_tslots. amp_lbound : float or list of floats; lower boundaries for the control amplitudes; Can be a scalar value applied to all controls; or a list of bounds for each control. amp_ubound : float or list of floats; upper boundaries for the control amplitudes; Can be a scalar value applied to all controls; or a list of bounds for each control. fid_err_targ : float; Fidelity error target. Pulse optimisation will; terminate when the fidelity error falls below this value. mim_grad : float; Minimum gradient. When the sum of the squares of the; gradients wrt to the control amplitudes falls below this; value, the optimisation terminates, assuming local minima. max_iter : integer; Maximum number of iterations of the optimisation algorithm. max_wall_time : float; Maximum allowed elapsed time for the optimisation algorithm. alg : string; Algorithm to use in pulse optimisation.; Options are:. âGRAPEâ (default) - GRadient Ascent Pulse Engineering; âCRABâ - Chopped RAndom Basis. alg_params : Dictionary; options that are specific to the algorithm see above. optim_params : Dictionary; The key value pairs are the attribute name and value; used to set attribute values; Note: attributes are created if they do not exist already,; and are overwritten if they do.; Note: method_params are applied afterwards and so may override these. optim_method : string; a scipy.op",MatchSource.WIKI,docs/4.3/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/apidoc/functions.html
https://qutip.org/docs/4.3/apidoc/functions.html:178054,Availability,error,error,178054,"on.; Typically the identity matrix. target : Qobj; target transformation, e.g. gate or state, for the time evolution. num_tslots : integer or None; number of timeslots.; None implies that timeslots will be given in the tau array. evo_time : float or None; total time for the evolution; None implies that timeslots will be given in the tau array. tau : array[num_tslots] of floats or None; durations for the timeslots.; if this is given then num_tslots and evo_time are dervived; from it; None implies that timeslot durations will be equal and; calculated as evo_time/num_tslots. amp_lbound : float or list of floats; lower boundaries for the control amplitudes; Can be a scalar value applied to all controls; or a list of bounds for each control. amp_ubound : float or list of floats; upper boundaries for the control amplitudes; Can be a scalar value applied to all controls; or a list of bounds for each control. fid_err_targ : float; Fidelity error target. Pulse optimisation will; terminate when the fidelity error falls below this value. mim_grad : float; Minimum gradient. When the sum of the squares of the; gradients wrt to the control amplitudes falls below this; value, the optimisation terminates, assuming local minima. max_iter : integer; Maximum number of iterations of the optimisation algorithm. max_wall_time : float; Maximum allowed elapsed time for the optimisation algorithm. alg : string; Algorithm to use in pulse optimisation.; Options are:. âGRAPEâ (default) - GRadient Ascent Pulse Engineering; âCRABâ - Chopped RAndom Basis. alg_params : Dictionary; options that are specific to the algorithm see above. optim_params : Dictionary; The key value pairs are the attribute name and value; used to set attribute values; Note: attributes are created if they do not exist already,; and are overwritten if they do.; Note: method_params are applied afterwards and so may override these. optim_method : string; a scipy.optimize.minimize method that will be used to optimise; the pulse ",MatchSource.WIKI,docs/4.3/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/apidoc/functions.html
https://qutip.org/docs/4.3/apidoc/functions.html:179063,Availability,error,error,179063,"his value. mim_grad : float; Minimum gradient. When the sum of the squares of the; gradients wrt to the control amplitudes falls below this; value, the optimisation terminates, assuming local minima. max_iter : integer; Maximum number of iterations of the optimisation algorithm. max_wall_time : float; Maximum allowed elapsed time for the optimisation algorithm. alg : string; Algorithm to use in pulse optimisation.; Options are:. âGRAPEâ (default) - GRadient Ascent Pulse Engineering; âCRABâ - Chopped RAndom Basis. alg_params : Dictionary; options that are specific to the algorithm see above. optim_params : Dictionary; The key value pairs are the attribute name and value; used to set attribute values; Note: attributes are created if they do not exist already,; and are overwritten if they do.; Note: method_params are applied afterwards and so may override these. optim_method : string; a scipy.optimize.minimize method that will be used to optimise; the pulse for minimum fidelity error; Note that FMIN, FMIN_BFGS & FMIN_L_BFGS_B will all result; in calling these specific scipy.optimize methods; Note the LBFGSB is equivalent to FMIN_L_BFGS_B for backwards; capatibility reasons.; Supplying DEF will given alg dependent result:. GRAPE - Default optim_method is FMIN_L_BFGS_B; CRAB - Default optim_method is Nelder-Mead. method_params : dict; Parameters for the optim_method.; Note that where there is an attribute of the; Optimizer object or the termination_conditions matching the key; that attribute. Otherwise, and in some case also,; they are assumed to be method_options; for the scipy.optimize.minimize method. optim_alg : string; Deprecated. Use optim_method. max_metric_corr : integer; Deprecated. Use method_params instead. accuracy_factor : float; Deprecated. Use method_params instead. dyn_type : string; Dynamics type, i.e. the type of matrix used to describe; the dynamics. Options are UNIT, GEN_MAT, SYMPL; (see Dynamics classes for details). dyn_params : dict; Parameters for",MatchSource.WIKI,docs/4.3/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/apidoc/functions.html
https://qutip.org/docs/4.3/apidoc/functions.html:180680,Availability,error,error,180680,"rr : integer; Deprecated. Use method_params instead. accuracy_factor : float; Deprecated. Use method_params instead. dyn_type : string; Dynamics type, i.e. the type of matrix used to describe; the dynamics. Options are UNIT, GEN_MAT, SYMPL; (see Dynamics classes for details). dyn_params : dict; Parameters for the Dynamics object; The key value pairs are assumed to be attribute name value pairs; They applied after the object is created. prop_type : string; Propagator type i.e. the method used to calculate the; propagtors and propagtor gradient for each timeslot; options are DEF, APPROX, DIAG, FRECHET, AUG_MAT; DEF will use the default for the specific dyn_type; (see PropagatorComputer classes for details). prop_params : dict; Parameters for the PropagatorComputer object; The key value pairs are assumed to be attribute name value pairs; They applied after the object is created. fid_type : string; Fidelity error (and fidelity error gradient) computation method; Options are DEF, UNIT, TRACEDIFF, TD_APPROX; DEF will use the default for the specific dyn_type; (See FidelityComputer classes for details). fid_params : dict; Parameters for the FidelityComputer object; The key value pairs are assumed to be attribute name value pairs; They applied after the object is created. phase_option : string; Deprecated. Pass in fid_params instead. fid_err_scale_factor : float; Deprecated. Use scale_factor key in fid_params instead. tslot_type : string; Method for computing the dynamics generators, propagators and; evolution in the timeslots.; Options: DEF, UPDATE_ALL, DYNAMIC; UPDATE_ALL is the only one that currently works; (See TimeslotComputer classes for details). tslot_params : dict; Parameters for the TimeslotComputer object; The key value pairs are assumed to be attribute name value pairs; They applied after the object is created. amp_update_mode : string; Deprecated. Use tslot_type instead. init_pulse_type : string; type / shape of pulse(s) used to initialise the; the control ampl",MatchSource.WIKI,docs/4.3/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/apidoc/functions.html
https://qutip.org/docs/4.3/apidoc/functions.html:180700,Availability,error,error,180700,"rr : integer; Deprecated. Use method_params instead. accuracy_factor : float; Deprecated. Use method_params instead. dyn_type : string; Dynamics type, i.e. the type of matrix used to describe; the dynamics. Options are UNIT, GEN_MAT, SYMPL; (see Dynamics classes for details). dyn_params : dict; Parameters for the Dynamics object; The key value pairs are assumed to be attribute name value pairs; They applied after the object is created. prop_type : string; Propagator type i.e. the method used to calculate the; propagtors and propagtor gradient for each timeslot; options are DEF, APPROX, DIAG, FRECHET, AUG_MAT; DEF will use the default for the specific dyn_type; (see PropagatorComputer classes for details). prop_params : dict; Parameters for the PropagatorComputer object; The key value pairs are assumed to be attribute name value pairs; They applied after the object is created. fid_type : string; Fidelity error (and fidelity error gradient) computation method; Options are DEF, UNIT, TRACEDIFF, TD_APPROX; DEF will use the default for the specific dyn_type; (See FidelityComputer classes for details). fid_params : dict; Parameters for the FidelityComputer object; The key value pairs are assumed to be attribute name value pairs; They applied after the object is created. phase_option : string; Deprecated. Pass in fid_params instead. fid_err_scale_factor : float; Deprecated. Use scale_factor key in fid_params instead. tslot_type : string; Method for computing the dynamics generators, propagators and; evolution in the timeslots.; Options: DEF, UPDATE_ALL, DYNAMIC; UPDATE_ALL is the only one that currently works; (See TimeslotComputer classes for details). tslot_params : dict; Parameters for the TimeslotComputer object; The key value pairs are assumed to be attribute name value pairs; They applied after the object is created. amp_update_mode : string; Deprecated. Use tslot_type instead. init_pulse_type : string; type / shape of pulse(s) used to initialise the; the control ampl",MatchSource.WIKI,docs/4.3/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/apidoc/functions.html
https://qutip.org/docs/4.3/apidoc/functions.html:184610,Availability,error,error,184610,"Instance of an Optimizer, through which the; Config, Dynamics, PulseGen, and TerminationConditions objects; can be accessed as attributes.; The PropagatorComputer, FidelityComputer and TimeslotComputer objects; can be accessed as attributes of the Dynamics object, e.g. optimizer.dynamics.fid_computer; The optimisation can be run through the optimizer.run_optimization. opt_pulse_crab(drift, ctrls, initial, target, num_tslots=None, evo_time=None, tau=None, amp_lbound=None, amp_ubound=None, fid_err_targ=1e-05, max_iter=500, max_wall_time=180, alg_params=None, num_coeffs=None, init_coeff_scaling=1.0, optim_params=None, optim_method='fmin', method_params=None, dyn_type='GEN_MAT', dyn_params=None, prop_type='DEF', prop_params=None, fid_type='DEF', fid_params=None, tslot_type='DEF', tslot_params=None, guess_pulse_type=None, guess_pulse_params=None, guess_pulse_scaling=1.0, guess_pulse_offset=0.0, guess_pulse_action='MODULATE', ramping_pulse_type=None, ramping_pulse_params=None, log_level=0, out_file_ext=None, gen_stats=False)[source]Â¶; Optimise a control pulse to minimise the fidelity error.; The dynamics of the system in any given timeslot are governed; by the combined dynamics generator,; i.e. the sum of the drift+ctrl_amp[j]*ctrls[j]; The control pulse is an [n_ts, n_ctrls] array of piecewise amplitudes.; The CRAB algorithm uses basis function coefficents as the variables to; optimise. It does NOT use any gradient function.; A multivariable optimisation algorithm attempts to determines the; optimal values for the control pulse to minimise the fidelity error; The fidelity error is some measure of distance of the system evolution; from the given target evolution in the time allowed for the evolution. Parameters:; drift : Qobj or list of Qobj; the underlying dynamics generator of the system; can provide list (of length num_tslots) for time dependent drift. ctrls : List of Qobj or array like [num_tslots, evo_time]; a list of control dynamics generators. These are scaled by; ",MatchSource.WIKI,docs/4.3/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/apidoc/functions.html
https://qutip.org/docs/4.3/apidoc/functions.html:185089,Availability,error,error,185089,"t_coeff_scaling=1.0, optim_params=None, optim_method='fmin', method_params=None, dyn_type='GEN_MAT', dyn_params=None, prop_type='DEF', prop_params=None, fid_type='DEF', fid_params=None, tslot_type='DEF', tslot_params=None, guess_pulse_type=None, guess_pulse_params=None, guess_pulse_scaling=1.0, guess_pulse_offset=0.0, guess_pulse_action='MODULATE', ramping_pulse_type=None, ramping_pulse_params=None, log_level=0, out_file_ext=None, gen_stats=False)[source]Â¶; Optimise a control pulse to minimise the fidelity error.; The dynamics of the system in any given timeslot are governed; by the combined dynamics generator,; i.e. the sum of the drift+ctrl_amp[j]*ctrls[j]; The control pulse is an [n_ts, n_ctrls] array of piecewise amplitudes.; The CRAB algorithm uses basis function coefficents as the variables to; optimise. It does NOT use any gradient function.; A multivariable optimisation algorithm attempts to determines the; optimal values for the control pulse to minimise the fidelity error; The fidelity error is some measure of distance of the system evolution; from the given target evolution in the time allowed for the evolution. Parameters:; drift : Qobj or list of Qobj; the underlying dynamics generator of the system; can provide list (of length num_tslots) for time dependent drift. ctrls : List of Qobj or array like [num_tslots, evo_time]; a list of control dynamics generators. These are scaled by; the amplitudes to alter the overall dynamics; Array like imput can be provided for time dependent control generators. initial : Qobj; starting point for the evolution.; Typically the identity matrix. target : Qobj; target transformation, e.g. gate or state, for the time evolution. num_tslots : integer or None; number of timeslots.; None implies that timeslots will be given in the tau array. evo_time : float or None; total time for the evolution; None implies that timeslots will be given in the tau array. tau : array[num_tslots] of floats or None; durations for the timeslots.;",MatchSource.WIKI,docs/4.3/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/apidoc/functions.html
https://qutip.org/docs/4.3/apidoc/functions.html:185109,Availability,error,error,185109,"t_coeff_scaling=1.0, optim_params=None, optim_method='fmin', method_params=None, dyn_type='GEN_MAT', dyn_params=None, prop_type='DEF', prop_params=None, fid_type='DEF', fid_params=None, tslot_type='DEF', tslot_params=None, guess_pulse_type=None, guess_pulse_params=None, guess_pulse_scaling=1.0, guess_pulse_offset=0.0, guess_pulse_action='MODULATE', ramping_pulse_type=None, ramping_pulse_params=None, log_level=0, out_file_ext=None, gen_stats=False)[source]Â¶; Optimise a control pulse to minimise the fidelity error.; The dynamics of the system in any given timeslot are governed; by the combined dynamics generator,; i.e. the sum of the drift+ctrl_amp[j]*ctrls[j]; The control pulse is an [n_ts, n_ctrls] array of piecewise amplitudes.; The CRAB algorithm uses basis function coefficents as the variables to; optimise. It does NOT use any gradient function.; A multivariable optimisation algorithm attempts to determines the; optimal values for the control pulse to minimise the fidelity error; The fidelity error is some measure of distance of the system evolution; from the given target evolution in the time allowed for the evolution. Parameters:; drift : Qobj or list of Qobj; the underlying dynamics generator of the system; can provide list (of length num_tslots) for time dependent drift. ctrls : List of Qobj or array like [num_tslots, evo_time]; a list of control dynamics generators. These are scaled by; the amplitudes to alter the overall dynamics; Array like imput can be provided for time dependent control generators. initial : Qobj; starting point for the evolution.; Typically the identity matrix. target : Qobj; target transformation, e.g. gate or state, for the time evolution. num_tslots : integer or None; number of timeslots.; None implies that timeslots will be given in the tau array. evo_time : float or None; total time for the evolution; None implies that timeslots will be given in the tau array. tau : array[num_tslots] of floats or None; durations for the timeslots.;",MatchSource.WIKI,docs/4.3/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/apidoc/functions.html
https://qutip.org/docs/4.3/apidoc/functions.html:186626,Availability,error,error,186626,"ntrol generators. initial : Qobj; starting point for the evolution.; Typically the identity matrix. target : Qobj; target transformation, e.g. gate or state, for the time evolution. num_tslots : integer or None; number of timeslots.; None implies that timeslots will be given in the tau array. evo_time : float or None; total time for the evolution; None implies that timeslots will be given in the tau array. tau : array[num_tslots] of floats or None; durations for the timeslots.; if this is given then num_tslots and evo_time are dervived; from it; None implies that timeslot durations will be equal and; calculated as evo_time/num_tslots. amp_lbound : float or list of floats; lower boundaries for the control amplitudes; Can be a scalar value applied to all controls; or a list of bounds for each control. amp_ubound : float or list of floats; upper boundaries for the control amplitudes; Can be a scalar value applied to all controls; or a list of bounds for each control. fid_err_targ : float; Fidelity error target. Pulse optimisation will; terminate when the fidelity error falls below this value. max_iter : integer; Maximum number of iterations of the optimisation algorithm. max_wall_time : float; Maximum allowed elapsed time for the optimisation algorithm. alg_params : Dictionary; options that are specific to the algorithm see above. optim_params : Dictionary; The key value pairs are the attribute name and value; used to set attribute values; Note: attributes are created if they do not exist already,; and are overwritten if they do.; Note: method_params are applied afterwards and so may override these. coeff_scaling : float; Linear scale factor for the random basis coefficients; By default these range from -1.0 to 1.0; Note this is overridden by alg_params (if given there). num_coeffs : integer; Number of coefficients used for each basis function; Note this is calculated automatically based on the dimension of the; dynamics if not given. It is crucial to the performane of ",MatchSource.WIKI,docs/4.3/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/apidoc/functions.html
https://qutip.org/docs/4.3/apidoc/functions.html:186693,Availability,error,error,186693,"on.; Typically the identity matrix. target : Qobj; target transformation, e.g. gate or state, for the time evolution. num_tslots : integer or None; number of timeslots.; None implies that timeslots will be given in the tau array. evo_time : float or None; total time for the evolution; None implies that timeslots will be given in the tau array. tau : array[num_tslots] of floats or None; durations for the timeslots.; if this is given then num_tslots and evo_time are dervived; from it; None implies that timeslot durations will be equal and; calculated as evo_time/num_tslots. amp_lbound : float or list of floats; lower boundaries for the control amplitudes; Can be a scalar value applied to all controls; or a list of bounds for each control. amp_ubound : float or list of floats; upper boundaries for the control amplitudes; Can be a scalar value applied to all controls; or a list of bounds for each control. fid_err_targ : float; Fidelity error target. Pulse optimisation will; terminate when the fidelity error falls below this value. max_iter : integer; Maximum number of iterations of the optimisation algorithm. max_wall_time : float; Maximum allowed elapsed time for the optimisation algorithm. alg_params : Dictionary; options that are specific to the algorithm see above. optim_params : Dictionary; The key value pairs are the attribute name and value; used to set attribute values; Note: attributes are created if they do not exist already,; and are overwritten if they do.; Note: method_params are applied afterwards and so may override these. coeff_scaling : float; Linear scale factor for the random basis coefficients; By default these range from -1.0 to 1.0; Note this is overridden by alg_params (if given there). num_coeffs : integer; Number of coefficients used for each basis function; Note this is calculated automatically based on the dimension of the; dynamics if not given. It is crucial to the performane of the; algorithm that it is set as low as possible, while still gi",MatchSource.WIKI,docs/4.3/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/apidoc/functions.html
https://qutip.org/docs/4.3/apidoc/functions.html:188377,Availability,error,error,188377,"1.0; Note this is overridden by alg_params (if given there). num_coeffs : integer; Number of coefficients used for each basis function; Note this is calculated automatically based on the dimension of the; dynamics if not given. It is crucial to the performane of the; algorithm that it is set as low as possible, while still giving; high enough frequencies.; Note this is overridden by alg_params (if given there). optim_method : string; Multi-variable optimisation method; The only tested options are âfminâ and âNelder-meadâ; In theory any non-gradient method implemented in; scipy.optimize.mininize could be used. method_params : dict; Parameters for the optim_method.; Note that where there is an attribute of the; Optimizer object or the termination_conditions matching the key; that attribute. Otherwise, and in some case also,; they are assumed to be method_options; for the scipy.optimize.minimize method.; The commonly used parameter are:. xtol - limit on variable change for convergence; ftol - limit on fidelity error change for convergence. dyn_type : string; Dynamics type, i.e. the type of matrix used to describe; the dynamics. Options are UNIT, GEN_MAT, SYMPL; (see Dynamics classes for details). dyn_params : dict; Parameters for the Dynamics object; The key value pairs are assumed to be attribute name value pairs; They applied after the object is created. prop_type : string; Propagator type i.e. the method used to calculate the; propagtors and propagtor gradient for each timeslot; options are DEF, APPROX, DIAG, FRECHET, AUG_MAT; DEF will use the default for the specific dyn_type; (see PropagatorComputer classes for details). prop_params : dict; Parameters for the PropagatorComputer object; The key value pairs are assumed to be attribute name value pairs; They applied after the object is created. fid_type : string; Fidelity error (and fidelity error gradient) computation method; Options are DEF, UNIT, TRACEDIFF, TD_APPROX; DEF will use the default for the specific dyn_",MatchSource.WIKI,docs/4.3/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/apidoc/functions.html
https://qutip.org/docs/4.3/apidoc/functions.html:189207,Availability,error,error,189207,"ameter are:. xtol - limit on variable change for convergence; ftol - limit on fidelity error change for convergence. dyn_type : string; Dynamics type, i.e. the type of matrix used to describe; the dynamics. Options are UNIT, GEN_MAT, SYMPL; (see Dynamics classes for details). dyn_params : dict; Parameters for the Dynamics object; The key value pairs are assumed to be attribute name value pairs; They applied after the object is created. prop_type : string; Propagator type i.e. the method used to calculate the; propagtors and propagtor gradient for each timeslot; options are DEF, APPROX, DIAG, FRECHET, AUG_MAT; DEF will use the default for the specific dyn_type; (see PropagatorComputer classes for details). prop_params : dict; Parameters for the PropagatorComputer object; The key value pairs are assumed to be attribute name value pairs; They applied after the object is created. fid_type : string; Fidelity error (and fidelity error gradient) computation method; Options are DEF, UNIT, TRACEDIFF, TD_APPROX; DEF will use the default for the specific dyn_type; (See FidelityComputer classes for details). fid_params : dict; Parameters for the FidelityComputer object; The key value pairs are assumed to be attribute name value pairs; They applied after the object is created. tslot_type : string; Method for computing the dynamics generators, propagators and; evolution in the timeslots.; Options: DEF, UPDATE_ALL, DYNAMIC; UPDATE_ALL is the only one that currently works; (See TimeslotComputer classes for details). tslot_params : dict; Parameters for the TimeslotComputer object; The key value pairs are assumed to be attribute name value pairs; They applied after the object is created. guess_pulse_type : string; type / shape of pulse(s) used modulate the control amplitudes.; Options include:. RND, LIN, ZERO, SINE, SQUARE, TRIANGLE, SAW, GAUSSIAN. Default is None. guess_pulse_params : dict; Parameters for the guess pulse generator object; The key value pairs are assumed to be attribu",MatchSource.WIKI,docs/4.3/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/apidoc/functions.html
https://qutip.org/docs/4.3/apidoc/functions.html:189227,Availability,error,error,189227,"ameter are:. xtol - limit on variable change for convergence; ftol - limit on fidelity error change for convergence. dyn_type : string; Dynamics type, i.e. the type of matrix used to describe; the dynamics. Options are UNIT, GEN_MAT, SYMPL; (see Dynamics classes for details). dyn_params : dict; Parameters for the Dynamics object; The key value pairs are assumed to be attribute name value pairs; They applied after the object is created. prop_type : string; Propagator type i.e. the method used to calculate the; propagtors and propagtor gradient for each timeslot; options are DEF, APPROX, DIAG, FRECHET, AUG_MAT; DEF will use the default for the specific dyn_type; (see PropagatorComputer classes for details). prop_params : dict; Parameters for the PropagatorComputer object; The key value pairs are assumed to be attribute name value pairs; They applied after the object is created. fid_type : string; Fidelity error (and fidelity error gradient) computation method; Options are DEF, UNIT, TRACEDIFF, TD_APPROX; DEF will use the default for the specific dyn_type; (See FidelityComputer classes for details). fid_params : dict; Parameters for the FidelityComputer object; The key value pairs are assumed to be attribute name value pairs; They applied after the object is created. tslot_type : string; Method for computing the dynamics generators, propagators and; evolution in the timeslots.; Options: DEF, UPDATE_ALL, DYNAMIC; UPDATE_ALL is the only one that currently works; (See TimeslotComputer classes for details). tslot_params : dict; Parameters for the TimeslotComputer object; The key value pairs are assumed to be attribute name value pairs; They applied after the object is created. guess_pulse_type : string; type / shape of pulse(s) used modulate the control amplitudes.; Options include:. RND, LIN, ZERO, SINE, SQUARE, TRIANGLE, SAW, GAUSSIAN. Default is None. guess_pulse_params : dict; Parameters for the guess pulse generator object; The key value pairs are assumed to be attribu",MatchSource.WIKI,docs/4.3/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/apidoc/functions.html
https://qutip.org/docs/4.3/apidoc/functions.html:192241,Availability,error,error,192241,"med to be attribute name value pairs; They applied after the object is created. log_level : integer; level of messaging output from the logger.; Options are attributes of qutip.logging_utils,; in decreasing levels of messaging, are:; DEBUG_INTENSE, DEBUG_VERBOSE, DEBUG, INFO, WARN, ERROR, CRITICAL; Anything WARN or above is effectively âquietâ execution,; assuming everything runs as expected.; The default NOTSET implies that the level will be taken from; the QuTiP settings file, which by default is WARN. out_file_ext : string or None; files containing the initial and final control pulse; amplitudes are saved to the current directory.; The default name will be postfixed with this extension; Setting this to None will suppress the output of files. gen_stats : boolean; if set to True then statistics for the optimisation; run will be generated - accessible through attributes; of the stats object. Returns:; opt : OptimResult; Returns instance of OptimResult, which has attributes giving the; reason for termination, final fidelity error, final evolution; final amplitudes, statistics etc. opt_pulse_crab_unitary(H_d, H_c, U_0, U_targ, num_tslots=None, evo_time=None, tau=None, amp_lbound=None, amp_ubound=None, fid_err_targ=1e-05, max_iter=500, max_wall_time=180, alg_params=None, num_coeffs=None, init_coeff_scaling=1.0, optim_params=None, optim_method='fmin', method_params=None, phase_option='PSU', dyn_params=None, prop_params=None, fid_params=None, tslot_type='DEF', tslot_params=None, guess_pulse_type=None, guess_pulse_params=None, guess_pulse_scaling=1.0, guess_pulse_offset=0.0, guess_pulse_action='MODULATE', ramping_pulse_type=None, ramping_pulse_params=None, log_level=0, out_file_ext=None, gen_stats=False)[source]Â¶; Optimise a control pulse to minimise the fidelity error, assuming that; the dynamics of the system are generated by unitary operators.; This function is simply a wrapper for optimize_pulse, where the; appropriate options for unitary dynamics are chosen and the p",MatchSource.WIKI,docs/4.3/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/apidoc/functions.html
https://qutip.org/docs/4.3/apidoc/functions.html:192990,Availability,error,error,192990,"s the output of files. gen_stats : boolean; if set to True then statistics for the optimisation; run will be generated - accessible through attributes; of the stats object. Returns:; opt : OptimResult; Returns instance of OptimResult, which has attributes giving the; reason for termination, final fidelity error, final evolution; final amplitudes, statistics etc. opt_pulse_crab_unitary(H_d, H_c, U_0, U_targ, num_tslots=None, evo_time=None, tau=None, amp_lbound=None, amp_ubound=None, fid_err_targ=1e-05, max_iter=500, max_wall_time=180, alg_params=None, num_coeffs=None, init_coeff_scaling=1.0, optim_params=None, optim_method='fmin', method_params=None, phase_option='PSU', dyn_params=None, prop_params=None, fid_params=None, tslot_type='DEF', tslot_params=None, guess_pulse_type=None, guess_pulse_params=None, guess_pulse_scaling=1.0, guess_pulse_offset=0.0, guess_pulse_action='MODULATE', ramping_pulse_type=None, ramping_pulse_params=None, log_level=0, out_file_ext=None, gen_stats=False)[source]Â¶; Optimise a control pulse to minimise the fidelity error, assuming that; the dynamics of the system are generated by unitary operators.; This function is simply a wrapper for optimize_pulse, where the; appropriate options for unitary dynamics are chosen and the parameter; names are in the format familiar to unitary dynamics; The dynamics of the system in any given timeslot are governed; by the combined Hamiltonian,; i.e. the sum of the H_d + ctrl_amp[j]*H_c[j]; The control pulse is an [n_ts, n_ctrls] array of piecewise amplitudes; The CRAB algorithm uses basis function coefficents as the variables to; optimise. It does NOT use any gradient function.; A multivariable optimisation algorithm attempts to determines the; optimal values for the control pulse to minimise the fidelity error; The fidelity error is some measure of distance of the system evolution; from the given target evolution in the time allowed for the evolution. Parameters:; H_d : Qobj or list of Qobj; Drift (aka system",MatchSource.WIKI,docs/4.3/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/apidoc/functions.html
https://qutip.org/docs/4.3/apidoc/functions.html:193727,Availability,error,error,193727,"params=None, guess_pulse_scaling=1.0, guess_pulse_offset=0.0, guess_pulse_action='MODULATE', ramping_pulse_type=None, ramping_pulse_params=None, log_level=0, out_file_ext=None, gen_stats=False)[source]Â¶; Optimise a control pulse to minimise the fidelity error, assuming that; the dynamics of the system are generated by unitary operators.; This function is simply a wrapper for optimize_pulse, where the; appropriate options for unitary dynamics are chosen and the parameter; names are in the format familiar to unitary dynamics; The dynamics of the system in any given timeslot are governed; by the combined Hamiltonian,; i.e. the sum of the H_d + ctrl_amp[j]*H_c[j]; The control pulse is an [n_ts, n_ctrls] array of piecewise amplitudes; The CRAB algorithm uses basis function coefficents as the variables to; optimise. It does NOT use any gradient function.; A multivariable optimisation algorithm attempts to determines the; optimal values for the control pulse to minimise the fidelity error; The fidelity error is some measure of distance of the system evolution; from the given target evolution in the time allowed for the evolution. Parameters:; H_d : Qobj or list of Qobj; Drift (aka system) the underlying Hamiltonian of the system; can provide list (of length num_tslots) for time dependent drift. H_c : List of Qobj or array like [num_tslots, evo_time]; a list of control Hamiltonians. These are scaled by; the amplitudes to alter the overall dynamics; Array like imput can be provided for time dependent control generators. U_0 : Qobj; starting point for the evolution.; Typically the identity matrix. U_targ : Qobj; target transformation, e.g. gate or state, for the time evolution. num_tslots : integer or None; number of timeslots.; None implies that timeslots will be given in the tau array. evo_time : float or None; total time for the evolution; None implies that timeslots will be given in the tau array. tau : array[num_tslots] of floats or None; durations for the timeslots.; if",MatchSource.WIKI,docs/4.3/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/apidoc/functions.html
https://qutip.org/docs/4.3/apidoc/functions.html:193747,Availability,error,error,193747,"params=None, guess_pulse_scaling=1.0, guess_pulse_offset=0.0, guess_pulse_action='MODULATE', ramping_pulse_type=None, ramping_pulse_params=None, log_level=0, out_file_ext=None, gen_stats=False)[source]Â¶; Optimise a control pulse to minimise the fidelity error, assuming that; the dynamics of the system are generated by unitary operators.; This function is simply a wrapper for optimize_pulse, where the; appropriate options for unitary dynamics are chosen and the parameter; names are in the format familiar to unitary dynamics; The dynamics of the system in any given timeslot are governed; by the combined Hamiltonian,; i.e. the sum of the H_d + ctrl_amp[j]*H_c[j]; The control pulse is an [n_ts, n_ctrls] array of piecewise amplitudes; The CRAB algorithm uses basis function coefficents as the variables to; optimise. It does NOT use any gradient function.; A multivariable optimisation algorithm attempts to determines the; optimal values for the control pulse to minimise the fidelity error; The fidelity error is some measure of distance of the system evolution; from the given target evolution in the time allowed for the evolution. Parameters:; H_d : Qobj or list of Qobj; Drift (aka system) the underlying Hamiltonian of the system; can provide list (of length num_tslots) for time dependent drift. H_c : List of Qobj or array like [num_tslots, evo_time]; a list of control Hamiltonians. These are scaled by; the amplitudes to alter the overall dynamics; Array like imput can be provided for time dependent control generators. U_0 : Qobj; starting point for the evolution.; Typically the identity matrix. U_targ : Qobj; target transformation, e.g. gate or state, for the time evolution. num_tslots : integer or None; number of timeslots.; None implies that timeslots will be given in the tau array. evo_time : float or None; total time for the evolution; None implies that timeslots will be given in the tau array. tau : array[num_tslots] of floats or None; durations for the timeslots.; if",MatchSource.WIKI,docs/4.3/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/apidoc/functions.html
