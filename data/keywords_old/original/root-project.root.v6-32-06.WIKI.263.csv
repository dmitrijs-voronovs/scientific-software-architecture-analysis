id,quality_attribute,keyword,matched_word,match_idx,sentence,source,filename,author,repo,version,wiki,url
https://root.cern/root/html602/RooAbsArg.html:9148,Testability,test,testArg,9148,"ual Bool_tisIdentical(const RooAbsArg& other, Bool_t assumeSameType = kFALSE); virtual Bool_tisLValue() const; Bool_tTObject::IsOnHeap() const; Bool_tisShapeDirty() const; Bool_tisShapeServer(const RooAbsArg& arg) const; Bool_tisShapeServer(const char* name) const; virtual Bool_tIsSortable() const; Bool_tisValueDirty() const; Bool_tisValueDirtyAndClear() const; Bool_tisValueOrShapeDirtyAndClear() const; Bool_tisValueServer(const RooAbsArg& arg) const; Bool_tisValueServer(const char* name) const; Bool_tTObject::IsZombie() const; voidleafNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t recurseNonDerived = kFALSE) const; Bool_tlocalNoDirtyInhibit() const; virtual voidTNamed::ls(Option_t* option = """") const; voidTObject::MayNotUse(const char* method) const; static voidRooPrintable::nameFieldLength(Int_t newLen); const TNamed*namePtr() const; virtual Bool_tTObject::Notify(); Int_tnumCaches() const; Bool_tobservableOverlaps(const RooAbsData* dset, const RooAbsArg& testArg) const; Bool_tobservableOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; voidTObject::operator delete(void* ptr); voidTObject::operator delete(void* ptr, void* vp); voidTObject::operator delete[](void* ptr); voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); RooAbsArg&operator=(const RooAbsArg&); virtual Bool_toperator==(const RooAbsArg& other); RooAbsArg::OperModeoperMode() const; virtual voidoptimizeCacheMode(const RooArgSet& observables); virtual voidoptimizeCacheMode(const RooArgSet& observables, RooArgSet& optNodes, RooLinkedList& processedNodes); Bool_toverlaps(const RooAbsArg& testArg, Bool_t valueOnly = kFALSE) const; const RooArgSet*ownedComponents() const; virtual voidTObject:",MatchSource.WIKI,root/html602/RooAbsArg.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsArg.html
https://root.cern/root/html602/RooAbsArg.html:9232,Testability,test,testArg,9232,"al Bool_tisLValue() const; Bool_tTObject::IsOnHeap() const; Bool_tisShapeDirty() const; Bool_tisShapeServer(const RooAbsArg& arg) const; Bool_tisShapeServer(const char* name) const; virtual Bool_tIsSortable() const; Bool_tisValueDirty() const; Bool_tisValueDirtyAndClear() const; Bool_tisValueOrShapeDirtyAndClear() const; Bool_tisValueServer(const RooAbsArg& arg) const; Bool_tisValueServer(const char* name) const; Bool_tTObject::IsZombie() const; voidleafNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t recurseNonDerived = kFALSE) const; Bool_tlocalNoDirtyInhibit() const; virtual voidTNamed::ls(Option_t* option = """") const; voidTObject::MayNotUse(const char* method) const; static voidRooPrintable::nameFieldLength(Int_t newLen); const TNamed*namePtr() const; virtual Bool_tTObject::Notify(); Int_tnumCaches() const; Bool_tobservableOverlaps(const RooAbsData* dset, const RooAbsArg& testArg) const; Bool_tobservableOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; voidTObject::operator delete(void* ptr); voidTObject::operator delete(void* ptr, void* vp); voidTObject::operator delete[](void* ptr); voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); RooAbsArg&operator=(const RooAbsArg&); virtual Bool_toperator==(const RooAbsArg& other); RooAbsArg::OperModeoperMode() const; virtual voidoptimizeCacheMode(const RooArgSet& observables); virtual voidoptimizeCacheMode(const RooArgSet& observables, RooArgSet& optNodes, RooLinkedList& processedNodes); Bool_toverlaps(const RooAbsArg& testArg, Bool_t valueOnly = kFALSE) const; const RooArgSet*ownedComponents() const; virtual voidTObject::Paint(Option_t* option = """"); virtual voidTObject::Pop(); virtual voidPrint(Option_",MatchSource.WIKI,root/html602/RooAbsArg.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsArg.html
https://root.cern/root/html602/RooAbsArg.html:10048,Testability,test,testArg,10048,"fy(); Int_tnumCaches() const; Bool_tobservableOverlaps(const RooAbsData* dset, const RooAbsArg& testArg) const; Bool_tobservableOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; voidTObject::operator delete(void* ptr); voidTObject::operator delete(void* ptr, void* vp); voidTObject::operator delete[](void* ptr); voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); RooAbsArg&operator=(const RooAbsArg&); virtual Bool_toperator==(const RooAbsArg& other); RooAbsArg::OperModeoperMode() const; virtual voidoptimizeCacheMode(const RooArgSet& observables); virtual voidoptimizeCacheMode(const RooArgSet& observables, RooArgSet& optNodes, RooLinkedList& processedNodes); Bool_toverlaps(const RooAbsArg& testArg, Bool_t valueOnly = kFALSE) const; const RooArgSet*ownedComponents() const; virtual voidTObject::Paint(Option_t* option = """"); virtual voidTObject::Pop(); virtual voidPrint(Option_t* options = 0) const; virtual voidprintAddress(ostream& os) const; virtual voidprintArgs(ostream& os) const; virtual voidprintClassName(ostream& os) const; voidprintCompactTree(const char* indent = """", const char* fileName = 0, const char* namePat = 0, RooAbsArg* client = 0); voidprintCompactTree(ostream& os, const char* indent = """", const char* namePat = 0, RooAbsArg* client = 0); virtual voidprintCompactTreeHook(ostream& os, const char* ind = """"); voidprintComponentTree(const char* indent = """", const char* namePat = 0, Int_t nLevel = 999); voidprintDirty(Bool_t depth = kTRUE) const; virtual voidRooPrintable::printExtras(ostream& os) const; virtual voidprintMetaArgs(ostream&) const; virtual voidprintMultiline(ostream& os, Int_t contents, Bool_t verbose = kFALSE, TString indent = """") const; virtual voidp",MatchSource.WIKI,root/html602/RooAbsArg.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsArg.html
https://root.cern/root/html602/RooAbsArg.html:26520,Testability,test,testArg,26520,"pression tree headed by this object. Bool_t checkObservables(const RooArgSet* nset) const; Overloadable function in which derived classes can implement; consistency checks of the variables. If this function returns; true, indicating an error, the fitter or generator will abort. Bool_t recursiveCheckObservables(const RooArgSet* nset) const; Recursively call checkObservables on all nodes in the expression tree. Bool_t dependsOn(const RooAbsCollection& serverList, const RooAbsArg* ignoreArg = 0, Bool_t valueOnly = kFALSE) const; Test whether we depend on (ie, are served by) any object in the; specified collection. Uses the dependsOn(RooAbsArg&) member function. Bool_t dependsOn(const RooAbsArg& server, const RooAbsArg* ignoreArg = 0, Bool_t valueOnly = kFALSE) const; Test whether we depend on (ie, are served by) the specified object.; Note that RooAbsArg objects are considered equivalent if they have; the same name. Bool_t overlaps(const RooAbsArg& testArg, Bool_t valueOnly = kFALSE) const; Test if any of the nodes of tree are shared with that of the given tree. Bool_t observableOverlaps(const RooAbsData* dset, const RooAbsArg& testArg) const; Test if any of the dependents of the arg tree (as determined by getObservables); overlaps with those of the testArg. Bool_t observableOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; Test if any of the dependents of the arg tree (as determined by getObservables); overlaps with those of the testArg. void setValueDirty(const RooAbsArg* source) const; Mark this object as having changed its value, and propagate this status; change to all of our clients. If the object is not in automatic dirty; state propagation mode, this call has no effect. void setShapeDirty(const RooAbsArg* source) const; Mark this object as having changed its shape, and propagate this status; change to all of our clients. Bool_t redirectServers(const RooAbsCollection& newServerList, Bool_t mustReplaceAll = kFALSE, Bool_t nameChange = kFALSE, Boo",MatchSource.WIKI,root/html602/RooAbsArg.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsArg.html
https://root.cern/root/html602/RooAbsArg.html:26703,Testability,test,testArg,26703,"the variables. If this function returns; true, indicating an error, the fitter or generator will abort. Bool_t recursiveCheckObservables(const RooArgSet* nset) const; Recursively call checkObservables on all nodes in the expression tree. Bool_t dependsOn(const RooAbsCollection& serverList, const RooAbsArg* ignoreArg = 0, Bool_t valueOnly = kFALSE) const; Test whether we depend on (ie, are served by) any object in the; specified collection. Uses the dependsOn(RooAbsArg&) member function. Bool_t dependsOn(const RooAbsArg& server, const RooAbsArg* ignoreArg = 0, Bool_t valueOnly = kFALSE) const; Test whether we depend on (ie, are served by) the specified object.; Note that RooAbsArg objects are considered equivalent if they have; the same name. Bool_t overlaps(const RooAbsArg& testArg, Bool_t valueOnly = kFALSE) const; Test if any of the nodes of tree are shared with that of the given tree. Bool_t observableOverlaps(const RooAbsData* dset, const RooAbsArg& testArg) const; Test if any of the dependents of the arg tree (as determined by getObservables); overlaps with those of the testArg. Bool_t observableOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; Test if any of the dependents of the arg tree (as determined by getObservables); overlaps with those of the testArg. void setValueDirty(const RooAbsArg* source) const; Mark this object as having changed its value, and propagate this status; change to all of our clients. If the object is not in automatic dirty; state propagation mode, this call has no effect. void setShapeDirty(const RooAbsArg* source) const; Mark this object as having changed its shape, and propagate this status; change to all of our clients. Bool_t redirectServers(const RooAbsCollection& newServerList, Bool_t mustReplaceAll = kFALSE, Bool_t nameChange = kFALSE, Bool_t isRecursionStep = kFALSE); Substitute our servers with those listed in newSet. If nameChange is false, servers and; and substitutes are matched by name. If nameChange is ",MatchSource.WIKI,root/html602/RooAbsArg.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsArg.html
https://root.cern/root/html602/RooAbsArg.html:26827,Testability,test,testArg,26827,"the variables. If this function returns; true, indicating an error, the fitter or generator will abort. Bool_t recursiveCheckObservables(const RooArgSet* nset) const; Recursively call checkObservables on all nodes in the expression tree. Bool_t dependsOn(const RooAbsCollection& serverList, const RooAbsArg* ignoreArg = 0, Bool_t valueOnly = kFALSE) const; Test whether we depend on (ie, are served by) any object in the; specified collection. Uses the dependsOn(RooAbsArg&) member function. Bool_t dependsOn(const RooAbsArg& server, const RooAbsArg* ignoreArg = 0, Bool_t valueOnly = kFALSE) const; Test whether we depend on (ie, are served by) the specified object.; Note that RooAbsArg objects are considered equivalent if they have; the same name. Bool_t overlaps(const RooAbsArg& testArg, Bool_t valueOnly = kFALSE) const; Test if any of the nodes of tree are shared with that of the given tree. Bool_t observableOverlaps(const RooAbsData* dset, const RooAbsArg& testArg) const; Test if any of the dependents of the arg tree (as determined by getObservables); overlaps with those of the testArg. Bool_t observableOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; Test if any of the dependents of the arg tree (as determined by getObservables); overlaps with those of the testArg. void setValueDirty(const RooAbsArg* source) const; Mark this object as having changed its value, and propagate this status; change to all of our clients. If the object is not in automatic dirty; state propagation mode, this call has no effect. void setShapeDirty(const RooAbsArg* source) const; Mark this object as having changed its shape, and propagate this status; change to all of our clients. Bool_t redirectServers(const RooAbsCollection& newServerList, Bool_t mustReplaceAll = kFALSE, Bool_t nameChange = kFALSE, Bool_t isRecursionStep = kFALSE); Substitute our servers with those listed in newSet. If nameChange is false, servers and; and substitutes are matched by name. If nameChange is ",MatchSource.WIKI,root/html602/RooAbsArg.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsArg.html
https://root.cern/root/html602/RooAbsArg.html:26905,Testability,test,testArg,26905,"on all nodes in the expression tree. Bool_t dependsOn(const RooAbsCollection& serverList, const RooAbsArg* ignoreArg = 0, Bool_t valueOnly = kFALSE) const; Test whether we depend on (ie, are served by) any object in the; specified collection. Uses the dependsOn(RooAbsArg&) member function. Bool_t dependsOn(const RooAbsArg& server, const RooAbsArg* ignoreArg = 0, Bool_t valueOnly = kFALSE) const; Test whether we depend on (ie, are served by) the specified object.; Note that RooAbsArg objects are considered equivalent if they have; the same name. Bool_t overlaps(const RooAbsArg& testArg, Bool_t valueOnly = kFALSE) const; Test if any of the nodes of tree are shared with that of the given tree. Bool_t observableOverlaps(const RooAbsData* dset, const RooAbsArg& testArg) const; Test if any of the dependents of the arg tree (as determined by getObservables); overlaps with those of the testArg. Bool_t observableOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; Test if any of the dependents of the arg tree (as determined by getObservables); overlaps with those of the testArg. void setValueDirty(const RooAbsArg* source) const; Mark this object as having changed its value, and propagate this status; change to all of our clients. If the object is not in automatic dirty; state propagation mode, this call has no effect. void setShapeDirty(const RooAbsArg* source) const; Mark this object as having changed its shape, and propagate this status; change to all of our clients. Bool_t redirectServers(const RooAbsCollection& newServerList, Bool_t mustReplaceAll = kFALSE, Bool_t nameChange = kFALSE, Bool_t isRecursionStep = kFALSE); Substitute our servers with those listed in newSet. If nameChange is false, servers and; and substitutes are matched by name. If nameChange is true, servers are matched to args; in newSet that have the 'ORIGNAME:<servername>' attribute set. If mustReplaceAll is set,; a warning is printed and error status is returned if not all servers could b",MatchSource.WIKI,root/html602/RooAbsArg.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsArg.html
https://root.cern/root/html602/RooAbsArg.html:27029,Testability,test,testArg,27029,"on all nodes in the expression tree. Bool_t dependsOn(const RooAbsCollection& serverList, const RooAbsArg* ignoreArg = 0, Bool_t valueOnly = kFALSE) const; Test whether we depend on (ie, are served by) any object in the; specified collection. Uses the dependsOn(RooAbsArg&) member function. Bool_t dependsOn(const RooAbsArg& server, const RooAbsArg* ignoreArg = 0, Bool_t valueOnly = kFALSE) const; Test whether we depend on (ie, are served by) the specified object.; Note that RooAbsArg objects are considered equivalent if they have; the same name. Bool_t overlaps(const RooAbsArg& testArg, Bool_t valueOnly = kFALSE) const; Test if any of the nodes of tree are shared with that of the given tree. Bool_t observableOverlaps(const RooAbsData* dset, const RooAbsArg& testArg) const; Test if any of the dependents of the arg tree (as determined by getObservables); overlaps with those of the testArg. Bool_t observableOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; Test if any of the dependents of the arg tree (as determined by getObservables); overlaps with those of the testArg. void setValueDirty(const RooAbsArg* source) const; Mark this object as having changed its value, and propagate this status; change to all of our clients. If the object is not in automatic dirty; state propagation mode, this call has no effect. void setShapeDirty(const RooAbsArg* source) const; Mark this object as having changed its shape, and propagate this status; change to all of our clients. Bool_t redirectServers(const RooAbsCollection& newServerList, Bool_t mustReplaceAll = kFALSE, Bool_t nameChange = kFALSE, Bool_t isRecursionStep = kFALSE); Substitute our servers with those listed in newSet. If nameChange is false, servers and; and substitutes are matched by name. If nameChange is true, servers are matched to args; in newSet that have the 'ORIGNAME:<servername>' attribute set. If mustReplaceAll is set,; a warning is printed and error status is returned if not all servers could b",MatchSource.WIKI,root/html602/RooAbsArg.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsArg.html
https://root.cern/root/html602/RooAbsArg.html:33621,Testability,test,test,33621,"mode optimization with given definition of observables.; The cache operation mode of all objects in the expression tree will; modified such that all nodes that depend directly or indirectly on; any of the listed observables will be set to ADirty, as they are; expected to change every time. This save change tracking overhead for; nodes that are a priori known to change every time. void optimizeCacheMode(const RooArgSet& observables, RooArgSet& optNodes, RooLinkedList& processedNodes); Activate cache mode optimization with given definition of observables.; The cache operation mode of all objects in the expression tree will; modified such that all nodes that depend directly or indirectly on; any of the listed observables will be set to ADirty, as they are; expected to change every time. This save change tracking overhead for; nodes that are a priori known to change every time. Bool_t findConstantNodes(const RooArgSet& observables, RooArgSet& cacheList); Find branch nodes with all-constant parameters, and add them to the list of; nodes that can be cached with a dataset in a test statistic calculation. Bool_t findConstantNodes(const RooArgSet& observables, RooArgSet& cacheList, RooLinkedList& processedNodes); Find branch nodes with all-constant parameters, and add them to the list of; nodes that can be cached with a dataset in a test statistic calculation. void constOptimizeTestStatistic(RooAbsArg::ConstOpCode opcode, Bool_t doAlsoTrackingOpt = kTRUE); Interface function signaling a request to perform constant term; optimization. This default implementation takes no action other than to; forward the calls to all servers. void setOperMode(RooAbsArg::OperMode mode, Bool_t recurseADirty = kTRUE); Change cache operation mode to given mode. If recurseAdirty; is true, then a mode change to AlwaysDirty will automatically; be propagated recursively to all client nodes. void printCompactTree(const char* indent = """", const char* fileName = 0, const char* namePat = 0, RooAbsArg* cl",MatchSource.WIKI,root/html602/RooAbsArg.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsArg.html
https://root.cern/root/html602/RooAbsArg.html:33880,Testability,test,test,33880,"ty, as they are; expected to change every time. This save change tracking overhead for; nodes that are a priori known to change every time. void optimizeCacheMode(const RooArgSet& observables, RooArgSet& optNodes, RooLinkedList& processedNodes); Activate cache mode optimization with given definition of observables.; The cache operation mode of all objects in the expression tree will; modified such that all nodes that depend directly or indirectly on; any of the listed observables will be set to ADirty, as they are; expected to change every time. This save change tracking overhead for; nodes that are a priori known to change every time. Bool_t findConstantNodes(const RooArgSet& observables, RooArgSet& cacheList); Find branch nodes with all-constant parameters, and add them to the list of; nodes that can be cached with a dataset in a test statistic calculation. Bool_t findConstantNodes(const RooArgSet& observables, RooArgSet& cacheList, RooLinkedList& processedNodes); Find branch nodes with all-constant parameters, and add them to the list of; nodes that can be cached with a dataset in a test statistic calculation. void constOptimizeTestStatistic(RooAbsArg::ConstOpCode opcode, Bool_t doAlsoTrackingOpt = kTRUE); Interface function signaling a request to perform constant term; optimization. This default implementation takes no action other than to; forward the calls to all servers. void setOperMode(RooAbsArg::OperMode mode, Bool_t recurseADirty = kTRUE); Change cache operation mode to given mode. If recurseAdirty; is true, then a mode change to AlwaysDirty will automatically; be propagated recursively to all client nodes. void printCompactTree(const char* indent = """", const char* fileName = 0, const char* namePat = 0, RooAbsArg* client = 0); Print tree structure of expression tree on stdout, or to file if filename is specified.; If namePat is not ""*"", only nodes with names matching the pattern will be printed.; The client argument is used in recursive calls to properly d",MatchSource.WIKI,root/html602/RooAbsArg.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsArg.html
https://root.cern/root/html602/RooAbsArg.html:41864,Testability,test,test,41864,"tListShape.fwdIterator() ; }. RooFIter serverMIterator() const; { return _serverList.fwdIterator() ; }. RooAbsArg* findServer(const char* name) const; Return server of this arg with given name. Returns null if not found. RooAbsArg* findServer(const RooAbsArg& arg) const; Return server of this arg with name of given input arg. Returns null if not found. RooAbsArg* findServer(Int_t index) const; Return i-th server from server list. Bool_t isValueServer(const RooAbsArg& arg) const; If true, arg is a value server of self. Bool_t isValueServer(const char* name) const; If true, we have a server with given name. Bool_t isShapeServer(const RooAbsArg& arg) const; If true arg is a shape server of self. Bool_t isShapeServer(const char* name) const; If true, we have a shape server with given name. Bool_t isFundamental() const; Is this object a fundamental type that can be added to a dataset?; Fundamental-type subclasses override this method to return kTRUE.; Note that this test is subtlely different from the dynamic isDerived(); test, e.g. a constant is not derived but is also not fundamental. RooAbsArg * createFundamental(const char* newname = 0) const; Create a fundamental-type object that stores our type of value. The; created object will have a valid value, but not necessarily the same; as our value. The caller is responsible for deleting the returned object. Bool_t isLValue() const; Is this argument an l-value, ie, can it appear on the left-hand side; of an assignment expression? LValues are also special since they can; potentially be analytically integrated and generated. RooArgSet* getParameters(const RooAbsData* data, Bool_t stripDisconnected = kTRUE) const. RooArgSet* getParameters(const RooAbsData& data, Bool_t stripDisconnected = kTRUE) const; Return the parameters of this p.d.f when used in conjuction with dataset 'data'. RooArgSet* getObservables(const RooArgSet& set, Bool_t valueOnly = kTRUE) const; Return the observables of _this_ pdf given a set of observables. ",MatchSource.WIKI,root/html602/RooAbsArg.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsArg.html
https://root.cern/root/html602/RooAbsArg.html:41921,Testability,test,test,41921,"tListShape.fwdIterator() ; }. RooFIter serverMIterator() const; { return _serverList.fwdIterator() ; }. RooAbsArg* findServer(const char* name) const; Return server of this arg with given name. Returns null if not found. RooAbsArg* findServer(const RooAbsArg& arg) const; Return server of this arg with name of given input arg. Returns null if not found. RooAbsArg* findServer(Int_t index) const; Return i-th server from server list. Bool_t isValueServer(const RooAbsArg& arg) const; If true, arg is a value server of self. Bool_t isValueServer(const char* name) const; If true, we have a server with given name. Bool_t isShapeServer(const RooAbsArg& arg) const; If true arg is a shape server of self. Bool_t isShapeServer(const char* name) const; If true, we have a shape server with given name. Bool_t isFundamental() const; Is this object a fundamental type that can be added to a dataset?; Fundamental-type subclasses override this method to return kTRUE.; Note that this test is subtlely different from the dynamic isDerived(); test, e.g. a constant is not derived but is also not fundamental. RooAbsArg * createFundamental(const char* newname = 0) const; Create a fundamental-type object that stores our type of value. The; created object will have a valid value, but not necessarily the same; as our value. The caller is responsible for deleting the returned object. Bool_t isLValue() const; Is this argument an l-value, ie, can it appear on the left-hand side; of an assignment expression? LValues are also special since they can; potentially be analytically integrated and generated. RooArgSet* getParameters(const RooAbsData* data, Bool_t stripDisconnected = kTRUE) const. RooArgSet* getParameters(const RooAbsData& data, Bool_t stripDisconnected = kTRUE) const; Return the parameters of this p.d.f when used in conjuction with dataset 'data'. RooArgSet* getObservables(const RooArgSet& set, Bool_t valueOnly = kTRUE) const; Return the observables of _this_ pdf given a set of observables. ",MatchSource.WIKI,root/html602/RooAbsArg.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsArg.html
https://root.cern/root/html602/RooAbsArg.html:43317,Testability,test,testArg,43317,", ie, can it appear on the left-hand side; of an assignment expression? LValues are also special since they can; potentially be analytically integrated and generated. RooArgSet* getParameters(const RooAbsData* data, Bool_t stripDisconnected = kTRUE) const. RooArgSet* getParameters(const RooAbsData& data, Bool_t stripDisconnected = kTRUE) const; Return the parameters of this p.d.f when used in conjuction with dataset 'data'. RooArgSet* getObservables(const RooArgSet& set, Bool_t valueOnly = kTRUE) const; Return the observables of _this_ pdf given a set of observables. return getObservables(&set,valueOnly). RooArgSet* getDependents(const RooArgSet& set) const; --- Obsolete functions for backward compatibility. { return getObservables(set) ; }. RooArgSet* getDependents(const RooAbsData* set) const; { return getObservables(set) ; }. RooArgSet* getDependents(const RooArgSet* depList) const; { return getObservables(depList) ; }. Bool_t dependentOverlaps(const RooAbsData* dset, const RooAbsArg& testArg) const; { return observableOverlaps(dset,testArg) ; }. Bool_t dependentOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; { return observableOverlaps(depList, testArg) ; }. Bool_t checkDependents(const RooArgSet* nset) const; { return checkObservables(nset) ; }. Bool_t recursiveCheckDependents(const RooArgSet* nset) const; --- End obsolete functions for backward compatibility. { return recursiveCheckObservables(nset) ; }. Bool_t readFromStream(istream& is, Bool_t compact, Bool_t verbose = kFALSE); I/O streaming interface (machine readable). void writeToStream(ostream& os, Bool_t compact) const. void Print(Option_t* options = 0) const; Printing interface (human readable). void printMetaArgs(ostream& ) const; {}. const std::set<std::string>& attributes() const; Returns set of names of boolean attributes defined. const std::map<std::string,std::string>& stringAttributes() const; Returns std::map<string,string> with all string attributes defined. const std::set<s",MatchSource.WIKI,root/html602/RooAbsArg.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsArg.html
https://root.cern/root/html602/RooAbsArg.html:43366,Testability,test,testArg,43366,", ie, can it appear on the left-hand side; of an assignment expression? LValues are also special since they can; potentially be analytically integrated and generated. RooArgSet* getParameters(const RooAbsData* data, Bool_t stripDisconnected = kTRUE) const. RooArgSet* getParameters(const RooAbsData& data, Bool_t stripDisconnected = kTRUE) const; Return the parameters of this p.d.f when used in conjuction with dataset 'data'. RooArgSet* getObservables(const RooArgSet& set, Bool_t valueOnly = kTRUE) const; Return the observables of _this_ pdf given a set of observables. return getObservables(&set,valueOnly). RooArgSet* getDependents(const RooArgSet& set) const; --- Obsolete functions for backward compatibility. { return getObservables(set) ; }. RooArgSet* getDependents(const RooAbsData* set) const; { return getObservables(set) ; }. RooArgSet* getDependents(const RooArgSet* depList) const; { return getObservables(depList) ; }. Bool_t dependentOverlaps(const RooAbsData* dset, const RooAbsArg& testArg) const; { return observableOverlaps(dset,testArg) ; }. Bool_t dependentOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; { return observableOverlaps(depList, testArg) ; }. Bool_t checkDependents(const RooArgSet* nset) const; { return checkObservables(nset) ; }. Bool_t recursiveCheckDependents(const RooArgSet* nset) const; --- End obsolete functions for backward compatibility. { return recursiveCheckObservables(nset) ; }. Bool_t readFromStream(istream& is, Bool_t compact, Bool_t verbose = kFALSE); I/O streaming interface (machine readable). void writeToStream(ostream& os, Bool_t compact) const. void Print(Option_t* options = 0) const; Printing interface (human readable). void printMetaArgs(ostream& ) const; {}. const std::set<std::string>& attributes() const; Returns set of names of boolean attributes defined. const std::map<std::string,std::string>& stringAttributes() const; Returns std::map<string,string> with all string attributes defined. const std::set<s",MatchSource.WIKI,root/html602/RooAbsArg.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsArg.html
https://root.cern/root/html602/RooAbsArg.html:43448,Testability,test,testArg,43448,"ytically integrated and generated. RooArgSet* getParameters(const RooAbsData* data, Bool_t stripDisconnected = kTRUE) const. RooArgSet* getParameters(const RooAbsData& data, Bool_t stripDisconnected = kTRUE) const; Return the parameters of this p.d.f when used in conjuction with dataset 'data'. RooArgSet* getObservables(const RooArgSet& set, Bool_t valueOnly = kTRUE) const; Return the observables of _this_ pdf given a set of observables. return getObservables(&set,valueOnly). RooArgSet* getDependents(const RooArgSet& set) const; --- Obsolete functions for backward compatibility. { return getObservables(set) ; }. RooArgSet* getDependents(const RooAbsData* set) const; { return getObservables(set) ; }. RooArgSet* getDependents(const RooArgSet* depList) const; { return getObservables(depList) ; }. Bool_t dependentOverlaps(const RooAbsData* dset, const RooAbsArg& testArg) const; { return observableOverlaps(dset,testArg) ; }. Bool_t dependentOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; { return observableOverlaps(depList, testArg) ; }. Bool_t checkDependents(const RooArgSet* nset) const; { return checkObservables(nset) ; }. Bool_t recursiveCheckDependents(const RooArgSet* nset) const; --- End obsolete functions for backward compatibility. { return recursiveCheckObservables(nset) ; }. Bool_t readFromStream(istream& is, Bool_t compact, Bool_t verbose = kFALSE); I/O streaming interface (machine readable). void writeToStream(ostream& os, Bool_t compact) const. void Print(Option_t* options = 0) const; Printing interface (human readable). void printMetaArgs(ostream& ) const; {}. const std::set<std::string>& attributes() const; Returns set of names of boolean attributes defined. const std::map<std::string,std::string>& stringAttributes() const; Returns std::map<string,string> with all string attributes defined. const std::set<std::string>& transientAttributes() const; Return set of transient boolean attributes. Bool_t isConstant() const; Returns true if 'Co",MatchSource.WIKI,root/html602/RooAbsArg.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsArg.html
https://root.cern/root/html602/RooAbsArg.html:43501,Testability,test,testArg,43501,"ytically integrated and generated. RooArgSet* getParameters(const RooAbsData* data, Bool_t stripDisconnected = kTRUE) const. RooArgSet* getParameters(const RooAbsData& data, Bool_t stripDisconnected = kTRUE) const; Return the parameters of this p.d.f when used in conjuction with dataset 'data'. RooArgSet* getObservables(const RooArgSet& set, Bool_t valueOnly = kTRUE) const; Return the observables of _this_ pdf given a set of observables. return getObservables(&set,valueOnly). RooArgSet* getDependents(const RooArgSet& set) const; --- Obsolete functions for backward compatibility. { return getObservables(set) ; }. RooArgSet* getDependents(const RooAbsData* set) const; { return getObservables(set) ; }. RooArgSet* getDependents(const RooArgSet* depList) const; { return getObservables(depList) ; }. Bool_t dependentOverlaps(const RooAbsData* dset, const RooAbsArg& testArg) const; { return observableOverlaps(dset,testArg) ; }. Bool_t dependentOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; { return observableOverlaps(depList, testArg) ; }. Bool_t checkDependents(const RooArgSet* nset) const; { return checkObservables(nset) ; }. Bool_t recursiveCheckDependents(const RooArgSet* nset) const; --- End obsolete functions for backward compatibility. { return recursiveCheckObservables(nset) ; }. Bool_t readFromStream(istream& is, Bool_t compact, Bool_t verbose = kFALSE); I/O streaming interface (machine readable). void writeToStream(ostream& os, Bool_t compact) const. void Print(Option_t* options = 0) const; Printing interface (human readable). void printMetaArgs(ostream& ) const; {}. const std::set<std::string>& attributes() const; Returns set of names of boolean attributes defined. const std::map<std::string,std::string>& stringAttributes() const; Returns std::map<string,string> with all string attributes defined. const std::set<std::string>& transientAttributes() const; Return set of transient boolean attributes. Bool_t isConstant() const; Returns true if 'Co",MatchSource.WIKI,root/html602/RooAbsArg.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsArg.html
https://root.cern/root/html602/RooAbsArg.html:1039,Usability,clear,clearing,1039,"sArg. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » ROOFIT; » ROOFITCORE; » RooAbsArg. class RooAbsArg: public TNamed, public RooPrintable. RooAbsArg is the common abstract base class for objects that; represent a value (of arbitrary type) and ""shape"" that in general; depends on (is a client of) other RooAbsArg subclasses. The only; state information about a value that is maintained in this base; class consists of named attributes and flags that track when either; the value or the shape of this object changes. The meaning of shape; depends on the client implementation but could be, for example, the; allowed range of a value. The base class is also responsible for; managing client/server links and propagating value/shape changes; through an expression tree. RooAbsArg implements public interfaces; for inspecting client/server relationships and; setting/clearing/testing named attributes.; . Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~RooAbsArg(); voidTObject::AbstractMethod(const char* method) const; Bool_taddOwnedComponents(const RooArgSet& comps); voidaddParameters(RooArgSet& params, const RooArgSet* nset = 0, Bool_t stripDisconnected = kTRUE) const; voidaddServer(RooAbsArg& server, Bool_t valueProp = kTRUE, Bool_t shapeProp = kFALSE); voidaddServerList(RooAbsCollection& serverList, Bool_t valueProp = kTRUE, Bool_t shapeProp = kFALSE); const char*aggregateCacheUniqueSuffix() const; virtual voidTObject::AppendPad(Option_t* option = """"); voidattachDataSet(const RooAbsData& set); voidattachDataStore(const RooAbsDataStore& set); const set<string>&attributes() const; voidbranchNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t recurseNonDerived = kFALSE) co",MatchSource.WIKI,root/html602/RooAbsArg.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsArg.html
https://root.cern/root/html602/RooAbsArg.html:21347,Usability,clear,clear,21347,"Function documentation; Bool_t inhibitDirty() const; { return _inhibitDirty && !_localNoInhibitDirty; }. RooAbsArg(); Default constructor. RooAbsArg(const char* name, const char* title); Create an object with the specified name and descriptive title.; The newly created object has no clients or servers and has its; dirty flags set. RooAbsArg(const RooAbsArg& other, const char* name = 0); Copy constructor transfers all boolean and string properties of the original; object. Transient properties and client-server links are not copied. ~RooAbsArg(); Destructor. void setDirtyInhibit(Bool_t flag); Control global dirty inhibit mode. When set to true no value or shape dirty; flags are propagated and cache is always considered to be dirty. void verboseDirty(Bool_t flag); Activate verbose messaging related to dirty flag propagation. Bool_t isCloneOf(const RooAbsArg& other) const; Check if this object was created as a clone of 'other'. void setAttribute(const Text_t* name, Bool_t value = kTRUE); Set (default) or clear a named boolean attribute of this object. Bool_t getAttribute(const Text_t* name) const; Check if a named attribute is set. By default, all attributes are unset. void setStringAttribute(const Text_t* key, const Text_t* value); Associate string 'value' to this object under key 'key'. const Text_t* getStringAttribute(const Text_t* key) const; Get string attribute mapped under key 'key'. Returns null pointer; if no attribute exists under that key. void setTransientAttribute(const Text_t* name, Bool_t value = kTRUE); Set (default) or clear a named boolean attribute of this object. Bool_t getTransientAttribute(const Text_t* name) const; Check if a named attribute is set. By default, all attributes; are unset. void addServer(RooAbsArg& server, Bool_t valueProp = kTRUE, Bool_t shapeProp = kFALSE); Register another RooAbsArg as a server to us, ie, declare that; we depend on it. In addition to the basic client-server relationship,; we can declare dependence on the server's",MatchSource.WIKI,root/html602/RooAbsArg.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsArg.html
https://root.cern/root/html602/RooAbsArg.html:21889,Usability,clear,clear,21889,"~RooAbsArg(); Destructor. void setDirtyInhibit(Bool_t flag); Control global dirty inhibit mode. When set to true no value or shape dirty; flags are propagated and cache is always considered to be dirty. void verboseDirty(Bool_t flag); Activate verbose messaging related to dirty flag propagation. Bool_t isCloneOf(const RooAbsArg& other) const; Check if this object was created as a clone of 'other'. void setAttribute(const Text_t* name, Bool_t value = kTRUE); Set (default) or clear a named boolean attribute of this object. Bool_t getAttribute(const Text_t* name) const; Check if a named attribute is set. By default, all attributes are unset. void setStringAttribute(const Text_t* key, const Text_t* value); Associate string 'value' to this object under key 'key'. const Text_t* getStringAttribute(const Text_t* key) const; Get string attribute mapped under key 'key'. Returns null pointer; if no attribute exists under that key. void setTransientAttribute(const Text_t* name, Bool_t value = kTRUE); Set (default) or clear a named boolean attribute of this object. Bool_t getTransientAttribute(const Text_t* name) const; Check if a named attribute is set. By default, all attributes; are unset. void addServer(RooAbsArg& server, Bool_t valueProp = kTRUE, Bool_t shapeProp = kFALSE); Register another RooAbsArg as a server to us, ie, declare that; we depend on it. In addition to the basic client-server relationship,; we can declare dependence on the server's value and/or shape. void addServerList(RooAbsCollection& serverList, Bool_t valueProp = kTRUE, Bool_t shapeProp = kFALSE); Register a list of RooAbsArg as servers to us by calls; addServer() for each arg in the list. void removeServer(RooAbsArg& server, Bool_t force = kFALSE); Unregister another RooAbsArg as a server to us, ie, declare that; we no longer depend on its value and shape. void replaceServer(RooAbsArg& oldServer, RooAbsArg& newServer, Bool_t valueProp, Bool_t shapeProp); Replace 'oldServer' with 'newServer'. void change",MatchSource.WIKI,root/html602/RooAbsArg.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsArg.html
https://root.cern/root/html602/RooAbsArg.html:45916,Usability,clear,clearValueAndShapeDirty,45916,"Bool_t isShapeDirty() const; Dirty state accessor. Bool_t isValueDirty() const; Returns true of value has been invalidated by server value change. Bool_t isValueDirtyAndClear() const; Returns true of value has been invalidated by server value change. Bool_t isValueOrShapeDirtyAndClear() const; Returns true of value has been invalidated by server value change. OperMode operMode() const; { return _operMode ; }. const RooArgSet* ownedComponents() const; { return _ownedComponents ; }. void setProhibitServerRedirect(Bool_t flag); { _prohibitServerRedirect = flag ; }. void operModeHook(); friend class RooSimCloneTool ;. {}. void optimizeDirtyHook(const RooArgSet* ); {}. void getParametersHook(const RooArgSet* , RooArgSet* , Bool_t ) const; {}. void getObservablesHook(const RooArgSet* , RooArgSet* ) const; {}. void setValueDirty() const; Dirty state modifiers. { if (_operMode==Auto && !inhibitDirty()) setValueDirty(0) ; }. void setShapeDirty() const; { setShapeDirty(0) ; }. void clearValueAndShapeDirty() const. void clearValueDirty() const. void clearShapeDirty() const. const char* cacheUniqueSuffix() const; { return 0 ; }. const TNamed* namePtr() const. Bool_t redirectServersHook(const RooAbsCollection& , Bool_t , Bool_t , Bool_t ); { return kFALSE ; }. void serverNameChangeHook(const RooAbsArg* , const RooAbsArg* ); { }. void setExpensiveObjectCache(RooExpensiveObjectCache& cache); { _eocache = &cache ; }. Bool_t importWorkspaceHook(RooWorkspace& ); { return kFALSE ; }. void syncCache(const RooArgSet* nset = 0). void copyCache(const RooAbsArg* source, Bool_t valueOnly = kFALSE, Bool_t setValDirty = kTRUE). void attachToVStore(RooVectorDataStore& vstore). void setTreeBranchStatus(TTree& t, Bool_t active). void fillTreeBranch(TTree& t). void setLocalNoDirtyInhibit(Bool_t flag) const; { _localNoInhibitDirty = flag ; }. Bool_t localNoDirtyInhibit() const; { return _localNoInhibitDirty ; }. » Last changed: Tue Jun 30 14:29:52 2015 » Last generated: 2015-06-30 14:29; This page",MatchSource.WIKI,root/html602/RooAbsArg.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsArg.html
https://root.cern/root/html602/RooAbsArg.html:45954,Usability,clear,clearValueDirty,45954," state accessor. Bool_t isValueDirty() const; Returns true of value has been invalidated by server value change. Bool_t isValueDirtyAndClear() const; Returns true of value has been invalidated by server value change. Bool_t isValueOrShapeDirtyAndClear() const; Returns true of value has been invalidated by server value change. OperMode operMode() const; { return _operMode ; }. const RooArgSet* ownedComponents() const; { return _ownedComponents ; }. void setProhibitServerRedirect(Bool_t flag); { _prohibitServerRedirect = flag ; }. void operModeHook(); friend class RooSimCloneTool ;. {}. void optimizeDirtyHook(const RooArgSet* ); {}. void getParametersHook(const RooArgSet* , RooArgSet* , Bool_t ) const; {}. void getObservablesHook(const RooArgSet* , RooArgSet* ) const; {}. void setValueDirty() const; Dirty state modifiers. { if (_operMode==Auto && !inhibitDirty()) setValueDirty(0) ; }. void setShapeDirty() const; { setShapeDirty(0) ; }. void clearValueAndShapeDirty() const. void clearValueDirty() const. void clearShapeDirty() const. const char* cacheUniqueSuffix() const; { return 0 ; }. const TNamed* namePtr() const. Bool_t redirectServersHook(const RooAbsCollection& , Bool_t , Bool_t , Bool_t ); { return kFALSE ; }. void serverNameChangeHook(const RooAbsArg* , const RooAbsArg* ); { }. void setExpensiveObjectCache(RooExpensiveObjectCache& cache); { _eocache = &cache ; }. Bool_t importWorkspaceHook(RooWorkspace& ); { return kFALSE ; }. void syncCache(const RooArgSet* nset = 0). void copyCache(const RooAbsArg* source, Bool_t valueOnly = kFALSE, Bool_t setValDirty = kTRUE). void attachToVStore(RooVectorDataStore& vstore). void setTreeBranchStatus(TTree& t, Bool_t active). void fillTreeBranch(TTree& t). void setLocalNoDirtyInhibit(Bool_t flag) const; { _localNoInhibitDirty = flag ; }. Bool_t localNoDirtyInhibit() const; { return _localNoInhibitDirty ; }. » Last changed: Tue Jun 30 14:29:52 2015 » Last generated: 2015-06-30 14:29; This page has been automatically generated.",MatchSource.WIKI,root/html602/RooAbsArg.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsArg.html
https://root.cern/root/html602/RooAbsArg.html:45984,Usability,clear,clearShapeDirty,45984,"eDirty() const; Returns true of value has been invalidated by server value change. Bool_t isValueDirtyAndClear() const; Returns true of value has been invalidated by server value change. Bool_t isValueOrShapeDirtyAndClear() const; Returns true of value has been invalidated by server value change. OperMode operMode() const; { return _operMode ; }. const RooArgSet* ownedComponents() const; { return _ownedComponents ; }. void setProhibitServerRedirect(Bool_t flag); { _prohibitServerRedirect = flag ; }. void operModeHook(); friend class RooSimCloneTool ;. {}. void optimizeDirtyHook(const RooArgSet* ); {}. void getParametersHook(const RooArgSet* , RooArgSet* , Bool_t ) const; {}. void getObservablesHook(const RooArgSet* , RooArgSet* ) const; {}. void setValueDirty() const; Dirty state modifiers. { if (_operMode==Auto && !inhibitDirty()) setValueDirty(0) ; }. void setShapeDirty() const; { setShapeDirty(0) ; }. void clearValueAndShapeDirty() const. void clearValueDirty() const. void clearShapeDirty() const. const char* cacheUniqueSuffix() const; { return 0 ; }. const TNamed* namePtr() const. Bool_t redirectServersHook(const RooAbsCollection& , Bool_t , Bool_t , Bool_t ); { return kFALSE ; }. void serverNameChangeHook(const RooAbsArg* , const RooAbsArg* ); { }. void setExpensiveObjectCache(RooExpensiveObjectCache& cache); { _eocache = &cache ; }. Bool_t importWorkspaceHook(RooWorkspace& ); { return kFALSE ; }. void syncCache(const RooArgSet* nset = 0). void copyCache(const RooAbsArg* source, Bool_t valueOnly = kFALSE, Bool_t setValDirty = kTRUE). void attachToVStore(RooVectorDataStore& vstore). void setTreeBranchStatus(TTree& t, Bool_t active). void fillTreeBranch(TTree& t). void setLocalNoDirtyInhibit(Bool_t flag) const; { _localNoInhibitDirty = flag ; }. Bool_t localNoDirtyInhibit() const; { return _localNoInhibitDirty ; }. » Last changed: Tue Jun 30 14:29:52 2015 » Last generated: 2015-06-30 14:29; This page has been automatically generated. For comments or suggestions r",MatchSource.WIKI,root/html602/RooAbsArg.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsArg.html
https://root.cern/root/html602/RooAbsBinning.html:615,Availability,avail,available,615,". RooAbsBinning. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » ROOFIT; » ROOFITCORE; » RooAbsBinning. class RooAbsBinning: public TNamed, public RooPrintable. RooAbsBinning is the abstract base class for RooRealVar binning definitions; This class defines the interface to retrieve bin boundaries, ranges etc.; . Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~RooAbsBinning(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual Double_t*array() const; virtual Double_taverageBinWidth() const; virtual Double_tbinCenter(Int_t bin) const; virtual Double_tbinHigh(Int_t bin) const; virtual Double_tbinLow(Int_t bin) const; virtual Int_tbinNumber(Double_t x) const; virtual Double_tbinWidth(Int_t bin) const; virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*Clone(const char* newname = 0) const; virtual RooAbsBinning*clone(const char* name = 0) const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual Int_tRooPrintable::defaultPrintContents(Option_t* opt) const; static ostream&RooPrintable::defaultPrintStream(ostream* os = 0); virtual RooPrintable::StyleOptionRooPrintable::defaultPrintStyle(Option_t* opt) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual",MatchSource.WIKI,root/html602/RooAbsBinning.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsBinning.html
https://root.cern/root/html602/RooAbsBinning.html:2144,Availability,error,error,2144," char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*Clone(const char* newname = 0) const; virtual RooAbsBinning*clone(const char* name = 0) const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual Int_tRooPrintable::defaultPrintContents(Option_t* opt) const; static ostream&RooPrintable::defaultPrintStream(ostream* os = 0); virtual RooPrintable::StyleOptionRooPrintable::defaultPrintStyle(Option_t* opt) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual const char*TNamed::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual const char*TNamed::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTNamed::Hash() const; virtual Double_thighBound() const; virtual RooAbsReal*highBoundFunc() const; virtual voidTO",MatchSource.WIKI,root/html602/RooAbsBinning.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsBinning.html
https://root.cern/root/html602/RooAbsBinning.html:2228,Availability,error,error,2228,"virtual TObject*Clone(const char* newname = 0) const; virtual RooAbsBinning*clone(const char* name = 0) const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual Int_tRooPrintable::defaultPrintContents(Option_t* opt) const; static ostream&RooPrintable::defaultPrintStream(ostream* os = 0); virtual RooPrintable::StyleOptionRooPrintable::defaultPrintStyle(Option_t* opt) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual const char*TNamed::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual const char*TNamed::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTNamed::Hash() const; virtual Double_thighBound() const; virtual RooAbsReal*highBoundFunc() const; virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::In",MatchSource.WIKI,root/html602/RooAbsBinning.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsBinning.html
https://root.cern/root/html602/RooAbsBinning.html:428,Integrability,interface,interface,428,". RooAbsBinning. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » ROOFIT; » ROOFITCORE; » RooAbsBinning. class RooAbsBinning: public TNamed, public RooPrintable. RooAbsBinning is the abstract base class for RooRealVar binning definitions; This class defines the interface to retrieve bin boundaries, ranges etc.; . Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~RooAbsBinning(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual Double_t*array() const; virtual Double_taverageBinWidth() const; virtual Double_tbinCenter(Int_t bin) const; virtual Double_tbinHigh(Int_t bin) const; virtual Double_tbinLow(Int_t bin) const; virtual Int_tbinNumber(Double_t x) const; virtual Double_tbinWidth(Int_t bin) const; virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*Clone(const char* newname = 0) const; virtual RooAbsBinning*clone(const char* name = 0) const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual Int_tRooPrintable::defaultPrintContents(Option_t* opt) const; static ostream&RooPrintable::defaultPrintStream(ostream* os = 0); virtual RooPrintable::StyleOptionRooPrintable::defaultPrintStyle(Option_t* opt) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual",MatchSource.WIKI,root/html602/RooAbsBinning.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsBinning.html
https://root.cern/root/html602/RooAbsBinning.html:10465,Integrability,interface,interface,10465,"daries for parameterized binning implementations. void printValue(ostream& os) const; Print binning value, i.e the bin boundary positions. void Streamer(TBuffer& ); Custom streamer implementing schema evolution between V1 and V2 persistent binnings. RooAbsBinning(const char* name = 0). TObject* Clone(const char* newname = 0) const; { return clone(newname) ; }. RooAbsBinning* clone(const char* name = 0) const. Int_t numBins() const; Return number of bins. return numBoundaries(). Int_t binNumber(Double_t x) const. Int_t rawBinNumber(Double_t x) const; { return binNumber(x) ; }. Double_t binCenter(Int_t bin) const. Double_t binWidth(Int_t bin) const. Double_t binLow(Int_t bin) const. Double_t binHigh(Int_t bin) const. Bool_t isUniform() const; { return kFALSE ; }. void setRange(Double_t xlo, Double_t xhi). void setMin(Double_t xlo); Change lower bound to xlo. void setMax(Double_t xhi); Change upper bound to xhi. Double_t lowBound() const. Double_t highBound() const. Double_t averageBinWidth() const. Double_t* array() const. void Print(Option_t* options = 0) const; Printing interface. Bool_t isParameterized() const; Interface function. If true, min/max of binning is parameterized by external RooAbsReals. RooAbsReal* lowBoundFunc() const; Return pointer to RooAbsReal parameterized lower bound, if any. RooAbsReal* highBoundFunc() const; Return pointer to RooAbsReal parameterized upper bound, if any. Bool_t isShareable() const; If true (default) range definition can be shared across clones of a RooRealVar. void insertHook(RooAbsRealLValue& ) const; Hook interface function to execute code upon insertion into a RooAbsRealLValue. void removeHook(RooAbsRealLValue& ) const; Hook interface functionto execute code upon removal from a RooAbsRealLValue. » Last changed: Tue Jun 30 14:29:52 2015 » Last generated: 2015-06-30 14:29; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html602/RooAbsBinning.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsBinning.html
https://root.cern/root/html602/RooAbsBinning.html:10951,Integrability,interface,interface,10951,"daries for parameterized binning implementations. void printValue(ostream& os) const; Print binning value, i.e the bin boundary positions. void Streamer(TBuffer& ); Custom streamer implementing schema evolution between V1 and V2 persistent binnings. RooAbsBinning(const char* name = 0). TObject* Clone(const char* newname = 0) const; { return clone(newname) ; }. RooAbsBinning* clone(const char* name = 0) const. Int_t numBins() const; Return number of bins. return numBoundaries(). Int_t binNumber(Double_t x) const. Int_t rawBinNumber(Double_t x) const; { return binNumber(x) ; }. Double_t binCenter(Int_t bin) const. Double_t binWidth(Int_t bin) const. Double_t binLow(Int_t bin) const. Double_t binHigh(Int_t bin) const. Bool_t isUniform() const; { return kFALSE ; }. void setRange(Double_t xlo, Double_t xhi). void setMin(Double_t xlo); Change lower bound to xlo. void setMax(Double_t xhi); Change upper bound to xhi. Double_t lowBound() const. Double_t highBound() const. Double_t averageBinWidth() const. Double_t* array() const. void Print(Option_t* options = 0) const; Printing interface. Bool_t isParameterized() const; Interface function. If true, min/max of binning is parameterized by external RooAbsReals. RooAbsReal* lowBoundFunc() const; Return pointer to RooAbsReal parameterized lower bound, if any. RooAbsReal* highBoundFunc() const; Return pointer to RooAbsReal parameterized upper bound, if any. Bool_t isShareable() const; If true (default) range definition can be shared across clones of a RooRealVar. void insertHook(RooAbsRealLValue& ) const; Hook interface function to execute code upon insertion into a RooAbsRealLValue. void removeHook(RooAbsRealLValue& ) const; Hook interface functionto execute code upon removal from a RooAbsRealLValue. » Last changed: Tue Jun 30 14:29:52 2015 » Last generated: 2015-06-30 14:29; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html602/RooAbsBinning.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsBinning.html
https://root.cern/root/html602/RooAbsBinning.html:11074,Integrability,interface,interface,11074,"daries for parameterized binning implementations. void printValue(ostream& os) const; Print binning value, i.e the bin boundary positions. void Streamer(TBuffer& ); Custom streamer implementing schema evolution between V1 and V2 persistent binnings. RooAbsBinning(const char* name = 0). TObject* Clone(const char* newname = 0) const; { return clone(newname) ; }. RooAbsBinning* clone(const char* name = 0) const. Int_t numBins() const; Return number of bins. return numBoundaries(). Int_t binNumber(Double_t x) const. Int_t rawBinNumber(Double_t x) const; { return binNumber(x) ; }. Double_t binCenter(Int_t bin) const. Double_t binWidth(Int_t bin) const. Double_t binLow(Int_t bin) const. Double_t binHigh(Int_t bin) const. Bool_t isUniform() const; { return kFALSE ; }. void setRange(Double_t xlo, Double_t xhi). void setMin(Double_t xlo); Change lower bound to xlo. void setMax(Double_t xhi); Change upper bound to xhi. Double_t lowBound() const. Double_t highBound() const. Double_t averageBinWidth() const. Double_t* array() const. void Print(Option_t* options = 0) const; Printing interface. Bool_t isParameterized() const; Interface function. If true, min/max of binning is parameterized by external RooAbsReals. RooAbsReal* lowBoundFunc() const; Return pointer to RooAbsReal parameterized lower bound, if any. RooAbsReal* highBoundFunc() const; Return pointer to RooAbsReal parameterized upper bound, if any. Bool_t isShareable() const; If true (default) range definition can be shared across clones of a RooRealVar. void insertHook(RooAbsRealLValue& ) const; Hook interface function to execute code upon insertion into a RooAbsRealLValue. void removeHook(RooAbsRealLValue& ) const; Hook interface functionto execute code upon removal from a RooAbsRealLValue. » Last changed: Tue Jun 30 14:29:52 2015 » Last generated: 2015-06-30 14:29; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html602/RooAbsBinning.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsBinning.html
https://root.cern/root/html602/RooAbsBinning.html:9361,Modifiability,variab,variable,9361," static RooPrintable::StyleOptionRooPrintable::kSingleLine; static RooPrintable::StyleOptionRooPrintable::kStandard; static RooPrintable::ContentsOptionRooPrintable::kTitle; static RooPrintable::StyleOptionRooPrintable::kTreeStructure; static RooPrintable::ContentsOptionRooPrintable::kValue; static RooPrintable::StyleOptionRooPrintable::kVerbose; static TObject::(anonymous)TObject::kWriteDelete; static TObject::(anonymous)TObject::kZombie. protected:. static Int_tRooPrintable::_nameLength; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; RooAbsBinning(const char* name = 0); Constructor. ~RooAbsBinning(); Destructor. void printName(ostream& os) const; Print binning name. void printTitle(ostream& os) const; Print binning title. void printClassName(ostream& os) const; Print binning class name. void printArgs(ostream& os) const; Print binning arguments (the RooAbsReal objects represening; the variable bin boundaries for parameterized binning implementations. void printValue(ostream& os) const; Print binning value, i.e the bin boundary positions. void Streamer(TBuffer& ); Custom streamer implementing schema evolution between V1 and V2 persistent binnings. RooAbsBinning(const char* name = 0). TObject* Clone(const char* newname = 0) const; { return clone(newname) ; }. RooAbsBinning* clone(const char* name = 0) const. Int_t numBins() const; Return number of bins. return numBoundaries(). Int_t binNumber(Double_t x) const. Int_t rawBinNumber(Double_t x) const; { return binNumber(x) ; }. Double_t binCenter(Int_t bin) const. Double_t binWidth(Int_t bin) const. Double_t binLow(Int_t bin) const. Double_t binHigh(Int_t bin) const. Bool_t isUniform() const; { return kFALSE ; }. void setRange(Double_t xlo, Double_t xhi). void setMin(Double_t xlo); Change lower bound to xlo. void setMax(Double_t xhi); Change upper bound to xhi. Double_t lowBound() const. Double_t highBou",MatchSource.WIKI,root/html602/RooAbsBinning.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsBinning.html
https://root.cern/root/html602/RooAbsBinning.html:9389,Modifiability,parameteriz,parameterized,9389," static RooPrintable::StyleOptionRooPrintable::kSingleLine; static RooPrintable::StyleOptionRooPrintable::kStandard; static RooPrintable::ContentsOptionRooPrintable::kTitle; static RooPrintable::StyleOptionRooPrintable::kTreeStructure; static RooPrintable::ContentsOptionRooPrintable::kValue; static RooPrintable::StyleOptionRooPrintable::kVerbose; static TObject::(anonymous)TObject::kWriteDelete; static TObject::(anonymous)TObject::kZombie. protected:. static Int_tRooPrintable::_nameLength; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; RooAbsBinning(const char* name = 0); Constructor. ~RooAbsBinning(); Destructor. void printName(ostream& os) const; Print binning name. void printTitle(ostream& os) const; Print binning title. void printClassName(ostream& os) const; Print binning class name. void printArgs(ostream& os) const; Print binning arguments (the RooAbsReal objects represening; the variable bin boundaries for parameterized binning implementations. void printValue(ostream& os) const; Print binning value, i.e the bin boundary positions. void Streamer(TBuffer& ); Custom streamer implementing schema evolution between V1 and V2 persistent binnings. RooAbsBinning(const char* name = 0). TObject* Clone(const char* newname = 0) const; { return clone(newname) ; }. RooAbsBinning* clone(const char* name = 0) const. Int_t numBins() const; Return number of bins. return numBoundaries(). Int_t binNumber(Double_t x) const. Int_t rawBinNumber(Double_t x) const; { return binNumber(x) ; }. Double_t binCenter(Int_t bin) const. Double_t binWidth(Int_t bin) const. Double_t binLow(Int_t bin) const. Double_t binHigh(Int_t bin) const. Bool_t isUniform() const; { return kFALSE ; }. void setRange(Double_t xlo, Double_t xhi). void setMin(Double_t xlo); Change lower bound to xlo. void setMax(Double_t xhi); Change upper bound to xhi. Double_t lowBound() const. Double_t highBou",MatchSource.WIKI,root/html602/RooAbsBinning.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsBinning.html
https://root.cern/root/html602/RooAbsBinning.html:10559,Modifiability,parameteriz,parameterized,10559,"daries for parameterized binning implementations. void printValue(ostream& os) const; Print binning value, i.e the bin boundary positions. void Streamer(TBuffer& ); Custom streamer implementing schema evolution between V1 and V2 persistent binnings. RooAbsBinning(const char* name = 0). TObject* Clone(const char* newname = 0) const; { return clone(newname) ; }. RooAbsBinning* clone(const char* name = 0) const. Int_t numBins() const; Return number of bins. return numBoundaries(). Int_t binNumber(Double_t x) const. Int_t rawBinNumber(Double_t x) const; { return binNumber(x) ; }. Double_t binCenter(Int_t bin) const. Double_t binWidth(Int_t bin) const. Double_t binLow(Int_t bin) const. Double_t binHigh(Int_t bin) const. Bool_t isUniform() const; { return kFALSE ; }. void setRange(Double_t xlo, Double_t xhi). void setMin(Double_t xlo); Change lower bound to xlo. void setMax(Double_t xhi); Change upper bound to xhi. Double_t lowBound() const. Double_t highBound() const. Double_t averageBinWidth() const. Double_t* array() const. void Print(Option_t* options = 0) const; Printing interface. Bool_t isParameterized() const; Interface function. If true, min/max of binning is parameterized by external RooAbsReals. RooAbsReal* lowBoundFunc() const; Return pointer to RooAbsReal parameterized lower bound, if any. RooAbsReal* highBoundFunc() const; Return pointer to RooAbsReal parameterized upper bound, if any. Bool_t isShareable() const; If true (default) range definition can be shared across clones of a RooRealVar. void insertHook(RooAbsRealLValue& ) const; Hook interface function to execute code upon insertion into a RooAbsRealLValue. void removeHook(RooAbsRealLValue& ) const; Hook interface functionto execute code upon removal from a RooAbsRealLValue. » Last changed: Tue Jun 30 14:29:52 2015 » Last generated: 2015-06-30 14:29; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html602/RooAbsBinning.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsBinning.html
https://root.cern/root/html602/RooAbsBinning.html:10661,Modifiability,parameteriz,parameterized,10661,"daries for parameterized binning implementations. void printValue(ostream& os) const; Print binning value, i.e the bin boundary positions. void Streamer(TBuffer& ); Custom streamer implementing schema evolution between V1 and V2 persistent binnings. RooAbsBinning(const char* name = 0). TObject* Clone(const char* newname = 0) const; { return clone(newname) ; }. RooAbsBinning* clone(const char* name = 0) const. Int_t numBins() const; Return number of bins. return numBoundaries(). Int_t binNumber(Double_t x) const. Int_t rawBinNumber(Double_t x) const; { return binNumber(x) ; }. Double_t binCenter(Int_t bin) const. Double_t binWidth(Int_t bin) const. Double_t binLow(Int_t bin) const. Double_t binHigh(Int_t bin) const. Bool_t isUniform() const; { return kFALSE ; }. void setRange(Double_t xlo, Double_t xhi). void setMin(Double_t xlo); Change lower bound to xlo. void setMax(Double_t xhi); Change upper bound to xhi. Double_t lowBound() const. Double_t highBound() const. Double_t averageBinWidth() const. Double_t* array() const. void Print(Option_t* options = 0) const; Printing interface. Bool_t isParameterized() const; Interface function. If true, min/max of binning is parameterized by external RooAbsReals. RooAbsReal* lowBoundFunc() const; Return pointer to RooAbsReal parameterized lower bound, if any. RooAbsReal* highBoundFunc() const; Return pointer to RooAbsReal parameterized upper bound, if any. Bool_t isShareable() const; If true (default) range definition can be shared across clones of a RooRealVar. void insertHook(RooAbsRealLValue& ) const; Hook interface function to execute code upon insertion into a RooAbsRealLValue. void removeHook(RooAbsRealLValue& ) const; Hook interface functionto execute code upon removal from a RooAbsRealLValue. » Last changed: Tue Jun 30 14:29:52 2015 » Last generated: 2015-06-30 14:29; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html602/RooAbsBinning.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsBinning.html
https://root.cern/root/html602/RooAbsBinning.html:10760,Modifiability,parameteriz,parameterized,10760,"daries for parameterized binning implementations. void printValue(ostream& os) const; Print binning value, i.e the bin boundary positions. void Streamer(TBuffer& ); Custom streamer implementing schema evolution between V1 and V2 persistent binnings. RooAbsBinning(const char* name = 0). TObject* Clone(const char* newname = 0) const; { return clone(newname) ; }. RooAbsBinning* clone(const char* name = 0) const. Int_t numBins() const; Return number of bins. return numBoundaries(). Int_t binNumber(Double_t x) const. Int_t rawBinNumber(Double_t x) const; { return binNumber(x) ; }. Double_t binCenter(Int_t bin) const. Double_t binWidth(Int_t bin) const. Double_t binLow(Int_t bin) const. Double_t binHigh(Int_t bin) const. Bool_t isUniform() const; { return kFALSE ; }. void setRange(Double_t xlo, Double_t xhi). void setMin(Double_t xlo); Change lower bound to xlo. void setMax(Double_t xhi); Change upper bound to xhi. Double_t lowBound() const. Double_t highBound() const. Double_t averageBinWidth() const. Double_t* array() const. void Print(Option_t* options = 0) const; Printing interface. Bool_t isParameterized() const; Interface function. If true, min/max of binning is parameterized by external RooAbsReals. RooAbsReal* lowBoundFunc() const; Return pointer to RooAbsReal parameterized lower bound, if any. RooAbsReal* highBoundFunc() const; Return pointer to RooAbsReal parameterized upper bound, if any. Bool_t isShareable() const; If true (default) range definition can be shared across clones of a RooRealVar. void insertHook(RooAbsRealLValue& ) const; Hook interface function to execute code upon insertion into a RooAbsRealLValue. void removeHook(RooAbsRealLValue& ) const; Hook interface functionto execute code upon removal from a RooAbsRealLValue. » Last changed: Tue Jun 30 14:29:52 2015 » Last generated: 2015-06-30 14:29; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html602/RooAbsBinning.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsBinning.html
https://root.cern/root/html602/RooAbsCache.html:426,Integrability,interface,interface,426,". RooAbsCache. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » ROOFIT; » ROOFITCORE; » RooAbsCache. class RooAbsCache. RooAbsCache is the abstract base class for data members of RooAbsArgs; that cache other (composite) RooAbsArg expressions. The RooAbsCache; interface defines the interaction between the owning RooAbsArg object; and the cache data member to communicate server redirects, operation; mode changes and constant term optimization management calls.; . Function Members (Methods); public:. virtual~RooAbsCache(); static TClass*Class(); virtual voidfindConstantNodes(const RooArgSet&, RooArgSet&, RooLinkedList&); virtual TClass*IsA() const; RooAbsCache&operator=(const RooAbsCache&); virtual voidoperModeHook(); virtual voidoptimizeCacheMode(const RooArgSet&, RooArgSet&, RooLinkedList&); virtual voidprintCompactTreeHook(ostream&, const char*); virtual Bool_tredirectServersHook(const RooAbsCollection&, Bool_t, Bool_t, Bool_t); RooAbsCache(RooAbsArg* owner = 0); RooAbsCache(const RooAbsCache&, RooAbsArg* owner = 0); virtual voidShowMembers(TMemberInspector& insp) const; virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); virtual voidwireCache(). Data Members; protected:. RooAbsArg*_ownerPointer to owning RooAbsArg. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; RooAbsCache(RooAbsArg* owner = 0); Constructor. Takes owner as argument and register cache with owner. RooAbsCache(const RooAbsCache& , RooAbsArg* owner = 0); Copy constructor. Takes owner as argument and registers cache with owne. ~RooAbsCache(); Destructor. Unregisters cache with owner. void optimizeCacheMode(const RooArgSet& , RooArgSet& , RooLinkedList& ); Interface for processing of cache mode optimization calls. Bool_t redirectServersHook(const RooAbsCollect",MatchSource.WIKI,root/html602/RooAbsCache.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsCache.html
https://root.cern/root/html602/RooAbsCache.html:362,Performance,cache,cache,362,". RooAbsCache. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » ROOFIT; » ROOFITCORE; » RooAbsCache. class RooAbsCache. RooAbsCache is the abstract base class for data members of RooAbsArgs; that cache other (composite) RooAbsArg expressions. The RooAbsCache; interface defines the interaction between the owning RooAbsArg object; and the cache data member to communicate server redirects, operation; mode changes and constant term optimization management calls.; . Function Members (Methods); public:. virtual~RooAbsCache(); static TClass*Class(); virtual voidfindConstantNodes(const RooArgSet&, RooArgSet&, RooLinkedList&); virtual TClass*IsA() const; RooAbsCache&operator=(const RooAbsCache&); virtual voidoperModeHook(); virtual voidoptimizeCacheMode(const RooArgSet&, RooArgSet&, RooLinkedList&); virtual voidprintCompactTreeHook(ostream&, const char*); virtual Bool_tredirectServersHook(const RooAbsCollection&, Bool_t, Bool_t, Bool_t); RooAbsCache(RooAbsArg* owner = 0); RooAbsCache(const RooAbsCache&, RooAbsArg* owner = 0); virtual voidShowMembers(TMemberInspector& insp) const; virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); virtual voidwireCache(). Data Members; protected:. RooAbsArg*_ownerPointer to owning RooAbsArg. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; RooAbsCache(RooAbsArg* owner = 0); Constructor. Takes owner as argument and register cache with owner. RooAbsCache(const RooAbsCache& , RooAbsArg* owner = 0); Copy constructor. Takes owner as argument and registers cache with owne. ~RooAbsCache(); Destructor. Unregisters cache with owner. void optimizeCacheMode(const RooArgSet& , RooArgSet& , RooLinkedList& ); Interface for processing of cache mode optimization calls. Bool_t redirectServersHook(const RooAbsCollect",MatchSource.WIKI,root/html602/RooAbsCache.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsCache.html
https://root.cern/root/html602/RooAbsCache.html:505,Performance,cache,cache,505,". RooAbsCache. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » ROOFIT; » ROOFITCORE; » RooAbsCache. class RooAbsCache. RooAbsCache is the abstract base class for data members of RooAbsArgs; that cache other (composite) RooAbsArg expressions. The RooAbsCache; interface defines the interaction between the owning RooAbsArg object; and the cache data member to communicate server redirects, operation; mode changes and constant term optimization management calls.; . Function Members (Methods); public:. virtual~RooAbsCache(); static TClass*Class(); virtual voidfindConstantNodes(const RooArgSet&, RooArgSet&, RooLinkedList&); virtual TClass*IsA() const; RooAbsCache&operator=(const RooAbsCache&); virtual voidoperModeHook(); virtual voidoptimizeCacheMode(const RooArgSet&, RooArgSet&, RooLinkedList&); virtual voidprintCompactTreeHook(ostream&, const char*); virtual Bool_tredirectServersHook(const RooAbsCollection&, Bool_t, Bool_t, Bool_t); RooAbsCache(RooAbsArg* owner = 0); RooAbsCache(const RooAbsCache&, RooAbsArg* owner = 0); virtual voidShowMembers(TMemberInspector& insp) const; virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); virtual voidwireCache(). Data Members; protected:. RooAbsArg*_ownerPointer to owning RooAbsArg. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; RooAbsCache(RooAbsArg* owner = 0); Constructor. Takes owner as argument and register cache with owner. RooAbsCache(const RooAbsCache& , RooAbsArg* owner = 0); Copy constructor. Takes owner as argument and registers cache with owne. ~RooAbsCache(); Destructor. Unregisters cache with owner. void optimizeCacheMode(const RooArgSet& , RooArgSet& , RooLinkedList& ); Interface for processing of cache mode optimization calls. Bool_t redirectServersHook(const RooAbsCollect",MatchSource.WIKI,root/html602/RooAbsCache.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsCache.html
https://root.cern/root/html602/RooAbsCache.html:598,Performance,optimiz,optimization,598,". RooAbsCache. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » ROOFIT; » ROOFITCORE; » RooAbsCache. class RooAbsCache. RooAbsCache is the abstract base class for data members of RooAbsArgs; that cache other (composite) RooAbsArg expressions. The RooAbsCache; interface defines the interaction between the owning RooAbsArg object; and the cache data member to communicate server redirects, operation; mode changes and constant term optimization management calls.; . Function Members (Methods); public:. virtual~RooAbsCache(); static TClass*Class(); virtual voidfindConstantNodes(const RooArgSet&, RooArgSet&, RooLinkedList&); virtual TClass*IsA() const; RooAbsCache&operator=(const RooAbsCache&); virtual voidoperModeHook(); virtual voidoptimizeCacheMode(const RooArgSet&, RooArgSet&, RooLinkedList&); virtual voidprintCompactTreeHook(ostream&, const char*); virtual Bool_tredirectServersHook(const RooAbsCollection&, Bool_t, Bool_t, Bool_t); RooAbsCache(RooAbsArg* owner = 0); RooAbsCache(const RooAbsCache&, RooAbsArg* owner = 0); virtual voidShowMembers(TMemberInspector& insp) const; virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); virtual voidwireCache(). Data Members; protected:. RooAbsArg*_ownerPointer to owning RooAbsArg. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; RooAbsCache(RooAbsArg* owner = 0); Constructor. Takes owner as argument and register cache with owner. RooAbsCache(const RooAbsCache& , RooAbsArg* owner = 0); Copy constructor. Takes owner as argument and registers cache with owne. ~RooAbsCache(); Destructor. Unregisters cache with owner. void optimizeCacheMode(const RooArgSet& , RooArgSet& , RooLinkedList& ); Interface for processing of cache mode optimization calls. Bool_t redirectServersHook(const RooAbsCollect",MatchSource.WIKI,root/html602/RooAbsCache.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsCache.html
https://root.cern/root/html602/RooAbsCache.html:1618,Performance,cache,cache,1618,"ion management calls.; . Function Members (Methods); public:. virtual~RooAbsCache(); static TClass*Class(); virtual voidfindConstantNodes(const RooArgSet&, RooArgSet&, RooLinkedList&); virtual TClass*IsA() const; RooAbsCache&operator=(const RooAbsCache&); virtual voidoperModeHook(); virtual voidoptimizeCacheMode(const RooArgSet&, RooArgSet&, RooLinkedList&); virtual voidprintCompactTreeHook(ostream&, const char*); virtual Bool_tredirectServersHook(const RooAbsCollection&, Bool_t, Bool_t, Bool_t); RooAbsCache(RooAbsArg* owner = 0); RooAbsCache(const RooAbsCache&, RooAbsArg* owner = 0); virtual voidShowMembers(TMemberInspector& insp) const; virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); virtual voidwireCache(). Data Members; protected:. RooAbsArg*_ownerPointer to owning RooAbsArg. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; RooAbsCache(RooAbsArg* owner = 0); Constructor. Takes owner as argument and register cache with owner. RooAbsCache(const RooAbsCache& , RooAbsArg* owner = 0); Copy constructor. Takes owner as argument and registers cache with owne. ~RooAbsCache(); Destructor. Unregisters cache with owner. void optimizeCacheMode(const RooArgSet& , RooArgSet& , RooLinkedList& ); Interface for processing of cache mode optimization calls. Bool_t redirectServersHook(const RooAbsCollection& , Bool_t , Bool_t , Bool_t ); Interface for server redirect calls. void operModeHook(); Interface for operation mode changes. void findConstantNodes(const RooArgSet& , RooArgSet& , RooLinkedList& ); Interface for constant term node finding calls. void printCompactTreeHook(ostream& , const char* ); Interface for printing of cache guts in tree mode printing. void wireCache(); {}. » Last changed: Tue Jun 30 14:29:53 2015 » Last generated: 2015-06-30 14:29; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROO",MatchSource.WIKI,root/html602/RooAbsCache.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsCache.html
https://root.cern/root/html602/RooAbsCache.html:1748,Performance,cache,cache,1748,"nt calls.; . Function Members (Methods); public:. virtual~RooAbsCache(); static TClass*Class(); virtual voidfindConstantNodes(const RooArgSet&, RooArgSet&, RooLinkedList&); virtual TClass*IsA() const; RooAbsCache&operator=(const RooAbsCache&); virtual voidoperModeHook(); virtual voidoptimizeCacheMode(const RooArgSet&, RooArgSet&, RooLinkedList&); virtual voidprintCompactTreeHook(ostream&, const char*); virtual Bool_tredirectServersHook(const RooAbsCollection&, Bool_t, Bool_t, Bool_t); RooAbsCache(RooAbsArg* owner = 0); RooAbsCache(const RooAbsCache&, RooAbsArg* owner = 0); virtual voidShowMembers(TMemberInspector& insp) const; virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); virtual voidwireCache(). Data Members; protected:. RooAbsArg*_ownerPointer to owning RooAbsArg. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; RooAbsCache(RooAbsArg* owner = 0); Constructor. Takes owner as argument and register cache with owner. RooAbsCache(const RooAbsCache& , RooAbsArg* owner = 0); Copy constructor. Takes owner as argument and registers cache with owne. ~RooAbsCache(); Destructor. Unregisters cache with owner. void optimizeCacheMode(const RooArgSet& , RooArgSet& , RooLinkedList& ); Interface for processing of cache mode optimization calls. Bool_t redirectServersHook(const RooAbsCollection& , Bool_t , Bool_t , Bool_t ); Interface for server redirect calls. void operModeHook(); Interface for operation mode changes. void findConstantNodes(const RooArgSet& , RooArgSet& , RooLinkedList& ); Interface for constant term node finding calls. void printCompactTreeHook(ostream& , const char* ); Interface for printing of cache guts in tree mode printing. void wireCache(); {}. » Last changed: Tue Jun 30 14:29:53 2015 » Last generated: 2015-06-30 14:29; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html602/RooAbsCache.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsCache.html
https://root.cern/root/html602/RooAbsCache.html:1805,Performance,cache,cache,1805,"nt calls.; . Function Members (Methods); public:. virtual~RooAbsCache(); static TClass*Class(); virtual voidfindConstantNodes(const RooArgSet&, RooArgSet&, RooLinkedList&); virtual TClass*IsA() const; RooAbsCache&operator=(const RooAbsCache&); virtual voidoperModeHook(); virtual voidoptimizeCacheMode(const RooArgSet&, RooArgSet&, RooLinkedList&); virtual voidprintCompactTreeHook(ostream&, const char*); virtual Bool_tredirectServersHook(const RooAbsCollection&, Bool_t, Bool_t, Bool_t); RooAbsCache(RooAbsArg* owner = 0); RooAbsCache(const RooAbsCache&, RooAbsArg* owner = 0); virtual voidShowMembers(TMemberInspector& insp) const; virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); virtual voidwireCache(). Data Members; protected:. RooAbsArg*_ownerPointer to owning RooAbsArg. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; RooAbsCache(RooAbsArg* owner = 0); Constructor. Takes owner as argument and register cache with owner. RooAbsCache(const RooAbsCache& , RooAbsArg* owner = 0); Copy constructor. Takes owner as argument and registers cache with owne. ~RooAbsCache(); Destructor. Unregisters cache with owner. void optimizeCacheMode(const RooArgSet& , RooArgSet& , RooLinkedList& ); Interface for processing of cache mode optimization calls. Bool_t redirectServersHook(const RooAbsCollection& , Bool_t , Bool_t , Bool_t ); Interface for server redirect calls. void operModeHook(); Interface for operation mode changes. void findConstantNodes(const RooArgSet& , RooArgSet& , RooLinkedList& ); Interface for constant term node finding calls. void printCompactTreeHook(ostream& , const char* ); Interface for printing of cache guts in tree mode printing. void wireCache(); {}. » Last changed: Tue Jun 30 14:29:53 2015 » Last generated: 2015-06-30 14:29; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html602/RooAbsCache.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsCache.html
https://root.cern/root/html602/RooAbsCache.html:1828,Performance,optimiz,optimizeCacheMode,1828,"nt calls.; . Function Members (Methods); public:. virtual~RooAbsCache(); static TClass*Class(); virtual voidfindConstantNodes(const RooArgSet&, RooArgSet&, RooLinkedList&); virtual TClass*IsA() const; RooAbsCache&operator=(const RooAbsCache&); virtual voidoperModeHook(); virtual voidoptimizeCacheMode(const RooArgSet&, RooArgSet&, RooLinkedList&); virtual voidprintCompactTreeHook(ostream&, const char*); virtual Bool_tredirectServersHook(const RooAbsCollection&, Bool_t, Bool_t, Bool_t); RooAbsCache(RooAbsArg* owner = 0); RooAbsCache(const RooAbsCache&, RooAbsArg* owner = 0); virtual voidShowMembers(TMemberInspector& insp) const; virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); virtual voidwireCache(). Data Members; protected:. RooAbsArg*_ownerPointer to owning RooAbsArg. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; RooAbsCache(RooAbsArg* owner = 0); Constructor. Takes owner as argument and register cache with owner. RooAbsCache(const RooAbsCache& , RooAbsArg* owner = 0); Copy constructor. Takes owner as argument and registers cache with owne. ~RooAbsCache(); Destructor. Unregisters cache with owner. void optimizeCacheMode(const RooArgSet& , RooArgSet& , RooLinkedList& ); Interface for processing of cache mode optimization calls. Bool_t redirectServersHook(const RooAbsCollection& , Bool_t , Bool_t , Bool_t ); Interface for server redirect calls. void operModeHook(); Interface for operation mode changes. void findConstantNodes(const RooArgSet& , RooArgSet& , RooLinkedList& ); Interface for constant term node finding calls. void printCompactTreeHook(ostream& , const char* ); Interface for printing of cache guts in tree mode printing. void wireCache(); {}. » Last changed: Tue Jun 30 14:29:53 2015 » Last generated: 2015-06-30 14:29; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html602/RooAbsCache.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsCache.html
https://root.cern/root/html602/RooAbsCache.html:1924,Performance,cache,cache,1924,"nt calls.; . Function Members (Methods); public:. virtual~RooAbsCache(); static TClass*Class(); virtual voidfindConstantNodes(const RooArgSet&, RooArgSet&, RooLinkedList&); virtual TClass*IsA() const; RooAbsCache&operator=(const RooAbsCache&); virtual voidoperModeHook(); virtual voidoptimizeCacheMode(const RooArgSet&, RooArgSet&, RooLinkedList&); virtual voidprintCompactTreeHook(ostream&, const char*); virtual Bool_tredirectServersHook(const RooAbsCollection&, Bool_t, Bool_t, Bool_t); RooAbsCache(RooAbsArg* owner = 0); RooAbsCache(const RooAbsCache&, RooAbsArg* owner = 0); virtual voidShowMembers(TMemberInspector& insp) const; virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); virtual voidwireCache(). Data Members; protected:. RooAbsArg*_ownerPointer to owning RooAbsArg. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; RooAbsCache(RooAbsArg* owner = 0); Constructor. Takes owner as argument and register cache with owner. RooAbsCache(const RooAbsCache& , RooAbsArg* owner = 0); Copy constructor. Takes owner as argument and registers cache with owne. ~RooAbsCache(); Destructor. Unregisters cache with owner. void optimizeCacheMode(const RooArgSet& , RooArgSet& , RooLinkedList& ); Interface for processing of cache mode optimization calls. Bool_t redirectServersHook(const RooAbsCollection& , Bool_t , Bool_t , Bool_t ); Interface for server redirect calls. void operModeHook(); Interface for operation mode changes. void findConstantNodes(const RooArgSet& , RooArgSet& , RooLinkedList& ); Interface for constant term node finding calls. void printCompactTreeHook(ostream& , const char* ); Interface for printing of cache guts in tree mode printing. void wireCache(); {}. » Last changed: Tue Jun 30 14:29:53 2015 » Last generated: 2015-06-30 14:29; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html602/RooAbsCache.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsCache.html
https://root.cern/root/html602/RooAbsCache.html:1935,Performance,optimiz,optimization,1935,"nt calls.; . Function Members (Methods); public:. virtual~RooAbsCache(); static TClass*Class(); virtual voidfindConstantNodes(const RooArgSet&, RooArgSet&, RooLinkedList&); virtual TClass*IsA() const; RooAbsCache&operator=(const RooAbsCache&); virtual voidoperModeHook(); virtual voidoptimizeCacheMode(const RooArgSet&, RooArgSet&, RooLinkedList&); virtual voidprintCompactTreeHook(ostream&, const char*); virtual Bool_tredirectServersHook(const RooAbsCollection&, Bool_t, Bool_t, Bool_t); RooAbsCache(RooAbsArg* owner = 0); RooAbsCache(const RooAbsCache&, RooAbsArg* owner = 0); virtual voidShowMembers(TMemberInspector& insp) const; virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); virtual voidwireCache(). Data Members; protected:. RooAbsArg*_ownerPointer to owning RooAbsArg. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; RooAbsCache(RooAbsArg* owner = 0); Constructor. Takes owner as argument and register cache with owner. RooAbsCache(const RooAbsCache& , RooAbsArg* owner = 0); Copy constructor. Takes owner as argument and registers cache with owne. ~RooAbsCache(); Destructor. Unregisters cache with owner. void optimizeCacheMode(const RooArgSet& , RooArgSet& , RooLinkedList& ); Interface for processing of cache mode optimization calls. Bool_t redirectServersHook(const RooAbsCollection& , Bool_t , Bool_t , Bool_t ); Interface for server redirect calls. void operModeHook(); Interface for operation mode changes. void findConstantNodes(const RooArgSet& , RooArgSet& , RooLinkedList& ); Interface for constant term node finding calls. void printCompactTreeHook(ostream& , const char* ); Interface for printing of cache guts in tree mode printing. void wireCache(); {}. » Last changed: Tue Jun 30 14:29:53 2015 » Last generated: 2015-06-30 14:29; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html602/RooAbsCache.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsCache.html
https://root.cern/root/html602/RooAbsCache.html:2331,Performance,cache,cache,2331,"nt calls.; . Function Members (Methods); public:. virtual~RooAbsCache(); static TClass*Class(); virtual voidfindConstantNodes(const RooArgSet&, RooArgSet&, RooLinkedList&); virtual TClass*IsA() const; RooAbsCache&operator=(const RooAbsCache&); virtual voidoperModeHook(); virtual voidoptimizeCacheMode(const RooArgSet&, RooArgSet&, RooLinkedList&); virtual voidprintCompactTreeHook(ostream&, const char*); virtual Bool_tredirectServersHook(const RooAbsCollection&, Bool_t, Bool_t, Bool_t); RooAbsCache(RooAbsArg* owner = 0); RooAbsCache(const RooAbsCache&, RooAbsArg* owner = 0); virtual voidShowMembers(TMemberInspector& insp) const; virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); virtual voidwireCache(). Data Members; protected:. RooAbsArg*_ownerPointer to owning RooAbsArg. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; RooAbsCache(RooAbsArg* owner = 0); Constructor. Takes owner as argument and register cache with owner. RooAbsCache(const RooAbsCache& , RooAbsArg* owner = 0); Copy constructor. Takes owner as argument and registers cache with owne. ~RooAbsCache(); Destructor. Unregisters cache with owner. void optimizeCacheMode(const RooArgSet& , RooArgSet& , RooLinkedList& ); Interface for processing of cache mode optimization calls. Bool_t redirectServersHook(const RooAbsCollection& , Bool_t , Bool_t , Bool_t ); Interface for server redirect calls. void operModeHook(); Interface for operation mode changes. void findConstantNodes(const RooArgSet& , RooArgSet& , RooLinkedList& ); Interface for constant term node finding calls. void printCompactTreeHook(ostream& , const char* ); Interface for printing of cache guts in tree mode printing. void wireCache(); {}. » Last changed: Tue Jun 30 14:29:53 2015 » Last generated: 2015-06-30 14:29; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html602/RooAbsCache.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsCache.html
https://root.cern/root/html602/RooAbsCachedPdf.html:1233,Availability,avail,available,1233," ROOT; » ROOFIT; » ROOFITCORE; » RooAbsCachedPdf. class RooAbsCachedPdf: public RooAbsPdf. RooAbsCachedPdf is the abstract base class for p.d.f.s that need or; want to cache their evaluate() output in a RooHistPdf defined in; terms of the used observables. This base class manages the creation; and storage of all RooHistPdf cache p.d.fs and the RooDataHists; that define their shape. Implementations of RooAbsCachedPdf must; define member function fillCacheObject() which serves to fill an; already created RooDataHist with the p.d.fs function values. In; addition the member functions actualObservables() and; actualParameters() must be define which report what the actual; observables to be cached are for a given set of observables passed; by the user to getVal() and on which parameters need to be tracked; for changes to trigger a refilling of the cache histogram.; . Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~RooAbsCachedPdf(); voidTObject::AbstractMethod(const char* method) const; Bool_tRooAbsArg::addOwnedComponents(const RooArgSet& comps); voidRooAbsArg::addParameters(RooArgSet& params, const RooArgSet* nset = 0, Bool_t stripDisconnected = kTRUE) const; voidRooAbsArg::addServer(RooAbsArg& server, Bool_t valueProp = kTRUE, Bool_t shapeProp = kFALSE); voidRooAbsArg::addServerList(RooAbsCollection& serverList, Bool_t valueProp = kTRUE, Bool_t shapeProp = kFALSE); const char*RooAbsArg::aggregateCacheUniqueSuffix() const; virtual Double_tRooAbsReal::analyticalIntegral(Int_t code, const char* rangeName = 0) const; virtual Double_tanalyticalIntegralWN(Int_t code, const RooArgSet* normSet, const char* rangeName = 0) const; virtual voidTObject::AppendPad(Option_t* option = """"); TF1*RooAbsReal::asTF(const RooArgList& obs, const RooArgList& pars = RooArgList(), const RooArgSet& nset = RooArgSet()) const; voidRooAbsArg::attachDataSet(const RooAbsData& ",MatchSource.WIKI,root/html602/RooAbsCachedPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsCachedPdf.html
https://root.cern/root/html602/RooAbsCachedPdf.html:10715,Availability,error,error,10715,,MatchSource.WIKI,root/html602/RooAbsCachedPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsCachedPdf.html
https://root.cern/root/html602/RooAbsCachedPdf.html:10799,Availability,error,error,10799,,MatchSource.WIKI,root/html602/RooAbsCachedPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsCachedPdf.html
https://root.cern/root/html602/RooAbsCachedPdf.html:43553,Availability,error,errors,43553,"; Bool_tRooAbsReal::_boolValue! Transient cache for bool values from tree branches; UChar_tRooAbsReal::_byteValue! Transient cache for byte values from tree branches; static Bool_tRooAbsReal::_cacheCheckIf true, always validate contents of clean which outcome of evaluate(); deque<RooAbsCache*>RooAbsArg::_cacheListlist of caches; RooObjCacheManager_cacheMgrThe cache manager; RooRefCountListRooAbsArg::_clientListlist of client objects; RooRefCountListRooAbsArg::_clientListShapesubset of clients that requested shape dirty flag propagation; RooRefCountListRooAbsArg::_clientListValuesubset of clients that requested value dirty flag propagation; TIterator*RooAbsArg::_clientShapeIter! Iterator over _clientListShape; TIterator*RooAbsArg::_clientValueIter! Iterator over _clientListValue; Bool_tRooAbsArg::_deleteWatch! Delete watch flag; RooExpensiveObjectCache*RooAbsArg::_eocachePointer to global cache manager for any expensive components created by this object; Int_tRooAbsPdf::_errorCountNumber of errors remaining to print; static Bool_tRooAbsPdf::_evalError; Bool_tRooAbsArg::_fastAllow fast access mode in getVal() and proxies; Float_tRooAbsReal::_floatValue! Transient cache for floating point values from tree branches; Bool_tRooAbsReal::_forceNumIntForce numerical integration if flag set; static Bool_tRooAbsReal::_globalSelectCompGlobal activation switch for component selection; static Bool_tRooAbsReal::_hideOffsetOffset hiding flag; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; Int_tRooAbsReal::_intValue! Transient cache for integer values from tree branches; Int_t_ipOrderInterpolation order for cache histograms; Bool_tRooAbsArg::_isConstant! Cached isConstant status; TStringRooAbsReal::_labelPlot label for objects value; RooArgSet*RooAbsReal::_lastNSet!; Bool_tRooAbsArg::_localNoInhibitDirty! Prevent 'AlwaysDirty' mode for this node; static Int_tRooPrintable::_nameLength; TNamed*RooAbsArg::_namePtr! Do not persist.",MatchSource.WIKI,root/html602/RooAbsCachedPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsCachedPdf.html
https://root.cern/root/html602/RooAbsCachedPdf.html:42317,Deployability,integrat,integration,42317,,MatchSource.WIKI,root/html602/RooAbsCachedPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsCachedPdf.html
https://root.cern/root/html602/RooAbsCachedPdf.html:42383,Deployability,integrat,integration,42383,,MatchSource.WIKI,root/html602/RooAbsCachedPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsCachedPdf.html
https://root.cern/root/html602/RooAbsCachedPdf.html:43826,Deployability,integrat,integration,43826,"; Bool_tRooAbsReal::_boolValue! Transient cache for bool values from tree branches; UChar_tRooAbsReal::_byteValue! Transient cache for byte values from tree branches; static Bool_tRooAbsReal::_cacheCheckIf true, always validate contents of clean which outcome of evaluate(); deque<RooAbsCache*>RooAbsArg::_cacheListlist of caches; RooObjCacheManager_cacheMgrThe cache manager; RooRefCountListRooAbsArg::_clientListlist of client objects; RooRefCountListRooAbsArg::_clientListShapesubset of clients that requested shape dirty flag propagation; RooRefCountListRooAbsArg::_clientListValuesubset of clients that requested value dirty flag propagation; TIterator*RooAbsArg::_clientShapeIter! Iterator over _clientListShape; TIterator*RooAbsArg::_clientValueIter! Iterator over _clientListValue; Bool_tRooAbsArg::_deleteWatch! Delete watch flag; RooExpensiveObjectCache*RooAbsArg::_eocachePointer to global cache manager for any expensive components created by this object; Int_tRooAbsPdf::_errorCountNumber of errors remaining to print; static Bool_tRooAbsPdf::_evalError; Bool_tRooAbsArg::_fastAllow fast access mode in getVal() and proxies; Float_tRooAbsReal::_floatValue! Transient cache for floating point values from tree branches; Bool_tRooAbsReal::_forceNumIntForce numerical integration if flag set; static Bool_tRooAbsReal::_globalSelectCompGlobal activation switch for component selection; static Bool_tRooAbsReal::_hideOffsetOffset hiding flag; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; Int_tRooAbsReal::_intValue! Transient cache for integer values from tree branches; Int_t_ipOrderInterpolation order for cache histograms; Bool_tRooAbsArg::_isConstant! Cached isConstant status; TStringRooAbsReal::_labelPlot label for objects value; RooArgSet*RooAbsReal::_lastNSet!; Bool_tRooAbsArg::_localNoInhibitDirty! Prevent 'AlwaysDirty' mode for this node; static Int_tRooPrintable::_nameLength; TNamed*RooAbsArg::_namePtr! Do not persist.",MatchSource.WIKI,root/html602/RooAbsCachedPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsCachedPdf.html
https://root.cern/root/html602/RooAbsCachedPdf.html:45908,Deployability,configurat,configuration,45908,"egral (owned by _normMgr); RooObjCacheManagerRooAbsPdf::_normMgrThe cache manager; TStringRooAbsPdf::_normRangeNormalization range; static TStringRooAbsPdf::_normRangeOverride; RooArgSet*RooAbsPdf::_normSet! Normalization set with for above integral; RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; Int_tRooAbsReal::_plotBinsNumber of plot bins; Double_tRooAbsReal::_plotMaxMaximum of plot range; Double_tRooAbsReal::_plotMinMinimum of plot range; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; RooRefArrayRooAbsArg::_proxyListlist of proxies; Double_tRooAbsPdf::_rawValue; Char_tRooAbsReal::_sbyteValue! Transient cache for signed byte values from tree branches; Bool_tRooAbsPdf::_selectCompComponent selection flag for RooAbsPdf::plotCompOn; Bool_tRooAbsReal::_selectComp! Component selection flag for RooAbsPdf::plotCompOn; RooRefCountListRooAbsArg::_serverListlist of server objects; Bool_tRooAbsArg::_shapeDirtyFlag set if value needs recalculating because input shapes modified; RooNumGenConfig*RooAbsPdf::_specGeneratorConfig! MC generator configuration specific for this object; RooNumIntConfig*RooAbsReal::_specIntegratorConfigNumeric integrator configuration specific for this object; map<string,string>RooAbsArg::_stringAttribString attributes; Int_tRooAbsPdf::_traceCountNumber of traces remaining to print; Bool_tRooAbsReal::_treeVar!do not persist; UInt_tRooAbsReal::_uintValue! Transient cache for unsigned integer values from tree branches; TStringRooAbsReal::_unitUnit for objects value; Double_tRooAbsReal::_valueCache for current value of object; Bool_tRooAbsArg::_valueDirtyFlag set if value needs recalculating because input values modified; static Bool_tRooAbsArg::_verboseDirtyStatic flag controlling verbose messaging for dirty state changes; static Int_tRooAbsPdf::_verboseEval; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title.",MatchSource.WIKI,root/html602/RooAbsCachedPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsCachedPdf.html
https://root.cern/root/html602/RooAbsCachedPdf.html:46005,Deployability,integrat,integrator,46005,"egral (owned by _normMgr); RooObjCacheManagerRooAbsPdf::_normMgrThe cache manager; TStringRooAbsPdf::_normRangeNormalization range; static TStringRooAbsPdf::_normRangeOverride; RooArgSet*RooAbsPdf::_normSet! Normalization set with for above integral; RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; Int_tRooAbsReal::_plotBinsNumber of plot bins; Double_tRooAbsReal::_plotMaxMaximum of plot range; Double_tRooAbsReal::_plotMinMinimum of plot range; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; RooRefArrayRooAbsArg::_proxyListlist of proxies; Double_tRooAbsPdf::_rawValue; Char_tRooAbsReal::_sbyteValue! Transient cache for signed byte values from tree branches; Bool_tRooAbsPdf::_selectCompComponent selection flag for RooAbsPdf::plotCompOn; Bool_tRooAbsReal::_selectComp! Component selection flag for RooAbsPdf::plotCompOn; RooRefCountListRooAbsArg::_serverListlist of server objects; Bool_tRooAbsArg::_shapeDirtyFlag set if value needs recalculating because input shapes modified; RooNumGenConfig*RooAbsPdf::_specGeneratorConfig! MC generator configuration specific for this object; RooNumIntConfig*RooAbsReal::_specIntegratorConfigNumeric integrator configuration specific for this object; map<string,string>RooAbsArg::_stringAttribString attributes; Int_tRooAbsPdf::_traceCountNumber of traces remaining to print; Bool_tRooAbsReal::_treeVar!do not persist; UInt_tRooAbsReal::_uintValue! Transient cache for unsigned integer values from tree branches; TStringRooAbsReal::_unitUnit for objects value; Double_tRooAbsReal::_valueCache for current value of object; Bool_tRooAbsArg::_valueDirtyFlag set if value needs recalculating because input values modified; static Bool_tRooAbsArg::_verboseDirtyStatic flag controlling verbose messaging for dirty state changes; static Int_tRooAbsPdf::_verboseEval; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title.",MatchSource.WIKI,root/html602/RooAbsCachedPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsCachedPdf.html
https://root.cern/root/html602/RooAbsCachedPdf.html:46016,Deployability,configurat,configuration,46016,"egral (owned by _normMgr); RooObjCacheManagerRooAbsPdf::_normMgrThe cache manager; TStringRooAbsPdf::_normRangeNormalization range; static TStringRooAbsPdf::_normRangeOverride; RooArgSet*RooAbsPdf::_normSet! Normalization set with for above integral; RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; Int_tRooAbsReal::_plotBinsNumber of plot bins; Double_tRooAbsReal::_plotMaxMaximum of plot range; Double_tRooAbsReal::_plotMinMinimum of plot range; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; RooRefArrayRooAbsArg::_proxyListlist of proxies; Double_tRooAbsPdf::_rawValue; Char_tRooAbsReal::_sbyteValue! Transient cache for signed byte values from tree branches; Bool_tRooAbsPdf::_selectCompComponent selection flag for RooAbsPdf::plotCompOn; Bool_tRooAbsReal::_selectComp! Component selection flag for RooAbsPdf::plotCompOn; RooRefCountListRooAbsArg::_serverListlist of server objects; Bool_tRooAbsArg::_shapeDirtyFlag set if value needs recalculating because input shapes modified; RooNumGenConfig*RooAbsPdf::_specGeneratorConfig! MC generator configuration specific for this object; RooNumIntConfig*RooAbsReal::_specIntegratorConfigNumeric integrator configuration specific for this object; map<string,string>RooAbsArg::_stringAttribString attributes; Int_tRooAbsPdf::_traceCountNumber of traces remaining to print; Bool_tRooAbsReal::_treeVar!do not persist; UInt_tRooAbsReal::_uintValue! Transient cache for unsigned integer values from tree branches; TStringRooAbsReal::_unitUnit for objects value; Double_tRooAbsReal::_valueCache for current value of object; Bool_tRooAbsArg::_valueDirtyFlag set if value needs recalculating because input values modified; static Bool_tRooAbsArg::_verboseDirtyStatic flag controlling verbose messaging for dirty state changes; static Int_tRooAbsPdf::_verboseEval; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title.",MatchSource.WIKI,root/html602/RooAbsCachedPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsCachedPdf.html
https://root.cern/root/html602/RooAbsCachedPdf.html:47917,Deployability,configurat,configuration,47917,"ce; Inherited Members; Includes; Libraries. Function documentation; RooAbsCachedPdf(const char* name, const char* title, Int_t ipOrder = 0); Constructor. RooAbsCachedPdf(const RooAbsCachedPdf& other, const char* name = 0); Copy constructor. ~RooAbsCachedPdf(); Destructor. Double_t getValV(const RooArgSet* set = 0) const; Implementation of getVal() overriding default implementation; of RooAbsPdf. Return normalized value stored in cache p.d.f; rather than return value of evaluate() which is undefined; for RooAbsCachedPdf. RooAbsPdf* getCachePdf(const RooArgSet* nset = 0) const; Return pointer to RooHistPdf cache pdf for given choice of observables. RooDataHist* getCacheHist(const RooArgSet* nset = 0) const; Return pointer to RooDataHist cache histogram for given choice of observables. void clearCacheObject(RooAbsCachedPdf::PdfCacheElem& cache) const; Mark all bins of given cache as unitialized (value -1). TString cacheNameSuffix(const RooArgSet& nset) const; Construct string with unique suffix for cache objects based on; observable names that define cache configuration. void setInterpolationOrder(Int_t order); Change the interpolation order that is used in RooHistPdf cache; representation smoothing the RooDataHist shapes. Bool_t forceAnalyticalInt(const RooAbsArg& dep) const; Force RooRealIntegral to offer all our actual observable for internal; integration. Int_t getAnalyticalIntegralWN(RooArgSet& allVars, RooArgSet& analVars, const RooArgSet* normSet, const char* rangeName = 0) const; Advertises internal (analytical) integration capabilities. Call; is forwarded to RooHistPdf cache p.d.f of cache that is used for; given choice of observables. Double_t analyticalIntegralWN(Int_t code, const RooArgSet* normSet, const char* rangeName = 0) const; Implements internal (analytical) integration capabilities. Call; is forwarded to RooHistPdf cache p.d.f of cache that is used for; given choice of observables. RooAbsCachedPdf(); Default constructor. Bool_t selfNormalized() cons",MatchSource.WIKI,root/html602/RooAbsCachedPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsCachedPdf.html
https://root.cern/root/html602/RooAbsCachedPdf.html:48213,Deployability,integrat,integration,48213,"et = 0) const; Implementation of getVal() overriding default implementation; of RooAbsPdf. Return normalized value stored in cache p.d.f; rather than return value of evaluate() which is undefined; for RooAbsCachedPdf. RooAbsPdf* getCachePdf(const RooArgSet* nset = 0) const; Return pointer to RooHistPdf cache pdf for given choice of observables. RooDataHist* getCacheHist(const RooArgSet* nset = 0) const; Return pointer to RooDataHist cache histogram for given choice of observables. void clearCacheObject(RooAbsCachedPdf::PdfCacheElem& cache) const; Mark all bins of given cache as unitialized (value -1). TString cacheNameSuffix(const RooArgSet& nset) const; Construct string with unique suffix for cache objects based on; observable names that define cache configuration. void setInterpolationOrder(Int_t order); Change the interpolation order that is used in RooHistPdf cache; representation smoothing the RooDataHist shapes. Bool_t forceAnalyticalInt(const RooAbsArg& dep) const; Force RooRealIntegral to offer all our actual observable for internal; integration. Int_t getAnalyticalIntegralWN(RooArgSet& allVars, RooArgSet& analVars, const RooArgSet* normSet, const char* rangeName = 0) const; Advertises internal (analytical) integration capabilities. Call; is forwarded to RooHistPdf cache p.d.f of cache that is used for; given choice of observables. Double_t analyticalIntegralWN(Int_t code, const RooArgSet* normSet, const char* rangeName = 0) const; Implements internal (analytical) integration capabilities. Call; is forwarded to RooHistPdf cache p.d.f of cache that is used for; given choice of observables. RooAbsCachedPdf(); Default constructor. Bool_t selfNormalized() const; Declare p.d.f self normalized. RooAbsPdf* getCachePdf(const RooArgSet& nset) const; Return RooHistPdf that represents cache histogram. RooDataHist* getCacheHist(const RooArgSet& nset) const; Return RooDataHist with cached values. Int_t getInterpolationOrder() const; Set interpolation order in RooHistPdf t",MatchSource.WIKI,root/html602/RooAbsCachedPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsCachedPdf.html
https://root.cern/root/html602/RooAbsCachedPdf.html:48390,Deployability,integrat,integration,48390," evaluate() which is undefined; for RooAbsCachedPdf. RooAbsPdf* getCachePdf(const RooArgSet* nset = 0) const; Return pointer to RooHistPdf cache pdf for given choice of observables. RooDataHist* getCacheHist(const RooArgSet* nset = 0) const; Return pointer to RooDataHist cache histogram for given choice of observables. void clearCacheObject(RooAbsCachedPdf::PdfCacheElem& cache) const; Mark all bins of given cache as unitialized (value -1). TString cacheNameSuffix(const RooArgSet& nset) const; Construct string with unique suffix for cache objects based on; observable names that define cache configuration. void setInterpolationOrder(Int_t order); Change the interpolation order that is used in RooHistPdf cache; representation smoothing the RooDataHist shapes. Bool_t forceAnalyticalInt(const RooAbsArg& dep) const; Force RooRealIntegral to offer all our actual observable for internal; integration. Int_t getAnalyticalIntegralWN(RooArgSet& allVars, RooArgSet& analVars, const RooArgSet* normSet, const char* rangeName = 0) const; Advertises internal (analytical) integration capabilities. Call; is forwarded to RooHistPdf cache p.d.f of cache that is used for; given choice of observables. Double_t analyticalIntegralWN(Int_t code, const RooArgSet* normSet, const char* rangeName = 0) const; Implements internal (analytical) integration capabilities. Call; is forwarded to RooHistPdf cache p.d.f of cache that is used for; given choice of observables. RooAbsCachedPdf(); Default constructor. Bool_t selfNormalized() const; Declare p.d.f self normalized. RooAbsPdf* getCachePdf(const RooArgSet& nset) const; Return RooHistPdf that represents cache histogram. RooDataHist* getCacheHist(const RooArgSet& nset) const; Return RooDataHist with cached values. Int_t getInterpolationOrder() const; Set interpolation order in RooHistPdf that represent cached histogram. PdfCacheElem* getCache(const RooArgSet* nset, Bool_t recalculate = kTRUE) const. const char* payloadUniqueSuffix() const; { return 0",MatchSource.WIKI,root/html602/RooAbsCachedPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsCachedPdf.html
https://root.cern/root/html602/RooAbsCachedPdf.html:48652,Deployability,integrat,integration,48652,"e histogram for given choice of observables. void clearCacheObject(RooAbsCachedPdf::PdfCacheElem& cache) const; Mark all bins of given cache as unitialized (value -1). TString cacheNameSuffix(const RooArgSet& nset) const; Construct string with unique suffix for cache objects based on; observable names that define cache configuration. void setInterpolationOrder(Int_t order); Change the interpolation order that is used in RooHistPdf cache; representation smoothing the RooDataHist shapes. Bool_t forceAnalyticalInt(const RooAbsArg& dep) const; Force RooRealIntegral to offer all our actual observable for internal; integration. Int_t getAnalyticalIntegralWN(RooArgSet& allVars, RooArgSet& analVars, const RooArgSet* normSet, const char* rangeName = 0) const; Advertises internal (analytical) integration capabilities. Call; is forwarded to RooHistPdf cache p.d.f of cache that is used for; given choice of observables. Double_t analyticalIntegralWN(Int_t code, const RooArgSet* normSet, const char* rangeName = 0) const; Implements internal (analytical) integration capabilities. Call; is forwarded to RooHistPdf cache p.d.f of cache that is used for; given choice of observables. RooAbsCachedPdf(); Default constructor. Bool_t selfNormalized() const; Declare p.d.f self normalized. RooAbsPdf* getCachePdf(const RooArgSet& nset) const; Return RooHistPdf that represents cache histogram. RooDataHist* getCacheHist(const RooArgSet& nset) const; Return RooDataHist with cached values. Int_t getInterpolationOrder() const; Set interpolation order in RooHistPdf that represent cached histogram. PdfCacheElem* getCache(const RooArgSet* nset, Bool_t recalculate = kTRUE) const. const char* payloadUniqueSuffix() const; { return 0 ; }. const char* binningName() const; Return name of binning to be used for creation of cache histogram. PdfCacheElem* createCache(const RooArgSet* nset) const; Create cache storage element. const char* inputBaseName() const. RooArgSet* actualObservables(const RooArgSet& nset",MatchSource.WIKI,root/html602/RooAbsCachedPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsCachedPdf.html
https://root.cern/root/html602/RooAbsCachedPdf.html:7759,Integrability,depend,dependentVars,7759,"), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()) const; RooAbsReal*RooAbsReal::createIntRI(const RooArgSet& iset, const RooArgSet& nset = RooArgSet()); virtual RooAbsReal*RooAbsPdf::createNLL(RooAbsData& data, const RooLinkedList& cmdList); virtual RooAbsReal*RooAbsPdf::createNLL(RooAbsData& data, const RooCmdArg& arg1 = RooCmdArg::none(), const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()); const RooAbsReal*RooAbsReal::createPlotProjection(const RooArgSet& depVars, const RooArgSet& projVars) const; const RooAbsReal*RooAbsReal::createPlotProjection(const RooArgSet& depVars, const RooArgSet& projVars, RooArgSet*& cloneSet) const; const RooAbsReal*RooAbsReal::createPlotProjection(const RooArgSet& dependentVars, const RooArgSet* projectedVars, RooArgSet*& cloneSet, const char* rangeName = 0, const RooArgSet* condObs = 0) const; virtual RooAbsReal*RooAbsReal::createProfile(const RooArgSet& paramsOfInterest); virtual RooAbsPdf*RooAbsPdf::createProjection(const RooArgSet& iset); RooAbsReal*RooAbsReal::createRunningIntegral(const RooArgSet& iset, const RooArgSet& nset = RooArgSet()); RooAbsReal*RooAbsReal::createRunningIntegral(const RooArgSet& iset, const RooCmdArg& arg1, const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()); RooAbsReal*RooAbsPdf::createScanCdf(const RooArgSet& iset, const RooArgSet& nset, Int_t numScanBins, Int_t intOrder); RooAbsReal*RooAbsReal::createScanRI(const RooArgSet& iset, const RooArgSet& nset, Int_t numScanBins, Int_t",MatchSource.WIKI,root/html602/RooAbsCachedPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsCachedPdf.html
https://root.cern/root/html602/RooAbsCachedPdf.html:9249,Integrability,depend,dependentOverlaps,9249,"aramsOfInterest); virtual RooAbsPdf*RooAbsPdf::createProjection(const RooArgSet& iset); RooAbsReal*RooAbsReal::createRunningIntegral(const RooArgSet& iset, const RooArgSet& nset = RooArgSet()); RooAbsReal*RooAbsReal::createRunningIntegral(const RooArgSet& iset, const RooCmdArg& arg1, const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()); RooAbsReal*RooAbsPdf::createScanCdf(const RooArgSet& iset, const RooArgSet& nset, Int_t numScanBins, Int_t intOrder); RooAbsReal*RooAbsReal::createScanRI(const RooArgSet& iset, const RooArgSet& nset, Int_t numScanBins, Int_t intOrder); virtual Double_tRooAbsReal::defaultErrorLevel() const; static RooNumGenConfig*RooAbsPdf::defaultGeneratorConfig(); static RooNumIntConfig*RooAbsReal::defaultIntegratorConfig(); virtual Int_tRooAbsArg::defaultPrintContents(Option_t* opt) const; static ostream&RooPrintable::defaultPrintStream(ostream* os = 0); virtual RooPrintable::StyleOptionRooPrintable::defaultPrintStyle(Option_t* opt) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; Bool_tRooAbsArg::dependentOverlaps(const RooAbsData* dset, const RooAbsArg& testArg) const; Bool_tRooAbsArg::dependentOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; Bool_tRooAbsArg::dependsOn(const RooAbsCollection& serverList, const RooAbsArg* ignoreArg = 0, Bool_t valueOnly = kFALSE) const; Bool_tRooAbsArg::dependsOn(const RooAbsArg& server, const RooAbsArg* ignoreArg = 0, Bool_t valueOnly = kFALSE) const; Bool_tRooAbsArg::dependsOnValue(const RooAbsCollection& serverList, const RooAbsArg* ignoreArg = 0) const; Bool_tRooAbsArg::dependsOnValue(const RooAbsArg& server, const RooAbsArg* ignoreArg = 0) const; RooDerivative*RooAbsReal::derivative(RooRealVar& obs, Int_t order = 1, Double_t eps = 0.",MatchSource.WIKI,root/html602/RooAbsCachedPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsCachedPdf.html
https://root.cern/root/html602/RooAbsCachedPdf.html:9341,Integrability,depend,dependentOverlaps,9341,"aramsOfInterest); virtual RooAbsPdf*RooAbsPdf::createProjection(const RooArgSet& iset); RooAbsReal*RooAbsReal::createRunningIntegral(const RooArgSet& iset, const RooArgSet& nset = RooArgSet()); RooAbsReal*RooAbsReal::createRunningIntegral(const RooArgSet& iset, const RooCmdArg& arg1, const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()); RooAbsReal*RooAbsPdf::createScanCdf(const RooArgSet& iset, const RooArgSet& nset, Int_t numScanBins, Int_t intOrder); RooAbsReal*RooAbsReal::createScanRI(const RooArgSet& iset, const RooArgSet& nset, Int_t numScanBins, Int_t intOrder); virtual Double_tRooAbsReal::defaultErrorLevel() const; static RooNumGenConfig*RooAbsPdf::defaultGeneratorConfig(); static RooNumIntConfig*RooAbsReal::defaultIntegratorConfig(); virtual Int_tRooAbsArg::defaultPrintContents(Option_t* opt) const; static ostream&RooPrintable::defaultPrintStream(ostream* os = 0); virtual RooPrintable::StyleOptionRooPrintable::defaultPrintStyle(Option_t* opt) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; Bool_tRooAbsArg::dependentOverlaps(const RooAbsData* dset, const RooAbsArg& testArg) const; Bool_tRooAbsArg::dependentOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; Bool_tRooAbsArg::dependsOn(const RooAbsCollection& serverList, const RooAbsArg* ignoreArg = 0, Bool_t valueOnly = kFALSE) const; Bool_tRooAbsArg::dependsOn(const RooAbsArg& server, const RooAbsArg* ignoreArg = 0, Bool_t valueOnly = kFALSE) const; Bool_tRooAbsArg::dependsOnValue(const RooAbsCollection& serverList, const RooAbsArg* ignoreArg = 0) const; Bool_tRooAbsArg::dependsOnValue(const RooAbsArg& server, const RooAbsArg* ignoreArg = 0) const; RooDerivative*RooAbsReal::derivative(RooRealVar& obs, Int_t order = 1, Double_t eps = 0.",MatchSource.WIKI,root/html602/RooAbsCachedPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsCachedPdf.html
https://root.cern/root/html602/RooAbsCachedPdf.html:9435,Integrability,depend,dependsOn,9435,"aramsOfInterest); virtual RooAbsPdf*RooAbsPdf::createProjection(const RooArgSet& iset); RooAbsReal*RooAbsReal::createRunningIntegral(const RooArgSet& iset, const RooArgSet& nset = RooArgSet()); RooAbsReal*RooAbsReal::createRunningIntegral(const RooArgSet& iset, const RooCmdArg& arg1, const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()); RooAbsReal*RooAbsPdf::createScanCdf(const RooArgSet& iset, const RooArgSet& nset, Int_t numScanBins, Int_t intOrder); RooAbsReal*RooAbsReal::createScanRI(const RooArgSet& iset, const RooArgSet& nset, Int_t numScanBins, Int_t intOrder); virtual Double_tRooAbsReal::defaultErrorLevel() const; static RooNumGenConfig*RooAbsPdf::defaultGeneratorConfig(); static RooNumIntConfig*RooAbsReal::defaultIntegratorConfig(); virtual Int_tRooAbsArg::defaultPrintContents(Option_t* opt) const; static ostream&RooPrintable::defaultPrintStream(ostream* os = 0); virtual RooPrintable::StyleOptionRooPrintable::defaultPrintStyle(Option_t* opt) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; Bool_tRooAbsArg::dependentOverlaps(const RooAbsData* dset, const RooAbsArg& testArg) const; Bool_tRooAbsArg::dependentOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; Bool_tRooAbsArg::dependsOn(const RooAbsCollection& serverList, const RooAbsArg* ignoreArg = 0, Bool_t valueOnly = kFALSE) const; Bool_tRooAbsArg::dependsOn(const RooAbsArg& server, const RooAbsArg* ignoreArg = 0, Bool_t valueOnly = kFALSE) const; Bool_tRooAbsArg::dependsOnValue(const RooAbsCollection& serverList, const RooAbsArg* ignoreArg = 0) const; Bool_tRooAbsArg::dependsOnValue(const RooAbsArg& server, const RooAbsArg* ignoreArg = 0) const; RooDerivative*RooAbsReal::derivative(RooRealVar& obs, Int_t order = 1, Double_t eps = 0.",MatchSource.WIKI,root/html602/RooAbsCachedPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsCachedPdf.html
https://root.cern/root/html602/RooAbsCachedPdf.html:9564,Integrability,depend,dependsOn,9564,"aramsOfInterest); virtual RooAbsPdf*RooAbsPdf::createProjection(const RooArgSet& iset); RooAbsReal*RooAbsReal::createRunningIntegral(const RooArgSet& iset, const RooArgSet& nset = RooArgSet()); RooAbsReal*RooAbsReal::createRunningIntegral(const RooArgSet& iset, const RooCmdArg& arg1, const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()); RooAbsReal*RooAbsPdf::createScanCdf(const RooArgSet& iset, const RooArgSet& nset, Int_t numScanBins, Int_t intOrder); RooAbsReal*RooAbsReal::createScanRI(const RooArgSet& iset, const RooArgSet& nset, Int_t numScanBins, Int_t intOrder); virtual Double_tRooAbsReal::defaultErrorLevel() const; static RooNumGenConfig*RooAbsPdf::defaultGeneratorConfig(); static RooNumIntConfig*RooAbsReal::defaultIntegratorConfig(); virtual Int_tRooAbsArg::defaultPrintContents(Option_t* opt) const; static ostream&RooPrintable::defaultPrintStream(ostream* os = 0); virtual RooPrintable::StyleOptionRooPrintable::defaultPrintStyle(Option_t* opt) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; Bool_tRooAbsArg::dependentOverlaps(const RooAbsData* dset, const RooAbsArg& testArg) const; Bool_tRooAbsArg::dependentOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; Bool_tRooAbsArg::dependsOn(const RooAbsCollection& serverList, const RooAbsArg* ignoreArg = 0, Bool_t valueOnly = kFALSE) const; Bool_tRooAbsArg::dependsOn(const RooAbsArg& server, const RooAbsArg* ignoreArg = 0, Bool_t valueOnly = kFALSE) const; Bool_tRooAbsArg::dependsOnValue(const RooAbsCollection& serverList, const RooAbsArg* ignoreArg = 0) const; Bool_tRooAbsArg::dependsOnValue(const RooAbsArg& server, const RooAbsArg* ignoreArg = 0) const; RooDerivative*RooAbsReal::derivative(RooRealVar& obs, Int_t order = 1, Double_t eps = 0.",MatchSource.WIKI,root/html602/RooAbsCachedPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsCachedPdf.html
https://root.cern/root/html602/RooAbsCachedPdf.html:9682,Integrability,depend,dependsOnValue,9682,"aramsOfInterest); virtual RooAbsPdf*RooAbsPdf::createProjection(const RooArgSet& iset); RooAbsReal*RooAbsReal::createRunningIntegral(const RooArgSet& iset, const RooArgSet& nset = RooArgSet()); RooAbsReal*RooAbsReal::createRunningIntegral(const RooArgSet& iset, const RooCmdArg& arg1, const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()); RooAbsReal*RooAbsPdf::createScanCdf(const RooArgSet& iset, const RooArgSet& nset, Int_t numScanBins, Int_t intOrder); RooAbsReal*RooAbsReal::createScanRI(const RooArgSet& iset, const RooArgSet& nset, Int_t numScanBins, Int_t intOrder); virtual Double_tRooAbsReal::defaultErrorLevel() const; static RooNumGenConfig*RooAbsPdf::defaultGeneratorConfig(); static RooNumIntConfig*RooAbsReal::defaultIntegratorConfig(); virtual Int_tRooAbsArg::defaultPrintContents(Option_t* opt) const; static ostream&RooPrintable::defaultPrintStream(ostream* os = 0); virtual RooPrintable::StyleOptionRooPrintable::defaultPrintStyle(Option_t* opt) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; Bool_tRooAbsArg::dependentOverlaps(const RooAbsData* dset, const RooAbsArg& testArg) const; Bool_tRooAbsArg::dependentOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; Bool_tRooAbsArg::dependsOn(const RooAbsCollection& serverList, const RooAbsArg* ignoreArg = 0, Bool_t valueOnly = kFALSE) const; Bool_tRooAbsArg::dependsOn(const RooAbsArg& server, const RooAbsArg* ignoreArg = 0, Bool_t valueOnly = kFALSE) const; Bool_tRooAbsArg::dependsOnValue(const RooAbsCollection& serverList, const RooAbsArg* ignoreArg = 0) const; Bool_tRooAbsArg::dependsOnValue(const RooAbsArg& server, const RooAbsArg* ignoreArg = 0) const; RooDerivative*RooAbsReal::derivative(RooRealVar& obs, Int_t order = 1, Double_t eps = 0.",MatchSource.WIKI,root/html602/RooAbsCachedPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsCachedPdf.html
https://root.cern/root/html602/RooAbsCachedPdf.html:9789,Integrability,depend,dependsOnValue,9789,"aramsOfInterest); virtual RooAbsPdf*RooAbsPdf::createProjection(const RooArgSet& iset); RooAbsReal*RooAbsReal::createRunningIntegral(const RooArgSet& iset, const RooArgSet& nset = RooArgSet()); RooAbsReal*RooAbsReal::createRunningIntegral(const RooArgSet& iset, const RooCmdArg& arg1, const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()); RooAbsReal*RooAbsPdf::createScanCdf(const RooArgSet& iset, const RooArgSet& nset, Int_t numScanBins, Int_t intOrder); RooAbsReal*RooAbsReal::createScanRI(const RooArgSet& iset, const RooArgSet& nset, Int_t numScanBins, Int_t intOrder); virtual Double_tRooAbsReal::defaultErrorLevel() const; static RooNumGenConfig*RooAbsPdf::defaultGeneratorConfig(); static RooNumIntConfig*RooAbsReal::defaultIntegratorConfig(); virtual Int_tRooAbsArg::defaultPrintContents(Option_t* opt) const; static ostream&RooPrintable::defaultPrintStream(ostream* os = 0); virtual RooPrintable::StyleOptionRooPrintable::defaultPrintStyle(Option_t* opt) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; Bool_tRooAbsArg::dependentOverlaps(const RooAbsData* dset, const RooAbsArg& testArg) const; Bool_tRooAbsArg::dependentOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; Bool_tRooAbsArg::dependsOn(const RooAbsCollection& serverList, const RooAbsArg* ignoreArg = 0, Bool_t valueOnly = kFALSE) const; Bool_tRooAbsArg::dependsOn(const RooAbsArg& server, const RooAbsArg* ignoreArg = 0, Bool_t valueOnly = kFALSE) const; Bool_tRooAbsArg::dependsOnValue(const RooAbsCollection& serverList, const RooAbsArg* ignoreArg = 0) const; Bool_tRooAbsArg::dependsOnValue(const RooAbsArg& server, const RooAbsArg* ignoreArg = 0) const; RooDerivative*RooAbsReal::derivative(RooRealVar& obs, Int_t order = 1, Double_t eps = 0.",MatchSource.WIKI,root/html602/RooAbsCachedPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsCachedPdf.html
https://root.cern/root/html602/RooAbsCachedPdf.html:21899,Integrability,message,message,21899,"TObject::IsFolder() const; virtual Bool_tRooAbsArg::isFundamental() const; virtual Bool_tRooAbsReal::isIdentical(const RooAbsArg& other, Bool_t assumeSameType = kFALSE); virtual Bool_tRooAbsArg::isLValue() const; virtual Bool_tRooAbsReal::isOffsetting() const; Bool_tTObject::IsOnHeap() const; Bool_tRooAbsArg::isShapeDirty() const; Bool_tRooAbsArg::isShapeServer(const RooAbsArg& arg) const; Bool_tRooAbsArg::isShapeServer(const char* name) const; virtual Bool_tRooAbsArg::IsSortable() const; Bool_tRooAbsArg::isValueDirty() const; Bool_tRooAbsArg::isValueDirtyAndClear() const; Bool_tRooAbsArg::isValueOrShapeDirtyAndClear() const; Bool_tRooAbsArg::isValueServer(const RooAbsArg& arg) const; Bool_tRooAbsArg::isValueServer(const char* name) const; Bool_tTObject::IsZombie() const; voidRooAbsArg::leafNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t recurseNonDerived = kFALSE) const; Bool_tRooAbsArg::localNoDirtyInhibit() const; voidRooAbsReal::logEvalError(const char* message, const char* serverValueString = 0) const; static voidRooAbsReal::logEvalError(const RooAbsReal* originator, const char* origName, const char* message, const char* serverValueString = 0); virtual voidTNamed::ls(Option_t* option = """") const; virtual Double_tRooAbsReal::maxVal(Int_t code) const; voidTObject::MayNotUse(const char* method) const; RooAbsMoment*RooAbsReal::mean(RooRealVar& obs); RooAbsMoment*RooAbsReal::mean(RooRealVar& obs, const RooArgSet& nset); virtual Int_tRooAbsReal::minTrialSamples(const RooArgSet&) const; RooAbsMoment*RooAbsReal::moment(RooRealVar& obs, Int_t order, Bool_t central, Bool_t takeRoot); RooAbsMoment*RooAbsReal::moment(RooRealVar& obs, const RooArgSet& normObs, Int_t order, Bool_t central, Bool_t takeRoot, Bool_t intNormObs); Bool_tRooAbsPdf::mustBeExtended() const; static voidRooPrintable::nameFieldLength(Int_t newLen); const TNamed*RooAbsArg::namePtr() const; const char*RooAbsPdf::normRange() const; virtual Bool_tTObject::Notify(); Int_tRooAbsArg::n",MatchSource.WIKI,root/html602/RooAbsCachedPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsCachedPdf.html
https://root.cern/root/html602/RooAbsCachedPdf.html:22050,Integrability,message,message,22050,"ameType = kFALSE); virtual Bool_tRooAbsArg::isLValue() const; virtual Bool_tRooAbsReal::isOffsetting() const; Bool_tTObject::IsOnHeap() const; Bool_tRooAbsArg::isShapeDirty() const; Bool_tRooAbsArg::isShapeServer(const RooAbsArg& arg) const; Bool_tRooAbsArg::isShapeServer(const char* name) const; virtual Bool_tRooAbsArg::IsSortable() const; Bool_tRooAbsArg::isValueDirty() const; Bool_tRooAbsArg::isValueDirtyAndClear() const; Bool_tRooAbsArg::isValueOrShapeDirtyAndClear() const; Bool_tRooAbsArg::isValueServer(const RooAbsArg& arg) const; Bool_tRooAbsArg::isValueServer(const char* name) const; Bool_tTObject::IsZombie() const; voidRooAbsArg::leafNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t recurseNonDerived = kFALSE) const; Bool_tRooAbsArg::localNoDirtyInhibit() const; voidRooAbsReal::logEvalError(const char* message, const char* serverValueString = 0) const; static voidRooAbsReal::logEvalError(const RooAbsReal* originator, const char* origName, const char* message, const char* serverValueString = 0); virtual voidTNamed::ls(Option_t* option = """") const; virtual Double_tRooAbsReal::maxVal(Int_t code) const; voidTObject::MayNotUse(const char* method) const; RooAbsMoment*RooAbsReal::mean(RooRealVar& obs); RooAbsMoment*RooAbsReal::mean(RooRealVar& obs, const RooArgSet& nset); virtual Int_tRooAbsReal::minTrialSamples(const RooArgSet&) const; RooAbsMoment*RooAbsReal::moment(RooRealVar& obs, Int_t order, Bool_t central, Bool_t takeRoot); RooAbsMoment*RooAbsReal::moment(RooRealVar& obs, const RooArgSet& normObs, Int_t order, Bool_t central, Bool_t takeRoot, Bool_t intNormObs); Bool_tRooAbsPdf::mustBeExtended() const; static voidRooPrintable::nameFieldLength(Int_t newLen); const TNamed*RooAbsArg::namePtr() const; const char*RooAbsPdf::normRange() const; virtual Bool_tTObject::Notify(); Int_tRooAbsArg::numCaches() const; static Int_tRooAbsReal::numEvalErrorItems(); static Int_tRooAbsReal::numEvalErrors(); Bool_tRooAbsArg::observableOverlaps(const RooAb",MatchSource.WIKI,root/html602/RooAbsCachedPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsCachedPdf.html
https://root.cern/root/html602/RooAbsCachedPdf.html:42317,Integrability,integrat,integration,42317,,MatchSource.WIKI,root/html602/RooAbsCachedPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsCachedPdf.html
https://root.cern/root/html602/RooAbsCachedPdf.html:42383,Integrability,integrat,integration,42383,,MatchSource.WIKI,root/html602/RooAbsCachedPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsCachedPdf.html
https://root.cern/root/html602/RooAbsCachedPdf.html:43826,Integrability,integrat,integration,43826,"; Bool_tRooAbsReal::_boolValue! Transient cache for bool values from tree branches; UChar_tRooAbsReal::_byteValue! Transient cache for byte values from tree branches; static Bool_tRooAbsReal::_cacheCheckIf true, always validate contents of clean which outcome of evaluate(); deque<RooAbsCache*>RooAbsArg::_cacheListlist of caches; RooObjCacheManager_cacheMgrThe cache manager; RooRefCountListRooAbsArg::_clientListlist of client objects; RooRefCountListRooAbsArg::_clientListShapesubset of clients that requested shape dirty flag propagation; RooRefCountListRooAbsArg::_clientListValuesubset of clients that requested value dirty flag propagation; TIterator*RooAbsArg::_clientShapeIter! Iterator over _clientListShape; TIterator*RooAbsArg::_clientValueIter! Iterator over _clientListValue; Bool_tRooAbsArg::_deleteWatch! Delete watch flag; RooExpensiveObjectCache*RooAbsArg::_eocachePointer to global cache manager for any expensive components created by this object; Int_tRooAbsPdf::_errorCountNumber of errors remaining to print; static Bool_tRooAbsPdf::_evalError; Bool_tRooAbsArg::_fastAllow fast access mode in getVal() and proxies; Float_tRooAbsReal::_floatValue! Transient cache for floating point values from tree branches; Bool_tRooAbsReal::_forceNumIntForce numerical integration if flag set; static Bool_tRooAbsReal::_globalSelectCompGlobal activation switch for component selection; static Bool_tRooAbsReal::_hideOffsetOffset hiding flag; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; Int_tRooAbsReal::_intValue! Transient cache for integer values from tree branches; Int_t_ipOrderInterpolation order for cache histograms; Bool_tRooAbsArg::_isConstant! Cached isConstant status; TStringRooAbsReal::_labelPlot label for objects value; RooArgSet*RooAbsReal::_lastNSet!; Bool_tRooAbsArg::_localNoInhibitDirty! Prevent 'AlwaysDirty' mode for this node; static Int_tRooPrintable::_nameLength; TNamed*RooAbsArg::_namePtr! Do not persist.",MatchSource.WIKI,root/html602/RooAbsCachedPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsCachedPdf.html
https://root.cern/root/html602/RooAbsCachedPdf.html:46005,Integrability,integrat,integrator,46005,"egral (owned by _normMgr); RooObjCacheManagerRooAbsPdf::_normMgrThe cache manager; TStringRooAbsPdf::_normRangeNormalization range; static TStringRooAbsPdf::_normRangeOverride; RooArgSet*RooAbsPdf::_normSet! Normalization set with for above integral; RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; Int_tRooAbsReal::_plotBinsNumber of plot bins; Double_tRooAbsReal::_plotMaxMaximum of plot range; Double_tRooAbsReal::_plotMinMinimum of plot range; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; RooRefArrayRooAbsArg::_proxyListlist of proxies; Double_tRooAbsPdf::_rawValue; Char_tRooAbsReal::_sbyteValue! Transient cache for signed byte values from tree branches; Bool_tRooAbsPdf::_selectCompComponent selection flag for RooAbsPdf::plotCompOn; Bool_tRooAbsReal::_selectComp! Component selection flag for RooAbsPdf::plotCompOn; RooRefCountListRooAbsArg::_serverListlist of server objects; Bool_tRooAbsArg::_shapeDirtyFlag set if value needs recalculating because input shapes modified; RooNumGenConfig*RooAbsPdf::_specGeneratorConfig! MC generator configuration specific for this object; RooNumIntConfig*RooAbsReal::_specIntegratorConfigNumeric integrator configuration specific for this object; map<string,string>RooAbsArg::_stringAttribString attributes; Int_tRooAbsPdf::_traceCountNumber of traces remaining to print; Bool_tRooAbsReal::_treeVar!do not persist; UInt_tRooAbsReal::_uintValue! Transient cache for unsigned integer values from tree branches; TStringRooAbsReal::_unitUnit for objects value; Double_tRooAbsReal::_valueCache for current value of object; Bool_tRooAbsArg::_valueDirtyFlag set if value needs recalculating because input values modified; static Bool_tRooAbsArg::_verboseDirtyStatic flag controlling verbose messaging for dirty state changes; static Int_tRooAbsPdf::_verboseEval; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title.",MatchSource.WIKI,root/html602/RooAbsCachedPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsCachedPdf.html
https://root.cern/root/html602/RooAbsCachedPdf.html:48213,Integrability,integrat,integration,48213,"et = 0) const; Implementation of getVal() overriding default implementation; of RooAbsPdf. Return normalized value stored in cache p.d.f; rather than return value of evaluate() which is undefined; for RooAbsCachedPdf. RooAbsPdf* getCachePdf(const RooArgSet* nset = 0) const; Return pointer to RooHistPdf cache pdf for given choice of observables. RooDataHist* getCacheHist(const RooArgSet* nset = 0) const; Return pointer to RooDataHist cache histogram for given choice of observables. void clearCacheObject(RooAbsCachedPdf::PdfCacheElem& cache) const; Mark all bins of given cache as unitialized (value -1). TString cacheNameSuffix(const RooArgSet& nset) const; Construct string with unique suffix for cache objects based on; observable names that define cache configuration. void setInterpolationOrder(Int_t order); Change the interpolation order that is used in RooHistPdf cache; representation smoothing the RooDataHist shapes. Bool_t forceAnalyticalInt(const RooAbsArg& dep) const; Force RooRealIntegral to offer all our actual observable for internal; integration. Int_t getAnalyticalIntegralWN(RooArgSet& allVars, RooArgSet& analVars, const RooArgSet* normSet, const char* rangeName = 0) const; Advertises internal (analytical) integration capabilities. Call; is forwarded to RooHistPdf cache p.d.f of cache that is used for; given choice of observables. Double_t analyticalIntegralWN(Int_t code, const RooArgSet* normSet, const char* rangeName = 0) const; Implements internal (analytical) integration capabilities. Call; is forwarded to RooHistPdf cache p.d.f of cache that is used for; given choice of observables. RooAbsCachedPdf(); Default constructor. Bool_t selfNormalized() const; Declare p.d.f self normalized. RooAbsPdf* getCachePdf(const RooArgSet& nset) const; Return RooHistPdf that represents cache histogram. RooDataHist* getCacheHist(const RooArgSet& nset) const; Return RooDataHist with cached values. Int_t getInterpolationOrder() const; Set interpolation order in RooHistPdf t",MatchSource.WIKI,root/html602/RooAbsCachedPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsCachedPdf.html
https://root.cern/root/html602/RooAbsCachedPdf.html:48390,Integrability,integrat,integration,48390," evaluate() which is undefined; for RooAbsCachedPdf. RooAbsPdf* getCachePdf(const RooArgSet* nset = 0) const; Return pointer to RooHistPdf cache pdf for given choice of observables. RooDataHist* getCacheHist(const RooArgSet* nset = 0) const; Return pointer to RooDataHist cache histogram for given choice of observables. void clearCacheObject(RooAbsCachedPdf::PdfCacheElem& cache) const; Mark all bins of given cache as unitialized (value -1). TString cacheNameSuffix(const RooArgSet& nset) const; Construct string with unique suffix for cache objects based on; observable names that define cache configuration. void setInterpolationOrder(Int_t order); Change the interpolation order that is used in RooHistPdf cache; representation smoothing the RooDataHist shapes. Bool_t forceAnalyticalInt(const RooAbsArg& dep) const; Force RooRealIntegral to offer all our actual observable for internal; integration. Int_t getAnalyticalIntegralWN(RooArgSet& allVars, RooArgSet& analVars, const RooArgSet* normSet, const char* rangeName = 0) const; Advertises internal (analytical) integration capabilities. Call; is forwarded to RooHistPdf cache p.d.f of cache that is used for; given choice of observables. Double_t analyticalIntegralWN(Int_t code, const RooArgSet* normSet, const char* rangeName = 0) const; Implements internal (analytical) integration capabilities. Call; is forwarded to RooHistPdf cache p.d.f of cache that is used for; given choice of observables. RooAbsCachedPdf(); Default constructor. Bool_t selfNormalized() const; Declare p.d.f self normalized. RooAbsPdf* getCachePdf(const RooArgSet& nset) const; Return RooHistPdf that represents cache histogram. RooDataHist* getCacheHist(const RooArgSet& nset) const; Return RooDataHist with cached values. Int_t getInterpolationOrder() const; Set interpolation order in RooHistPdf that represent cached histogram. PdfCacheElem* getCache(const RooArgSet* nset, Bool_t recalculate = kTRUE) const. const char* payloadUniqueSuffix() const; { return 0",MatchSource.WIKI,root/html602/RooAbsCachedPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsCachedPdf.html
https://root.cern/root/html602/RooAbsCachedPdf.html:48652,Integrability,integrat,integration,48652,"e histogram for given choice of observables. void clearCacheObject(RooAbsCachedPdf::PdfCacheElem& cache) const; Mark all bins of given cache as unitialized (value -1). TString cacheNameSuffix(const RooArgSet& nset) const; Construct string with unique suffix for cache objects based on; observable names that define cache configuration. void setInterpolationOrder(Int_t order); Change the interpolation order that is used in RooHistPdf cache; representation smoothing the RooDataHist shapes. Bool_t forceAnalyticalInt(const RooAbsArg& dep) const; Force RooRealIntegral to offer all our actual observable for internal; integration. Int_t getAnalyticalIntegralWN(RooArgSet& allVars, RooArgSet& analVars, const RooArgSet* normSet, const char* rangeName = 0) const; Advertises internal (analytical) integration capabilities. Call; is forwarded to RooHistPdf cache p.d.f of cache that is used for; given choice of observables. Double_t analyticalIntegralWN(Int_t code, const RooArgSet* normSet, const char* rangeName = 0) const; Implements internal (analytical) integration capabilities. Call; is forwarded to RooHistPdf cache p.d.f of cache that is used for; given choice of observables. RooAbsCachedPdf(); Default constructor. Bool_t selfNormalized() const; Declare p.d.f self normalized. RooAbsPdf* getCachePdf(const RooArgSet& nset) const; Return RooHistPdf that represents cache histogram. RooDataHist* getCacheHist(const RooArgSet& nset) const; Return RooDataHist with cached values. Int_t getInterpolationOrder() const; Set interpolation order in RooHistPdf that represent cached histogram. PdfCacheElem* getCache(const RooArgSet* nset, Bool_t recalculate = kTRUE) const. const char* payloadUniqueSuffix() const; { return 0 ; }. const char* binningName() const; Return name of binning to be used for creation of cache histogram. PdfCacheElem* createCache(const RooArgSet* nset) const; Create cache storage element. const char* inputBaseName() const. RooArgSet* actualObservables(const RooArgSet& nset",MatchSource.WIKI,root/html602/RooAbsCachedPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsCachedPdf.html
https://root.cern/root/html602/RooAbsCachedPdf.html:11115,Modifiability,extend,extendedTerm,11115,"nt_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidRooAbsReal::enableOffsetting(Bool_t); virtual voidTObject::Error(const char* method, const char* msgfmt) const; static Bool_tRooAbsPdf::evalError(); static RooAbsReal::EvalErrorIterRooAbsReal::evalErrorIter(); static RooAbsReal::ErrorLoggingModeRooAbsReal::evalErrorLoggingMode(); virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual Double_tRooAbsPdf::expectedEvents(const RooArgSet* nset) const; virtual Double_tRooAbsPdf::expectedEvents(const RooArgSet& nset) const; RooExpensiveObjectCache&RooAbsArg::expensiveObjectCache() const; virtual Double_tRooAbsPdf::extendedTerm(Double_t observedEvents, const RooArgSet* nset = 0) const; virtual RooAbsPdf::ExtendModeRooAbsPdf::extendMode() const; virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); RooDataHist*RooAbsReal::fillDataHist(RooDataHist* hist, const RooArgSet* nset, Double_t scaleFactor, Bool_t correctForBinVolume = kFALSE, Bool_t showProgress = kFALSE) const; TH1*RooAbsReal::fillHistogram(TH1* hist, const RooArgList& plotVars, Double_t scaleFactor = 1, const RooArgSet* projectedVars = 0, Bool_t scaling = kTRUE, const RooArgSet* condObs = 0, Bool_t setError = kTRUE) const; Bool_tRooAbsArg::findConstantNodes(const RooArgSet& observables, RooArgSet& cacheList); Bool_tRooAbsArg::findConstantNodes(const RooArgSet& observables, RooArgSet& cacheList, RooLinkedList& processedNodes); RooAbsArg*RooAbsArg::findNewServer(const RooAbsCollection& newSet, Bool_t nameChange) const; virtual TObject*TObject::FindObject(const char* name) const; v",MatchSource.WIKI,root/html602/RooAbsCachedPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsCachedPdf.html
https://root.cern/root/html602/RooAbsCachedPdf.html:11227,Modifiability,extend,extendMode,11227,"U ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidRooAbsReal::enableOffsetting(Bool_t); virtual voidTObject::Error(const char* method, const char* msgfmt) const; static Bool_tRooAbsPdf::evalError(); static RooAbsReal::EvalErrorIterRooAbsReal::evalErrorIter(); static RooAbsReal::ErrorLoggingModeRooAbsReal::evalErrorLoggingMode(); virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual Double_tRooAbsPdf::expectedEvents(const RooArgSet* nset) const; virtual Double_tRooAbsPdf::expectedEvents(const RooArgSet& nset) const; RooExpensiveObjectCache&RooAbsArg::expensiveObjectCache() const; virtual Double_tRooAbsPdf::extendedTerm(Double_t observedEvents, const RooArgSet* nset = 0) const; virtual RooAbsPdf::ExtendModeRooAbsPdf::extendMode() const; virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); RooDataHist*RooAbsReal::fillDataHist(RooDataHist* hist, const RooArgSet* nset, Double_t scaleFactor, Bool_t correctForBinVolume = kFALSE, Bool_t showProgress = kFALSE) const; TH1*RooAbsReal::fillHistogram(TH1* hist, const RooArgList& plotVars, Double_t scaleFactor = 1, const RooArgSet* projectedVars = 0, Bool_t scaling = kTRUE, const RooArgSet* condObs = 0, Bool_t setError = kTRUE) const; Bool_tRooAbsArg::findConstantNodes(const RooArgSet& observables, RooArgSet& cacheList); Bool_tRooAbsArg::findConstantNodes(const RooArgSet& observables, RooArgSet& cacheList, RooLinkedList& processedNodes); RooAbsArg*RooAbsArg::findNewServer(const RooAbsCollection& newSet, Bool_t nameChange) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; Double_tRooAbsReal::findRoot(RooRealVar& x, Doubl",MatchSource.WIKI,root/html602/RooAbsCachedPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsCachedPdf.html
https://root.cern/root/html602/RooAbsCachedPdf.html:14729,Modifiability,extend,extended,14729,"ec&) const; RooDataSet*RooAbsPdf::generate(const RooArgSet& whatVars, const RooDataSet& prototype, Int_t nEvents = 0, Bool_t verbose = kFALSE, Bool_t randProtoOrder = kFALSE, Bool_t resampleProto = kFALSE) const; RooDataSet*RooAbsPdf::generate(const RooArgSet& whatVars, Int_t nEvents, const RooCmdArg& arg1, const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none()); RooDataSet*RooAbsPdf::generate(const RooArgSet& whatVars, const RooCmdArg& arg1 = RooCmdArg::none(), const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none()); RooDataSet*RooAbsPdf::generate(const RooArgSet& whatVars, Double_t nEvents = 0, Bool_t verbose = kFALSE, Bool_t autoBinned = kTRUE, const char* binnedTag = """", Bool_t expectedData = kFALSE, Bool_t extended = kFALSE) const; virtual RooDataHist*RooAbsPdf::generateBinned(const RooArgSet& whatVars, Double_t nEvents, Bool_t expectedData = kFALSE, Bool_t extended = kFALSE) const; virtual RooDataHist*RooAbsPdf::generateBinned(const RooArgSet& whatVars, Double_t nEvents, const RooCmdArg& arg1, const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none()); virtual RooDataHist*RooAbsPdf::generateBinned(const RooArgSet& whatVars, const RooCmdArg& arg1 = RooCmdArg::none(), const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none()); virtual voidRooAbsPdf::generateEvent(Int_t code); virtual RooDataSet*RooAbsPdf::generateSimGlobal(const RooArgSet& whatVars, Int_t nEvents); virtual RooArgSet*RooAbsPdf::getAllConstraints(const RooArgSet& o",MatchSource.WIKI,root/html602/RooAbsCachedPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsCachedPdf.html
https://root.cern/root/html602/RooAbsCachedPdf.html:14883,Modifiability,extend,extended,14883,"ProtoOrder = kFALSE, Bool_t resampleProto = kFALSE) const; RooDataSet*RooAbsPdf::generate(const RooArgSet& whatVars, Int_t nEvents, const RooCmdArg& arg1, const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none()); RooDataSet*RooAbsPdf::generate(const RooArgSet& whatVars, const RooCmdArg& arg1 = RooCmdArg::none(), const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none()); RooDataSet*RooAbsPdf::generate(const RooArgSet& whatVars, Double_t nEvents = 0, Bool_t verbose = kFALSE, Bool_t autoBinned = kTRUE, const char* binnedTag = """", Bool_t expectedData = kFALSE, Bool_t extended = kFALSE) const; virtual RooDataHist*RooAbsPdf::generateBinned(const RooArgSet& whatVars, Double_t nEvents, Bool_t expectedData = kFALSE, Bool_t extended = kFALSE) const; virtual RooDataHist*RooAbsPdf::generateBinned(const RooArgSet& whatVars, Double_t nEvents, const RooCmdArg& arg1, const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none()); virtual RooDataHist*RooAbsPdf::generateBinned(const RooArgSet& whatVars, const RooCmdArg& arg1 = RooCmdArg::none(), const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none()); virtual voidRooAbsPdf::generateEvent(Int_t code); virtual RooDataSet*RooAbsPdf::generateSimGlobal(const RooArgSet& whatVars, Int_t nEvents); virtual RooArgSet*RooAbsPdf::getAllConstraints(const RooArgSet& observables, RooArgSet& constrainedParams, Bool_t stripDisconnected = kTRUE) const; virtual Int_tRooAbsReal::getAnalyticalIntegral(RooArgSet& allVars, RooA",MatchSource.WIKI,root/html602/RooAbsCachedPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsCachedPdf.html
https://root.cern/root/html602/RooAbsCachedPdf.html:29974,Modifiability,config,config,29974,"ect::SavePrimitive(ostream& out, Option_t* option = """"); virtual Bool_tselfNormalized() const; TIterator*RooAbsArg::serverIterator() const; RooFIterRooAbsArg::serverMIterator() const; virtual voidRooAbsArg::serverNameChangeHook(const RooAbsArg*, const RooAbsArg*); voidRooAbsArg::setAttribute(const Text_t* name, Bool_t value = kTRUE); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); virtual voidRooAbsArg::setCacheAndTrackHints(RooArgSet&); static voidRooAbsReal::setCacheCheck(Bool_t flag); virtual Bool_tRooAbsReal::setData(RooAbsData&, Bool_t = kTRUE); static voidRooAbsArg::setDirtyInhibit(Bool_t flag); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); static voidRooAbsReal::setEvalErrorLoggingMode(RooAbsReal::ErrorLoggingMode m); virtual voidRooAbsArg::setExpensiveObjectCache(RooExpensiveObjectCache& cache); voidRooAbsPdf::setGeneratorConfig(); voidRooAbsPdf::setGeneratorConfig(const RooNumGenConfig& config); static voidRooAbsReal::setHideOffset(Bool_t flag); voidRooAbsReal::setIntegratorConfig(); voidRooAbsReal::setIntegratorConfig(const RooNumIntConfig& config); voidsetInterpolationOrder(Int_t order); voidRooAbsArg::setLocalNoDirtyInhibit(Bool_t flag) const; virtual voidRooAbsArg::SetName(const char* name); virtual voidRooAbsArg::SetNameTitle(const char* name, const char* title); voidRooAbsPdf::setNormRange(const char* rangeName); voidRooAbsPdf::setNormRangeOverride(const char* rangeName); static voidTObject::SetObjectStat(Bool_t stat); voidRooAbsArg::setOperMode(RooAbsArg::OperMode mode, Bool_t recurseADirty = kTRUE); voidRooAbsReal::setParameterizeIntegral(const RooArgSet& paramVars); voidRooAbsReal::setPlotLabel(const char* label); voidRooAbsArg::setProhibitServerRedirect(Bool_t flag); voidRooAbsArg::setShapeDirty() const; voidRooAbsArg::setStringAttribute(const Text_t* key, const Text_t* value); virtual voidTNamed::SetTitle(const char* title = """")MENU ; voidRooAbsPdf::setTraceCou",MatchSource.WIKI,root/html602/RooAbsCachedPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsCachedPdf.html
https://root.cern/root/html602/RooAbsCachedPdf.html:30132,Modifiability,config,config,30132,":serverMIterator() const; virtual voidRooAbsArg::serverNameChangeHook(const RooAbsArg*, const RooAbsArg*); voidRooAbsArg::setAttribute(const Text_t* name, Bool_t value = kTRUE); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); virtual voidRooAbsArg::setCacheAndTrackHints(RooArgSet&); static voidRooAbsReal::setCacheCheck(Bool_t flag); virtual Bool_tRooAbsReal::setData(RooAbsData&, Bool_t = kTRUE); static voidRooAbsArg::setDirtyInhibit(Bool_t flag); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); static voidRooAbsReal::setEvalErrorLoggingMode(RooAbsReal::ErrorLoggingMode m); virtual voidRooAbsArg::setExpensiveObjectCache(RooExpensiveObjectCache& cache); voidRooAbsPdf::setGeneratorConfig(); voidRooAbsPdf::setGeneratorConfig(const RooNumGenConfig& config); static voidRooAbsReal::setHideOffset(Bool_t flag); voidRooAbsReal::setIntegratorConfig(); voidRooAbsReal::setIntegratorConfig(const RooNumIntConfig& config); voidsetInterpolationOrder(Int_t order); voidRooAbsArg::setLocalNoDirtyInhibit(Bool_t flag) const; virtual voidRooAbsArg::SetName(const char* name); virtual voidRooAbsArg::SetNameTitle(const char* name, const char* title); voidRooAbsPdf::setNormRange(const char* rangeName); voidRooAbsPdf::setNormRangeOverride(const char* rangeName); static voidTObject::SetObjectStat(Bool_t stat); voidRooAbsArg::setOperMode(RooAbsArg::OperMode mode, Bool_t recurseADirty = kTRUE); voidRooAbsReal::setParameterizeIntegral(const RooArgSet& paramVars); voidRooAbsReal::setPlotLabel(const char* label); voidRooAbsArg::setProhibitServerRedirect(Bool_t flag); voidRooAbsArg::setShapeDirty() const; voidRooAbsArg::setStringAttribute(const Text_t* key, const Text_t* value); virtual voidTNamed::SetTitle(const char* title = """")MENU ; voidRooAbsPdf::setTraceCounter(Int_t value, Bool_t allNodes = kFALSE); voidRooAbsArg::setTransientAttribute(const Text_t* name, Bool_t value = kTRUE); virtual voidTObject::SetUniqueID(",MatchSource.WIKI,root/html602/RooAbsCachedPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsCachedPdf.html
https://root.cern/root/html602/RooAbsCachedPdf.html:35278,Modifiability,extend,extended,35278,"heElem*createCache(const RooArgSet* nset) const; RooAbsReal*RooAbsReal::createIntObj(const RooArgSet& iset, const RooArgSet* nset, const RooNumIntConfig* cfg, const char* rangeName) const; voiddisableCache(Bool_t flag); virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; virtual Double_tRooAbsReal::evaluate() const; virtual voidfillCacheObject(RooAbsCachedPdf::PdfCacheElem& cache) const; virtual voidRooAbsReal::fillTreeBranch(TTree& t); voidRooAbsReal::findInnerMostIntegration(const RooArgSet& allObs, RooArgSet& innerObs, const char* rangeName) const; virtual RooAbsGenContext*RooAbsPdf::genContext(const RooArgSet& vars, const RooDataSet* prototype = 0, const RooArgSet* auxProto = 0, Bool_t verbose = kFALSE) const; RooDataSet*RooAbsPdf::generate(RooAbsGenContext& context, const RooArgSet& whatVars, const RooDataSet* prototype, Double_t nEvents, Bool_t verbose, Bool_t randProtoOrder, Bool_t resampleProto, Bool_t skipInit = kFALSE, Bool_t extended = kFALSE) const; RooAbsCachedPdf::PdfCacheElem*getCache(const RooArgSet* nset, Bool_t recalculate = kTRUE) const; virtual voidRooAbsArg::getObservablesHook(const RooArgSet*, RooArgSet*) const; virtual voidRooAbsArg::getParametersHook(const RooArgSet*, RooArgSet*, Bool_t) const; RooAbsProxy*RooAbsArg::getProxy(Int_t index) const; static voidRooAbsReal::globalSelectComp(Bool_t flag); voidRooAbsArg::graphVizAddConnections(set<pair<RooAbsArg*,RooAbsArg*> >&); virtual TStringhistNameSuffix() const; Bool_tRooAbsArg::inhibitDirty() const; virtual const char*inputBaseName() const; TStringRooAbsReal::integralNameSuffix(const RooArgSet& iset, const RooArgSet* nset = 0, const char* rangeName = 0, Bool_t omitEmpty = kFALSE) const; Bool_tRooAbsReal::isSelectedComp() const; virtual Bool_tRooAbsReal::isValid() const; virtual Bool_tRooAbsReal::isValidReal(Double_t value, Bool_t printError = kFALSE) const; voidRooAbsReal::makeProjectionSet(const RooAbsArg* plotVar, const RooArgSet* allVars, RooArgS",MatchSource.WIKI,root/html602/RooAbsCachedPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsCachedPdf.html
https://root.cern/root/html602/RooAbsCachedPdf.html:45908,Modifiability,config,configuration,45908,"egral (owned by _normMgr); RooObjCacheManagerRooAbsPdf::_normMgrThe cache manager; TStringRooAbsPdf::_normRangeNormalization range; static TStringRooAbsPdf::_normRangeOverride; RooArgSet*RooAbsPdf::_normSet! Normalization set with for above integral; RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; Int_tRooAbsReal::_plotBinsNumber of plot bins; Double_tRooAbsReal::_plotMaxMaximum of plot range; Double_tRooAbsReal::_plotMinMinimum of plot range; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; RooRefArrayRooAbsArg::_proxyListlist of proxies; Double_tRooAbsPdf::_rawValue; Char_tRooAbsReal::_sbyteValue! Transient cache for signed byte values from tree branches; Bool_tRooAbsPdf::_selectCompComponent selection flag for RooAbsPdf::plotCompOn; Bool_tRooAbsReal::_selectComp! Component selection flag for RooAbsPdf::plotCompOn; RooRefCountListRooAbsArg::_serverListlist of server objects; Bool_tRooAbsArg::_shapeDirtyFlag set if value needs recalculating because input shapes modified; RooNumGenConfig*RooAbsPdf::_specGeneratorConfig! MC generator configuration specific for this object; RooNumIntConfig*RooAbsReal::_specIntegratorConfigNumeric integrator configuration specific for this object; map<string,string>RooAbsArg::_stringAttribString attributes; Int_tRooAbsPdf::_traceCountNumber of traces remaining to print; Bool_tRooAbsReal::_treeVar!do not persist; UInt_tRooAbsReal::_uintValue! Transient cache for unsigned integer values from tree branches; TStringRooAbsReal::_unitUnit for objects value; Double_tRooAbsReal::_valueCache for current value of object; Bool_tRooAbsArg::_valueDirtyFlag set if value needs recalculating because input values modified; static Bool_tRooAbsArg::_verboseDirtyStatic flag controlling verbose messaging for dirty state changes; static Int_tRooAbsPdf::_verboseEval; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title.",MatchSource.WIKI,root/html602/RooAbsCachedPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsCachedPdf.html
https://root.cern/root/html602/RooAbsCachedPdf.html:46016,Modifiability,config,configuration,46016,"egral (owned by _normMgr); RooObjCacheManagerRooAbsPdf::_normMgrThe cache manager; TStringRooAbsPdf::_normRangeNormalization range; static TStringRooAbsPdf::_normRangeOverride; RooArgSet*RooAbsPdf::_normSet! Normalization set with for above integral; RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; Int_tRooAbsReal::_plotBinsNumber of plot bins; Double_tRooAbsReal::_plotMaxMaximum of plot range; Double_tRooAbsReal::_plotMinMinimum of plot range; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; RooRefArrayRooAbsArg::_proxyListlist of proxies; Double_tRooAbsPdf::_rawValue; Char_tRooAbsReal::_sbyteValue! Transient cache for signed byte values from tree branches; Bool_tRooAbsPdf::_selectCompComponent selection flag for RooAbsPdf::plotCompOn; Bool_tRooAbsReal::_selectComp! Component selection flag for RooAbsPdf::plotCompOn; RooRefCountListRooAbsArg::_serverListlist of server objects; Bool_tRooAbsArg::_shapeDirtyFlag set if value needs recalculating because input shapes modified; RooNumGenConfig*RooAbsPdf::_specGeneratorConfig! MC generator configuration specific for this object; RooNumIntConfig*RooAbsReal::_specIntegratorConfigNumeric integrator configuration specific for this object; map<string,string>RooAbsArg::_stringAttribString attributes; Int_tRooAbsPdf::_traceCountNumber of traces remaining to print; Bool_tRooAbsReal::_treeVar!do not persist; UInt_tRooAbsReal::_uintValue! Transient cache for unsigned integer values from tree branches; TStringRooAbsReal::_unitUnit for objects value; Double_tRooAbsReal::_valueCache for current value of object; Bool_tRooAbsArg::_valueDirtyFlag set if value needs recalculating because input values modified; static Bool_tRooAbsArg::_verboseDirtyStatic flag controlling verbose messaging for dirty state changes; static Int_tRooAbsPdf::_verboseEval; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title.",MatchSource.WIKI,root/html602/RooAbsCachedPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsCachedPdf.html
https://root.cern/root/html602/RooAbsCachedPdf.html:47917,Modifiability,config,configuration,47917,"ce; Inherited Members; Includes; Libraries. Function documentation; RooAbsCachedPdf(const char* name, const char* title, Int_t ipOrder = 0); Constructor. RooAbsCachedPdf(const RooAbsCachedPdf& other, const char* name = 0); Copy constructor. ~RooAbsCachedPdf(); Destructor. Double_t getValV(const RooArgSet* set = 0) const; Implementation of getVal() overriding default implementation; of RooAbsPdf. Return normalized value stored in cache p.d.f; rather than return value of evaluate() which is undefined; for RooAbsCachedPdf. RooAbsPdf* getCachePdf(const RooArgSet* nset = 0) const; Return pointer to RooHistPdf cache pdf for given choice of observables. RooDataHist* getCacheHist(const RooArgSet* nset = 0) const; Return pointer to RooDataHist cache histogram for given choice of observables. void clearCacheObject(RooAbsCachedPdf::PdfCacheElem& cache) const; Mark all bins of given cache as unitialized (value -1). TString cacheNameSuffix(const RooArgSet& nset) const; Construct string with unique suffix for cache objects based on; observable names that define cache configuration. void setInterpolationOrder(Int_t order); Change the interpolation order that is used in RooHistPdf cache; representation smoothing the RooDataHist shapes. Bool_t forceAnalyticalInt(const RooAbsArg& dep) const; Force RooRealIntegral to offer all our actual observable for internal; integration. Int_t getAnalyticalIntegralWN(RooArgSet& allVars, RooArgSet& analVars, const RooArgSet* normSet, const char* rangeName = 0) const; Advertises internal (analytical) integration capabilities. Call; is forwarded to RooHistPdf cache p.d.f of cache that is used for; given choice of observables. Double_t analyticalIntegralWN(Int_t code, const RooArgSet* normSet, const char* rangeName = 0) const; Implements internal (analytical) integration capabilities. Call; is forwarded to RooHistPdf cache p.d.f of cache that is used for; given choice of observables. RooAbsCachedPdf(); Default constructor. Bool_t selfNormalized() cons",MatchSource.WIKI,root/html602/RooAbsCachedPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsCachedPdf.html
https://root.cern/root/html602/RooAbsCachedPdf.html:393,Performance,cache,cache,393,". RooAbsCachedPdf. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » ROOFIT; » ROOFITCORE; » RooAbsCachedPdf. class RooAbsCachedPdf: public RooAbsPdf. RooAbsCachedPdf is the abstract base class for p.d.f.s that need or; want to cache their evaluate() output in a RooHistPdf defined in; terms of the used observables. This base class manages the creation; and storage of all RooHistPdf cache p.d.fs and the RooDataHists; that define their shape. Implementations of RooAbsCachedPdf must; define member function fillCacheObject() which serves to fill an; already created RooDataHist with the p.d.fs function values. In; addition the member functions actualObservables() and; actualParameters() must be define which report what the actual; observables to be cached are for a given set of observables passed; by the user to getVal() and on which parameters need to be tracked; for changes to trigger a refilling of the cache histogram.; . Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~RooAbsCachedPdf(); voidTObject::AbstractMethod(const char* method) const; Bool_tRooAbsArg::addOwnedComponents(const RooArgSet& comps); voidRooAbsArg::addParameters(RooArgSet& params, const RooArgSet* nset = 0, Bool_t stripDisconnected = kTRUE) const; voidRooAbsArg::addServer(RooAbsArg& server, Bool_t valueProp = kTRUE, Bool_t shapeProp = kFALSE); voidRooAbsArg::addServerList(RooAbsCollection& serverList, Bool_t valueProp = kTRUE, Bool_t shapeProp = kFALSE); const char*RooAbsArg::aggregateCacheUniqueSuffix() const; virtual Double_tRooAbsReal::analyticalIntegral(Int_t code, const char* rangeName = 0) const; virtual Double_tanalyticalIntegralWN(Int_t code, const RooArgSet* normSet, const char* rangeName = 0) const; virt",MatchSource.WIKI,root/html602/RooAbsCachedPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsCachedPdf.html
https://root.cern/root/html602/RooAbsCachedPdf.html:550,Performance,cache,cache,550,". RooAbsCachedPdf. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » ROOFIT; » ROOFITCORE; » RooAbsCachedPdf. class RooAbsCachedPdf: public RooAbsPdf. RooAbsCachedPdf is the abstract base class for p.d.f.s that need or; want to cache their evaluate() output in a RooHistPdf defined in; terms of the used observables. This base class manages the creation; and storage of all RooHistPdf cache p.d.fs and the RooDataHists; that define their shape. Implementations of RooAbsCachedPdf must; define member function fillCacheObject() which serves to fill an; already created RooDataHist with the p.d.fs function values. In; addition the member functions actualObservables() and; actualParameters() must be define which report what the actual; observables to be cached are for a given set of observables passed; by the user to getVal() and on which parameters need to be tracked; for changes to trigger a refilling of the cache histogram.; . Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~RooAbsCachedPdf(); voidTObject::AbstractMethod(const char* method) const; Bool_tRooAbsArg::addOwnedComponents(const RooArgSet& comps); voidRooAbsArg::addParameters(RooArgSet& params, const RooArgSet* nset = 0, Bool_t stripDisconnected = kTRUE) const; voidRooAbsArg::addServer(RooAbsArg& server, Bool_t valueProp = kTRUE, Bool_t shapeProp = kFALSE); voidRooAbsArg::addServerList(RooAbsCollection& serverList, Bool_t valueProp = kTRUE, Bool_t shapeProp = kFALSE); const char*RooAbsArg::aggregateCacheUniqueSuffix() const; virtual Double_tRooAbsReal::analyticalIntegral(Int_t code, const char* rangeName = 0) const; virtual Double_tanalyticalIntegralWN(Int_t code, const RooArgSet* normSet, const char* rangeName = 0) const; virt",MatchSource.WIKI,root/html602/RooAbsCachedPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsCachedPdf.html
https://root.cern/root/html602/RooAbsCachedPdf.html:919,Performance,cache,cached,919,". RooAbsCachedPdf. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » ROOFIT; » ROOFITCORE; » RooAbsCachedPdf. class RooAbsCachedPdf: public RooAbsPdf. RooAbsCachedPdf is the abstract base class for p.d.f.s that need or; want to cache their evaluate() output in a RooHistPdf defined in; terms of the used observables. This base class manages the creation; and storage of all RooHistPdf cache p.d.fs and the RooDataHists; that define their shape. Implementations of RooAbsCachedPdf must; define member function fillCacheObject() which serves to fill an; already created RooDataHist with the p.d.fs function values. In; addition the member functions actualObservables() and; actualParameters() must be define which report what the actual; observables to be cached are for a given set of observables passed; by the user to getVal() and on which parameters need to be tracked; for changes to trigger a refilling of the cache histogram.; . Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~RooAbsCachedPdf(); voidTObject::AbstractMethod(const char* method) const; Bool_tRooAbsArg::addOwnedComponents(const RooArgSet& comps); voidRooAbsArg::addParameters(RooArgSet& params, const RooArgSet* nset = 0, Bool_t stripDisconnected = kTRUE) const; voidRooAbsArg::addServer(RooAbsArg& server, Bool_t valueProp = kTRUE, Bool_t shapeProp = kFALSE); voidRooAbsArg::addServerList(RooAbsCollection& serverList, Bool_t valueProp = kTRUE, Bool_t shapeProp = kFALSE); const char*RooAbsArg::aggregateCacheUniqueSuffix() const; virtual Double_tRooAbsReal::analyticalIntegral(Int_t code, const char* rangeName = 0) const; virtual Double_tanalyticalIntegralWN(Int_t code, const RooArgSet* normSet, const char* rangeName = 0) const; virt",MatchSource.WIKI,root/html602/RooAbsCachedPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsCachedPdf.html
https://root.cern/root/html602/RooAbsCachedPdf.html:1079,Performance,cache,cache,1079,". RooAbsCachedPdf. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » ROOFIT; » ROOFITCORE; » RooAbsCachedPdf. class RooAbsCachedPdf: public RooAbsPdf. RooAbsCachedPdf is the abstract base class for p.d.f.s that need or; want to cache their evaluate() output in a RooHistPdf defined in; terms of the used observables. This base class manages the creation; and storage of all RooHistPdf cache p.d.fs and the RooDataHists; that define their shape. Implementations of RooAbsCachedPdf must; define member function fillCacheObject() which serves to fill an; already created RooDataHist with the p.d.fs function values. In; addition the member functions actualObservables() and; actualParameters() must be define which report what the actual; observables to be cached are for a given set of observables passed; by the user to getVal() and on which parameters need to be tracked; for changes to trigger a refilling of the cache histogram.; . Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~RooAbsCachedPdf(); voidTObject::AbstractMethod(const char* method) const; Bool_tRooAbsArg::addOwnedComponents(const RooArgSet& comps); voidRooAbsArg::addParameters(RooArgSet& params, const RooArgSet* nset = 0, Bool_t stripDisconnected = kTRUE) const; voidRooAbsArg::addServer(RooAbsArg& server, Bool_t valueProp = kTRUE, Bool_t shapeProp = kFALSE); voidRooAbsArg::addServerList(RooAbsCollection& serverList, Bool_t valueProp = kTRUE, Bool_t shapeProp = kFALSE); const char*RooAbsArg::aggregateCacheUniqueSuffix() const; virtual Double_tRooAbsReal::analyticalIntegral(Int_t code, const char* rangeName = 0) const; virtual Double_tanalyticalIntegralWN(Int_t code, const RooArgSet* normSet, const char* rangeName = 0) const; virt",MatchSource.WIKI,root/html602/RooAbsCachedPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsCachedPdf.html
https://root.cern/root/html602/RooAbsCachedPdf.html:2754,Performance,cache,cacheUniqueSuffix,2754,"egateCacheUniqueSuffix() const; virtual Double_tRooAbsReal::analyticalIntegral(Int_t code, const char* rangeName = 0) const; virtual Double_tanalyticalIntegralWN(Int_t code, const RooArgSet* normSet, const char* rangeName = 0) const; virtual voidTObject::AppendPad(Option_t* option = """"); TF1*RooAbsReal::asTF(const RooArgList& obs, const RooArgList& pars = RooArgList(), const RooArgSet& nset = RooArgSet()) const; voidRooAbsArg::attachDataSet(const RooAbsData& set); voidRooAbsArg::attachDataStore(const RooAbsDataStore& set); const set<string>&RooAbsArg::attributes() const; virtual list<Double_t>*RooAbsReal::binBoundaries(RooAbsRealLValue&, Double_t, Double_t) const; RooAbsFunc*RooAbsReal::bindVars(const RooArgSet& vars, const RooArgSet* nset = 0, Bool_t clipInvalid = kFALSE) const; voidRooAbsArg::branchNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t recurseNonDerived = kFALSE) const; virtual voidTObject::Browse(TBrowser* b); virtual const char*RooAbsArg::cacheUniqueSuffix() const; Bool_tRooAbsPdf::canBeExtended() const; virtual RooAbsArg::CacheModeRooAbsArg::canNodeBeCached() const; voidRooAbsArg::changeServer(RooAbsArg& server, Bool_t valueProp, Bool_t shapeProp); Bool_tRooAbsArg::checkDependents(const RooArgSet* nset) const; virtual Bool_tRooAbsArg::checkObservables(const RooArgSet* nset) const; virtual RooFitResult*RooAbsPdf::chi2FitTo(RooDataHist& data, const RooLinkedList& cmdList); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); static voidRooAbsPdf::clearEvalError(); static voidRooAbsReal::clearEvalErrorLog(); voidRooAbsArg::clearShapeDirty() const; voidRooAbsArg::clearValueAndShapeDirty() const; voidRooAbsArg::clearValueDirty() const; TIterator*RooAbsArg::clientIterator() const; virtual TObject*RooAbsArg::clone(const char* newname = 0) const; virtual TObject*RooAbsArg::Clone(const char* newname = 0) const; virtual RooAbsArg*RooAbsArg::cloneTree(const char* newname =",MatchSource.WIKI,root/html602/RooAbsCachedPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsCachedPdf.html
https://root.cern/root/html602/RooAbsCachedPdf.html:11836,Performance,cache,cacheList,11836,"ent(Int_t event, Int_t px, Int_t py); virtual Double_tRooAbsPdf::expectedEvents(const RooArgSet* nset) const; virtual Double_tRooAbsPdf::expectedEvents(const RooArgSet& nset) const; RooExpensiveObjectCache&RooAbsArg::expensiveObjectCache() const; virtual Double_tRooAbsPdf::extendedTerm(Double_t observedEvents, const RooArgSet* nset = 0) const; virtual RooAbsPdf::ExtendModeRooAbsPdf::extendMode() const; virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); RooDataHist*RooAbsReal::fillDataHist(RooDataHist* hist, const RooArgSet* nset, Double_t scaleFactor, Bool_t correctForBinVolume = kFALSE, Bool_t showProgress = kFALSE) const; TH1*RooAbsReal::fillHistogram(TH1* hist, const RooArgList& plotVars, Double_t scaleFactor = 1, const RooArgSet* projectedVars = 0, Bool_t scaling = kTRUE, const RooArgSet* condObs = 0, Bool_t setError = kTRUE) const; Bool_tRooAbsArg::findConstantNodes(const RooArgSet& observables, RooArgSet& cacheList); Bool_tRooAbsArg::findConstantNodes(const RooArgSet& observables, RooArgSet& cacheList, RooLinkedList& processedNodes); RooAbsArg*RooAbsArg::findNewServer(const RooAbsCollection& newSet, Bool_t nameChange) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; Double_tRooAbsReal::findRoot(RooRealVar& x, Double_t xmin, Double_t xmax, Double_t yval); RooAbsArg*RooAbsArg::findServer(const char* name) const; RooAbsArg*RooAbsArg::findServer(const RooAbsArg& arg) const; RooAbsArg*RooAbsArg::findServer(Int_t index) const; virtual RooFitResult*RooAbsPdf::fitTo(RooAbsData& data, const RooLinkedList& cmdList); virtual RooFitResult*RooAbsPdf::fitTo(RooAbsData& data, const RooCmdArg& arg1 = RooCmdArg::none(), const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none",MatchSource.WIKI,root/html602/RooAbsCachedPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsCachedPdf.html
https://root.cern/root/html602/RooAbsCachedPdf.html:11924,Performance,cache,cacheList,11924,"oArgSet* nset) const; virtual Double_tRooAbsPdf::expectedEvents(const RooArgSet& nset) const; RooExpensiveObjectCache&RooAbsArg::expensiveObjectCache() const; virtual Double_tRooAbsPdf::extendedTerm(Double_t observedEvents, const RooArgSet* nset = 0) const; virtual RooAbsPdf::ExtendModeRooAbsPdf::extendMode() const; virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); RooDataHist*RooAbsReal::fillDataHist(RooDataHist* hist, const RooArgSet* nset, Double_t scaleFactor, Bool_t correctForBinVolume = kFALSE, Bool_t showProgress = kFALSE) const; TH1*RooAbsReal::fillHistogram(TH1* hist, const RooArgList& plotVars, Double_t scaleFactor = 1, const RooArgSet* projectedVars = 0, Bool_t scaling = kTRUE, const RooArgSet* condObs = 0, Bool_t setError = kTRUE) const; Bool_tRooAbsArg::findConstantNodes(const RooArgSet& observables, RooArgSet& cacheList); Bool_tRooAbsArg::findConstantNodes(const RooArgSet& observables, RooArgSet& cacheList, RooLinkedList& processedNodes); RooAbsArg*RooAbsArg::findNewServer(const RooAbsCollection& newSet, Bool_t nameChange) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; Double_tRooAbsReal::findRoot(RooRealVar& x, Double_t xmin, Double_t xmax, Double_t yval); RooAbsArg*RooAbsArg::findServer(const char* name) const; RooAbsArg*RooAbsArg::findServer(const RooAbsArg& arg) const; RooAbsArg*RooAbsArg::findServer(Int_t index) const; virtual RooFitResult*RooAbsPdf::fitTo(RooAbsData& data, const RooLinkedList& cmdList); virtual RooFitResult*RooAbsPdf::fitTo(RooAbsData& data, const RooCmdArg& arg1 = RooCmdArg::none(), const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()",MatchSource.WIKI,root/html602/RooAbsCachedPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsCachedPdf.html
https://root.cern/root/html602/RooAbsCachedPdf.html:23943,Performance,optimiz,optimizeCacheMode,23943,"ooRealVar& obs, Int_t order, Bool_t central, Bool_t takeRoot); RooAbsMoment*RooAbsReal::moment(RooRealVar& obs, const RooArgSet& normObs, Int_t order, Bool_t central, Bool_t takeRoot, Bool_t intNormObs); Bool_tRooAbsPdf::mustBeExtended() const; static voidRooPrintable::nameFieldLength(Int_t newLen); const TNamed*RooAbsArg::namePtr() const; const char*RooAbsPdf::normRange() const; virtual Bool_tTObject::Notify(); Int_tRooAbsArg::numCaches() const; static Int_tRooAbsReal::numEvalErrorItems(); static Int_tRooAbsReal::numEvalErrors(); Bool_tRooAbsArg::observableOverlaps(const RooAbsData* dset, const RooAbsArg& testArg) const; Bool_tRooAbsArg::observableOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; virtual Double_tRooAbsReal::offset() const; voidTObject::operator delete(void* ptr); voidTObject::operator delete(void* ptr, void* vp); voidTObject::operator delete[](void* ptr); voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); RooAbsCachedPdf&operator=(const RooAbsCachedPdf&); Bool_tRooAbsReal::operator==(Double_t value) const; virtual Bool_tRooAbsReal::operator==(const RooAbsArg& other); RooAbsArg::OperModeRooAbsArg::operMode() const; virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables); virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables, RooArgSet& optNodes, RooLinkedList& processedNodes); Bool_tRooAbsArg::overlaps(const RooAbsArg& testArg, Bool_t valueOnly = kFALSE) const; const RooArgSet*RooAbsArg::ownedComponents() const; virtual voidTObject::Paint(Option_t* option = """"); virtual RooPlot*RooAbsPdf::paramOn(RooPlot* frame, const RooAbsData* data, const char* label = """", Int_t sigDigits = 2, Option_t* options = ""NELU"", Double_t xmin = 0.",MatchSource.WIKI,root/html602/RooAbsCachedPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsCachedPdf.html
https://root.cern/root/html602/RooAbsCachedPdf.html:24015,Performance,optimiz,optimizeCacheMode,24015,"ooRealVar& obs, Int_t order, Bool_t central, Bool_t takeRoot); RooAbsMoment*RooAbsReal::moment(RooRealVar& obs, const RooArgSet& normObs, Int_t order, Bool_t central, Bool_t takeRoot, Bool_t intNormObs); Bool_tRooAbsPdf::mustBeExtended() const; static voidRooPrintable::nameFieldLength(Int_t newLen); const TNamed*RooAbsArg::namePtr() const; const char*RooAbsPdf::normRange() const; virtual Bool_tTObject::Notify(); Int_tRooAbsArg::numCaches() const; static Int_tRooAbsReal::numEvalErrorItems(); static Int_tRooAbsReal::numEvalErrors(); Bool_tRooAbsArg::observableOverlaps(const RooAbsData* dset, const RooAbsArg& testArg) const; Bool_tRooAbsArg::observableOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; virtual Double_tRooAbsReal::offset() const; voidTObject::operator delete(void* ptr); voidTObject::operator delete(void* ptr, void* vp); voidTObject::operator delete[](void* ptr); voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); RooAbsCachedPdf&operator=(const RooAbsCachedPdf&); Bool_tRooAbsReal::operator==(Double_t value) const; virtual Bool_tRooAbsReal::operator==(const RooAbsArg& other); RooAbsArg::OperModeRooAbsArg::operMode() const; virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables); virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables, RooArgSet& optNodes, RooLinkedList& processedNodes); Bool_tRooAbsArg::overlaps(const RooAbsArg& testArg, Bool_t valueOnly = kFALSE) const; const RooArgSet*RooAbsArg::ownedComponents() const; virtual voidTObject::Paint(Option_t* option = """"); virtual RooPlot*RooAbsPdf::paramOn(RooPlot* frame, const RooAbsData* data, const char* label = """", Int_t sigDigits = 2, Option_t* options = ""NELU"", Double_t xmin = 0.",MatchSource.WIKI,root/html602/RooAbsCachedPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsCachedPdf.html
https://root.cern/root/html602/RooAbsCachedPdf.html:28422,Performance,cache,cache,28422,"eam(ostream& os, Int_t contents, RooPrintable::StyleOption style, TString indent = """") const; virtual voidRooAbsArg::printTitle(ostream& os) const; virtual voidRooAbsArg::printTree(ostream& os, TString indent = """") const; virtual voidRooAbsPdf::printValue(ostream& os) const; virtual Int_tTObject::Read(const char* name); virtual Bool_tRooAbsReal::readFromStream(istream& is, Bool_t compact, Bool_t verbose = kFALSE); Bool_tRooAbsArg::recursiveCheckDependents(const RooArgSet* nset) const; Bool_tRooAbsArg::recursiveCheckObservables(const RooArgSet* nset) const; Bool_tRooAbsArg::recursiveRedirectServers(const RooAbsCollection& newServerList, Bool_t mustReplaceAll = kFALSE, Bool_t nameChange = kFALSE, Bool_t recurseInNewSet = kTRUE); virtual voidTObject::RecursiveRemove(TObject* obj); Bool_tRooAbsArg::redirectServers(const RooAbsCollection& newServerList, Bool_t mustReplaceAll = kFALSE, Bool_t nameChange = kFALSE, Bool_t isRecursionStep = kFALSE); voidRooAbsArg::registerCache(RooAbsCache& cache); voidRooAbsArg::removeServer(RooAbsArg& server, Bool_t force = kFALSE); voidRooAbsArg::replaceServer(RooAbsArg& oldServer, RooAbsArg& newServer, Bool_t valueProp, Bool_t shapeProp); voidTObject::ResetBit(UInt_t f); virtual voidRooAbsPdf::resetErrorCounters(Int_t resetValue = 10); RooAbsCachedPdf(); RooAbsCachedPdf(const RooAbsCachedPdf& other, const char* name = 0); RooAbsCachedPdf(const char* name, const char* title, Int_t ipOrder = 0); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); virtual Bool_tselfNormalized() const; TIterator*RooAbsArg::serverIterator() const; RooFIterRooAbsArg::serverMIterator() const; virtual voidRooAbsArg::serverNameChangeHook(const RooAbsArg*, const RooAbsArg*); voidRooAbsArg::setAttribute(const Text_t* name, Bool_t value = kTRUE); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); virtual voidRooAbsArg::setCacheAndTrac",MatchSource.WIKI,root/html602/RooAbsCachedPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsCachedPdf.html
https://root.cern/root/html602/RooAbsCachedPdf.html:29872,Performance,cache,cache,29872,"ual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); virtual Bool_tselfNormalized() const; TIterator*RooAbsArg::serverIterator() const; RooFIterRooAbsArg::serverMIterator() const; virtual voidRooAbsArg::serverNameChangeHook(const RooAbsArg*, const RooAbsArg*); voidRooAbsArg::setAttribute(const Text_t* name, Bool_t value = kTRUE); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); virtual voidRooAbsArg::setCacheAndTrackHints(RooArgSet&); static voidRooAbsReal::setCacheCheck(Bool_t flag); virtual Bool_tRooAbsReal::setData(RooAbsData&, Bool_t = kTRUE); static voidRooAbsArg::setDirtyInhibit(Bool_t flag); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); static voidRooAbsReal::setEvalErrorLoggingMode(RooAbsReal::ErrorLoggingMode m); virtual voidRooAbsArg::setExpensiveObjectCache(RooExpensiveObjectCache& cache); voidRooAbsPdf::setGeneratorConfig(); voidRooAbsPdf::setGeneratorConfig(const RooNumGenConfig& config); static voidRooAbsReal::setHideOffset(Bool_t flag); voidRooAbsReal::setIntegratorConfig(); voidRooAbsReal::setIntegratorConfig(const RooNumIntConfig& config); voidsetInterpolationOrder(Int_t order); voidRooAbsArg::setLocalNoDirtyInhibit(Bool_t flag) const; virtual voidRooAbsArg::SetName(const char* name); virtual voidRooAbsArg::SetNameTitle(const char* name, const char* title); voidRooAbsPdf::setNormRange(const char* rangeName); voidRooAbsPdf::setNormRangeOverride(const char* rangeName); static voidTObject::SetObjectStat(Bool_t stat); voidRooAbsArg::setOperMode(RooAbsArg::OperMode mode, Bool_t recurseADirty = kTRUE); voidRooAbsReal::setParameterizeIntegral(const RooArgSet& paramVars); voidRooAbsReal::setPlotLabel(const char* label); voidRooAbsArg::setProhibitServerRedirect(Bool_t flag); voidRooAbsArg::setShapeDirty() const; voidRooAbsArg::setStringAttribute(const Text_t* key, cons",MatchSource.WIKI,root/html602/RooAbsCachedPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsCachedPdf.html
https://root.cern/root/html602/RooAbsCachedPdf.html:32541,Performance,cache,cache,32541,"r* unit); voidRooAbsArg::setValueDirty() const; TIterator*RooAbsArg::shapeClientIterator() const; RooFIterRooAbsArg::shapeClientMIterator() const; virtual voidShowMembers(TMemberInspector& insp) const; RooAbsMoment*RooAbsReal::sigma(RooRealVar& obs); RooAbsMoment*RooAbsReal::sigma(RooRealVar& obs, const RooArgSet& nset); virtual Int_tTNamed::Sizeof() const; RooNumGenConfig*RooAbsPdf::specialGeneratorConfig() const; RooNumGenConfig*RooAbsPdf::specialGeneratorConfig(Bool_t createOnTheFly); RooNumIntConfig*RooAbsReal::specialIntegratorConfig() const; RooNumIntConfig*RooAbsReal::specialIntegratorConfig(Bool_t createOnTheFly); virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); const map<string,string>&RooAbsArg::stringAttributes() const; virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; virtual Bool_tRooAbsPdf::traceEvalHook(Double_t value) const; Bool_tRooAbsPdf::traceEvalPdf(Double_t value) const; const set<string>&RooAbsArg::transientAttributes() const; voidRooAbsArg::treeNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t doBranch = kTRUE, Bool_t doLeaf = kTRUE, Bool_t valueOnly = kFALSE, Bool_t recurseNonDerived = kFALSE) const; voidRooAbsArg::unRegisterCache(RooAbsCache& cache); virtual voidTObject::UseCurrentStyle(); TIterator*RooAbsArg::valueClientIterator() const; RooFIterRooAbsArg::valueClientMIterator() const; static voidRooAbsArg::verboseDirty(Bool_t flag); static intRooAbsPdf::verboseEval(); static voidRooAbsPdf::verboseEval(Int_t stat); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; voidRooAbsArg::wireAllCaches(); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const; virtual voidRooAbsReal::writeToStream(ostream& os, Bool_t compact) const.",MatchSource.WIKI,root/html602/RooAbsCachedPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsCachedPdf.html
https://root.cern/root/html602/RooAbsCachedPdf.html:34122,Performance,cache,cache,34122,,MatchSource.WIKI,root/html602/RooAbsCachedPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsCachedPdf.html
https://root.cern/root/html602/RooAbsCachedPdf.html:34705,Performance,cache,cache,34705,", const char* binnedTag = """") const; virtual RooAbsGenContext*RooAbsPdf::binnedGenContext(const RooArgSet& vars, Bool_t verbose = kFALSE) const; virtual const char*binningName() const; TStringcacheNameSuffix(const RooArgSet& nset) const; RooFitResult*RooAbsReal::chi2FitDriver(RooAbsReal& fcn, RooLinkedList& cmdList); TStringRooAbsArg::cleanBranchName() const; voidclearCacheObject(RooAbsCachedPdf::PdfCacheElem& cache) const; virtual voidRooAbsReal::copyCache(const RooAbsArg* source, Bool_t valueOnly = kFALSE, Bool_t setValDirty = kTRUE); virtual RooAbsCachedPdf::PdfCacheElem*createCache(const RooArgSet* nset) const; RooAbsReal*RooAbsReal::createIntObj(const RooArgSet& iset, const RooArgSet* nset, const RooNumIntConfig* cfg, const char* rangeName) const; voiddisableCache(Bool_t flag); virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; virtual Double_tRooAbsReal::evaluate() const; virtual voidfillCacheObject(RooAbsCachedPdf::PdfCacheElem& cache) const; virtual voidRooAbsReal::fillTreeBranch(TTree& t); voidRooAbsReal::findInnerMostIntegration(const RooArgSet& allObs, RooArgSet& innerObs, const char* rangeName) const; virtual RooAbsGenContext*RooAbsPdf::genContext(const RooArgSet& vars, const RooDataSet* prototype = 0, const RooArgSet* auxProto = 0, Bool_t verbose = kFALSE) const; RooDataSet*RooAbsPdf::generate(RooAbsGenContext& context, const RooArgSet& whatVars, const RooDataSet* prototype, Double_t nEvents, Bool_t verbose, Bool_t randProtoOrder, Bool_t resampleProto, Bool_t skipInit = kFALSE, Bool_t extended = kFALSE) const; RooAbsCachedPdf::PdfCacheElem*getCache(const RooArgSet* nset, Bool_t recalculate = kTRUE) const; virtual voidRooAbsArg::getObservablesHook(const RooArgSet*, RooArgSet*) const; virtual voidRooAbsArg::getParametersHook(const RooArgSet*, RooArgSet*, Bool_t) const; RooAbsProxy*RooAbsArg::getProxy(Int_t index) const; static voidRooAbsReal::globalSelectComp(Bool_t flag); voidRooAbsArg::graphVizAddConnection",MatchSource.WIKI,root/html602/RooAbsCachedPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsCachedPdf.html
https://root.cern/root/html602/RooAbsCachedPdf.html:37096,Performance,optimiz,optimizeDirtyHook,37096,"lem*getCache(const RooArgSet* nset, Bool_t recalculate = kTRUE) const; virtual voidRooAbsArg::getObservablesHook(const RooArgSet*, RooArgSet*) const; virtual voidRooAbsArg::getParametersHook(const RooArgSet*, RooArgSet*, Bool_t) const; RooAbsProxy*RooAbsArg::getProxy(Int_t index) const; static voidRooAbsReal::globalSelectComp(Bool_t flag); voidRooAbsArg::graphVizAddConnections(set<pair<RooAbsArg*,RooAbsArg*> >&); virtual TStringhistNameSuffix() const; Bool_tRooAbsArg::inhibitDirty() const; virtual const char*inputBaseName() const; TStringRooAbsReal::integralNameSuffix(const RooArgSet& iset, const RooArgSet* nset = 0, const char* rangeName = 0, Bool_t omitEmpty = kFALSE) const; Bool_tRooAbsReal::isSelectedComp() const; virtual Bool_tRooAbsReal::isValid() const; virtual Bool_tRooAbsReal::isValidReal(Double_t value, Bool_t printError = kFALSE) const; voidRooAbsReal::makeProjectionSet(const RooAbsArg* plotVar, const RooArgSet* allVars, RooArgSet& projectedVars, Bool_t silent) const; voidTObject::MakeZombie(); Bool_tRooAbsReal::matchArgs(const RooArgSet& allDeps, RooArgSet& numDeps, const RooArgProxy& a) const; Bool_tRooAbsReal::matchArgs(const RooArgSet& allDeps, RooArgSet& numDeps, const RooArgSet& set) const; Bool_tRooAbsReal::matchArgs(const RooArgSet& allDeps, RooArgSet& numDeps, const RooArgProxy& a, const RooArgProxy& b) const; Bool_tRooAbsReal::matchArgs(const RooArgSet& allDeps, RooArgSet& numDeps, const RooArgProxy& a, const RooArgProxy& b, const RooArgProxy& c) const; Bool_tRooAbsReal::matchArgs(const RooArgSet& allDeps, RooArgSet& numDeps, const RooArgProxy& a, const RooArgProxy& b, const RooArgProxy& c, const RooArgProxy& d) const; Int_tRooAbsArg::numProxies() const; virtual voidRooAbsArg::operModeHook(); virtual voidRooAbsArg::optimizeDirtyHook(const RooArgSet*); virtual RooPlot*RooAbsPdf::paramOn(RooPlot* frame, const RooArgSet& params, Bool_t showConstants = kFALSE, const char* label = """", Int_t sigDigits = 2, Option_t* options = ""NELU"", Double_t xmin = 0.",MatchSource.WIKI,root/html602/RooAbsCachedPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsCachedPdf.html
https://root.cern/root/html602/RooAbsCachedPdf.html:42590,Performance,cache,cache,42590,,MatchSource.WIKI,root/html602/RooAbsCachedPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsCachedPdf.html
https://root.cern/root/html602/RooAbsCachedPdf.html:42673,Performance,cache,cache,42673,,MatchSource.WIKI,root/html602/RooAbsCachedPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsCachedPdf.html
https://root.cern/root/html602/RooAbsCachedPdf.html:42871,Performance,cache,caches,42871,,MatchSource.WIKI,root/html602/RooAbsCachedPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsCachedPdf.html
https://root.cern/root/html602/RooAbsCachedPdf.html:42910,Performance,cache,cache,42910,,MatchSource.WIKI,root/html602/RooAbsCachedPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsCachedPdf.html
https://root.cern/root/html602/RooAbsCachedPdf.html:43449,Performance,cache,cache,43449,"s; set<string>RooAbsArg::_boolAttribTransient! Transient boolean attributes (not copied in ctor); Bool_tRooAbsReal::_boolValue! Transient cache for bool values from tree branches; UChar_tRooAbsReal::_byteValue! Transient cache for byte values from tree branches; static Bool_tRooAbsReal::_cacheCheckIf true, always validate contents of clean which outcome of evaluate(); deque<RooAbsCache*>RooAbsArg::_cacheListlist of caches; RooObjCacheManager_cacheMgrThe cache manager; RooRefCountListRooAbsArg::_clientListlist of client objects; RooRefCountListRooAbsArg::_clientListShapesubset of clients that requested shape dirty flag propagation; RooRefCountListRooAbsArg::_clientListValuesubset of clients that requested value dirty flag propagation; TIterator*RooAbsArg::_clientShapeIter! Iterator over _clientListShape; TIterator*RooAbsArg::_clientValueIter! Iterator over _clientListValue; Bool_tRooAbsArg::_deleteWatch! Delete watch flag; RooExpensiveObjectCache*RooAbsArg::_eocachePointer to global cache manager for any expensive components created by this object; Int_tRooAbsPdf::_errorCountNumber of errors remaining to print; static Bool_tRooAbsPdf::_evalError; Bool_tRooAbsArg::_fastAllow fast access mode in getVal() and proxies; Float_tRooAbsReal::_floatValue! Transient cache for floating point values from tree branches; Bool_tRooAbsReal::_forceNumIntForce numerical integration if flag set; static Bool_tRooAbsReal::_globalSelectCompGlobal activation switch for component selection; static Bool_tRooAbsReal::_hideOffsetOffset hiding flag; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; Int_tRooAbsReal::_intValue! Transient cache for integer values from tree branches; Int_t_ipOrderInterpolation order for cache histograms; Bool_tRooAbsArg::_isConstant! Cached isConstant status; TStringRooAbsReal::_labelPlot label for objects value; RooArgSet*RooAbsReal::_lastNSet!; Bool_tRooAbsArg::_localNoInhibitDirty! Prevent 'AlwaysDirty' mode ",MatchSource.WIKI,root/html602/RooAbsCachedPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsCachedPdf.html
https://root.cern/root/html602/RooAbsCachedPdf.html:43728,Performance,cache,cache,43728,"; Bool_tRooAbsReal::_boolValue! Transient cache for bool values from tree branches; UChar_tRooAbsReal::_byteValue! Transient cache for byte values from tree branches; static Bool_tRooAbsReal::_cacheCheckIf true, always validate contents of clean which outcome of evaluate(); deque<RooAbsCache*>RooAbsArg::_cacheListlist of caches; RooObjCacheManager_cacheMgrThe cache manager; RooRefCountListRooAbsArg::_clientListlist of client objects; RooRefCountListRooAbsArg::_clientListShapesubset of clients that requested shape dirty flag propagation; RooRefCountListRooAbsArg::_clientListValuesubset of clients that requested value dirty flag propagation; TIterator*RooAbsArg::_clientShapeIter! Iterator over _clientListShape; TIterator*RooAbsArg::_clientValueIter! Iterator over _clientListValue; Bool_tRooAbsArg::_deleteWatch! Delete watch flag; RooExpensiveObjectCache*RooAbsArg::_eocachePointer to global cache manager for any expensive components created by this object; Int_tRooAbsPdf::_errorCountNumber of errors remaining to print; static Bool_tRooAbsPdf::_evalError; Bool_tRooAbsArg::_fastAllow fast access mode in getVal() and proxies; Float_tRooAbsReal::_floatValue! Transient cache for floating point values from tree branches; Bool_tRooAbsReal::_forceNumIntForce numerical integration if flag set; static Bool_tRooAbsReal::_globalSelectCompGlobal activation switch for component selection; static Bool_tRooAbsReal::_hideOffsetOffset hiding flag; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; Int_tRooAbsReal::_intValue! Transient cache for integer values from tree branches; Int_t_ipOrderInterpolation order for cache histograms; Bool_tRooAbsArg::_isConstant! Cached isConstant status; TStringRooAbsReal::_labelPlot label for objects value; RooArgSet*RooAbsReal::_lastNSet!; Bool_tRooAbsArg::_localNoInhibitDirty! Prevent 'AlwaysDirty' mode for this node; static Int_tRooPrintable::_nameLength; TNamed*RooAbsArg::_namePtr! Do not persist.",MatchSource.WIKI,root/html602/RooAbsCachedPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsCachedPdf.html
https://root.cern/root/html602/RooAbsCachedPdf.html:44141,Performance,cache,cache,44141,"; Bool_tRooAbsReal::_boolValue! Transient cache for bool values from tree branches; UChar_tRooAbsReal::_byteValue! Transient cache for byte values from tree branches; static Bool_tRooAbsReal::_cacheCheckIf true, always validate contents of clean which outcome of evaluate(); deque<RooAbsCache*>RooAbsArg::_cacheListlist of caches; RooObjCacheManager_cacheMgrThe cache manager; RooRefCountListRooAbsArg::_clientListlist of client objects; RooRefCountListRooAbsArg::_clientListShapesubset of clients that requested shape dirty flag propagation; RooRefCountListRooAbsArg::_clientListValuesubset of clients that requested value dirty flag propagation; TIterator*RooAbsArg::_clientShapeIter! Iterator over _clientListShape; TIterator*RooAbsArg::_clientValueIter! Iterator over _clientListValue; Bool_tRooAbsArg::_deleteWatch! Delete watch flag; RooExpensiveObjectCache*RooAbsArg::_eocachePointer to global cache manager for any expensive components created by this object; Int_tRooAbsPdf::_errorCountNumber of errors remaining to print; static Bool_tRooAbsPdf::_evalError; Bool_tRooAbsArg::_fastAllow fast access mode in getVal() and proxies; Float_tRooAbsReal::_floatValue! Transient cache for floating point values from tree branches; Bool_tRooAbsReal::_forceNumIntForce numerical integration if flag set; static Bool_tRooAbsReal::_globalSelectCompGlobal activation switch for component selection; static Bool_tRooAbsReal::_hideOffsetOffset hiding flag; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; Int_tRooAbsReal::_intValue! Transient cache for integer values from tree branches; Int_t_ipOrderInterpolation order for cache histograms; Bool_tRooAbsArg::_isConstant! Cached isConstant status; TStringRooAbsReal::_labelPlot label for objects value; RooArgSet*RooAbsReal::_lastNSet!; Bool_tRooAbsArg::_localNoInhibitDirty! Prevent 'AlwaysDirty' mode for this node; static Int_tRooPrintable::_nameLength; TNamed*RooAbsArg::_namePtr! Do not persist.",MatchSource.WIKI,root/html602/RooAbsCachedPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsCachedPdf.html
https://root.cern/root/html602/RooAbsCachedPdf.html:44223,Performance,cache,cache,44223,"; Bool_tRooAbsReal::_boolValue! Transient cache for bool values from tree branches; UChar_tRooAbsReal::_byteValue! Transient cache for byte values from tree branches; static Bool_tRooAbsReal::_cacheCheckIf true, always validate contents of clean which outcome of evaluate(); deque<RooAbsCache*>RooAbsArg::_cacheListlist of caches; RooObjCacheManager_cacheMgrThe cache manager; RooRefCountListRooAbsArg::_clientListlist of client objects; RooRefCountListRooAbsArg::_clientListShapesubset of clients that requested shape dirty flag propagation; RooRefCountListRooAbsArg::_clientListValuesubset of clients that requested value dirty flag propagation; TIterator*RooAbsArg::_clientShapeIter! Iterator over _clientListShape; TIterator*RooAbsArg::_clientValueIter! Iterator over _clientListValue; Bool_tRooAbsArg::_deleteWatch! Delete watch flag; RooExpensiveObjectCache*RooAbsArg::_eocachePointer to global cache manager for any expensive components created by this object; Int_tRooAbsPdf::_errorCountNumber of errors remaining to print; static Bool_tRooAbsPdf::_evalError; Bool_tRooAbsArg::_fastAllow fast access mode in getVal() and proxies; Float_tRooAbsReal::_floatValue! Transient cache for floating point values from tree branches; Bool_tRooAbsReal::_forceNumIntForce numerical integration if flag set; static Bool_tRooAbsReal::_globalSelectCompGlobal activation switch for component selection; static Bool_tRooAbsReal::_hideOffsetOffset hiding flag; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; Int_tRooAbsReal::_intValue! Transient cache for integer values from tree branches; Int_t_ipOrderInterpolation order for cache histograms; Bool_tRooAbsArg::_isConstant! Cached isConstant status; TStringRooAbsReal::_labelPlot label for objects value; RooArgSet*RooAbsReal::_lastNSet!; Bool_tRooAbsArg::_localNoInhibitDirty! Prevent 'AlwaysDirty' mode for this node; static Int_tRooPrintable::_nameLength; TNamed*RooAbsArg::_namePtr! Do not persist.",MatchSource.WIKI,root/html602/RooAbsCachedPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsCachedPdf.html
https://root.cern/root/html602/RooAbsCachedPdf.html:44805,Performance,cache,cache,44805,,MatchSource.WIKI,root/html602/RooAbsCachedPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsCachedPdf.html
https://root.cern/root/html602/RooAbsCachedPdf.html:45476,Performance,cache,cache,45476,,MatchSource.WIKI,root/html602/RooAbsCachedPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsCachedPdf.html
https://root.cern/root/html602/RooAbsCachedPdf.html:46264,Performance,cache,cache,46264,"egral (owned by _normMgr); RooObjCacheManagerRooAbsPdf::_normMgrThe cache manager; TStringRooAbsPdf::_normRangeNormalization range; static TStringRooAbsPdf::_normRangeOverride; RooArgSet*RooAbsPdf::_normSet! Normalization set with for above integral; RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; Int_tRooAbsReal::_plotBinsNumber of plot bins; Double_tRooAbsReal::_plotMaxMaximum of plot range; Double_tRooAbsReal::_plotMinMinimum of plot range; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; RooRefArrayRooAbsArg::_proxyListlist of proxies; Double_tRooAbsPdf::_rawValue; Char_tRooAbsReal::_sbyteValue! Transient cache for signed byte values from tree branches; Bool_tRooAbsPdf::_selectCompComponent selection flag for RooAbsPdf::plotCompOn; Bool_tRooAbsReal::_selectComp! Component selection flag for RooAbsPdf::plotCompOn; RooRefCountListRooAbsArg::_serverListlist of server objects; Bool_tRooAbsArg::_shapeDirtyFlag set if value needs recalculating because input shapes modified; RooNumGenConfig*RooAbsPdf::_specGeneratorConfig! MC generator configuration specific for this object; RooNumIntConfig*RooAbsReal::_specIntegratorConfigNumeric integrator configuration specific for this object; map<string,string>RooAbsArg::_stringAttribString attributes; Int_tRooAbsPdf::_traceCountNumber of traces remaining to print; Bool_tRooAbsReal::_treeVar!do not persist; UInt_tRooAbsReal::_uintValue! Transient cache for unsigned integer values from tree branches; TStringRooAbsReal::_unitUnit for objects value; Double_tRooAbsReal::_valueCache for current value of object; Bool_tRooAbsArg::_valueDirtyFlag set if value needs recalculating because input values modified; static Bool_tRooAbsArg::_verboseDirtyStatic flag controlling verbose messaging for dirty state changes; static Int_tRooAbsPdf::_verboseEval; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title.",MatchSource.WIKI,root/html602/RooAbsCachedPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsCachedPdf.html
https://root.cern/root/html602/RooAbsCachedPdf.html:47280,Performance,cache,cache,47280,"che for unsigned integer values from tree branches; TStringRooAbsReal::_unitUnit for objects value; Double_tRooAbsReal::_valueCache for current value of object; Bool_tRooAbsArg::_valueDirtyFlag set if value needs recalculating because input values modified; static Bool_tRooAbsArg::_verboseDirtyStatic flag controlling verbose messaging for dirty state changes; static Int_tRooAbsPdf::_verboseEval; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title. private:. Bool_t_disableCacheFlag to run object in passthrough (= non-caching mode). Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; RooAbsCachedPdf(const char* name, const char* title, Int_t ipOrder = 0); Constructor. RooAbsCachedPdf(const RooAbsCachedPdf& other, const char* name = 0); Copy constructor. ~RooAbsCachedPdf(); Destructor. Double_t getValV(const RooArgSet* set = 0) const; Implementation of getVal() overriding default implementation; of RooAbsPdf. Return normalized value stored in cache p.d.f; rather than return value of evaluate() which is undefined; for RooAbsCachedPdf. RooAbsPdf* getCachePdf(const RooArgSet* nset = 0) const; Return pointer to RooHistPdf cache pdf for given choice of observables. RooDataHist* getCacheHist(const RooArgSet* nset = 0) const; Return pointer to RooDataHist cache histogram for given choice of observables. void clearCacheObject(RooAbsCachedPdf::PdfCacheElem& cache) const; Mark all bins of given cache as unitialized (value -1). TString cacheNameSuffix(const RooArgSet& nset) const; Construct string with unique suffix for cache objects based on; observable names that define cache configuration. void setInterpolationOrder(Int_t order); Change the interpolation order that is used in RooHistPdf cache; representation smoothing the RooDataHist shapes. Bool_t forceAnalyticalInt(const RooAbsArg& dep) const; Force RooRealIntegral to offer all our actual observable for internal; integration. Int_t getAnalyticalIntegralWN(RooArgSet& ",MatchSource.WIKI,root/html602/RooAbsCachedPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsCachedPdf.html
https://root.cern/root/html602/RooAbsCachedPdf.html:47459,Performance,cache,cache,47459,"AbsArg::_valueDirtyFlag set if value needs recalculating because input values modified; static Bool_tRooAbsArg::_verboseDirtyStatic flag controlling verbose messaging for dirty state changes; static Int_tRooAbsPdf::_verboseEval; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title. private:. Bool_t_disableCacheFlag to run object in passthrough (= non-caching mode). Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; RooAbsCachedPdf(const char* name, const char* title, Int_t ipOrder = 0); Constructor. RooAbsCachedPdf(const RooAbsCachedPdf& other, const char* name = 0); Copy constructor. ~RooAbsCachedPdf(); Destructor. Double_t getValV(const RooArgSet* set = 0) const; Implementation of getVal() overriding default implementation; of RooAbsPdf. Return normalized value stored in cache p.d.f; rather than return value of evaluate() which is undefined; for RooAbsCachedPdf. RooAbsPdf* getCachePdf(const RooArgSet* nset = 0) const; Return pointer to RooHistPdf cache pdf for given choice of observables. RooDataHist* getCacheHist(const RooArgSet* nset = 0) const; Return pointer to RooDataHist cache histogram for given choice of observables. void clearCacheObject(RooAbsCachedPdf::PdfCacheElem& cache) const; Mark all bins of given cache as unitialized (value -1). TString cacheNameSuffix(const RooArgSet& nset) const; Construct string with unique suffix for cache objects based on; observable names that define cache configuration. void setInterpolationOrder(Int_t order); Change the interpolation order that is used in RooHistPdf cache; representation smoothing the RooDataHist shapes. Bool_t forceAnalyticalInt(const RooAbsArg& dep) const; Force RooRealIntegral to offer all our actual observable for internal; integration. Int_t getAnalyticalIntegralWN(RooArgSet& allVars, RooArgSet& analVars, const RooArgSet* normSet, const char* rangeName = 0) const; Advertises internal (analytical) integration capabilities. Call; is forwarded to",MatchSource.WIKI,root/html602/RooAbsCachedPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsCachedPdf.html
https://root.cern/root/html602/RooAbsCachedPdf.html:47592,Performance,cache,cache,47592,"ag controlling verbose messaging for dirty state changes; static Int_tRooAbsPdf::_verboseEval; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title. private:. Bool_t_disableCacheFlag to run object in passthrough (= non-caching mode). Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; RooAbsCachedPdf(const char* name, const char* title, Int_t ipOrder = 0); Constructor. RooAbsCachedPdf(const RooAbsCachedPdf& other, const char* name = 0); Copy constructor. ~RooAbsCachedPdf(); Destructor. Double_t getValV(const RooArgSet* set = 0) const; Implementation of getVal() overriding default implementation; of RooAbsPdf. Return normalized value stored in cache p.d.f; rather than return value of evaluate() which is undefined; for RooAbsCachedPdf. RooAbsPdf* getCachePdf(const RooArgSet* nset = 0) const; Return pointer to RooHistPdf cache pdf for given choice of observables. RooDataHist* getCacheHist(const RooArgSet* nset = 0) const; Return pointer to RooDataHist cache histogram for given choice of observables. void clearCacheObject(RooAbsCachedPdf::PdfCacheElem& cache) const; Mark all bins of given cache as unitialized (value -1). TString cacheNameSuffix(const RooArgSet& nset) const; Construct string with unique suffix for cache objects based on; observable names that define cache configuration. void setInterpolationOrder(Int_t order); Change the interpolation order that is used in RooHistPdf cache; representation smoothing the RooDataHist shapes. Bool_t forceAnalyticalInt(const RooAbsArg& dep) const; Force RooRealIntegral to offer all our actual observable for internal; integration. Int_t getAnalyticalIntegralWN(RooArgSet& allVars, RooArgSet& analVars, const RooArgSet* normSet, const char* rangeName = 0) const; Advertises internal (analytical) integration capabilities. Call; is forwarded to RooHistPdf cache p.d.f of cache that is used for; given choice of observables. Double_t analyticalIntegralWN(Int_t code, const RooArg",MatchSource.WIKI,root/html602/RooAbsCachedPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsCachedPdf.html
https://root.cern/root/html602/RooAbsCachedPdf.html:47694,Performance,cache,cache,47694,"r; TStringTNamed::fTitleobject title. private:. Bool_t_disableCacheFlag to run object in passthrough (= non-caching mode). Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; RooAbsCachedPdf(const char* name, const char* title, Int_t ipOrder = 0); Constructor. RooAbsCachedPdf(const RooAbsCachedPdf& other, const char* name = 0); Copy constructor. ~RooAbsCachedPdf(); Destructor. Double_t getValV(const RooArgSet* set = 0) const; Implementation of getVal() overriding default implementation; of RooAbsPdf. Return normalized value stored in cache p.d.f; rather than return value of evaluate() which is undefined; for RooAbsCachedPdf. RooAbsPdf* getCachePdf(const RooArgSet* nset = 0) const; Return pointer to RooHistPdf cache pdf for given choice of observables. RooDataHist* getCacheHist(const RooArgSet* nset = 0) const; Return pointer to RooDataHist cache histogram for given choice of observables. void clearCacheObject(RooAbsCachedPdf::PdfCacheElem& cache) const; Mark all bins of given cache as unitialized (value -1). TString cacheNameSuffix(const RooArgSet& nset) const; Construct string with unique suffix for cache objects based on; observable names that define cache configuration. void setInterpolationOrder(Int_t order); Change the interpolation order that is used in RooHistPdf cache; representation smoothing the RooDataHist shapes. Bool_t forceAnalyticalInt(const RooAbsArg& dep) const; Force RooRealIntegral to offer all our actual observable for internal; integration. Int_t getAnalyticalIntegralWN(RooArgSet& allVars, RooArgSet& analVars, const RooArgSet* normSet, const char* rangeName = 0) const; Advertises internal (analytical) integration capabilities. Call; is forwarded to RooHistPdf cache p.d.f of cache that is used for; given choice of observables. Double_t analyticalIntegralWN(Int_t code, const RooArgSet* normSet, const char* rangeName = 0) const; Implements internal (analytical) integration capabilities. Call; is forwarded to Ro",MatchSource.WIKI,root/html602/RooAbsCachedPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsCachedPdf.html
https://root.cern/root/html602/RooAbsCachedPdf.html:47731,Performance,cache,cache,47731,"r; TStringTNamed::fTitleobject title. private:. Bool_t_disableCacheFlag to run object in passthrough (= non-caching mode). Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; RooAbsCachedPdf(const char* name, const char* title, Int_t ipOrder = 0); Constructor. RooAbsCachedPdf(const RooAbsCachedPdf& other, const char* name = 0); Copy constructor. ~RooAbsCachedPdf(); Destructor. Double_t getValV(const RooArgSet* set = 0) const; Implementation of getVal() overriding default implementation; of RooAbsPdf. Return normalized value stored in cache p.d.f; rather than return value of evaluate() which is undefined; for RooAbsCachedPdf. RooAbsPdf* getCachePdf(const RooArgSet* nset = 0) const; Return pointer to RooHistPdf cache pdf for given choice of observables. RooDataHist* getCacheHist(const RooArgSet* nset = 0) const; Return pointer to RooDataHist cache histogram for given choice of observables. void clearCacheObject(RooAbsCachedPdf::PdfCacheElem& cache) const; Mark all bins of given cache as unitialized (value -1). TString cacheNameSuffix(const RooArgSet& nset) const; Construct string with unique suffix for cache objects based on; observable names that define cache configuration. void setInterpolationOrder(Int_t order); Change the interpolation order that is used in RooHistPdf cache; representation smoothing the RooDataHist shapes. Bool_t forceAnalyticalInt(const RooAbsArg& dep) const; Force RooRealIntegral to offer all our actual observable for internal; integration. Int_t getAnalyticalIntegralWN(RooArgSet& allVars, RooArgSet& analVars, const RooArgSet* normSet, const char* rangeName = 0) const; Advertises internal (analytical) integration capabilities. Call; is forwarded to RooHistPdf cache p.d.f of cache that is used for; given choice of observables. Double_t analyticalIntegralWN(Int_t code, const RooArgSet* normSet, const char* rangeName = 0) const; Implements internal (analytical) integration capabilities. Call; is forwarded to Ro",MatchSource.WIKI,root/html602/RooAbsCachedPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsCachedPdf.html
https://root.cern/root/html602/RooAbsCachedPdf.html:47772,Performance,cache,cacheNameSuffix,47772,"ce; Inherited Members; Includes; Libraries. Function documentation; RooAbsCachedPdf(const char* name, const char* title, Int_t ipOrder = 0); Constructor. RooAbsCachedPdf(const RooAbsCachedPdf& other, const char* name = 0); Copy constructor. ~RooAbsCachedPdf(); Destructor. Double_t getValV(const RooArgSet* set = 0) const; Implementation of getVal() overriding default implementation; of RooAbsPdf. Return normalized value stored in cache p.d.f; rather than return value of evaluate() which is undefined; for RooAbsCachedPdf. RooAbsPdf* getCachePdf(const RooArgSet* nset = 0) const; Return pointer to RooHistPdf cache pdf for given choice of observables. RooDataHist* getCacheHist(const RooArgSet* nset = 0) const; Return pointer to RooDataHist cache histogram for given choice of observables. void clearCacheObject(RooAbsCachedPdf::PdfCacheElem& cache) const; Mark all bins of given cache as unitialized (value -1). TString cacheNameSuffix(const RooArgSet& nset) const; Construct string with unique suffix for cache objects based on; observable names that define cache configuration. void setInterpolationOrder(Int_t order); Change the interpolation order that is used in RooHistPdf cache; representation smoothing the RooDataHist shapes. Bool_t forceAnalyticalInt(const RooAbsArg& dep) const; Force RooRealIntegral to offer all our actual observable for internal; integration. Int_t getAnalyticalIntegralWN(RooArgSet& allVars, RooArgSet& analVars, const RooArgSet* normSet, const char* rangeName = 0) const; Advertises internal (analytical) integration capabilities. Call; is forwarded to RooHistPdf cache p.d.f of cache that is used for; given choice of observables. Double_t analyticalIntegralWN(Int_t code, const RooArgSet* normSet, const char* rangeName = 0) const; Implements internal (analytical) integration capabilities. Call; is forwarded to RooHistPdf cache p.d.f of cache that is used for; given choice of observables. RooAbsCachedPdf(); Default constructor. Bool_t selfNormalized() cons",MatchSource.WIKI,root/html602/RooAbsCachedPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsCachedPdf.html
https://root.cern/root/html602/RooAbsCachedPdf.html:47858,Performance,cache,cache,47858,"ce; Inherited Members; Includes; Libraries. Function documentation; RooAbsCachedPdf(const char* name, const char* title, Int_t ipOrder = 0); Constructor. RooAbsCachedPdf(const RooAbsCachedPdf& other, const char* name = 0); Copy constructor. ~RooAbsCachedPdf(); Destructor. Double_t getValV(const RooArgSet* set = 0) const; Implementation of getVal() overriding default implementation; of RooAbsPdf. Return normalized value stored in cache p.d.f; rather than return value of evaluate() which is undefined; for RooAbsCachedPdf. RooAbsPdf* getCachePdf(const RooArgSet* nset = 0) const; Return pointer to RooHistPdf cache pdf for given choice of observables. RooDataHist* getCacheHist(const RooArgSet* nset = 0) const; Return pointer to RooDataHist cache histogram for given choice of observables. void clearCacheObject(RooAbsCachedPdf::PdfCacheElem& cache) const; Mark all bins of given cache as unitialized (value -1). TString cacheNameSuffix(const RooArgSet& nset) const; Construct string with unique suffix for cache objects based on; observable names that define cache configuration. void setInterpolationOrder(Int_t order); Change the interpolation order that is used in RooHistPdf cache; representation smoothing the RooDataHist shapes. Bool_t forceAnalyticalInt(const RooAbsArg& dep) const; Force RooRealIntegral to offer all our actual observable for internal; integration. Int_t getAnalyticalIntegralWN(RooArgSet& allVars, RooArgSet& analVars, const RooArgSet* normSet, const char* rangeName = 0) const; Advertises internal (analytical) integration capabilities. Call; is forwarded to RooHistPdf cache p.d.f of cache that is used for; given choice of observables. Double_t analyticalIntegralWN(Int_t code, const RooArgSet* normSet, const char* rangeName = 0) const; Implements internal (analytical) integration capabilities. Call; is forwarded to RooHistPdf cache p.d.f of cache that is used for; given choice of observables. RooAbsCachedPdf(); Default constructor. Bool_t selfNormalized() cons",MatchSource.WIKI,root/html602/RooAbsCachedPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsCachedPdf.html
https://root.cern/root/html602/RooAbsCachedPdf.html:47911,Performance,cache,cache,47911,"ce; Inherited Members; Includes; Libraries. Function documentation; RooAbsCachedPdf(const char* name, const char* title, Int_t ipOrder = 0); Constructor. RooAbsCachedPdf(const RooAbsCachedPdf& other, const char* name = 0); Copy constructor. ~RooAbsCachedPdf(); Destructor. Double_t getValV(const RooArgSet* set = 0) const; Implementation of getVal() overriding default implementation; of RooAbsPdf. Return normalized value stored in cache p.d.f; rather than return value of evaluate() which is undefined; for RooAbsCachedPdf. RooAbsPdf* getCachePdf(const RooArgSet* nset = 0) const; Return pointer to RooHistPdf cache pdf for given choice of observables. RooDataHist* getCacheHist(const RooArgSet* nset = 0) const; Return pointer to RooDataHist cache histogram for given choice of observables. void clearCacheObject(RooAbsCachedPdf::PdfCacheElem& cache) const; Mark all bins of given cache as unitialized (value -1). TString cacheNameSuffix(const RooArgSet& nset) const; Construct string with unique suffix for cache objects based on; observable names that define cache configuration. void setInterpolationOrder(Int_t order); Change the interpolation order that is used in RooHistPdf cache; representation smoothing the RooDataHist shapes. Bool_t forceAnalyticalInt(const RooAbsArg& dep) const; Force RooRealIntegral to offer all our actual observable for internal; integration. Int_t getAnalyticalIntegralWN(RooArgSet& allVars, RooArgSet& analVars, const RooArgSet* normSet, const char* rangeName = 0) const; Advertises internal (analytical) integration capabilities. Call; is forwarded to RooHistPdf cache p.d.f of cache that is used for; given choice of observables. Double_t analyticalIntegralWN(Int_t code, const RooArgSet* normSet, const char* rangeName = 0) const; Implements internal (analytical) integration capabilities. Call; is forwarded to RooHistPdf cache p.d.f of cache that is used for; given choice of observables. RooAbsCachedPdf(); Default constructor. Bool_t selfNormalized() cons",MatchSource.WIKI,root/html602/RooAbsCachedPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsCachedPdf.html
https://root.cern/root/html602/RooAbsCachedPdf.html:48031,Performance,cache,cache,48031,"achedPdf(const RooAbsCachedPdf& other, const char* name = 0); Copy constructor. ~RooAbsCachedPdf(); Destructor. Double_t getValV(const RooArgSet* set = 0) const; Implementation of getVal() overriding default implementation; of RooAbsPdf. Return normalized value stored in cache p.d.f; rather than return value of evaluate() which is undefined; for RooAbsCachedPdf. RooAbsPdf* getCachePdf(const RooArgSet* nset = 0) const; Return pointer to RooHistPdf cache pdf for given choice of observables. RooDataHist* getCacheHist(const RooArgSet* nset = 0) const; Return pointer to RooDataHist cache histogram for given choice of observables. void clearCacheObject(RooAbsCachedPdf::PdfCacheElem& cache) const; Mark all bins of given cache as unitialized (value -1). TString cacheNameSuffix(const RooArgSet& nset) const; Construct string with unique suffix for cache objects based on; observable names that define cache configuration. void setInterpolationOrder(Int_t order); Change the interpolation order that is used in RooHistPdf cache; representation smoothing the RooDataHist shapes. Bool_t forceAnalyticalInt(const RooAbsArg& dep) const; Force RooRealIntegral to offer all our actual observable for internal; integration. Int_t getAnalyticalIntegralWN(RooArgSet& allVars, RooArgSet& analVars, const RooArgSet* normSet, const char* rangeName = 0) const; Advertises internal (analytical) integration capabilities. Call; is forwarded to RooHistPdf cache p.d.f of cache that is used for; given choice of observables. Double_t analyticalIntegralWN(Int_t code, const RooArgSet* normSet, const char* rangeName = 0) const; Implements internal (analytical) integration capabilities. Call; is forwarded to RooHistPdf cache p.d.f of cache that is used for; given choice of observables. RooAbsCachedPdf(); Default constructor. Bool_t selfNormalized() const; Declare p.d.f self normalized. RooAbsPdf* getCachePdf(const RooArgSet& nset) const; Return RooHistPdf that represents cache histogram. RooDataHist* getCacheHis",MatchSource.WIKI,root/html602/RooAbsCachedPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsCachedPdf.html
https://root.cern/root/html602/RooAbsCachedPdf.html:48449,Performance,cache,cache,48449," pointer to RooHistPdf cache pdf for given choice of observables. RooDataHist* getCacheHist(const RooArgSet* nset = 0) const; Return pointer to RooDataHist cache histogram for given choice of observables. void clearCacheObject(RooAbsCachedPdf::PdfCacheElem& cache) const; Mark all bins of given cache as unitialized (value -1). TString cacheNameSuffix(const RooArgSet& nset) const; Construct string with unique suffix for cache objects based on; observable names that define cache configuration. void setInterpolationOrder(Int_t order); Change the interpolation order that is used in RooHistPdf cache; representation smoothing the RooDataHist shapes. Bool_t forceAnalyticalInt(const RooAbsArg& dep) const; Force RooRealIntegral to offer all our actual observable for internal; integration. Int_t getAnalyticalIntegralWN(RooArgSet& allVars, RooArgSet& analVars, const RooArgSet* normSet, const char* rangeName = 0) const; Advertises internal (analytical) integration capabilities. Call; is forwarded to RooHistPdf cache p.d.f of cache that is used for; given choice of observables. Double_t analyticalIntegralWN(Int_t code, const RooArgSet* normSet, const char* rangeName = 0) const; Implements internal (analytical) integration capabilities. Call; is forwarded to RooHistPdf cache p.d.f of cache that is used for; given choice of observables. RooAbsCachedPdf(); Default constructor. Bool_t selfNormalized() const; Declare p.d.f self normalized. RooAbsPdf* getCachePdf(const RooArgSet& nset) const; Return RooHistPdf that represents cache histogram. RooDataHist* getCacheHist(const RooArgSet& nset) const; Return RooDataHist with cached values. Int_t getInterpolationOrder() const; Set interpolation order in RooHistPdf that represent cached histogram. PdfCacheElem* getCache(const RooArgSet* nset, Bool_t recalculate = kTRUE) const. const char* payloadUniqueSuffix() const; { return 0 ; }. const char* binningName() const; Return name of binning to be used for creation of cache histogram. PdfCacheEl",MatchSource.WIKI,root/html602/RooAbsCachedPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsCachedPdf.html
https://root.cern/root/html602/RooAbsCachedPdf.html:48464,Performance,cache,cache,48464,"f observables. RooDataHist* getCacheHist(const RooArgSet* nset = 0) const; Return pointer to RooDataHist cache histogram for given choice of observables. void clearCacheObject(RooAbsCachedPdf::PdfCacheElem& cache) const; Mark all bins of given cache as unitialized (value -1). TString cacheNameSuffix(const RooArgSet& nset) const; Construct string with unique suffix for cache objects based on; observable names that define cache configuration. void setInterpolationOrder(Int_t order); Change the interpolation order that is used in RooHistPdf cache; representation smoothing the RooDataHist shapes. Bool_t forceAnalyticalInt(const RooAbsArg& dep) const; Force RooRealIntegral to offer all our actual observable for internal; integration. Int_t getAnalyticalIntegralWN(RooArgSet& allVars, RooArgSet& analVars, const RooArgSet* normSet, const char* rangeName = 0) const; Advertises internal (analytical) integration capabilities. Call; is forwarded to RooHistPdf cache p.d.f of cache that is used for; given choice of observables. Double_t analyticalIntegralWN(Int_t code, const RooArgSet* normSet, const char* rangeName = 0) const; Implements internal (analytical) integration capabilities. Call; is forwarded to RooHistPdf cache p.d.f of cache that is used for; given choice of observables. RooAbsCachedPdf(); Default constructor. Bool_t selfNormalized() const; Declare p.d.f self normalized. RooAbsPdf* getCachePdf(const RooArgSet& nset) const; Return RooHistPdf that represents cache histogram. RooDataHist* getCacheHist(const RooArgSet& nset) const; Return RooDataHist with cached values. Int_t getInterpolationOrder() const; Set interpolation order in RooHistPdf that represent cached histogram. PdfCacheElem* getCache(const RooArgSet* nset, Bool_t recalculate = kTRUE) const. const char* payloadUniqueSuffix() const; { return 0 ; }. const char* binningName() const; Return name of binning to be used for creation of cache histogram. PdfCacheElem* createCache(const RooArgSet* nset) const; Create",MatchSource.WIKI,root/html602/RooAbsCachedPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsCachedPdf.html
https://root.cern/root/html602/RooAbsCachedPdf.html:48711,Performance,cache,cache,48711,"e) const; Mark all bins of given cache as unitialized (value -1). TString cacheNameSuffix(const RooArgSet& nset) const; Construct string with unique suffix for cache objects based on; observable names that define cache configuration. void setInterpolationOrder(Int_t order); Change the interpolation order that is used in RooHistPdf cache; representation smoothing the RooDataHist shapes. Bool_t forceAnalyticalInt(const RooAbsArg& dep) const; Force RooRealIntegral to offer all our actual observable for internal; integration. Int_t getAnalyticalIntegralWN(RooArgSet& allVars, RooArgSet& analVars, const RooArgSet* normSet, const char* rangeName = 0) const; Advertises internal (analytical) integration capabilities. Call; is forwarded to RooHistPdf cache p.d.f of cache that is used for; given choice of observables. Double_t analyticalIntegralWN(Int_t code, const RooArgSet* normSet, const char* rangeName = 0) const; Implements internal (analytical) integration capabilities. Call; is forwarded to RooHistPdf cache p.d.f of cache that is used for; given choice of observables. RooAbsCachedPdf(); Default constructor. Bool_t selfNormalized() const; Declare p.d.f self normalized. RooAbsPdf* getCachePdf(const RooArgSet& nset) const; Return RooHistPdf that represents cache histogram. RooDataHist* getCacheHist(const RooArgSet& nset) const; Return RooDataHist with cached values. Int_t getInterpolationOrder() const; Set interpolation order in RooHistPdf that represent cached histogram. PdfCacheElem* getCache(const RooArgSet* nset, Bool_t recalculate = kTRUE) const. const char* payloadUniqueSuffix() const; { return 0 ; }. const char* binningName() const; Return name of binning to be used for creation of cache histogram. PdfCacheElem* createCache(const RooArgSet* nset) const; Create cache storage element. const char* inputBaseName() const. RooArgSet* actualObservables(const RooArgSet& nset) const. RooArgSet* actualParameters(const RooArgSet& nset) const. RooAbsArg& pdfObservable(RooAbsArg",MatchSource.WIKI,root/html602/RooAbsCachedPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsCachedPdf.html
https://root.cern/root/html602/RooAbsCachedPdf.html:48726,Performance,cache,cache,48726,"ed (value -1). TString cacheNameSuffix(const RooArgSet& nset) const; Construct string with unique suffix for cache objects based on; observable names that define cache configuration. void setInterpolationOrder(Int_t order); Change the interpolation order that is used in RooHistPdf cache; representation smoothing the RooDataHist shapes. Bool_t forceAnalyticalInt(const RooAbsArg& dep) const; Force RooRealIntegral to offer all our actual observable for internal; integration. Int_t getAnalyticalIntegralWN(RooArgSet& allVars, RooArgSet& analVars, const RooArgSet* normSet, const char* rangeName = 0) const; Advertises internal (analytical) integration capabilities. Call; is forwarded to RooHistPdf cache p.d.f of cache that is used for; given choice of observables. Double_t analyticalIntegralWN(Int_t code, const RooArgSet* normSet, const char* rangeName = 0) const; Implements internal (analytical) integration capabilities. Call; is forwarded to RooHistPdf cache p.d.f of cache that is used for; given choice of observables. RooAbsCachedPdf(); Default constructor. Bool_t selfNormalized() const; Declare p.d.f self normalized. RooAbsPdf* getCachePdf(const RooArgSet& nset) const; Return RooHistPdf that represents cache histogram. RooDataHist* getCacheHist(const RooArgSet& nset) const; Return RooDataHist with cached values. Int_t getInterpolationOrder() const; Set interpolation order in RooHistPdf that represent cached histogram. PdfCacheElem* getCache(const RooArgSet* nset, Bool_t recalculate = kTRUE) const. const char* payloadUniqueSuffix() const; { return 0 ; }. const char* binningName() const; Return name of binning to be used for creation of cache histogram. PdfCacheElem* createCache(const RooArgSet* nset) const; Create cache storage element. const char* inputBaseName() const. RooArgSet* actualObservables(const RooArgSet& nset) const. RooArgSet* actualParameters(const RooArgSet& nset) const. RooAbsArg& pdfObservable(RooAbsArg& histObservable) const; { return histObservable ; }",MatchSource.WIKI,root/html602/RooAbsCachedPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsCachedPdf.html
https://root.cern/root/html602/RooAbsCachedPdf.html:48968,Performance,cache,cache,48968,"void setInterpolationOrder(Int_t order); Change the interpolation order that is used in RooHistPdf cache; representation smoothing the RooDataHist shapes. Bool_t forceAnalyticalInt(const RooAbsArg& dep) const; Force RooRealIntegral to offer all our actual observable for internal; integration. Int_t getAnalyticalIntegralWN(RooArgSet& allVars, RooArgSet& analVars, const RooArgSet* normSet, const char* rangeName = 0) const; Advertises internal (analytical) integration capabilities. Call; is forwarded to RooHistPdf cache p.d.f of cache that is used for; given choice of observables. Double_t analyticalIntegralWN(Int_t code, const RooArgSet* normSet, const char* rangeName = 0) const; Implements internal (analytical) integration capabilities. Call; is forwarded to RooHistPdf cache p.d.f of cache that is used for; given choice of observables. RooAbsCachedPdf(); Default constructor. Bool_t selfNormalized() const; Declare p.d.f self normalized. RooAbsPdf* getCachePdf(const RooArgSet& nset) const; Return RooHistPdf that represents cache histogram. RooDataHist* getCacheHist(const RooArgSet& nset) const; Return RooDataHist with cached values. Int_t getInterpolationOrder() const; Set interpolation order in RooHistPdf that represent cached histogram. PdfCacheElem* getCache(const RooArgSet* nset, Bool_t recalculate = kTRUE) const. const char* payloadUniqueSuffix() const; { return 0 ; }. const char* binningName() const; Return name of binning to be used for creation of cache histogram. PdfCacheElem* createCache(const RooArgSet* nset) const; Create cache storage element. const char* inputBaseName() const. RooArgSet* actualObservables(const RooArgSet& nset) const. RooArgSet* actualParameters(const RooArgSet& nset) const. RooAbsArg& pdfObservable(RooAbsArg& histObservable) const; { return histObservable ; }. void fillCacheObject(RooAbsCachedPdf::PdfCacheElem& cache) const. TString histNameSuffix() const; { return TString("""") ; }. void disableCache(Bool_t flag); Flag to disable caching ",MatchSource.WIKI,root/html602/RooAbsCachedPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsCachedPdf.html
https://root.cern/root/html602/RooAbsCachedPdf.html:49065,Performance,cache,cached,49065,"cache; representation smoothing the RooDataHist shapes. Bool_t forceAnalyticalInt(const RooAbsArg& dep) const; Force RooRealIntegral to offer all our actual observable for internal; integration. Int_t getAnalyticalIntegralWN(RooArgSet& allVars, RooArgSet& analVars, const RooArgSet* normSet, const char* rangeName = 0) const; Advertises internal (analytical) integration capabilities. Call; is forwarded to RooHistPdf cache p.d.f of cache that is used for; given choice of observables. Double_t analyticalIntegralWN(Int_t code, const RooArgSet* normSet, const char* rangeName = 0) const; Implements internal (analytical) integration capabilities. Call; is forwarded to RooHistPdf cache p.d.f of cache that is used for; given choice of observables. RooAbsCachedPdf(); Default constructor. Bool_t selfNormalized() const; Declare p.d.f self normalized. RooAbsPdf* getCachePdf(const RooArgSet& nset) const; Return RooHistPdf that represents cache histogram. RooDataHist* getCacheHist(const RooArgSet& nset) const; Return RooDataHist with cached values. Int_t getInterpolationOrder() const; Set interpolation order in RooHistPdf that represent cached histogram. PdfCacheElem* getCache(const RooArgSet* nset, Bool_t recalculate = kTRUE) const. const char* payloadUniqueSuffix() const; { return 0 ; }. const char* binningName() const; Return name of binning to be used for creation of cache histogram. PdfCacheElem* createCache(const RooArgSet* nset) const; Create cache storage element. const char* inputBaseName() const. RooArgSet* actualObservables(const RooArgSet& nset) const. RooArgSet* actualParameters(const RooArgSet& nset) const. RooAbsArg& pdfObservable(RooAbsArg& histObservable) const; { return histObservable ; }. void fillCacheObject(RooAbsCachedPdf::PdfCacheElem& cache) const. TString histNameSuffix() const; { return TString("""") ; }. void disableCache(Bool_t flag); Flag to disable caching mechanism. » Last changed: Tue Jun 30 14:29:56 2015 » Last generated: 2015-06-30 14:29; This page ha",MatchSource.WIKI,root/html602/RooAbsCachedPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsCachedPdf.html
https://root.cern/root/html602/RooAbsCachedPdf.html:49170,Performance,cache,cached,49170,") const; Force RooRealIntegral to offer all our actual observable for internal; integration. Int_t getAnalyticalIntegralWN(RooArgSet& allVars, RooArgSet& analVars, const RooArgSet* normSet, const char* rangeName = 0) const; Advertises internal (analytical) integration capabilities. Call; is forwarded to RooHistPdf cache p.d.f of cache that is used for; given choice of observables. Double_t analyticalIntegralWN(Int_t code, const RooArgSet* normSet, const char* rangeName = 0) const; Implements internal (analytical) integration capabilities. Call; is forwarded to RooHistPdf cache p.d.f of cache that is used for; given choice of observables. RooAbsCachedPdf(); Default constructor. Bool_t selfNormalized() const; Declare p.d.f self normalized. RooAbsPdf* getCachePdf(const RooArgSet& nset) const; Return RooHistPdf that represents cache histogram. RooDataHist* getCacheHist(const RooArgSet& nset) const; Return RooDataHist with cached values. Int_t getInterpolationOrder() const; Set interpolation order in RooHistPdf that represent cached histogram. PdfCacheElem* getCache(const RooArgSet* nset, Bool_t recalculate = kTRUE) const. const char* payloadUniqueSuffix() const; { return 0 ; }. const char* binningName() const; Return name of binning to be used for creation of cache histogram. PdfCacheElem* createCache(const RooArgSet* nset) const; Create cache storage element. const char* inputBaseName() const. RooArgSet* actualObservables(const RooArgSet& nset) const. RooArgSet* actualParameters(const RooArgSet& nset) const. RooAbsArg& pdfObservable(RooAbsArg& histObservable) const; { return histObservable ; }. void fillCacheObject(RooAbsCachedPdf::PdfCacheElem& cache) const. TString histNameSuffix() const; { return TString("""") ; }. void disableCache(Bool_t flag); Flag to disable caching mechanism. » Last changed: Tue Jun 30 14:29:56 2015 » Last generated: 2015-06-30 14:29; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in ge",MatchSource.WIKI,root/html602/RooAbsCachedPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsCachedPdf.html
https://root.cern/root/html602/RooAbsCachedPdf.html:49409,Performance,cache,cache,49409,"l our actual observable for internal; integration. Int_t getAnalyticalIntegralWN(RooArgSet& allVars, RooArgSet& analVars, const RooArgSet* normSet, const char* rangeName = 0) const; Advertises internal (analytical) integration capabilities. Call; is forwarded to RooHistPdf cache p.d.f of cache that is used for; given choice of observables. Double_t analyticalIntegralWN(Int_t code, const RooArgSet* normSet, const char* rangeName = 0) const; Implements internal (analytical) integration capabilities. Call; is forwarded to RooHistPdf cache p.d.f of cache that is used for; given choice of observables. RooAbsCachedPdf(); Default constructor. Bool_t selfNormalized() const; Declare p.d.f self normalized. RooAbsPdf* getCachePdf(const RooArgSet& nset) const; Return RooHistPdf that represents cache histogram. RooDataHist* getCacheHist(const RooArgSet& nset) const; Return RooDataHist with cached values. Int_t getInterpolationOrder() const; Set interpolation order in RooHistPdf that represent cached histogram. PdfCacheElem* getCache(const RooArgSet* nset, Bool_t recalculate = kTRUE) const. const char* payloadUniqueSuffix() const; { return 0 ; }. const char* binningName() const; Return name of binning to be used for creation of cache histogram. PdfCacheElem* createCache(const RooArgSet* nset) const; Create cache storage element. const char* inputBaseName() const. RooArgSet* actualObservables(const RooArgSet& nset) const. RooArgSet* actualParameters(const RooArgSet& nset) const. RooAbsArg& pdfObservable(RooAbsArg& histObservable) const; { return histObservable ; }. void fillCacheObject(RooAbsCachedPdf::PdfCacheElem& cache) const. TString histNameSuffix() const; { return TString("""") ; }. void disableCache(Bool_t flag); Flag to disable caching mechanism. » Last changed: Tue Jun 30 14:29:56 2015 » Last generated: 2015-06-30 14:29; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html602/RooAbsCachedPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsCachedPdf.html
https://root.cern/root/html602/RooAbsCachedPdf.html:49489,Performance,cache,cache,49489,"l our actual observable for internal; integration. Int_t getAnalyticalIntegralWN(RooArgSet& allVars, RooArgSet& analVars, const RooArgSet* normSet, const char* rangeName = 0) const; Advertises internal (analytical) integration capabilities. Call; is forwarded to RooHistPdf cache p.d.f of cache that is used for; given choice of observables. Double_t analyticalIntegralWN(Int_t code, const RooArgSet* normSet, const char* rangeName = 0) const; Implements internal (analytical) integration capabilities. Call; is forwarded to RooHistPdf cache p.d.f of cache that is used for; given choice of observables. RooAbsCachedPdf(); Default constructor. Bool_t selfNormalized() const; Declare p.d.f self normalized. RooAbsPdf* getCachePdf(const RooArgSet& nset) const; Return RooHistPdf that represents cache histogram. RooDataHist* getCacheHist(const RooArgSet& nset) const; Return RooDataHist with cached values. Int_t getInterpolationOrder() const; Set interpolation order in RooHistPdf that represent cached histogram. PdfCacheElem* getCache(const RooArgSet* nset, Bool_t recalculate = kTRUE) const. const char* payloadUniqueSuffix() const; { return 0 ; }. const char* binningName() const; Return name of binning to be used for creation of cache histogram. PdfCacheElem* createCache(const RooArgSet* nset) const; Create cache storage element. const char* inputBaseName() const. RooArgSet* actualObservables(const RooArgSet& nset) const. RooArgSet* actualParameters(const RooArgSet& nset) const. RooAbsArg& pdfObservable(RooAbsArg& histObservable) const; { return histObservable ; }. void fillCacheObject(RooAbsCachedPdf::PdfCacheElem& cache) const. TString histNameSuffix() const; { return TString("""") ; }. void disableCache(Bool_t flag); Flag to disable caching mechanism. » Last changed: Tue Jun 30 14:29:56 2015 » Last generated: 2015-06-30 14:29; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html602/RooAbsCachedPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsCachedPdf.html
https://root.cern/root/html602/RooAbsCachedPdf.html:49804,Performance,cache,cache,49804,"l our actual observable for internal; integration. Int_t getAnalyticalIntegralWN(RooArgSet& allVars, RooArgSet& analVars, const RooArgSet* normSet, const char* rangeName = 0) const; Advertises internal (analytical) integration capabilities. Call; is forwarded to RooHistPdf cache p.d.f of cache that is used for; given choice of observables. Double_t analyticalIntegralWN(Int_t code, const RooArgSet* normSet, const char* rangeName = 0) const; Implements internal (analytical) integration capabilities. Call; is forwarded to RooHistPdf cache p.d.f of cache that is used for; given choice of observables. RooAbsCachedPdf(); Default constructor. Bool_t selfNormalized() const; Declare p.d.f self normalized. RooAbsPdf* getCachePdf(const RooArgSet& nset) const; Return RooHistPdf that represents cache histogram. RooDataHist* getCacheHist(const RooArgSet& nset) const; Return RooDataHist with cached values. Int_t getInterpolationOrder() const; Set interpolation order in RooHistPdf that represent cached histogram. PdfCacheElem* getCache(const RooArgSet* nset, Bool_t recalculate = kTRUE) const. const char* payloadUniqueSuffix() const; { return 0 ; }. const char* binningName() const; Return name of binning to be used for creation of cache histogram. PdfCacheElem* createCache(const RooArgSet* nset) const; Create cache storage element. const char* inputBaseName() const. RooArgSet* actualObservables(const RooArgSet& nset) const. RooArgSet* actualParameters(const RooArgSet& nset) const. RooAbsArg& pdfObservable(RooAbsArg& histObservable) const; { return histObservable ; }. void fillCacheObject(RooAbsCachedPdf::PdfCacheElem& cache) const. TString histNameSuffix() const; { return TString("""") ; }. void disableCache(Bool_t flag); Flag to disable caching mechanism. » Last changed: Tue Jun 30 14:29:56 2015 » Last generated: 2015-06-30 14:29; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html602/RooAbsCachedPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsCachedPdf.html
https://root.cern/root/html602/RooAbsCachedPdf.html:13256,Security,hash,hash,13256,"Double_t yval); RooAbsArg*RooAbsArg::findServer(const char* name) const; RooAbsArg*RooAbsArg::findServer(const RooAbsArg& arg) const; RooAbsArg*RooAbsArg::findServer(Int_t index) const; virtual RooFitResult*RooAbsPdf::fitTo(RooAbsData& data, const RooLinkedList& cmdList); virtual RooFitResult*RooAbsPdf::fitTo(RooAbsData& data, const RooCmdArg& arg1 = RooCmdArg::none(), const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()); virtual voidRooAbsReal::fixAddCoefNormalization(const RooArgSet& addNormSet = RooArgSet(), Bool_t force = kTRUE); virtual voidRooAbsReal::fixAddCoefRange(const char* rangeName = 0, Bool_t force = kTRUE); static UInt_tRooAbsArg::fnv1a32(const char* data); static UInt_tRooAbsArg::fnv1a32(const char* data, ULong_t sz, UInt_t hash = fnv1a32start); static ULong64_tRooAbsArg::fnv1a64(const char* data); static ULong64_tRooAbsArg::fnv1a64(const char* data, ULong_t sz, ULong64_t hash = fnv1a64start); virtual Bool_tforceAnalyticalInt(const RooAbsArg& dep) const; virtual voidRooAbsReal::forceNumInt(Bool_t flag = kTRUE); RooFunctor*RooAbsReal::functor(const RooArgList& obs, const RooArgList& pars = RooArgList(), const RooArgSet& nset = RooArgSet()) const; RooDataSet*RooAbsPdf::generate(RooAbsPdf::GenSpec&) const; RooDataSet*RooAbsPdf::generate(const RooArgSet& whatVars, const RooDataSet& prototype, Int_t nEvents = 0, Bool_t verbose = kFALSE, Bool_t randProtoOrder = kFALSE, Bool_t resampleProto = kFALSE) const; RooDataSet*RooAbsPdf::generate(const RooArgSet& whatVars, Int_t nEvents, const RooCmdArg& arg1, const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none()); RooDataSet*RooAbsPdf::generate(const RooArgS",MatchSource.WIKI,root/html602/RooAbsCachedPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsCachedPdf.html
https://root.cern/root/html602/RooAbsCachedPdf.html:13407,Security,hash,hash,13407,"rg::findServer(Int_t index) const; virtual RooFitResult*RooAbsPdf::fitTo(RooAbsData& data, const RooLinkedList& cmdList); virtual RooFitResult*RooAbsPdf::fitTo(RooAbsData& data, const RooCmdArg& arg1 = RooCmdArg::none(), const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()); virtual voidRooAbsReal::fixAddCoefNormalization(const RooArgSet& addNormSet = RooArgSet(), Bool_t force = kTRUE); virtual voidRooAbsReal::fixAddCoefRange(const char* rangeName = 0, Bool_t force = kTRUE); static UInt_tRooAbsArg::fnv1a32(const char* data); static UInt_tRooAbsArg::fnv1a32(const char* data, ULong_t sz, UInt_t hash = fnv1a32start); static ULong64_tRooAbsArg::fnv1a64(const char* data); static ULong64_tRooAbsArg::fnv1a64(const char* data, ULong_t sz, ULong64_t hash = fnv1a64start); virtual Bool_tforceAnalyticalInt(const RooAbsArg& dep) const; virtual voidRooAbsReal::forceNumInt(Bool_t flag = kTRUE); RooFunctor*RooAbsReal::functor(const RooArgList& obs, const RooArgList& pars = RooArgList(), const RooArgSet& nset = RooArgSet()) const; RooDataSet*RooAbsPdf::generate(RooAbsPdf::GenSpec&) const; RooDataSet*RooAbsPdf::generate(const RooArgSet& whatVars, const RooDataSet& prototype, Int_t nEvents = 0, Bool_t verbose = kFALSE, Bool_t randProtoOrder = kFALSE, Bool_t resampleProto = kFALSE) const; RooDataSet*RooAbsPdf::generate(const RooArgSet& whatVars, Int_t nEvents, const RooCmdArg& arg1, const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none()); RooDataSet*RooAbsPdf::generate(const RooArgSet& whatVars, const RooCmdArg& arg1 = RooCmdArg::none(), const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const Ro",MatchSource.WIKI,root/html602/RooAbsCachedPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsCachedPdf.html
https://root.cern/root/html602/RooAbsCachedPdf.html:42767,Security,validat,validate,42767,,MatchSource.WIKI,root/html602/RooAbsCachedPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsCachedPdf.html
https://root.cern/root/html602/RooAbsCachedPdf.html:43649,Security,access,access,43649,"; Bool_tRooAbsReal::_boolValue! Transient cache for bool values from tree branches; UChar_tRooAbsReal::_byteValue! Transient cache for byte values from tree branches; static Bool_tRooAbsReal::_cacheCheckIf true, always validate contents of clean which outcome of evaluate(); deque<RooAbsCache*>RooAbsArg::_cacheListlist of caches; RooObjCacheManager_cacheMgrThe cache manager; RooRefCountListRooAbsArg::_clientListlist of client objects; RooRefCountListRooAbsArg::_clientListShapesubset of clients that requested shape dirty flag propagation; RooRefCountListRooAbsArg::_clientListValuesubset of clients that requested value dirty flag propagation; TIterator*RooAbsArg::_clientShapeIter! Iterator over _clientListShape; TIterator*RooAbsArg::_clientValueIter! Iterator over _clientListValue; Bool_tRooAbsArg::_deleteWatch! Delete watch flag; RooExpensiveObjectCache*RooAbsArg::_eocachePointer to global cache manager for any expensive components created by this object; Int_tRooAbsPdf::_errorCountNumber of errors remaining to print; static Bool_tRooAbsPdf::_evalError; Bool_tRooAbsArg::_fastAllow fast access mode in getVal() and proxies; Float_tRooAbsReal::_floatValue! Transient cache for floating point values from tree branches; Bool_tRooAbsReal::_forceNumIntForce numerical integration if flag set; static Bool_tRooAbsReal::_globalSelectCompGlobal activation switch for component selection; static Bool_tRooAbsReal::_hideOffsetOffset hiding flag; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; Int_tRooAbsReal::_intValue! Transient cache for integer values from tree branches; Int_t_ipOrderInterpolation order for cache histograms; Bool_tRooAbsArg::_isConstant! Cached isConstant status; TStringRooAbsReal::_labelPlot label for objects value; RooArgSet*RooAbsReal::_lastNSet!; Bool_tRooAbsArg::_localNoInhibitDirty! Prevent 'AlwaysDirty' mode for this node; static Int_tRooPrintable::_nameLength; TNamed*RooAbsArg::_namePtr! Do not persist.",MatchSource.WIKI,root/html602/RooAbsCachedPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsCachedPdf.html
https://root.cern/root/html602/RooAbsCachedPdf.html:9308,Testability,test,testArg,9308,"aramsOfInterest); virtual RooAbsPdf*RooAbsPdf::createProjection(const RooArgSet& iset); RooAbsReal*RooAbsReal::createRunningIntegral(const RooArgSet& iset, const RooArgSet& nset = RooArgSet()); RooAbsReal*RooAbsReal::createRunningIntegral(const RooArgSet& iset, const RooCmdArg& arg1, const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()); RooAbsReal*RooAbsPdf::createScanCdf(const RooArgSet& iset, const RooArgSet& nset, Int_t numScanBins, Int_t intOrder); RooAbsReal*RooAbsReal::createScanRI(const RooArgSet& iset, const RooArgSet& nset, Int_t numScanBins, Int_t intOrder); virtual Double_tRooAbsReal::defaultErrorLevel() const; static RooNumGenConfig*RooAbsPdf::defaultGeneratorConfig(); static RooNumIntConfig*RooAbsReal::defaultIntegratorConfig(); virtual Int_tRooAbsArg::defaultPrintContents(Option_t* opt) const; static ostream&RooPrintable::defaultPrintStream(ostream* os = 0); virtual RooPrintable::StyleOptionRooPrintable::defaultPrintStyle(Option_t* opt) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; Bool_tRooAbsArg::dependentOverlaps(const RooAbsData* dset, const RooAbsArg& testArg) const; Bool_tRooAbsArg::dependentOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; Bool_tRooAbsArg::dependsOn(const RooAbsCollection& serverList, const RooAbsArg* ignoreArg = 0, Bool_t valueOnly = kFALSE) const; Bool_tRooAbsArg::dependsOn(const RooAbsArg& server, const RooAbsArg* ignoreArg = 0, Bool_t valueOnly = kFALSE) const; Bool_tRooAbsArg::dependsOnValue(const RooAbsCollection& serverList, const RooAbsArg* ignoreArg = 0) const; Bool_tRooAbsArg::dependsOnValue(const RooAbsArg& server, const RooAbsArg* ignoreArg = 0) const; RooDerivative*RooAbsReal::derivative(RooRealVar& obs, Int_t order = 1, Double_t eps = 0.",MatchSource.WIKI,root/html602/RooAbsCachedPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsCachedPdf.html
https://root.cern/root/html602/RooAbsCachedPdf.html:9402,Testability,test,testArg,9402,"aramsOfInterest); virtual RooAbsPdf*RooAbsPdf::createProjection(const RooArgSet& iset); RooAbsReal*RooAbsReal::createRunningIntegral(const RooArgSet& iset, const RooArgSet& nset = RooArgSet()); RooAbsReal*RooAbsReal::createRunningIntegral(const RooArgSet& iset, const RooCmdArg& arg1, const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()); RooAbsReal*RooAbsPdf::createScanCdf(const RooArgSet& iset, const RooArgSet& nset, Int_t numScanBins, Int_t intOrder); RooAbsReal*RooAbsReal::createScanRI(const RooArgSet& iset, const RooArgSet& nset, Int_t numScanBins, Int_t intOrder); virtual Double_tRooAbsReal::defaultErrorLevel() const; static RooNumGenConfig*RooAbsPdf::defaultGeneratorConfig(); static RooNumIntConfig*RooAbsReal::defaultIntegratorConfig(); virtual Int_tRooAbsArg::defaultPrintContents(Option_t* opt) const; static ostream&RooPrintable::defaultPrintStream(ostream* os = 0); virtual RooPrintable::StyleOptionRooPrintable::defaultPrintStyle(Option_t* opt) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; Bool_tRooAbsArg::dependentOverlaps(const RooAbsData* dset, const RooAbsArg& testArg) const; Bool_tRooAbsArg::dependentOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; Bool_tRooAbsArg::dependsOn(const RooAbsCollection& serverList, const RooAbsArg* ignoreArg = 0, Bool_t valueOnly = kFALSE) const; Bool_tRooAbsArg::dependsOn(const RooAbsArg& server, const RooAbsArg* ignoreArg = 0, Bool_t valueOnly = kFALSE) const; Bool_tRooAbsArg::dependsOnValue(const RooAbsCollection& serverList, const RooAbsArg* ignoreArg = 0) const; Bool_tRooAbsArg::dependsOnValue(const RooAbsArg& server, const RooAbsArg* ignoreArg = 0) const; RooDerivative*RooAbsReal::derivative(RooRealVar& obs, Int_t order = 1, Double_t eps = 0.",MatchSource.WIKI,root/html602/RooAbsCachedPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsCachedPdf.html
https://root.cern/root/html602/RooAbsCachedPdf.html:21874,Testability,log,logEvalError,21874,") const; virtual Bool_tTObject::IsFolder() const; virtual Bool_tRooAbsArg::isFundamental() const; virtual Bool_tRooAbsReal::isIdentical(const RooAbsArg& other, Bool_t assumeSameType = kFALSE); virtual Bool_tRooAbsArg::isLValue() const; virtual Bool_tRooAbsReal::isOffsetting() const; Bool_tTObject::IsOnHeap() const; Bool_tRooAbsArg::isShapeDirty() const; Bool_tRooAbsArg::isShapeServer(const RooAbsArg& arg) const; Bool_tRooAbsArg::isShapeServer(const char* name) const; virtual Bool_tRooAbsArg::IsSortable() const; Bool_tRooAbsArg::isValueDirty() const; Bool_tRooAbsArg::isValueDirtyAndClear() const; Bool_tRooAbsArg::isValueOrShapeDirtyAndClear() const; Bool_tRooAbsArg::isValueServer(const RooAbsArg& arg) const; Bool_tRooAbsArg::isValueServer(const char* name) const; Bool_tTObject::IsZombie() const; voidRooAbsArg::leafNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t recurseNonDerived = kFALSE) const; Bool_tRooAbsArg::localNoDirtyInhibit() const; voidRooAbsReal::logEvalError(const char* message, const char* serverValueString = 0) const; static voidRooAbsReal::logEvalError(const RooAbsReal* originator, const char* origName, const char* message, const char* serverValueString = 0); virtual voidTNamed::ls(Option_t* option = """") const; virtual Double_tRooAbsReal::maxVal(Int_t code) const; voidTObject::MayNotUse(const char* method) const; RooAbsMoment*RooAbsReal::mean(RooRealVar& obs); RooAbsMoment*RooAbsReal::mean(RooRealVar& obs, const RooArgSet& nset); virtual Int_tRooAbsReal::minTrialSamples(const RooArgSet&) const; RooAbsMoment*RooAbsReal::moment(RooRealVar& obs, Int_t order, Bool_t central, Bool_t takeRoot); RooAbsMoment*RooAbsReal::moment(RooRealVar& obs, const RooArgSet& normObs, Int_t order, Bool_t central, Bool_t takeRoot, Bool_t intNormObs); Bool_tRooAbsPdf::mustBeExtended() const; static voidRooPrintable::nameFieldLength(Int_t newLen); const TNamed*RooAbsArg::namePtr() const; const char*RooAbsPdf::normRange() const; virtual Bool_tTObject::Notif",MatchSource.WIKI,root/html602/RooAbsCachedPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsCachedPdf.html
https://root.cern/root/html602/RooAbsCachedPdf.html:21973,Testability,log,logEvalError,21973,"irtual Bool_tRooAbsReal::isIdentical(const RooAbsArg& other, Bool_t assumeSameType = kFALSE); virtual Bool_tRooAbsArg::isLValue() const; virtual Bool_tRooAbsReal::isOffsetting() const; Bool_tTObject::IsOnHeap() const; Bool_tRooAbsArg::isShapeDirty() const; Bool_tRooAbsArg::isShapeServer(const RooAbsArg& arg) const; Bool_tRooAbsArg::isShapeServer(const char* name) const; virtual Bool_tRooAbsArg::IsSortable() const; Bool_tRooAbsArg::isValueDirty() const; Bool_tRooAbsArg::isValueDirtyAndClear() const; Bool_tRooAbsArg::isValueOrShapeDirtyAndClear() const; Bool_tRooAbsArg::isValueServer(const RooAbsArg& arg) const; Bool_tRooAbsArg::isValueServer(const char* name) const; Bool_tTObject::IsZombie() const; voidRooAbsArg::leafNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t recurseNonDerived = kFALSE) const; Bool_tRooAbsArg::localNoDirtyInhibit() const; voidRooAbsReal::logEvalError(const char* message, const char* serverValueString = 0) const; static voidRooAbsReal::logEvalError(const RooAbsReal* originator, const char* origName, const char* message, const char* serverValueString = 0); virtual voidTNamed::ls(Option_t* option = """") const; virtual Double_tRooAbsReal::maxVal(Int_t code) const; voidTObject::MayNotUse(const char* method) const; RooAbsMoment*RooAbsReal::mean(RooRealVar& obs); RooAbsMoment*RooAbsReal::mean(RooRealVar& obs, const RooArgSet& nset); virtual Int_tRooAbsReal::minTrialSamples(const RooArgSet&) const; RooAbsMoment*RooAbsReal::moment(RooRealVar& obs, Int_t order, Bool_t central, Bool_t takeRoot); RooAbsMoment*RooAbsReal::moment(RooRealVar& obs, const RooArgSet& normObs, Int_t order, Bool_t central, Bool_t takeRoot, Bool_t intNormObs); Bool_tRooAbsPdf::mustBeExtended() const; static voidRooPrintable::nameFieldLength(Int_t newLen); const TNamed*RooAbsArg::namePtr() const; const char*RooAbsPdf::normRange() const; virtual Bool_tTObject::Notify(); Int_tRooAbsArg::numCaches() const; static Int_tRooAbsReal::numEvalErrorItems(); static Int_tRo",MatchSource.WIKI,root/html602/RooAbsCachedPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsCachedPdf.html
https://root.cern/root/html602/RooAbsCachedPdf.html:23084,Testability,test,testArg,23084," = 0); virtual voidTNamed::ls(Option_t* option = """") const; virtual Double_tRooAbsReal::maxVal(Int_t code) const; voidTObject::MayNotUse(const char* method) const; RooAbsMoment*RooAbsReal::mean(RooRealVar& obs); RooAbsMoment*RooAbsReal::mean(RooRealVar& obs, const RooArgSet& nset); virtual Int_tRooAbsReal::minTrialSamples(const RooArgSet&) const; RooAbsMoment*RooAbsReal::moment(RooRealVar& obs, Int_t order, Bool_t central, Bool_t takeRoot); RooAbsMoment*RooAbsReal::moment(RooRealVar& obs, const RooArgSet& normObs, Int_t order, Bool_t central, Bool_t takeRoot, Bool_t intNormObs); Bool_tRooAbsPdf::mustBeExtended() const; static voidRooPrintable::nameFieldLength(Int_t newLen); const TNamed*RooAbsArg::namePtr() const; const char*RooAbsPdf::normRange() const; virtual Bool_tTObject::Notify(); Int_tRooAbsArg::numCaches() const; static Int_tRooAbsReal::numEvalErrorItems(); static Int_tRooAbsReal::numEvalErrors(); Bool_tRooAbsArg::observableOverlaps(const RooAbsData* dset, const RooAbsArg& testArg) const; Bool_tRooAbsArg::observableOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; virtual Double_tRooAbsReal::offset() const; voidTObject::operator delete(void* ptr); voidTObject::operator delete(void* ptr, void* vp); voidTObject::operator delete[](void* ptr); voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); RooAbsCachedPdf&operator=(const RooAbsCachedPdf&); Bool_tRooAbsReal::operator==(Double_t value) const; virtual Bool_tRooAbsReal::operator==(const RooAbsArg& other); RooAbsArg::OperModeRooAbsArg::operMode() const; virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables); virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables, RooArgSet& optNodes, RooL",MatchSource.WIKI,root/html602/RooAbsCachedPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsCachedPdf.html
https://root.cern/root/html602/RooAbsCachedPdf.html:23179,Testability,test,testArg,23179,"Int_t code) const; voidTObject::MayNotUse(const char* method) const; RooAbsMoment*RooAbsReal::mean(RooRealVar& obs); RooAbsMoment*RooAbsReal::mean(RooRealVar& obs, const RooArgSet& nset); virtual Int_tRooAbsReal::minTrialSamples(const RooArgSet&) const; RooAbsMoment*RooAbsReal::moment(RooRealVar& obs, Int_t order, Bool_t central, Bool_t takeRoot); RooAbsMoment*RooAbsReal::moment(RooRealVar& obs, const RooArgSet& normObs, Int_t order, Bool_t central, Bool_t takeRoot, Bool_t intNormObs); Bool_tRooAbsPdf::mustBeExtended() const; static voidRooPrintable::nameFieldLength(Int_t newLen); const TNamed*RooAbsArg::namePtr() const; const char*RooAbsPdf::normRange() const; virtual Bool_tTObject::Notify(); Int_tRooAbsArg::numCaches() const; static Int_tRooAbsReal::numEvalErrorItems(); static Int_tRooAbsReal::numEvalErrors(); Bool_tRooAbsArg::observableOverlaps(const RooAbsData* dset, const RooAbsArg& testArg) const; Bool_tRooAbsArg::observableOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; virtual Double_tRooAbsReal::offset() const; voidTObject::operator delete(void* ptr); voidTObject::operator delete(void* ptr, void* vp); voidTObject::operator delete[](void* ptr); voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); RooAbsCachedPdf&operator=(const RooAbsCachedPdf&); Bool_tRooAbsReal::operator==(Double_t value) const; virtual Bool_tRooAbsReal::operator==(const RooAbsArg& other); RooAbsArg::OperModeRooAbsArg::operMode() const; virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables); virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables, RooArgSet& optNodes, RooLinkedList& processedNodes); Bool_tRooAbsArg::overlaps(const RooAbsArg& testArg, Bool_t valueOnl",MatchSource.WIKI,root/html602/RooAbsCachedPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsCachedPdf.html
https://root.cern/root/html602/RooAbsCachedPdf.html:24159,Testability,test,testArg,24159,"ooRealVar& obs, Int_t order, Bool_t central, Bool_t takeRoot); RooAbsMoment*RooAbsReal::moment(RooRealVar& obs, const RooArgSet& normObs, Int_t order, Bool_t central, Bool_t takeRoot, Bool_t intNormObs); Bool_tRooAbsPdf::mustBeExtended() const; static voidRooPrintable::nameFieldLength(Int_t newLen); const TNamed*RooAbsArg::namePtr() const; const char*RooAbsPdf::normRange() const; virtual Bool_tTObject::Notify(); Int_tRooAbsArg::numCaches() const; static Int_tRooAbsReal::numEvalErrorItems(); static Int_tRooAbsReal::numEvalErrors(); Bool_tRooAbsArg::observableOverlaps(const RooAbsData* dset, const RooAbsArg& testArg) const; Bool_tRooAbsArg::observableOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; virtual Double_tRooAbsReal::offset() const; voidTObject::operator delete(void* ptr); voidTObject::operator delete(void* ptr, void* vp); voidTObject::operator delete[](void* ptr); voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); RooAbsCachedPdf&operator=(const RooAbsCachedPdf&); Bool_tRooAbsReal::operator==(Double_t value) const; virtual Bool_tRooAbsReal::operator==(const RooAbsArg& other); RooAbsArg::OperModeRooAbsArg::operMode() const; virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables); virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables, RooArgSet& optNodes, RooLinkedList& processedNodes); Bool_tRooAbsArg::overlaps(const RooAbsArg& testArg, Bool_t valueOnly = kFALSE) const; const RooArgSet*RooAbsArg::ownedComponents() const; virtual voidTObject::Paint(Option_t* option = """"); virtual RooPlot*RooAbsPdf::paramOn(RooPlot* frame, const RooAbsData* data, const char* label = """", Int_t sigDigits = 2, Option_t* options = ""NELU"", Double_t xmin = 0.",MatchSource.WIKI,root/html602/RooAbsCachedPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsCachedPdf.html
https://root.cern/root/html602/RooAbsCachedPdf.html:3338,Usability,clear,clearEvalError,3338,"ual list<Double_t>*RooAbsReal::binBoundaries(RooAbsRealLValue&, Double_t, Double_t) const; RooAbsFunc*RooAbsReal::bindVars(const RooArgSet& vars, const RooArgSet* nset = 0, Bool_t clipInvalid = kFALSE) const; voidRooAbsArg::branchNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t recurseNonDerived = kFALSE) const; virtual voidTObject::Browse(TBrowser* b); virtual const char*RooAbsArg::cacheUniqueSuffix() const; Bool_tRooAbsPdf::canBeExtended() const; virtual RooAbsArg::CacheModeRooAbsArg::canNodeBeCached() const; voidRooAbsArg::changeServer(RooAbsArg& server, Bool_t valueProp, Bool_t shapeProp); Bool_tRooAbsArg::checkDependents(const RooArgSet* nset) const; virtual Bool_tRooAbsArg::checkObservables(const RooArgSet* nset) const; virtual RooFitResult*RooAbsPdf::chi2FitTo(RooDataHist& data, const RooLinkedList& cmdList); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); static voidRooAbsPdf::clearEvalError(); static voidRooAbsReal::clearEvalErrorLog(); voidRooAbsArg::clearShapeDirty() const; voidRooAbsArg::clearValueAndShapeDirty() const; voidRooAbsArg::clearValueDirty() const; TIterator*RooAbsArg::clientIterator() const; virtual TObject*RooAbsArg::clone(const char* newname = 0) const; virtual TObject*RooAbsArg::Clone(const char* newname = 0) const; virtual RooAbsArg*RooAbsArg::cloneTree(const char* newname = 0) const; virtual Int_tRooAbsArg::Compare(const TObject* other) const; virtual voidRooAbsArg::constOptimizeTestStatistic(RooAbsArg::ConstOpCode opcode, Bool_t doAlsoTrackingOpt = kTRUE); virtual voidTNamed::Copy(TObject& named) const; static UInt_tRooAbsArg::crc32(const char* data); static UInt_tRooAbsArg::crc32(const char* data, ULong_t sz, UInt_t crc = 0); RooAbsReal*RooAbsPdf::createCdf(const RooArgSet& iset, const RooArgSet& nset = RooArgSet()); RooAbsReal*RooAbsPdf::createCdf(const RooArgSet& iset, const RooCmdArg& arg1, const RooCmdArg& arg2 = RooCmdArg::none(), const R",MatchSource.WIKI,root/html602/RooAbsCachedPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsCachedPdf.html
https://root.cern/root/html602/RooAbsCachedPdf.html:3379,Usability,clear,clearEvalErrorLog,3379,"s(RooAbsRealLValue&, Double_t, Double_t) const; RooAbsFunc*RooAbsReal::bindVars(const RooArgSet& vars, const RooArgSet* nset = 0, Bool_t clipInvalid = kFALSE) const; voidRooAbsArg::branchNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t recurseNonDerived = kFALSE) const; virtual voidTObject::Browse(TBrowser* b); virtual const char*RooAbsArg::cacheUniqueSuffix() const; Bool_tRooAbsPdf::canBeExtended() const; virtual RooAbsArg::CacheModeRooAbsArg::canNodeBeCached() const; voidRooAbsArg::changeServer(RooAbsArg& server, Bool_t valueProp, Bool_t shapeProp); Bool_tRooAbsArg::checkDependents(const RooArgSet* nset) const; virtual Bool_tRooAbsArg::checkObservables(const RooArgSet* nset) const; virtual RooFitResult*RooAbsPdf::chi2FitTo(RooDataHist& data, const RooLinkedList& cmdList); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); static voidRooAbsPdf::clearEvalError(); static voidRooAbsReal::clearEvalErrorLog(); voidRooAbsArg::clearShapeDirty() const; voidRooAbsArg::clearValueAndShapeDirty() const; voidRooAbsArg::clearValueDirty() const; TIterator*RooAbsArg::clientIterator() const; virtual TObject*RooAbsArg::clone(const char* newname = 0) const; virtual TObject*RooAbsArg::Clone(const char* newname = 0) const; virtual RooAbsArg*RooAbsArg::cloneTree(const char* newname = 0) const; virtual Int_tRooAbsArg::Compare(const TObject* other) const; virtual voidRooAbsArg::constOptimizeTestStatistic(RooAbsArg::ConstOpCode opcode, Bool_t doAlsoTrackingOpt = kTRUE); virtual voidTNamed::Copy(TObject& named) const; static UInt_tRooAbsArg::crc32(const char* data); static UInt_tRooAbsArg::crc32(const char* data, ULong_t sz, UInt_t crc = 0); RooAbsReal*RooAbsPdf::createCdf(const RooArgSet& iset, const RooArgSet& nset = RooArgSet()); RooAbsReal*RooAbsPdf::createCdf(const RooArgSet& iset, const RooCmdArg& arg1, const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const ",MatchSource.WIKI,root/html602/RooAbsCachedPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsCachedPdf.html
https://root.cern/root/html602/RooAbsCachedPdf.html:3415,Usability,clear,clearShapeDirty,3415,"le_t) const; RooAbsFunc*RooAbsReal::bindVars(const RooArgSet& vars, const RooArgSet* nset = 0, Bool_t clipInvalid = kFALSE) const; voidRooAbsArg::branchNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t recurseNonDerived = kFALSE) const; virtual voidTObject::Browse(TBrowser* b); virtual const char*RooAbsArg::cacheUniqueSuffix() const; Bool_tRooAbsPdf::canBeExtended() const; virtual RooAbsArg::CacheModeRooAbsArg::canNodeBeCached() const; voidRooAbsArg::changeServer(RooAbsArg& server, Bool_t valueProp, Bool_t shapeProp); Bool_tRooAbsArg::checkDependents(const RooArgSet* nset) const; virtual Bool_tRooAbsArg::checkObservables(const RooArgSet* nset) const; virtual RooFitResult*RooAbsPdf::chi2FitTo(RooDataHist& data, const RooLinkedList& cmdList); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); static voidRooAbsPdf::clearEvalError(); static voidRooAbsReal::clearEvalErrorLog(); voidRooAbsArg::clearShapeDirty() const; voidRooAbsArg::clearValueAndShapeDirty() const; voidRooAbsArg::clearValueDirty() const; TIterator*RooAbsArg::clientIterator() const; virtual TObject*RooAbsArg::clone(const char* newname = 0) const; virtual TObject*RooAbsArg::Clone(const char* newname = 0) const; virtual RooAbsArg*RooAbsArg::cloneTree(const char* newname = 0) const; virtual Int_tRooAbsArg::Compare(const TObject* other) const; virtual voidRooAbsArg::constOptimizeTestStatistic(RooAbsArg::ConstOpCode opcode, Bool_t doAlsoTrackingOpt = kTRUE); virtual voidTNamed::Copy(TObject& named) const; static UInt_tRooAbsArg::crc32(const char* data); static UInt_tRooAbsArg::crc32(const char* data, ULong_t sz, UInt_t crc = 0); RooAbsReal*RooAbsPdf::createCdf(const RooArgSet& iset, const RooArgSet& nset = RooArgSet()); RooAbsReal*RooAbsPdf::createCdf(const RooArgSet& iset, const RooCmdArg& arg1, const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none()",MatchSource.WIKI,root/html602/RooAbsCachedPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsCachedPdf.html
https://root.cern/root/html602/RooAbsCachedPdf.html:3455,Usability,clear,clearValueAndShapeDirty,3455,"(const RooArgSet& vars, const RooArgSet* nset = 0, Bool_t clipInvalid = kFALSE) const; voidRooAbsArg::branchNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t recurseNonDerived = kFALSE) const; virtual voidTObject::Browse(TBrowser* b); virtual const char*RooAbsArg::cacheUniqueSuffix() const; Bool_tRooAbsPdf::canBeExtended() const; virtual RooAbsArg::CacheModeRooAbsArg::canNodeBeCached() const; voidRooAbsArg::changeServer(RooAbsArg& server, Bool_t valueProp, Bool_t shapeProp); Bool_tRooAbsArg::checkDependents(const RooArgSet* nset) const; virtual Bool_tRooAbsArg::checkObservables(const RooArgSet* nset) const; virtual RooFitResult*RooAbsPdf::chi2FitTo(RooDataHist& data, const RooLinkedList& cmdList); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); static voidRooAbsPdf::clearEvalError(); static voidRooAbsReal::clearEvalErrorLog(); voidRooAbsArg::clearShapeDirty() const; voidRooAbsArg::clearValueAndShapeDirty() const; voidRooAbsArg::clearValueDirty() const; TIterator*RooAbsArg::clientIterator() const; virtual TObject*RooAbsArg::clone(const char* newname = 0) const; virtual TObject*RooAbsArg::Clone(const char* newname = 0) const; virtual RooAbsArg*RooAbsArg::cloneTree(const char* newname = 0) const; virtual Int_tRooAbsArg::Compare(const TObject* other) const; virtual voidRooAbsArg::constOptimizeTestStatistic(RooAbsArg::ConstOpCode opcode, Bool_t doAlsoTrackingOpt = kTRUE); virtual voidTNamed::Copy(TObject& named) const; static UInt_tRooAbsArg::crc32(const char* data); static UInt_tRooAbsArg::crc32(const char* data, ULong_t sz, UInt_t crc = 0); RooAbsReal*RooAbsPdf::createCdf(const RooArgSet& iset, const RooArgSet& nset = RooArgSet()); RooAbsReal*RooAbsPdf::createCdf(const RooArgSet& iset, const RooCmdArg& arg1, const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(),",MatchSource.WIKI,root/html602/RooAbsCachedPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsCachedPdf.html
https://root.cern/root/html602/RooAbsCachedPdf.html:3503,Usability,clear,clearValueDirty,3503,"t = 0, Bool_t clipInvalid = kFALSE) const; voidRooAbsArg::branchNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t recurseNonDerived = kFALSE) const; virtual voidTObject::Browse(TBrowser* b); virtual const char*RooAbsArg::cacheUniqueSuffix() const; Bool_tRooAbsPdf::canBeExtended() const; virtual RooAbsArg::CacheModeRooAbsArg::canNodeBeCached() const; voidRooAbsArg::changeServer(RooAbsArg& server, Bool_t valueProp, Bool_t shapeProp); Bool_tRooAbsArg::checkDependents(const RooArgSet* nset) const; virtual Bool_tRooAbsArg::checkObservables(const RooArgSet* nset) const; virtual RooFitResult*RooAbsPdf::chi2FitTo(RooDataHist& data, const RooLinkedList& cmdList); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); static voidRooAbsPdf::clearEvalError(); static voidRooAbsReal::clearEvalErrorLog(); voidRooAbsArg::clearShapeDirty() const; voidRooAbsArg::clearValueAndShapeDirty() const; voidRooAbsArg::clearValueDirty() const; TIterator*RooAbsArg::clientIterator() const; virtual TObject*RooAbsArg::clone(const char* newname = 0) const; virtual TObject*RooAbsArg::Clone(const char* newname = 0) const; virtual RooAbsArg*RooAbsArg::cloneTree(const char* newname = 0) const; virtual Int_tRooAbsArg::Compare(const TObject* other) const; virtual voidRooAbsArg::constOptimizeTestStatistic(RooAbsArg::ConstOpCode opcode, Bool_t doAlsoTrackingOpt = kTRUE); virtual voidTNamed::Copy(TObject& named) const; static UInt_tRooAbsArg::crc32(const char* data); static UInt_tRooAbsArg::crc32(const char* data, ULong_t sz, UInt_t crc = 0); RooAbsReal*RooAbsPdf::createCdf(const RooArgSet& iset, const RooArgSet& nset = RooArgSet()); RooAbsReal*RooAbsPdf::createCdf(const RooArgSet& iset, const RooCmdArg& arg1, const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), ",MatchSource.WIKI,root/html602/RooAbsCachedPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsCachedPdf.html
https://root.cern/root/html602/RooAbsCachedPdf.html:47646,Usability,clear,clearCacheObject,47646,"r; TStringTNamed::fTitleobject title. private:. Bool_t_disableCacheFlag to run object in passthrough (= non-caching mode). Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; RooAbsCachedPdf(const char* name, const char* title, Int_t ipOrder = 0); Constructor. RooAbsCachedPdf(const RooAbsCachedPdf& other, const char* name = 0); Copy constructor. ~RooAbsCachedPdf(); Destructor. Double_t getValV(const RooArgSet* set = 0) const; Implementation of getVal() overriding default implementation; of RooAbsPdf. Return normalized value stored in cache p.d.f; rather than return value of evaluate() which is undefined; for RooAbsCachedPdf. RooAbsPdf* getCachePdf(const RooArgSet* nset = 0) const; Return pointer to RooHistPdf cache pdf for given choice of observables. RooDataHist* getCacheHist(const RooArgSet* nset = 0) const; Return pointer to RooDataHist cache histogram for given choice of observables. void clearCacheObject(RooAbsCachedPdf::PdfCacheElem& cache) const; Mark all bins of given cache as unitialized (value -1). TString cacheNameSuffix(const RooArgSet& nset) const; Construct string with unique suffix for cache objects based on; observable names that define cache configuration. void setInterpolationOrder(Int_t order); Change the interpolation order that is used in RooHistPdf cache; representation smoothing the RooDataHist shapes. Bool_t forceAnalyticalInt(const RooAbsArg& dep) const; Force RooRealIntegral to offer all our actual observable for internal; integration. Int_t getAnalyticalIntegralWN(RooArgSet& allVars, RooArgSet& analVars, const RooArgSet* normSet, const char* rangeName = 0) const; Advertises internal (analytical) integration capabilities. Call; is forwarded to RooHistPdf cache p.d.f of cache that is used for; given choice of observables. Double_t analyticalIntegralWN(Int_t code, const RooArgSet* normSet, const char* rangeName = 0) const; Implements internal (analytical) integration capabilities. Call; is forwarded to Ro",MatchSource.WIKI,root/html602/RooAbsCachedPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsCachedPdf.html
https://root.cern/root/html602/RooAbsCachedReal.html:1246,Availability,avail,available,1246,"FIT; » ROOFITCORE; » RooAbsCachedReal. class RooAbsCachedReal: public RooAbsReal. RooAbsCachedReal is the abstract base class for functions that need or; want to cache their evaluate() output in a RooHistFunc defined in; terms of the used observables. This base class manages the creation; and storage of all RooHistFunc cache p.d.fs and the RooDataHists; that define their shape. Implementations of RooAbsCachedReal must; define member function fillCacheObject() which serves to fill an; already created RooDataHist with the functions function values. In; addition the member functions actualObservables() and; actualParameters() must be define which report what the actual; observables to be cached are for a given set of observables passed; by the user to getVal() and on which parameters need to be tracked; for changes to trigger a refilling of the cache histogram.; . Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~RooAbsCachedReal(); voidTObject::AbstractMethod(const char* method) const; Bool_tRooAbsArg::addOwnedComponents(const RooArgSet& comps); voidRooAbsArg::addParameters(RooArgSet& params, const RooArgSet* nset = 0, Bool_t stripDisconnected = kTRUE) const; voidRooAbsArg::addServer(RooAbsArg& server, Bool_t valueProp = kTRUE, Bool_t shapeProp = kFALSE); voidRooAbsArg::addServerList(RooAbsCollection& serverList, Bool_t valueProp = kTRUE, Bool_t shapeProp = kFALSE); const char*RooAbsArg::aggregateCacheUniqueSuffix() const; virtual Double_tRooAbsReal::analyticalIntegral(Int_t code, const char* rangeName = 0) const; virtual Double_tanalyticalIntegralWN(Int_t code, const RooArgSet* normSet, const char* rangeName = 0) const; virtual voidTObject::AppendPad(Option_t* option = """"); TF1*RooAbsReal::asTF(const RooArgList& obs, const RooArgList& pars = RooArgList(), const RooArgSet& nset = RooArgSet()) const; voidRooAbsArg::attachDataSet(const RooAbsData&",MatchSource.WIKI,root/html602/RooAbsCachedReal.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsCachedReal.html
https://root.cern/root/html602/RooAbsCachedReal.html:10839,Availability,error,error,10839,,MatchSource.WIKI,root/html602/RooAbsCachedReal.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsCachedReal.html
https://root.cern/root/html602/RooAbsCachedReal.html:10923,Availability,error,error,10923,,MatchSource.WIKI,root/html602/RooAbsCachedReal.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsCachedReal.html
https://root.cern/root/html602/RooAbsCachedReal.html:35145,Deployability,integrat,integration,35145,,MatchSource.WIKI,root/html602/RooAbsCachedReal.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsCachedReal.html
https://root.cern/root/html602/RooAbsCachedReal.html:36490,Deployability,integrat,integration,36490,"tes; set<string>RooAbsArg::_boolAttribTransient! Transient boolean attributes (not copied in ctor); Bool_tRooAbsReal::_boolValue! Transient cache for bool values from tree branches; UChar_tRooAbsReal::_byteValue! Transient cache for byte values from tree branches; static Bool_tRooAbsReal::_cacheCheckIf true, always validate contents of clean which outcome of evaluate(); deque<RooAbsCache*>RooAbsArg::_cacheListlist of caches; RooObjCacheManager_cacheMgr! The cache manager; RooRefCountListRooAbsArg::_clientListlist of client objects; RooRefCountListRooAbsArg::_clientListShapesubset of clients that requested shape dirty flag propagation; RooRefCountListRooAbsArg::_clientListValuesubset of clients that requested value dirty flag propagation; TIterator*RooAbsArg::_clientShapeIter! Iterator over _clientListShape; TIterator*RooAbsArg::_clientValueIter! Iterator over _clientListValue; Bool_tRooAbsArg::_deleteWatch! Delete watch flag; RooExpensiveObjectCache*RooAbsArg::_eocachePointer to global cache manager for any expensive components created by this object; Bool_tRooAbsArg::_fastAllow fast access mode in getVal() and proxies; Float_tRooAbsReal::_floatValue! Transient cache for floating point values from tree branches; Bool_tRooAbsReal::_forceNumIntForce numerical integration if flag set; static Bool_tRooAbsReal::_globalSelectCompGlobal activation switch for component selection; static Bool_tRooAbsReal::_hideOffsetOffset hiding flag; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; Int_tRooAbsReal::_intValue! Transient cache for integer values from tree branches; Int_t_ipOrderInterpolation order for cache histograms; Bool_tRooAbsArg::_isConstant! Cached isConstant status; TStringRooAbsReal::_labelPlot label for objects value; RooArgSet*RooAbsReal::_lastNSet!; Bool_tRooAbsArg::_localNoInhibitDirty! Prevent 'AlwaysDirty' mode for this node; static Int_tRooPrintable::_nameLength; TNamed*RooAbsArg::_namePtr! Do not persist.",MatchSource.WIKI,root/html602/RooAbsCachedReal.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsCachedReal.html
https://root.cern/root/html602/RooAbsCachedReal.html:38083,Deployability,integrat,integrator,38083,"ringRooAbsReal::_labelPlot label for objects value; RooArgSet*RooAbsReal::_lastNSet!; Bool_tRooAbsArg::_localNoInhibitDirty! Prevent 'AlwaysDirty' mode for this node; static Int_tRooPrintable::_nameLength; TNamed*RooAbsArg::_namePtr! Do not persist. Pointer to global instance of string that matches object named; RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; Int_tRooAbsReal::_plotBinsNumber of plot bins; Double_tRooAbsReal::_plotMaxMaximum of plot range; Double_tRooAbsReal::_plotMinMinimum of plot range; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; RooRefArrayRooAbsArg::_proxyListlist of proxies; Char_tRooAbsReal::_sbyteValue! Transient cache for signed byte values from tree branches; Bool_tRooAbsReal::_selectComp! Component selection flag for RooAbsPdf::plotCompOn; RooRefCountListRooAbsArg::_serverListlist of server objects; Bool_tRooAbsArg::_shapeDirtyFlag set if value needs recalculating because input shapes modified; RooNumIntConfig*RooAbsReal::_specIntegratorConfigNumeric integrator configuration specific for this object; map<string,string>RooAbsArg::_stringAttribString attributes; Bool_tRooAbsReal::_treeVar!do not persist; UInt_tRooAbsReal::_uintValue! Transient cache for unsigned integer values from tree branches; TStringRooAbsReal::_unitUnit for objects value; Double_tRooAbsReal::_valueCache for current value of object; Bool_tRooAbsArg::_valueDirtyFlag set if value needs recalculating because input values modified; static Bool_tRooAbsArg::_verboseDirtyStatic flag controlling verbose messaging for dirty state changes; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title. private:. Bool_t_disableCacheFlag to run object in passthrough (= non-caching mode). Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; RooAbsCachedReal(const char* name, const char* title, Int_t ipOrder = 0)",MatchSource.WIKI,root/html602/RooAbsCachedReal.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsCachedReal.html
https://root.cern/root/html602/RooAbsCachedReal.html:38094,Deployability,configurat,configuration,38094,"ringRooAbsReal::_labelPlot label for objects value; RooArgSet*RooAbsReal::_lastNSet!; Bool_tRooAbsArg::_localNoInhibitDirty! Prevent 'AlwaysDirty' mode for this node; static Int_tRooPrintable::_nameLength; TNamed*RooAbsArg::_namePtr! Do not persist. Pointer to global instance of string that matches object named; RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; Int_tRooAbsReal::_plotBinsNumber of plot bins; Double_tRooAbsReal::_plotMaxMaximum of plot range; Double_tRooAbsReal::_plotMinMinimum of plot range; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; RooRefArrayRooAbsArg::_proxyListlist of proxies; Char_tRooAbsReal::_sbyteValue! Transient cache for signed byte values from tree branches; Bool_tRooAbsReal::_selectComp! Component selection flag for RooAbsPdf::plotCompOn; RooRefCountListRooAbsArg::_serverListlist of server objects; Bool_tRooAbsArg::_shapeDirtyFlag set if value needs recalculating because input shapes modified; RooNumIntConfig*RooAbsReal::_specIntegratorConfigNumeric integrator configuration specific for this object; map<string,string>RooAbsArg::_stringAttribString attributes; Bool_tRooAbsReal::_treeVar!do not persist; UInt_tRooAbsReal::_uintValue! Transient cache for unsigned integer values from tree branches; TStringRooAbsReal::_unitUnit for objects value; Double_tRooAbsReal::_valueCache for current value of object; Bool_tRooAbsArg::_valueDirtyFlag set if value needs recalculating because input values modified; static Bool_tRooAbsArg::_verboseDirtyStatic flag controlling verbose messaging for dirty state changes; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title. private:. Bool_t_disableCacheFlag to run object in passthrough (= non-caching mode). Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; RooAbsCachedReal(const char* name, const char* title, Int_t ipOrder = 0)",MatchSource.WIKI,root/html602/RooAbsCachedReal.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsCachedReal.html
https://root.cern/root/html602/RooAbsCachedReal.html:39822,Deployability,integrat,integration,39822,"de). Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; RooAbsCachedReal(const char* name, const char* title, Int_t ipOrder = 0); Constructor. RooAbsCachedReal(const RooAbsCachedReal& other, const char* name = 0); Copy constructor. ~RooAbsCachedReal(); Destructor. Double_t getValV(const RooArgSet* set = 0) const; Implementation of getVal() overriding default implementation; of RooAbsReal. Return value stored in cache p.d.f; rather than return value of evaluate() which is undefined; for RooAbsCachedReal. void clearCacheObject(RooAbsCachedReal::FuncCacheElem& cache) const; Mark all bins as unitialized (value -1). TString cacheNameSuffix(const RooArgSet& nset) const; Construct unique suffix name for cache p.d.f object. void setInterpolationOrder(Int_t order); Set interpolation order of RooHistFunct representing cache histogram. Int_t getAnalyticalIntegralWN(RooArgSet& allVars, RooArgSet& analVars, const RooArgSet* normSet, const char* rangeName = 0) const; Return analytical integration capabilities of the RooHistFunc that corresponds to the set of observables in allVars. Double_t analyticalIntegralWN(Int_t code, const RooArgSet* normSet, const char* rangeName = 0) const; Forward call to implementation in relevant RooHistFunc instance. RooAbsCachedReal(); {}. Bool_t selfNormalized() const; Declares function self normalized. Int_t getInterpolationOrder() const; Set interpolation order in RooHistFuncs that represent cache histograms. Bool_t forceAnalyticalInt(const RooAbsArg& ) const; Force all observables to be offered for internal integration. void disableCache(Bool_t flag); Switch to disable caching mechanism. FuncCacheElem* getCache(const RooArgSet* nset) const. const char* payloadUniqueSuffix() const; { return 0 ; }. const char* binningName() const; Returns name of binning to be used for cache histogram creation. FuncCacheElem* createCache(const RooArgSet* nset) const. const char* inputBaseName() const. RooArgSet* actualObserva",MatchSource.WIKI,root/html602/RooAbsCachedReal.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsCachedReal.html
https://root.cern/root/html602/RooAbsCachedReal.html:40389,Deployability,integrat,integration,40389,"default implementation; of RooAbsReal. Return value stored in cache p.d.f; rather than return value of evaluate() which is undefined; for RooAbsCachedReal. void clearCacheObject(RooAbsCachedReal::FuncCacheElem& cache) const; Mark all bins as unitialized (value -1). TString cacheNameSuffix(const RooArgSet& nset) const; Construct unique suffix name for cache p.d.f object. void setInterpolationOrder(Int_t order); Set interpolation order of RooHistFunct representing cache histogram. Int_t getAnalyticalIntegralWN(RooArgSet& allVars, RooArgSet& analVars, const RooArgSet* normSet, const char* rangeName = 0) const; Return analytical integration capabilities of the RooHistFunc that corresponds to the set of observables in allVars. Double_t analyticalIntegralWN(Int_t code, const RooArgSet* normSet, const char* rangeName = 0) const; Forward call to implementation in relevant RooHistFunc instance. RooAbsCachedReal(); {}. Bool_t selfNormalized() const; Declares function self normalized. Int_t getInterpolationOrder() const; Set interpolation order in RooHistFuncs that represent cache histograms. Bool_t forceAnalyticalInt(const RooAbsArg& ) const; Force all observables to be offered for internal integration. void disableCache(Bool_t flag); Switch to disable caching mechanism. FuncCacheElem* getCache(const RooArgSet* nset) const. const char* payloadUniqueSuffix() const; { return 0 ; }. const char* binningName() const; Returns name of binning to be used for cache histogram creation. FuncCacheElem* createCache(const RooArgSet* nset) const. const char* inputBaseName() const. RooArgSet* actualObservables(const RooArgSet& nset) const. RooArgSet* actualParameters(const RooArgSet& nset) const. void fillCacheObject(RooAbsCachedReal::FuncCacheElem& cache) const. » Last changed: Tue Jun 30 14:29:58 2015 » Last generated: 2015-06-30 14:29; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html602/RooAbsCachedReal.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsCachedReal.html
https://root.cern/root/html602/RooAbsCachedReal.html:8137,Integrability,depend,dependentVars,8137,"const char* rangeName = 0) const; virtual RooAbsReal*RooAbsReal::createIntegral(const RooArgSet& iset, const RooArgSet* nset = 0, const RooNumIntConfig* cfg = 0, const char* rangeName = 0) const; RooAbsReal*RooAbsReal::createIntegral(const RooArgSet& iset, const RooCmdArg& arg1, const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()) const; RooAbsReal*RooAbsReal::createIntRI(const RooArgSet& iset, const RooArgSet& nset = RooArgSet()); const RooAbsReal*RooAbsReal::createPlotProjection(const RooArgSet& depVars, const RooArgSet& projVars) const; const RooAbsReal*RooAbsReal::createPlotProjection(const RooArgSet& depVars, const RooArgSet& projVars, RooArgSet*& cloneSet) const; const RooAbsReal*RooAbsReal::createPlotProjection(const RooArgSet& dependentVars, const RooArgSet* projectedVars, RooArgSet*& cloneSet, const char* rangeName = 0, const RooArgSet* condObs = 0) const; virtual RooAbsReal*RooAbsReal::createProfile(const RooArgSet& paramsOfInterest); RooAbsReal*RooAbsReal::createRunningIntegral(const RooArgSet& iset, const RooArgSet& nset = RooArgSet()); RooAbsReal*RooAbsReal::createRunningIntegral(const RooArgSet& iset, const RooCmdArg& arg1, const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()); RooAbsReal*RooAbsReal::createScanRI(const RooArgSet& iset, const RooArgSet& nset, Int_t numScanBins, Int_t intOrder); virtual Double_tRooAbsReal::defaultErrorLevel() const; static RooNumIntConfig*RooAbsReal::defaultIntegratorConfig(); virtual Int_tRooAbsArg::defaultPrintContents(Option_t* opt)",MatchSource.WIKI,root/html602/RooAbsCachedReal.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsCachedReal.html
https://root.cern/root/html602/RooAbsCachedReal.html:9379,Integrability,depend,dependentOverlaps,9379,"l*RooAbsReal::createPlotProjection(const RooArgSet& dependentVars, const RooArgSet* projectedVars, RooArgSet*& cloneSet, const char* rangeName = 0, const RooArgSet* condObs = 0) const; virtual RooAbsReal*RooAbsReal::createProfile(const RooArgSet& paramsOfInterest); RooAbsReal*RooAbsReal::createRunningIntegral(const RooArgSet& iset, const RooArgSet& nset = RooArgSet()); RooAbsReal*RooAbsReal::createRunningIntegral(const RooArgSet& iset, const RooCmdArg& arg1, const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()); RooAbsReal*RooAbsReal::createScanRI(const RooArgSet& iset, const RooArgSet& nset, Int_t numScanBins, Int_t intOrder); virtual Double_tRooAbsReal::defaultErrorLevel() const; static RooNumIntConfig*RooAbsReal::defaultIntegratorConfig(); virtual Int_tRooAbsArg::defaultPrintContents(Option_t* opt) const; static ostream&RooPrintable::defaultPrintStream(ostream* os = 0); virtual RooPrintable::StyleOptionRooPrintable::defaultPrintStyle(Option_t* opt) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; Bool_tRooAbsArg::dependentOverlaps(const RooAbsData* dset, const RooAbsArg& testArg) const; Bool_tRooAbsArg::dependentOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; Bool_tRooAbsArg::dependsOn(const RooAbsCollection& serverList, const RooAbsArg* ignoreArg = 0, Bool_t valueOnly = kFALSE) const; Bool_tRooAbsArg::dependsOn(const RooAbsArg& server, const RooAbsArg* ignoreArg = 0, Bool_t valueOnly = kFALSE) const; Bool_tRooAbsArg::dependsOnValue(const RooAbsCollection& serverList, const RooAbsArg* ignoreArg = 0) const; Bool_tRooAbsArg::dependsOnValue(const RooAbsArg& server, const RooAbsArg* ignoreArg = 0) const; RooDerivative*RooAbsReal::derivative(RooRealVar& obs, Int_t order = 1, Double_t eps = 0.",MatchSource.WIKI,root/html602/RooAbsCachedReal.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsCachedReal.html
https://root.cern/root/html602/RooAbsCachedReal.html:9471,Integrability,depend,dependentOverlaps,9471,"l*RooAbsReal::createPlotProjection(const RooArgSet& dependentVars, const RooArgSet* projectedVars, RooArgSet*& cloneSet, const char* rangeName = 0, const RooArgSet* condObs = 0) const; virtual RooAbsReal*RooAbsReal::createProfile(const RooArgSet& paramsOfInterest); RooAbsReal*RooAbsReal::createRunningIntegral(const RooArgSet& iset, const RooArgSet& nset = RooArgSet()); RooAbsReal*RooAbsReal::createRunningIntegral(const RooArgSet& iset, const RooCmdArg& arg1, const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()); RooAbsReal*RooAbsReal::createScanRI(const RooArgSet& iset, const RooArgSet& nset, Int_t numScanBins, Int_t intOrder); virtual Double_tRooAbsReal::defaultErrorLevel() const; static RooNumIntConfig*RooAbsReal::defaultIntegratorConfig(); virtual Int_tRooAbsArg::defaultPrintContents(Option_t* opt) const; static ostream&RooPrintable::defaultPrintStream(ostream* os = 0); virtual RooPrintable::StyleOptionRooPrintable::defaultPrintStyle(Option_t* opt) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; Bool_tRooAbsArg::dependentOverlaps(const RooAbsData* dset, const RooAbsArg& testArg) const; Bool_tRooAbsArg::dependentOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; Bool_tRooAbsArg::dependsOn(const RooAbsCollection& serverList, const RooAbsArg* ignoreArg = 0, Bool_t valueOnly = kFALSE) const; Bool_tRooAbsArg::dependsOn(const RooAbsArg& server, const RooAbsArg* ignoreArg = 0, Bool_t valueOnly = kFALSE) const; Bool_tRooAbsArg::dependsOnValue(const RooAbsCollection& serverList, const RooAbsArg* ignoreArg = 0) const; Bool_tRooAbsArg::dependsOnValue(const RooAbsArg& server, const RooAbsArg* ignoreArg = 0) const; RooDerivative*RooAbsReal::derivative(RooRealVar& obs, Int_t order = 1, Double_t eps = 0.",MatchSource.WIKI,root/html602/RooAbsCachedReal.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsCachedReal.html
https://root.cern/root/html602/RooAbsCachedReal.html:9565,Integrability,depend,dependsOn,9565,"l*RooAbsReal::createPlotProjection(const RooArgSet& dependentVars, const RooArgSet* projectedVars, RooArgSet*& cloneSet, const char* rangeName = 0, const RooArgSet* condObs = 0) const; virtual RooAbsReal*RooAbsReal::createProfile(const RooArgSet& paramsOfInterest); RooAbsReal*RooAbsReal::createRunningIntegral(const RooArgSet& iset, const RooArgSet& nset = RooArgSet()); RooAbsReal*RooAbsReal::createRunningIntegral(const RooArgSet& iset, const RooCmdArg& arg1, const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()); RooAbsReal*RooAbsReal::createScanRI(const RooArgSet& iset, const RooArgSet& nset, Int_t numScanBins, Int_t intOrder); virtual Double_tRooAbsReal::defaultErrorLevel() const; static RooNumIntConfig*RooAbsReal::defaultIntegratorConfig(); virtual Int_tRooAbsArg::defaultPrintContents(Option_t* opt) const; static ostream&RooPrintable::defaultPrintStream(ostream* os = 0); virtual RooPrintable::StyleOptionRooPrintable::defaultPrintStyle(Option_t* opt) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; Bool_tRooAbsArg::dependentOverlaps(const RooAbsData* dset, const RooAbsArg& testArg) const; Bool_tRooAbsArg::dependentOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; Bool_tRooAbsArg::dependsOn(const RooAbsCollection& serverList, const RooAbsArg* ignoreArg = 0, Bool_t valueOnly = kFALSE) const; Bool_tRooAbsArg::dependsOn(const RooAbsArg& server, const RooAbsArg* ignoreArg = 0, Bool_t valueOnly = kFALSE) const; Bool_tRooAbsArg::dependsOnValue(const RooAbsCollection& serverList, const RooAbsArg* ignoreArg = 0) const; Bool_tRooAbsArg::dependsOnValue(const RooAbsArg& server, const RooAbsArg* ignoreArg = 0) const; RooDerivative*RooAbsReal::derivative(RooRealVar& obs, Int_t order = 1, Double_t eps = 0.",MatchSource.WIKI,root/html602/RooAbsCachedReal.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsCachedReal.html
https://root.cern/root/html602/RooAbsCachedReal.html:9694,Integrability,depend,dependsOn,9694,"l*RooAbsReal::createPlotProjection(const RooArgSet& dependentVars, const RooArgSet* projectedVars, RooArgSet*& cloneSet, const char* rangeName = 0, const RooArgSet* condObs = 0) const; virtual RooAbsReal*RooAbsReal::createProfile(const RooArgSet& paramsOfInterest); RooAbsReal*RooAbsReal::createRunningIntegral(const RooArgSet& iset, const RooArgSet& nset = RooArgSet()); RooAbsReal*RooAbsReal::createRunningIntegral(const RooArgSet& iset, const RooCmdArg& arg1, const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()); RooAbsReal*RooAbsReal::createScanRI(const RooArgSet& iset, const RooArgSet& nset, Int_t numScanBins, Int_t intOrder); virtual Double_tRooAbsReal::defaultErrorLevel() const; static RooNumIntConfig*RooAbsReal::defaultIntegratorConfig(); virtual Int_tRooAbsArg::defaultPrintContents(Option_t* opt) const; static ostream&RooPrintable::defaultPrintStream(ostream* os = 0); virtual RooPrintable::StyleOptionRooPrintable::defaultPrintStyle(Option_t* opt) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; Bool_tRooAbsArg::dependentOverlaps(const RooAbsData* dset, const RooAbsArg& testArg) const; Bool_tRooAbsArg::dependentOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; Bool_tRooAbsArg::dependsOn(const RooAbsCollection& serverList, const RooAbsArg* ignoreArg = 0, Bool_t valueOnly = kFALSE) const; Bool_tRooAbsArg::dependsOn(const RooAbsArg& server, const RooAbsArg* ignoreArg = 0, Bool_t valueOnly = kFALSE) const; Bool_tRooAbsArg::dependsOnValue(const RooAbsCollection& serverList, const RooAbsArg* ignoreArg = 0) const; Bool_tRooAbsArg::dependsOnValue(const RooAbsArg& server, const RooAbsArg* ignoreArg = 0) const; RooDerivative*RooAbsReal::derivative(RooRealVar& obs, Int_t order = 1, Double_t eps = 0.",MatchSource.WIKI,root/html602/RooAbsCachedReal.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsCachedReal.html
https://root.cern/root/html602/RooAbsCachedReal.html:9812,Integrability,depend,dependsOnValue,9812,"l*RooAbsReal::createPlotProjection(const RooArgSet& dependentVars, const RooArgSet* projectedVars, RooArgSet*& cloneSet, const char* rangeName = 0, const RooArgSet* condObs = 0) const; virtual RooAbsReal*RooAbsReal::createProfile(const RooArgSet& paramsOfInterest); RooAbsReal*RooAbsReal::createRunningIntegral(const RooArgSet& iset, const RooArgSet& nset = RooArgSet()); RooAbsReal*RooAbsReal::createRunningIntegral(const RooArgSet& iset, const RooCmdArg& arg1, const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()); RooAbsReal*RooAbsReal::createScanRI(const RooArgSet& iset, const RooArgSet& nset, Int_t numScanBins, Int_t intOrder); virtual Double_tRooAbsReal::defaultErrorLevel() const; static RooNumIntConfig*RooAbsReal::defaultIntegratorConfig(); virtual Int_tRooAbsArg::defaultPrintContents(Option_t* opt) const; static ostream&RooPrintable::defaultPrintStream(ostream* os = 0); virtual RooPrintable::StyleOptionRooPrintable::defaultPrintStyle(Option_t* opt) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; Bool_tRooAbsArg::dependentOverlaps(const RooAbsData* dset, const RooAbsArg& testArg) const; Bool_tRooAbsArg::dependentOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; Bool_tRooAbsArg::dependsOn(const RooAbsCollection& serverList, const RooAbsArg* ignoreArg = 0, Bool_t valueOnly = kFALSE) const; Bool_tRooAbsArg::dependsOn(const RooAbsArg& server, const RooAbsArg* ignoreArg = 0, Bool_t valueOnly = kFALSE) const; Bool_tRooAbsArg::dependsOnValue(const RooAbsCollection& serverList, const RooAbsArg* ignoreArg = 0) const; Bool_tRooAbsArg::dependsOnValue(const RooAbsArg& server, const RooAbsArg* ignoreArg = 0) const; RooDerivative*RooAbsReal::derivative(RooRealVar& obs, Int_t order = 1, Double_t eps = 0.",MatchSource.WIKI,root/html602/RooAbsCachedReal.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsCachedReal.html
https://root.cern/root/html602/RooAbsCachedReal.html:9919,Integrability,depend,dependsOnValue,9919,"l*RooAbsReal::createPlotProjection(const RooArgSet& dependentVars, const RooArgSet* projectedVars, RooArgSet*& cloneSet, const char* rangeName = 0, const RooArgSet* condObs = 0) const; virtual RooAbsReal*RooAbsReal::createProfile(const RooArgSet& paramsOfInterest); RooAbsReal*RooAbsReal::createRunningIntegral(const RooArgSet& iset, const RooArgSet& nset = RooArgSet()); RooAbsReal*RooAbsReal::createRunningIntegral(const RooArgSet& iset, const RooCmdArg& arg1, const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()); RooAbsReal*RooAbsReal::createScanRI(const RooArgSet& iset, const RooArgSet& nset, Int_t numScanBins, Int_t intOrder); virtual Double_tRooAbsReal::defaultErrorLevel() const; static RooNumIntConfig*RooAbsReal::defaultIntegratorConfig(); virtual Int_tRooAbsArg::defaultPrintContents(Option_t* opt) const; static ostream&RooPrintable::defaultPrintStream(ostream* os = 0); virtual RooPrintable::StyleOptionRooPrintable::defaultPrintStyle(Option_t* opt) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; Bool_tRooAbsArg::dependentOverlaps(const RooAbsData* dset, const RooAbsArg& testArg) const; Bool_tRooAbsArg::dependentOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; Bool_tRooAbsArg::dependsOn(const RooAbsCollection& serverList, const RooAbsArg* ignoreArg = 0, Bool_t valueOnly = kFALSE) const; Bool_tRooAbsArg::dependsOn(const RooAbsArg& server, const RooAbsArg* ignoreArg = 0, Bool_t valueOnly = kFALSE) const; Bool_tRooAbsArg::dependsOnValue(const RooAbsCollection& serverList, const RooAbsArg* ignoreArg = 0) const; Bool_tRooAbsArg::dependsOnValue(const RooAbsArg& server, const RooAbsArg* ignoreArg = 0) const; RooDerivative*RooAbsReal::derivative(RooRealVar& obs, Int_t order = 1, Double_t eps = 0.",MatchSource.WIKI,root/html602/RooAbsCachedReal.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsCachedReal.html
https://root.cern/root/html602/RooAbsCachedReal.html:18081,Integrability,message,message,18081,"TObject::IsFolder() const; virtual Bool_tRooAbsArg::isFundamental() const; virtual Bool_tRooAbsReal::isIdentical(const RooAbsArg& other, Bool_t assumeSameType = kFALSE); virtual Bool_tRooAbsArg::isLValue() const; virtual Bool_tRooAbsReal::isOffsetting() const; Bool_tTObject::IsOnHeap() const; Bool_tRooAbsArg::isShapeDirty() const; Bool_tRooAbsArg::isShapeServer(const RooAbsArg& arg) const; Bool_tRooAbsArg::isShapeServer(const char* name) const; virtual Bool_tRooAbsArg::IsSortable() const; Bool_tRooAbsArg::isValueDirty() const; Bool_tRooAbsArg::isValueDirtyAndClear() const; Bool_tRooAbsArg::isValueOrShapeDirtyAndClear() const; Bool_tRooAbsArg::isValueServer(const RooAbsArg& arg) const; Bool_tRooAbsArg::isValueServer(const char* name) const; Bool_tTObject::IsZombie() const; voidRooAbsArg::leafNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t recurseNonDerived = kFALSE) const; Bool_tRooAbsArg::localNoDirtyInhibit() const; voidRooAbsReal::logEvalError(const char* message, const char* serverValueString = 0) const; static voidRooAbsReal::logEvalError(const RooAbsReal* originator, const char* origName, const char* message, const char* serverValueString = 0); virtual voidTNamed::ls(Option_t* option = """") const; virtual Double_tRooAbsReal::maxVal(Int_t code) const; voidTObject::MayNotUse(const char* method) const; RooAbsMoment*RooAbsReal::mean(RooRealVar& obs); RooAbsMoment*RooAbsReal::mean(RooRealVar& obs, const RooArgSet& nset); virtual Int_tRooAbsReal::minTrialSamples(const RooArgSet&) const; RooAbsMoment*RooAbsReal::moment(RooRealVar& obs, Int_t order, Bool_t central, Bool_t takeRoot); RooAbsMoment*RooAbsReal::moment(RooRealVar& obs, const RooArgSet& normObs, Int_t order, Bool_t central, Bool_t takeRoot, Bool_t intNormObs); static voidRooPrintable::nameFieldLength(Int_t newLen); const TNamed*RooAbsArg::namePtr() const; virtual Bool_tTObject::Notify(); Int_tRooAbsArg::numCaches() const; static Int_tRooAbsReal::numEvalErrorItems(); static Int_tRooAbsR",MatchSource.WIKI,root/html602/RooAbsCachedReal.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsCachedReal.html
https://root.cern/root/html602/RooAbsCachedReal.html:18232,Integrability,message,message,18232,"ameType = kFALSE); virtual Bool_tRooAbsArg::isLValue() const; virtual Bool_tRooAbsReal::isOffsetting() const; Bool_tTObject::IsOnHeap() const; Bool_tRooAbsArg::isShapeDirty() const; Bool_tRooAbsArg::isShapeServer(const RooAbsArg& arg) const; Bool_tRooAbsArg::isShapeServer(const char* name) const; virtual Bool_tRooAbsArg::IsSortable() const; Bool_tRooAbsArg::isValueDirty() const; Bool_tRooAbsArg::isValueDirtyAndClear() const; Bool_tRooAbsArg::isValueOrShapeDirtyAndClear() const; Bool_tRooAbsArg::isValueServer(const RooAbsArg& arg) const; Bool_tRooAbsArg::isValueServer(const char* name) const; Bool_tTObject::IsZombie() const; voidRooAbsArg::leafNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t recurseNonDerived = kFALSE) const; Bool_tRooAbsArg::localNoDirtyInhibit() const; voidRooAbsReal::logEvalError(const char* message, const char* serverValueString = 0) const; static voidRooAbsReal::logEvalError(const RooAbsReal* originator, const char* origName, const char* message, const char* serverValueString = 0); virtual voidTNamed::ls(Option_t* option = """") const; virtual Double_tRooAbsReal::maxVal(Int_t code) const; voidTObject::MayNotUse(const char* method) const; RooAbsMoment*RooAbsReal::mean(RooRealVar& obs); RooAbsMoment*RooAbsReal::mean(RooRealVar& obs, const RooArgSet& nset); virtual Int_tRooAbsReal::minTrialSamples(const RooArgSet&) const; RooAbsMoment*RooAbsReal::moment(RooRealVar& obs, Int_t order, Bool_t central, Bool_t takeRoot); RooAbsMoment*RooAbsReal::moment(RooRealVar& obs, const RooArgSet& normObs, Int_t order, Bool_t central, Bool_t takeRoot, Bool_t intNormObs); static voidRooPrintable::nameFieldLength(Int_t newLen); const TNamed*RooAbsArg::namePtr() const; virtual Bool_tTObject::Notify(); Int_tRooAbsArg::numCaches() const; static Int_tRooAbsReal::numEvalErrorItems(); static Int_tRooAbsReal::numEvalErrors(); Bool_tRooAbsArg::observableOverlaps(const RooAbsData* dset, const RooAbsArg& testArg) const; Bool_tRooAbsArg::observableOverlaps(",MatchSource.WIKI,root/html602/RooAbsCachedReal.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsCachedReal.html
https://root.cern/root/html602/RooAbsCachedReal.html:35145,Integrability,integrat,integration,35145,,MatchSource.WIKI,root/html602/RooAbsCachedReal.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsCachedReal.html
https://root.cern/root/html602/RooAbsCachedReal.html:36490,Integrability,integrat,integration,36490,"tes; set<string>RooAbsArg::_boolAttribTransient! Transient boolean attributes (not copied in ctor); Bool_tRooAbsReal::_boolValue! Transient cache for bool values from tree branches; UChar_tRooAbsReal::_byteValue! Transient cache for byte values from tree branches; static Bool_tRooAbsReal::_cacheCheckIf true, always validate contents of clean which outcome of evaluate(); deque<RooAbsCache*>RooAbsArg::_cacheListlist of caches; RooObjCacheManager_cacheMgr! The cache manager; RooRefCountListRooAbsArg::_clientListlist of client objects; RooRefCountListRooAbsArg::_clientListShapesubset of clients that requested shape dirty flag propagation; RooRefCountListRooAbsArg::_clientListValuesubset of clients that requested value dirty flag propagation; TIterator*RooAbsArg::_clientShapeIter! Iterator over _clientListShape; TIterator*RooAbsArg::_clientValueIter! Iterator over _clientListValue; Bool_tRooAbsArg::_deleteWatch! Delete watch flag; RooExpensiveObjectCache*RooAbsArg::_eocachePointer to global cache manager for any expensive components created by this object; Bool_tRooAbsArg::_fastAllow fast access mode in getVal() and proxies; Float_tRooAbsReal::_floatValue! Transient cache for floating point values from tree branches; Bool_tRooAbsReal::_forceNumIntForce numerical integration if flag set; static Bool_tRooAbsReal::_globalSelectCompGlobal activation switch for component selection; static Bool_tRooAbsReal::_hideOffsetOffset hiding flag; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; Int_tRooAbsReal::_intValue! Transient cache for integer values from tree branches; Int_t_ipOrderInterpolation order for cache histograms; Bool_tRooAbsArg::_isConstant! Cached isConstant status; TStringRooAbsReal::_labelPlot label for objects value; RooArgSet*RooAbsReal::_lastNSet!; Bool_tRooAbsArg::_localNoInhibitDirty! Prevent 'AlwaysDirty' mode for this node; static Int_tRooPrintable::_nameLength; TNamed*RooAbsArg::_namePtr! Do not persist.",MatchSource.WIKI,root/html602/RooAbsCachedReal.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsCachedReal.html
https://root.cern/root/html602/RooAbsCachedReal.html:38083,Integrability,integrat,integrator,38083,"ringRooAbsReal::_labelPlot label for objects value; RooArgSet*RooAbsReal::_lastNSet!; Bool_tRooAbsArg::_localNoInhibitDirty! Prevent 'AlwaysDirty' mode for this node; static Int_tRooPrintable::_nameLength; TNamed*RooAbsArg::_namePtr! Do not persist. Pointer to global instance of string that matches object named; RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; Int_tRooAbsReal::_plotBinsNumber of plot bins; Double_tRooAbsReal::_plotMaxMaximum of plot range; Double_tRooAbsReal::_plotMinMinimum of plot range; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; RooRefArrayRooAbsArg::_proxyListlist of proxies; Char_tRooAbsReal::_sbyteValue! Transient cache for signed byte values from tree branches; Bool_tRooAbsReal::_selectComp! Component selection flag for RooAbsPdf::plotCompOn; RooRefCountListRooAbsArg::_serverListlist of server objects; Bool_tRooAbsArg::_shapeDirtyFlag set if value needs recalculating because input shapes modified; RooNumIntConfig*RooAbsReal::_specIntegratorConfigNumeric integrator configuration specific for this object; map<string,string>RooAbsArg::_stringAttribString attributes; Bool_tRooAbsReal::_treeVar!do not persist; UInt_tRooAbsReal::_uintValue! Transient cache for unsigned integer values from tree branches; TStringRooAbsReal::_unitUnit for objects value; Double_tRooAbsReal::_valueCache for current value of object; Bool_tRooAbsArg::_valueDirtyFlag set if value needs recalculating because input values modified; static Bool_tRooAbsArg::_verboseDirtyStatic flag controlling verbose messaging for dirty state changes; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title. private:. Bool_t_disableCacheFlag to run object in passthrough (= non-caching mode). Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; RooAbsCachedReal(const char* name, const char* title, Int_t ipOrder = 0)",MatchSource.WIKI,root/html602/RooAbsCachedReal.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsCachedReal.html
https://root.cern/root/html602/RooAbsCachedReal.html:39822,Integrability,integrat,integration,39822,"de). Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; RooAbsCachedReal(const char* name, const char* title, Int_t ipOrder = 0); Constructor. RooAbsCachedReal(const RooAbsCachedReal& other, const char* name = 0); Copy constructor. ~RooAbsCachedReal(); Destructor. Double_t getValV(const RooArgSet* set = 0) const; Implementation of getVal() overriding default implementation; of RooAbsReal. Return value stored in cache p.d.f; rather than return value of evaluate() which is undefined; for RooAbsCachedReal. void clearCacheObject(RooAbsCachedReal::FuncCacheElem& cache) const; Mark all bins as unitialized (value -1). TString cacheNameSuffix(const RooArgSet& nset) const; Construct unique suffix name for cache p.d.f object. void setInterpolationOrder(Int_t order); Set interpolation order of RooHistFunct representing cache histogram. Int_t getAnalyticalIntegralWN(RooArgSet& allVars, RooArgSet& analVars, const RooArgSet* normSet, const char* rangeName = 0) const; Return analytical integration capabilities of the RooHistFunc that corresponds to the set of observables in allVars. Double_t analyticalIntegralWN(Int_t code, const RooArgSet* normSet, const char* rangeName = 0) const; Forward call to implementation in relevant RooHistFunc instance. RooAbsCachedReal(); {}. Bool_t selfNormalized() const; Declares function self normalized. Int_t getInterpolationOrder() const; Set interpolation order in RooHistFuncs that represent cache histograms. Bool_t forceAnalyticalInt(const RooAbsArg& ) const; Force all observables to be offered for internal integration. void disableCache(Bool_t flag); Switch to disable caching mechanism. FuncCacheElem* getCache(const RooArgSet* nset) const. const char* payloadUniqueSuffix() const; { return 0 ; }. const char* binningName() const; Returns name of binning to be used for cache histogram creation. FuncCacheElem* createCache(const RooArgSet* nset) const. const char* inputBaseName() const. RooArgSet* actualObserva",MatchSource.WIKI,root/html602/RooAbsCachedReal.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsCachedReal.html
https://root.cern/root/html602/RooAbsCachedReal.html:40389,Integrability,integrat,integration,40389,"default implementation; of RooAbsReal. Return value stored in cache p.d.f; rather than return value of evaluate() which is undefined; for RooAbsCachedReal. void clearCacheObject(RooAbsCachedReal::FuncCacheElem& cache) const; Mark all bins as unitialized (value -1). TString cacheNameSuffix(const RooArgSet& nset) const; Construct unique suffix name for cache p.d.f object. void setInterpolationOrder(Int_t order); Set interpolation order of RooHistFunct representing cache histogram. Int_t getAnalyticalIntegralWN(RooArgSet& allVars, RooArgSet& analVars, const RooArgSet* normSet, const char* rangeName = 0) const; Return analytical integration capabilities of the RooHistFunc that corresponds to the set of observables in allVars. Double_t analyticalIntegralWN(Int_t code, const RooArgSet* normSet, const char* rangeName = 0) const; Forward call to implementation in relevant RooHistFunc instance. RooAbsCachedReal(); {}. Bool_t selfNormalized() const; Declares function self normalized. Int_t getInterpolationOrder() const; Set interpolation order in RooHistFuncs that represent cache histograms. Bool_t forceAnalyticalInt(const RooAbsArg& ) const; Force all observables to be offered for internal integration. void disableCache(Bool_t flag); Switch to disable caching mechanism. FuncCacheElem* getCache(const RooArgSet* nset) const. const char* payloadUniqueSuffix() const; { return 0 ; }. const char* binningName() const; Returns name of binning to be used for cache histogram creation. FuncCacheElem* createCache(const RooArgSet* nset) const. const char* inputBaseName() const. RooArgSet* actualObservables(const RooArgSet& nset) const. RooArgSet* actualParameters(const RooArgSet& nset) const. void fillCacheObject(RooAbsCachedReal::FuncCacheElem& cache) const. » Last changed: Tue Jun 30 14:29:58 2015 » Last generated: 2015-06-30 14:29; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html602/RooAbsCachedReal.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsCachedReal.html
https://root.cern/root/html602/RooAbsCachedReal.html:25136,Modifiability,config,config,25136,"; virtual Bool_tselfNormalized() const; TIterator*RooAbsArg::serverIterator() const; RooFIterRooAbsArg::serverMIterator() const; virtual voidRooAbsArg::serverNameChangeHook(const RooAbsArg*, const RooAbsArg*); voidRooAbsArg::setAttribute(const Text_t* name, Bool_t value = kTRUE); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); virtual voidRooAbsArg::setCacheAndTrackHints(RooArgSet&); static voidRooAbsReal::setCacheCheck(Bool_t flag); virtual Bool_tRooAbsReal::setData(RooAbsData&, Bool_t = kTRUE); static voidRooAbsArg::setDirtyInhibit(Bool_t flag); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); static voidRooAbsReal::setEvalErrorLoggingMode(RooAbsReal::ErrorLoggingMode m); virtual voidRooAbsArg::setExpensiveObjectCache(RooExpensiveObjectCache& cache); static voidRooAbsReal::setHideOffset(Bool_t flag); voidRooAbsReal::setIntegratorConfig(); voidRooAbsReal::setIntegratorConfig(const RooNumIntConfig& config); voidsetInterpolationOrder(Int_t order); voidRooAbsArg::setLocalNoDirtyInhibit(Bool_t flag) const; virtual voidRooAbsArg::SetName(const char* name); virtual voidRooAbsArg::SetNameTitle(const char* name, const char* title); static voidTObject::SetObjectStat(Bool_t stat); voidRooAbsArg::setOperMode(RooAbsArg::OperMode mode, Bool_t recurseADirty = kTRUE); voidRooAbsReal::setParameterizeIntegral(const RooArgSet& paramVars); voidRooAbsReal::setPlotLabel(const char* label); voidRooAbsArg::setProhibitServerRedirect(Bool_t flag); voidRooAbsArg::setShapeDirty() const; voidRooAbsArg::setStringAttribute(const Text_t* key, const Text_t* value); virtual voidTNamed::SetTitle(const char* title = """")MENU ; voidRooAbsArg::setTransientAttribute(const Text_t* name, Bool_t value = kTRUE); virtual voidTObject::SetUniqueID(UInt_t uid); voidRooAbsReal::setUnit(const char* unit); voidRooAbsArg::setValueDirty() const; TIterator*RooAbsArg::shapeClientIterator() const; RooFIterRooAbsArg::shapeClientMIterator",MatchSource.WIKI,root/html602/RooAbsCachedReal.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsCachedReal.html
https://root.cern/root/html602/RooAbsCachedReal.html:38094,Modifiability,config,configuration,38094,"ringRooAbsReal::_labelPlot label for objects value; RooArgSet*RooAbsReal::_lastNSet!; Bool_tRooAbsArg::_localNoInhibitDirty! Prevent 'AlwaysDirty' mode for this node; static Int_tRooPrintable::_nameLength; TNamed*RooAbsArg::_namePtr! Do not persist. Pointer to global instance of string that matches object named; RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; Int_tRooAbsReal::_plotBinsNumber of plot bins; Double_tRooAbsReal::_plotMaxMaximum of plot range; Double_tRooAbsReal::_plotMinMinimum of plot range; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; RooRefArrayRooAbsArg::_proxyListlist of proxies; Char_tRooAbsReal::_sbyteValue! Transient cache for signed byte values from tree branches; Bool_tRooAbsReal::_selectComp! Component selection flag for RooAbsPdf::plotCompOn; RooRefCountListRooAbsArg::_serverListlist of server objects; Bool_tRooAbsArg::_shapeDirtyFlag set if value needs recalculating because input shapes modified; RooNumIntConfig*RooAbsReal::_specIntegratorConfigNumeric integrator configuration specific for this object; map<string,string>RooAbsArg::_stringAttribString attributes; Bool_tRooAbsReal::_treeVar!do not persist; UInt_tRooAbsReal::_uintValue! Transient cache for unsigned integer values from tree branches; TStringRooAbsReal::_unitUnit for objects value; Double_tRooAbsReal::_valueCache for current value of object; Bool_tRooAbsArg::_valueDirtyFlag set if value needs recalculating because input values modified; static Bool_tRooAbsArg::_verboseDirtyStatic flag controlling verbose messaging for dirty state changes; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title. private:. Bool_t_disableCacheFlag to run object in passthrough (= non-caching mode). Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; RooAbsCachedReal(const char* name, const char* title, Int_t ipOrder = 0)",MatchSource.WIKI,root/html602/RooAbsCachedReal.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsCachedReal.html
https://root.cern/root/html602/RooAbsCachedReal.html:400,Performance,cache,cache,400,". RooAbsCachedReal. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » ROOFIT; » ROOFITCORE; » RooAbsCachedReal. class RooAbsCachedReal: public RooAbsReal. RooAbsCachedReal is the abstract base class for functions that need or; want to cache their evaluate() output in a RooHistFunc defined in; terms of the used observables. This base class manages the creation; and storage of all RooHistFunc cache p.d.fs and the RooDataHists; that define their shape. Implementations of RooAbsCachedReal must; define member function fillCacheObject() which serves to fill an; already created RooDataHist with the functions function values. In; addition the member functions actualObservables() and; actualParameters() must be define which report what the actual; observables to be cached are for a given set of observables passed; by the user to getVal() and on which parameters need to be tracked; for changes to trigger a refilling of the cache histogram.; . Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~RooAbsCachedReal(); voidTObject::AbstractMethod(const char* method) const; Bool_tRooAbsArg::addOwnedComponents(const RooArgSet& comps); voidRooAbsArg::addParameters(RooArgSet& params, const RooArgSet* nset = 0, Bool_t stripDisconnected = kTRUE) const; voidRooAbsArg::addServer(RooAbsArg& server, Bool_t valueProp = kTRUE, Bool_t shapeProp = kFALSE); voidRooAbsArg::addServerList(RooAbsCollection& serverList, Bool_t valueProp = kTRUE, Bool_t shapeProp = kFALSE); const char*RooAbsArg::aggregateCacheUniqueSuffix() const; virtual Double_tRooAbsReal::analyticalIntegral(Int_t code, const char* rangeName = 0) const; virtual Double_tanalyticalIntegralWN(Int_t code, const RooArgSet* normSet, const char* rangeName = ",MatchSource.WIKI,root/html602/RooAbsCachedReal.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsCachedReal.html
https://root.cern/root/html602/RooAbsCachedReal.html:559,Performance,cache,cache,559,". RooAbsCachedReal. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » ROOFIT; » ROOFITCORE; » RooAbsCachedReal. class RooAbsCachedReal: public RooAbsReal. RooAbsCachedReal is the abstract base class for functions that need or; want to cache their evaluate() output in a RooHistFunc defined in; terms of the used observables. This base class manages the creation; and storage of all RooHistFunc cache p.d.fs and the RooDataHists; that define their shape. Implementations of RooAbsCachedReal must; define member function fillCacheObject() which serves to fill an; already created RooDataHist with the functions function values. In; addition the member functions actualObservables() and; actualParameters() must be define which report what the actual; observables to be cached are for a given set of observables passed; by the user to getVal() and on which parameters need to be tracked; for changes to trigger a refilling of the cache histogram.; . Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~RooAbsCachedReal(); voidTObject::AbstractMethod(const char* method) const; Bool_tRooAbsArg::addOwnedComponents(const RooArgSet& comps); voidRooAbsArg::addParameters(RooArgSet& params, const RooArgSet* nset = 0, Bool_t stripDisconnected = kTRUE) const; voidRooAbsArg::addServer(RooAbsArg& server, Bool_t valueProp = kTRUE, Bool_t shapeProp = kFALSE); voidRooAbsArg::addServerList(RooAbsCollection& serverList, Bool_t valueProp = kTRUE, Bool_t shapeProp = kFALSE); const char*RooAbsArg::aggregateCacheUniqueSuffix() const; virtual Double_tRooAbsReal::analyticalIntegral(Int_t code, const char* rangeName = 0) const; virtual Double_tanalyticalIntegralWN(Int_t code, const RooArgSet* normSet, const char* rangeName = ",MatchSource.WIKI,root/html602/RooAbsCachedReal.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsCachedReal.html
https://root.cern/root/html602/RooAbsCachedReal.html:932,Performance,cache,cached,932,". RooAbsCachedReal. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » ROOFIT; » ROOFITCORE; » RooAbsCachedReal. class RooAbsCachedReal: public RooAbsReal. RooAbsCachedReal is the abstract base class for functions that need or; want to cache their evaluate() output in a RooHistFunc defined in; terms of the used observables. This base class manages the creation; and storage of all RooHistFunc cache p.d.fs and the RooDataHists; that define their shape. Implementations of RooAbsCachedReal must; define member function fillCacheObject() which serves to fill an; already created RooDataHist with the functions function values. In; addition the member functions actualObservables() and; actualParameters() must be define which report what the actual; observables to be cached are for a given set of observables passed; by the user to getVal() and on which parameters need to be tracked; for changes to trigger a refilling of the cache histogram.; . Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~RooAbsCachedReal(); voidTObject::AbstractMethod(const char* method) const; Bool_tRooAbsArg::addOwnedComponents(const RooArgSet& comps); voidRooAbsArg::addParameters(RooArgSet& params, const RooArgSet* nset = 0, Bool_t stripDisconnected = kTRUE) const; voidRooAbsArg::addServer(RooAbsArg& server, Bool_t valueProp = kTRUE, Bool_t shapeProp = kFALSE); voidRooAbsArg::addServerList(RooAbsCollection& serverList, Bool_t valueProp = kTRUE, Bool_t shapeProp = kFALSE); const char*RooAbsArg::aggregateCacheUniqueSuffix() const; virtual Double_tRooAbsReal::analyticalIntegral(Int_t code, const char* rangeName = 0) const; virtual Double_tanalyticalIntegralWN(Int_t code, const RooArgSet* normSet, const char* rangeName = ",MatchSource.WIKI,root/html602/RooAbsCachedReal.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsCachedReal.html
https://root.cern/root/html602/RooAbsCachedReal.html:1092,Performance,cache,cache,1092,". RooAbsCachedReal. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » ROOFIT; » ROOFITCORE; » RooAbsCachedReal. class RooAbsCachedReal: public RooAbsReal. RooAbsCachedReal is the abstract base class for functions that need or; want to cache their evaluate() output in a RooHistFunc defined in; terms of the used observables. This base class manages the creation; and storage of all RooHistFunc cache p.d.fs and the RooDataHists; that define their shape. Implementations of RooAbsCachedReal must; define member function fillCacheObject() which serves to fill an; already created RooDataHist with the functions function values. In; addition the member functions actualObservables() and; actualParameters() must be define which report what the actual; observables to be cached are for a given set of observables passed; by the user to getVal() and on which parameters need to be tracked; for changes to trigger a refilling of the cache histogram.; . Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~RooAbsCachedReal(); voidTObject::AbstractMethod(const char* method) const; Bool_tRooAbsArg::addOwnedComponents(const RooArgSet& comps); voidRooAbsArg::addParameters(RooArgSet& params, const RooArgSet* nset = 0, Bool_t stripDisconnected = kTRUE) const; voidRooAbsArg::addServer(RooAbsArg& server, Bool_t valueProp = kTRUE, Bool_t shapeProp = kFALSE); voidRooAbsArg::addServerList(RooAbsCollection& serverList, Bool_t valueProp = kTRUE, Bool_t shapeProp = kFALSE); const char*RooAbsArg::aggregateCacheUniqueSuffix() const; virtual Double_tRooAbsReal::analyticalIntegral(Int_t code, const char* rangeName = 0) const; virtual Double_tanalyticalIntegralWN(Int_t code, const RooArgSet* normSet, const char* rangeName = ",MatchSource.WIKI,root/html602/RooAbsCachedReal.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsCachedReal.html
https://root.cern/root/html602/RooAbsCachedReal.html:2768,Performance,cache,cacheUniqueSuffix,2768,"egateCacheUniqueSuffix() const; virtual Double_tRooAbsReal::analyticalIntegral(Int_t code, const char* rangeName = 0) const; virtual Double_tanalyticalIntegralWN(Int_t code, const RooArgSet* normSet, const char* rangeName = 0) const; virtual voidTObject::AppendPad(Option_t* option = """"); TF1*RooAbsReal::asTF(const RooArgList& obs, const RooArgList& pars = RooArgList(), const RooArgSet& nset = RooArgSet()) const; voidRooAbsArg::attachDataSet(const RooAbsData& set); voidRooAbsArg::attachDataStore(const RooAbsDataStore& set); const set<string>&RooAbsArg::attributes() const; virtual list<Double_t>*RooAbsReal::binBoundaries(RooAbsRealLValue&, Double_t, Double_t) const; RooAbsFunc*RooAbsReal::bindVars(const RooArgSet& vars, const RooArgSet* nset = 0, Bool_t clipInvalid = kFALSE) const; voidRooAbsArg::branchNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t recurseNonDerived = kFALSE) const; virtual voidTObject::Browse(TBrowser* b); virtual const char*RooAbsArg::cacheUniqueSuffix() const; virtual RooAbsArg::CacheModeRooAbsArg::canNodeBeCached() const; voidRooAbsArg::changeServer(RooAbsArg& server, Bool_t valueProp, Bool_t shapeProp); Bool_tRooAbsArg::checkDependents(const RooArgSet* nset) const; virtual Bool_tRooAbsArg::checkObservables(const RooArgSet* nset) const; virtual RooFitResult*RooAbsReal::chi2FitTo(RooDataHist& data, const RooLinkedList& cmdList); virtual RooFitResult*RooAbsReal::chi2FitTo(RooDataSet& xydata, const RooLinkedList& cmdList); virtual RooFitResult*RooAbsReal::chi2FitTo(RooDataHist& data, const RooCmdArg& arg1 = RooCmdArg::none(), const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()); virtual RooFitResult*RooAbsReal::chi2FitTo(RooDataSet& xydata, const RooCmdArg& arg1 = RooCmdArg::none(),",MatchSource.WIKI,root/html602/RooAbsCachedReal.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsCachedReal.html
https://root.cern/root/html602/RooAbsCachedReal.html:11657,Performance,cache,cacheList,11657,"rRooAbsReal::evalErrorIter(); static RooAbsReal::ErrorLoggingModeRooAbsReal::evalErrorLoggingMode(); virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); RooExpensiveObjectCache&RooAbsArg::expensiveObjectCache() const; virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); RooDataHist*RooAbsReal::fillDataHist(RooDataHist* hist, const RooArgSet* nset, Double_t scaleFactor, Bool_t correctForBinVolume = kFALSE, Bool_t showProgress = kFALSE) const; TH1*RooAbsReal::fillHistogram(TH1* hist, const RooArgList& plotVars, Double_t scaleFactor = 1, const RooArgSet* projectedVars = 0, Bool_t scaling = kTRUE, const RooArgSet* condObs = 0, Bool_t setError = kTRUE) const; Bool_tRooAbsArg::findConstantNodes(const RooArgSet& observables, RooArgSet& cacheList); Bool_tRooAbsArg::findConstantNodes(const RooArgSet& observables, RooArgSet& cacheList, RooLinkedList& processedNodes); RooAbsArg*RooAbsArg::findNewServer(const RooAbsCollection& newSet, Bool_t nameChange) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; Double_tRooAbsReal::findRoot(RooRealVar& x, Double_t xmin, Double_t xmax, Double_t yval); RooAbsArg*RooAbsArg::findServer(const char* name) const; RooAbsArg*RooAbsArg::findServer(const RooAbsArg& arg) const; RooAbsArg*RooAbsArg::findServer(Int_t index) const; virtual voidRooAbsReal::fixAddCoefNormalization(const RooArgSet& addNormSet = RooArgSet(), Bool_t force = kTRUE); virtual voidRooAbsReal::fixAddCoefRange(const char* rangeName = 0, Bool_t force = kTRUE); static UInt_tRooAbsArg::fnv1a32(const char* data); static UInt_tRooAbsArg::fnv1a32(const char* data, ULong_t sz, UInt_t hash = fnv1a32start); static ULong64_tRooAbsArg::fnv1a64(const char* data",MatchSource.WIKI,root/html602/RooAbsCachedReal.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsCachedReal.html
https://root.cern/root/html602/RooAbsCachedReal.html:11745,Performance,cache,cacheList,11745,"ggingMode(); virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); RooExpensiveObjectCache&RooAbsArg::expensiveObjectCache() const; virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); RooDataHist*RooAbsReal::fillDataHist(RooDataHist* hist, const RooArgSet* nset, Double_t scaleFactor, Bool_t correctForBinVolume = kFALSE, Bool_t showProgress = kFALSE) const; TH1*RooAbsReal::fillHistogram(TH1* hist, const RooArgList& plotVars, Double_t scaleFactor = 1, const RooArgSet* projectedVars = 0, Bool_t scaling = kTRUE, const RooArgSet* condObs = 0, Bool_t setError = kTRUE) const; Bool_tRooAbsArg::findConstantNodes(const RooArgSet& observables, RooArgSet& cacheList); Bool_tRooAbsArg::findConstantNodes(const RooArgSet& observables, RooArgSet& cacheList, RooLinkedList& processedNodes); RooAbsArg*RooAbsArg::findNewServer(const RooAbsCollection& newSet, Bool_t nameChange) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; Double_tRooAbsReal::findRoot(RooRealVar& x, Double_t xmin, Double_t xmax, Double_t yval); RooAbsArg*RooAbsArg::findServer(const char* name) const; RooAbsArg*RooAbsArg::findServer(const RooAbsArg& arg) const; RooAbsArg*RooAbsArg::findServer(Int_t index) const; virtual voidRooAbsReal::fixAddCoefNormalization(const RooArgSet& addNormSet = RooArgSet(), Bool_t force = kTRUE); virtual voidRooAbsReal::fixAddCoefRange(const char* rangeName = 0, Bool_t force = kTRUE); static UInt_tRooAbsArg::fnv1a32(const char* data); static UInt_tRooAbsArg::fnv1a32(const char* data, ULong_t sz, UInt_t hash = fnv1a32start); static ULong64_tRooAbsArg::fnv1a64(const char* data); static ULong64_tRooAbsArg::fnv1a64(const char* data, ULong_t sz, ULong64_t hash = fnv",MatchSource.WIKI,root/html602/RooAbsCachedReal.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsCachedReal.html
https://root.cern/root/html602/RooAbsCachedReal.html:20045,Performance,optimiz,optimizeCacheMode,20045,"rorItems(); static Int_tRooAbsReal::numEvalErrors(); Bool_tRooAbsArg::observableOverlaps(const RooAbsData* dset, const RooAbsArg& testArg) const; Bool_tRooAbsArg::observableOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; virtual Double_tRooAbsReal::offset() const; voidTObject::operator delete(void* ptr); voidTObject::operator delete(void* ptr, void* vp); voidTObject::operator delete[](void* ptr); voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); RooAbsCachedReal&operator=(const RooAbsCachedReal&); Bool_tRooAbsReal::operator==(Double_t value) const; virtual Bool_tRooAbsReal::operator==(const RooAbsArg& other); RooAbsArg::OperModeRooAbsArg::operMode() const; virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables); virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables, RooArgSet& optNodes, RooLinkedList& processedNodes); Bool_tRooAbsArg::overlaps(const RooAbsArg& testArg, Bool_t valueOnly = kFALSE) const; const RooArgSet*RooAbsArg::ownedComponents() const; virtual voidTObject::Paint(Option_t* option = """"); virtual RooPlot*RooAbsReal::plotOn(RooPlot* frame, RooLinkedList& cmdList) const; virtual RooPlot*RooAbsReal::plotOn(RooPlot* frame, const RooCmdArg& arg1 = RooCmdArg(), const RooCmdArg& arg2 = RooCmdArg(), const RooCmdArg& arg3 = RooCmdArg(), const RooCmdArg& arg4 = RooCmdArg(), const RooCmdArg& arg5 = RooCmdArg(), const RooCmdArg& arg6 = RooCmdArg(), const RooCmdArg& arg7 = RooCmdArg(), const RooCmdArg& arg8 = RooCmdArg(), const RooCmdArg& arg9 = RooCmdArg(), const RooCmdArg& arg10 = RooCmdArg()) const; virtual list<Double_t>*RooAbsReal::plotSamplingHint(RooAbsRealLValue&, Double_t, Double_t) const; virtual RooPlot*RooAbsReal::plotSliceO",MatchSource.WIKI,root/html602/RooAbsCachedReal.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsCachedReal.html
https://root.cern/root/html602/RooAbsCachedReal.html:20117,Performance,optimiz,optimizeCacheMode,20117,"servableOverlaps(const RooAbsData* dset, const RooAbsArg& testArg) const; Bool_tRooAbsArg::observableOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; virtual Double_tRooAbsReal::offset() const; voidTObject::operator delete(void* ptr); voidTObject::operator delete(void* ptr, void* vp); voidTObject::operator delete[](void* ptr); voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); RooAbsCachedReal&operator=(const RooAbsCachedReal&); Bool_tRooAbsReal::operator==(Double_t value) const; virtual Bool_tRooAbsReal::operator==(const RooAbsArg& other); RooAbsArg::OperModeRooAbsArg::operMode() const; virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables); virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables, RooArgSet& optNodes, RooLinkedList& processedNodes); Bool_tRooAbsArg::overlaps(const RooAbsArg& testArg, Bool_t valueOnly = kFALSE) const; const RooArgSet*RooAbsArg::ownedComponents() const; virtual voidTObject::Paint(Option_t* option = """"); virtual RooPlot*RooAbsReal::plotOn(RooPlot* frame, RooLinkedList& cmdList) const; virtual RooPlot*RooAbsReal::plotOn(RooPlot* frame, const RooCmdArg& arg1 = RooCmdArg(), const RooCmdArg& arg2 = RooCmdArg(), const RooCmdArg& arg3 = RooCmdArg(), const RooCmdArg& arg4 = RooCmdArg(), const RooCmdArg& arg5 = RooCmdArg(), const RooCmdArg& arg6 = RooCmdArg(), const RooCmdArg& arg7 = RooCmdArg(), const RooCmdArg& arg8 = RooCmdArg(), const RooCmdArg& arg9 = RooCmdArg(), const RooCmdArg& arg10 = RooCmdArg()) const; virtual list<Double_t>*RooAbsReal::plotSamplingHint(RooAbsRealLValue&, Double_t, Double_t) const; virtual RooPlot*RooAbsReal::plotSliceOn(RooPlot* frame, const RooArgSet& sliceSet, Option_t* drawOptions = ""L""",MatchSource.WIKI,root/html602/RooAbsCachedReal.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsCachedReal.html
https://root.cern/root/html602/RooAbsCachedReal.html:23591,Performance,cache,cache,23591,"rtual voidRooAbsArg::printTitle(ostream& os) const; virtual voidRooAbsArg::printTree(ostream& os, TString indent = """") const; virtual voidRooAbsReal::printValue(ostream& os) const; virtual Int_tTObject::Read(const char* name); virtual Bool_tRooAbsReal::readFromStream(istream& is, Bool_t compact, Bool_t verbose = kFALSE); Bool_tRooAbsArg::recursiveCheckDependents(const RooArgSet* nset) const; Bool_tRooAbsArg::recursiveCheckObservables(const RooArgSet* nset) const; Bool_tRooAbsArg::recursiveRedirectServers(const RooAbsCollection& newServerList, Bool_t mustReplaceAll = kFALSE, Bool_t nameChange = kFALSE, Bool_t recurseInNewSet = kTRUE); virtual voidTObject::RecursiveRemove(TObject* obj); Bool_tRooAbsArg::redirectServers(const RooAbsCollection& newServerList, Bool_t mustReplaceAll = kFALSE, Bool_t nameChange = kFALSE, Bool_t isRecursionStep = kFALSE); virtual Bool_tRooAbsArg::redirectServersHook(const RooAbsCollection&, Bool_t, Bool_t, Bool_t); voidRooAbsArg::registerCache(RooAbsCache& cache); voidRooAbsArg::removeServer(RooAbsArg& server, Bool_t force = kFALSE); voidRooAbsArg::replaceServer(RooAbsArg& oldServer, RooAbsArg& newServer, Bool_t valueProp, Bool_t shapeProp); voidTObject::ResetBit(UInt_t f); RooAbsCachedReal(); RooAbsCachedReal(const RooAbsCachedReal& other, const char* name = 0); RooAbsCachedReal(const char* name, const char* title, Int_t ipOrder = 0); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); virtual Bool_tselfNormalized() const; TIterator*RooAbsArg::serverIterator() const; RooFIterRooAbsArg::serverMIterator() const; virtual voidRooAbsArg::serverNameChangeHook(const RooAbsArg*, const RooAbsArg*); voidRooAbsArg::setAttribute(const Text_t* name, Bool_t value = kTRUE); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); virtual voidRooAbsArg::setCacheAndTrackHints(RooArgSet&); static voidRooAbsReal::setCacheCheck(Bool_",MatchSource.WIKI,root/html602/RooAbsCachedReal.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsCachedReal.html
https://root.cern/root/html602/RooAbsCachedReal.html:24979,Performance,cache,cache,24979,"ual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); virtual Bool_tselfNormalized() const; TIterator*RooAbsArg::serverIterator() const; RooFIterRooAbsArg::serverMIterator() const; virtual voidRooAbsArg::serverNameChangeHook(const RooAbsArg*, const RooAbsArg*); voidRooAbsArg::setAttribute(const Text_t* name, Bool_t value = kTRUE); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); virtual voidRooAbsArg::setCacheAndTrackHints(RooArgSet&); static voidRooAbsReal::setCacheCheck(Bool_t flag); virtual Bool_tRooAbsReal::setData(RooAbsData&, Bool_t = kTRUE); static voidRooAbsArg::setDirtyInhibit(Bool_t flag); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); static voidRooAbsReal::setEvalErrorLoggingMode(RooAbsReal::ErrorLoggingMode m); virtual voidRooAbsArg::setExpensiveObjectCache(RooExpensiveObjectCache& cache); static voidRooAbsReal::setHideOffset(Bool_t flag); voidRooAbsReal::setIntegratorConfig(); voidRooAbsReal::setIntegratorConfig(const RooNumIntConfig& config); voidsetInterpolationOrder(Int_t order); voidRooAbsArg::setLocalNoDirtyInhibit(Bool_t flag) const; virtual voidRooAbsArg::SetName(const char* name); virtual voidRooAbsArg::SetNameTitle(const char* name, const char* title); static voidTObject::SetObjectStat(Bool_t stat); voidRooAbsArg::setOperMode(RooAbsArg::OperMode mode, Bool_t recurseADirty = kTRUE); voidRooAbsReal::setParameterizeIntegral(const RooArgSet& paramVars); voidRooAbsReal::setPlotLabel(const char* label); voidRooAbsArg::setProhibitServerRedirect(Bool_t flag); voidRooAbsArg::setShapeDirty() const; voidRooAbsArg::setStringAttribute(const Text_t* key, const Text_t* value); virtual voidTNamed::SetTitle(const char* title = """")MENU ; voidRooAbsArg::setTransientAttribute(const Text_t* name, Bool_t value = kTRUE); virtual voidTObject::SetUniqueID(UInt_t uid); voidRooAbsRe",MatchSource.WIKI,root/html602/RooAbsCachedReal.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsCachedReal.html
https://root.cern/root/html602/RooAbsCachedReal.html:27114,Performance,cache,cache,27114,"voidRooAbsArg::setShapeDirty() const; voidRooAbsArg::setStringAttribute(const Text_t* key, const Text_t* value); virtual voidTNamed::SetTitle(const char* title = """")MENU ; voidRooAbsArg::setTransientAttribute(const Text_t* name, Bool_t value = kTRUE); virtual voidTObject::SetUniqueID(UInt_t uid); voidRooAbsReal::setUnit(const char* unit); voidRooAbsArg::setValueDirty() const; TIterator*RooAbsArg::shapeClientIterator() const; RooFIterRooAbsArg::shapeClientMIterator() const; virtual voidShowMembers(TMemberInspector& insp) const; RooAbsMoment*RooAbsReal::sigma(RooRealVar& obs); RooAbsMoment*RooAbsReal::sigma(RooRealVar& obs, const RooArgSet& nset); virtual Int_tTNamed::Sizeof() const; RooNumIntConfig*RooAbsReal::specialIntegratorConfig() const; RooNumIntConfig*RooAbsReal::specialIntegratorConfig(Bool_t createOnTheFly); virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); const map<string,string>&RooAbsArg::stringAttributes() const; virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; const set<string>&RooAbsArg::transientAttributes() const; voidRooAbsArg::treeNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t doBranch = kTRUE, Bool_t doLeaf = kTRUE, Bool_t valueOnly = kFALSE, Bool_t recurseNonDerived = kFALSE) const; voidRooAbsArg::unRegisterCache(RooAbsCache& cache); virtual voidTObject::UseCurrentStyle(); TIterator*RooAbsArg::valueClientIterator() const; RooFIterRooAbsArg::valueClientMIterator() const; static voidRooAbsArg::verboseDirty(Bool_t flag); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; voidRooAbsArg::wireAllCaches(); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const; virtual voidRooAbsReal::writeToStream(ostream& os, Bool_t compact) const.",MatchSource.WIKI,root/html602/RooAbsCachedReal.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsCachedReal.html
https://root.cern/root/html602/RooAbsCachedReal.html:28281,Performance,cache,cache,28281,,MatchSource.WIKI,root/html602/RooAbsCachedReal.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsCachedReal.html
https://root.cern/root/html602/RooAbsCachedReal.html:28837,Performance,cache,cache,28837,"Store(RooAbsDataStore& store); virtual voidRooAbsReal::attachToTree(TTree& t, Int_t bufSize = 32000); virtual voidRooAbsReal::attachToVStore(RooVectorDataStore& vstore); virtual const char*binningName() const; TStringcacheNameSuffix(const RooArgSet& nset) const; RooFitResult*RooAbsReal::chi2FitDriver(RooAbsReal& fcn, RooLinkedList& cmdList); TStringRooAbsArg::cleanBranchName() const; voidclearCacheObject(RooAbsCachedReal::FuncCacheElem& cache) const; virtual voidRooAbsReal::copyCache(const RooAbsArg* source, Bool_t valueOnly = kFALSE, Bool_t setValDirty = kTRUE); virtual RooAbsCachedReal::FuncCacheElem*createCache(const RooArgSet* nset) const; RooAbsReal*RooAbsReal::createIntObj(const RooArgSet& iset, const RooArgSet* nset, const RooNumIntConfig* cfg, const char* rangeName) const; virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; virtual Double_tRooAbsReal::evaluate() const; virtual voidfillCacheObject(RooAbsCachedReal::FuncCacheElem& cache) const; virtual voidRooAbsReal::fillTreeBranch(TTree& t); voidRooAbsReal::findInnerMostIntegration(const RooArgSet& allObs, RooArgSet& innerObs, const char* rangeName) const; RooAbsCachedReal::FuncCacheElem*getCache(const RooArgSet* nset) const; virtual voidRooAbsArg::getObservablesHook(const RooArgSet*, RooArgSet*) const; virtual voidRooAbsArg::getParametersHook(const RooArgSet*, RooArgSet*, Bool_t) const; RooAbsProxy*RooAbsArg::getProxy(Int_t index) const; static voidRooAbsReal::globalSelectComp(Bool_t flag); voidRooAbsArg::graphVizAddConnections(set<pair<RooAbsArg*,RooAbsArg*> >&); Bool_tRooAbsArg::inhibitDirty() const; virtual const char*inputBaseName() const; TStringRooAbsReal::integralNameSuffix(const RooArgSet& iset, const RooArgSet* nset = 0, const char* rangeName = 0, Bool_t omitEmpty = kFALSE) const; Bool_tRooAbsReal::isSelectedComp() const; virtual Bool_tRooAbsReal::isValid() const; virtual Bool_tRooAbsReal::isValidReal(Double_t value, Bool_t printError = kFALSE) const; v",MatchSource.WIKI,root/html602/RooAbsCachedReal.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsCachedReal.html
https://root.cern/root/html602/RooAbsCachedReal.html:30745,Performance,optimiz,optimizeDirtyHook,30745,"ual Bool_tRooAbsReal::isValidReal(Double_t value, Bool_t printError = kFALSE) const; voidRooAbsReal::makeProjectionSet(const RooAbsArg* plotVar, const RooArgSet* allVars, RooArgSet& projectedVars, Bool_t silent) const; voidTObject::MakeZombie(); Bool_tRooAbsReal::matchArgs(const RooArgSet& allDeps, RooArgSet& numDeps, const RooArgProxy& a) const; Bool_tRooAbsReal::matchArgs(const RooArgSet& allDeps, RooArgSet& numDeps, const RooArgSet& set) const; Bool_tRooAbsReal::matchArgs(const RooArgSet& allDeps, RooArgSet& numDeps, const RooArgProxy& a, const RooArgProxy& b) const; Bool_tRooAbsReal::matchArgs(const RooArgSet& allDeps, RooArgSet& numDeps, const RooArgProxy& a, const RooArgProxy& b, const RooArgProxy& c) const; Bool_tRooAbsReal::matchArgs(const RooArgSet& allDeps, RooArgSet& numDeps, const RooArgProxy& a, const RooArgProxy& b, const RooArgProxy& c, const RooArgProxy& d) const; Int_tRooAbsArg::numProxies() const; virtual voidRooAbsArg::operModeHook(); virtual voidRooAbsArg::optimizeDirtyHook(const RooArgSet*); virtual const char*payloadUniqueSuffix() const; virtual RooPlot*RooAbsReal::plotAsymOn(RooPlot* frame, const RooAbsCategoryLValue& asymCat, RooAbsReal::PlotOpt o) const; virtual RooPlot*RooAbsReal::plotOn(RooPlot* frame, RooAbsReal::PlotOpt o) const; voidRooAbsReal::plotOnCompSelect(RooArgSet* selNodes) const; RooPlot*RooAbsReal::plotOnWithErrorBand(RooPlot* frame, const RooFitResult& fr, Double_t Z, const RooArgSet* params, const RooLinkedList& argList, Bool_t method1) const; Bool_tRooAbsReal::plotSanityChecks(RooPlot* frame) const; voidRooAbsArg::printAttribList(ostream& os) const; voidRooAbsArg::registerProxy(RooArgProxy& proxy); voidRooAbsArg::registerProxy(RooSetProxy& proxy); voidRooAbsArg::registerProxy(RooListProxy& proxy); voidRooAbsReal::selectComp(Bool_t flag); virtual voidRooAbsReal::selectNormalization(const RooArgSet* depSet = 0, Bool_t force = kFALSE); virtual voidRooAbsReal::selectNormalizationRange(const char* rangeName = 0, Bool_t force = k",MatchSource.WIKI,root/html602/RooAbsCachedReal.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsCachedReal.html
https://root.cern/root/html602/RooAbsCachedReal.html:35352,Performance,cache,cache,35352,,MatchSource.WIKI,root/html602/RooAbsCachedReal.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsCachedReal.html
https://root.cern/root/html602/RooAbsCachedReal.html:35435,Performance,cache,cache,35435,,MatchSource.WIKI,root/html602/RooAbsCachedReal.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsCachedReal.html
https://root.cern/root/html602/RooAbsCachedReal.html:35633,Performance,cache,caches,35633,,MatchSource.WIKI,root/html602/RooAbsCachedReal.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsCachedReal.html
https://root.cern/root/html602/RooAbsCachedReal.html:35674,Performance,cache,cache,35674,,MatchSource.WIKI,root/html602/RooAbsCachedReal.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsCachedReal.html
https://root.cern/root/html602/RooAbsCachedReal.html:36213,Performance,cache,cache,36213,"tes; set<string>RooAbsArg::_boolAttribTransient! Transient boolean attributes (not copied in ctor); Bool_tRooAbsReal::_boolValue! Transient cache for bool values from tree branches; UChar_tRooAbsReal::_byteValue! Transient cache for byte values from tree branches; static Bool_tRooAbsReal::_cacheCheckIf true, always validate contents of clean which outcome of evaluate(); deque<RooAbsCache*>RooAbsArg::_cacheListlist of caches; RooObjCacheManager_cacheMgr! The cache manager; RooRefCountListRooAbsArg::_clientListlist of client objects; RooRefCountListRooAbsArg::_clientListShapesubset of clients that requested shape dirty flag propagation; RooRefCountListRooAbsArg::_clientListValuesubset of clients that requested value dirty flag propagation; TIterator*RooAbsArg::_clientShapeIter! Iterator over _clientListShape; TIterator*RooAbsArg::_clientValueIter! Iterator over _clientListValue; Bool_tRooAbsArg::_deleteWatch! Delete watch flag; RooExpensiveObjectCache*RooAbsArg::_eocachePointer to global cache manager for any expensive components created by this object; Bool_tRooAbsArg::_fastAllow fast access mode in getVal() and proxies; Float_tRooAbsReal::_floatValue! Transient cache for floating point values from tree branches; Bool_tRooAbsReal::_forceNumIntForce numerical integration if flag set; static Bool_tRooAbsReal::_globalSelectCompGlobal activation switch for component selection; static Bool_tRooAbsReal::_hideOffsetOffset hiding flag; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; Int_tRooAbsReal::_intValue! Transient cache for integer values from tree branches; Int_t_ipOrderInterpolation order for cache histograms; Bool_tRooAbsArg::_isConstant! Cached isConstant status; TStringRooAbsReal::_labelPlot label for objects value; RooArgSet*RooAbsReal::_lastNSet!; Bool_tRooAbsArg::_localNoInhibitDirty! Prevent 'AlwaysDirty' mode for this node; static Int_tRooPrintable::_nameLength; TNamed*RooAbsArg::_namePtr! Do not persist.",MatchSource.WIKI,root/html602/RooAbsCachedReal.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsCachedReal.html
https://root.cern/root/html602/RooAbsCachedReal.html:36392,Performance,cache,cache,36392,"tes; set<string>RooAbsArg::_boolAttribTransient! Transient boolean attributes (not copied in ctor); Bool_tRooAbsReal::_boolValue! Transient cache for bool values from tree branches; UChar_tRooAbsReal::_byteValue! Transient cache for byte values from tree branches; static Bool_tRooAbsReal::_cacheCheckIf true, always validate contents of clean which outcome of evaluate(); deque<RooAbsCache*>RooAbsArg::_cacheListlist of caches; RooObjCacheManager_cacheMgr! The cache manager; RooRefCountListRooAbsArg::_clientListlist of client objects; RooRefCountListRooAbsArg::_clientListShapesubset of clients that requested shape dirty flag propagation; RooRefCountListRooAbsArg::_clientListValuesubset of clients that requested value dirty flag propagation; TIterator*RooAbsArg::_clientShapeIter! Iterator over _clientListShape; TIterator*RooAbsArg::_clientValueIter! Iterator over _clientListValue; Bool_tRooAbsArg::_deleteWatch! Delete watch flag; RooExpensiveObjectCache*RooAbsArg::_eocachePointer to global cache manager for any expensive components created by this object; Bool_tRooAbsArg::_fastAllow fast access mode in getVal() and proxies; Float_tRooAbsReal::_floatValue! Transient cache for floating point values from tree branches; Bool_tRooAbsReal::_forceNumIntForce numerical integration if flag set; static Bool_tRooAbsReal::_globalSelectCompGlobal activation switch for component selection; static Bool_tRooAbsReal::_hideOffsetOffset hiding flag; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; Int_tRooAbsReal::_intValue! Transient cache for integer values from tree branches; Int_t_ipOrderInterpolation order for cache histograms; Bool_tRooAbsArg::_isConstant! Cached isConstant status; TStringRooAbsReal::_labelPlot label for objects value; RooArgSet*RooAbsReal::_lastNSet!; Bool_tRooAbsArg::_localNoInhibitDirty! Prevent 'AlwaysDirty' mode for this node; static Int_tRooPrintable::_nameLength; TNamed*RooAbsArg::_namePtr! Do not persist.",MatchSource.WIKI,root/html602/RooAbsCachedReal.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsCachedReal.html
https://root.cern/root/html602/RooAbsCachedReal.html:36805,Performance,cache,cache,36805,"tes; set<string>RooAbsArg::_boolAttribTransient! Transient boolean attributes (not copied in ctor); Bool_tRooAbsReal::_boolValue! Transient cache for bool values from tree branches; UChar_tRooAbsReal::_byteValue! Transient cache for byte values from tree branches; static Bool_tRooAbsReal::_cacheCheckIf true, always validate contents of clean which outcome of evaluate(); deque<RooAbsCache*>RooAbsArg::_cacheListlist of caches; RooObjCacheManager_cacheMgr! The cache manager; RooRefCountListRooAbsArg::_clientListlist of client objects; RooRefCountListRooAbsArg::_clientListShapesubset of clients that requested shape dirty flag propagation; RooRefCountListRooAbsArg::_clientListValuesubset of clients that requested value dirty flag propagation; TIterator*RooAbsArg::_clientShapeIter! Iterator over _clientListShape; TIterator*RooAbsArg::_clientValueIter! Iterator over _clientListValue; Bool_tRooAbsArg::_deleteWatch! Delete watch flag; RooExpensiveObjectCache*RooAbsArg::_eocachePointer to global cache manager for any expensive components created by this object; Bool_tRooAbsArg::_fastAllow fast access mode in getVal() and proxies; Float_tRooAbsReal::_floatValue! Transient cache for floating point values from tree branches; Bool_tRooAbsReal::_forceNumIntForce numerical integration if flag set; static Bool_tRooAbsReal::_globalSelectCompGlobal activation switch for component selection; static Bool_tRooAbsReal::_hideOffsetOffset hiding flag; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; Int_tRooAbsReal::_intValue! Transient cache for integer values from tree branches; Int_t_ipOrderInterpolation order for cache histograms; Bool_tRooAbsArg::_isConstant! Cached isConstant status; TStringRooAbsReal::_labelPlot label for objects value; RooArgSet*RooAbsReal::_lastNSet!; Bool_tRooAbsArg::_localNoInhibitDirty! Prevent 'AlwaysDirty' mode for this node; static Int_tRooPrintable::_nameLength; TNamed*RooAbsArg::_namePtr! Do not persist.",MatchSource.WIKI,root/html602/RooAbsCachedReal.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsCachedReal.html
https://root.cern/root/html602/RooAbsCachedReal.html:36887,Performance,cache,cache,36887,"tes; set<string>RooAbsArg::_boolAttribTransient! Transient boolean attributes (not copied in ctor); Bool_tRooAbsReal::_boolValue! Transient cache for bool values from tree branches; UChar_tRooAbsReal::_byteValue! Transient cache for byte values from tree branches; static Bool_tRooAbsReal::_cacheCheckIf true, always validate contents of clean which outcome of evaluate(); deque<RooAbsCache*>RooAbsArg::_cacheListlist of caches; RooObjCacheManager_cacheMgr! The cache manager; RooRefCountListRooAbsArg::_clientListlist of client objects; RooRefCountListRooAbsArg::_clientListShapesubset of clients that requested shape dirty flag propagation; RooRefCountListRooAbsArg::_clientListValuesubset of clients that requested value dirty flag propagation; TIterator*RooAbsArg::_clientShapeIter! Iterator over _clientListShape; TIterator*RooAbsArg::_clientValueIter! Iterator over _clientListValue; Bool_tRooAbsArg::_deleteWatch! Delete watch flag; RooExpensiveObjectCache*RooAbsArg::_eocachePointer to global cache manager for any expensive components created by this object; Bool_tRooAbsArg::_fastAllow fast access mode in getVal() and proxies; Float_tRooAbsReal::_floatValue! Transient cache for floating point values from tree branches; Bool_tRooAbsReal::_forceNumIntForce numerical integration if flag set; static Bool_tRooAbsReal::_globalSelectCompGlobal activation switch for component selection; static Bool_tRooAbsReal::_hideOffsetOffset hiding flag; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; Int_tRooAbsReal::_intValue! Transient cache for integer values from tree branches; Int_t_ipOrderInterpolation order for cache histograms; Bool_tRooAbsArg::_isConstant! Cached isConstant status; TStringRooAbsReal::_labelPlot label for objects value; RooArgSet*RooAbsReal::_lastNSet!; Bool_tRooAbsArg::_localNoInhibitDirty! Prevent 'AlwaysDirty' mode for this node; static Int_tRooPrintable::_nameLength; TNamed*RooAbsArg::_namePtr! Do not persist.",MatchSource.WIKI,root/html602/RooAbsCachedReal.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsCachedReal.html
https://root.cern/root/html602/RooAbsCachedReal.html:37736,Performance,cache,cache,37736,"ringRooAbsReal::_labelPlot label for objects value; RooArgSet*RooAbsReal::_lastNSet!; Bool_tRooAbsArg::_localNoInhibitDirty! Prevent 'AlwaysDirty' mode for this node; static Int_tRooPrintable::_nameLength; TNamed*RooAbsArg::_namePtr! Do not persist. Pointer to global instance of string that matches object named; RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; Int_tRooAbsReal::_plotBinsNumber of plot bins; Double_tRooAbsReal::_plotMaxMaximum of plot range; Double_tRooAbsReal::_plotMinMinimum of plot range; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; RooRefArrayRooAbsArg::_proxyListlist of proxies; Char_tRooAbsReal::_sbyteValue! Transient cache for signed byte values from tree branches; Bool_tRooAbsReal::_selectComp! Component selection flag for RooAbsPdf::plotCompOn; RooRefCountListRooAbsArg::_serverListlist of server objects; Bool_tRooAbsArg::_shapeDirtyFlag set if value needs recalculating because input shapes modified; RooNumIntConfig*RooAbsReal::_specIntegratorConfigNumeric integrator configuration specific for this object; map<string,string>RooAbsArg::_stringAttribString attributes; Bool_tRooAbsReal::_treeVar!do not persist; UInt_tRooAbsReal::_uintValue! Transient cache for unsigned integer values from tree branches; TStringRooAbsReal::_unitUnit for objects value; Double_tRooAbsReal::_valueCache for current value of object; Bool_tRooAbsArg::_valueDirtyFlag set if value needs recalculating because input values modified; static Bool_tRooAbsArg::_verboseDirtyStatic flag controlling verbose messaging for dirty state changes; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title. private:. Bool_t_disableCacheFlag to run object in passthrough (= non-caching mode). Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; RooAbsCachedReal(const char* name, const char* title, Int_t ipOrder = 0)",MatchSource.WIKI,root/html602/RooAbsCachedReal.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsCachedReal.html
https://root.cern/root/html602/RooAbsCachedReal.html:38278,Performance,cache,cache,38278,"ringRooAbsReal::_labelPlot label for objects value; RooArgSet*RooAbsReal::_lastNSet!; Bool_tRooAbsArg::_localNoInhibitDirty! Prevent 'AlwaysDirty' mode for this node; static Int_tRooPrintable::_nameLength; TNamed*RooAbsArg::_namePtr! Do not persist. Pointer to global instance of string that matches object named; RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; Int_tRooAbsReal::_plotBinsNumber of plot bins; Double_tRooAbsReal::_plotMaxMaximum of plot range; Double_tRooAbsReal::_plotMinMinimum of plot range; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; RooRefArrayRooAbsArg::_proxyListlist of proxies; Char_tRooAbsReal::_sbyteValue! Transient cache for signed byte values from tree branches; Bool_tRooAbsReal::_selectComp! Component selection flag for RooAbsPdf::plotCompOn; RooRefCountListRooAbsArg::_serverListlist of server objects; Bool_tRooAbsArg::_shapeDirtyFlag set if value needs recalculating because input shapes modified; RooNumIntConfig*RooAbsReal::_specIntegratorConfigNumeric integrator configuration specific for this object; map<string,string>RooAbsArg::_stringAttribString attributes; Bool_tRooAbsReal::_treeVar!do not persist; UInt_tRooAbsReal::_uintValue! Transient cache for unsigned integer values from tree branches; TStringRooAbsReal::_unitUnit for objects value; Double_tRooAbsReal::_valueCache for current value of object; Bool_tRooAbsArg::_valueDirtyFlag set if value needs recalculating because input values modified; static Bool_tRooAbsArg::_verboseDirtyStatic flag controlling verbose messaging for dirty state changes; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title. private:. Bool_t_disableCacheFlag to run object in passthrough (= non-caching mode). Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; RooAbsCachedReal(const char* name, const char* title, Int_t ipOrder = 0)",MatchSource.WIKI,root/html602/RooAbsCachedReal.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsCachedReal.html
https://root.cern/root/html602/RooAbsCachedReal.html:39251,Performance,cache,cache,39251,"tRooAbsReal::_uintValue! Transient cache for unsigned integer values from tree branches; TStringRooAbsReal::_unitUnit for objects value; Double_tRooAbsReal::_valueCache for current value of object; Bool_tRooAbsArg::_valueDirtyFlag set if value needs recalculating because input values modified; static Bool_tRooAbsArg::_verboseDirtyStatic flag controlling verbose messaging for dirty state changes; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title. private:. Bool_t_disableCacheFlag to run object in passthrough (= non-caching mode). Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; RooAbsCachedReal(const char* name, const char* title, Int_t ipOrder = 0); Constructor. RooAbsCachedReal(const RooAbsCachedReal& other, const char* name = 0); Copy constructor. ~RooAbsCachedReal(); Destructor. Double_t getValV(const RooArgSet* set = 0) const; Implementation of getVal() overriding default implementation; of RooAbsReal. Return value stored in cache p.d.f; rather than return value of evaluate() which is undefined; for RooAbsCachedReal. void clearCacheObject(RooAbsCachedReal::FuncCacheElem& cache) const; Mark all bins as unitialized (value -1). TString cacheNameSuffix(const RooArgSet& nset) const; Construct unique suffix name for cache p.d.f object. void setInterpolationOrder(Int_t order); Set interpolation order of RooHistFunct representing cache histogram. Int_t getAnalyticalIntegralWN(RooArgSet& allVars, RooArgSet& analVars, const RooArgSet* normSet, const char* rangeName = 0) const; Return analytical integration capabilities of the RooHistFunc that corresponds to the set of observables in allVars. Double_t analyticalIntegralWN(Int_t code, const RooArgSet* normSet, const char* rangeName = 0) const; Forward call to implementation in relevant RooHistFunc instance. RooAbsCachedReal(); {}. Bool_t selfNormalized() const; Declares function self normalized. Int_t getInterpolationOrder() const; Set interpolation order in R",MatchSource.WIKI,root/html602/RooAbsCachedReal.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsCachedReal.html
https://root.cern/root/html602/RooAbsCachedReal.html:39400,Performance,cache,cache,39400,":_valueCache for current value of object; Bool_tRooAbsArg::_valueDirtyFlag set if value needs recalculating because input values modified; static Bool_tRooAbsArg::_verboseDirtyStatic flag controlling verbose messaging for dirty state changes; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title. private:. Bool_t_disableCacheFlag to run object in passthrough (= non-caching mode). Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; RooAbsCachedReal(const char* name, const char* title, Int_t ipOrder = 0); Constructor. RooAbsCachedReal(const RooAbsCachedReal& other, const char* name = 0); Copy constructor. ~RooAbsCachedReal(); Destructor. Double_t getValV(const RooArgSet* set = 0) const; Implementation of getVal() overriding default implementation; of RooAbsReal. Return value stored in cache p.d.f; rather than return value of evaluate() which is undefined; for RooAbsCachedReal. void clearCacheObject(RooAbsCachedReal::FuncCacheElem& cache) const; Mark all bins as unitialized (value -1). TString cacheNameSuffix(const RooArgSet& nset) const; Construct unique suffix name for cache p.d.f object. void setInterpolationOrder(Int_t order); Set interpolation order of RooHistFunct representing cache histogram. Int_t getAnalyticalIntegralWN(RooArgSet& allVars, RooArgSet& analVars, const RooArgSet* normSet, const char* rangeName = 0) const; Return analytical integration capabilities of the RooHistFunc that corresponds to the set of observables in allVars. Double_t analyticalIntegralWN(Int_t code, const RooArgSet* normSet, const char* rangeName = 0) const; Forward call to implementation in relevant RooHistFunc instance. RooAbsCachedReal(); {}. Bool_t selfNormalized() const; Declares function self normalized. Int_t getInterpolationOrder() const; Set interpolation order in RooHistFuncs that represent cache histograms. Bool_t forceAnalyticalInt(const RooAbsArg& ) const; Force all observables to be offered for internal integratio",MatchSource.WIKI,root/html602/RooAbsCachedReal.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsCachedReal.html
https://root.cern/root/html602/RooAbsCachedReal.html:39463,Performance,cache,cacheNameSuffix,39463,"ting because input values modified; static Bool_tRooAbsArg::_verboseDirtyStatic flag controlling verbose messaging for dirty state changes; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title. private:. Bool_t_disableCacheFlag to run object in passthrough (= non-caching mode). Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; RooAbsCachedReal(const char* name, const char* title, Int_t ipOrder = 0); Constructor. RooAbsCachedReal(const RooAbsCachedReal& other, const char* name = 0); Copy constructor. ~RooAbsCachedReal(); Destructor. Double_t getValV(const RooArgSet* set = 0) const; Implementation of getVal() overriding default implementation; of RooAbsReal. Return value stored in cache p.d.f; rather than return value of evaluate() which is undefined; for RooAbsCachedReal. void clearCacheObject(RooAbsCachedReal::FuncCacheElem& cache) const; Mark all bins as unitialized (value -1). TString cacheNameSuffix(const RooArgSet& nset) const; Construct unique suffix name for cache p.d.f object. void setInterpolationOrder(Int_t order); Set interpolation order of RooHistFunct representing cache histogram. Int_t getAnalyticalIntegralWN(RooArgSet& allVars, RooArgSet& analVars, const RooArgSet* normSet, const char* rangeName = 0) const; Return analytical integration capabilities of the RooHistFunc that corresponds to the set of observables in allVars. Double_t analyticalIntegralWN(Int_t code, const RooArgSet* normSet, const char* rangeName = 0) const; Forward call to implementation in relevant RooHistFunc instance. RooAbsCachedReal(); {}. Bool_t selfNormalized() const; Declares function self normalized. Int_t getInterpolationOrder() const; Set interpolation order in RooHistFuncs that represent cache histograms. Bool_t forceAnalyticalInt(const RooAbsArg& ) const; Force all observables to be offered for internal integration. void disableCache(Bool_t flag); Switch to disable caching mechanism. FuncCacheElem* getCache(const R",MatchSource.WIKI,root/html602/RooAbsCachedReal.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsCachedReal.html
https://root.cern/root/html602/RooAbsCachedReal.html:39542,Performance,cache,cache,39542,"ting because input values modified; static Bool_tRooAbsArg::_verboseDirtyStatic flag controlling verbose messaging for dirty state changes; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title. private:. Bool_t_disableCacheFlag to run object in passthrough (= non-caching mode). Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; RooAbsCachedReal(const char* name, const char* title, Int_t ipOrder = 0); Constructor. RooAbsCachedReal(const RooAbsCachedReal& other, const char* name = 0); Copy constructor. ~RooAbsCachedReal(); Destructor. Double_t getValV(const RooArgSet* set = 0) const; Implementation of getVal() overriding default implementation; of RooAbsReal. Return value stored in cache p.d.f; rather than return value of evaluate() which is undefined; for RooAbsCachedReal. void clearCacheObject(RooAbsCachedReal::FuncCacheElem& cache) const; Mark all bins as unitialized (value -1). TString cacheNameSuffix(const RooArgSet& nset) const; Construct unique suffix name for cache p.d.f object. void setInterpolationOrder(Int_t order); Set interpolation order of RooHistFunct representing cache histogram. Int_t getAnalyticalIntegralWN(RooArgSet& allVars, RooArgSet& analVars, const RooArgSet* normSet, const char* rangeName = 0) const; Return analytical integration capabilities of the RooHistFunc that corresponds to the set of observables in allVars. Double_t analyticalIntegralWN(Int_t code, const RooArgSet* normSet, const char* rangeName = 0) const; Forward call to implementation in relevant RooHistFunc instance. RooAbsCachedReal(); {}. Bool_t selfNormalized() const; Declares function self normalized. Int_t getInterpolationOrder() const; Set interpolation order in RooHistFuncs that represent cache histograms. Bool_t forceAnalyticalInt(const RooAbsArg& ) const; Force all observables to be offered for internal integration. void disableCache(Bool_t flag); Switch to disable caching mechanism. FuncCacheElem* getCache(const R",MatchSource.WIKI,root/html602/RooAbsCachedReal.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsCachedReal.html
https://root.cern/root/html602/RooAbsCachedReal.html:39656,Performance,cache,cache,39656," for dirty state changes; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title. private:. Bool_t_disableCacheFlag to run object in passthrough (= non-caching mode). Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; RooAbsCachedReal(const char* name, const char* title, Int_t ipOrder = 0); Constructor. RooAbsCachedReal(const RooAbsCachedReal& other, const char* name = 0); Copy constructor. ~RooAbsCachedReal(); Destructor. Double_t getValV(const RooArgSet* set = 0) const; Implementation of getVal() overriding default implementation; of RooAbsReal. Return value stored in cache p.d.f; rather than return value of evaluate() which is undefined; for RooAbsCachedReal. void clearCacheObject(RooAbsCachedReal::FuncCacheElem& cache) const; Mark all bins as unitialized (value -1). TString cacheNameSuffix(const RooArgSet& nset) const; Construct unique suffix name for cache p.d.f object. void setInterpolationOrder(Int_t order); Set interpolation order of RooHistFunct representing cache histogram. Int_t getAnalyticalIntegralWN(RooArgSet& allVars, RooArgSet& analVars, const RooArgSet* normSet, const char* rangeName = 0) const; Return analytical integration capabilities of the RooHistFunc that corresponds to the set of observables in allVars. Double_t analyticalIntegralWN(Int_t code, const RooArgSet* normSet, const char* rangeName = 0) const; Forward call to implementation in relevant RooHistFunc instance. RooAbsCachedReal(); {}. Bool_t selfNormalized() const; Declares function self normalized. Int_t getInterpolationOrder() const; Set interpolation order in RooHistFuncs that represent cache histograms. Bool_t forceAnalyticalInt(const RooAbsArg& ) const; Force all observables to be offered for internal integration. void disableCache(Bool_t flag); Switch to disable caching mechanism. FuncCacheElem* getCache(const RooArgSet* nset) const. const char* payloadUniqueSuffix() const; { return 0 ; }. const char* binningName() const; Re",MatchSource.WIKI,root/html602/RooAbsCachedReal.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsCachedReal.html
https://root.cern/root/html602/RooAbsCachedReal.html:40270,Performance,cache,cache,40270,"default implementation; of RooAbsReal. Return value stored in cache p.d.f; rather than return value of evaluate() which is undefined; for RooAbsCachedReal. void clearCacheObject(RooAbsCachedReal::FuncCacheElem& cache) const; Mark all bins as unitialized (value -1). TString cacheNameSuffix(const RooArgSet& nset) const; Construct unique suffix name for cache p.d.f object. void setInterpolationOrder(Int_t order); Set interpolation order of RooHistFunct representing cache histogram. Int_t getAnalyticalIntegralWN(RooArgSet& allVars, RooArgSet& analVars, const RooArgSet* normSet, const char* rangeName = 0) const; Return analytical integration capabilities of the RooHistFunc that corresponds to the set of observables in allVars. Double_t analyticalIntegralWN(Int_t code, const RooArgSet* normSet, const char* rangeName = 0) const; Forward call to implementation in relevant RooHistFunc instance. RooAbsCachedReal(); {}. Bool_t selfNormalized() const; Declares function self normalized. Int_t getInterpolationOrder() const; Set interpolation order in RooHistFuncs that represent cache histograms. Bool_t forceAnalyticalInt(const RooAbsArg& ) const; Force all observables to be offered for internal integration. void disableCache(Bool_t flag); Switch to disable caching mechanism. FuncCacheElem* getCache(const RooArgSet* nset) const. const char* payloadUniqueSuffix() const; { return 0 ; }. const char* binningName() const; Returns name of binning to be used for cache histogram creation. FuncCacheElem* createCache(const RooArgSet* nset) const. const char* inputBaseName() const. RooArgSet* actualObservables(const RooArgSet& nset) const. RooArgSet* actualParameters(const RooArgSet& nset) const. void fillCacheObject(RooAbsCachedReal::FuncCacheElem& cache) const. » Last changed: Tue Jun 30 14:29:58 2015 » Last generated: 2015-06-30 14:29; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html602/RooAbsCachedReal.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsCachedReal.html
https://root.cern/root/html602/RooAbsCachedReal.html:40654,Performance,cache,cache,40654,"default implementation; of RooAbsReal. Return value stored in cache p.d.f; rather than return value of evaluate() which is undefined; for RooAbsCachedReal. void clearCacheObject(RooAbsCachedReal::FuncCacheElem& cache) const; Mark all bins as unitialized (value -1). TString cacheNameSuffix(const RooArgSet& nset) const; Construct unique suffix name for cache p.d.f object. void setInterpolationOrder(Int_t order); Set interpolation order of RooHistFunct representing cache histogram. Int_t getAnalyticalIntegralWN(RooArgSet& allVars, RooArgSet& analVars, const RooArgSet* normSet, const char* rangeName = 0) const; Return analytical integration capabilities of the RooHistFunc that corresponds to the set of observables in allVars. Double_t analyticalIntegralWN(Int_t code, const RooArgSet* normSet, const char* rangeName = 0) const; Forward call to implementation in relevant RooHistFunc instance. RooAbsCachedReal(); {}. Bool_t selfNormalized() const; Declares function self normalized. Int_t getInterpolationOrder() const; Set interpolation order in RooHistFuncs that represent cache histograms. Bool_t forceAnalyticalInt(const RooAbsArg& ) const; Force all observables to be offered for internal integration. void disableCache(Bool_t flag); Switch to disable caching mechanism. FuncCacheElem* getCache(const RooArgSet* nset) const. const char* payloadUniqueSuffix() const; { return 0 ; }. const char* binningName() const; Returns name of binning to be used for cache histogram creation. FuncCacheElem* createCache(const RooArgSet* nset) const. const char* inputBaseName() const. RooArgSet* actualObservables(const RooArgSet& nset) const. RooArgSet* actualParameters(const RooArgSet& nset) const. void fillCacheObject(RooAbsCachedReal::FuncCacheElem& cache) const. » Last changed: Tue Jun 30 14:29:58 2015 » Last generated: 2015-06-30 14:29; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html602/RooAbsCachedReal.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsCachedReal.html
https://root.cern/root/html602/RooAbsCachedReal.html:40943,Performance,cache,cache,40943,"default implementation; of RooAbsReal. Return value stored in cache p.d.f; rather than return value of evaluate() which is undefined; for RooAbsCachedReal. void clearCacheObject(RooAbsCachedReal::FuncCacheElem& cache) const; Mark all bins as unitialized (value -1). TString cacheNameSuffix(const RooArgSet& nset) const; Construct unique suffix name for cache p.d.f object. void setInterpolationOrder(Int_t order); Set interpolation order of RooHistFunct representing cache histogram. Int_t getAnalyticalIntegralWN(RooArgSet& allVars, RooArgSet& analVars, const RooArgSet* normSet, const char* rangeName = 0) const; Return analytical integration capabilities of the RooHistFunc that corresponds to the set of observables in allVars. Double_t analyticalIntegralWN(Int_t code, const RooArgSet* normSet, const char* rangeName = 0) const; Forward call to implementation in relevant RooHistFunc instance. RooAbsCachedReal(); {}. Bool_t selfNormalized() const; Declares function self normalized. Int_t getInterpolationOrder() const; Set interpolation order in RooHistFuncs that represent cache histograms. Bool_t forceAnalyticalInt(const RooAbsArg& ) const; Force all observables to be offered for internal integration. void disableCache(Bool_t flag); Switch to disable caching mechanism. FuncCacheElem* getCache(const RooArgSet* nset) const. const char* payloadUniqueSuffix() const; { return 0 ; }. const char* binningName() const; Returns name of binning to be used for cache histogram creation. FuncCacheElem* createCache(const RooArgSet* nset) const. const char* inputBaseName() const. RooArgSet* actualObservables(const RooArgSet& nset) const. RooArgSet* actualParameters(const RooArgSet& nset) const. void fillCacheObject(RooAbsCachedReal::FuncCacheElem& cache) const. » Last changed: Tue Jun 30 14:29:58 2015 » Last generated: 2015-06-30 14:29; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html602/RooAbsCachedReal.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsCachedReal.html
https://root.cern/root/html602/RooAbsCachedReal.html:12589,Security,hash,hash,12589,"bsArg::findConstantNodes(const RooArgSet& observables, RooArgSet& cacheList); Bool_tRooAbsArg::findConstantNodes(const RooArgSet& observables, RooArgSet& cacheList, RooLinkedList& processedNodes); RooAbsArg*RooAbsArg::findNewServer(const RooAbsCollection& newSet, Bool_t nameChange) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; Double_tRooAbsReal::findRoot(RooRealVar& x, Double_t xmin, Double_t xmax, Double_t yval); RooAbsArg*RooAbsArg::findServer(const char* name) const; RooAbsArg*RooAbsArg::findServer(const RooAbsArg& arg) const; RooAbsArg*RooAbsArg::findServer(Int_t index) const; virtual voidRooAbsReal::fixAddCoefNormalization(const RooArgSet& addNormSet = RooArgSet(), Bool_t force = kTRUE); virtual voidRooAbsReal::fixAddCoefRange(const char* rangeName = 0, Bool_t force = kTRUE); static UInt_tRooAbsArg::fnv1a32(const char* data); static UInt_tRooAbsArg::fnv1a32(const char* data, ULong_t sz, UInt_t hash = fnv1a32start); static ULong64_tRooAbsArg::fnv1a64(const char* data); static ULong64_tRooAbsArg::fnv1a64(const char* data, ULong_t sz, ULong64_t hash = fnv1a64start); virtual Bool_tforceAnalyticalInt(const RooAbsArg&) const; virtual voidRooAbsReal::forceNumInt(Bool_t flag = kTRUE); RooFunctor*RooAbsReal::functor(const RooArgList& obs, const RooArgList& pars = RooArgList(), const RooArgSet& nset = RooArgSet()) const; virtual Int_tRooAbsReal::getAnalyticalIntegral(RooArgSet& allVars, RooArgSet& analVars, const char* rangeName = 0) const; virtual Int_tgetAnalyticalIntegralWN(RooArgSet& allVars, RooArgSet& analVars, const RooArgSet* normSet, const char* rangeName = 0) const; Bool_tRooAbsArg::getAttribute(const Text_t* name) const; RooLinkedListRooAbsArg::getCloningAncestors() const; RooArgSet*RooAbsArg::getComponents() const; RooArgSet*RooAbsArg::getDependents(const RooArgSet& set) const; RooArgSet*RooAbsArg::getDependents(const RooAbsData* set) const; RooArgSet*RooAbsArg::getDependents",MatchSource.WIKI,root/html602/RooAbsCachedReal.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsCachedReal.html
https://root.cern/root/html602/RooAbsCachedReal.html:12740,Security,hash,hash,12740,"t& cacheList, RooLinkedList& processedNodes); RooAbsArg*RooAbsArg::findNewServer(const RooAbsCollection& newSet, Bool_t nameChange) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; Double_tRooAbsReal::findRoot(RooRealVar& x, Double_t xmin, Double_t xmax, Double_t yval); RooAbsArg*RooAbsArg::findServer(const char* name) const; RooAbsArg*RooAbsArg::findServer(const RooAbsArg& arg) const; RooAbsArg*RooAbsArg::findServer(Int_t index) const; virtual voidRooAbsReal::fixAddCoefNormalization(const RooArgSet& addNormSet = RooArgSet(), Bool_t force = kTRUE); virtual voidRooAbsReal::fixAddCoefRange(const char* rangeName = 0, Bool_t force = kTRUE); static UInt_tRooAbsArg::fnv1a32(const char* data); static UInt_tRooAbsArg::fnv1a32(const char* data, ULong_t sz, UInt_t hash = fnv1a32start); static ULong64_tRooAbsArg::fnv1a64(const char* data); static ULong64_tRooAbsArg::fnv1a64(const char* data, ULong_t sz, ULong64_t hash = fnv1a64start); virtual Bool_tforceAnalyticalInt(const RooAbsArg&) const; virtual voidRooAbsReal::forceNumInt(Bool_t flag = kTRUE); RooFunctor*RooAbsReal::functor(const RooArgList& obs, const RooArgList& pars = RooArgList(), const RooArgSet& nset = RooArgSet()) const; virtual Int_tRooAbsReal::getAnalyticalIntegral(RooArgSet& allVars, RooArgSet& analVars, const char* rangeName = 0) const; virtual Int_tgetAnalyticalIntegralWN(RooArgSet& allVars, RooArgSet& analVars, const RooArgSet* normSet, const char* rangeName = 0) const; Bool_tRooAbsArg::getAttribute(const Text_t* name) const; RooLinkedListRooAbsArg::getCloningAncestors() const; RooArgSet*RooAbsArg::getComponents() const; RooArgSet*RooAbsArg::getDependents(const RooArgSet& set) const; RooArgSet*RooAbsArg::getDependents(const RooAbsData* set) const; RooArgSet*RooAbsArg::getDependents(const RooArgSet* depList) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); Bool_tRooAbsReal::getForceNumIn",MatchSource.WIKI,root/html602/RooAbsCachedReal.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsCachedReal.html
https://root.cern/root/html602/RooAbsCachedReal.html:35529,Security,validat,validate,35529,,MatchSource.WIKI,root/html602/RooAbsCachedReal.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsCachedReal.html
https://root.cern/root/html602/RooAbsCachedReal.html:36313,Security,access,access,36313,"tes; set<string>RooAbsArg::_boolAttribTransient! Transient boolean attributes (not copied in ctor); Bool_tRooAbsReal::_boolValue! Transient cache for bool values from tree branches; UChar_tRooAbsReal::_byteValue! Transient cache for byte values from tree branches; static Bool_tRooAbsReal::_cacheCheckIf true, always validate contents of clean which outcome of evaluate(); deque<RooAbsCache*>RooAbsArg::_cacheListlist of caches; RooObjCacheManager_cacheMgr! The cache manager; RooRefCountListRooAbsArg::_clientListlist of client objects; RooRefCountListRooAbsArg::_clientListShapesubset of clients that requested shape dirty flag propagation; RooRefCountListRooAbsArg::_clientListValuesubset of clients that requested value dirty flag propagation; TIterator*RooAbsArg::_clientShapeIter! Iterator over _clientListShape; TIterator*RooAbsArg::_clientValueIter! Iterator over _clientListValue; Bool_tRooAbsArg::_deleteWatch! Delete watch flag; RooExpensiveObjectCache*RooAbsArg::_eocachePointer to global cache manager for any expensive components created by this object; Bool_tRooAbsArg::_fastAllow fast access mode in getVal() and proxies; Float_tRooAbsReal::_floatValue! Transient cache for floating point values from tree branches; Bool_tRooAbsReal::_forceNumIntForce numerical integration if flag set; static Bool_tRooAbsReal::_globalSelectCompGlobal activation switch for component selection; static Bool_tRooAbsReal::_hideOffsetOffset hiding flag; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; Int_tRooAbsReal::_intValue! Transient cache for integer values from tree branches; Int_t_ipOrderInterpolation order for cache histograms; Bool_tRooAbsArg::_isConstant! Cached isConstant status; TStringRooAbsReal::_labelPlot label for objects value; RooArgSet*RooAbsReal::_lastNSet!; Bool_tRooAbsArg::_localNoInhibitDirty! Prevent 'AlwaysDirty' mode for this node; static Int_tRooPrintable::_nameLength; TNamed*RooAbsArg::_namePtr! Do not persist.",MatchSource.WIKI,root/html602/RooAbsCachedReal.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsCachedReal.html
https://root.cern/root/html602/RooAbsCachedReal.html:9438,Testability,test,testArg,9438,"l*RooAbsReal::createPlotProjection(const RooArgSet& dependentVars, const RooArgSet* projectedVars, RooArgSet*& cloneSet, const char* rangeName = 0, const RooArgSet* condObs = 0) const; virtual RooAbsReal*RooAbsReal::createProfile(const RooArgSet& paramsOfInterest); RooAbsReal*RooAbsReal::createRunningIntegral(const RooArgSet& iset, const RooArgSet& nset = RooArgSet()); RooAbsReal*RooAbsReal::createRunningIntegral(const RooArgSet& iset, const RooCmdArg& arg1, const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()); RooAbsReal*RooAbsReal::createScanRI(const RooArgSet& iset, const RooArgSet& nset, Int_t numScanBins, Int_t intOrder); virtual Double_tRooAbsReal::defaultErrorLevel() const; static RooNumIntConfig*RooAbsReal::defaultIntegratorConfig(); virtual Int_tRooAbsArg::defaultPrintContents(Option_t* opt) const; static ostream&RooPrintable::defaultPrintStream(ostream* os = 0); virtual RooPrintable::StyleOptionRooPrintable::defaultPrintStyle(Option_t* opt) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; Bool_tRooAbsArg::dependentOverlaps(const RooAbsData* dset, const RooAbsArg& testArg) const; Bool_tRooAbsArg::dependentOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; Bool_tRooAbsArg::dependsOn(const RooAbsCollection& serverList, const RooAbsArg* ignoreArg = 0, Bool_t valueOnly = kFALSE) const; Bool_tRooAbsArg::dependsOn(const RooAbsArg& server, const RooAbsArg* ignoreArg = 0, Bool_t valueOnly = kFALSE) const; Bool_tRooAbsArg::dependsOnValue(const RooAbsCollection& serverList, const RooAbsArg* ignoreArg = 0) const; Bool_tRooAbsArg::dependsOnValue(const RooAbsArg& server, const RooAbsArg* ignoreArg = 0) const; RooDerivative*RooAbsReal::derivative(RooRealVar& obs, Int_t order = 1, Double_t eps = 0.",MatchSource.WIKI,root/html602/RooAbsCachedReal.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsCachedReal.html
https://root.cern/root/html602/RooAbsCachedReal.html:9532,Testability,test,testArg,9532,"l*RooAbsReal::createPlotProjection(const RooArgSet& dependentVars, const RooArgSet* projectedVars, RooArgSet*& cloneSet, const char* rangeName = 0, const RooArgSet* condObs = 0) const; virtual RooAbsReal*RooAbsReal::createProfile(const RooArgSet& paramsOfInterest); RooAbsReal*RooAbsReal::createRunningIntegral(const RooArgSet& iset, const RooArgSet& nset = RooArgSet()); RooAbsReal*RooAbsReal::createRunningIntegral(const RooArgSet& iset, const RooCmdArg& arg1, const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()); RooAbsReal*RooAbsReal::createScanRI(const RooArgSet& iset, const RooArgSet& nset, Int_t numScanBins, Int_t intOrder); virtual Double_tRooAbsReal::defaultErrorLevel() const; static RooNumIntConfig*RooAbsReal::defaultIntegratorConfig(); virtual Int_tRooAbsArg::defaultPrintContents(Option_t* opt) const; static ostream&RooPrintable::defaultPrintStream(ostream* os = 0); virtual RooPrintable::StyleOptionRooPrintable::defaultPrintStyle(Option_t* opt) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; Bool_tRooAbsArg::dependentOverlaps(const RooAbsData* dset, const RooAbsArg& testArg) const; Bool_tRooAbsArg::dependentOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; Bool_tRooAbsArg::dependsOn(const RooAbsCollection& serverList, const RooAbsArg* ignoreArg = 0, Bool_t valueOnly = kFALSE) const; Bool_tRooAbsArg::dependsOn(const RooAbsArg& server, const RooAbsArg* ignoreArg = 0, Bool_t valueOnly = kFALSE) const; Bool_tRooAbsArg::dependsOnValue(const RooAbsCollection& serverList, const RooAbsArg* ignoreArg = 0) const; Bool_tRooAbsArg::dependsOnValue(const RooAbsArg& server, const RooAbsArg* ignoreArg = 0) const; RooDerivative*RooAbsReal::derivative(RooRealVar& obs, Int_t order = 1, Double_t eps = 0.",MatchSource.WIKI,root/html602/RooAbsCachedReal.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsCachedReal.html
https://root.cern/root/html602/RooAbsCachedReal.html:18056,Testability,log,logEvalError,18056,") const; virtual Bool_tTObject::IsFolder() const; virtual Bool_tRooAbsArg::isFundamental() const; virtual Bool_tRooAbsReal::isIdentical(const RooAbsArg& other, Bool_t assumeSameType = kFALSE); virtual Bool_tRooAbsArg::isLValue() const; virtual Bool_tRooAbsReal::isOffsetting() const; Bool_tTObject::IsOnHeap() const; Bool_tRooAbsArg::isShapeDirty() const; Bool_tRooAbsArg::isShapeServer(const RooAbsArg& arg) const; Bool_tRooAbsArg::isShapeServer(const char* name) const; virtual Bool_tRooAbsArg::IsSortable() const; Bool_tRooAbsArg::isValueDirty() const; Bool_tRooAbsArg::isValueDirtyAndClear() const; Bool_tRooAbsArg::isValueOrShapeDirtyAndClear() const; Bool_tRooAbsArg::isValueServer(const RooAbsArg& arg) const; Bool_tRooAbsArg::isValueServer(const char* name) const; Bool_tTObject::IsZombie() const; voidRooAbsArg::leafNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t recurseNonDerived = kFALSE) const; Bool_tRooAbsArg::localNoDirtyInhibit() const; voidRooAbsReal::logEvalError(const char* message, const char* serverValueString = 0) const; static voidRooAbsReal::logEvalError(const RooAbsReal* originator, const char* origName, const char* message, const char* serverValueString = 0); virtual voidTNamed::ls(Option_t* option = """") const; virtual Double_tRooAbsReal::maxVal(Int_t code) const; voidTObject::MayNotUse(const char* method) const; RooAbsMoment*RooAbsReal::mean(RooRealVar& obs); RooAbsMoment*RooAbsReal::mean(RooRealVar& obs, const RooArgSet& nset); virtual Int_tRooAbsReal::minTrialSamples(const RooArgSet&) const; RooAbsMoment*RooAbsReal::moment(RooRealVar& obs, Int_t order, Bool_t central, Bool_t takeRoot); RooAbsMoment*RooAbsReal::moment(RooRealVar& obs, const RooArgSet& normObs, Int_t order, Bool_t central, Bool_t takeRoot, Bool_t intNormObs); static voidRooPrintable::nameFieldLength(Int_t newLen); const TNamed*RooAbsArg::namePtr() const; virtual Bool_tTObject::Notify(); Int_tRooAbsArg::numCaches() const; static Int_tRooAbsReal::numEvalErrorItems(",MatchSource.WIKI,root/html602/RooAbsCachedReal.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsCachedReal.html
https://root.cern/root/html602/RooAbsCachedReal.html:18155,Testability,log,logEvalError,18155,"irtual Bool_tRooAbsReal::isIdentical(const RooAbsArg& other, Bool_t assumeSameType = kFALSE); virtual Bool_tRooAbsArg::isLValue() const; virtual Bool_tRooAbsReal::isOffsetting() const; Bool_tTObject::IsOnHeap() const; Bool_tRooAbsArg::isShapeDirty() const; Bool_tRooAbsArg::isShapeServer(const RooAbsArg& arg) const; Bool_tRooAbsArg::isShapeServer(const char* name) const; virtual Bool_tRooAbsArg::IsSortable() const; Bool_tRooAbsArg::isValueDirty() const; Bool_tRooAbsArg::isValueDirtyAndClear() const; Bool_tRooAbsArg::isValueOrShapeDirtyAndClear() const; Bool_tRooAbsArg::isValueServer(const RooAbsArg& arg) const; Bool_tRooAbsArg::isValueServer(const char* name) const; Bool_tTObject::IsZombie() const; voidRooAbsArg::leafNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t recurseNonDerived = kFALSE) const; Bool_tRooAbsArg::localNoDirtyInhibit() const; voidRooAbsReal::logEvalError(const char* message, const char* serverValueString = 0) const; static voidRooAbsReal::logEvalError(const RooAbsReal* originator, const char* origName, const char* message, const char* serverValueString = 0); virtual voidTNamed::ls(Option_t* option = """") const; virtual Double_tRooAbsReal::maxVal(Int_t code) const; voidTObject::MayNotUse(const char* method) const; RooAbsMoment*RooAbsReal::mean(RooRealVar& obs); RooAbsMoment*RooAbsReal::mean(RooRealVar& obs, const RooArgSet& nset); virtual Int_tRooAbsReal::minTrialSamples(const RooArgSet&) const; RooAbsMoment*RooAbsReal::moment(RooRealVar& obs, Int_t order, Bool_t central, Bool_t takeRoot); RooAbsMoment*RooAbsReal::moment(RooRealVar& obs, const RooArgSet& normObs, Int_t order, Bool_t central, Bool_t takeRoot, Bool_t intNormObs); static voidRooPrintable::nameFieldLength(Int_t newLen); const TNamed*RooAbsArg::namePtr() const; virtual Bool_tTObject::Notify(); Int_tRooAbsArg::numCaches() const; static Int_tRooAbsReal::numEvalErrorItems(); static Int_tRooAbsReal::numEvalErrors(); Bool_tRooAbsArg::observableOverlaps(const RooAbsData* d",MatchSource.WIKI,root/html602/RooAbsCachedReal.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsCachedReal.html
https://root.cern/root/html602/RooAbsCachedReal.html:19184,Testability,test,testArg,19184,"iginator, const char* origName, const char* message, const char* serverValueString = 0); virtual voidTNamed::ls(Option_t* option = """") const; virtual Double_tRooAbsReal::maxVal(Int_t code) const; voidTObject::MayNotUse(const char* method) const; RooAbsMoment*RooAbsReal::mean(RooRealVar& obs); RooAbsMoment*RooAbsReal::mean(RooRealVar& obs, const RooArgSet& nset); virtual Int_tRooAbsReal::minTrialSamples(const RooArgSet&) const; RooAbsMoment*RooAbsReal::moment(RooRealVar& obs, Int_t order, Bool_t central, Bool_t takeRoot); RooAbsMoment*RooAbsReal::moment(RooRealVar& obs, const RooArgSet& normObs, Int_t order, Bool_t central, Bool_t takeRoot, Bool_t intNormObs); static voidRooPrintable::nameFieldLength(Int_t newLen); const TNamed*RooAbsArg::namePtr() const; virtual Bool_tTObject::Notify(); Int_tRooAbsArg::numCaches() const; static Int_tRooAbsReal::numEvalErrorItems(); static Int_tRooAbsReal::numEvalErrors(); Bool_tRooAbsArg::observableOverlaps(const RooAbsData* dset, const RooAbsArg& testArg) const; Bool_tRooAbsArg::observableOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; virtual Double_tRooAbsReal::offset() const; voidTObject::operator delete(void* ptr); voidTObject::operator delete(void* ptr, void* vp); voidTObject::operator delete[](void* ptr); voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); RooAbsCachedReal&operator=(const RooAbsCachedReal&); Bool_tRooAbsReal::operator==(Double_t value) const; virtual Bool_tRooAbsReal::operator==(const RooAbsArg& other); RooAbsArg::OperModeRooAbsArg::operMode() const; virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables); virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables, RooArgSet& optNodes, Ro",MatchSource.WIKI,root/html602/RooAbsCachedReal.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsCachedReal.html
https://root.cern/root/html602/RooAbsCachedReal.html:19279,Testability,test,testArg,19279,"l voidTNamed::ls(Option_t* option = """") const; virtual Double_tRooAbsReal::maxVal(Int_t code) const; voidTObject::MayNotUse(const char* method) const; RooAbsMoment*RooAbsReal::mean(RooRealVar& obs); RooAbsMoment*RooAbsReal::mean(RooRealVar& obs, const RooArgSet& nset); virtual Int_tRooAbsReal::minTrialSamples(const RooArgSet&) const; RooAbsMoment*RooAbsReal::moment(RooRealVar& obs, Int_t order, Bool_t central, Bool_t takeRoot); RooAbsMoment*RooAbsReal::moment(RooRealVar& obs, const RooArgSet& normObs, Int_t order, Bool_t central, Bool_t takeRoot, Bool_t intNormObs); static voidRooPrintable::nameFieldLength(Int_t newLen); const TNamed*RooAbsArg::namePtr() const; virtual Bool_tTObject::Notify(); Int_tRooAbsArg::numCaches() const; static Int_tRooAbsReal::numEvalErrorItems(); static Int_tRooAbsReal::numEvalErrors(); Bool_tRooAbsArg::observableOverlaps(const RooAbsData* dset, const RooAbsArg& testArg) const; Bool_tRooAbsArg::observableOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; virtual Double_tRooAbsReal::offset() const; voidTObject::operator delete(void* ptr); voidTObject::operator delete(void* ptr, void* vp); voidTObject::operator delete[](void* ptr); voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); RooAbsCachedReal&operator=(const RooAbsCachedReal&); Bool_tRooAbsReal::operator==(Double_t value) const; virtual Bool_tRooAbsReal::operator==(const RooAbsArg& other); RooAbsArg::OperModeRooAbsArg::operMode() const; virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables); virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables, RooArgSet& optNodes, RooLinkedList& processedNodes); Bool_tRooAbsArg::overlaps(const RooAbsArg& testArg, Bool_t valueO",MatchSource.WIKI,root/html602/RooAbsCachedReal.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsCachedReal.html
https://root.cern/root/html602/RooAbsCachedReal.html:20261,Testability,test,testArg,20261,"AbsData* dset, const RooAbsArg& testArg) const; Bool_tRooAbsArg::observableOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; virtual Double_tRooAbsReal::offset() const; voidTObject::operator delete(void* ptr); voidTObject::operator delete(void* ptr, void* vp); voidTObject::operator delete[](void* ptr); voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); RooAbsCachedReal&operator=(const RooAbsCachedReal&); Bool_tRooAbsReal::operator==(Double_t value) const; virtual Bool_tRooAbsReal::operator==(const RooAbsArg& other); RooAbsArg::OperModeRooAbsArg::operMode() const; virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables); virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables, RooArgSet& optNodes, RooLinkedList& processedNodes); Bool_tRooAbsArg::overlaps(const RooAbsArg& testArg, Bool_t valueOnly = kFALSE) const; const RooArgSet*RooAbsArg::ownedComponents() const; virtual voidTObject::Paint(Option_t* option = """"); virtual RooPlot*RooAbsReal::plotOn(RooPlot* frame, RooLinkedList& cmdList) const; virtual RooPlot*RooAbsReal::plotOn(RooPlot* frame, const RooCmdArg& arg1 = RooCmdArg(), const RooCmdArg& arg2 = RooCmdArg(), const RooCmdArg& arg3 = RooCmdArg(), const RooCmdArg& arg4 = RooCmdArg(), const RooCmdArg& arg5 = RooCmdArg(), const RooCmdArg& arg6 = RooCmdArg(), const RooCmdArg& arg7 = RooCmdArg(), const RooCmdArg& arg8 = RooCmdArg(), const RooCmdArg& arg9 = RooCmdArg(), const RooCmdArg& arg10 = RooCmdArg()) const; virtual list<Double_t>*RooAbsReal::plotSamplingHint(RooAbsRealLValue&, Double_t, Double_t) const; virtual RooPlot*RooAbsReal::plotSliceOn(RooPlot* frame, const RooArgSet& sliceSet, Option_t* drawOptions = ""L"", Double_t scaleFactor = 1.",MatchSource.WIKI,root/html602/RooAbsCachedReal.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsCachedReal.html
https://root.cern/root/html602/RooAbsCachedReal.html:4223,Usability,clear,clearEvalErrorLog,4223,", const RooLinkedList& cmdList); virtual RooFitResult*RooAbsReal::chi2FitTo(RooDataHist& data, const RooCmdArg& arg1 = RooCmdArg::none(), const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()); virtual RooFitResult*RooAbsReal::chi2FitTo(RooDataSet& xydata, const RooCmdArg& arg1 = RooCmdArg::none(), const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); static voidRooAbsReal::clearEvalErrorLog(); voidRooAbsArg::clearShapeDirty() const; voidRooAbsArg::clearValueAndShapeDirty() const; voidRooAbsArg::clearValueDirty() const; TIterator*RooAbsArg::clientIterator() const; virtual TObject*RooAbsArg::clone(const char* newname = 0) const; virtual TObject*RooAbsArg::Clone(const char* newname = 0) const; virtual RooAbsArg*RooAbsArg::cloneTree(const char* newname = 0) const; virtual Int_tRooAbsArg::Compare(const TObject* other) const; virtual voidRooAbsArg::constOptimizeTestStatistic(RooAbsArg::ConstOpCode opcode, Bool_t doAlsoTrackingOpt = kTRUE); virtual voidTNamed::Copy(TObject& named) const; static UInt_tRooAbsArg::crc32(const char* data); static UInt_tRooAbsArg::crc32(const char* data, ULong_t sz, UInt_t crc = 0); virtual RooAbsReal*RooAbsReal::createChi2(RooDataHist& data, const RooLinkedList& cmdList); virtual RooAbsReal*RooAbsReal::createChi2(RooDataSet& data, const RooLinkedList& cmdList); virtual RooAbsReal*RooAbsReal::createChi2(RooDataHist& data, const RooCmdArg& ar",MatchSource.WIKI,root/html602/RooAbsCachedReal.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsCachedReal.html
https://root.cern/root/html602/RooAbsCachedReal.html:4259,Usability,clear,clearShapeDirty,4259,"rtual RooFitResult*RooAbsReal::chi2FitTo(RooDataHist& data, const RooCmdArg& arg1 = RooCmdArg::none(), const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()); virtual RooFitResult*RooAbsReal::chi2FitTo(RooDataSet& xydata, const RooCmdArg& arg1 = RooCmdArg::none(), const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); static voidRooAbsReal::clearEvalErrorLog(); voidRooAbsArg::clearShapeDirty() const; voidRooAbsArg::clearValueAndShapeDirty() const; voidRooAbsArg::clearValueDirty() const; TIterator*RooAbsArg::clientIterator() const; virtual TObject*RooAbsArg::clone(const char* newname = 0) const; virtual TObject*RooAbsArg::Clone(const char* newname = 0) const; virtual RooAbsArg*RooAbsArg::cloneTree(const char* newname = 0) const; virtual Int_tRooAbsArg::Compare(const TObject* other) const; virtual voidRooAbsArg::constOptimizeTestStatistic(RooAbsArg::ConstOpCode opcode, Bool_t doAlsoTrackingOpt = kTRUE); virtual voidTNamed::Copy(TObject& named) const; static UInt_tRooAbsArg::crc32(const char* data); static UInt_tRooAbsArg::crc32(const char* data, ULong_t sz, UInt_t crc = 0); virtual RooAbsReal*RooAbsReal::createChi2(RooDataHist& data, const RooLinkedList& cmdList); virtual RooAbsReal*RooAbsReal::createChi2(RooDataSet& data, const RooLinkedList& cmdList); virtual RooAbsReal*RooAbsReal::createChi2(RooDataHist& data, const RooCmdArg& arg1 = RooCmdArg::none(), const RooCm",MatchSource.WIKI,root/html602/RooAbsCachedReal.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsCachedReal.html
https://root.cern/root/html602/RooAbsCachedReal.html:4299,Usability,clear,clearValueAndShapeDirty,4299,"DataHist& data, const RooCmdArg& arg1 = RooCmdArg::none(), const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()); virtual RooFitResult*RooAbsReal::chi2FitTo(RooDataSet& xydata, const RooCmdArg& arg1 = RooCmdArg::none(), const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); static voidRooAbsReal::clearEvalErrorLog(); voidRooAbsArg::clearShapeDirty() const; voidRooAbsArg::clearValueAndShapeDirty() const; voidRooAbsArg::clearValueDirty() const; TIterator*RooAbsArg::clientIterator() const; virtual TObject*RooAbsArg::clone(const char* newname = 0) const; virtual TObject*RooAbsArg::Clone(const char* newname = 0) const; virtual RooAbsArg*RooAbsArg::cloneTree(const char* newname = 0) const; virtual Int_tRooAbsArg::Compare(const TObject* other) const; virtual voidRooAbsArg::constOptimizeTestStatistic(RooAbsArg::ConstOpCode opcode, Bool_t doAlsoTrackingOpt = kTRUE); virtual voidTNamed::Copy(TObject& named) const; static UInt_tRooAbsArg::crc32(const char* data); static UInt_tRooAbsArg::crc32(const char* data, ULong_t sz, UInt_t crc = 0); virtual RooAbsReal*RooAbsReal::createChi2(RooDataHist& data, const RooLinkedList& cmdList); virtual RooAbsReal*RooAbsReal::createChi2(RooDataSet& data, const RooLinkedList& cmdList); virtual RooAbsReal*RooAbsReal::createChi2(RooDataHist& data, const RooCmdArg& arg1 = RooCmdArg::none(), const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmd",MatchSource.WIKI,root/html602/RooAbsCachedReal.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsCachedReal.html
https://root.cern/root/html602/RooAbsCachedReal.html:4347,Usability,clear,clearValueDirty,4347,"mdArg::none(), const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()); virtual RooFitResult*RooAbsReal::chi2FitTo(RooDataSet& xydata, const RooCmdArg& arg1 = RooCmdArg::none(), const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); static voidRooAbsReal::clearEvalErrorLog(); voidRooAbsArg::clearShapeDirty() const; voidRooAbsArg::clearValueAndShapeDirty() const; voidRooAbsArg::clearValueDirty() const; TIterator*RooAbsArg::clientIterator() const; virtual TObject*RooAbsArg::clone(const char* newname = 0) const; virtual TObject*RooAbsArg::Clone(const char* newname = 0) const; virtual RooAbsArg*RooAbsArg::cloneTree(const char* newname = 0) const; virtual Int_tRooAbsArg::Compare(const TObject* other) const; virtual voidRooAbsArg::constOptimizeTestStatistic(RooAbsArg::ConstOpCode opcode, Bool_t doAlsoTrackingOpt = kTRUE); virtual voidTNamed::Copy(TObject& named) const; static UInt_tRooAbsArg::crc32(const char* data); static UInt_tRooAbsArg::crc32(const char* data, ULong_t sz, UInt_t crc = 0); virtual RooAbsReal*RooAbsReal::createChi2(RooDataHist& data, const RooLinkedList& cmdList); virtual RooAbsReal*RooAbsReal::createChi2(RooDataSet& data, const RooLinkedList& cmdList); virtual RooAbsReal*RooAbsReal::createChi2(RooDataHist& data, const RooCmdArg& arg1 = RooCmdArg::none(), const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdA",MatchSource.WIKI,root/html602/RooAbsCachedReal.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsCachedReal.html
https://root.cern/root/html602/RooAbsCachedReal.html:39350,Usability,clear,clearCacheObject,39350,":_valueCache for current value of object; Bool_tRooAbsArg::_valueDirtyFlag set if value needs recalculating because input values modified; static Bool_tRooAbsArg::_verboseDirtyStatic flag controlling verbose messaging for dirty state changes; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title. private:. Bool_t_disableCacheFlag to run object in passthrough (= non-caching mode). Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; RooAbsCachedReal(const char* name, const char* title, Int_t ipOrder = 0); Constructor. RooAbsCachedReal(const RooAbsCachedReal& other, const char* name = 0); Copy constructor. ~RooAbsCachedReal(); Destructor. Double_t getValV(const RooArgSet* set = 0) const; Implementation of getVal() overriding default implementation; of RooAbsReal. Return value stored in cache p.d.f; rather than return value of evaluate() which is undefined; for RooAbsCachedReal. void clearCacheObject(RooAbsCachedReal::FuncCacheElem& cache) const; Mark all bins as unitialized (value -1). TString cacheNameSuffix(const RooArgSet& nset) const; Construct unique suffix name for cache p.d.f object. void setInterpolationOrder(Int_t order); Set interpolation order of RooHistFunct representing cache histogram. Int_t getAnalyticalIntegralWN(RooArgSet& allVars, RooArgSet& analVars, const RooArgSet* normSet, const char* rangeName = 0) const; Return analytical integration capabilities of the RooHistFunc that corresponds to the set of observables in allVars. Double_t analyticalIntegralWN(Int_t code, const RooArgSet* normSet, const char* rangeName = 0) const; Forward call to implementation in relevant RooHistFunc instance. RooAbsCachedReal(); {}. Bool_t selfNormalized() const; Declares function self normalized. Int_t getInterpolationOrder() const; Set interpolation order in RooHistFuncs that represent cache histograms. Bool_t forceAnalyticalInt(const RooAbsArg& ) const; Force all observables to be offered for internal integratio",MatchSource.WIKI,root/html602/RooAbsCachedReal.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsCachedReal.html
https://root.cern/root/html602/RooAbsCacheElement.html:712,Availability,avail,available,712,". RooAbsCacheElement. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » ROOFIT; » ROOFITCORE; » RooAbsCacheElement. class RooAbsCacheElement. RooAbsCacheElement is the abstract base class for objects to be stored; in RooAbsCache cache manager objects. Each storage element has an ; interface to pass on calls for server redirection, operation mode; change calls and constant term optimization management calls; . Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~RooAbsCacheElement(); static TClass*Class(); virtual RooArgListcontainedArgs(RooAbsCacheElement::Action); virtual voidfindConstantNodes(const RooArgSet& obs, RooArgSet& cacheList, RooLinkedList& processedNodes); virtual TClass*IsA() const; RooAbsCacheElement&operator=(const RooAbsCacheElement&); virtual voidoperModeHook(RooAbsArg::OperMode); virtual voidoptimizeCacheMode(const RooArgSet& obs, RooArgSet& optNodes, RooLinkedList& processedNodes); virtual voidprintCompactTreeHook(ostream&, const char*, Int_t curElem, Int_t totElem); virtual Bool_tredirectServersHook(const RooAbsCollection&, Bool_t, Bool_t, Bool_t); RooAbsCacheElement(); RooAbsCacheElement(const RooAbsCacheElement&); voidsetOwner(RooAbsArg* owner); virtual voidShowMembers(TMemberInspector& insp) const; virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b). Data Members; public:. static RooAbsCacheElement::ActionFindConstantNodes; static RooAbsCacheElement::ActionOperModeChange; static RooAbsCacheElement::ActionOptimizeCaching. protected:. RooAbsArg*_owner! Pointer to owning RooAbsArg. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; Bool_t redirectServersHook(const RooAbsCollection& , Bo",MatchSource.WIKI,root/html602/RooAbsCacheElement.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsCacheElement.html
https://root.cern/root/html602/RooAbsCacheElement.html:447,Integrability,interface,interface,447,". RooAbsCacheElement. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » ROOFIT; » ROOFITCORE; » RooAbsCacheElement. class RooAbsCacheElement. RooAbsCacheElement is the abstract base class for objects to be stored; in RooAbsCache cache manager objects. Each storage element has an ; interface to pass on calls for server redirection, operation mode; change calls and constant term optimization management calls; . Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~RooAbsCacheElement(); static TClass*Class(); virtual RooArgListcontainedArgs(RooAbsCacheElement::Action); virtual voidfindConstantNodes(const RooArgSet& obs, RooArgSet& cacheList, RooLinkedList& processedNodes); virtual TClass*IsA() const; RooAbsCacheElement&operator=(const RooAbsCacheElement&); virtual voidoperModeHook(RooAbsArg::OperMode); virtual voidoptimizeCacheMode(const RooArgSet& obs, RooArgSet& optNodes, RooLinkedList& processedNodes); virtual voidprintCompactTreeHook(ostream&, const char*, Int_t curElem, Int_t totElem); virtual Bool_tredirectServersHook(const RooAbsCollection&, Bool_t, Bool_t, Bool_t); RooAbsCacheElement(); RooAbsCacheElement(const RooAbsCacheElement&); voidsetOwner(RooAbsArg* owner); virtual voidShowMembers(TMemberInspector& insp) const; virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b). Data Members; public:. static RooAbsCacheElement::ActionFindConstantNodes; static RooAbsCacheElement::ActionOperModeChange; static RooAbsCacheElement::ActionOptimizeCaching. protected:. RooAbsArg*_owner! Pointer to owning RooAbsArg. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; Bool_t redirectServersHook(const RooAbsCollection& , Bo",MatchSource.WIKI,root/html602/RooAbsCacheElement.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsCacheElement.html
https://root.cern/root/html602/RooAbsCacheElement.html:394,Performance,cache,cache,394,". RooAbsCacheElement. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » ROOFIT; » ROOFITCORE; » RooAbsCacheElement. class RooAbsCacheElement. RooAbsCacheElement is the abstract base class for objects to be stored; in RooAbsCache cache manager objects. Each storage element has an ; interface to pass on calls for server redirection, operation mode; change calls and constant term optimization management calls; . Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~RooAbsCacheElement(); static TClass*Class(); virtual RooArgListcontainedArgs(RooAbsCacheElement::Action); virtual voidfindConstantNodes(const RooArgSet& obs, RooArgSet& cacheList, RooLinkedList& processedNodes); virtual TClass*IsA() const; RooAbsCacheElement&operator=(const RooAbsCacheElement&); virtual voidoperModeHook(RooAbsArg::OperMode); virtual voidoptimizeCacheMode(const RooArgSet& obs, RooArgSet& optNodes, RooLinkedList& processedNodes); virtual voidprintCompactTreeHook(ostream&, const char*, Int_t curElem, Int_t totElem); virtual Bool_tredirectServersHook(const RooAbsCollection&, Bool_t, Bool_t, Bool_t); RooAbsCacheElement(); RooAbsCacheElement(const RooAbsCacheElement&); voidsetOwner(RooAbsArg* owner); virtual voidShowMembers(TMemberInspector& insp) const; virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b). Data Members; public:. static RooAbsCacheElement::ActionFindConstantNodes; static RooAbsCacheElement::ActionOperModeChange; static RooAbsCacheElement::ActionOptimizeCaching. protected:. RooAbsArg*_owner! Pointer to owning RooAbsArg. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; Bool_t redirectServersHook(const RooAbsCollection& , Bo",MatchSource.WIKI,root/html602/RooAbsCacheElement.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsCacheElement.html
https://root.cern/root/html602/RooAbsCacheElement.html:545,Performance,optimiz,optimization,545,". RooAbsCacheElement. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » ROOFIT; » ROOFITCORE; » RooAbsCacheElement. class RooAbsCacheElement. RooAbsCacheElement is the abstract base class for objects to be stored; in RooAbsCache cache manager objects. Each storage element has an ; interface to pass on calls for server redirection, operation mode; change calls and constant term optimization management calls; . Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~RooAbsCacheElement(); static TClass*Class(); virtual RooArgListcontainedArgs(RooAbsCacheElement::Action); virtual voidfindConstantNodes(const RooArgSet& obs, RooArgSet& cacheList, RooLinkedList& processedNodes); virtual TClass*IsA() const; RooAbsCacheElement&operator=(const RooAbsCacheElement&); virtual voidoperModeHook(RooAbsArg::OperMode); virtual voidoptimizeCacheMode(const RooArgSet& obs, RooArgSet& optNodes, RooLinkedList& processedNodes); virtual voidprintCompactTreeHook(ostream&, const char*, Int_t curElem, Int_t totElem); virtual Bool_tredirectServersHook(const RooAbsCollection&, Bool_t, Bool_t, Bool_t); RooAbsCacheElement(); RooAbsCacheElement(const RooAbsCacheElement&); voidsetOwner(RooAbsArg* owner); virtual voidShowMembers(TMemberInspector& insp) const; virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b). Data Members; public:. static RooAbsCacheElement::ActionFindConstantNodes; static RooAbsCacheElement::ActionOperModeChange; static RooAbsCacheElement::ActionOptimizeCaching. protected:. RooAbsArg*_owner! Pointer to owning RooAbsArg. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; Bool_t redirectServersHook(const RooAbsCollection& , Bo",MatchSource.WIKI,root/html602/RooAbsCacheElement.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsCacheElement.html
https://root.cern/root/html602/RooAbsCacheElement.html:923,Performance,cache,cacheList,923,"function members; data members; class charts. ROOT; » ROOFIT; » ROOFITCORE; » RooAbsCacheElement. class RooAbsCacheElement. RooAbsCacheElement is the abstract base class for objects to be stored; in RooAbsCache cache manager objects. Each storage element has an ; interface to pass on calls for server redirection, operation mode; change calls and constant term optimization management calls; . Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~RooAbsCacheElement(); static TClass*Class(); virtual RooArgListcontainedArgs(RooAbsCacheElement::Action); virtual voidfindConstantNodes(const RooArgSet& obs, RooArgSet& cacheList, RooLinkedList& processedNodes); virtual TClass*IsA() const; RooAbsCacheElement&operator=(const RooAbsCacheElement&); virtual voidoperModeHook(RooAbsArg::OperMode); virtual voidoptimizeCacheMode(const RooArgSet& obs, RooArgSet& optNodes, RooLinkedList& processedNodes); virtual voidprintCompactTreeHook(ostream&, const char*, Int_t curElem, Int_t totElem); virtual Bool_tredirectServersHook(const RooAbsCollection&, Bool_t, Bool_t, Bool_t); RooAbsCacheElement(); RooAbsCacheElement(const RooAbsCacheElement&); voidsetOwner(RooAbsArg* owner); virtual voidShowMembers(TMemberInspector& insp) const; virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b). Data Members; public:. static RooAbsCacheElement::ActionFindConstantNodes; static RooAbsCacheElement::ActionOperModeChange; static RooAbsCacheElement::ActionOptimizeCaching. protected:. RooAbsArg*_owner! Pointer to owning RooAbsArg. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; Bool_t redirectServersHook(const RooAbsCollection& , Bool_t , Bool_t , Bool_t ); Interface for server redirect calls. void printCompactTreeHook(ostream& , const char* , Int_t curElem, Int_t totElem); Hook function to print cache guts in ",MatchSource.WIKI,root/html602/RooAbsCacheElement.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsCacheElement.html
https://root.cern/root/html602/RooAbsCacheElement.html:2169,Performance,cache,cache,2169,"gSet& obs, RooArgSet& optNodes, RooLinkedList& processedNodes); virtual voidprintCompactTreeHook(ostream&, const char*, Int_t curElem, Int_t totElem); virtual Bool_tredirectServersHook(const RooAbsCollection&, Bool_t, Bool_t, Bool_t); RooAbsCacheElement(); RooAbsCacheElement(const RooAbsCacheElement&); voidsetOwner(RooAbsArg* owner); virtual voidShowMembers(TMemberInspector& insp) const; virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b). Data Members; public:. static RooAbsCacheElement::ActionFindConstantNodes; static RooAbsCacheElement::ActionOperModeChange; static RooAbsCacheElement::ActionOptimizeCaching. protected:. RooAbsArg*_owner! Pointer to owning RooAbsArg. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; Bool_t redirectServersHook(const RooAbsCollection& , Bool_t , Bool_t , Bool_t ); Interface for server redirect calls. void printCompactTreeHook(ostream& , const char* , Int_t curElem, Int_t totElem); Hook function to print cache guts in tree printing mode of RooAbsArgs. void operModeHook(RooAbsArg::OperMode ); Interface for operation mode change calls. void optimizeCacheMode(const RooArgSet& obs, RooArgSet& optNodes, RooLinkedList& processedNodes); Interface for cache optimization calls. The default implementation is to forward all these; calls to all contained RooAbsArg objects as publicized through containedArg(). void findConstantNodes(const RooArgSet& obs, RooArgSet& cacheList, RooLinkedList& processedNodes); Interface for constant term optimization calls. The default implementation is to forward all these; calls to all contained RooAbsArg objects as publicized through containedArg(). RooAbsCacheElement(); Default constructor. virtual ~RooAbsCacheElement(); Destructor. RooArgList containedArgs(RooAbsCacheElement::Action ). void setOwner(RooAbsArg* owner); Store pointer to owner. » Last changed: Tue Jun 30 14:29:54 2015 » Last generated: 2015-06-30 14:29; This page has bee",MatchSource.WIKI,root/html602/RooAbsCacheElement.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsCacheElement.html
https://root.cern/root/html602/RooAbsCacheElement.html:2306,Performance,optimiz,optimizeCacheMode,2306,"t totElem); virtual Bool_tredirectServersHook(const RooAbsCollection&, Bool_t, Bool_t, Bool_t); RooAbsCacheElement(); RooAbsCacheElement(const RooAbsCacheElement&); voidsetOwner(RooAbsArg* owner); virtual voidShowMembers(TMemberInspector& insp) const; virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b). Data Members; public:. static RooAbsCacheElement::ActionFindConstantNodes; static RooAbsCacheElement::ActionOperModeChange; static RooAbsCacheElement::ActionOptimizeCaching. protected:. RooAbsArg*_owner! Pointer to owning RooAbsArg. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; Bool_t redirectServersHook(const RooAbsCollection& , Bool_t , Bool_t , Bool_t ); Interface for server redirect calls. void printCompactTreeHook(ostream& , const char* , Int_t curElem, Int_t totElem); Hook function to print cache guts in tree printing mode of RooAbsArgs. void operModeHook(RooAbsArg::OperMode ); Interface for operation mode change calls. void optimizeCacheMode(const RooArgSet& obs, RooArgSet& optNodes, RooLinkedList& processedNodes); Interface for cache optimization calls. The default implementation is to forward all these; calls to all contained RooAbsArg objects as publicized through containedArg(). void findConstantNodes(const RooArgSet& obs, RooArgSet& cacheList, RooLinkedList& processedNodes); Interface for constant term optimization calls. The default implementation is to forward all these; calls to all contained RooAbsArg objects as publicized through containedArg(). RooAbsCacheElement(); Default constructor. virtual ~RooAbsCacheElement(); Destructor. RooArgList containedArgs(RooAbsCacheElement::Action ). void setOwner(RooAbsArg* owner); Store pointer to owner. » Last changed: Tue Jun 30 14:29:54 2015 » Last generated: 2015-06-30 14:29; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html602/RooAbsCacheElement.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsCacheElement.html
https://root.cern/root/html602/RooAbsCacheElement.html:2413,Performance,cache,cache,2413,"t totElem); virtual Bool_tredirectServersHook(const RooAbsCollection&, Bool_t, Bool_t, Bool_t); RooAbsCacheElement(); RooAbsCacheElement(const RooAbsCacheElement&); voidsetOwner(RooAbsArg* owner); virtual voidShowMembers(TMemberInspector& insp) const; virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b). Data Members; public:. static RooAbsCacheElement::ActionFindConstantNodes; static RooAbsCacheElement::ActionOperModeChange; static RooAbsCacheElement::ActionOptimizeCaching. protected:. RooAbsArg*_owner! Pointer to owning RooAbsArg. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; Bool_t redirectServersHook(const RooAbsCollection& , Bool_t , Bool_t , Bool_t ); Interface for server redirect calls. void printCompactTreeHook(ostream& , const char* , Int_t curElem, Int_t totElem); Hook function to print cache guts in tree printing mode of RooAbsArgs. void operModeHook(RooAbsArg::OperMode ); Interface for operation mode change calls. void optimizeCacheMode(const RooArgSet& obs, RooArgSet& optNodes, RooLinkedList& processedNodes); Interface for cache optimization calls. The default implementation is to forward all these; calls to all contained RooAbsArg objects as publicized through containedArg(). void findConstantNodes(const RooArgSet& obs, RooArgSet& cacheList, RooLinkedList& processedNodes); Interface for constant term optimization calls. The default implementation is to forward all these; calls to all contained RooAbsArg objects as publicized through containedArg(). RooAbsCacheElement(); Default constructor. virtual ~RooAbsCacheElement(); Destructor. RooArgList containedArgs(RooAbsCacheElement::Action ). void setOwner(RooAbsArg* owner); Store pointer to owner. » Last changed: Tue Jun 30 14:29:54 2015 » Last generated: 2015-06-30 14:29; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html602/RooAbsCacheElement.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsCacheElement.html
https://root.cern/root/html602/RooAbsCacheElement.html:2419,Performance,optimiz,optimization,2419,"t totElem); virtual Bool_tredirectServersHook(const RooAbsCollection&, Bool_t, Bool_t, Bool_t); RooAbsCacheElement(); RooAbsCacheElement(const RooAbsCacheElement&); voidsetOwner(RooAbsArg* owner); virtual voidShowMembers(TMemberInspector& insp) const; virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b). Data Members; public:. static RooAbsCacheElement::ActionFindConstantNodes; static RooAbsCacheElement::ActionOperModeChange; static RooAbsCacheElement::ActionOptimizeCaching. protected:. RooAbsArg*_owner! Pointer to owning RooAbsArg. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; Bool_t redirectServersHook(const RooAbsCollection& , Bool_t , Bool_t , Bool_t ); Interface for server redirect calls. void printCompactTreeHook(ostream& , const char* , Int_t curElem, Int_t totElem); Hook function to print cache guts in tree printing mode of RooAbsArgs. void operModeHook(RooAbsArg::OperMode ); Interface for operation mode change calls. void optimizeCacheMode(const RooArgSet& obs, RooArgSet& optNodes, RooLinkedList& processedNodes); Interface for cache optimization calls. The default implementation is to forward all these; calls to all contained RooAbsArg objects as publicized through containedArg(). void findConstantNodes(const RooArgSet& obs, RooArgSet& cacheList, RooLinkedList& processedNodes); Interface for constant term optimization calls. The default implementation is to forward all these; calls to all contained RooAbsArg objects as publicized through containedArg(). RooAbsCacheElement(); Default constructor. virtual ~RooAbsCacheElement(); Destructor. RooArgList containedArgs(RooAbsCacheElement::Action ). void setOwner(RooAbsArg* owner); Store pointer to owner. » Last changed: Tue Jun 30 14:29:54 2015 » Last generated: 2015-06-30 14:29; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html602/RooAbsCacheElement.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsCacheElement.html
https://root.cern/root/html602/RooAbsCacheElement.html:2626,Performance,cache,cacheList,2626,"t totElem); virtual Bool_tredirectServersHook(const RooAbsCollection&, Bool_t, Bool_t, Bool_t); RooAbsCacheElement(); RooAbsCacheElement(const RooAbsCacheElement&); voidsetOwner(RooAbsArg* owner); virtual voidShowMembers(TMemberInspector& insp) const; virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b). Data Members; public:. static RooAbsCacheElement::ActionFindConstantNodes; static RooAbsCacheElement::ActionOperModeChange; static RooAbsCacheElement::ActionOptimizeCaching. protected:. RooAbsArg*_owner! Pointer to owning RooAbsArg. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; Bool_t redirectServersHook(const RooAbsCollection& , Bool_t , Bool_t , Bool_t ); Interface for server redirect calls. void printCompactTreeHook(ostream& , const char* , Int_t curElem, Int_t totElem); Hook function to print cache guts in tree printing mode of RooAbsArgs. void operModeHook(RooAbsArg::OperMode ); Interface for operation mode change calls. void optimizeCacheMode(const RooArgSet& obs, RooArgSet& optNodes, RooLinkedList& processedNodes); Interface for cache optimization calls. The default implementation is to forward all these; calls to all contained RooAbsArg objects as publicized through containedArg(). void findConstantNodes(const RooArgSet& obs, RooArgSet& cacheList, RooLinkedList& processedNodes); Interface for constant term optimization calls. The default implementation is to forward all these; calls to all contained RooAbsArg objects as publicized through containedArg(). RooAbsCacheElement(); Default constructor. virtual ~RooAbsCacheElement(); Destructor. RooArgList containedArgs(RooAbsCacheElement::Action ). void setOwner(RooAbsArg* owner); Store pointer to owner. » Last changed: Tue Jun 30 14:29:54 2015 » Last generated: 2015-06-30 14:29; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html602/RooAbsCacheElement.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsCacheElement.html
https://root.cern/root/html602/RooAbsCacheElement.html:2697,Performance,optimiz,optimization,2697,"t totElem); virtual Bool_tredirectServersHook(const RooAbsCollection&, Bool_t, Bool_t, Bool_t); RooAbsCacheElement(); RooAbsCacheElement(const RooAbsCacheElement&); voidsetOwner(RooAbsArg* owner); virtual voidShowMembers(TMemberInspector& insp) const; virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b). Data Members; public:. static RooAbsCacheElement::ActionFindConstantNodes; static RooAbsCacheElement::ActionOperModeChange; static RooAbsCacheElement::ActionOptimizeCaching. protected:. RooAbsArg*_owner! Pointer to owning RooAbsArg. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; Bool_t redirectServersHook(const RooAbsCollection& , Bool_t , Bool_t , Bool_t ); Interface for server redirect calls. void printCompactTreeHook(ostream& , const char* , Int_t curElem, Int_t totElem); Hook function to print cache guts in tree printing mode of RooAbsArgs. void operModeHook(RooAbsArg::OperMode ); Interface for operation mode change calls. void optimizeCacheMode(const RooArgSet& obs, RooArgSet& optNodes, RooLinkedList& processedNodes); Interface for cache optimization calls. The default implementation is to forward all these; calls to all contained RooAbsArg objects as publicized through containedArg(). void findConstantNodes(const RooArgSet& obs, RooArgSet& cacheList, RooLinkedList& processedNodes); Interface for constant term optimization calls. The default implementation is to forward all these; calls to all contained RooAbsArg objects as publicized through containedArg(). RooAbsCacheElement(); Default constructor. virtual ~RooAbsCacheElement(); Destructor. RooArgList containedArgs(RooAbsCacheElement::Action ). void setOwner(RooAbsArg* owner); Store pointer to owner. » Last changed: Tue Jun 30 14:29:54 2015 » Last generated: 2015-06-30 14:29; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html602/RooAbsCacheElement.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsCacheElement.html
https://root.cern/root/html602/RooAbsCategory.html:809,Availability,avail,available,809,". RooAbsCategory. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » ROOFIT; » ROOFITCORE; » RooAbsCategory. class RooAbsCategory: public RooAbsArg. RooAbsCategory is the common abstract base class for objects that; represent a discrete value with a finite number of states. Each; state consist of a label/index pair, which is stored in a; RooCatType object.; ; Implementation of RooAbsCategory may be derived, there no interface; is provided to modify the contents, nor a public interface to define states.; . Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~RooAbsCategory(); voidTObject::AbstractMethod(const char* method) const; Bool_tRooAbsArg::addOwnedComponents(const RooArgSet& comps); voidRooAbsArg::addParameters(RooArgSet& params, const RooArgSet* nset = 0, Bool_t stripDisconnected = kTRUE) const; voidRooAbsArg::addServer(RooAbsArg& server, Bool_t valueProp = kTRUE, Bool_t shapeProp = kFALSE); voidRooAbsArg::addServerList(RooAbsCollection& serverList, Bool_t valueProp = kTRUE, Bool_t shapeProp = kFALSE); const char*RooAbsArg::aggregateCacheUniqueSuffix() const; virtual voidTObject::AppendPad(Option_t* option = """"); voidRooAbsArg::attachDataSet(const RooAbsData& set); voidRooAbsArg::attachDataStore(const RooAbsDataStore& set); const set<string>&RooAbsArg::attributes() const; voidRooAbsArg::branchNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t recurseNonDerived = kFALSE) const; virtual voidTObject::Browse(TBrowser* b); virtual const char*RooAbsArg::cacheUniqueSuffix() const; virtual RooAbsArg::CacheModeRooAbsArg::canNodeBeCached() const; voidRooAbsArg::changeServer(RooAbsArg& server, Bool_t valueProp, Bool_t shapeProp); Bool_tRooAbsArg::checkDependents(const ",MatchSource.WIKI,root/html602/RooAbsCategory.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsCategory.html
https://root.cern/root/html602/RooAbsCategory.html:4390,Availability,error,error,4390,", const RooAbsArg& testArg) const; Bool_tRooAbsArg::dependentOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; Bool_tRooAbsArg::dependsOn(const RooAbsCollection& serverList, const RooAbsArg* ignoreArg = 0, Bool_t valueOnly = kFALSE) const; Bool_tRooAbsArg::dependsOn(const RooAbsArg& server, const RooAbsArg* ignoreArg = 0, Bool_t valueOnly = kFALSE) const; Bool_tRooAbsArg::dependsOnValue(const RooAbsCollection& serverList, const RooAbsArg* ignoreArg = 0) const; Bool_tRooAbsArg::dependsOnValue(const RooAbsArg& server, const RooAbsArg* ignoreArg = 0) const; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); RooExpensiveObjectCache&RooAbsArg::expensiveObjectCache() const; virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); Bool_tRooAbsArg::findConstantNodes(const RooArgSet& observables, RooArgSet& cacheList); Bool_tRooAbsArg::findConstantNodes(const RooArgSet& observables, RooArgSet& cacheList, RooLinkedList& processedNodes); RooAbsArg*RooAbsArg::findNewServer(const RooAbsCollection& newSet, Bool_t nameChange) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; RooAbsArg*RooAbsArg::findServer(const char* name) const; RooAbsArg*RooAbsArg::findServer(const RooAbsArg& arg) const; RooAbsArg*RooAbsArg::findServer(Int_t index) const; static UInt_tRooAbsArg::fnv1a32(const char* data); static U",MatchSource.WIKI,root/html602/RooAbsCategory.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsCategory.html
https://root.cern/root/html602/RooAbsCategory.html:4474,Availability,error,error,4474,"t* depList, const RooAbsArg& testArg) const; Bool_tRooAbsArg::dependsOn(const RooAbsCollection& serverList, const RooAbsArg* ignoreArg = 0, Bool_t valueOnly = kFALSE) const; Bool_tRooAbsArg::dependsOn(const RooAbsArg& server, const RooAbsArg* ignoreArg = 0, Bool_t valueOnly = kFALSE) const; Bool_tRooAbsArg::dependsOnValue(const RooAbsCollection& serverList, const RooAbsArg* ignoreArg = 0) const; Bool_tRooAbsArg::dependsOnValue(const RooAbsArg& server, const RooAbsArg* ignoreArg = 0) const; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); RooExpensiveObjectCache&RooAbsArg::expensiveObjectCache() const; virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); Bool_tRooAbsArg::findConstantNodes(const RooArgSet& observables, RooArgSet& cacheList); Bool_tRooAbsArg::findConstantNodes(const RooArgSet& observables, RooArgSet& cacheList, RooLinkedList& processedNodes); RooAbsArg*RooAbsArg::findNewServer(const RooAbsCollection& newSet, Bool_t nameChange) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; RooAbsArg*RooAbsArg::findServer(const char* name) const; RooAbsArg*RooAbsArg::findServer(const RooAbsArg& arg) const; RooAbsArg*RooAbsArg::findServer(Int_t index) const; static UInt_tRooAbsArg::fnv1a32(const char* data); static UInt_tRooAbsArg::fnv1a32(const char* data, ULong_t sz, UInt_t hash = fnv1a32start); s",MatchSource.WIKI,root/html602/RooAbsCategory.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsCategory.html
https://root.cern/root/html602/RooAbsCategory.html:24882,Availability,avail,available,24882,"f current state. const char* getLabel() const; Return label string of current state. RooCatType traceEval() const; Recalculate current value and check validity of new result. TIterator* typeIterator() const; Return iterator over all defined states. Bool_t operator==(Int_t index) const; Equality operator with a integer (compares with state index number). Bool_t operator==(const char* label) const; Equality operator with a string (compares with state label string). Bool_t operator==(const RooAbsArg& other); Equality operator with another RooAbsArg. Only functional; is also a RooAbsCategory, will return true if index is the same. Bool_t isIdentical(const RooAbsArg& other, Bool_t assumeSameType = kFALSE). Bool_t isValidIndex(Int_t index) const; Check if state with given index is defined. Bool_t isValidLabel(const char* label) const; Check if state with given name is defined. const RooCatType* defineType(const char* label); Define a new state with given name. The lowest available; integer number is assigned as index value. const RooCatType* defineTypeUnchecked(const char* label, Int_t index); Internal version of defineType that does not check if type; already exists. const RooCatType* defineType(const char* label, Int_t index); Define new state with given name and index number. void clearTypes(); Delete all currently defined states. const RooCatType* lookupType(const RooCatType& type, Bool_t printError = kFALSE) const; Find our type that matches the specified type, or return 0 for no match. const RooCatType* lookupType(Int_t index, Bool_t printError = kFALSE) const; Find our type corresponding to the specified index, or return 0 for no match. const RooCatType* lookupType(const char* label, Bool_t printError = kFALSE) const; Find our type corresponding to the specified label, or return 0 for no match. Bool_t isValid() const; Check if current value is a valid state. Bool_t isValid(const RooCatType& value) const; Check if given state is defined for this object. Roo1DTable* c",MatchSource.WIKI,root/html602/RooAbsCategory.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsCategory.html
https://root.cern/root/html602/RooAbsCategory.html:28387,Deployability,integrat,integration,28387,"bel to as branches to the given; TTree. The index field will be attached as integer with name; <name>_idx, the label field will be attached as char[] with label; <name>_lbl. void fillTreeBranch(TTree& t); Fill tree branches associated with current object with current value. void setTreeBranchStatus(TTree& t, Bool_t active); (De)activate associate tree branch. void syncCache(const RooArgSet* set = 0); Explicitly synchronize RooAbsCategory internal cache. void copyCache(const RooAbsArg* source, Bool_t valueOnly = kFALSE, Bool_t setValueDirty = kTRUE); Copy the cached value from given source and raise dirty flag.; It is the callers responsability to ensure that the sources; cache is clean(valid) before this function is called, e.g. by; calling syncCache() on the source. const RooCatType* getOrdinal(UInt_t n, const char* rangeName = 0) const; Return state definition of ordinal nth defined state,; needed by the generator mechanism. RooAbsArg * createFundamental(const char* newname = 0) const; Create a RooCategory fundamental object with our properties. Bool_t isSignType(Bool_t mustHaveZero = kFALSE) const; Determine if category has 2 or 3 states with index values -1,0,1. RooAbsCategory(); Constructors, assignment etc. Bool_t operator!=(Int_t index); { return !operator==(index);}. Bool_t operator!=(const char* label); { return !operator==(label);}. Bool_t operator!=(const RooAbsArg& other); { return !operator==(other);}. Int_t numTypes(const char* = 0) const; Return number of types defined (in range named rangeName if rangeName!=0). Bool_t isIntegrationSafeLValue(const RooArgSet* ) const; Is this l-value object safe for use as integration observable. Bool_t traceEvalHook(RooCatType ) const; coverity[PASS_BY_VALUE]. RooCatType evaluate() const. » Last changed: Tue Jun 30 14:29:59 2015 » Last generated: 2015-06-30 14:29; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html602/RooAbsCategory.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsCategory.html
https://root.cern/root/html602/RooAbsCategory.html:584,Integrability,interface,interface,584,". RooAbsCategory. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » ROOFIT; » ROOFITCORE; » RooAbsCategory. class RooAbsCategory: public RooAbsArg. RooAbsCategory is the common abstract base class for objects that; represent a discrete value with a finite number of states. Each; state consist of a label/index pair, which is stored in a; RooCatType object.; ; Implementation of RooAbsCategory may be derived, there no interface; is provided to modify the contents, nor a public interface to define states.; . Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~RooAbsCategory(); voidTObject::AbstractMethod(const char* method) const; Bool_tRooAbsArg::addOwnedComponents(const RooArgSet& comps); voidRooAbsArg::addParameters(RooArgSet& params, const RooArgSet* nset = 0, Bool_t stripDisconnected = kTRUE) const; voidRooAbsArg::addServer(RooAbsArg& server, Bool_t valueProp = kTRUE, Bool_t shapeProp = kFALSE); voidRooAbsArg::addServerList(RooAbsCollection& serverList, Bool_t valueProp = kTRUE, Bool_t shapeProp = kFALSE); const char*RooAbsArg::aggregateCacheUniqueSuffix() const; virtual voidTObject::AppendPad(Option_t* option = """"); voidRooAbsArg::attachDataSet(const RooAbsData& set); voidRooAbsArg::attachDataStore(const RooAbsDataStore& set); const set<string>&RooAbsArg::attributes() const; voidRooAbsArg::branchNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t recurseNonDerived = kFALSE) const; virtual voidTObject::Browse(TBrowser* b); virtual const char*RooAbsArg::cacheUniqueSuffix() const; virtual RooAbsArg::CacheModeRooAbsArg::canNodeBeCached() const; voidRooAbsArg::changeServer(RooAbsArg& server, Bool_t valueProp, Bool_t shapeProp); Bool_tRooAbsArg::checkDependents(const ",MatchSource.WIKI,root/html602/RooAbsCategory.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsCategory.html
https://root.cern/root/html602/RooAbsCategory.html:644,Integrability,interface,interface,644,". RooAbsCategory. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » ROOFIT; » ROOFITCORE; » RooAbsCategory. class RooAbsCategory: public RooAbsArg. RooAbsCategory is the common abstract base class for objects that; represent a discrete value with a finite number of states. Each; state consist of a label/index pair, which is stored in a; RooCatType object.; ; Implementation of RooAbsCategory may be derived, there no interface; is provided to modify the contents, nor a public interface to define states.; . Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~RooAbsCategory(); voidTObject::AbstractMethod(const char* method) const; Bool_tRooAbsArg::addOwnedComponents(const RooArgSet& comps); voidRooAbsArg::addParameters(RooArgSet& params, const RooArgSet* nset = 0, Bool_t stripDisconnected = kTRUE) const; voidRooAbsArg::addServer(RooAbsArg& server, Bool_t valueProp = kTRUE, Bool_t shapeProp = kFALSE); voidRooAbsArg::addServerList(RooAbsCollection& serverList, Bool_t valueProp = kTRUE, Bool_t shapeProp = kFALSE); const char*RooAbsArg::aggregateCacheUniqueSuffix() const; virtual voidTObject::AppendPad(Option_t* option = """"); voidRooAbsArg::attachDataSet(const RooAbsData& set); voidRooAbsArg::attachDataStore(const RooAbsDataStore& set); const set<string>&RooAbsArg::attributes() const; voidRooAbsArg::branchNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t recurseNonDerived = kFALSE) const; virtual voidTObject::Browse(TBrowser* b); virtual const char*RooAbsArg::cacheUniqueSuffix() const; virtual RooAbsArg::CacheModeRooAbsArg::canNodeBeCached() const; voidRooAbsArg::changeServer(RooAbsArg& server, Bool_t valueProp, Bool_t shapeProp); Bool_tRooAbsArg::checkDependents(const ",MatchSource.WIKI,root/html602/RooAbsCategory.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsCategory.html
https://root.cern/root/html602/RooAbsCategory.html:3353,Integrability,depend,dependentOverlaps,3353,"rg::clientIterator() const; virtual TObject*RooAbsArg::clone(const char* newname = 0) const; virtual TObject*RooAbsArg::Clone(const char* newname = 0) const; virtual RooAbsArg*RooAbsArg::cloneTree(const char* newname = 0) const; virtual Int_tRooAbsArg::Compare(const TObject* other) const; virtual voidRooAbsArg::constOptimizeTestStatistic(RooAbsArg::ConstOpCode opcode, Bool_t doAlsoTrackingOpt = kTRUE); virtual voidTNamed::Copy(TObject& named) const; static UInt_tRooAbsArg::crc32(const char* data); static UInt_tRooAbsArg::crc32(const char* data, ULong_t sz, UInt_t crc = 0); virtual RooAbsArg*createFundamental(const char* newname = 0) const; Roo1DTable*createTable(const char* label) const; virtual Int_tRooAbsArg::defaultPrintContents(Option_t* opt) const; static ostream&RooPrintable::defaultPrintStream(ostream* os = 0); virtual RooPrintable::StyleOptionRooPrintable::defaultPrintStyle(Option_t* opt) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; Bool_tRooAbsArg::dependentOverlaps(const RooAbsData* dset, const RooAbsArg& testArg) const; Bool_tRooAbsArg::dependentOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; Bool_tRooAbsArg::dependsOn(const RooAbsCollection& serverList, const RooAbsArg* ignoreArg = 0, Bool_t valueOnly = kFALSE) const; Bool_tRooAbsArg::dependsOn(const RooAbsArg& server, const RooAbsArg* ignoreArg = 0, Bool_t valueOnly = kFALSE) const; Bool_tRooAbsArg::dependsOnValue(const RooAbsCollection& serverList, const RooAbsArg* ignoreArg = 0) const; Bool_tRooAbsArg::dependsOnValue(const RooAbsArg& server, const RooAbsArg* ignoreArg = 0) const; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method,",MatchSource.WIKI,root/html602/RooAbsCategory.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsCategory.html
https://root.cern/root/html602/RooAbsCategory.html:3445,Integrability,depend,dependentOverlaps,3445," virtual TObject*RooAbsArg::Clone(const char* newname = 0) const; virtual RooAbsArg*RooAbsArg::cloneTree(const char* newname = 0) const; virtual Int_tRooAbsArg::Compare(const TObject* other) const; virtual voidRooAbsArg::constOptimizeTestStatistic(RooAbsArg::ConstOpCode opcode, Bool_t doAlsoTrackingOpt = kTRUE); virtual voidTNamed::Copy(TObject& named) const; static UInt_tRooAbsArg::crc32(const char* data); static UInt_tRooAbsArg::crc32(const char* data, ULong_t sz, UInt_t crc = 0); virtual RooAbsArg*createFundamental(const char* newname = 0) const; Roo1DTable*createTable(const char* label) const; virtual Int_tRooAbsArg::defaultPrintContents(Option_t* opt) const; static ostream&RooPrintable::defaultPrintStream(ostream* os = 0); virtual RooPrintable::StyleOptionRooPrintable::defaultPrintStyle(Option_t* opt) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; Bool_tRooAbsArg::dependentOverlaps(const RooAbsData* dset, const RooAbsArg& testArg) const; Bool_tRooAbsArg::dependentOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; Bool_tRooAbsArg::dependsOn(const RooAbsCollection& serverList, const RooAbsArg* ignoreArg = 0, Bool_t valueOnly = kFALSE) const; Bool_tRooAbsArg::dependsOn(const RooAbsArg& server, const RooAbsArg* ignoreArg = 0, Bool_t valueOnly = kFALSE) const; Bool_tRooAbsArg::dependsOnValue(const RooAbsCollection& serverList, const RooAbsArg* ignoreArg = 0) const; Bool_tRooAbsArg::dependsOnValue(const RooAbsArg& server, const RooAbsArg* ignoreArg = 0) const; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjAr",MatchSource.WIKI,root/html602/RooAbsCategory.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsCategory.html
https://root.cern/root/html602/RooAbsCategory.html:3539,Integrability,depend,dependsOn,3539,"Arg::cloneTree(const char* newname = 0) const; virtual Int_tRooAbsArg::Compare(const TObject* other) const; virtual voidRooAbsArg::constOptimizeTestStatistic(RooAbsArg::ConstOpCode opcode, Bool_t doAlsoTrackingOpt = kTRUE); virtual voidTNamed::Copy(TObject& named) const; static UInt_tRooAbsArg::crc32(const char* data); static UInt_tRooAbsArg::crc32(const char* data, ULong_t sz, UInt_t crc = 0); virtual RooAbsArg*createFundamental(const char* newname = 0) const; Roo1DTable*createTable(const char* label) const; virtual Int_tRooAbsArg::defaultPrintContents(Option_t* opt) const; static ostream&RooPrintable::defaultPrintStream(ostream* os = 0); virtual RooPrintable::StyleOptionRooPrintable::defaultPrintStyle(Option_t* opt) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; Bool_tRooAbsArg::dependentOverlaps(const RooAbsData* dset, const RooAbsArg& testArg) const; Bool_tRooAbsArg::dependentOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; Bool_tRooAbsArg::dependsOn(const RooAbsCollection& serverList, const RooAbsArg* ignoreArg = 0, Bool_t valueOnly = kFALSE) const; Bool_tRooAbsArg::dependsOn(const RooAbsArg& server, const RooAbsArg* ignoreArg = 0, Bool_t valueOnly = kFALSE) const; Bool_tRooAbsArg::dependsOnValue(const RooAbsCollection& serverList, const RooAbsArg* ignoreArg = 0) const; Bool_tRooAbsArg::dependsOnValue(const RooAbsArg& server, const RooAbsArg* ignoreArg = 0) const; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, I",MatchSource.WIKI,root/html602/RooAbsCategory.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsCategory.html
https://root.cern/root/html602/RooAbsCategory.html:3668,Integrability,depend,dependsOn,3668,"::constOptimizeTestStatistic(RooAbsArg::ConstOpCode opcode, Bool_t doAlsoTrackingOpt = kTRUE); virtual voidTNamed::Copy(TObject& named) const; static UInt_tRooAbsArg::crc32(const char* data); static UInt_tRooAbsArg::crc32(const char* data, ULong_t sz, UInt_t crc = 0); virtual RooAbsArg*createFundamental(const char* newname = 0) const; Roo1DTable*createTable(const char* label) const; virtual Int_tRooAbsArg::defaultPrintContents(Option_t* opt) const; static ostream&RooPrintable::defaultPrintStream(ostream* os = 0); virtual RooPrintable::StyleOptionRooPrintable::defaultPrintStyle(Option_t* opt) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; Bool_tRooAbsArg::dependentOverlaps(const RooAbsData* dset, const RooAbsArg& testArg) const; Bool_tRooAbsArg::dependentOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; Bool_tRooAbsArg::dependsOn(const RooAbsCollection& serverList, const RooAbsArg* ignoreArg = 0, Bool_t valueOnly = kFALSE) const; Bool_tRooAbsArg::dependsOn(const RooAbsArg& server, const RooAbsArg* ignoreArg = 0, Bool_t valueOnly = kFALSE) const; Bool_tRooAbsArg::dependsOnValue(const RooAbsCollection& serverList, const RooAbsArg* ignoreArg = 0) const; Bool_tRooAbsArg::dependsOnValue(const RooAbsArg& server, const RooAbsArg* ignoreArg = 0) const; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); RooExpensiveObjectCache&RooAbsArg::expensiveObjectCache() const; virtual voidTObject::Fatal(const char* method, const c",MatchSource.WIKI,root/html602/RooAbsCategory.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsCategory.html
https://root.cern/root/html602/RooAbsCategory.html:3786,Integrability,depend,dependsOnValue,3786,"TObject& named) const; static UInt_tRooAbsArg::crc32(const char* data); static UInt_tRooAbsArg::crc32(const char* data, ULong_t sz, UInt_t crc = 0); virtual RooAbsArg*createFundamental(const char* newname = 0) const; Roo1DTable*createTable(const char* label) const; virtual Int_tRooAbsArg::defaultPrintContents(Option_t* opt) const; static ostream&RooPrintable::defaultPrintStream(ostream* os = 0); virtual RooPrintable::StyleOptionRooPrintable::defaultPrintStyle(Option_t* opt) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; Bool_tRooAbsArg::dependentOverlaps(const RooAbsData* dset, const RooAbsArg& testArg) const; Bool_tRooAbsArg::dependentOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; Bool_tRooAbsArg::dependsOn(const RooAbsCollection& serverList, const RooAbsArg* ignoreArg = 0, Bool_t valueOnly = kFALSE) const; Bool_tRooAbsArg::dependsOn(const RooAbsArg& server, const RooAbsArg* ignoreArg = 0, Bool_t valueOnly = kFALSE) const; Bool_tRooAbsArg::dependsOnValue(const RooAbsCollection& serverList, const RooAbsArg* ignoreArg = 0) const; Bool_tRooAbsArg::dependsOnValue(const RooAbsArg& server, const RooAbsArg* ignoreArg = 0) const; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); RooExpensiveObjectCache&RooAbsArg::expensiveObjectCache() const; virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); Bool_tRooAbsArg::findConstantNodes(const RooArgSet& ob",MatchSource.WIKI,root/html602/RooAbsCategory.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsCategory.html
https://root.cern/root/html602/RooAbsCategory.html:3893,Integrability,depend,dependsOnValue,3893," char* data, ULong_t sz, UInt_t crc = 0); virtual RooAbsArg*createFundamental(const char* newname = 0) const; Roo1DTable*createTable(const char* label) const; virtual Int_tRooAbsArg::defaultPrintContents(Option_t* opt) const; static ostream&RooPrintable::defaultPrintStream(ostream* os = 0); virtual RooPrintable::StyleOptionRooPrintable::defaultPrintStyle(Option_t* opt) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; Bool_tRooAbsArg::dependentOverlaps(const RooAbsData* dset, const RooAbsArg& testArg) const; Bool_tRooAbsArg::dependentOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; Bool_tRooAbsArg::dependsOn(const RooAbsCollection& serverList, const RooAbsArg* ignoreArg = 0, Bool_t valueOnly = kFALSE) const; Bool_tRooAbsArg::dependsOn(const RooAbsArg& server, const RooAbsArg* ignoreArg = 0, Bool_t valueOnly = kFALSE) const; Bool_tRooAbsArg::dependsOnValue(const RooAbsCollection& serverList, const RooAbsArg* ignoreArg = 0) const; Bool_tRooAbsArg::dependsOnValue(const RooAbsArg& server, const RooAbsArg* ignoreArg = 0) const; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); RooExpensiveObjectCache&RooAbsArg::expensiveObjectCache() const; virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); Bool_tRooAbsArg::findConstantNodes(const RooArgSet& observables, RooArgSet& cacheList); Bool_tRooAbsArg::findConstantNodes(const RooArgSet& observables, RooArgSe",MatchSource.WIKI,root/html602/RooAbsCategory.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsCategory.html
https://root.cern/root/html602/RooAbsCategory.html:27153,Integrability,synchroniz,synchronize,27153,"os, Bool_t compact) const; Write object contents to ostream. void printValue(ostream& os) const; Print value (label name). void printMultiline(ostream& os, Int_t contents, Bool_t verbose = kFALSE, TString indent = """") const; Print info about this object to the specified stream. In addition to the info; from RooAbsArg::printStream() we add:. Shape : label, index, defined types. void attachToVStore(RooVectorDataStore& vstore); Attach the category index and label to as branches to the given vector store. void attachToTree(TTree& t, Int_t bufSize = 32000); Attach the category index and label to as branches to the given; TTree. The index field will be attached as integer with name; <name>_idx, the label field will be attached as char[] with label; <name>_lbl. void fillTreeBranch(TTree& t); Fill tree branches associated with current object with current value. void setTreeBranchStatus(TTree& t, Bool_t active); (De)activate associate tree branch. void syncCache(const RooArgSet* set = 0); Explicitly synchronize RooAbsCategory internal cache. void copyCache(const RooAbsArg* source, Bool_t valueOnly = kFALSE, Bool_t setValueDirty = kTRUE); Copy the cached value from given source and raise dirty flag.; It is the callers responsability to ensure that the sources; cache is clean(valid) before this function is called, e.g. by; calling syncCache() on the source. const RooCatType* getOrdinal(UInt_t n, const char* rangeName = 0) const; Return state definition of ordinal nth defined state,; needed by the generator mechanism. RooAbsArg * createFundamental(const char* newname = 0) const; Create a RooCategory fundamental object with our properties. Bool_t isSignType(Bool_t mustHaveZero = kFALSE) const; Determine if category has 2 or 3 states with index values -1,0,1. RooAbsCategory(); Constructors, assignment etc. Bool_t operator!=(Int_t index); { return !operator==(index);}. Bool_t operator!=(const char* label); { return !operator==(label);}. Bool_t operator!=(const RooAbsArg& other); {",MatchSource.WIKI,root/html602/RooAbsCategory.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsCategory.html
https://root.cern/root/html602/RooAbsCategory.html:28387,Integrability,integrat,integration,28387,"bel to as branches to the given; TTree. The index field will be attached as integer with name; <name>_idx, the label field will be attached as char[] with label; <name>_lbl. void fillTreeBranch(TTree& t); Fill tree branches associated with current object with current value. void setTreeBranchStatus(TTree& t, Bool_t active); (De)activate associate tree branch. void syncCache(const RooArgSet* set = 0); Explicitly synchronize RooAbsCategory internal cache. void copyCache(const RooAbsArg* source, Bool_t valueOnly = kFALSE, Bool_t setValueDirty = kTRUE); Copy the cached value from given source and raise dirty flag.; It is the callers responsability to ensure that the sources; cache is clean(valid) before this function is called, e.g. by; calling syncCache() on the source. const RooCatType* getOrdinal(UInt_t n, const char* rangeName = 0) const; Return state definition of ordinal nth defined state,; needed by the generator mechanism. RooAbsArg * createFundamental(const char* newname = 0) const; Create a RooCategory fundamental object with our properties. Bool_t isSignType(Bool_t mustHaveZero = kFALSE) const; Determine if category has 2 or 3 states with index values -1,0,1. RooAbsCategory(); Constructors, assignment etc. Bool_t operator!=(Int_t index); { return !operator==(index);}. Bool_t operator!=(const char* label); { return !operator==(label);}. Bool_t operator!=(const RooAbsArg& other); { return !operator==(other);}. Int_t numTypes(const char* = 0) const; Return number of types defined (in range named rangeName if rangeName!=0). Bool_t isIntegrationSafeLValue(const RooArgSet* ) const; Is this l-value object safe for use as integration observable. Bool_t traceEvalHook(RooCatType ) const; coverity[PASS_BY_VALUE]. RooCatType evaluate() const. » Last changed: Tue Jun 30 14:29:59 2015 » Last generated: 2015-06-30 14:29; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html602/RooAbsCategory.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsCategory.html
https://root.cern/root/html602/RooAbsCategory.html:1787,Performance,cache,cacheUniqueSuffix,1787," virtual~RooAbsCategory(); voidTObject::AbstractMethod(const char* method) const; Bool_tRooAbsArg::addOwnedComponents(const RooArgSet& comps); voidRooAbsArg::addParameters(RooArgSet& params, const RooArgSet* nset = 0, Bool_t stripDisconnected = kTRUE) const; voidRooAbsArg::addServer(RooAbsArg& server, Bool_t valueProp = kTRUE, Bool_t shapeProp = kFALSE); voidRooAbsArg::addServerList(RooAbsCollection& serverList, Bool_t valueProp = kTRUE, Bool_t shapeProp = kFALSE); const char*RooAbsArg::aggregateCacheUniqueSuffix() const; virtual voidTObject::AppendPad(Option_t* option = """"); voidRooAbsArg::attachDataSet(const RooAbsData& set); voidRooAbsArg::attachDataStore(const RooAbsDataStore& set); const set<string>&RooAbsArg::attributes() const; voidRooAbsArg::branchNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t recurseNonDerived = kFALSE) const; virtual voidTObject::Browse(TBrowser* b); virtual const char*RooAbsArg::cacheUniqueSuffix() const; virtual RooAbsArg::CacheModeRooAbsArg::canNodeBeCached() const; voidRooAbsArg::changeServer(RooAbsArg& server, Bool_t valueProp, Bool_t shapeProp); Bool_tRooAbsArg::checkDependents(const ",MatchSource.WIKI,root/html602/RooAbsCategory.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsCategory.html
https://root.cern/root/html602/RooAbsCategory.html:4816,Performance,cache,cacheList,4816,"on& serverList, const RooAbsArg* ignoreArg = 0) const; Bool_tRooAbsArg::dependsOnValue(const RooAbsArg& server, const RooAbsArg* ignoreArg = 0) const; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); RooExpensiveObjectCache&RooAbsArg::expensiveObjectCache() const; virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); Bool_tRooAbsArg::findConstantNodes(const RooArgSet& observables, RooArgSet& cacheList); Bool_tRooAbsArg::findConstantNodes(const RooArgSet& observables, RooArgSet& cacheList, RooLinkedList& processedNodes); RooAbsArg*RooAbsArg::findNewServer(const RooAbsCollection& newSet, Bool_t nameChange) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; RooAbsArg*RooAbsArg::findServer(const char* name) const; RooAbsArg*RooAbsArg::findServer(const RooAbsArg& arg) const; RooAbsArg*RooAbsArg::findServer(Int_t index) const; static UInt_tRooAbsArg::fnv1a32(const char* data); static UInt_tRooAbsArg::fnv1a32(const char* data, ULong_t sz, UInt_t hash = fnv1a32start); static ULong64_tRooAbsArg::fnv1a64(const char* data); static ULong64_tRooAbsArg::fnv1a64(const char* data, ULong_t sz, ULong64_t hash = fnv1a64start); Bool_tRooAbsArg::getAttribute(const Text_t* name) const; RooAbsCache*RooAbsArg::getCache(Int_t index) const; RooLinkedListRooAbsArg::getCloningAncestors() const; RooArgSet*RooAbsArg::getComponen",MatchSource.WIKI,root/html602/RooAbsCategory.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsCategory.html
https://root.cern/root/html602/RooAbsCategory.html:4904,Performance,cache,cacheList,4904,"onst RooAbsArg& server, const RooAbsArg* ignoreArg = 0) const; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); RooExpensiveObjectCache&RooAbsArg::expensiveObjectCache() const; virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); Bool_tRooAbsArg::findConstantNodes(const RooArgSet& observables, RooArgSet& cacheList); Bool_tRooAbsArg::findConstantNodes(const RooArgSet& observables, RooArgSet& cacheList, RooLinkedList& processedNodes); RooAbsArg*RooAbsArg::findNewServer(const RooAbsCollection& newSet, Bool_t nameChange) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; RooAbsArg*RooAbsArg::findServer(const char* name) const; RooAbsArg*RooAbsArg::findServer(const RooAbsArg& arg) const; RooAbsArg*RooAbsArg::findServer(Int_t index) const; static UInt_tRooAbsArg::fnv1a32(const char* data); static UInt_tRooAbsArg::fnv1a32(const char* data, ULong_t sz, UInt_t hash = fnv1a32start); static ULong64_tRooAbsArg::fnv1a64(const char* data); static ULong64_tRooAbsArg::fnv1a64(const char* data, ULong_t sz, ULong64_t hash = fnv1a64start); Bool_tRooAbsArg::getAttribute(const Text_t* name) const; RooAbsCache*RooAbsArg::getCache(Int_t index) const; RooLinkedListRooAbsArg::getCloningAncestors() const; RooArgSet*RooAbsArg::getComponents() const; RooArgSet*RooAbsArg::getDependents(const RooArgSet& set) const; RooArgSet*Ro",MatchSource.WIKI,root/html602/RooAbsCategory.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsCategory.html
https://root.cern/root/html602/RooAbsCategory.html:11259,Performance,optimiz,optimizeCacheMode,11259,"leOverlaps(const RooAbsData* dset, const RooAbsArg& testArg) const; Bool_tRooAbsArg::observableOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; voidTObject::operator delete(void* ptr); voidTObject::operator delete(void* ptr, void* vp); voidTObject::operator delete[](void* ptr); voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); Bool_toperator!=(Int_t index); Bool_toperator!=(const char* label); Bool_toperator!=(const RooAbsArg& other); RooAbsCategory&operator=(const RooAbsCategory&); Bool_toperator==(Int_t index) const; Bool_toperator==(const char* label) const; virtual Bool_toperator==(const RooAbsArg& other); RooAbsArg::OperModeRooAbsArg::operMode() const; virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables); virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables, RooArgSet& optNodes, RooLinkedList& processedNodes); Bool_tRooAbsArg::overlaps(const RooAbsArg& testArg, Bool_t valueOnly = kFALSE) const; const RooArgSet*RooAbsArg::ownedComponents() const; virtual voidTObject::Paint(Option_t* option = """"); virtual voidTObject::Pop(); virtual voidRooAbsArg::Print(Option_t* options = 0) const; virtual voidRooAbsArg::printAddress(ostream& os) const; virtual voidRooAbsArg::printArgs(ostream& os) const; virtual voidRooAbsArg::printClassName(ostream& os) const; voidRooAbsArg::printCompactTree(const char* indent = """", const char* fileName = 0, const char* namePat = 0, RooAbsArg* client = 0); voidRooAbsArg::printCompactTree(ostream& os, const char* indent = """", const char* namePat = 0, RooAbsArg* client = 0); virtual voidRooAbsArg::printCompactTreeHook(ostream& os, const char* ind = """"); voidRooAbsArg::printComponentTree(const char* indent = """", con",MatchSource.WIKI,root/html602/RooAbsCategory.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsCategory.html
https://root.cern/root/html602/RooAbsCategory.html:11331,Performance,optimiz,optimizeCacheMode,11331,"_tRooAbsArg::observableOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; voidTObject::operator delete(void* ptr); voidTObject::operator delete(void* ptr, void* vp); voidTObject::operator delete[](void* ptr); voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); Bool_toperator!=(Int_t index); Bool_toperator!=(const char* label); Bool_toperator!=(const RooAbsArg& other); RooAbsCategory&operator=(const RooAbsCategory&); Bool_toperator==(Int_t index) const; Bool_toperator==(const char* label) const; virtual Bool_toperator==(const RooAbsArg& other); RooAbsArg::OperModeRooAbsArg::operMode() const; virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables); virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables, RooArgSet& optNodes, RooLinkedList& processedNodes); Bool_tRooAbsArg::overlaps(const RooAbsArg& testArg, Bool_t valueOnly = kFALSE) const; const RooArgSet*RooAbsArg::ownedComponents() const; virtual voidTObject::Paint(Option_t* option = """"); virtual voidTObject::Pop(); virtual voidRooAbsArg::Print(Option_t* options = 0) const; virtual voidRooAbsArg::printAddress(ostream& os) const; virtual voidRooAbsArg::printArgs(ostream& os) const; virtual voidRooAbsArg::printClassName(ostream& os) const; voidRooAbsArg::printCompactTree(const char* indent = """", const char* fileName = 0, const char* namePat = 0, RooAbsArg* client = 0); voidRooAbsArg::printCompactTree(ostream& os, const char* indent = """", const char* namePat = 0, RooAbsArg* client = 0); virtual voidRooAbsArg::printCompactTreeHook(ostream& os, const char* ind = """"); voidRooAbsArg::printComponentTree(const char* indent = """", const char* namePat = 0, Int_t nLevel = 999); voidRooAbsArg::printDirty(Boo",MatchSource.WIKI,root/html602/RooAbsCategory.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsCategory.html
https://root.cern/root/html602/RooAbsCategory.html:13743,Performance,cache,cache,13743,"g indent = """") const; virtual voidRooAbsArg::printTitle(ostream& os) const; virtual voidRooAbsArg::printTree(ostream& os, TString indent = """") const; virtual voidprintValue(ostream& os) const; virtual Int_tTObject::Read(const char* name); virtual Bool_treadFromStream(istream& is, Bool_t compact, Bool_t verbose = kFALSE); Bool_tRooAbsArg::recursiveCheckDependents(const RooArgSet* nset) const; Bool_tRooAbsArg::recursiveCheckObservables(const RooArgSet* nset) const; Bool_tRooAbsArg::recursiveRedirectServers(const RooAbsCollection& newServerList, Bool_t mustReplaceAll = kFALSE, Bool_t nameChange = kFALSE, Bool_t recurseInNewSet = kTRUE); virtual voidTObject::RecursiveRemove(TObject* obj); Bool_tRooAbsArg::redirectServers(const RooAbsCollection& newServerList, Bool_t mustReplaceAll = kFALSE, Bool_t nameChange = kFALSE, Bool_t isRecursionStep = kFALSE); virtual Bool_tRooAbsArg::redirectServersHook(const RooAbsCollection&, Bool_t, Bool_t, Bool_t); voidRooAbsArg::registerCache(RooAbsCache& cache); voidRooAbsArg::removeServer(RooAbsArg& server, Bool_t force = kFALSE); voidRooAbsArg::replaceServer(RooAbsArg& oldServer, RooAbsArg& newServer, Bool_t valueProp, Bool_t shapeProp); voidTObject::ResetBit(UInt_t f); RooAbsCategory(); RooAbsCategory(const char* name, const char* title); RooAbsCategory(const RooAbsCategory& other, const char* name = 0); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); TIterator*RooAbsArg::serverIterator() const; RooFIterRooAbsArg::serverMIterator() const; virtual voidRooAbsArg::serverNameChangeHook(const RooAbsArg*, const RooAbsArg*); voidRooAbsArg::setAttribute(const Text_t* name, Bool_t value = kTRUE); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); virtual voidRooAbsArg::setCacheAndTrackHints(RooArgSet&); static voidRooAbsArg::setDirtyInhibit(Bool_t flag); virtual voidTObject::SetDrawOption(Option_t* option = """,MatchSource.WIKI,root/html602/RooAbsCategory.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsCategory.html
https://root.cern/root/html602/RooAbsCategory.html:14871,Performance,cache,cache,14871,"ooAbsArg& newServer, Bool_t valueProp, Bool_t shapeProp); voidTObject::ResetBit(UInt_t f); RooAbsCategory(); RooAbsCategory(const char* name, const char* title); RooAbsCategory(const RooAbsCategory& other, const char* name = 0); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); TIterator*RooAbsArg::serverIterator() const; RooFIterRooAbsArg::serverMIterator() const; virtual voidRooAbsArg::serverNameChangeHook(const RooAbsArg*, const RooAbsArg*); voidRooAbsArg::setAttribute(const Text_t* name, Bool_t value = kTRUE); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); virtual voidRooAbsArg::setCacheAndTrackHints(RooArgSet&); static voidRooAbsArg::setDirtyInhibit(Bool_t flag); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); virtual voidRooAbsArg::setExpensiveObjectCache(RooExpensiveObjectCache& cache); voidRooAbsArg::setLocalNoDirtyInhibit(Bool_t flag) const; virtual voidRooAbsArg::SetName(const char* name); virtual voidRooAbsArg::SetNameTitle(const char* name, const char* title); static voidTObject::SetObjectStat(Bool_t stat); voidRooAbsArg::setOperMode(RooAbsArg::OperMode mode, Bool_t recurseADirty = kTRUE); voidRooAbsArg::setProhibitServerRedirect(Bool_t flag); voidRooAbsArg::setShapeDirty() const; voidRooAbsArg::setStringAttribute(const Text_t* key, const Text_t* value); virtual voidTNamed::SetTitle(const char* title = """")MENU ; voidRooAbsArg::setTransientAttribute(const Text_t* name, Bool_t value = kTRUE); virtual voidTObject::SetUniqueID(UInt_t uid); voidRooAbsArg::setValueDirty() const; TIterator*RooAbsArg::shapeClientIterator() const; RooFIterRooAbsArg::shapeClientMIterator() const; virtual voidShowMembers(TMemberInspector& insp) const; virtual Int_tTNamed::Sizeof() const; virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); const m",MatchSource.WIKI,root/html602/RooAbsCategory.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsCategory.html
https://root.cern/root/html602/RooAbsCategory.html:16421,Performance,cache,cache,16421,"(const char* name); virtual voidRooAbsArg::SetNameTitle(const char* name, const char* title); static voidTObject::SetObjectStat(Bool_t stat); voidRooAbsArg::setOperMode(RooAbsArg::OperMode mode, Bool_t recurseADirty = kTRUE); voidRooAbsArg::setProhibitServerRedirect(Bool_t flag); voidRooAbsArg::setShapeDirty() const; voidRooAbsArg::setStringAttribute(const Text_t* key, const Text_t* value); virtual voidTNamed::SetTitle(const char* title = """")MENU ; voidRooAbsArg::setTransientAttribute(const Text_t* name, Bool_t value = kTRUE); virtual voidTObject::SetUniqueID(UInt_t uid); voidRooAbsArg::setValueDirty() const; TIterator*RooAbsArg::shapeClientIterator() const; RooFIterRooAbsArg::shapeClientMIterator() const; virtual voidShowMembers(TMemberInspector& insp) const; virtual Int_tTNamed::Sizeof() const; virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); const map<string,string>&RooAbsArg::stringAttributes() const; virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; const set<string>&RooAbsArg::transientAttributes() const; voidRooAbsArg::treeNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t doBranch = kTRUE, Bool_t doLeaf = kTRUE, Bool_t valueOnly = kFALSE, Bool_t recurseNonDerived = kFALSE) const; TIterator*typeIterator() const; voidRooAbsArg::unRegisterCache(RooAbsCache& cache); virtual voidTObject::UseCurrentStyle(); TIterator*RooAbsArg::valueClientIterator() const; RooFIterRooAbsArg::valueClientMIterator() const; static voidRooAbsArg::verboseDirty(Bool_t flag); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; voidRooAbsArg::wireAllCaches(); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const; virtual voidwriteToStream(ostream& os, Bool_t compact) const.",MatchSource.WIKI,root/html602/RooAbsCategory.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsCategory.html
https://root.cern/root/html602/RooAbsCategory.html:18280,Performance,optimiz,optimizeDirtyHook,18280," virtual voidattachToTree(TTree& t, Int_t bufSize = 32000); virtual voidattachToVStore(RooVectorDataStore& vstore); TStringRooAbsArg::cleanBranchName() const; voidclearTypes(); virtual voidcopyCache(const RooAbsArg* source, Bool_t valueOnly = kFALSE, Bool_t setValueDirty = kTRUE); const RooCatType*defineType(const char* label); const RooCatType*defineType(const char* label, Int_t index); const RooCatType*defineTypeUnchecked(const char* label, Int_t index); virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; virtual RooCatTypeevaluate() const; virtual voidfillTreeBranch(TTree& t); virtual voidRooAbsArg::getObservablesHook(const RooArgSet*, RooArgSet*) const; const RooCatType*getOrdinal(UInt_t n, const char* rangeName = 0) const; virtual voidRooAbsArg::getParametersHook(const RooArgSet*, RooArgSet*, Bool_t) const; RooAbsProxy*RooAbsArg::getProxy(Int_t index) const; voidRooAbsArg::graphVizAddConnections(set<pair<RooAbsArg*,RooAbsArg*> >&); Bool_tRooAbsArg::inhibitDirty() const; virtual Bool_tisValid() const; virtual Bool_tisValid(const RooCatType& value) const; voidTObject::MakeZombie(); Int_tRooAbsArg::numProxies() const; virtual voidRooAbsArg::operModeHook(); virtual voidRooAbsArg::optimizeDirtyHook(const RooArgSet*); voidRooAbsArg::printAttribList(ostream& os) const; voidRooAbsArg::registerProxy(RooArgProxy& proxy); voidRooAbsArg::registerProxy(RooSetProxy& proxy); voidRooAbsArg::registerProxy(RooListProxy& proxy); voidRooAbsArg::setProxyNormSet(const RooArgSet* nset); voidRooAbsArg::setShapeDirty(const RooAbsArg* source) const; virtual voidsetTreeBranchStatus(TTree& t, Bool_t active); voidRooAbsArg::setValueDirty(const RooAbsArg* source) const; virtual voidsyncCache(const RooArgSet* set = 0); RooCatTypetraceEval() const; virtual Bool_ttraceEvalHook(RooCatType) const; voidRooAbsArg::unRegisterProxy(RooArgProxy& proxy); voidRooAbsArg::unRegisterProxy(RooSetProxy& proxy); voidRooAbsArg::unRegisterProxy(RooListProxy& proxy).",MatchSource.WIKI,root/html602/RooAbsCategory.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsCategory.html
https://root.cern/root/html602/RooAbsCategory.html:21493,Performance,cache,cache,21493,eOptionRooPrintable::kStandard; static RooPrintable::ContentsOptionRooPrintable::kTitle; static RooPrintable::StyleOptionRooPrintable::kTreeStructure; static RooPrintable::ContentsOptionRooPrintable::kValue; static RooPrintable::StyleOptionRooPrintable::kVerbose; static TObject::(anonymous)TObject::kWriteDelete; static TObject::(anonymous)TObject::kZombie. protected:. set<string>RooAbsArg::_boolAttribBoolean attributes; set<string>RooAbsArg::_boolAttribTransient! Transient boolean attributes (not copied in ctor); UChar_t_byteValue! Transient cache for byte values from tree branches; deque<RooAbsCache*>RooAbsArg::_cacheListlist of caches; RooRefCountListRooAbsArg::_clientListlist of client objects; RooRefCountListRooAbsArg::_clientListShapesubset of clients that requested shape dirty flag propagation; RooRefCountListRooAbsArg::_clientListValuesubset of clients that requested value dirty flag propagation; TIterator*RooAbsArg::_clientShapeIter! Iterator over _clientListShape; TIterator*RooAbsArg::_clientValueIter! Iterator over _clientListValue; Bool_tRooAbsArg::_deleteWatch! Delete watch flag; RooExpensiveObjectCache*RooAbsArg::_eocachePointer to global cache manager for any expensive components created by this object; Bool_tRooAbsArg::_fastAllow fast access mode in getVal() and proxies; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; Bool_tRooAbsArg::_isConstant! Cached isConstant status; Bool_tRooAbsArg::_localNoInhibitDirty! Prevent 'AlwaysDirty' mode for this node; static Int_tRooPrintable::_nameLength; TNamed*RooAbsArg::_namePtr! Do not persist. Pointer to global instance of string that matches object named; RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; RooRefArrayRooAbsArg::_proxyListlist of proxies; RooRefCountListRooAbsArg::_serverList,MatchSource.WIKI,root/html602/RooAbsCategory.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsCategory.html
https://root.cern/root/html602/RooAbsCategory.html:21583,Performance,cache,caches,21583,eOptionRooPrintable::kStandard; static RooPrintable::ContentsOptionRooPrintable::kTitle; static RooPrintable::StyleOptionRooPrintable::kTreeStructure; static RooPrintable::ContentsOptionRooPrintable::kValue; static RooPrintable::StyleOptionRooPrintable::kVerbose; static TObject::(anonymous)TObject::kWriteDelete; static TObject::(anonymous)TObject::kZombie. protected:. set<string>RooAbsArg::_boolAttribBoolean attributes; set<string>RooAbsArg::_boolAttribTransient! Transient boolean attributes (not copied in ctor); UChar_t_byteValue! Transient cache for byte values from tree branches; deque<RooAbsCache*>RooAbsArg::_cacheListlist of caches; RooRefCountListRooAbsArg::_clientListlist of client objects; RooRefCountListRooAbsArg::_clientListShapesubset of clients that requested shape dirty flag propagation; RooRefCountListRooAbsArg::_clientListValuesubset of clients that requested value dirty flag propagation; TIterator*RooAbsArg::_clientShapeIter! Iterator over _clientListShape; TIterator*RooAbsArg::_clientValueIter! Iterator over _clientListValue; Bool_tRooAbsArg::_deleteWatch! Delete watch flag; RooExpensiveObjectCache*RooAbsArg::_eocachePointer to global cache manager for any expensive components created by this object; Bool_tRooAbsArg::_fastAllow fast access mode in getVal() and proxies; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; Bool_tRooAbsArg::_isConstant! Cached isConstant status; Bool_tRooAbsArg::_localNoInhibitDirty! Prevent 'AlwaysDirty' mode for this node; static Int_tRooPrintable::_nameLength; TNamed*RooAbsArg::_namePtr! Do not persist. Pointer to global instance of string that matches object named; RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; RooRefArrayRooAbsArg::_proxyListlist of proxies; RooRefCountListRooAbsArg::_serverList,MatchSource.WIKI,root/html602/RooAbsCategory.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsCategory.html
https://root.cern/root/html602/RooAbsCategory.html:22115,Performance,cache,cache,22115,eOptionRooPrintable::kStandard; static RooPrintable::ContentsOptionRooPrintable::kTitle; static RooPrintable::StyleOptionRooPrintable::kTreeStructure; static RooPrintable::ContentsOptionRooPrintable::kValue; static RooPrintable::StyleOptionRooPrintable::kVerbose; static TObject::(anonymous)TObject::kWriteDelete; static TObject::(anonymous)TObject::kZombie. protected:. set<string>RooAbsArg::_boolAttribBoolean attributes; set<string>RooAbsArg::_boolAttribTransient! Transient boolean attributes (not copied in ctor); UChar_t_byteValue! Transient cache for byte values from tree branches; deque<RooAbsCache*>RooAbsArg::_cacheListlist of caches; RooRefCountListRooAbsArg::_clientListlist of client objects; RooRefCountListRooAbsArg::_clientListShapesubset of clients that requested shape dirty flag propagation; RooRefCountListRooAbsArg::_clientListValuesubset of clients that requested value dirty flag propagation; TIterator*RooAbsArg::_clientShapeIter! Iterator over _clientListShape; TIterator*RooAbsArg::_clientValueIter! Iterator over _clientListValue; Bool_tRooAbsArg::_deleteWatch! Delete watch flag; RooExpensiveObjectCache*RooAbsArg::_eocachePointer to global cache manager for any expensive components created by this object; Bool_tRooAbsArg::_fastAllow fast access mode in getVal() and proxies; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; Bool_tRooAbsArg::_isConstant! Cached isConstant status; Bool_tRooAbsArg::_localNoInhibitDirty! Prevent 'AlwaysDirty' mode for this node; static Int_tRooPrintable::_nameLength; TNamed*RooAbsArg::_namePtr! Do not persist. Pointer to global instance of string that matches object named; RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; RooRefArrayRooAbsArg::_proxyListlist of proxies; RooRefCountListRooAbsArg::_serverList,MatchSource.WIKI,root/html602/RooAbsCategory.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsCategory.html
https://root.cern/root/html602/RooAbsCategory.html:27189,Performance,cache,cache,27189,"os, Bool_t compact) const; Write object contents to ostream. void printValue(ostream& os) const; Print value (label name). void printMultiline(ostream& os, Int_t contents, Bool_t verbose = kFALSE, TString indent = """") const; Print info about this object to the specified stream. In addition to the info; from RooAbsArg::printStream() we add:. Shape : label, index, defined types. void attachToVStore(RooVectorDataStore& vstore); Attach the category index and label to as branches to the given vector store. void attachToTree(TTree& t, Int_t bufSize = 32000); Attach the category index and label to as branches to the given; TTree. The index field will be attached as integer with name; <name>_idx, the label field will be attached as char[] with label; <name>_lbl. void fillTreeBranch(TTree& t); Fill tree branches associated with current object with current value. void setTreeBranchStatus(TTree& t, Bool_t active); (De)activate associate tree branch. void syncCache(const RooArgSet* set = 0); Explicitly synchronize RooAbsCategory internal cache. void copyCache(const RooAbsArg* source, Bool_t valueOnly = kFALSE, Bool_t setValueDirty = kTRUE); Copy the cached value from given source and raise dirty flag.; It is the callers responsability to ensure that the sources; cache is clean(valid) before this function is called, e.g. by; calling syncCache() on the source. const RooCatType* getOrdinal(UInt_t n, const char* rangeName = 0) const; Return state definition of ordinal nth defined state,; needed by the generator mechanism. RooAbsArg * createFundamental(const char* newname = 0) const; Create a RooCategory fundamental object with our properties. Bool_t isSignType(Bool_t mustHaveZero = kFALSE) const; Determine if category has 2 or 3 states with index values -1,0,1. RooAbsCategory(); Constructors, assignment etc. Bool_t operator!=(Int_t index); { return !operator==(index);}. Bool_t operator!=(const char* label); { return !operator==(label);}. Bool_t operator!=(const RooAbsArg& other); {",MatchSource.WIKI,root/html602/RooAbsCategory.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsCategory.html
https://root.cern/root/html602/RooAbsCategory.html:27303,Performance,cache,cached,27303,"printMultiline(ostream& os, Int_t contents, Bool_t verbose = kFALSE, TString indent = """") const; Print info about this object to the specified stream. In addition to the info; from RooAbsArg::printStream() we add:. Shape : label, index, defined types. void attachToVStore(RooVectorDataStore& vstore); Attach the category index and label to as branches to the given vector store. void attachToTree(TTree& t, Int_t bufSize = 32000); Attach the category index and label to as branches to the given; TTree. The index field will be attached as integer with name; <name>_idx, the label field will be attached as char[] with label; <name>_lbl. void fillTreeBranch(TTree& t); Fill tree branches associated with current object with current value. void setTreeBranchStatus(TTree& t, Bool_t active); (De)activate associate tree branch. void syncCache(const RooArgSet* set = 0); Explicitly synchronize RooAbsCategory internal cache. void copyCache(const RooAbsArg* source, Bool_t valueOnly = kFALSE, Bool_t setValueDirty = kTRUE); Copy the cached value from given source and raise dirty flag.; It is the callers responsability to ensure that the sources; cache is clean(valid) before this function is called, e.g. by; calling syncCache() on the source. const RooCatType* getOrdinal(UInt_t n, const char* rangeName = 0) const; Return state definition of ordinal nth defined state,; needed by the generator mechanism. RooAbsArg * createFundamental(const char* newname = 0) const; Create a RooCategory fundamental object with our properties. Bool_t isSignType(Bool_t mustHaveZero = kFALSE) const; Determine if category has 2 or 3 states with index values -1,0,1. RooAbsCategory(); Constructors, assignment etc. Bool_t operator!=(Int_t index); { return !operator==(index);}. Bool_t operator!=(const char* label); { return !operator==(label);}. Bool_t operator!=(const RooAbsArg& other); { return !operator==(other);}. Int_t numTypes(const char* = 0) const; Return number of types defined (in range named rangeName if",MatchSource.WIKI,root/html602/RooAbsCategory.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsCategory.html
https://root.cern/root/html602/RooAbsCategory.html:27418,Performance,cache,cache,27418,"ied stream. In addition to the info; from RooAbsArg::printStream() we add:. Shape : label, index, defined types. void attachToVStore(RooVectorDataStore& vstore); Attach the category index and label to as branches to the given vector store. void attachToTree(TTree& t, Int_t bufSize = 32000); Attach the category index and label to as branches to the given; TTree. The index field will be attached as integer with name; <name>_idx, the label field will be attached as char[] with label; <name>_lbl. void fillTreeBranch(TTree& t); Fill tree branches associated with current object with current value. void setTreeBranchStatus(TTree& t, Bool_t active); (De)activate associate tree branch. void syncCache(const RooArgSet* set = 0); Explicitly synchronize RooAbsCategory internal cache. void copyCache(const RooAbsArg* source, Bool_t valueOnly = kFALSE, Bool_t setValueDirty = kTRUE); Copy the cached value from given source and raise dirty flag.; It is the callers responsability to ensure that the sources; cache is clean(valid) before this function is called, e.g. by; calling syncCache() on the source. const RooCatType* getOrdinal(UInt_t n, const char* rangeName = 0) const; Return state definition of ordinal nth defined state,; needed by the generator mechanism. RooAbsArg * createFundamental(const char* newname = 0) const; Create a RooCategory fundamental object with our properties. Bool_t isSignType(Bool_t mustHaveZero = kFALSE) const; Determine if category has 2 or 3 states with index values -1,0,1. RooAbsCategory(); Constructors, assignment etc. Bool_t operator!=(Int_t index); { return !operator==(index);}. Bool_t operator!=(const char* label); { return !operator==(label);}. Bool_t operator!=(const RooAbsArg& other); { return !operator==(other);}. Int_t numTypes(const char* = 0) const; Return number of types defined (in range named rangeName if rangeName!=0). Bool_t isIntegrationSafeLValue(const RooArgSet* ) const; Is this l-value object safe for use as integration observable. Bool",MatchSource.WIKI,root/html602/RooAbsCategory.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsCategory.html
https://root.cern/root/html602/RooAbsCategory.html:28371,Safety,safe,safe,28371,"bel to as branches to the given; TTree. The index field will be attached as integer with name; <name>_idx, the label field will be attached as char[] with label; <name>_lbl. void fillTreeBranch(TTree& t); Fill tree branches associated with current object with current value. void setTreeBranchStatus(TTree& t, Bool_t active); (De)activate associate tree branch. void syncCache(const RooArgSet* set = 0); Explicitly synchronize RooAbsCategory internal cache. void copyCache(const RooAbsArg* source, Bool_t valueOnly = kFALSE, Bool_t setValueDirty = kTRUE); Copy the cached value from given source and raise dirty flag.; It is the callers responsability to ensure that the sources; cache is clean(valid) before this function is called, e.g. by; calling syncCache() on the source. const RooCatType* getOrdinal(UInt_t n, const char* rangeName = 0) const; Return state definition of ordinal nth defined state,; needed by the generator mechanism. RooAbsArg * createFundamental(const char* newname = 0) const; Create a RooCategory fundamental object with our properties. Bool_t isSignType(Bool_t mustHaveZero = kFALSE) const; Determine if category has 2 or 3 states with index values -1,0,1. RooAbsCategory(); Constructors, assignment etc. Bool_t operator!=(Int_t index); { return !operator==(index);}. Bool_t operator!=(const char* label); { return !operator==(label);}. Bool_t operator!=(const RooAbsArg& other); { return !operator==(other);}. Int_t numTypes(const char* = 0) const; Return number of types defined (in range named rangeName if rangeName!=0). Bool_t isIntegrationSafeLValue(const RooArgSet* ) const; Is this l-value object safe for use as integration observable. Bool_t traceEvalHook(RooCatType ) const; coverity[PASS_BY_VALUE]. RooCatType evaluate() const. » Last changed: Tue Jun 30 14:29:59 2015 » Last generated: 2015-06-30 14:29; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html602/RooAbsCategory.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsCategory.html
https://root.cern/root/html602/RooAbsCategory.html:5454,Security,hash,hash,5454,"y* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); RooExpensiveObjectCache&RooAbsArg::expensiveObjectCache() const; virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); Bool_tRooAbsArg::findConstantNodes(const RooArgSet& observables, RooArgSet& cacheList); Bool_tRooAbsArg::findConstantNodes(const RooArgSet& observables, RooArgSet& cacheList, RooLinkedList& processedNodes); RooAbsArg*RooAbsArg::findNewServer(const RooAbsCollection& newSet, Bool_t nameChange) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; RooAbsArg*RooAbsArg::findServer(const char* name) const; RooAbsArg*RooAbsArg::findServer(const RooAbsArg& arg) const; RooAbsArg*RooAbsArg::findServer(Int_t index) const; static UInt_tRooAbsArg::fnv1a32(const char* data); static UInt_tRooAbsArg::fnv1a32(const char* data, ULong_t sz, UInt_t hash = fnv1a32start); static ULong64_tRooAbsArg::fnv1a64(const char* data); static ULong64_tRooAbsArg::fnv1a64(const char* data, ULong_t sz, ULong64_t hash = fnv1a64start); Bool_tRooAbsArg::getAttribute(const Text_t* name) const; RooAbsCache*RooAbsArg::getCache(Int_t index) const; RooLinkedListRooAbsArg::getCloningAncestors() const; RooArgSet*RooAbsArg::getComponents() const; RooArgSet*RooAbsArg::getDependents(const RooArgSet& set) const; RooArgSet*RooAbsArg::getDependents(const RooAbsData* set) const; RooArgSet*RooAbsArg::getDependents(const RooArgSet* depList) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual Int_tgetIndex() const; virtual const char*getLabel() const; virtual const char*TNamed::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); RooArgSet*RooAbsArg::getObservables(const RooAbsData* data) const; RooArgSet*R",MatchSource.WIKI,root/html602/RooAbsCategory.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsCategory.html
https://root.cern/root/html602/RooAbsCategory.html:5605,Security,hash,hash,5605,"he() const; virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); Bool_tRooAbsArg::findConstantNodes(const RooArgSet& observables, RooArgSet& cacheList); Bool_tRooAbsArg::findConstantNodes(const RooArgSet& observables, RooArgSet& cacheList, RooLinkedList& processedNodes); RooAbsArg*RooAbsArg::findNewServer(const RooAbsCollection& newSet, Bool_t nameChange) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; RooAbsArg*RooAbsArg::findServer(const char* name) const; RooAbsArg*RooAbsArg::findServer(const RooAbsArg& arg) const; RooAbsArg*RooAbsArg::findServer(Int_t index) const; static UInt_tRooAbsArg::fnv1a32(const char* data); static UInt_tRooAbsArg::fnv1a32(const char* data, ULong_t sz, UInt_t hash = fnv1a32start); static ULong64_tRooAbsArg::fnv1a64(const char* data); static ULong64_tRooAbsArg::fnv1a64(const char* data, ULong_t sz, ULong64_t hash = fnv1a64start); Bool_tRooAbsArg::getAttribute(const Text_t* name) const; RooAbsCache*RooAbsArg::getCache(Int_t index) const; RooLinkedListRooAbsArg::getCloningAncestors() const; RooArgSet*RooAbsArg::getComponents() const; RooArgSet*RooAbsArg::getDependents(const RooArgSet& set) const; RooArgSet*RooAbsArg::getDependents(const RooAbsData* set) const; RooArgSet*RooAbsArg::getDependents(const RooArgSet* depList) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual Int_tgetIndex() const; virtual const char*getLabel() const; virtual const char*TNamed::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); RooArgSet*RooAbsArg::getObservables(const RooAbsData* data) const; RooArgSet*RooAbsArg::getObservables(const RooAbsData& data) const; RooArgSet*RooAbsArg::getObservables(const RooArgSet& set, Bool_t valueOnly = kTRUE) const; RooA",MatchSource.WIKI,root/html602/RooAbsCategory.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsCategory.html
https://root.cern/root/html602/RooAbsCategory.html:22215,Security,access,access,22215,eOptionRooPrintable::kStandard; static RooPrintable::ContentsOptionRooPrintable::kTitle; static RooPrintable::StyleOptionRooPrintable::kTreeStructure; static RooPrintable::ContentsOptionRooPrintable::kValue; static RooPrintable::StyleOptionRooPrintable::kVerbose; static TObject::(anonymous)TObject::kWriteDelete; static TObject::(anonymous)TObject::kZombie. protected:. set<string>RooAbsArg::_boolAttribBoolean attributes; set<string>RooAbsArg::_boolAttribTransient! Transient boolean attributes (not copied in ctor); UChar_t_byteValue! Transient cache for byte values from tree branches; deque<RooAbsCache*>RooAbsArg::_cacheListlist of caches; RooRefCountListRooAbsArg::_clientListlist of client objects; RooRefCountListRooAbsArg::_clientListShapesubset of clients that requested shape dirty flag propagation; RooRefCountListRooAbsArg::_clientListValuesubset of clients that requested value dirty flag propagation; TIterator*RooAbsArg::_clientShapeIter! Iterator over _clientListShape; TIterator*RooAbsArg::_clientValueIter! Iterator over _clientListValue; Bool_tRooAbsArg::_deleteWatch! Delete watch flag; RooExpensiveObjectCache*RooAbsArg::_eocachePointer to global cache manager for any expensive components created by this object; Bool_tRooAbsArg::_fastAllow fast access mode in getVal() and proxies; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; Bool_tRooAbsArg::_isConstant! Cached isConstant status; Bool_tRooAbsArg::_localNoInhibitDirty! Prevent 'AlwaysDirty' mode for this node; static Int_tRooPrintable::_nameLength; TNamed*RooAbsArg::_namePtr! Do not persist. Pointer to global instance of string that matches object named; RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; RooRefArrayRooAbsArg::_proxyListlist of proxies; RooRefCountListRooAbsArg::_serverList,MatchSource.WIKI,root/html602/RooAbsCategory.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsCategory.html
https://root.cern/root/html602/RooAbsCategory.html:3412,Testability,test,testArg,3412,":clone(const char* newname = 0) const; virtual TObject*RooAbsArg::Clone(const char* newname = 0) const; virtual RooAbsArg*RooAbsArg::cloneTree(const char* newname = 0) const; virtual Int_tRooAbsArg::Compare(const TObject* other) const; virtual voidRooAbsArg::constOptimizeTestStatistic(RooAbsArg::ConstOpCode opcode, Bool_t doAlsoTrackingOpt = kTRUE); virtual voidTNamed::Copy(TObject& named) const; static UInt_tRooAbsArg::crc32(const char* data); static UInt_tRooAbsArg::crc32(const char* data, ULong_t sz, UInt_t crc = 0); virtual RooAbsArg*createFundamental(const char* newname = 0) const; Roo1DTable*createTable(const char* label) const; virtual Int_tRooAbsArg::defaultPrintContents(Option_t* opt) const; static ostream&RooPrintable::defaultPrintStream(ostream* os = 0); virtual RooPrintable::StyleOptionRooPrintable::defaultPrintStyle(Option_t* opt) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; Bool_tRooAbsArg::dependentOverlaps(const RooAbsData* dset, const RooAbsArg& testArg) const; Bool_tRooAbsArg::dependentOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; Bool_tRooAbsArg::dependsOn(const RooAbsCollection& serverList, const RooAbsArg* ignoreArg = 0, Bool_t valueOnly = kFALSE) const; Bool_tRooAbsArg::dependsOn(const RooAbsArg& server, const RooAbsArg* ignoreArg = 0, Bool_t valueOnly = kFALSE) const; Bool_tRooAbsArg::dependsOnValue(const RooAbsCollection& serverList, const RooAbsArg* ignoreArg = 0) const; Bool_tRooAbsArg::dependsOnValue(const RooAbsArg& server, const RooAbsArg* ignoreArg = 0) const; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTO",MatchSource.WIKI,root/html602/RooAbsCategory.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsCategory.html
https://root.cern/root/html602/RooAbsCategory.html:3506,Testability,test,testArg,3506,"0) const; virtual RooAbsArg*RooAbsArg::cloneTree(const char* newname = 0) const; virtual Int_tRooAbsArg::Compare(const TObject* other) const; virtual voidRooAbsArg::constOptimizeTestStatistic(RooAbsArg::ConstOpCode opcode, Bool_t doAlsoTrackingOpt = kTRUE); virtual voidTNamed::Copy(TObject& named) const; static UInt_tRooAbsArg::crc32(const char* data); static UInt_tRooAbsArg::crc32(const char* data, ULong_t sz, UInt_t crc = 0); virtual RooAbsArg*createFundamental(const char* newname = 0) const; Roo1DTable*createTable(const char* label) const; virtual Int_tRooAbsArg::defaultPrintContents(Option_t* opt) const; static ostream&RooPrintable::defaultPrintStream(ostream* os = 0); virtual RooPrintable::StyleOptionRooPrintable::defaultPrintStyle(Option_t* opt) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; Bool_tRooAbsArg::dependentOverlaps(const RooAbsData* dset, const RooAbsArg& testArg) const; Bool_tRooAbsArg::dependentOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; Bool_tRooAbsArg::dependsOn(const RooAbsCollection& serverList, const RooAbsArg* ignoreArg = 0, Bool_t valueOnly = kFALSE) const; Bool_tRooAbsArg::dependsOn(const RooAbsArg& server, const RooAbsArg* ignoreArg = 0, Bool_t valueOnly = kFALSE) const; Bool_tRooAbsArg::dependsOnValue(const RooAbsCollection& serverList, const RooAbsArg* ignoreArg = 0) const; Bool_tRooAbsArg::dependsOnValue(const RooAbsArg& server, const RooAbsArg* ignoreArg = 0) const; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::Exe",MatchSource.WIKI,root/html602/RooAbsCategory.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsCategory.html
https://root.cern/root/html602/RooAbsCategory.html:10320,Testability,test,testArg,10320,"ooAbsArg::isValueOrShapeDirtyAndClear() const; Bool_tRooAbsArg::isValueServer(const RooAbsArg& arg) const; Bool_tRooAbsArg::isValueServer(const char* name) const; Bool_tTObject::IsZombie() const; voidRooAbsArg::leafNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t recurseNonDerived = kFALSE) const; Bool_tRooAbsArg::localNoDirtyInhibit() const; const RooCatType*lookupType(Int_t index, Bool_t printError = kFALSE) const; const RooCatType*lookupType(const char* label, Bool_t printError = kFALSE) const; const RooCatType*lookupType(const RooCatType& type, Bool_t printError = kFALSE) const; virtual voidTNamed::ls(Option_t* option = """") const; voidTObject::MayNotUse(const char* method) const; static voidRooPrintable::nameFieldLength(Int_t newLen); const TNamed*RooAbsArg::namePtr() const; virtual Bool_tTObject::Notify(); Int_tRooAbsArg::numCaches() const; Int_tnumTypes(const char* = 0) const; Bool_tRooAbsArg::observableOverlaps(const RooAbsData* dset, const RooAbsArg& testArg) const; Bool_tRooAbsArg::observableOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; voidTObject::operator delete(void* ptr); voidTObject::operator delete(void* ptr, void* vp); voidTObject::operator delete[](void* ptr); voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); Bool_toperator!=(Int_t index); Bool_toperator!=(const char* label); Bool_toperator!=(const RooAbsArg& other); RooAbsCategory&operator=(const RooAbsCategory&); Bool_toperator==(Int_t index) const; Bool_toperator==(const char* label) const; virtual Bool_toperator==(const RooAbsArg& other); RooAbsArg::OperModeRooAbsArg::operMode() const; virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables); virtual voidRooA",MatchSource.WIKI,root/html602/RooAbsCategory.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsCategory.html
https://root.cern/root/html602/RooAbsCategory.html:10415,Testability,test,testArg,10415,"arg) const; Bool_tRooAbsArg::isValueServer(const char* name) const; Bool_tTObject::IsZombie() const; voidRooAbsArg::leafNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t recurseNonDerived = kFALSE) const; Bool_tRooAbsArg::localNoDirtyInhibit() const; const RooCatType*lookupType(Int_t index, Bool_t printError = kFALSE) const; const RooCatType*lookupType(const char* label, Bool_t printError = kFALSE) const; const RooCatType*lookupType(const RooCatType& type, Bool_t printError = kFALSE) const; virtual voidTNamed::ls(Option_t* option = """") const; voidTObject::MayNotUse(const char* method) const; static voidRooPrintable::nameFieldLength(Int_t newLen); const TNamed*RooAbsArg::namePtr() const; virtual Bool_tTObject::Notify(); Int_tRooAbsArg::numCaches() const; Int_tnumTypes(const char* = 0) const; Bool_tRooAbsArg::observableOverlaps(const RooAbsData* dset, const RooAbsArg& testArg) const; Bool_tRooAbsArg::observableOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; voidTObject::operator delete(void* ptr); voidTObject::operator delete(void* ptr, void* vp); voidTObject::operator delete[](void* ptr); voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); Bool_toperator!=(Int_t index); Bool_toperator!=(const char* label); Bool_toperator!=(const RooAbsArg& other); RooAbsCategory&operator=(const RooAbsCategory&); Bool_toperator==(Int_t index) const; Bool_toperator==(const char* label) const; virtual Bool_toperator==(const RooAbsArg& other); RooAbsArg::OperModeRooAbsArg::operMode() const; virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables); virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables, RooArgSet& optNodes, RooLinkedList& proc",MatchSource.WIKI,root/html602/RooAbsCategory.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsCategory.html
https://root.cern/root/html602/RooAbsCategory.html:11475,Testability,test,testArg,11475,"char* asOfVers, const char* removedFromVers) const; voidTObject::operator delete(void* ptr); voidTObject::operator delete(void* ptr, void* vp); voidTObject::operator delete[](void* ptr); voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); Bool_toperator!=(Int_t index); Bool_toperator!=(const char* label); Bool_toperator!=(const RooAbsArg& other); RooAbsCategory&operator=(const RooAbsCategory&); Bool_toperator==(Int_t index) const; Bool_toperator==(const char* label) const; virtual Bool_toperator==(const RooAbsArg& other); RooAbsArg::OperModeRooAbsArg::operMode() const; virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables); virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables, RooArgSet& optNodes, RooLinkedList& processedNodes); Bool_tRooAbsArg::overlaps(const RooAbsArg& testArg, Bool_t valueOnly = kFALSE) const; const RooArgSet*RooAbsArg::ownedComponents() const; virtual voidTObject::Paint(Option_t* option = """"); virtual voidTObject::Pop(); virtual voidRooAbsArg::Print(Option_t* options = 0) const; virtual voidRooAbsArg::printAddress(ostream& os) const; virtual voidRooAbsArg::printArgs(ostream& os) const; virtual voidRooAbsArg::printClassName(ostream& os) const; voidRooAbsArg::printCompactTree(const char* indent = """", const char* fileName = 0, const char* namePat = 0, RooAbsArg* client = 0); voidRooAbsArg::printCompactTree(ostream& os, const char* indent = """", const char* namePat = 0, RooAbsArg* client = 0); virtual voidRooAbsArg::printCompactTreeHook(ostream& os, const char* ind = """"); voidRooAbsArg::printComponentTree(const char* indent = """", const char* namePat = 0, Int_t nLevel = 999); voidRooAbsArg::printDirty(Bool_t depth = kTRUE) const; virtual voidRooPrintable::printExtras(ostream& os) const; virtual voidRooAbsArg::printMetaArgs(ostream&) const; v",MatchSource.WIKI,root/html602/RooAbsCategory.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsCategory.html
https://root.cern/root/html602/RooAbsCategory.html:2232,Usability,clear,clearShapeDirty,2232,"tion& serverList, Bool_t valueProp = kTRUE, Bool_t shapeProp = kFALSE); const char*RooAbsArg::aggregateCacheUniqueSuffix() const; virtual voidTObject::AppendPad(Option_t* option = """"); voidRooAbsArg::attachDataSet(const RooAbsData& set); voidRooAbsArg::attachDataStore(const RooAbsDataStore& set); const set<string>&RooAbsArg::attributes() const; voidRooAbsArg::branchNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t recurseNonDerived = kFALSE) const; virtual voidTObject::Browse(TBrowser* b); virtual const char*RooAbsArg::cacheUniqueSuffix() const; virtual RooAbsArg::CacheModeRooAbsArg::canNodeBeCached() const; voidRooAbsArg::changeServer(RooAbsArg& server, Bool_t valueProp, Bool_t shapeProp); Bool_tRooAbsArg::checkDependents(const RooArgSet* nset) const; virtual Bool_tRooAbsArg::checkObservables(const RooArgSet* nset) const; static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); voidRooAbsArg::clearShapeDirty() const; voidRooAbsArg::clearValueAndShapeDirty() const; voidRooAbsArg::clearValueDirty() const; TIterator*RooAbsArg::clientIterator() const; virtual TObject*RooAbsArg::clone(const char* newname = 0) const; virtual TObject*RooAbsArg::Clone(const char* newname = 0) const; virtual RooAbsArg*RooAbsArg::cloneTree(const char* newname = 0) const; virtual Int_tRooAbsArg::Compare(const TObject* other) const; virtual voidRooAbsArg::constOptimizeTestStatistic(RooAbsArg::ConstOpCode opcode, Bool_t doAlsoTrackingOpt = kTRUE); virtual voidTNamed::Copy(TObject& named) const; static UInt_tRooAbsArg::crc32(const char* data); static UInt_tRooAbsArg::crc32(const char* data, ULong_t sz, UInt_t crc = 0); virtual RooAbsArg*createFundamental(const char* newname = 0) const; Roo1DTable*createTable(const char* label) const; virtual Int_tRooAbsArg::defaultPrintContents(Option_t* opt) const; static ostream&RooPrintable::defaultPrintStream(ostream* os = 0); virtual RooPrintable::StyleOptionRooPrintable::d",MatchSource.WIKI,root/html602/RooAbsCategory.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsCategory.html
https://root.cern/root/html602/RooAbsCategory.html:2272,Usability,clear,clearValueAndShapeDirty,2272,"Bool_t shapeProp = kFALSE); const char*RooAbsArg::aggregateCacheUniqueSuffix() const; virtual voidTObject::AppendPad(Option_t* option = """"); voidRooAbsArg::attachDataSet(const RooAbsData& set); voidRooAbsArg::attachDataStore(const RooAbsDataStore& set); const set<string>&RooAbsArg::attributes() const; voidRooAbsArg::branchNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t recurseNonDerived = kFALSE) const; virtual voidTObject::Browse(TBrowser* b); virtual const char*RooAbsArg::cacheUniqueSuffix() const; virtual RooAbsArg::CacheModeRooAbsArg::canNodeBeCached() const; voidRooAbsArg::changeServer(RooAbsArg& server, Bool_t valueProp, Bool_t shapeProp); Bool_tRooAbsArg::checkDependents(const RooArgSet* nset) const; virtual Bool_tRooAbsArg::checkObservables(const RooArgSet* nset) const; static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); voidRooAbsArg::clearShapeDirty() const; voidRooAbsArg::clearValueAndShapeDirty() const; voidRooAbsArg::clearValueDirty() const; TIterator*RooAbsArg::clientIterator() const; virtual TObject*RooAbsArg::clone(const char* newname = 0) const; virtual TObject*RooAbsArg::Clone(const char* newname = 0) const; virtual RooAbsArg*RooAbsArg::cloneTree(const char* newname = 0) const; virtual Int_tRooAbsArg::Compare(const TObject* other) const; virtual voidRooAbsArg::constOptimizeTestStatistic(RooAbsArg::ConstOpCode opcode, Bool_t doAlsoTrackingOpt = kTRUE); virtual voidTNamed::Copy(TObject& named) const; static UInt_tRooAbsArg::crc32(const char* data); static UInt_tRooAbsArg::crc32(const char* data, ULong_t sz, UInt_t crc = 0); virtual RooAbsArg*createFundamental(const char* newname = 0) const; Roo1DTable*createTable(const char* label) const; virtual Int_tRooAbsArg::defaultPrintContents(Option_t* opt) const; static ostream&RooPrintable::defaultPrintStream(ostream* os = 0); virtual RooPrintable::StyleOptionRooPrintable::defaultPrintStyle(Option_t* opt) const; virtu",MatchSource.WIKI,root/html602/RooAbsCategory.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsCategory.html
https://root.cern/root/html602/RooAbsCategory.html:2320,Usability,clear,clearValueDirty,2320,"sArg::aggregateCacheUniqueSuffix() const; virtual voidTObject::AppendPad(Option_t* option = """"); voidRooAbsArg::attachDataSet(const RooAbsData& set); voidRooAbsArg::attachDataStore(const RooAbsDataStore& set); const set<string>&RooAbsArg::attributes() const; voidRooAbsArg::branchNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t recurseNonDerived = kFALSE) const; virtual voidTObject::Browse(TBrowser* b); virtual const char*RooAbsArg::cacheUniqueSuffix() const; virtual RooAbsArg::CacheModeRooAbsArg::canNodeBeCached() const; voidRooAbsArg::changeServer(RooAbsArg& server, Bool_t valueProp, Bool_t shapeProp); Bool_tRooAbsArg::checkDependents(const RooArgSet* nset) const; virtual Bool_tRooAbsArg::checkObservables(const RooArgSet* nset) const; static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); voidRooAbsArg::clearShapeDirty() const; voidRooAbsArg::clearValueAndShapeDirty() const; voidRooAbsArg::clearValueDirty() const; TIterator*RooAbsArg::clientIterator() const; virtual TObject*RooAbsArg::clone(const char* newname = 0) const; virtual TObject*RooAbsArg::Clone(const char* newname = 0) const; virtual RooAbsArg*RooAbsArg::cloneTree(const char* newname = 0) const; virtual Int_tRooAbsArg::Compare(const TObject* other) const; virtual voidRooAbsArg::constOptimizeTestStatistic(RooAbsArg::ConstOpCode opcode, Bool_t doAlsoTrackingOpt = kTRUE); virtual voidTNamed::Copy(TObject& named) const; static UInt_tRooAbsArg::crc32(const char* data); static UInt_tRooAbsArg::crc32(const char* data, ULong_t sz, UInt_t crc = 0); virtual RooAbsArg*createFundamental(const char* newname = 0) const; Roo1DTable*createTable(const char* label) const; virtual Int_tRooAbsArg::defaultPrintContents(Option_t* opt) const; static ostream&RooPrintable::defaultPrintStream(ostream* os = 0); virtual RooPrintable::StyleOptionRooPrintable::defaultPrintStyle(Option_t* opt) const; virtual voidTObject::Delete(Option_t* option = """"",MatchSource.WIKI,root/html602/RooAbsCategory.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsCategory.html
https://root.cern/root/html602/RooAbsCategory.html:25201,Usability,clear,clearTypes,25201,"compares with state index number). Bool_t operator==(const char* label) const; Equality operator with a string (compares with state label string). Bool_t operator==(const RooAbsArg& other); Equality operator with another RooAbsArg. Only functional; is also a RooAbsCategory, will return true if index is the same. Bool_t isIdentical(const RooAbsArg& other, Bool_t assumeSameType = kFALSE). Bool_t isValidIndex(Int_t index) const; Check if state with given index is defined. Bool_t isValidLabel(const char* label) const; Check if state with given name is defined. const RooCatType* defineType(const char* label); Define a new state with given name. The lowest available; integer number is assigned as index value. const RooCatType* defineTypeUnchecked(const char* label, Int_t index); Internal version of defineType that does not check if type; already exists. const RooCatType* defineType(const char* label, Int_t index); Define new state with given name and index number. void clearTypes(); Delete all currently defined states. const RooCatType* lookupType(const RooCatType& type, Bool_t printError = kFALSE) const; Find our type that matches the specified type, or return 0 for no match. const RooCatType* lookupType(Int_t index, Bool_t printError = kFALSE) const; Find our type corresponding to the specified index, or return 0 for no match. const RooCatType* lookupType(const char* label, Bool_t printError = kFALSE) const; Find our type corresponding to the specified label, or return 0 for no match. Bool_t isValid() const; Check if current value is a valid state. Bool_t isValid(const RooCatType& value) const; Check if given state is defined for this object. Roo1DTable* createTable(const char* label) const; Create a table matching the shape of this category. Bool_t readFromStream(istream& is, Bool_t compact, Bool_t verbose = kFALSE); Read object contents from stream (dummy for now). void writeToStream(ostream& os, Bool_t compact) const; Write object contents to ostream. void printValue",MatchSource.WIKI,root/html602/RooAbsCategory.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsCategory.html
https://root.cern/root/html602/RooAbsCategoryLValue.html:872,Availability,avail,available,872,". RooAbsCategoryLValue. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » ROOFIT; » ROOFITCORE; » RooAbsCategoryLValue. class RooAbsCategoryLValue: public RooAbsCategory, public RooAbsLValue. RooAbsCategoryLValue is the common abstract base class for objects that represent a; discrete value that may appear on the left hand side of an equation ('lvalue'); Each implementation must provide setIndex()/setLabel() members to allow direct modification ; of the value. RooAbsCategoryLValue may be derived, but its functional relation; to other RooAbsArgs must be invertible; . Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~RooAbsCategoryLValue(); voidTObject::AbstractMethod(const char* method) const; Bool_tRooAbsArg::addOwnedComponents(const RooArgSet& comps); voidRooAbsArg::addParameters(RooArgSet& params, const RooArgSet* nset = 0, Bool_t stripDisconnected = kTRUE) const; voidRooAbsArg::addServer(RooAbsArg& server, Bool_t valueProp = kTRUE, Bool_t shapeProp = kFALSE); voidRooAbsArg::addServerList(RooAbsCollection& serverList, Bool_t valueProp = kTRUE, Bool_t shapeProp = kFALSE); const char*RooAbsArg::aggregateCacheUniqueSuffix() const; virtual voidTObject::AppendPad(Option_t* option = """"); voidRooAbsArg::attachDataSet(const RooAbsData& set); voidRooAbsArg::attachDataStore(const RooAbsDataStore& set); const set<string>&RooAbsArg::attributes() const; voidRooAbsArg::branchNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t recurseNonDerived = kFALSE) const; virtual voidTObject::Browse(TBrowser* b); virtual const char*RooAbsArg::cacheUniqueSuffix() const; virtual RooAbsArg::CacheModeRooAbsArg::canNodeBeCached() const; voidRooAbsArg::changeServer(RooAbsArg& server, Bool_t ",MatchSource.WIKI,root/html602/RooAbsCategoryLValue.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsCategoryLValue.html
https://root.cern/root/html602/RooAbsCategoryLValue.html:4491,Availability,error,error,4491,", const RooAbsArg& testArg) const; Bool_tRooAbsArg::dependentOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; Bool_tRooAbsArg::dependsOn(const RooAbsCollection& serverList, const RooAbsArg* ignoreArg = 0, Bool_t valueOnly = kFALSE) const; Bool_tRooAbsArg::dependsOn(const RooAbsArg& server, const RooAbsArg* ignoreArg = 0, Bool_t valueOnly = kFALSE) const; Bool_tRooAbsArg::dependsOnValue(const RooAbsCollection& serverList, const RooAbsArg* ignoreArg = 0) const; Bool_tRooAbsArg::dependsOnValue(const RooAbsArg& server, const RooAbsArg* ignoreArg = 0) const; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); RooExpensiveObjectCache&RooAbsArg::expensiveObjectCache() const; virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); Bool_tRooAbsArg::findConstantNodes(const RooArgSet& observables, RooArgSet& cacheList); Bool_tRooAbsArg::findConstantNodes(const RooArgSet& observables, RooArgSet& cacheList, RooLinkedList& processedNodes); RooAbsArg*RooAbsArg::findNewServer(const RooAbsCollection& newSet, Bool_t nameChange) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; RooAbsArg*RooAbsArg::findServer(const char* name) const; RooAbsArg*RooAbsArg::findServer(const RooAbsArg& arg) const; RooAbsArg*RooAbsArg::findServer(Int_t index) const; static UInt_tRooAbsArg::fnv1a32(const char* data); static U",MatchSource.WIKI,root/html602/RooAbsCategoryLValue.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsCategoryLValue.html
https://root.cern/root/html602/RooAbsCategoryLValue.html:4575,Availability,error,error,4575,"t* depList, const RooAbsArg& testArg) const; Bool_tRooAbsArg::dependsOn(const RooAbsCollection& serverList, const RooAbsArg* ignoreArg = 0, Bool_t valueOnly = kFALSE) const; Bool_tRooAbsArg::dependsOn(const RooAbsArg& server, const RooAbsArg* ignoreArg = 0, Bool_t valueOnly = kFALSE) const; Bool_tRooAbsArg::dependsOnValue(const RooAbsCollection& serverList, const RooAbsArg* ignoreArg = 0) const; Bool_tRooAbsArg::dependsOnValue(const RooAbsArg& server, const RooAbsArg* ignoreArg = 0) const; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); RooExpensiveObjectCache&RooAbsArg::expensiveObjectCache() const; virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); Bool_tRooAbsArg::findConstantNodes(const RooArgSet& observables, RooArgSet& cacheList); Bool_tRooAbsArg::findConstantNodes(const RooArgSet& observables, RooArgSet& cacheList, RooLinkedList& processedNodes); RooAbsArg*RooAbsArg::findNewServer(const RooAbsCollection& newSet, Bool_t nameChange) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; RooAbsArg*RooAbsArg::findServer(const char* name) const; RooAbsArg*RooAbsArg::findServer(const RooAbsArg& arg) const; RooAbsArg*RooAbsArg::findServer(Int_t index) const; static UInt_tRooAbsArg::fnv1a32(const char* data); static UInt_tRooAbsArg::fnv1a32(const char* data, ULong_t sz, UInt_t hash = fnv1a32start); s",MatchSource.WIKI,root/html602/RooAbsCategoryLValue.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsCategoryLValue.html
https://root.cern/root/html602/RooAbsCategoryLValue.html:3454,Integrability,depend,dependentOverlaps,3454,"ual TObject*RooAbsArg::clone(const char* newname = 0) const; virtual TObject*RooAbsArg::Clone(const char* newname = 0) const; virtual RooAbsArg*RooAbsArg::cloneTree(const char* newname = 0) const; virtual Int_tRooAbsArg::Compare(const TObject* other) const; virtual voidRooAbsArg::constOptimizeTestStatistic(RooAbsArg::ConstOpCode opcode, Bool_t doAlsoTrackingOpt = kTRUE); virtual voidTNamed::Copy(TObject& named) const; static UInt_tRooAbsArg::crc32(const char* data); static UInt_tRooAbsArg::crc32(const char* data, ULong_t sz, UInt_t crc = 0); virtual RooAbsArg*RooAbsCategory::createFundamental(const char* newname = 0) const; Roo1DTable*RooAbsCategory::createTable(const char* label) const; virtual Int_tRooAbsArg::defaultPrintContents(Option_t* opt) const; static ostream&RooPrintable::defaultPrintStream(ostream* os = 0); virtual RooPrintable::StyleOptionRooPrintable::defaultPrintStyle(Option_t* opt) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; Bool_tRooAbsArg::dependentOverlaps(const RooAbsData* dset, const RooAbsArg& testArg) const; Bool_tRooAbsArg::dependentOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; Bool_tRooAbsArg::dependsOn(const RooAbsCollection& serverList, const RooAbsArg* ignoreArg = 0, Bool_t valueOnly = kFALSE) const; Bool_tRooAbsArg::dependsOn(const RooAbsArg& server, const RooAbsArg* ignoreArg = 0, Bool_t valueOnly = kFALSE) const; Bool_tRooAbsArg::dependsOnValue(const RooAbsCollection& serverList, const RooAbsArg* ignoreArg = 0) const; Bool_tRooAbsArg::dependsOnValue(const RooAbsArg& server, const RooAbsArg* ignoreArg = 0) const; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method,",MatchSource.WIKI,root/html602/RooAbsCategoryLValue.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsCategoryLValue.html
https://root.cern/root/html602/RooAbsCategoryLValue.html:3546,Integrability,depend,dependentOverlaps,3546,"e(const char* newname = 0) const; virtual RooAbsArg*RooAbsArg::cloneTree(const char* newname = 0) const; virtual Int_tRooAbsArg::Compare(const TObject* other) const; virtual voidRooAbsArg::constOptimizeTestStatistic(RooAbsArg::ConstOpCode opcode, Bool_t doAlsoTrackingOpt = kTRUE); virtual voidTNamed::Copy(TObject& named) const; static UInt_tRooAbsArg::crc32(const char* data); static UInt_tRooAbsArg::crc32(const char* data, ULong_t sz, UInt_t crc = 0); virtual RooAbsArg*RooAbsCategory::createFundamental(const char* newname = 0) const; Roo1DTable*RooAbsCategory::createTable(const char* label) const; virtual Int_tRooAbsArg::defaultPrintContents(Option_t* opt) const; static ostream&RooPrintable::defaultPrintStream(ostream* os = 0); virtual RooPrintable::StyleOptionRooPrintable::defaultPrintStyle(Option_t* opt) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; Bool_tRooAbsArg::dependentOverlaps(const RooAbsData* dset, const RooAbsArg& testArg) const; Bool_tRooAbsArg::dependentOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; Bool_tRooAbsArg::dependsOn(const RooAbsCollection& serverList, const RooAbsArg* ignoreArg = 0, Bool_t valueOnly = kFALSE) const; Bool_tRooAbsArg::dependsOn(const RooAbsArg& server, const RooAbsArg* ignoreArg = 0, Bool_t valueOnly = kFALSE) const; Bool_tRooAbsArg::dependsOnValue(const RooAbsCollection& serverList, const RooAbsArg* ignoreArg = 0) const; Bool_tRooAbsArg::dependsOnValue(const RooAbsArg& server, const RooAbsArg* ignoreArg = 0) const; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjAr",MatchSource.WIKI,root/html602/RooAbsCategoryLValue.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsCategoryLValue.html
https://root.cern/root/html602/RooAbsCategoryLValue.html:3640,Integrability,depend,dependsOn,3640,"me = 0) const; virtual Int_tRooAbsArg::Compare(const TObject* other) const; virtual voidRooAbsArg::constOptimizeTestStatistic(RooAbsArg::ConstOpCode opcode, Bool_t doAlsoTrackingOpt = kTRUE); virtual voidTNamed::Copy(TObject& named) const; static UInt_tRooAbsArg::crc32(const char* data); static UInt_tRooAbsArg::crc32(const char* data, ULong_t sz, UInt_t crc = 0); virtual RooAbsArg*RooAbsCategory::createFundamental(const char* newname = 0) const; Roo1DTable*RooAbsCategory::createTable(const char* label) const; virtual Int_tRooAbsArg::defaultPrintContents(Option_t* opt) const; static ostream&RooPrintable::defaultPrintStream(ostream* os = 0); virtual RooPrintable::StyleOptionRooPrintable::defaultPrintStyle(Option_t* opt) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; Bool_tRooAbsArg::dependentOverlaps(const RooAbsData* dset, const RooAbsArg& testArg) const; Bool_tRooAbsArg::dependentOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; Bool_tRooAbsArg::dependsOn(const RooAbsCollection& serverList, const RooAbsArg* ignoreArg = 0, Bool_t valueOnly = kFALSE) const; Bool_tRooAbsArg::dependsOn(const RooAbsArg& server, const RooAbsArg* ignoreArg = 0, Bool_t valueOnly = kFALSE) const; Bool_tRooAbsArg::dependsOnValue(const RooAbsCollection& serverList, const RooAbsArg* ignoreArg = 0) const; Bool_tRooAbsArg::dependsOnValue(const RooAbsArg& server, const RooAbsArg* ignoreArg = 0) const; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, I",MatchSource.WIKI,root/html602/RooAbsCategoryLValue.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsCategoryLValue.html
https://root.cern/root/html602/RooAbsCategoryLValue.html:3769,Integrability,depend,dependsOn,3769,"AbsArg::ConstOpCode opcode, Bool_t doAlsoTrackingOpt = kTRUE); virtual voidTNamed::Copy(TObject& named) const; static UInt_tRooAbsArg::crc32(const char* data); static UInt_tRooAbsArg::crc32(const char* data, ULong_t sz, UInt_t crc = 0); virtual RooAbsArg*RooAbsCategory::createFundamental(const char* newname = 0) const; Roo1DTable*RooAbsCategory::createTable(const char* label) const; virtual Int_tRooAbsArg::defaultPrintContents(Option_t* opt) const; static ostream&RooPrintable::defaultPrintStream(ostream* os = 0); virtual RooPrintable::StyleOptionRooPrintable::defaultPrintStyle(Option_t* opt) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; Bool_tRooAbsArg::dependentOverlaps(const RooAbsData* dset, const RooAbsArg& testArg) const; Bool_tRooAbsArg::dependentOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; Bool_tRooAbsArg::dependsOn(const RooAbsCollection& serverList, const RooAbsArg* ignoreArg = 0, Bool_t valueOnly = kFALSE) const; Bool_tRooAbsArg::dependsOn(const RooAbsArg& server, const RooAbsArg* ignoreArg = 0, Bool_t valueOnly = kFALSE) const; Bool_tRooAbsArg::dependsOnValue(const RooAbsCollection& serverList, const RooAbsArg* ignoreArg = 0) const; Bool_tRooAbsArg::dependsOnValue(const RooAbsArg& server, const RooAbsArg* ignoreArg = 0) const; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); RooExpensiveObjectCache&RooAbsArg::expensiveObjectCache() const; virtual voidTObject::Fatal(const char* method, const c",MatchSource.WIKI,root/html602/RooAbsCategoryLValue.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsCategoryLValue.html
https://root.cern/root/html602/RooAbsCategoryLValue.html:3887,Integrability,depend,dependsOnValue,3887,"nt_tRooAbsArg::crc32(const char* data); static UInt_tRooAbsArg::crc32(const char* data, ULong_t sz, UInt_t crc = 0); virtual RooAbsArg*RooAbsCategory::createFundamental(const char* newname = 0) const; Roo1DTable*RooAbsCategory::createTable(const char* label) const; virtual Int_tRooAbsArg::defaultPrintContents(Option_t* opt) const; static ostream&RooPrintable::defaultPrintStream(ostream* os = 0); virtual RooPrintable::StyleOptionRooPrintable::defaultPrintStyle(Option_t* opt) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; Bool_tRooAbsArg::dependentOverlaps(const RooAbsData* dset, const RooAbsArg& testArg) const; Bool_tRooAbsArg::dependentOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; Bool_tRooAbsArg::dependsOn(const RooAbsCollection& serverList, const RooAbsArg* ignoreArg = 0, Bool_t valueOnly = kFALSE) const; Bool_tRooAbsArg::dependsOn(const RooAbsArg& server, const RooAbsArg* ignoreArg = 0, Bool_t valueOnly = kFALSE) const; Bool_tRooAbsArg::dependsOnValue(const RooAbsCollection& serverList, const RooAbsArg* ignoreArg = 0) const; Bool_tRooAbsArg::dependsOnValue(const RooAbsArg& server, const RooAbsArg* ignoreArg = 0) const; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); RooExpensiveObjectCache&RooAbsArg::expensiveObjectCache() const; virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); Bool_tRooAbsArg::findConstantNodes(const RooArgSet& ob",MatchSource.WIKI,root/html602/RooAbsCategoryLValue.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsCategoryLValue.html
https://root.cern/root/html602/RooAbsCategoryLValue.html:3994,Integrability,depend,dependsOnValue,3994,"crc = 0); virtual RooAbsArg*RooAbsCategory::createFundamental(const char* newname = 0) const; Roo1DTable*RooAbsCategory::createTable(const char* label) const; virtual Int_tRooAbsArg::defaultPrintContents(Option_t* opt) const; static ostream&RooPrintable::defaultPrintStream(ostream* os = 0); virtual RooPrintable::StyleOptionRooPrintable::defaultPrintStyle(Option_t* opt) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; Bool_tRooAbsArg::dependentOverlaps(const RooAbsData* dset, const RooAbsArg& testArg) const; Bool_tRooAbsArg::dependentOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; Bool_tRooAbsArg::dependsOn(const RooAbsCollection& serverList, const RooAbsArg* ignoreArg = 0, Bool_t valueOnly = kFALSE) const; Bool_tRooAbsArg::dependsOn(const RooAbsArg& server, const RooAbsArg* ignoreArg = 0, Bool_t valueOnly = kFALSE) const; Bool_tRooAbsArg::dependsOnValue(const RooAbsCollection& serverList, const RooAbsArg* ignoreArg = 0) const; Bool_tRooAbsArg::dependsOnValue(const RooAbsArg& server, const RooAbsArg* ignoreArg = 0) const; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); RooExpensiveObjectCache&RooAbsArg::expensiveObjectCache() const; virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); Bool_tRooAbsArg::findConstantNodes(const RooArgSet& observables, RooArgSet& cacheList); Bool_tRooAbsArg::findConstantNodes(const RooArgSet& observables, RooArgSe",MatchSource.WIKI,root/html602/RooAbsCategoryLValue.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsCategoryLValue.html
https://root.cern/root/html602/RooAbsCategoryLValue.html:1856,Performance,cache,cacheUniqueSuffix,1856," virtual~RooAbsCategoryLValue(); voidTObject::AbstractMethod(const char* method) const; Bool_tRooAbsArg::addOwnedComponents(const RooArgSet& comps); voidRooAbsArg::addParameters(RooArgSet& params, const RooArgSet* nset = 0, Bool_t stripDisconnected = kTRUE) const; voidRooAbsArg::addServer(RooAbsArg& server, Bool_t valueProp = kTRUE, Bool_t shapeProp = kFALSE); voidRooAbsArg::addServerList(RooAbsCollection& serverList, Bool_t valueProp = kTRUE, Bool_t shapeProp = kFALSE); const char*RooAbsArg::aggregateCacheUniqueSuffix() const; virtual voidTObject::AppendPad(Option_t* option = """"); voidRooAbsArg::attachDataSet(const RooAbsData& set); voidRooAbsArg::attachDataStore(const RooAbsDataStore& set); const set<string>&RooAbsArg::attributes() const; voidRooAbsArg::branchNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t recurseNonDerived = kFALSE) const; virtual voidTObject::Browse(TBrowser* b); virtual const char*RooAbsArg::cacheUniqueSuffix() const; virtual RooAbsArg::CacheModeRooAbsArg::canNodeBeCached() const; voidRooAbsArg::changeServer(RooAbsArg& server, Bool_t ",MatchSource.WIKI,root/html602/RooAbsCategoryLValue.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsCategoryLValue.html
https://root.cern/root/html602/RooAbsCategoryLValue.html:4917,Performance,cache,cacheList,4917,"on& serverList, const RooAbsArg* ignoreArg = 0) const; Bool_tRooAbsArg::dependsOnValue(const RooAbsArg& server, const RooAbsArg* ignoreArg = 0) const; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); RooExpensiveObjectCache&RooAbsArg::expensiveObjectCache() const; virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); Bool_tRooAbsArg::findConstantNodes(const RooArgSet& observables, RooArgSet& cacheList); Bool_tRooAbsArg::findConstantNodes(const RooArgSet& observables, RooArgSet& cacheList, RooLinkedList& processedNodes); RooAbsArg*RooAbsArg::findNewServer(const RooAbsCollection& newSet, Bool_t nameChange) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; RooAbsArg*RooAbsArg::findServer(const char* name) const; RooAbsArg*RooAbsArg::findServer(const RooAbsArg& arg) const; RooAbsArg*RooAbsArg::findServer(Int_t index) const; static UInt_tRooAbsArg::fnv1a32(const char* data); static UInt_tRooAbsArg::fnv1a32(const char* data, ULong_t sz, UInt_t hash = fnv1a32start); static ULong64_tRooAbsArg::fnv1a64(const char* data); static ULong64_tRooAbsArg::fnv1a64(const char* data, ULong_t sz, ULong64_t hash = fnv1a64start); Bool_tRooAbsArg::getAttribute(const Text_t* name) const; virtual Int_tgetBin(const char* rangeName = 0) const; virtual Int_tgetBin(const RooAbsBinning*) const; virtual list<string>getBinningName",MatchSource.WIKI,root/html602/RooAbsCategoryLValue.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsCategoryLValue.html
https://root.cern/root/html602/RooAbsCategoryLValue.html:5005,Performance,cache,cacheList,5005,"onst RooAbsArg& server, const RooAbsArg* ignoreArg = 0) const; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); RooExpensiveObjectCache&RooAbsArg::expensiveObjectCache() const; virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); Bool_tRooAbsArg::findConstantNodes(const RooArgSet& observables, RooArgSet& cacheList); Bool_tRooAbsArg::findConstantNodes(const RooArgSet& observables, RooArgSet& cacheList, RooLinkedList& processedNodes); RooAbsArg*RooAbsArg::findNewServer(const RooAbsCollection& newSet, Bool_t nameChange) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; RooAbsArg*RooAbsArg::findServer(const char* name) const; RooAbsArg*RooAbsArg::findServer(const RooAbsArg& arg) const; RooAbsArg*RooAbsArg::findServer(Int_t index) const; static UInt_tRooAbsArg::fnv1a32(const char* data); static UInt_tRooAbsArg::fnv1a32(const char* data, ULong_t sz, UInt_t hash = fnv1a32start); static ULong64_tRooAbsArg::fnv1a64(const char* data); static ULong64_tRooAbsArg::fnv1a64(const char* data, ULong_t sz, ULong64_t hash = fnv1a64start); Bool_tRooAbsArg::getAttribute(const Text_t* name) const; virtual Int_tgetBin(const char* rangeName = 0) const; virtual Int_tgetBin(const RooAbsBinning*) const; virtual list<string>getBinningNames() const; virtual const RooAbsBinning*getBinningPtr(const char*) const; virtual Double_",MatchSource.WIKI,root/html602/RooAbsCategoryLValue.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsCategoryLValue.html
https://root.cern/root/html602/RooAbsCategoryLValue.html:12075,Performance,optimiz,optimizeCacheMode,12075,"st char* removedFromVers) const; voidTObject::operator delete(void* ptr); voidTObject::operator delete(void* ptr, void* vp); voidTObject::operator delete[](void* ptr); voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); Bool_tRooAbsCategory::operator!=(Int_t index); Bool_tRooAbsCategory::operator!=(const char* label); Bool_tRooAbsCategory::operator!=(const RooAbsArg& other); RooAbsArg&operator=(int index); RooAbsArg&operator=(const char* label); RooAbsArg&operator=(const RooAbsCategory& other); RooAbsCategoryLValue&operator=(const RooAbsCategoryLValue&); Bool_tRooAbsCategory::operator==(Int_t index) const; Bool_tRooAbsCategory::operator==(const char* label) const; virtual Bool_tRooAbsCategory::operator==(const RooAbsArg& other); RooAbsArg::OperModeRooAbsArg::operMode() const; virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables); virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables, RooArgSet& optNodes, RooLinkedList& processedNodes); Bool_tRooAbsArg::overlaps(const RooAbsArg& testArg, Bool_t valueOnly = kFALSE) const; const RooArgSet*RooAbsArg::ownedComponents() const; virtual voidTObject::Paint(Option_t* option = """"); virtual voidTObject::Pop(); virtual voidRooAbsArg::Print(Option_t* options = 0) const; virtual voidRooAbsArg::printAddress(ostream& os) const; virtual voidRooAbsArg::printArgs(ostream& os) const; virtual voidRooAbsArg::printClassName(ostream& os) const; voidRooAbsArg::printCompactTree(const char* indent = """", const char* fileName = 0, const char* namePat = 0, RooAbsArg* client = 0); voidRooAbsArg::printCompactTree(ostream& os, const char* indent = """", const char* namePat = 0, RooAbsArg* client = 0); virtual voidRooAbsArg::printCompactTreeHook(ostream& os, const char* ind = """"); voidRooAbsArg::printComponentTree(const char* indent = """", con",MatchSource.WIKI,root/html602/RooAbsCategoryLValue.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsCategoryLValue.html
https://root.cern/root/html602/RooAbsCategoryLValue.html:12147,Performance,optimiz,optimizeCacheMode,12147,"; voidTObject::operator delete(void* ptr, void* vp); voidTObject::operator delete[](void* ptr); voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); Bool_tRooAbsCategory::operator!=(Int_t index); Bool_tRooAbsCategory::operator!=(const char* label); Bool_tRooAbsCategory::operator!=(const RooAbsArg& other); RooAbsArg&operator=(int index); RooAbsArg&operator=(const char* label); RooAbsArg&operator=(const RooAbsCategory& other); RooAbsCategoryLValue&operator=(const RooAbsCategoryLValue&); Bool_tRooAbsCategory::operator==(Int_t index) const; Bool_tRooAbsCategory::operator==(const char* label) const; virtual Bool_tRooAbsCategory::operator==(const RooAbsArg& other); RooAbsArg::OperModeRooAbsArg::operMode() const; virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables); virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables, RooArgSet& optNodes, RooLinkedList& processedNodes); Bool_tRooAbsArg::overlaps(const RooAbsArg& testArg, Bool_t valueOnly = kFALSE) const; const RooArgSet*RooAbsArg::ownedComponents() const; virtual voidTObject::Paint(Option_t* option = """"); virtual voidTObject::Pop(); virtual voidRooAbsArg::Print(Option_t* options = 0) const; virtual voidRooAbsArg::printAddress(ostream& os) const; virtual voidRooAbsArg::printArgs(ostream& os) const; virtual voidRooAbsArg::printClassName(ostream& os) const; voidRooAbsArg::printCompactTree(const char* indent = """", const char* fileName = 0, const char* namePat = 0, RooAbsArg* client = 0); voidRooAbsArg::printCompactTree(ostream& os, const char* indent = """", const char* namePat = 0, RooAbsArg* client = 0); virtual voidRooAbsArg::printCompactTreeHook(ostream& os, const char* ind = """"); voidRooAbsArg::printComponentTree(const char* indent = """", const char* namePat = 0, Int_t nLevel = 999); voidRooAbsArg::printDirty(Boo",MatchSource.WIKI,root/html602/RooAbsCategoryLValue.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsCategoryLValue.html
https://root.cern/root/html602/RooAbsCategoryLValue.html:14641,Performance,cache,cache,14641,"s) const; virtual voidRooAbsArg::printTree(ostream& os, TString indent = """") const; virtual voidRooAbsCategory::printValue(ostream& os) const; virtual voidrandomize(const char* rangeName = 0); virtual Int_tTObject::Read(const char* name); virtual Bool_treadFromStream(istream& is, Bool_t compact, Bool_t verbose = kFALSE); Bool_tRooAbsArg::recursiveCheckDependents(const RooArgSet* nset) const; Bool_tRooAbsArg::recursiveCheckObservables(const RooArgSet* nset) const; Bool_tRooAbsArg::recursiveRedirectServers(const RooAbsCollection& newServerList, Bool_t mustReplaceAll = kFALSE, Bool_t nameChange = kFALSE, Bool_t recurseInNewSet = kTRUE); virtual voidTObject::RecursiveRemove(TObject* obj); Bool_tRooAbsArg::redirectServers(const RooAbsCollection& newServerList, Bool_t mustReplaceAll = kFALSE, Bool_t nameChange = kFALSE, Bool_t isRecursionStep = kFALSE); virtual Bool_tRooAbsArg::redirectServersHook(const RooAbsCollection&, Bool_t, Bool_t, Bool_t); voidRooAbsArg::registerCache(RooAbsCache& cache); voidRooAbsArg::removeServer(RooAbsArg& server, Bool_t force = kFALSE); voidRooAbsArg::replaceServer(RooAbsArg& oldServer, RooAbsArg& newServer, Bool_t valueProp, Bool_t shapeProp); voidTObject::ResetBit(UInt_t f); RooAbsCategoryLValue(); RooAbsCategoryLValue(const char* name, const char* title); RooAbsCategoryLValue(const RooAbsCategoryLValue& other, const char* name = 0); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); TIterator*RooAbsArg::serverIterator() const; RooFIterRooAbsArg::serverMIterator() const; virtual voidRooAbsArg::serverNameChangeHook(const RooAbsArg*, const RooAbsArg*); voidRooAbsArg::setAttribute(const Text_t* name, Bool_t value = kTRUE); virtual voidsetBin(Int_t ibin, const char* rangeName = 0); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); virtual voidRooAbsArg::setCacheAndTrackHints(RooArgSet&); voidsetConstant(Bool_t v",MatchSource.WIKI,root/html602/RooAbsCategoryLValue.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsCategoryLValue.html
https://root.cern/root/html602/RooAbsCategoryLValue.html:15891,Performance,cache,cache,15891,"ategoryLValue(const char* name, const char* title); RooAbsCategoryLValue(const RooAbsCategoryLValue& other, const char* name = 0); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); TIterator*RooAbsArg::serverIterator() const; RooFIterRooAbsArg::serverMIterator() const; virtual voidRooAbsArg::serverNameChangeHook(const RooAbsArg*, const RooAbsArg*); voidRooAbsArg::setAttribute(const Text_t* name, Bool_t value = kTRUE); virtual voidsetBin(Int_t ibin, const char* rangeName = 0); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); virtual voidRooAbsArg::setCacheAndTrackHints(RooArgSet&); voidsetConstant(Bool_t value = kTRUE); static voidRooAbsArg::setDirtyInhibit(Bool_t flag); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); virtual voidRooAbsArg::setExpensiveObjectCache(RooExpensiveObjectCache& cache); virtual Bool_tsetIndex(Int_t index, Bool_t printError = kTRUE); virtual Bool_tsetLabel(const char* label, Bool_t printError = kTRUE); voidRooAbsArg::setLocalNoDirtyInhibit(Bool_t flag) const; virtual voidRooAbsArg::SetName(const char* name); virtual voidRooAbsArg::SetNameTitle(const char* name, const char* title); static voidTObject::SetObjectStat(Bool_t stat); voidRooAbsArg::setOperMode(RooAbsArg::OperMode mode, Bool_t recurseADirty = kTRUE); voidRooAbsArg::setProhibitServerRedirect(Bool_t flag); voidRooAbsArg::setShapeDirty() const; voidRooAbsArg::setStringAttribute(const Text_t* key, const Text_t* value); virtual voidTNamed::SetTitle(const char* title = """")MENU ; voidRooAbsArg::setTransientAttribute(const Text_t* name, Bool_t value = kTRUE); virtual voidTObject::SetUniqueID(UInt_t uid); voidRooAbsArg::setValueDirty() const; TIterator*RooAbsArg::shapeClientIterator() const; RooFIterRooAbsArg::shapeClientMIterator() const; virtual voidShowMembers(TMemberInspector& insp) const; vi",MatchSource.WIKI,root/html602/RooAbsCategoryLValue.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsCategoryLValue.html
https://root.cern/root/html602/RooAbsCategoryLValue.html:17591,Performance,cache,cache,17591,"ame, const char* title); static voidTObject::SetObjectStat(Bool_t stat); voidRooAbsArg::setOperMode(RooAbsArg::OperMode mode, Bool_t recurseADirty = kTRUE); voidRooAbsArg::setProhibitServerRedirect(Bool_t flag); voidRooAbsArg::setShapeDirty() const; voidRooAbsArg::setStringAttribute(const Text_t* key, const Text_t* value); virtual voidTNamed::SetTitle(const char* title = """")MENU ; voidRooAbsArg::setTransientAttribute(const Text_t* name, Bool_t value = kTRUE); virtual voidTObject::SetUniqueID(UInt_t uid); voidRooAbsArg::setValueDirty() const; TIterator*RooAbsArg::shapeClientIterator() const; RooFIterRooAbsArg::shapeClientMIterator() const; virtual voidShowMembers(TMemberInspector& insp) const; virtual Int_tTNamed::Sizeof() const; virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); const map<string,string>&RooAbsArg::stringAttributes() const; virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; const set<string>&RooAbsArg::transientAttributes() const; voidRooAbsArg::treeNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t doBranch = kTRUE, Bool_t doLeaf = kTRUE, Bool_t valueOnly = kFALSE, Bool_t recurseNonDerived = kFALSE) const; TIterator*RooAbsCategory::typeIterator() const; voidRooAbsArg::unRegisterCache(RooAbsCache& cache); virtual voidTObject::UseCurrentStyle(); TIterator*RooAbsArg::valueClientIterator() const; RooFIterRooAbsArg::valueClientMIterator() const; static voidRooAbsArg::verboseDirty(Bool_t flag); virtual Double_tvolume(const char* rangeName) const; virtual voidTObject::Warning(const char* method, const char* msgfmt) const; voidRooAbsArg::wireAllCaches(); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const; virtual voidwriteToStream(ostream& os, Bool_t compact) const.",MatchSource.WIKI,root/html602/RooAbsCategoryLValue.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsCategoryLValue.html
https://root.cern/root/html602/RooAbsCategoryLValue.html:19677,Performance,optimiz,optimizeDirtyHook,19677,"t RooCatType*RooAbsCategory::defineType(const char* label); const RooCatType*RooAbsCategory::defineType(const char* label, Int_t index); const RooCatType*RooAbsCategory::defineTypeUnchecked(const char* label, Int_t index); virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; virtual RooCatTypeRooAbsCategory::evaluate() const; virtual voidRooAbsCategory::fillTreeBranch(TTree& t); virtual voidRooAbsArg::getObservablesHook(const RooArgSet*, RooArgSet*) const; const RooCatType*RooAbsCategory::getOrdinal(UInt_t n, const char* rangeName = 0) const; virtual voidRooAbsArg::getParametersHook(const RooArgSet*, RooArgSet*, Bool_t) const; RooAbsProxy*RooAbsArg::getProxy(Int_t index) const; voidRooAbsArg::graphVizAddConnections(set<pair<RooAbsArg*,RooAbsArg*> >&); Bool_tRooAbsArg::inhibitDirty() const; virtual Bool_tRooAbsCategory::isValid() const; virtual Bool_tRooAbsCategory::isValid(const RooCatType& value) const; voidTObject::MakeZombie(); Int_tRooAbsArg::numProxies() const; virtual voidRooAbsArg::operModeHook(); virtual voidRooAbsArg::optimizeDirtyHook(const RooArgSet*); voidRooAbsArg::printAttribList(ostream& os) const; voidRooAbsArg::registerProxy(RooArgProxy& proxy); voidRooAbsArg::registerProxy(RooSetProxy& proxy); voidRooAbsArg::registerProxy(RooListProxy& proxy); virtual voidsetIndexFast(Int_t index); Bool_tsetOrdinal(UInt_t index, const char* rangeName); voidRooAbsArg::setProxyNormSet(const RooArgSet* nset); voidRooAbsArg::setShapeDirty(const RooAbsArg* source) const; virtual voidRooAbsCategory::setTreeBranchStatus(TTree& t, Bool_t active); voidRooAbsArg::setValueDirty(const RooAbsArg* source) const; virtual voidRooAbsCategory::syncCache(const RooArgSet* set = 0); RooCatTypeRooAbsCategory::traceEval() const; virtual Bool_tRooAbsCategory::traceEvalHook(RooCatType) const; voidRooAbsArg::unRegisterProxy(RooArgProxy& proxy); voidRooAbsArg::unRegisterProxy(RooSetProxy& proxy); voidRooAbsArg::unRegisterProxy(RooListProxy& proxy).",MatchSource.WIKI,root/html602/RooAbsCategoryLValue.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsCategoryLValue.html
https://root.cern/root/html602/RooAbsCategoryLValue.html:23064,Performance,cache,cache,23064,ooPrintable::kStandard; static RooPrintable::ContentsOptionRooPrintable::kTitle; static RooPrintable::StyleOptionRooPrintable::kTreeStructure; static RooPrintable::ContentsOptionRooPrintable::kValue; static RooPrintable::StyleOptionRooPrintable::kVerbose; static TObject::(anonymous)TObject::kWriteDelete; static TObject::(anonymous)TObject::kZombie. protected:. set<string>RooAbsArg::_boolAttribBoolean attributes; set<string>RooAbsArg::_boolAttribTransient! Transient boolean attributes (not copied in ctor); UChar_tRooAbsCategory::_byteValue! Transient cache for byte values from tree branches; deque<RooAbsCache*>RooAbsArg::_cacheListlist of caches; RooRefCountListRooAbsArg::_clientListlist of client objects; RooRefCountListRooAbsArg::_clientListShapesubset of clients that requested shape dirty flag propagation; RooRefCountListRooAbsArg::_clientListValuesubset of clients that requested value dirty flag propagation; TIterator*RooAbsArg::_clientShapeIter! Iterator over _clientListShape; TIterator*RooAbsArg::_clientValueIter! Iterator over _clientListValue; Bool_tRooAbsArg::_deleteWatch! Delete watch flag; RooExpensiveObjectCache*RooAbsArg::_eocachePointer to global cache manager for any expensive components created by this object; Bool_tRooAbsArg::_fastAllow fast access mode in getVal() and proxies; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; Bool_tRooAbsArg::_isConstant! Cached isConstant status; Bool_tRooAbsArg::_localNoInhibitDirty! Prevent 'AlwaysDirty' mode for this node; static Int_tRooPrintable::_nameLength; TNamed*RooAbsArg::_namePtr! Do not persist. Pointer to global instance of string that matches object named; RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; RooRefArrayRooAbsArg::_proxyListlist of proxies; RooRefCountListRooAbsArg::_se,MatchSource.WIKI,root/html602/RooAbsCategoryLValue.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsCategoryLValue.html
https://root.cern/root/html602/RooAbsCategoryLValue.html:23154,Performance,cache,caches,23154,ooPrintable::kStandard; static RooPrintable::ContentsOptionRooPrintable::kTitle; static RooPrintable::StyleOptionRooPrintable::kTreeStructure; static RooPrintable::ContentsOptionRooPrintable::kValue; static RooPrintable::StyleOptionRooPrintable::kVerbose; static TObject::(anonymous)TObject::kWriteDelete; static TObject::(anonymous)TObject::kZombie. protected:. set<string>RooAbsArg::_boolAttribBoolean attributes; set<string>RooAbsArg::_boolAttribTransient! Transient boolean attributes (not copied in ctor); UChar_tRooAbsCategory::_byteValue! Transient cache for byte values from tree branches; deque<RooAbsCache*>RooAbsArg::_cacheListlist of caches; RooRefCountListRooAbsArg::_clientListlist of client objects; RooRefCountListRooAbsArg::_clientListShapesubset of clients that requested shape dirty flag propagation; RooRefCountListRooAbsArg::_clientListValuesubset of clients that requested value dirty flag propagation; TIterator*RooAbsArg::_clientShapeIter! Iterator over _clientListShape; TIterator*RooAbsArg::_clientValueIter! Iterator over _clientListValue; Bool_tRooAbsArg::_deleteWatch! Delete watch flag; RooExpensiveObjectCache*RooAbsArg::_eocachePointer to global cache manager for any expensive components created by this object; Bool_tRooAbsArg::_fastAllow fast access mode in getVal() and proxies; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; Bool_tRooAbsArg::_isConstant! Cached isConstant status; Bool_tRooAbsArg::_localNoInhibitDirty! Prevent 'AlwaysDirty' mode for this node; static Int_tRooPrintable::_nameLength; TNamed*RooAbsArg::_namePtr! Do not persist. Pointer to global instance of string that matches object named; RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; RooRefArrayRooAbsArg::_proxyListlist of proxies; RooRefCountListRooAbsArg::_se,MatchSource.WIKI,root/html602/RooAbsCategoryLValue.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsCategoryLValue.html
https://root.cern/root/html602/RooAbsCategoryLValue.html:23686,Performance,cache,cache,23686,ooPrintable::kStandard; static RooPrintable::ContentsOptionRooPrintable::kTitle; static RooPrintable::StyleOptionRooPrintable::kTreeStructure; static RooPrintable::ContentsOptionRooPrintable::kValue; static RooPrintable::StyleOptionRooPrintable::kVerbose; static TObject::(anonymous)TObject::kWriteDelete; static TObject::(anonymous)TObject::kZombie. protected:. set<string>RooAbsArg::_boolAttribBoolean attributes; set<string>RooAbsArg::_boolAttribTransient! Transient boolean attributes (not copied in ctor); UChar_tRooAbsCategory::_byteValue! Transient cache for byte values from tree branches; deque<RooAbsCache*>RooAbsArg::_cacheListlist of caches; RooRefCountListRooAbsArg::_clientListlist of client objects; RooRefCountListRooAbsArg::_clientListShapesubset of clients that requested shape dirty flag propagation; RooRefCountListRooAbsArg::_clientListValuesubset of clients that requested value dirty flag propagation; TIterator*RooAbsArg::_clientShapeIter! Iterator over _clientListShape; TIterator*RooAbsArg::_clientValueIter! Iterator over _clientListValue; Bool_tRooAbsArg::_deleteWatch! Delete watch flag; RooExpensiveObjectCache*RooAbsArg::_eocachePointer to global cache manager for any expensive components created by this object; Bool_tRooAbsArg::_fastAllow fast access mode in getVal() and proxies; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; Bool_tRooAbsArg::_isConstant! Cached isConstant status; Bool_tRooAbsArg::_localNoInhibitDirty! Prevent 'AlwaysDirty' mode for this node; static Int_tRooPrintable::_nameLength; TNamed*RooAbsArg::_namePtr! Do not persist. Pointer to global instance of string that matches object named; RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; RooRefArrayRooAbsArg::_proxyListlist of proxies; RooRefCountListRooAbsArg::_se,MatchSource.WIKI,root/html602/RooAbsCategoryLValue.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsCategoryLValue.html
https://root.cern/root/html602/RooAbsCategoryLValue.html:25969,Performance,cache,cached,25969,"alculating because input values modified; static Bool_tRooAbsArg::_verboseDirtyStatic flag controlling verbose messaging for dirty state changes; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; RooAbsCategoryLValue(const char* name, const char* title); Constructor. RooAbsCategoryLValue(const RooAbsCategoryLValue& other, const char* name = 0); Copy constructor. ~RooAbsCategoryLValue(); Destructor. RooAbsArg& operator=(Int_t index); Assignment operator from integer index number. RooAbsArg& operator=(const char* label); Assignment operator from string pointer. RooAbsArg& operator=(const RooAbsCategory& other); Assignment from another RooAbsCategory. Bool_t setOrdinal(UInt_t index, const char* rangeName); Set our state to our n'th defined type and return kTRUE.; Return kFALSE if n is out of range. void copyCache(const RooAbsArg* source, Bool_t valueOnly = kFALSE, Bool_t setValDirty = kTRUE); Copy the cached value from given source and raise dirty flag.; It is the callers responsability to ensure that the sources; cache is clean(valid) before this function is called, e.g. by; calling syncCache() on the source. Bool_t readFromStream(istream& is, Bool_t compact, Bool_t verbose = kFALSE); Read object contents from given stream (dummy implementation). void writeToStream(ostream& os, Bool_t compact) const; Write object contents to given stream (dummy implementation). void randomize(const char* rangeName = 0); Randomize current value. void setBin(Int_t ibin, const char* rangeName = 0); Set category to i-th fit bin, which is the i-th registered state. Int_t getBin(const char* rangeName = 0) const; Get index of plot bin for current value this category. Int_t numBins(const char* rangeName) const; Returm the number of fit bins ( = number of types ). RooAbsCategoryLValue(); Constructor, assignment etc. Bool_t setIndex(Int_t index, Bool_t printError = kTRUE); Value mo",MatchSource.WIKI,root/html602/RooAbsCategoryLValue.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsCategoryLValue.html
https://root.cern/root/html602/RooAbsCategoryLValue.html:26084,Performance,cache,cache,26084,"hanges; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; RooAbsCategoryLValue(const char* name, const char* title); Constructor. RooAbsCategoryLValue(const RooAbsCategoryLValue& other, const char* name = 0); Copy constructor. ~RooAbsCategoryLValue(); Destructor. RooAbsArg& operator=(Int_t index); Assignment operator from integer index number. RooAbsArg& operator=(const char* label); Assignment operator from string pointer. RooAbsArg& operator=(const RooAbsCategory& other); Assignment from another RooAbsCategory. Bool_t setOrdinal(UInt_t index, const char* rangeName); Set our state to our n'th defined type and return kTRUE.; Return kFALSE if n is out of range. void copyCache(const RooAbsArg* source, Bool_t valueOnly = kFALSE, Bool_t setValDirty = kTRUE); Copy the cached value from given source and raise dirty flag.; It is the callers responsability to ensure that the sources; cache is clean(valid) before this function is called, e.g. by; calling syncCache() on the source. Bool_t readFromStream(istream& is, Bool_t compact, Bool_t verbose = kFALSE); Read object contents from given stream (dummy implementation). void writeToStream(ostream& os, Bool_t compact) const; Write object contents to given stream (dummy implementation). void randomize(const char* rangeName = 0); Randomize current value. void setBin(Int_t ibin, const char* rangeName = 0); Set category to i-th fit bin, which is the i-th registered state. Int_t getBin(const char* rangeName = 0) const; Get index of plot bin for current value this category. Int_t numBins(const char* rangeName) const; Returm the number of fit bins ( = number of types ). RooAbsCategoryLValue(); Constructor, assignment etc. Bool_t setIndex(Int_t index, Bool_t printError = kTRUE); Value modifiers. Bool_t setLabel(const char* label, Bool_t printError = kTRUE). RooAbsArg& operator=(int index). Int_t getBin(const char* rangeName",MatchSource.WIKI,root/html602/RooAbsCategoryLValue.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsCategoryLValue.html
https://root.cern/root/html602/RooAbsCategoryLValue.html:5555,Security,hash,hash,5555,"y* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); RooExpensiveObjectCache&RooAbsArg::expensiveObjectCache() const; virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); Bool_tRooAbsArg::findConstantNodes(const RooArgSet& observables, RooArgSet& cacheList); Bool_tRooAbsArg::findConstantNodes(const RooArgSet& observables, RooArgSet& cacheList, RooLinkedList& processedNodes); RooAbsArg*RooAbsArg::findNewServer(const RooAbsCollection& newSet, Bool_t nameChange) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; RooAbsArg*RooAbsArg::findServer(const char* name) const; RooAbsArg*RooAbsArg::findServer(const RooAbsArg& arg) const; RooAbsArg*RooAbsArg::findServer(Int_t index) const; static UInt_tRooAbsArg::fnv1a32(const char* data); static UInt_tRooAbsArg::fnv1a32(const char* data, ULong_t sz, UInt_t hash = fnv1a32start); static ULong64_tRooAbsArg::fnv1a64(const char* data); static ULong64_tRooAbsArg::fnv1a64(const char* data, ULong_t sz, ULong64_t hash = fnv1a64start); Bool_tRooAbsArg::getAttribute(const Text_t* name) const; virtual Int_tgetBin(const char* rangeName = 0) const; virtual Int_tgetBin(const RooAbsBinning*) const; virtual list<string>getBinningNames() const; virtual const RooAbsBinning*getBinningPtr(const char*) const; virtual Double_tgetBinWidth(Int_t, const char* = 0) const; RooAbsCache*RooAbsArg::getCache(Int_t index) const; RooLinkedListRooAbsArg::getCloningAncestors() const; RooArgSet*RooAbsArg::getComponents() const; RooArgSet*RooAbsArg::getDependents(const RooArgSet& set) const; RooArgSet*RooAbsArg::getDependents(const RooAbsData* set) const; RooArgSet*RooAbsArg::getDependents(const RooArgSet* depList) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual Int_tRooAbsCate",MatchSource.WIKI,root/html602/RooAbsCategoryLValue.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsCategoryLValue.html
https://root.cern/root/html602/RooAbsCategoryLValue.html:5706,Security,hash,hash,5706,"he() const; virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); Bool_tRooAbsArg::findConstantNodes(const RooArgSet& observables, RooArgSet& cacheList); Bool_tRooAbsArg::findConstantNodes(const RooArgSet& observables, RooArgSet& cacheList, RooLinkedList& processedNodes); RooAbsArg*RooAbsArg::findNewServer(const RooAbsCollection& newSet, Bool_t nameChange) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; RooAbsArg*RooAbsArg::findServer(const char* name) const; RooAbsArg*RooAbsArg::findServer(const RooAbsArg& arg) const; RooAbsArg*RooAbsArg::findServer(Int_t index) const; static UInt_tRooAbsArg::fnv1a32(const char* data); static UInt_tRooAbsArg::fnv1a32(const char* data, ULong_t sz, UInt_t hash = fnv1a32start); static ULong64_tRooAbsArg::fnv1a64(const char* data); static ULong64_tRooAbsArg::fnv1a64(const char* data, ULong_t sz, ULong64_t hash = fnv1a64start); Bool_tRooAbsArg::getAttribute(const Text_t* name) const; virtual Int_tgetBin(const char* rangeName = 0) const; virtual Int_tgetBin(const RooAbsBinning*) const; virtual list<string>getBinningNames() const; virtual const RooAbsBinning*getBinningPtr(const char*) const; virtual Double_tgetBinWidth(Int_t, const char* = 0) const; RooAbsCache*RooAbsArg::getCache(Int_t index) const; RooLinkedListRooAbsArg::getCloningAncestors() const; RooArgSet*RooAbsArg::getComponents() const; RooArgSet*RooAbsArg::getDependents(const RooArgSet& set) const; RooArgSet*RooAbsArg::getDependents(const RooAbsData* set) const; RooArgSet*RooAbsArg::getDependents(const RooArgSet* depList) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual Int_tRooAbsCategory::getIndex() const; virtual const char*RooAbsCategory::getLabel() const; virtual const char*TNamed::GetName() const; virtual char*TObject::GetObjec",MatchSource.WIKI,root/html602/RooAbsCategoryLValue.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsCategoryLValue.html
https://root.cern/root/html602/RooAbsCategoryLValue.html:23786,Security,access,access,23786,ooPrintable::kStandard; static RooPrintable::ContentsOptionRooPrintable::kTitle; static RooPrintable::StyleOptionRooPrintable::kTreeStructure; static RooPrintable::ContentsOptionRooPrintable::kValue; static RooPrintable::StyleOptionRooPrintable::kVerbose; static TObject::(anonymous)TObject::kWriteDelete; static TObject::(anonymous)TObject::kZombie. protected:. set<string>RooAbsArg::_boolAttribBoolean attributes; set<string>RooAbsArg::_boolAttribTransient! Transient boolean attributes (not copied in ctor); UChar_tRooAbsCategory::_byteValue! Transient cache for byte values from tree branches; deque<RooAbsCache*>RooAbsArg::_cacheListlist of caches; RooRefCountListRooAbsArg::_clientListlist of client objects; RooRefCountListRooAbsArg::_clientListShapesubset of clients that requested shape dirty flag propagation; RooRefCountListRooAbsArg::_clientListValuesubset of clients that requested value dirty flag propagation; TIterator*RooAbsArg::_clientShapeIter! Iterator over _clientListShape; TIterator*RooAbsArg::_clientValueIter! Iterator over _clientListValue; Bool_tRooAbsArg::_deleteWatch! Delete watch flag; RooExpensiveObjectCache*RooAbsArg::_eocachePointer to global cache manager for any expensive components created by this object; Bool_tRooAbsArg::_fastAllow fast access mode in getVal() and proxies; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; Bool_tRooAbsArg::_isConstant! Cached isConstant status; Bool_tRooAbsArg::_localNoInhibitDirty! Prevent 'AlwaysDirty' mode for this node; static Int_tRooPrintable::_nameLength; TNamed*RooAbsArg::_namePtr! Do not persist. Pointer to global instance of string that matches object named; RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; RooRefArrayRooAbsArg::_proxyListlist of proxies; RooRefCountListRooAbsArg::_se,MatchSource.WIKI,root/html602/RooAbsCategoryLValue.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsCategoryLValue.html
https://root.cern/root/html602/RooAbsCategoryLValue.html:3513,Testability,test,testArg,3513,"const; virtual TObject*RooAbsArg::Clone(const char* newname = 0) const; virtual RooAbsArg*RooAbsArg::cloneTree(const char* newname = 0) const; virtual Int_tRooAbsArg::Compare(const TObject* other) const; virtual voidRooAbsArg::constOptimizeTestStatistic(RooAbsArg::ConstOpCode opcode, Bool_t doAlsoTrackingOpt = kTRUE); virtual voidTNamed::Copy(TObject& named) const; static UInt_tRooAbsArg::crc32(const char* data); static UInt_tRooAbsArg::crc32(const char* data, ULong_t sz, UInt_t crc = 0); virtual RooAbsArg*RooAbsCategory::createFundamental(const char* newname = 0) const; Roo1DTable*RooAbsCategory::createTable(const char* label) const; virtual Int_tRooAbsArg::defaultPrintContents(Option_t* opt) const; static ostream&RooPrintable::defaultPrintStream(ostream* os = 0); virtual RooPrintable::StyleOptionRooPrintable::defaultPrintStyle(Option_t* opt) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; Bool_tRooAbsArg::dependentOverlaps(const RooAbsData* dset, const RooAbsArg& testArg) const; Bool_tRooAbsArg::dependentOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; Bool_tRooAbsArg::dependsOn(const RooAbsCollection& serverList, const RooAbsArg* ignoreArg = 0, Bool_t valueOnly = kFALSE) const; Bool_tRooAbsArg::dependsOn(const RooAbsArg& server, const RooAbsArg* ignoreArg = 0, Bool_t valueOnly = kFALSE) const; Bool_tRooAbsArg::dependsOnValue(const RooAbsCollection& serverList, const RooAbsArg* ignoreArg = 0) const; Bool_tRooAbsArg::dependsOnValue(const RooAbsArg& server, const RooAbsArg* ignoreArg = 0) const; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTO",MatchSource.WIKI,root/html602/RooAbsCategoryLValue.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsCategoryLValue.html
https://root.cern/root/html602/RooAbsCategoryLValue.html:3607,Testability,test,testArg,3607,"bsArg::cloneTree(const char* newname = 0) const; virtual Int_tRooAbsArg::Compare(const TObject* other) const; virtual voidRooAbsArg::constOptimizeTestStatistic(RooAbsArg::ConstOpCode opcode, Bool_t doAlsoTrackingOpt = kTRUE); virtual voidTNamed::Copy(TObject& named) const; static UInt_tRooAbsArg::crc32(const char* data); static UInt_tRooAbsArg::crc32(const char* data, ULong_t sz, UInt_t crc = 0); virtual RooAbsArg*RooAbsCategory::createFundamental(const char* newname = 0) const; Roo1DTable*RooAbsCategory::createTable(const char* label) const; virtual Int_tRooAbsArg::defaultPrintContents(Option_t* opt) const; static ostream&RooPrintable::defaultPrintStream(ostream* os = 0); virtual RooPrintable::StyleOptionRooPrintable::defaultPrintStyle(Option_t* opt) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; Bool_tRooAbsArg::dependentOverlaps(const RooAbsData* dset, const RooAbsArg& testArg) const; Bool_tRooAbsArg::dependentOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; Bool_tRooAbsArg::dependsOn(const RooAbsCollection& serverList, const RooAbsArg* ignoreArg = 0, Bool_t valueOnly = kFALSE) const; Bool_tRooAbsArg::dependsOn(const RooAbsArg& server, const RooAbsArg* ignoreArg = 0, Bool_t valueOnly = kFALSE) const; Bool_tRooAbsArg::dependsOnValue(const RooAbsCollection& serverList, const RooAbsArg* ignoreArg = 0) const; Bool_tRooAbsArg::dependsOnValue(const RooAbsArg& server, const RooAbsArg* ignoreArg = 0) const; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::Exe",MatchSource.WIKI,root/html602/RooAbsCategoryLValue.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsCategoryLValue.html
https://root.cern/root/html602/RooAbsCategoryLValue.html:10906,Testability,test,testArg,10906,"oAbsArg::isValueServer(const char* name) const; Bool_tTObject::IsZombie() const; voidRooAbsArg::leafNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t recurseNonDerived = kFALSE) const; Bool_tRooAbsArg::localNoDirtyInhibit() const; const RooCatType*RooAbsCategory::lookupType(Int_t index, Bool_t printError = kFALSE) const; const RooCatType*RooAbsCategory::lookupType(const char* label, Bool_t printError = kFALSE) const; const RooCatType*RooAbsCategory::lookupType(const RooCatType& type, Bool_t printError = kFALSE) const; virtual voidTNamed::ls(Option_t* option = """") const; voidTObject::MayNotUse(const char* method) const; static voidRooPrintable::nameFieldLength(Int_t newLen); const TNamed*RooAbsArg::namePtr() const; virtual Bool_tTObject::Notify(); virtual Int_tnumBins(const char* rangeName) const; Int_tRooAbsArg::numCaches() const; Int_tRooAbsCategory::numTypes(const char* = 0) const; Bool_tRooAbsArg::observableOverlaps(const RooAbsData* dset, const RooAbsArg& testArg) const; Bool_tRooAbsArg::observableOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; voidTObject::operator delete(void* ptr); voidTObject::operator delete(void* ptr, void* vp); voidTObject::operator delete[](void* ptr); voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); Bool_tRooAbsCategory::operator!=(Int_t index); Bool_tRooAbsCategory::operator!=(const char* label); Bool_tRooAbsCategory::operator!=(const RooAbsArg& other); RooAbsArg&operator=(int index); RooAbsArg&operator=(const char* label); RooAbsArg&operator=(const RooAbsCategory& other); RooAbsCategoryLValue&operator=(const RooAbsCategoryLValue&); Bool_tRooAbsCategory::operator==(Int_t index) const; Bool_tRooAbsCategory::operator=",MatchSource.WIKI,root/html602/RooAbsCategoryLValue.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsCategoryLValue.html
https://root.cern/root/html602/RooAbsCategoryLValue.html:11001,Testability,test,testArg,11001,":leafNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t recurseNonDerived = kFALSE) const; Bool_tRooAbsArg::localNoDirtyInhibit() const; const RooCatType*RooAbsCategory::lookupType(Int_t index, Bool_t printError = kFALSE) const; const RooCatType*RooAbsCategory::lookupType(const char* label, Bool_t printError = kFALSE) const; const RooCatType*RooAbsCategory::lookupType(const RooCatType& type, Bool_t printError = kFALSE) const; virtual voidTNamed::ls(Option_t* option = """") const; voidTObject::MayNotUse(const char* method) const; static voidRooPrintable::nameFieldLength(Int_t newLen); const TNamed*RooAbsArg::namePtr() const; virtual Bool_tTObject::Notify(); virtual Int_tnumBins(const char* rangeName) const; Int_tRooAbsArg::numCaches() const; Int_tRooAbsCategory::numTypes(const char* = 0) const; Bool_tRooAbsArg::observableOverlaps(const RooAbsData* dset, const RooAbsArg& testArg) const; Bool_tRooAbsArg::observableOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; voidTObject::operator delete(void* ptr); voidTObject::operator delete(void* ptr, void* vp); voidTObject::operator delete[](void* ptr); voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); Bool_tRooAbsCategory::operator!=(Int_t index); Bool_tRooAbsCategory::operator!=(const char* label); Bool_tRooAbsCategory::operator!=(const RooAbsArg& other); RooAbsArg&operator=(int index); RooAbsArg&operator=(const char* label); RooAbsArg&operator=(const RooAbsCategory& other); RooAbsCategoryLValue&operator=(const RooAbsCategoryLValue&); Bool_tRooAbsCategory::operator==(Int_t index) const; Bool_tRooAbsCategory::operator==(const char* label) const; virtual Bool_tRooAbsCategory::operator==(const RooAbsArg& other); R",MatchSource.WIKI,root/html602/RooAbsCategoryLValue.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsCategoryLValue.html
https://root.cern/root/html602/RooAbsCategoryLValue.html:12291,Testability,test,testArg,12291,"oid* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); Bool_tRooAbsCategory::operator!=(Int_t index); Bool_tRooAbsCategory::operator!=(const char* label); Bool_tRooAbsCategory::operator!=(const RooAbsArg& other); RooAbsArg&operator=(int index); RooAbsArg&operator=(const char* label); RooAbsArg&operator=(const RooAbsCategory& other); RooAbsCategoryLValue&operator=(const RooAbsCategoryLValue&); Bool_tRooAbsCategory::operator==(Int_t index) const; Bool_tRooAbsCategory::operator==(const char* label) const; virtual Bool_tRooAbsCategory::operator==(const RooAbsArg& other); RooAbsArg::OperModeRooAbsArg::operMode() const; virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables); virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables, RooArgSet& optNodes, RooLinkedList& processedNodes); Bool_tRooAbsArg::overlaps(const RooAbsArg& testArg, Bool_t valueOnly = kFALSE) const; const RooArgSet*RooAbsArg::ownedComponents() const; virtual voidTObject::Paint(Option_t* option = """"); virtual voidTObject::Pop(); virtual voidRooAbsArg::Print(Option_t* options = 0) const; virtual voidRooAbsArg::printAddress(ostream& os) const; virtual voidRooAbsArg::printArgs(ostream& os) const; virtual voidRooAbsArg::printClassName(ostream& os) const; voidRooAbsArg::printCompactTree(const char* indent = """", const char* fileName = 0, const char* namePat = 0, RooAbsArg* client = 0); voidRooAbsArg::printCompactTree(ostream& os, const char* indent = """", const char* namePat = 0, RooAbsArg* client = 0); virtual voidRooAbsArg::printCompactTreeHook(ostream& os, const char* ind = """"); voidRooAbsArg::printComponentTree(const char* indent = """", const char* namePat = 0, Int_t nLevel = 999); voidRooAbsArg::printDirty(Bool_t depth = kTRUE) const; virtual voidRooPrintable::printExtras(ostream& os) const; virtual voidRooAbsArg::printMetaArgs(ostream&) const; v",MatchSource.WIKI,root/html602/RooAbsCategoryLValue.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsCategoryLValue.html
https://root.cern/root/html602/RooAbsCategoryLValue.html:2301,Usability,clear,clearShapeDirty,2301,"tion& serverList, Bool_t valueProp = kTRUE, Bool_t shapeProp = kFALSE); const char*RooAbsArg::aggregateCacheUniqueSuffix() const; virtual voidTObject::AppendPad(Option_t* option = """"); voidRooAbsArg::attachDataSet(const RooAbsData& set); voidRooAbsArg::attachDataStore(const RooAbsDataStore& set); const set<string>&RooAbsArg::attributes() const; voidRooAbsArg::branchNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t recurseNonDerived = kFALSE) const; virtual voidTObject::Browse(TBrowser* b); virtual const char*RooAbsArg::cacheUniqueSuffix() const; virtual RooAbsArg::CacheModeRooAbsArg::canNodeBeCached() const; voidRooAbsArg::changeServer(RooAbsArg& server, Bool_t valueProp, Bool_t shapeProp); Bool_tRooAbsArg::checkDependents(const RooArgSet* nset) const; virtual Bool_tRooAbsArg::checkObservables(const RooArgSet* nset) const; static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); voidRooAbsArg::clearShapeDirty() const; voidRooAbsArg::clearValueAndShapeDirty() const; voidRooAbsArg::clearValueDirty() const; TIterator*RooAbsArg::clientIterator() const; virtual TObject*RooAbsArg::clone(const char* newname = 0) const; virtual TObject*RooAbsArg::Clone(const char* newname = 0) const; virtual RooAbsArg*RooAbsArg::cloneTree(const char* newname = 0) const; virtual Int_tRooAbsArg::Compare(const TObject* other) const; virtual voidRooAbsArg::constOptimizeTestStatistic(RooAbsArg::ConstOpCode opcode, Bool_t doAlsoTrackingOpt = kTRUE); virtual voidTNamed::Copy(TObject& named) const; static UInt_tRooAbsArg::crc32(const char* data); static UInt_tRooAbsArg::crc32(const char* data, ULong_t sz, UInt_t crc = 0); virtual RooAbsArg*RooAbsCategory::createFundamental(const char* newname = 0) const; Roo1DTable*RooAbsCategory::createTable(const char* label) const; virtual Int_tRooAbsArg::defaultPrintContents(Option_t* opt) const; static ostream&RooPrintable::defaultPrintStream(ostream* os = 0); virtual RooPrint",MatchSource.WIKI,root/html602/RooAbsCategoryLValue.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsCategoryLValue.html
https://root.cern/root/html602/RooAbsCategoryLValue.html:2341,Usability,clear,clearValueAndShapeDirty,2341,"Bool_t shapeProp = kFALSE); const char*RooAbsArg::aggregateCacheUniqueSuffix() const; virtual voidTObject::AppendPad(Option_t* option = """"); voidRooAbsArg::attachDataSet(const RooAbsData& set); voidRooAbsArg::attachDataStore(const RooAbsDataStore& set); const set<string>&RooAbsArg::attributes() const; voidRooAbsArg::branchNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t recurseNonDerived = kFALSE) const; virtual voidTObject::Browse(TBrowser* b); virtual const char*RooAbsArg::cacheUniqueSuffix() const; virtual RooAbsArg::CacheModeRooAbsArg::canNodeBeCached() const; voidRooAbsArg::changeServer(RooAbsArg& server, Bool_t valueProp, Bool_t shapeProp); Bool_tRooAbsArg::checkDependents(const RooArgSet* nset) const; virtual Bool_tRooAbsArg::checkObservables(const RooArgSet* nset) const; static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); voidRooAbsArg::clearShapeDirty() const; voidRooAbsArg::clearValueAndShapeDirty() const; voidRooAbsArg::clearValueDirty() const; TIterator*RooAbsArg::clientIterator() const; virtual TObject*RooAbsArg::clone(const char* newname = 0) const; virtual TObject*RooAbsArg::Clone(const char* newname = 0) const; virtual RooAbsArg*RooAbsArg::cloneTree(const char* newname = 0) const; virtual Int_tRooAbsArg::Compare(const TObject* other) const; virtual voidRooAbsArg::constOptimizeTestStatistic(RooAbsArg::ConstOpCode opcode, Bool_t doAlsoTrackingOpt = kTRUE); virtual voidTNamed::Copy(TObject& named) const; static UInt_tRooAbsArg::crc32(const char* data); static UInt_tRooAbsArg::crc32(const char* data, ULong_t sz, UInt_t crc = 0); virtual RooAbsArg*RooAbsCategory::createFundamental(const char* newname = 0) const; Roo1DTable*RooAbsCategory::createTable(const char* label) const; virtual Int_tRooAbsArg::defaultPrintContents(Option_t* opt) const; static ostream&RooPrintable::defaultPrintStream(ostream* os = 0); virtual RooPrintable::StyleOptionRooPrintable::defaultPrintS",MatchSource.WIKI,root/html602/RooAbsCategoryLValue.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsCategoryLValue.html
https://root.cern/root/html602/RooAbsCategoryLValue.html:2389,Usability,clear,clearValueDirty,2389,"sArg::aggregateCacheUniqueSuffix() const; virtual voidTObject::AppendPad(Option_t* option = """"); voidRooAbsArg::attachDataSet(const RooAbsData& set); voidRooAbsArg::attachDataStore(const RooAbsDataStore& set); const set<string>&RooAbsArg::attributes() const; voidRooAbsArg::branchNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t recurseNonDerived = kFALSE) const; virtual voidTObject::Browse(TBrowser* b); virtual const char*RooAbsArg::cacheUniqueSuffix() const; virtual RooAbsArg::CacheModeRooAbsArg::canNodeBeCached() const; voidRooAbsArg::changeServer(RooAbsArg& server, Bool_t valueProp, Bool_t shapeProp); Bool_tRooAbsArg::checkDependents(const RooArgSet* nset) const; virtual Bool_tRooAbsArg::checkObservables(const RooArgSet* nset) const; static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); voidRooAbsArg::clearShapeDirty() const; voidRooAbsArg::clearValueAndShapeDirty() const; voidRooAbsArg::clearValueDirty() const; TIterator*RooAbsArg::clientIterator() const; virtual TObject*RooAbsArg::clone(const char* newname = 0) const; virtual TObject*RooAbsArg::Clone(const char* newname = 0) const; virtual RooAbsArg*RooAbsArg::cloneTree(const char* newname = 0) const; virtual Int_tRooAbsArg::Compare(const TObject* other) const; virtual voidRooAbsArg::constOptimizeTestStatistic(RooAbsArg::ConstOpCode opcode, Bool_t doAlsoTrackingOpt = kTRUE); virtual voidTNamed::Copy(TObject& named) const; static UInt_tRooAbsArg::crc32(const char* data); static UInt_tRooAbsArg::crc32(const char* data, ULong_t sz, UInt_t crc = 0); virtual RooAbsArg*RooAbsCategory::createFundamental(const char* newname = 0) const; Roo1DTable*RooAbsCategory::createTable(const char* label) const; virtual Int_tRooAbsArg::defaultPrintContents(Option_t* opt) const; static ostream&RooPrintable::defaultPrintStream(ostream* os = 0); virtual RooPrintable::StyleOptionRooPrintable::defaultPrintStyle(Option_t* opt) const; virtual voidTObje",MatchSource.WIKI,root/html602/RooAbsCategoryLValue.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsCategoryLValue.html
https://root.cern/root/html602/RooAbsCategoryLValue.html:18468,Usability,clear,clearTypes,18468,,MatchSource.WIKI,root/html602/RooAbsCategoryLValue.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsCategoryLValue.html
https://root.cern/root/html602/RooAbsCollection.html:879,Availability,avail,available,879,". RooAbsCollection. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » ROOFIT; » ROOFITCORE; » RooAbsCollection. class RooAbsCollection: public TObject, public RooPrintable. RooAbsCollection is an abstract container object that can hold; multiple RooAbsArg objects. Collections are ordered and can; contain multiple objects of the same name, (but a derived; implementation can enforce unique names). The storage of objects in; implement through class RooLinkedList, a doubly linked list with an; an optional hash-table lookup mechanism for fast indexing of large; collections. ; . Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~RooAbsCollection(); voidTObject::AbstractMethod(const char* method) const; virtual Bool_tadd(const RooAbsArg& var, Bool_t silent = kFALSE); virtual Bool_tadd(const RooAbsCollection& list, Bool_t silent = kFALSE); virtual RooAbsArg*addClone(const RooAbsArg& var, Bool_t silent = kFALSE); virtual voidaddClone(const RooAbsCollection& list, Bool_t silent = kFALSE); virtual Bool_taddOwned(RooAbsArg& var, Bool_t silent = kFALSE); virtual Bool_taddOwned(const RooAbsCollection& list, Bool_t silent = kFALSE); Bool_tallInRange(const char* rangeSpec) const; virtual voidTObject::AppendPad(Option_t* option = """"); voidassignFast(const RooAbsCollection& other, Bool_t setValDirty = kTRUE); RooAbsCollection&assignValueOnly(const RooAbsCollection& other, Bool_t oneSafe = kFALSE); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*clone(const char* newname) const; virtual TObject*Clone(const char* newname = 0) const; virtual Int_tTObject::Compare(const TObject* obj",MatchSource.WIKI,root/html602/RooAbsCollection.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsCollection.html
https://root.cern/root/html602/RooAbsCollection.html:3053,Availability,error,error,3053,"ol_tcontainsInstance(const RooAbsArg& var) const; stringcontentsString() const; virtual voidTObject::Copy(TObject& object) const; virtual TObject*create(const char* newname) const; TIterator*createIterator(Bool_t dir = kIterForward) const; virtual Int_tdefaultPrintContents(Option_t* opt) const; static ostream&RooPrintable::defaultPrintStream(ostream* os = 0); virtual RooPrintable::StyleOptionRooPrintable::defaultPrintStyle(Option_t* opt) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; voiddump() const; virtual voidTObject::Dump() constMENU ; Bool_tequals(const RooAbsCollection& otherColl) const; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; RooAbsArg*find(const char* name) const; RooAbsArg*find(const RooAbsArg&) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; RooAbsArg*first() const; RooFIterfwdIterator() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); Int_tgetHashTableSize() const; virtual const char*TObject::GetIconName() const; virtual const char*GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; Int_tgetSize() const; virtual const char*TObject::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* tim",MatchSource.WIKI,root/html602/RooAbsCollection.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsCollection.html
https://root.cern/root/html602/RooAbsCollection.html:3137,Availability,error,error,3137,"ual voidTObject::Copy(TObject& object) const; virtual TObject*create(const char* newname) const; TIterator*createIterator(Bool_t dir = kIterForward) const; virtual Int_tdefaultPrintContents(Option_t* opt) const; static ostream&RooPrintable::defaultPrintStream(ostream* os = 0); virtual RooPrintable::StyleOptionRooPrintable::defaultPrintStyle(Option_t* opt) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; voiddump() const; virtual voidTObject::Dump() constMENU ; Bool_tequals(const RooAbsCollection& otherColl) const; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; RooAbsArg*find(const char* name) const; RooAbsArg*find(const RooAbsArg&) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; RooAbsArg*first() const; RooFIterfwdIterator() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); Int_tgetHashTableSize() const; virtual const char*TObject::GetIconName() const; virtual const char*GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; Int_tgetSize() const; virtual const char*TObject::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTObject::Hash() const; virtual voidTObject::Info(const char* met",MatchSource.WIKI,root/html602/RooAbsCollection.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsCollection.html
https://root.cern/root/html602/RooAbsCollection.html:20341,Availability,error,error,20341,"ult behavior. Columns(Int_t ncol) -- Fold table into multiple columns, i.e. ncol=3 will result in 3 x 2 = 6 total columns; Sibling(const RooAbsCollection& other) -- Define sibling list. The sibling list is assumed to have objects with the same; name in the same order. If this is not the case warnings will be printed. If a single; sibling list is specified, 3 columns will be output: the (common) name, the value of this; list and the value in the sibling list. Multiple sibling lists can be specified by; repeating the Sibling() command.; Format(const char* str) -- Classic format string, provided for backward compatibility; Format(...) -- Formatting arguments, details are given below; OutputFile(const char* fname) -- Send output to file with given name rather than standard output. The Format(const char* what,...) has the following structure. const char* what -- Controls what is shown. ""N"" adds name, ""E"" adds error,; ""A"" shows asymmetric error, ""U"" shows unit, ""H"" hides the value; FixedPrecision(int n) -- Controls precision, set fixed number of digits; AutoPrecision(int n) -- Controls precision. Number of shown digits is calculated from error; + n specified additional digits (1 is sensible default); VerbatimName(Bool_t flag) -- Put variable name in a \verb+ + clause. Example use: list.printLatex(Columns(2), Format(""NEU"",AutoPrecision(1),VerbatimName()) ) ;. void printLatex(ostream& ofs, Int_t ncol, const char* option = ""NEYU"", Int_t sigDigit = 1, const RooLinkedList& siblingLists = RooLinkedList(), const RooCmdArg* formatCmd = 0) const; Internal implementation function of printLatex. Bool_t allInRange(const char* rangeSpec) const; Return true if all contained object report to have their; value inside the specified range. void makeStructureTag(). void makeTypedStructureTag(). TObject* clone(const char* newname) const. TObject* create(const char* newname) const. TObject* Clone(const char* newname = 0) const. void setHashTableSize(Int_t i); Hash table control. Int_t getHash",MatchSource.WIKI,root/html602/RooAbsCollection.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsCollection.html
https://root.cern/root/html602/RooAbsCollection.html:20370,Availability,error,error,20370,"ult behavior. Columns(Int_t ncol) -- Fold table into multiple columns, i.e. ncol=3 will result in 3 x 2 = 6 total columns; Sibling(const RooAbsCollection& other) -- Define sibling list. The sibling list is assumed to have objects with the same; name in the same order. If this is not the case warnings will be printed. If a single; sibling list is specified, 3 columns will be output: the (common) name, the value of this; list and the value in the sibling list. Multiple sibling lists can be specified by; repeating the Sibling() command.; Format(const char* str) -- Classic format string, provided for backward compatibility; Format(...) -- Formatting arguments, details are given below; OutputFile(const char* fname) -- Send output to file with given name rather than standard output. The Format(const char* what,...) has the following structure. const char* what -- Controls what is shown. ""N"" adds name, ""E"" adds error,; ""A"" shows asymmetric error, ""U"" shows unit, ""H"" hides the value; FixedPrecision(int n) -- Controls precision, set fixed number of digits; AutoPrecision(int n) -- Controls precision. Number of shown digits is calculated from error; + n specified additional digits (1 is sensible default); VerbatimName(Bool_t flag) -- Put variable name in a \verb+ + clause. Example use: list.printLatex(Columns(2), Format(""NEU"",AutoPrecision(1),VerbatimName()) ) ;. void printLatex(ostream& ofs, Int_t ncol, const char* option = ""NEYU"", Int_t sigDigit = 1, const RooLinkedList& siblingLists = RooLinkedList(), const RooCmdArg* formatCmd = 0) const; Internal implementation function of printLatex. Bool_t allInRange(const char* rangeSpec) const; Return true if all contained object report to have their; value inside the specified range. void makeStructureTag(). void makeTypedStructureTag(). TObject* clone(const char* newname) const. TObject* create(const char* newname) const. TObject* Clone(const char* newname = 0) const. void setHashTableSize(Int_t i); Hash table control. Int_t getHash",MatchSource.WIKI,root/html602/RooAbsCollection.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsCollection.html
https://root.cern/root/html602/RooAbsCollection.html:20573,Availability,error,error,20573,"ing list is assumed to have objects with the same; name in the same order. If this is not the case warnings will be printed. If a single; sibling list is specified, 3 columns will be output: the (common) name, the value of this; list and the value in the sibling list. Multiple sibling lists can be specified by; repeating the Sibling() command.; Format(const char* str) -- Classic format string, provided for backward compatibility; Format(...) -- Formatting arguments, details are given below; OutputFile(const char* fname) -- Send output to file with given name rather than standard output. The Format(const char* what,...) has the following structure. const char* what -- Controls what is shown. ""N"" adds name, ""E"" adds error,; ""A"" shows asymmetric error, ""U"" shows unit, ""H"" hides the value; FixedPrecision(int n) -- Controls precision, set fixed number of digits; AutoPrecision(int n) -- Controls precision. Number of shown digits is calculated from error; + n specified additional digits (1 is sensible default); VerbatimName(Bool_t flag) -- Put variable name in a \verb+ + clause. Example use: list.printLatex(Columns(2), Format(""NEU"",AutoPrecision(1),VerbatimName()) ) ;. void printLatex(ostream& ofs, Int_t ncol, const char* option = ""NEYU"", Int_t sigDigit = 1, const RooLinkedList& siblingLists = RooLinkedList(), const RooCmdArg* formatCmd = 0) const; Internal implementation function of printLatex. Bool_t allInRange(const char* rangeSpec) const; Return true if all contained object report to have their; value inside the specified range. void makeStructureTag(). void makeTypedStructureTag(). TObject* clone(const char* newname) const. TObject* create(const char* newname) const. TObject* Clone(const char* newname = 0) const. void setHashTableSize(Int_t i); Hash table control. Int_t getHashTableSize() const; Return size of internal hash table. Bool_t contains(const RooAbsArg& var) const; Returns true if object with same name as var is contained in this collection. Bool_t containsIn",MatchSource.WIKI,root/html602/RooAbsCollection.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsCollection.html
https://root.cern/root/html602/RooAbsCollection.html:22261,Deployability,release,releaseOwnership,22261,"inkedList(), const RooCmdArg* formatCmd = 0) const; Internal implementation function of printLatex. Bool_t allInRange(const char* rangeSpec) const; Return true if all contained object report to have their; value inside the specified range. void makeStructureTag(). void makeTypedStructureTag(). TObject* clone(const char* newname) const. TObject* create(const char* newname) const. TObject* Clone(const char* newname = 0) const. void setHashTableSize(Int_t i); Hash table control. Int_t getHashTableSize() const; Return size of internal hash table. Bool_t contains(const RooAbsArg& var) const; Returns true if object with same name as var is contained in this collection. Bool_t containsInstance(const RooAbsArg& var) const; Returns true if var is contained in this collection. TIterator* createIterator(Bool_t dir = kIterForward) const; export subset of THashList interface. RooFIter fwdIterator() const; { return RooFIter(&_list); }. Int_t getSize() const; Return the number of elements in the collection. RooAbsArg * first() const; Return the first element in this collection. void Print(Option_t* options = 0) const; Printing interface (human readable). void setName(const char* name); Set name of collection. const char* GetName() const; Return namer of collection. Bool_t isOwning() const; Does collection own contents?. void releaseOwnership(); { _ownCont = kFALSE ; }. void takeOwnership(); { _ownCont = kTRUE ; }. void sort(Bool_t ascend = kTRUE); { _list.Sort(ascend) ; }. TNamed* structureTag(); { if (_structureTag==0) makeStructureTag() ; return _structureTag ; }. TNamed* typedStructureTag(); { if (_typedStructureTag==0) makeTypedStructureTag() ; return _typedStructureTag ; }. void clearStructureTags(); { _structureTag=0 ; _typedStructureTag = 0 ; }. » Last changed: Tue Jun 30 14:30:02 2015 » Last generated: 2015-06-30 14:30; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html602/RooAbsCollection.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsCollection.html
https://root.cern/root/html602/RooAbsCollection.html:11717,Integrability,depend,dependencies,11717,"TObject::kWriteDelete; static TObject::(anonymous)TObject::kZombie. protected:. Bool_t_allRRVAll contents are RRV; RooLinkedList_listActual object store; TString_nameOur name.; static Int_tRooPrintable::_nameLength; Bool_t_ownContFlag to identify a list that owns its contents.; TNamed*_structureTag! Structure tag; TNamed*_typedStructureTag! Typed structure tag. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; RooAbsCollection(); Default constructor. RooAbsCollection(const char* name); Empty collection constructor. RooAbsCollection(const RooAbsCollection& other, const char* name = """"); Copy constructor. Note that a copy of a collection is always non-owning,; even the source collection is owning. To create an owning copy of; a collection (owning or not), use the snaphot() method. ~RooAbsCollection(); Destructor. RooLinkedListIter iterator(Bool_t dir = kIterForward) const. void safeDeleteList(); Examine client server dependencies in list and; delete contents in safe order: any client; is deleted before a server is deleted. RooAbsCollection* snapshot(Bool_t deepCopy = kTRUE) const; Take a snap shot of current collection contents:; An owning collection is returned containing clones of. - Elements in this collection; - External dependents of all elements; and recursively any dependents of those dependents; (if deepCopy flag is set). If deepCopy is specified, the client-server links between the cloned; list elements and the cloned external dependents are reconnected to; each other, making the snapshot a completely self-contained entity. Bool_t snapshot(RooAbsCollection& output, Bool_t deepCopy = kTRUE) const; Take a snap shot of current collection contents:; An owning collection is returned containing clones of. - Elements in this collection; - External dependents of all elements; and recursively any dependents of those dependents; (if deepCopy flag is set). If deepCopy is specified, the client-server links between the cloned; list ",MatchSource.WIKI,root/html602/RooAbsCollection.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsCollection.html
https://root.cern/root/html602/RooAbsCollection.html:12031,Integrability,depend,dependents,12031," TNamed*_typedStructureTag! Typed structure tag. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; RooAbsCollection(); Default constructor. RooAbsCollection(const char* name); Empty collection constructor. RooAbsCollection(const RooAbsCollection& other, const char* name = """"); Copy constructor. Note that a copy of a collection is always non-owning,; even the source collection is owning. To create an owning copy of; a collection (owning or not), use the snaphot() method. ~RooAbsCollection(); Destructor. RooLinkedListIter iterator(Bool_t dir = kIterForward) const. void safeDeleteList(); Examine client server dependencies in list and; delete contents in safe order: any client; is deleted before a server is deleted. RooAbsCollection* snapshot(Bool_t deepCopy = kTRUE) const; Take a snap shot of current collection contents:; An owning collection is returned containing clones of. - Elements in this collection; - External dependents of all elements; and recursively any dependents of those dependents; (if deepCopy flag is set). If deepCopy is specified, the client-server links between the cloned; list elements and the cloned external dependents are reconnected to; each other, making the snapshot a completely self-contained entity. Bool_t snapshot(RooAbsCollection& output, Bool_t deepCopy = kTRUE) const; Take a snap shot of current collection contents:; An owning collection is returned containing clones of. - Elements in this collection; - External dependents of all elements; and recursively any dependents of those dependents; (if deepCopy flag is set). If deepCopy is specified, the client-server links between the cloned; list elements and the cloned external dependents are reconnected to; each other, making the snapshot a completely self-contained entity. Bool_t addServerClonesToList(const RooAbsArg& var); Add clones of servers of given argument to list. RooAbsCollection & operator=(const RooAbsCollection& other); The assignment operat",MatchSource.WIKI,root/html602/RooAbsCollection.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsCollection.html
https://root.cern/root/html602/RooAbsCollection.html:12079,Integrability,depend,dependents,12079," TNamed*_typedStructureTag! Typed structure tag. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; RooAbsCollection(); Default constructor. RooAbsCollection(const char* name); Empty collection constructor. RooAbsCollection(const RooAbsCollection& other, const char* name = """"); Copy constructor. Note that a copy of a collection is always non-owning,; even the source collection is owning. To create an owning copy of; a collection (owning or not), use the snaphot() method. ~RooAbsCollection(); Destructor. RooLinkedListIter iterator(Bool_t dir = kIterForward) const. void safeDeleteList(); Examine client server dependencies in list and; delete contents in safe order: any client; is deleted before a server is deleted. RooAbsCollection* snapshot(Bool_t deepCopy = kTRUE) const; Take a snap shot of current collection contents:; An owning collection is returned containing clones of. - Elements in this collection; - External dependents of all elements; and recursively any dependents of those dependents; (if deepCopy flag is set). If deepCopy is specified, the client-server links between the cloned; list elements and the cloned external dependents are reconnected to; each other, making the snapshot a completely self-contained entity. Bool_t snapshot(RooAbsCollection& output, Bool_t deepCopy = kTRUE) const; Take a snap shot of current collection contents:; An owning collection is returned containing clones of. - Elements in this collection; - External dependents of all elements; and recursively any dependents of those dependents; (if deepCopy flag is set). If deepCopy is specified, the client-server links between the cloned; list elements and the cloned external dependents are reconnected to; each other, making the snapshot a completely self-contained entity. Bool_t addServerClonesToList(const RooAbsArg& var); Add clones of servers of given argument to list. RooAbsCollection & operator=(const RooAbsCollection& other); The assignment operat",MatchSource.WIKI,root/html602/RooAbsCollection.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsCollection.html
https://root.cern/root/html602/RooAbsCollection.html:12099,Integrability,depend,dependents,12099," TNamed*_typedStructureTag! Typed structure tag. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; RooAbsCollection(); Default constructor. RooAbsCollection(const char* name); Empty collection constructor. RooAbsCollection(const RooAbsCollection& other, const char* name = """"); Copy constructor. Note that a copy of a collection is always non-owning,; even the source collection is owning. To create an owning copy of; a collection (owning or not), use the snaphot() method. ~RooAbsCollection(); Destructor. RooLinkedListIter iterator(Bool_t dir = kIterForward) const. void safeDeleteList(); Examine client server dependencies in list and; delete contents in safe order: any client; is deleted before a server is deleted. RooAbsCollection* snapshot(Bool_t deepCopy = kTRUE) const; Take a snap shot of current collection contents:; An owning collection is returned containing clones of. - Elements in this collection; - External dependents of all elements; and recursively any dependents of those dependents; (if deepCopy flag is set). If deepCopy is specified, the client-server links between the cloned; list elements and the cloned external dependents are reconnected to; each other, making the snapshot a completely self-contained entity. Bool_t snapshot(RooAbsCollection& output, Bool_t deepCopy = kTRUE) const; Take a snap shot of current collection contents:; An owning collection is returned containing clones of. - Elements in this collection; - External dependents of all elements; and recursively any dependents of those dependents; (if deepCopy flag is set). If deepCopy is specified, the client-server links between the cloned; list elements and the cloned external dependents are reconnected to; each other, making the snapshot a completely self-contained entity. Bool_t addServerClonesToList(const RooAbsArg& var); Add clones of servers of given argument to list. RooAbsCollection & operator=(const RooAbsCollection& other); The assignment operat",MatchSource.WIKI,root/html602/RooAbsCollection.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsCollection.html
https://root.cern/root/html602/RooAbsCollection.html:12246,Integrability,depend,dependents,12246,"r. RooAbsCollection(const char* name); Empty collection constructor. RooAbsCollection(const RooAbsCollection& other, const char* name = """"); Copy constructor. Note that a copy of a collection is always non-owning,; even the source collection is owning. To create an owning copy of; a collection (owning or not), use the snaphot() method. ~RooAbsCollection(); Destructor. RooLinkedListIter iterator(Bool_t dir = kIterForward) const. void safeDeleteList(); Examine client server dependencies in list and; delete contents in safe order: any client; is deleted before a server is deleted. RooAbsCollection* snapshot(Bool_t deepCopy = kTRUE) const; Take a snap shot of current collection contents:; An owning collection is returned containing clones of. - Elements in this collection; - External dependents of all elements; and recursively any dependents of those dependents; (if deepCopy flag is set). If deepCopy is specified, the client-server links between the cloned; list elements and the cloned external dependents are reconnected to; each other, making the snapshot a completely self-contained entity. Bool_t snapshot(RooAbsCollection& output, Bool_t deepCopy = kTRUE) const; Take a snap shot of current collection contents:; An owning collection is returned containing clones of. - Elements in this collection; - External dependents of all elements; and recursively any dependents of those dependents; (if deepCopy flag is set). If deepCopy is specified, the client-server links between the cloned; list elements and the cloned external dependents are reconnected to; each other, making the snapshot a completely self-contained entity. Bool_t addServerClonesToList(const RooAbsArg& var); Add clones of servers of given argument to list. RooAbsCollection & operator=(const RooAbsCollection& other); The assignment operator sets the value of any argument in our set; that also appears in the other set. RooAbsCollection & assignValueOnly(const RooAbsCollection& other, Bool_t oneSafe = kFALSE); The ",MatchSource.WIKI,root/html602/RooAbsCollection.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsCollection.html
https://root.cern/root/html602/RooAbsCollection.html:12566,Integrability,depend,dependents,12566,"; Destructor. RooLinkedListIter iterator(Bool_t dir = kIterForward) const. void safeDeleteList(); Examine client server dependencies in list and; delete contents in safe order: any client; is deleted before a server is deleted. RooAbsCollection* snapshot(Bool_t deepCopy = kTRUE) const; Take a snap shot of current collection contents:; An owning collection is returned containing clones of. - Elements in this collection; - External dependents of all elements; and recursively any dependents of those dependents; (if deepCopy flag is set). If deepCopy is specified, the client-server links between the cloned; list elements and the cloned external dependents are reconnected to; each other, making the snapshot a completely self-contained entity. Bool_t snapshot(RooAbsCollection& output, Bool_t deepCopy = kTRUE) const; Take a snap shot of current collection contents:; An owning collection is returned containing clones of. - Elements in this collection; - External dependents of all elements; and recursively any dependents of those dependents; (if deepCopy flag is set). If deepCopy is specified, the client-server links between the cloned; list elements and the cloned external dependents are reconnected to; each other, making the snapshot a completely self-contained entity. Bool_t addServerClonesToList(const RooAbsArg& var); Add clones of servers of given argument to list. RooAbsCollection & operator=(const RooAbsCollection& other); The assignment operator sets the value of any argument in our set; that also appears in the other set. RooAbsCollection & assignValueOnly(const RooAbsCollection& other, Bool_t oneSafe = kFALSE); The assignment operator sets the value of any argument in our set; that also appears in the other set. void assignFast(const RooAbsCollection& other, Bool_t setValDirty = kTRUE); Functional equivalent of operator=() but assumes this and other collection; have same layout. Also no attributes are copied. Bool_t addOwned(RooAbsArg& var, Bool_t silent = kFALSE); ",MatchSource.WIKI,root/html602/RooAbsCollection.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsCollection.html
https://root.cern/root/html602/RooAbsCollection.html:12614,Integrability,depend,dependents,12614,"; Destructor. RooLinkedListIter iterator(Bool_t dir = kIterForward) const. void safeDeleteList(); Examine client server dependencies in list and; delete contents in safe order: any client; is deleted before a server is deleted. RooAbsCollection* snapshot(Bool_t deepCopy = kTRUE) const; Take a snap shot of current collection contents:; An owning collection is returned containing clones of. - Elements in this collection; - External dependents of all elements; and recursively any dependents of those dependents; (if deepCopy flag is set). If deepCopy is specified, the client-server links between the cloned; list elements and the cloned external dependents are reconnected to; each other, making the snapshot a completely self-contained entity. Bool_t snapshot(RooAbsCollection& output, Bool_t deepCopy = kTRUE) const; Take a snap shot of current collection contents:; An owning collection is returned containing clones of. - Elements in this collection; - External dependents of all elements; and recursively any dependents of those dependents; (if deepCopy flag is set). If deepCopy is specified, the client-server links between the cloned; list elements and the cloned external dependents are reconnected to; each other, making the snapshot a completely self-contained entity. Bool_t addServerClonesToList(const RooAbsArg& var); Add clones of servers of given argument to list. RooAbsCollection & operator=(const RooAbsCollection& other); The assignment operator sets the value of any argument in our set; that also appears in the other set. RooAbsCollection & assignValueOnly(const RooAbsCollection& other, Bool_t oneSafe = kFALSE); The assignment operator sets the value of any argument in our set; that also appears in the other set. void assignFast(const RooAbsCollection& other, Bool_t setValDirty = kTRUE); Functional equivalent of operator=() but assumes this and other collection; have same layout. Also no attributes are copied. Bool_t addOwned(RooAbsArg& var, Bool_t silent = kFALSE); ",MatchSource.WIKI,root/html602/RooAbsCollection.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsCollection.html
https://root.cern/root/html602/RooAbsCollection.html:12634,Integrability,depend,dependents,12634,"; Destructor. RooLinkedListIter iterator(Bool_t dir = kIterForward) const. void safeDeleteList(); Examine client server dependencies in list and; delete contents in safe order: any client; is deleted before a server is deleted. RooAbsCollection* snapshot(Bool_t deepCopy = kTRUE) const; Take a snap shot of current collection contents:; An owning collection is returned containing clones of. - Elements in this collection; - External dependents of all elements; and recursively any dependents of those dependents; (if deepCopy flag is set). If deepCopy is specified, the client-server links between the cloned; list elements and the cloned external dependents are reconnected to; each other, making the snapshot a completely self-contained entity. Bool_t snapshot(RooAbsCollection& output, Bool_t deepCopy = kTRUE) const; Take a snap shot of current collection contents:; An owning collection is returned containing clones of. - Elements in this collection; - External dependents of all elements; and recursively any dependents of those dependents; (if deepCopy flag is set). If deepCopy is specified, the client-server links between the cloned; list elements and the cloned external dependents are reconnected to; each other, making the snapshot a completely self-contained entity. Bool_t addServerClonesToList(const RooAbsArg& var); Add clones of servers of given argument to list. RooAbsCollection & operator=(const RooAbsCollection& other); The assignment operator sets the value of any argument in our set; that also appears in the other set. RooAbsCollection & assignValueOnly(const RooAbsCollection& other, Bool_t oneSafe = kFALSE); The assignment operator sets the value of any argument in our set; that also appears in the other set. void assignFast(const RooAbsCollection& other, Bool_t setValDirty = kTRUE); Functional equivalent of operator=() but assumes this and other collection; have same layout. Also no attributes are copied. Bool_t addOwned(RooAbsArg& var, Bool_t silent = kFALSE); ",MatchSource.WIKI,root/html602/RooAbsCollection.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsCollection.html
https://root.cern/root/html602/RooAbsCollection.html:12781,Integrability,depend,dependents,12781,"ny client; is deleted before a server is deleted. RooAbsCollection* snapshot(Bool_t deepCopy = kTRUE) const; Take a snap shot of current collection contents:; An owning collection is returned containing clones of. - Elements in this collection; - External dependents of all elements; and recursively any dependents of those dependents; (if deepCopy flag is set). If deepCopy is specified, the client-server links between the cloned; list elements and the cloned external dependents are reconnected to; each other, making the snapshot a completely self-contained entity. Bool_t snapshot(RooAbsCollection& output, Bool_t deepCopy = kTRUE) const; Take a snap shot of current collection contents:; An owning collection is returned containing clones of. - Elements in this collection; - External dependents of all elements; and recursively any dependents of those dependents; (if deepCopy flag is set). If deepCopy is specified, the client-server links between the cloned; list elements and the cloned external dependents are reconnected to; each other, making the snapshot a completely self-contained entity. Bool_t addServerClonesToList(const RooAbsArg& var); Add clones of servers of given argument to list. RooAbsCollection & operator=(const RooAbsCollection& other); The assignment operator sets the value of any argument in our set; that also appears in the other set. RooAbsCollection & assignValueOnly(const RooAbsCollection& other, Bool_t oneSafe = kFALSE); The assignment operator sets the value of any argument in our set; that also appears in the other set. void assignFast(const RooAbsCollection& other, Bool_t setValDirty = kTRUE); Functional equivalent of operator=() but assumes this and other collection; have same layout. Also no attributes are copied. Bool_t addOwned(RooAbsArg& var, Bool_t silent = kFALSE); Add the specified argument to list. Returns kTRUE if successful, or; else kFALSE if a variable of the same name is already in the list.; This method can only be called on a list ",MatchSource.WIKI,root/html602/RooAbsCollection.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsCollection.html
https://root.cern/root/html602/RooAbsCollection.html:21794,Integrability,interface,interface,21794,"NEU"",AutoPrecision(1),VerbatimName()) ) ;. void printLatex(ostream& ofs, Int_t ncol, const char* option = ""NEYU"", Int_t sigDigit = 1, const RooLinkedList& siblingLists = RooLinkedList(), const RooCmdArg* formatCmd = 0) const; Internal implementation function of printLatex. Bool_t allInRange(const char* rangeSpec) const; Return true if all contained object report to have their; value inside the specified range. void makeStructureTag(). void makeTypedStructureTag(). TObject* clone(const char* newname) const. TObject* create(const char* newname) const. TObject* Clone(const char* newname = 0) const. void setHashTableSize(Int_t i); Hash table control. Int_t getHashTableSize() const; Return size of internal hash table. Bool_t contains(const RooAbsArg& var) const; Returns true if object with same name as var is contained in this collection. Bool_t containsInstance(const RooAbsArg& var) const; Returns true if var is contained in this collection. TIterator* createIterator(Bool_t dir = kIterForward) const; export subset of THashList interface. RooFIter fwdIterator() const; { return RooFIter(&_list); }. Int_t getSize() const; Return the number of elements in the collection. RooAbsArg * first() const; Return the first element in this collection. void Print(Option_t* options = 0) const; Printing interface (human readable). void setName(const char* name); Set name of collection. const char* GetName() const; Return namer of collection. Bool_t isOwning() const; Does collection own contents?. void releaseOwnership(); { _ownCont = kFALSE ; }. void takeOwnership(); { _ownCont = kTRUE ; }. void sort(Bool_t ascend = kTRUE); { _list.Sort(ascend) ; }. TNamed* structureTag(); { if (_structureTag==0) makeStructureTag() ; return _structureTag ; }. TNamed* typedStructureTag(); { if (_typedStructureTag==0) makeTypedStructureTag() ; return _typedStructureTag ; }. void clearStructureTags(); { _structureTag=0 ; _typedStructureTag = 0 ; }. » Last changed: Tue Jun 30 14:30:02 2015 » Last generated:",MatchSource.WIKI,root/html602/RooAbsCollection.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsCollection.html
https://root.cern/root/html602/RooAbsCollection.html:22059,Integrability,interface,interface,22059,"inkedList(), const RooCmdArg* formatCmd = 0) const; Internal implementation function of printLatex. Bool_t allInRange(const char* rangeSpec) const; Return true if all contained object report to have their; value inside the specified range. void makeStructureTag(). void makeTypedStructureTag(). TObject* clone(const char* newname) const. TObject* create(const char* newname) const. TObject* Clone(const char* newname = 0) const. void setHashTableSize(Int_t i); Hash table control. Int_t getHashTableSize() const; Return size of internal hash table. Bool_t contains(const RooAbsArg& var) const; Returns true if object with same name as var is contained in this collection. Bool_t containsInstance(const RooAbsArg& var) const; Returns true if var is contained in this collection. TIterator* createIterator(Bool_t dir = kIterForward) const; export subset of THashList interface. RooFIter fwdIterator() const; { return RooFIter(&_list); }. Int_t getSize() const; Return the number of elements in the collection. RooAbsArg * first() const; Return the first element in this collection. void Print(Option_t* options = 0) const; Printing interface (human readable). void setName(const char* name); Set name of collection. const char* GetName() const; Return namer of collection. Bool_t isOwning() const; Does collection own contents?. void releaseOwnership(); { _ownCont = kFALSE ; }. void takeOwnership(); { _ownCont = kTRUE ; }. void sort(Bool_t ascend = kTRUE); { _list.Sort(ascend) ; }. TNamed* structureTag(); { if (_structureTag==0) makeStructureTag() ; return _structureTag ; }. TNamed* typedStructureTag(); { if (_typedStructureTag==0) makeTypedStructureTag() ; return _typedStructureTag ; }. void clearStructureTags(); { _structureTag=0 ; _typedStructureTag = 0 ; }. » Last changed: Tue Jun 30 14:30:02 2015 » Last generated: 2015-06-30 14:30; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html602/RooAbsCollection.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsCollection.html
https://root.cern/root/html602/RooAbsCollection.html:13684,Modifiability,variab,variable,13684,"y is specified, the client-server links between the cloned; list elements and the cloned external dependents are reconnected to; each other, making the snapshot a completely self-contained entity. Bool_t addServerClonesToList(const RooAbsArg& var); Add clones of servers of given argument to list. RooAbsCollection & operator=(const RooAbsCollection& other); The assignment operator sets the value of any argument in our set; that also appears in the other set. RooAbsCollection & assignValueOnly(const RooAbsCollection& other, Bool_t oneSafe = kFALSE); The assignment operator sets the value of any argument in our set; that also appears in the other set. void assignFast(const RooAbsCollection& other, Bool_t setValDirty = kTRUE); Functional equivalent of operator=() but assumes this and other collection; have same layout. Also no attributes are copied. Bool_t addOwned(RooAbsArg& var, Bool_t silent = kFALSE); Add the specified argument to list. Returns kTRUE if successful, or; else kFALSE if a variable of the same name is already in the list.; This method can only be called on a list that is flagged as owning; all of its contents, or else on an empty list (which will force the; list into that mode). RooAbsArg * addClone(const RooAbsArg& var, Bool_t silent = kFALSE); Add a clone of the specified argument to list. Returns a pointer to; the clone if successful, or else zero if a variable of the same name; is already in the list or the list does *not* own its variables (in; this case, try add() instead.) Calling addClone() on an empty list; forces it to take ownership of all its subsequent variables. Bool_t add(const RooAbsArg& var, Bool_t silent = kFALSE); Add the specified argument to list. Returns kTRUE if successful, or; else kFALSE if a variable of the same name is already in the list; or the list owns its variables (in this case, try addClone() or addOwned() instead). Bool_t add(const RooAbsCollection& list, Bool_t silent = kFALSE); Add a collection of arguments to this c",MatchSource.WIKI,root/html602/RooAbsCollection.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsCollection.html
https://root.cern/root/html602/RooAbsCollection.html:14074,Modifiability,variab,variable,14074," set; that also appears in the other set. RooAbsCollection & assignValueOnly(const RooAbsCollection& other, Bool_t oneSafe = kFALSE); The assignment operator sets the value of any argument in our set; that also appears in the other set. void assignFast(const RooAbsCollection& other, Bool_t setValDirty = kTRUE); Functional equivalent of operator=() but assumes this and other collection; have same layout. Also no attributes are copied. Bool_t addOwned(RooAbsArg& var, Bool_t silent = kFALSE); Add the specified argument to list. Returns kTRUE if successful, or; else kFALSE if a variable of the same name is already in the list.; This method can only be called on a list that is flagged as owning; all of its contents, or else on an empty list (which will force the; list into that mode). RooAbsArg * addClone(const RooAbsArg& var, Bool_t silent = kFALSE); Add a clone of the specified argument to list. Returns a pointer to; the clone if successful, or else zero if a variable of the same name; is already in the list or the list does *not* own its variables (in; this case, try add() instead.) Calling addClone() on an empty list; forces it to take ownership of all its subsequent variables. Bool_t add(const RooAbsArg& var, Bool_t silent = kFALSE); Add the specified argument to list. Returns kTRUE if successful, or; else kFALSE if a variable of the same name is already in the list; or the list owns its variables (in this case, try addClone() or addOwned() instead). Bool_t add(const RooAbsCollection& list, Bool_t silent = kFALSE); Add a collection of arguments to this collection by calling add(); for each element in the source collection. Bool_t addOwned(const RooAbsCollection& list, Bool_t silent = kFALSE); Add a collection of arguments to this collection by calling addOwned(); for each element in the source collection. void addClone(const RooAbsCollection& list, Bool_t silent = kFALSE); Add a collection of arguments to this collection by calling addOwned(); for each element in the",MatchSource.WIKI,root/html602/RooAbsCollection.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsCollection.html
https://root.cern/root/html602/RooAbsCollection.html:14155,Modifiability,variab,variables,14155," set; that also appears in the other set. RooAbsCollection & assignValueOnly(const RooAbsCollection& other, Bool_t oneSafe = kFALSE); The assignment operator sets the value of any argument in our set; that also appears in the other set. void assignFast(const RooAbsCollection& other, Bool_t setValDirty = kTRUE); Functional equivalent of operator=() but assumes this and other collection; have same layout. Also no attributes are copied. Bool_t addOwned(RooAbsArg& var, Bool_t silent = kFALSE); Add the specified argument to list. Returns kTRUE if successful, or; else kFALSE if a variable of the same name is already in the list.; This method can only be called on a list that is flagged as owning; all of its contents, or else on an empty list (which will force the; list into that mode). RooAbsArg * addClone(const RooAbsArg& var, Bool_t silent = kFALSE); Add a clone of the specified argument to list. Returns a pointer to; the clone if successful, or else zero if a variable of the same name; is already in the list or the list does *not* own its variables (in; this case, try add() instead.) Calling addClone() on an empty list; forces it to take ownership of all its subsequent variables. Bool_t add(const RooAbsArg& var, Bool_t silent = kFALSE); Add the specified argument to list. Returns kTRUE if successful, or; else kFALSE if a variable of the same name is already in the list; or the list owns its variables (in this case, try addClone() or addOwned() instead). Bool_t add(const RooAbsCollection& list, Bool_t silent = kFALSE); Add a collection of arguments to this collection by calling add(); for each element in the source collection. Bool_t addOwned(const RooAbsCollection& list, Bool_t silent = kFALSE); Add a collection of arguments to this collection by calling addOwned(); for each element in the source collection. void addClone(const RooAbsCollection& list, Bool_t silent = kFALSE); Add a collection of arguments to this collection by calling addOwned(); for each element in the",MatchSource.WIKI,root/html602/RooAbsCollection.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsCollection.html
https://root.cern/root/html602/RooAbsCollection.html:14288,Modifiability,variab,variables,14288,"ent operator sets the value of any argument in our set; that also appears in the other set. void assignFast(const RooAbsCollection& other, Bool_t setValDirty = kTRUE); Functional equivalent of operator=() but assumes this and other collection; have same layout. Also no attributes are copied. Bool_t addOwned(RooAbsArg& var, Bool_t silent = kFALSE); Add the specified argument to list. Returns kTRUE if successful, or; else kFALSE if a variable of the same name is already in the list.; This method can only be called on a list that is flagged as owning; all of its contents, or else on an empty list (which will force the; list into that mode). RooAbsArg * addClone(const RooAbsArg& var, Bool_t silent = kFALSE); Add a clone of the specified argument to list. Returns a pointer to; the clone if successful, or else zero if a variable of the same name; is already in the list or the list does *not* own its variables (in; this case, try add() instead.) Calling addClone() on an empty list; forces it to take ownership of all its subsequent variables. Bool_t add(const RooAbsArg& var, Bool_t silent = kFALSE); Add the specified argument to list. Returns kTRUE if successful, or; else kFALSE if a variable of the same name is already in the list; or the list owns its variables (in this case, try addClone() or addOwned() instead). Bool_t add(const RooAbsCollection& list, Bool_t silent = kFALSE); Add a collection of arguments to this collection by calling add(); for each element in the source collection. Bool_t addOwned(const RooAbsCollection& list, Bool_t silent = kFALSE); Add a collection of arguments to this collection by calling addOwned(); for each element in the source collection. void addClone(const RooAbsCollection& list, Bool_t silent = kFALSE); Add a collection of arguments to this collection by calling addOwned(); for each element in the source collection. Bool_t replace(const RooAbsCollection& other); Replace any args in our set with args of the same name from the other set; and",MatchSource.WIKI,root/html602/RooAbsCollection.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsCollection.html
https://root.cern/root/html602/RooAbsCollection.html:14443,Modifiability,variab,variable,14443,"ection; have same layout. Also no attributes are copied. Bool_t addOwned(RooAbsArg& var, Bool_t silent = kFALSE); Add the specified argument to list. Returns kTRUE if successful, or; else kFALSE if a variable of the same name is already in the list.; This method can only be called on a list that is flagged as owning; all of its contents, or else on an empty list (which will force the; list into that mode). RooAbsArg * addClone(const RooAbsArg& var, Bool_t silent = kFALSE); Add a clone of the specified argument to list. Returns a pointer to; the clone if successful, or else zero if a variable of the same name; is already in the list or the list does *not* own its variables (in; this case, try add() instead.) Calling addClone() on an empty list; forces it to take ownership of all its subsequent variables. Bool_t add(const RooAbsArg& var, Bool_t silent = kFALSE); Add the specified argument to list. Returns kTRUE if successful, or; else kFALSE if a variable of the same name is already in the list; or the list owns its variables (in this case, try addClone() or addOwned() instead). Bool_t add(const RooAbsCollection& list, Bool_t silent = kFALSE); Add a collection of arguments to this collection by calling add(); for each element in the source collection. Bool_t addOwned(const RooAbsCollection& list, Bool_t silent = kFALSE); Add a collection of arguments to this collection by calling addOwned(); for each element in the source collection. void addClone(const RooAbsCollection& list, Bool_t silent = kFALSE); Add a collection of arguments to this collection by calling addOwned(); for each element in the source collection. Bool_t replace(const RooAbsCollection& other); Replace any args in our set with args of the same name from the other set; and return kTRUE for success. Fails if this list is a copy of another. Bool_t replace(const RooAbsArg& var1, const RooAbsArg& var2); Replace var1 with var2 and return kTRUE for success. Fails if; this list is a copy of another, if var1 is ",MatchSource.WIKI,root/html602/RooAbsCollection.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsCollection.html
https://root.cern/root/html602/RooAbsCollection.html:14514,Modifiability,variab,variables,14514,"ection; have same layout. Also no attributes are copied. Bool_t addOwned(RooAbsArg& var, Bool_t silent = kFALSE); Add the specified argument to list. Returns kTRUE if successful, or; else kFALSE if a variable of the same name is already in the list.; This method can only be called on a list that is flagged as owning; all of its contents, or else on an empty list (which will force the; list into that mode). RooAbsArg * addClone(const RooAbsArg& var, Bool_t silent = kFALSE); Add a clone of the specified argument to list. Returns a pointer to; the clone if successful, or else zero if a variable of the same name; is already in the list or the list does *not* own its variables (in; this case, try add() instead.) Calling addClone() on an empty list; forces it to take ownership of all its subsequent variables. Bool_t add(const RooAbsArg& var, Bool_t silent = kFALSE); Add the specified argument to list. Returns kTRUE if successful, or; else kFALSE if a variable of the same name is already in the list; or the list owns its variables (in this case, try addClone() or addOwned() instead). Bool_t add(const RooAbsCollection& list, Bool_t silent = kFALSE); Add a collection of arguments to this collection by calling add(); for each element in the source collection. Bool_t addOwned(const RooAbsCollection& list, Bool_t silent = kFALSE); Add a collection of arguments to this collection by calling addOwned(); for each element in the source collection. void addClone(const RooAbsCollection& list, Bool_t silent = kFALSE); Add a collection of arguments to this collection by calling addOwned(); for each element in the source collection. Bool_t replace(const RooAbsCollection& other); Replace any args in our set with args of the same name from the other set; and return kTRUE for success. Fails if this list is a copy of another. Bool_t replace(const RooAbsArg& var1, const RooAbsArg& var2); Replace var1 with var2 and return kTRUE for success. Fails if; this list is a copy of another, if var1 is ",MatchSource.WIKI,root/html602/RooAbsCollection.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsCollection.html
https://root.cern/root/html602/RooAbsCollection.html:15867,Modifiability,variab,variable,15867,"element in the source collection. void addClone(const RooAbsCollection& list, Bool_t silent = kFALSE); Add a collection of arguments to this collection by calling addOwned(); for each element in the source collection. Bool_t replace(const RooAbsCollection& other); Replace any args in our set with args of the same name from the other set; and return kTRUE for success. Fails if this list is a copy of another. Bool_t replace(const RooAbsArg& var1, const RooAbsArg& var2); Replace var1 with var2 and return kTRUE for success. Fails if; this list is a copy of another, if var1 is not already in this set,; or if var2 is already in this set. var1 and var2 do not need to have; the same name. Bool_t remove(const RooAbsArg& var, Bool_t silent = kFALSE, Bool_t matchByNameOnly = kFALSE); Remove the specified argument from our list. Return kFALSE if; the specified argument is not found in our list. An exact pointer; match is required, not just a match by name. A variable can be; removed from a copied list and will be deleted at the same time. Bool_t remove(const RooAbsCollection& list, Bool_t silent = kFALSE, Bool_t matchByNameOnly = kFALSE); Remove each argument in the input list from our list using remove(const RooAbsArg&).; Return kFALSE in case of problems. void removeAll(); Remove all arguments from our set, deleting them if we own them.; This effectively restores our object to the state it would have; just after calling the RooAbsCollection(const char*) constructor. void setAttribAll(const Text_t* name, Bool_t value = kTRUE); Set given attribute in each element of the collection by; calling each elements setAttribute() function. RooAbsCollection* selectByAttrib(const char* name, Bool_t value) const; Create a subset of the current collection, consisting only of those; elements with the specified attribute set. The caller is responsibe; for deleting the returned collection. RooAbsCollection* selectCommon(const RooAbsCollection& refColl) const; Create a subset of the current col",MatchSource.WIKI,root/html602/RooAbsCollection.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsCollection.html
https://root.cern/root/html602/RooAbsCollection.html:19316,Modifiability,variab,variable,19316," inline printing only show value of objects, for default print show; name,class name value and extras of each object. In verbose mode; also add object adress, argument and title. void printValue(ostream& os) const; Print value of collection, i.e. a comma separated list of contained; object names. void printMultiline(ostream& os, Int_t contents, Bool_t verbose = kFALSE, TString indent = """") const; Implement multiline printin of collection, one line for each ontained object showing; the requested content. void dump() const; Base contents dumper for debugging purposes. void printLatex(const RooCmdArg& arg1 = RooCmdArg(), const RooCmdArg& arg2 = RooCmdArg(), const RooCmdArg& arg3 = RooCmdArg(), const RooCmdArg& arg4 = RooCmdArg(), const RooCmdArg& arg5 = RooCmdArg(), const RooCmdArg& arg6 = RooCmdArg(), const RooCmdArg& arg7 = RooCmdArg(), const RooCmdArg& arg8 = RooCmdArg()) const; Output content of collection as LaTex table. By default a table with two columns is created: the left; column contains the name of each variable, the right column the value. The following optional named arguments can be used to modify the default behavior. Columns(Int_t ncol) -- Fold table into multiple columns, i.e. ncol=3 will result in 3 x 2 = 6 total columns; Sibling(const RooAbsCollection& other) -- Define sibling list. The sibling list is assumed to have objects with the same; name in the same order. If this is not the case warnings will be printed. If a single; sibling list is specified, 3 columns will be output: the (common) name, the value of this; list and the value in the sibling list. Multiple sibling lists can be specified by; repeating the Sibling() command.; Format(const char* str) -- Classic format string, provided for backward compatibility; Format(...) -- Formatting arguments, details are given below; OutputFile(const char* fname) -- Send output to file with given name rather than standard output. The Format(const char* what,...) has the following structure. const char* what",MatchSource.WIKI,root/html602/RooAbsCollection.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsCollection.html
https://root.cern/root/html602/RooAbsCollection.html:20670,Modifiability,variab,variable,20670,"ing list is assumed to have objects with the same; name in the same order. If this is not the case warnings will be printed. If a single; sibling list is specified, 3 columns will be output: the (common) name, the value of this; list and the value in the sibling list. Multiple sibling lists can be specified by; repeating the Sibling() command.; Format(const char* str) -- Classic format string, provided for backward compatibility; Format(...) -- Formatting arguments, details are given below; OutputFile(const char* fname) -- Send output to file with given name rather than standard output. The Format(const char* what,...) has the following structure. const char* what -- Controls what is shown. ""N"" adds name, ""E"" adds error,; ""A"" shows asymmetric error, ""U"" shows unit, ""H"" hides the value; FixedPrecision(int n) -- Controls precision, set fixed number of digits; AutoPrecision(int n) -- Controls precision. Number of shown digits is calculated from error; + n specified additional digits (1 is sensible default); VerbatimName(Bool_t flag) -- Put variable name in a \verb+ + clause. Example use: list.printLatex(Columns(2), Format(""NEU"",AutoPrecision(1),VerbatimName()) ) ;. void printLatex(ostream& ofs, Int_t ncol, const char* option = ""NEYU"", Int_t sigDigit = 1, const RooLinkedList& siblingLists = RooLinkedList(), const RooCmdArg* formatCmd = 0) const; Internal implementation function of printLatex. Bool_t allInRange(const char* rangeSpec) const; Return true if all contained object report to have their; value inside the specified range. void makeStructureTag(). void makeTypedStructureTag(). TObject* clone(const char* newname) const. TObject* create(const char* newname) const. TObject* Clone(const char* newname = 0) const. void setHashTableSize(Int_t i); Hash table control. Int_t getHashTableSize() const; Return size of internal hash table. Bool_t contains(const RooAbsArg& var) const; Returns true if object with same name as var is contained in this collection. Bool_t containsIn",MatchSource.WIKI,root/html602/RooAbsCollection.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsCollection.html
https://root.cern/root/html602/RooAbsCollection.html:11677,Safety,safe,safeDeleteList,11677,"TObject::kWriteDelete; static TObject::(anonymous)TObject::kZombie. protected:. Bool_t_allRRVAll contents are RRV; RooLinkedList_listActual object store; TString_nameOur name.; static Int_tRooPrintable::_nameLength; Bool_t_ownContFlag to identify a list that owns its contents.; TNamed*_structureTag! Structure tag; TNamed*_typedStructureTag! Typed structure tag. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; RooAbsCollection(); Default constructor. RooAbsCollection(const char* name); Empty collection constructor. RooAbsCollection(const RooAbsCollection& other, const char* name = """"); Copy constructor. Note that a copy of a collection is always non-owning,; even the source collection is owning. To create an owning copy of; a collection (owning or not), use the snaphot() method. ~RooAbsCollection(); Destructor. RooLinkedListIter iterator(Bool_t dir = kIterForward) const. void safeDeleteList(); Examine client server dependencies in list and; delete contents in safe order: any client; is deleted before a server is deleted. RooAbsCollection* snapshot(Bool_t deepCopy = kTRUE) const; Take a snap shot of current collection contents:; An owning collection is returned containing clones of. - Elements in this collection; - External dependents of all elements; and recursively any dependents of those dependents; (if deepCopy flag is set). If deepCopy is specified, the client-server links between the cloned; list elements and the cloned external dependents are reconnected to; each other, making the snapshot a completely self-contained entity. Bool_t snapshot(RooAbsCollection& output, Bool_t deepCopy = kTRUE) const; Take a snap shot of current collection contents:; An owning collection is returned containing clones of. - Elements in this collection; - External dependents of all elements; and recursively any dependents of those dependents; (if deepCopy flag is set). If deepCopy is specified, the client-server links between the cloned; list ",MatchSource.WIKI,root/html602/RooAbsCollection.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsCollection.html
https://root.cern/root/html602/RooAbsCollection.html:11762,Safety,safe,safe,11762,"TObject::kWriteDelete; static TObject::(anonymous)TObject::kZombie. protected:. Bool_t_allRRVAll contents are RRV; RooLinkedList_listActual object store; TString_nameOur name.; static Int_tRooPrintable::_nameLength; Bool_t_ownContFlag to identify a list that owns its contents.; TNamed*_structureTag! Structure tag; TNamed*_typedStructureTag! Typed structure tag. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; RooAbsCollection(); Default constructor. RooAbsCollection(const char* name); Empty collection constructor. RooAbsCollection(const RooAbsCollection& other, const char* name = """"); Copy constructor. Note that a copy of a collection is always non-owning,; even the source collection is owning. To create an owning copy of; a collection (owning or not), use the snaphot() method. ~RooAbsCollection(); Destructor. RooLinkedListIter iterator(Bool_t dir = kIterForward) const. void safeDeleteList(); Examine client server dependencies in list and; delete contents in safe order: any client; is deleted before a server is deleted. RooAbsCollection* snapshot(Bool_t deepCopy = kTRUE) const; Take a snap shot of current collection contents:; An owning collection is returned containing clones of. - Elements in this collection; - External dependents of all elements; and recursively any dependents of those dependents; (if deepCopy flag is set). If deepCopy is specified, the client-server links between the cloned; list elements and the cloned external dependents are reconnected to; each other, making the snapshot a completely self-contained entity. Bool_t snapshot(RooAbsCollection& output, Bool_t deepCopy = kTRUE) const; Take a snap shot of current collection contents:; An owning collection is returned containing clones of. - Elements in this collection; - External dependents of all elements; and recursively any dependents of those dependents; (if deepCopy flag is set). If deepCopy is specified, the client-server links between the cloned; list ",MatchSource.WIKI,root/html602/RooAbsCollection.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsCollection.html
https://root.cern/root/html602/RooAbsCollection.html:672,Security,hash,hash-table,672,". RooAbsCollection. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » ROOFIT; » ROOFITCORE; » RooAbsCollection. class RooAbsCollection: public TObject, public RooPrintable. RooAbsCollection is an abstract container object that can hold; multiple RooAbsArg objects. Collections are ordered and can; contain multiple objects of the same name, (but a derived; implementation can enforce unique names). The storage of objects in; implement through class RooLinkedList, a doubly linked list with an; an optional hash-table lookup mechanism for fast indexing of large; collections. ; . Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~RooAbsCollection(); voidTObject::AbstractMethod(const char* method) const; virtual Bool_tadd(const RooAbsArg& var, Bool_t silent = kFALSE); virtual Bool_tadd(const RooAbsCollection& list, Bool_t silent = kFALSE); virtual RooAbsArg*addClone(const RooAbsArg& var, Bool_t silent = kFALSE); virtual voidaddClone(const RooAbsCollection& list, Bool_t silent = kFALSE); virtual Bool_taddOwned(RooAbsArg& var, Bool_t silent = kFALSE); virtual Bool_taddOwned(const RooAbsCollection& list, Bool_t silent = kFALSE); Bool_tallInRange(const char* rangeSpec) const; virtual voidTObject::AppendPad(Option_t* option = """"); voidassignFast(const RooAbsCollection& other, Bool_t setValDirty = kTRUE); RooAbsCollection&assignValueOnly(const RooAbsCollection& other, Bool_t oneSafe = kFALSE); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*clone(const char* newname) const; virtual TObject*Clone(const char* newname = 0) const; virtual Int_tTObject::Compare(const TObject* obj",MatchSource.WIKI,root/html602/RooAbsCollection.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsCollection.html
https://root.cern/root/html602/RooAbsCollection.html:21466,Security,hash,hash,21466,"rols precision, set fixed number of digits; AutoPrecision(int n) -- Controls precision. Number of shown digits is calculated from error; + n specified additional digits (1 is sensible default); VerbatimName(Bool_t flag) -- Put variable name in a \verb+ + clause. Example use: list.printLatex(Columns(2), Format(""NEU"",AutoPrecision(1),VerbatimName()) ) ;. void printLatex(ostream& ofs, Int_t ncol, const char* option = ""NEYU"", Int_t sigDigit = 1, const RooLinkedList& siblingLists = RooLinkedList(), const RooCmdArg* formatCmd = 0) const; Internal implementation function of printLatex. Bool_t allInRange(const char* rangeSpec) const; Return true if all contained object report to have their; value inside the specified range. void makeStructureTag(). void makeTypedStructureTag(). TObject* clone(const char* newname) const. TObject* create(const char* newname) const. TObject* Clone(const char* newname = 0) const. void setHashTableSize(Int_t i); Hash table control. Int_t getHashTableSize() const; Return size of internal hash table. Bool_t contains(const RooAbsArg& var) const; Returns true if object with same name as var is contained in this collection. Bool_t containsInstance(const RooAbsArg& var) const; Returns true if var is contained in this collection. TIterator* createIterator(Bool_t dir = kIterForward) const; export subset of THashList interface. RooFIter fwdIterator() const; { return RooFIter(&_list); }. Int_t getSize() const; Return the number of elements in the collection. RooAbsArg * first() const; Return the first element in this collection. void Print(Option_t* options = 0) const; Printing interface (human readable). void setName(const char* name); Set name of collection. const char* GetName() const; Return namer of collection. Bool_t isOwning() const; Does collection own contents?. void releaseOwnership(); { _ownCont = kFALSE ; }. void takeOwnership(); { _ownCont = kTRUE ; }. void sort(Bool_t ascend = kTRUE); { _list.Sort(ascend) ; }. TNamed* structureTag(); { if (_",MatchSource.WIKI,root/html602/RooAbsCollection.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsCollection.html
https://root.cern/root/html602/RooAbsCollection.html:22627,Usability,clear,clearStructureTags,22627,"inkedList(), const RooCmdArg* formatCmd = 0) const; Internal implementation function of printLatex. Bool_t allInRange(const char* rangeSpec) const; Return true if all contained object report to have their; value inside the specified range. void makeStructureTag(). void makeTypedStructureTag(). TObject* clone(const char* newname) const. TObject* create(const char* newname) const. TObject* Clone(const char* newname = 0) const. void setHashTableSize(Int_t i); Hash table control. Int_t getHashTableSize() const; Return size of internal hash table. Bool_t contains(const RooAbsArg& var) const; Returns true if object with same name as var is contained in this collection. Bool_t containsInstance(const RooAbsArg& var) const; Returns true if var is contained in this collection. TIterator* createIterator(Bool_t dir = kIterForward) const; export subset of THashList interface. RooFIter fwdIterator() const; { return RooFIter(&_list); }. Int_t getSize() const; Return the number of elements in the collection. RooAbsArg * first() const; Return the first element in this collection. void Print(Option_t* options = 0) const; Printing interface (human readable). void setName(const char* name); Set name of collection. const char* GetName() const; Return namer of collection. Bool_t isOwning() const; Does collection own contents?. void releaseOwnership(); { _ownCont = kFALSE ; }. void takeOwnership(); { _ownCont = kTRUE ; }. void sort(Bool_t ascend = kTRUE); { _list.Sort(ascend) ; }. TNamed* structureTag(); { if (_structureTag==0) makeStructureTag() ; return _structureTag ; }. TNamed* typedStructureTag(); { if (_typedStructureTag==0) makeTypedStructureTag() ; return _typedStructureTag ; }. void clearStructureTags(); { _structureTag=0 ; _typedStructureTag = 0 ; }. » Last changed: Tue Jun 30 14:30:02 2015 » Last generated: 2015-06-30 14:30; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html602/RooAbsCollection.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsCollection.html
https://root.cern/root/html602/RooAbsData.html:730,Availability,avail,available,730,". RooAbsData. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » ROOFIT; » ROOFITCORE; » RooAbsData. class RooAbsData: public TNamed, public RooPrintable. RooAbsData is the common abstract base class for binned and unbinned; datasets. The abstract interface defines plotting and tabulating entry; points for its contents and provides an iterator over its elements; (bins for binned data sets, data points for unbinned datasets).; . Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~RooAbsData(); voidTObject::AbstractMethod(const char* method) const; virtual voidadd(const RooArgSet& row, Double_t weight = 1, Double_t weightError = 0); voidaddOwnedComponent(const char* idxlabel, RooAbsData& data); virtual voidTObject::AppendPad(Option_t* option = """"); voidattachBuffers(const RooArgSet& extObs); virtual voidTObject::Browse(TBrowser* b); Bool_tcanSplitFast() const; virtual Bool_tchangeObservableName(const char* from, const char* to); voidcheckInit() const; static voidclaimVars(RooAbsData*); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; voidconvertToVectorStore(); virtual voidTNamed::Copy(TObject& named) const; Double_tcorrelation(RooRealVar& x, RooRealVar& y, const char* cutSpec = 0, const char* cutRange = 0) const; TMatrixDSym*correlationMatrix(const char* cutSpec = 0, const char* cutRange = 0) const; TMatrixDSym*correlationMatrix(const RooArgList& vars, const char* cutSpec = 0, const char* cutRange = 0) const; Double_tcovariance(RooRealVar& x, RooRealVar& y, const char* cutSpec = 0, const char* cutRa",MatchSource.WIKI,root/html602/RooAbsData.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsData.html
https://root.cern/root/html602/RooAbsData.html:3660,Availability,error,error,3660,"const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()) const; virtual Int_tdefaultPrintContents(Option_t* opt) const; static ostream&RooPrintable::defaultPrintStream(ostream* os = 0); virtual RooPrintable::StyleOptionRooPrintable::defaultPrintStyle(Option_t* opt) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidDraw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual RooAbsData*emptyClone(const char* newName = 0, const char* newTitle = 0, const RooArgSet* vars = 0, const char* wgtVarName = 0) const; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidfill(); virtual voidTNamed::FillBuffer(char*& buffer); virtual TH1*fillHistogram(TH1* hist, const RooArgList& plotVars, const char* cuts = """", const char* cutRange = 0) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual const RooArgSet*get() const; virtual const RooArgSet*get(Int_t index) const; static RooAbsData::StorageTypegetDefaultStorageType(); virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual const char*TNamed::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOpt",MatchSource.WIKI,root/html602/RooAbsData.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsData.html
https://root.cern/root/html602/RooAbsData.html:3744,Availability,error,error,3744,", const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()) const; virtual Int_tdefaultPrintContents(Option_t* opt) const; static ostream&RooPrintable::defaultPrintStream(ostream* os = 0); virtual RooPrintable::StyleOptionRooPrintable::defaultPrintStyle(Option_t* opt) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidDraw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual RooAbsData*emptyClone(const char* newName = 0, const char* newTitle = 0, const RooArgSet* vars = 0, const char* wgtVarName = 0) const; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidfill(); virtual voidTNamed::FillBuffer(char*& buffer); virtual TH1*fillHistogram(TH1* hist, const RooArgList& plotVars, const char* cuts = """", const char* cutRange = 0) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual const RooArgSet*get() const; virtual const RooArgSet*get(Int_t index) const; static RooAbsData::StorageTypegetDefaultStorageType(); virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual const char*TNamed::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; Bool_tgetRange(RooRealVar& var, Double_t& lowest, Double_t& highest, Do",MatchSource.WIKI,root/html602/RooAbsData.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsData.html
https://root.cern/root/html602/RooAbsData.html:19975,Availability,error,error,19975,"a subset of the data set by applying the given cut on the data points.; The 'cutVar' formula variable is used to select the subset of data points to be; retained in the reduced data collection. RooAbsData* reduce(const RooArgSet& varSubset, const char* cut = 0); Create a subset of the data set by applying the given cut on the data points; and reducing the dimensions to the specified set. The cut expression can refer to any variable in the data set. For cuts involving; other variables, such as intermediate formula objects, use the equivalent; reduce method specifying the as a RooFormulVar reference. RooAbsData* reduce(const RooArgSet& varSubset, const RooFormulaVar& cutVar); Create a subset of the data set by applying the given cut on the data points; and reducing the dimensions to the specified set. The 'cutVar' formula variable is used to select the subset of data points to be; retained in the reduced data collection. Double_t weightError(RooAbsData::ErrorType etype = Poisson) const; Return error on current weight (dummy implementation returning zero). void weightError(Double_t& lo, Double_t& hi, RooAbsData::ErrorType etype = Poisson) const; Return asymmetric error on weight. (Dummy implementation returning zero). RooPlot* plotOn(RooPlot* frame, const RooCmdArg& arg1 = RooCmdArg::none(), const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()) const; Plot dataset on specified frame. By default an unbinned dataset will use the default binning of; the target frame. A binned dataset will by default retain its intrinsic binning. The following optional named arguments can be used to modify the default behavior. Data representation options. Asymmetry(const RooCategory& c) -- Show the asymmetry of the daya in given two-state category",MatchSource.WIKI,root/html602/RooAbsData.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsData.html
https://root.cern/root/html602/RooAbsData.html:20147,Availability,error,error,20147,"f data points to be; retained in the reduced data collection. RooAbsData* reduce(const RooArgSet& varSubset, const char* cut = 0); Create a subset of the data set by applying the given cut on the data points; and reducing the dimensions to the specified set. The cut expression can refer to any variable in the data set. For cuts involving; other variables, such as intermediate formula objects, use the equivalent; reduce method specifying the as a RooFormulVar reference. RooAbsData* reduce(const RooArgSet& varSubset, const RooFormulaVar& cutVar); Create a subset of the data set by applying the given cut on the data points; and reducing the dimensions to the specified set. The 'cutVar' formula variable is used to select the subset of data points to be; retained in the reduced data collection. Double_t weightError(RooAbsData::ErrorType etype = Poisson) const; Return error on current weight (dummy implementation returning zero). void weightError(Double_t& lo, Double_t& hi, RooAbsData::ErrorType etype = Poisson) const; Return asymmetric error on weight. (Dummy implementation returning zero). RooPlot* plotOn(RooPlot* frame, const RooCmdArg& arg1 = RooCmdArg::none(), const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()) const; Plot dataset on specified frame. By default an unbinned dataset will use the default binning of; the target frame. A binned dataset will by default retain its intrinsic binning. The following optional named arguments can be used to modify the default behavior. Data representation options. Asymmetry(const RooCategory& c) -- Show the asymmetry of the daya in given two-state category [F(+)-F(-)] / [F(+)+F(-)].; Category must have two states with indices -1 and +1 or three states with indeces -1,0 and +1.; DataEr",MatchSource.WIKI,root/html602/RooAbsData.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsData.html
https://root.cern/root/html602/RooAbsData.html:21145,Availability,error,error,21145,"eight. (Dummy implementation returning zero). RooPlot* plotOn(RooPlot* frame, const RooCmdArg& arg1 = RooCmdArg::none(), const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()) const; Plot dataset on specified frame. By default an unbinned dataset will use the default binning of; the target frame. A binned dataset will by default retain its intrinsic binning. The following optional named arguments can be used to modify the default behavior. Data representation options. Asymmetry(const RooCategory& c) -- Show the asymmetry of the daya in given two-state category [F(+)-F(-)] / [F(+)+F(-)].; Category must have two states with indices -1 and +1 or three states with indeces -1,0 and +1.; DataError(RooAbsData::EType) -- Select the type of error drawn: Poisson (default) draws asymmetric Poisson; confidence intervals. SumW2 draws symmetric sum-of-weights error; Binning(int nbins, double xlo, -- Use specified binning to draw dataset; double xhi); Binning(const RooAbsBinning&) -- Use specified binning to draw dataset; Binning(const char* name) -- Use binning with specified name to draw dataset; RefreshNorm(Bool_t flag) -- Force refreshing for PDF normalization information in frame.; If set, any subsequent PDF will normalize to this dataset, even if it is; not the first one added to the frame. By default only the 1st dataset; added to a frame will update the normalization information; Rescale(Double_t factor) -- Apply global rescaling factor to histogram. Histogram drawing options. DrawOption(const char* opt) -- Select ROOT draw option for resulting TGraph object; LineStyle(Int_t style) -- Select line style by ROOT line style code, default is solid; LineColor(Int_t color) -- Select line color by ROOT color code, default is black; LineWid",MatchSource.WIKI,root/html602/RooAbsData.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsData.html
https://root.cern/root/html602/RooAbsData.html:21261,Availability,error,error,21261,"const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()) const; Plot dataset on specified frame. By default an unbinned dataset will use the default binning of; the target frame. A binned dataset will by default retain its intrinsic binning. The following optional named arguments can be used to modify the default behavior. Data representation options. Asymmetry(const RooCategory& c) -- Show the asymmetry of the daya in given two-state category [F(+)-F(-)] / [F(+)+F(-)].; Category must have two states with indices -1 and +1 or three states with indeces -1,0 and +1.; DataError(RooAbsData::EType) -- Select the type of error drawn: Poisson (default) draws asymmetric Poisson; confidence intervals. SumW2 draws symmetric sum-of-weights error; Binning(int nbins, double xlo, -- Use specified binning to draw dataset; double xhi); Binning(const RooAbsBinning&) -- Use specified binning to draw dataset; Binning(const char* name) -- Use binning with specified name to draw dataset; RefreshNorm(Bool_t flag) -- Force refreshing for PDF normalization information in frame.; If set, any subsequent PDF will normalize to this dataset, even if it is; not the first one added to the frame. By default only the 1st dataset; added to a frame will update the normalization information; Rescale(Double_t factor) -- Apply global rescaling factor to histogram. Histogram drawing options. DrawOption(const char* opt) -- Select ROOT draw option for resulting TGraph object; LineStyle(Int_t style) -- Select line style by ROOT line style code, default is solid; LineColor(Int_t color) -- Select line color by ROOT color code, default is black; LineWidth(Int_t width) -- Select line with in pixels, default is 3; MarkerStyle(Int_t style) -- Select the ROOT marker style, default is 21; MarkerColor(Int_t color) -- Select the ROOT marker color, default is black; MarkerSize(Double_t size) -- Select the ",MatchSource.WIKI,root/html602/RooAbsData.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsData.html
https://root.cern/root/html602/RooAbsData.html:22472,Availability,error,error,22472,"e intervals. SumW2 draws symmetric sum-of-weights error; Binning(int nbins, double xlo, -- Use specified binning to draw dataset; double xhi); Binning(const RooAbsBinning&) -- Use specified binning to draw dataset; Binning(const char* name) -- Use binning with specified name to draw dataset; RefreshNorm(Bool_t flag) -- Force refreshing for PDF normalization information in frame.; If set, any subsequent PDF will normalize to this dataset, even if it is; not the first one added to the frame. By default only the 1st dataset; added to a frame will update the normalization information; Rescale(Double_t factor) -- Apply global rescaling factor to histogram. Histogram drawing options. DrawOption(const char* opt) -- Select ROOT draw option for resulting TGraph object; LineStyle(Int_t style) -- Select line style by ROOT line style code, default is solid; LineColor(Int_t color) -- Select line color by ROOT color code, default is black; LineWidth(Int_t width) -- Select line with in pixels, default is 3; MarkerStyle(Int_t style) -- Select the ROOT marker style, default is 21; MarkerColor(Int_t color) -- Select the ROOT marker color, default is black; MarkerSize(Double_t size) -- Select the ROOT marker size; XErrorSize(Double_t frac) -- Select size of X error bar as fraction of the bin width, default is 1. Misc. other options. Name(const chat* name) -- Give curve specified name in frame. Useful if curve is to be referenced later; Invisble(Bool_t flag) -- Add curve to frame, but do not display. Useful in combination AddTo(); AddTo(const char* name, -- Add constructed histogram to already existing histogram with given name and relative weight factors; double_t wgtSelf, double_t wgtOther). TH1 * createHistogram(const char* varNameList, Int_t xbins = 0, Int_t ybins = 0, Int_t zbins = 0) const; Create and fill a ROOT histogram TH1,TH2 or TH3 with the values of this dataset for the variables with given names; The range of each observable that is histogrammed is always automatically ca",MatchSource.WIKI,root/html602/RooAbsData.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsData.html
https://root.cern/root/html602/RooAbsData.html:29921,Availability,error,error,29921,"- Controls what is printed: ""N"" = count, ""M"" is mean, ""R"" is RMS.; Format(const char* optStr) -- Classing [arameter formatting options, provided for backward compatibility; Format(const char* what,...) -- Parameter formatting options, details given below; Label(const chat* label) -- Add header label to parameter box; Layout(Double_t xmin, -- Specify relative position of left,right side of box and top of box. Position of; Double_t xmax, Double_t ymax) bottom of box is calculated automatically from number lines in box; Cut(const char* expression) -- Apply given cut expression to data when calculating statistics; CutRange(const char* rangeName) -- Only consider events within given range when calculating statistics. Multiple; CutRange() argument may be specified to combine ranges. The Format(const char* what,...) has the following structure. const char* what -- Controls what is shown. ""N"" adds name, ""E"" adds error,; ""A"" shows asymmetric error, ""U"" shows unit, ""H"" hides the value; FixedPrecision(int n) -- Controls precision, set fixed number of digits; AutoPrecision(int n) -- Controls precision. Number of shown digits is calculated from error; + n specified additional digits (1 is sensible default); VerbatimName(Bool_t flag) -- Put variable name in a \verb+ + clause. RooPlot* statOn(RooPlot* frame, const char* what, const char* label = """", Int_t sigDigits = 2, Option_t* options = ""NELU"", Double_t xmin = 0.14999999999999999, Double_t xmax = 0.65000000000000002, Double_t ymax = 0.84999999999999998, const char* cutSpec = 0, const char* cutRange = 0, const RooCmdArg* formatCmd = 0); Implementation back-end of statOn() mehtod with named arguments. TH1 * fillHistogram(TH1* hist, const RooArgList& plotVars, const char* cuts = """", const char* cutRange = 0) const; Loop over columns of our tree data and fill the input histogram. Returns a pointer to the; input histogram, or zero in case of an error. The input histogram can be any TH1 subclass, and; therefore of arbitrary dimension",MatchSource.WIKI,root/html602/RooAbsData.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsData.html
https://root.cern/root/html602/RooAbsData.html:29950,Availability,error,error,29950,"- Controls what is printed: ""N"" = count, ""M"" is mean, ""R"" is RMS.; Format(const char* optStr) -- Classing [arameter formatting options, provided for backward compatibility; Format(const char* what,...) -- Parameter formatting options, details given below; Label(const chat* label) -- Add header label to parameter box; Layout(Double_t xmin, -- Specify relative position of left,right side of box and top of box. Position of; Double_t xmax, Double_t ymax) bottom of box is calculated automatically from number lines in box; Cut(const char* expression) -- Apply given cut expression to data when calculating statistics; CutRange(const char* rangeName) -- Only consider events within given range when calculating statistics. Multiple; CutRange() argument may be specified to combine ranges. The Format(const char* what,...) has the following structure. const char* what -- Controls what is shown. ""N"" adds name, ""E"" adds error,; ""A"" shows asymmetric error, ""U"" shows unit, ""H"" hides the value; FixedPrecision(int n) -- Controls precision, set fixed number of digits; AutoPrecision(int n) -- Controls precision. Number of shown digits is calculated from error; + n specified additional digits (1 is sensible default); VerbatimName(Bool_t flag) -- Put variable name in a \verb+ + clause. RooPlot* statOn(RooPlot* frame, const char* what, const char* label = """", Int_t sigDigits = 2, Option_t* options = ""NELU"", Double_t xmin = 0.14999999999999999, Double_t xmax = 0.65000000000000002, Double_t ymax = 0.84999999999999998, const char* cutSpec = 0, const char* cutRange = 0, const RooCmdArg* formatCmd = 0); Implementation back-end of statOn() mehtod with named arguments. TH1 * fillHistogram(TH1* hist, const RooArgList& plotVars, const char* cuts = """", const char* cutRange = 0) const; Loop over columns of our tree data and fill the input histogram. Returns a pointer to the; input histogram, or zero in case of an error. The input histogram can be any TH1 subclass, and; therefore of arbitrary dimension",MatchSource.WIKI,root/html602/RooAbsData.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsData.html
https://root.cern/root/html602/RooAbsData.html:30153,Availability,error,error,30153,"at,...) -- Parameter formatting options, details given below; Label(const chat* label) -- Add header label to parameter box; Layout(Double_t xmin, -- Specify relative position of left,right side of box and top of box. Position of; Double_t xmax, Double_t ymax) bottom of box is calculated automatically from number lines in box; Cut(const char* expression) -- Apply given cut expression to data when calculating statistics; CutRange(const char* rangeName) -- Only consider events within given range when calculating statistics. Multiple; CutRange() argument may be specified to combine ranges. The Format(const char* what,...) has the following structure. const char* what -- Controls what is shown. ""N"" adds name, ""E"" adds error,; ""A"" shows asymmetric error, ""U"" shows unit, ""H"" hides the value; FixedPrecision(int n) -- Controls precision, set fixed number of digits; AutoPrecision(int n) -- Controls precision. Number of shown digits is calculated from error; + n specified additional digits (1 is sensible default); VerbatimName(Bool_t flag) -- Put variable name in a \verb+ + clause. RooPlot* statOn(RooPlot* frame, const char* what, const char* label = """", Int_t sigDigits = 2, Option_t* options = ""NELU"", Double_t xmin = 0.14999999999999999, Double_t xmax = 0.65000000000000002, Double_t ymax = 0.84999999999999998, const char* cutSpec = 0, const char* cutRange = 0, const RooCmdArg* formatCmd = 0); Implementation back-end of statOn() mehtod with named arguments. TH1 * fillHistogram(TH1* hist, const RooArgList& plotVars, const char* cuts = """", const char* cutRange = 0) const; Loop over columns of our tree data and fill the input histogram. Returns a pointer to the; input histogram, or zero in case of an error. The input histogram can be any TH1 subclass, and; therefore of arbitrary dimension. Variables are matched with the (x,y,...) dimensions of the input; histogram according to the order in which they appear in the input plotVars list. TList* split(const RooAbsCategory& splitCat, ",MatchSource.WIKI,root/html602/RooAbsData.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsData.html
https://root.cern/root/html602/RooAbsData.html:30914,Availability,error,error,30914,"at is shown. ""N"" adds name, ""E"" adds error,; ""A"" shows asymmetric error, ""U"" shows unit, ""H"" hides the value; FixedPrecision(int n) -- Controls precision, set fixed number of digits; AutoPrecision(int n) -- Controls precision. Number of shown digits is calculated from error; + n specified additional digits (1 is sensible default); VerbatimName(Bool_t flag) -- Put variable name in a \verb+ + clause. RooPlot* statOn(RooPlot* frame, const char* what, const char* label = """", Int_t sigDigits = 2, Option_t* options = ""NELU"", Double_t xmin = 0.14999999999999999, Double_t xmax = 0.65000000000000002, Double_t ymax = 0.84999999999999998, const char* cutSpec = 0, const char* cutRange = 0, const RooCmdArg* formatCmd = 0); Implementation back-end of statOn() mehtod with named arguments. TH1 * fillHistogram(TH1* hist, const RooArgList& plotVars, const char* cuts = """", const char* cutRange = 0) const; Loop over columns of our tree data and fill the input histogram. Returns a pointer to the; input histogram, or zero in case of an error. The input histogram can be any TH1 subclass, and; therefore of arbitrary dimension. Variables are matched with the (x,y,...) dimensions of the input; histogram according to the order in which they appear in the input plotVars list. TList* split(const RooAbsCategory& splitCat, Bool_t createEmptyDataSets = kFALSE) const; Split dataset into subsets based on states of given splitCat in this dataset.; A TList of RooDataSets is returned in which each RooDataSet is named; after the state name of splitCat of which it contains the dataset subset.; The observables splitCat itself is no longer present in the sub datasets.; If createEmptyDataSets is kFALSE (default) this method only creates datasets for states; which have at least one entry The caller takes ownership of the returned list and its contents. RooPlot* plotOn(RooPlot* frame, const RooLinkedList& cmdList) const; Plot dataset on specified frame. By default an unbinned dataset will use the default binn",MatchSource.WIKI,root/html602/RooAbsData.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsData.html
https://root.cern/root/html602/RooAbsData.html:32485,Availability,error,error,32485," present in the sub datasets.; If createEmptyDataSets is kFALSE (default) this method only creates datasets for states; which have at least one entry The caller takes ownership of the returned list and its contents. RooPlot* plotOn(RooPlot* frame, const RooLinkedList& cmdList) const; Plot dataset on specified frame. By default an unbinned dataset will use the default binning of; the target frame. A binned dataset will by default retain its intrinsic binning. The following optional named arguments can be used to modify the default behavior. Data representation options. Asymmetry(const RooCategory& c) -- Show the asymmetry of the data in given two-state category [F(+)-F(-)] / [F(+)+F(-)].; Category must have two states with indices -1 and +1 or three states with indeces -1,0 and +1.; Efficiency(const RooCategory& c)-- Show the efficiency F(acc)/[F(acc)+F(rej)]. Category must have two states with indices 0 and 1; DataError(RooAbsData::EType) -- Select the type of error drawn:; - Auto(default) results in Poisson for unweighted data and SumW2 for weighted data; - Poisson draws asymmetric Poisson confidence intervals.; - SumW2 draws symmetric sum-of-weights error ( sum(w)^2/sum(w^2) ); - None draws no error bars; Binning(int nbins, double xlo, double xhi) -- Use specified binning to draw dataset; Binning(const RooAbsBinning&) -- Use specified binning to draw dataset; Binning(const char* name) -- Use binning with specified name to draw dataset; RefreshNorm(Bool_t flag) -- Force refreshing for PDF normalization information in frame.; If set, any subsequent PDF will normalize to this dataset, even if it is; not the first one added to the frame. By default only the 1st dataset; added to a frame will update the normalization information; Rescale(Double_t f) -- Rescale drawn histogram by given factor. Histogram drawing options. DrawOption(const char* opt) -- Select ROOT draw option for resulting TGraph object; LineStyle(Int_t style) -- Select line style by ROOT line style code,",MatchSource.WIKI,root/html602/RooAbsData.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsData.html
https://root.cern/root/html602/RooAbsData.html:32680,Availability,error,error,32680,"d dataset will use the default binning of; the target frame. A binned dataset will by default retain its intrinsic binning. The following optional named arguments can be used to modify the default behavior. Data representation options. Asymmetry(const RooCategory& c) -- Show the asymmetry of the data in given two-state category [F(+)-F(-)] / [F(+)+F(-)].; Category must have two states with indices -1 and +1 or three states with indeces -1,0 and +1.; Efficiency(const RooCategory& c)-- Show the efficiency F(acc)/[F(acc)+F(rej)]. Category must have two states with indices 0 and 1; DataError(RooAbsData::EType) -- Select the type of error drawn:; - Auto(default) results in Poisson for unweighted data and SumW2 for weighted data; - Poisson draws asymmetric Poisson confidence intervals.; - SumW2 draws symmetric sum-of-weights error ( sum(w)^2/sum(w^2) ); - None draws no error bars; Binning(int nbins, double xlo, double xhi) -- Use specified binning to draw dataset; Binning(const RooAbsBinning&) -- Use specified binning to draw dataset; Binning(const char* name) -- Use binning with specified name to draw dataset; RefreshNorm(Bool_t flag) -- Force refreshing for PDF normalization information in frame.; If set, any subsequent PDF will normalize to this dataset, even if it is; not the first one added to the frame. By default only the 1st dataset; added to a frame will update the normalization information; Rescale(Double_t f) -- Rescale drawn histogram by given factor. Histogram drawing options. DrawOption(const char* opt) -- Select ROOT draw option for resulting TGraph object; LineStyle(Int_t style) -- Select line style by ROOT line style code, default is solid; LineColor(Int_t color) -- Select line color by ROOT color code, default is black; LineWidth(Int_t width) -- Select line with in pixels, default is 3; MarkerStyle(Int_t style) -- Select the ROOT marker style, default is 21; MarkerColor(Int_t color) -- Select the ROOT marker color, default is black; MarkerSize(Double_t si",MatchSource.WIKI,root/html602/RooAbsData.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsData.html
https://root.cern/root/html602/RooAbsData.html:32725,Availability,error,error,32725,"d dataset will use the default binning of; the target frame. A binned dataset will by default retain its intrinsic binning. The following optional named arguments can be used to modify the default behavior. Data representation options. Asymmetry(const RooCategory& c) -- Show the asymmetry of the data in given two-state category [F(+)-F(-)] / [F(+)+F(-)].; Category must have two states with indices -1 and +1 or three states with indeces -1,0 and +1.; Efficiency(const RooCategory& c)-- Show the efficiency F(acc)/[F(acc)+F(rej)]. Category must have two states with indices 0 and 1; DataError(RooAbsData::EType) -- Select the type of error drawn:; - Auto(default) results in Poisson for unweighted data and SumW2 for weighted data; - Poisson draws asymmetric Poisson confidence intervals.; - SumW2 draws symmetric sum-of-weights error ( sum(w)^2/sum(w^2) ); - None draws no error bars; Binning(int nbins, double xlo, double xhi) -- Use specified binning to draw dataset; Binning(const RooAbsBinning&) -- Use specified binning to draw dataset; Binning(const char* name) -- Use binning with specified name to draw dataset; RefreshNorm(Bool_t flag) -- Force refreshing for PDF normalization information in frame.; If set, any subsequent PDF will normalize to this dataset, even if it is; not the first one added to the frame. By default only the 1st dataset; added to a frame will update the normalization information; Rescale(Double_t f) -- Rescale drawn histogram by given factor. Histogram drawing options. DrawOption(const char* opt) -- Select ROOT draw option for resulting TGraph object; LineStyle(Int_t style) -- Select line style by ROOT line style code, default is solid; LineColor(Int_t color) -- Select line color by ROOT color code, default is black; LineWidth(Int_t width) -- Select line with in pixels, default is 3; MarkerStyle(Int_t style) -- Select the ROOT marker style, default is 21; MarkerColor(Int_t color) -- Select the ROOT marker color, default is black; MarkerSize(Double_t si",MatchSource.WIKI,root/html602/RooAbsData.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsData.html
https://root.cern/root/html602/RooAbsData.html:34061,Availability,error,error,34061,"ization information in frame.; If set, any subsequent PDF will normalize to this dataset, even if it is; not the first one added to the frame. By default only the 1st dataset; added to a frame will update the normalization information; Rescale(Double_t f) -- Rescale drawn histogram by given factor. Histogram drawing options. DrawOption(const char* opt) -- Select ROOT draw option for resulting TGraph object; LineStyle(Int_t style) -- Select line style by ROOT line style code, default is solid; LineColor(Int_t color) -- Select line color by ROOT color code, default is black; LineWidth(Int_t width) -- Select line with in pixels, default is 3; MarkerStyle(Int_t style) -- Select the ROOT marker style, default is 21; MarkerColor(Int_t color) -- Select the ROOT marker color, default is black; MarkerSize(Double_t size) -- Select the ROOT marker size; FillStyle(Int_t style) -- Select fill style, default is filled.; FillColor(Int_t color) -- Select fill color by ROOT color code; XErrorSize(Double_t frac) -- Select size of X error bar as fraction of the bin width, default is 1. Misc. other options. Name(const chat* name) -- Give curve specified name in frame. Useful if curve is to be referenced later; Invisble() -- Add curve to frame, but do not display. Useful in combination AddTo(); AddTo(const char* name, -- Add constructed histogram to already existing histogram with given name and relative weight factors; double_t wgtSelf, double_t wgtOther). RooPlot * plotOn(RooPlot* frame, RooAbsData::PlotOpt o) const; Create and fill a histogram of the frame's variable and append it to the frame.; The frame variable must be one of the data sets dimensions. The plot range and the number of plot bins is determined by the parameters; of the plot variable of the frame (RooAbsReal::setPlotRange(), RooAbsReal::setPlotBins()). The optional cut string expression can be used to select the events to be plotted.; The cut specification may refer to any variable contained in the data set. The drawOp",MatchSource.WIKI,root/html602/RooAbsData.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsData.html
https://root.cern/root/html602/RooAbsData.html:37281,Availability,error,error,37281,"s; of the plot variable of the frame (RooAbsReal::setPlotRange(), RooAbsReal::setPlotBins()). The optional cut string expression can be used to select the events to be plotted.; The cut specification may refer to any variable contained in the data set. The drawOptions are passed to the TH1::Draw() method. Roo1DTable* table(const RooAbsCategory& cat, const char* cuts = """", const char* opts = """") const; Create and fill a 1-dimensional table for given category column; This functions is the equivalent of plotOn() for category dimensions. The optional cut string expression can be used to select the events to be tabulated; The cut specification may refer to any variable contained in the data set. The option string is currently not used. Bool_t getRange(RooRealVar& var, Double_t& lowest, Double_t& highest, Double_t marginFrac = 0, Bool_t symMode = kFALSE) const; Fill Doubles 'lowest' and 'highest' with the lowest and highest value of; observable 'var' in this dataset. If the return value is kTRUE and error; occurred. void optimizeReadingWithCaching(RooAbsArg& arg, const RooArgSet& cacheList, const RooArgSet& keepObsList); Prepare dataset for use with cached constant terms listed in; 'cacheList' of expression 'arg'. Deactivate tree branches; for any dataset observable that is either not used at all,; or is used exclusively by cached branch nodes. Bool_t allClientsCached(RooAbsArg* , const RooArgSet& ); Utility function that determines if all clients of object 'var'; appear in given list of cached nodes. void attachBuffers(const RooArgSet& extObs). void resetBuffers(). Bool_t canSplitFast() const. RooAbsData* getSimData(const char* idxstate). void addOwnedComponent(const char* idxlabel, RooAbsData& data). void Streamer(TBuffer& ); Stream an object of class RooAbsData. void checkInit() const. void Draw(Option_t* option = """"); Forward draw command to data store. Bool_t hasFilledCache() const. const TTree* tree() const. RooAbsData* emptyClone(const char* newName = 0, const char",MatchSource.WIKI,root/html602/RooAbsData.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsData.html
https://root.cern/root/html602/RooAbsData.html:16243,Deployability,release,releaseVars,16243,"tatic RooPrintable::StyleOptionRooPrintable::kTreeStructure; static RooPrintable::ContentsOptionRooPrintable::kValue; static RooPrintable::StyleOptionRooPrintable::kVerbose; static TObject::(anonymous)TObject::kWriteDelete; static TObject::(anonymous)TObject::kZombie. protected:. TIterator*_cacheIter! Iterator over cached variables; RooArgSet_cachedVars! External variables cached with this data set; RooAbsDataStore*_dstoreData storage implementation; TIterator*_iterator! Iterator over dimension variables; static Int_tRooPrintable::_nameLength; map<string,RooAbsData*>_ownedComponentsOwned external components; RooArgSet_varsDimensions of this data set; static RooAbsData::StorageTypedefaultStorageType; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; void setDefaultStorageType(RooAbsData::StorageType s). void claimVars(RooAbsData* ). Bool_t releaseVars(RooAbsData* ); If return value is true variables can be deleted. RooAbsData(); Default constructor. RooAbsData(const char* name, const char* title, const RooArgSet& vars, RooAbsDataStore* store = 0); Constructor from a set of variables. Only fundamental elements of vars; (RooRealVar,RooCategory etc) are stored as part of the dataset. RooAbsData(const RooAbsData& other, const char* newname = 0); Copy constructor. ~RooAbsData(); Destructor. void convertToVectorStore(); Convert tree-based storage to vector-based storage. Bool_t changeObservableName(const char* from, const char* to). void fill(). Int_t numEntries() const. void reset(). const RooArgSet* get(Int_t index) const. void cacheArgs(const RooAbsArg* owner, RooArgSet& varSet, const RooArgSet* nset = 0, Bool_t skipZeroWeights = kFALSE); Internal method -- Cache given set of functions with data. void resetCache(); Internal method -- Remove cached function values. void attachCache(const RooAbsArg* newOwner, const RooArgSet& cachedVars); Internal method -- A",MatchSource.WIKI,root/html602/RooAbsData.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsData.html
https://root.cern/root/html602/RooAbsData.html:21761,Deployability,update,update,21761,"named arguments can be used to modify the default behavior. Data representation options. Asymmetry(const RooCategory& c) -- Show the asymmetry of the daya in given two-state category [F(+)-F(-)] / [F(+)+F(-)].; Category must have two states with indices -1 and +1 or three states with indeces -1,0 and +1.; DataError(RooAbsData::EType) -- Select the type of error drawn: Poisson (default) draws asymmetric Poisson; confidence intervals. SumW2 draws symmetric sum-of-weights error; Binning(int nbins, double xlo, -- Use specified binning to draw dataset; double xhi); Binning(const RooAbsBinning&) -- Use specified binning to draw dataset; Binning(const char* name) -- Use binning with specified name to draw dataset; RefreshNorm(Bool_t flag) -- Force refreshing for PDF normalization information in frame.; If set, any subsequent PDF will normalize to this dataset, even if it is; not the first one added to the frame. By default only the 1st dataset; added to a frame will update the normalization information; Rescale(Double_t factor) -- Apply global rescaling factor to histogram. Histogram drawing options. DrawOption(const char* opt) -- Select ROOT draw option for resulting TGraph object; LineStyle(Int_t style) -- Select line style by ROOT line style code, default is solid; LineColor(Int_t color) -- Select line color by ROOT color code, default is black; LineWidth(Int_t width) -- Select line with in pixels, default is 3; MarkerStyle(Int_t style) -- Select the ROOT marker style, default is 21; MarkerColor(Int_t color) -- Select the ROOT marker color, default is black; MarkerSize(Double_t size) -- Select the ROOT marker size; XErrorSize(Double_t frac) -- Select size of X error bar as fraction of the bin width, default is 1. Misc. other options. Name(const chat* name) -- Give curve specified name in frame. Useful if curve is to be referenced later; Invisble(Bool_t flag) -- Add curve to frame, but do not display. Useful in combination AddTo(); AddTo(const char* name, -- Add construct",MatchSource.WIKI,root/html602/RooAbsData.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsData.html
https://root.cern/root/html602/RooAbsData.html:33229,Deployability,update,update,33229,"1 and +1 or three states with indeces -1,0 and +1.; Efficiency(const RooCategory& c)-- Show the efficiency F(acc)/[F(acc)+F(rej)]. Category must have two states with indices 0 and 1; DataError(RooAbsData::EType) -- Select the type of error drawn:; - Auto(default) results in Poisson for unweighted data and SumW2 for weighted data; - Poisson draws asymmetric Poisson confidence intervals.; - SumW2 draws symmetric sum-of-weights error ( sum(w)^2/sum(w^2) ); - None draws no error bars; Binning(int nbins, double xlo, double xhi) -- Use specified binning to draw dataset; Binning(const RooAbsBinning&) -- Use specified binning to draw dataset; Binning(const char* name) -- Use binning with specified name to draw dataset; RefreshNorm(Bool_t flag) -- Force refreshing for PDF normalization information in frame.; If set, any subsequent PDF will normalize to this dataset, even if it is; not the first one added to the frame. By default only the 1st dataset; added to a frame will update the normalization information; Rescale(Double_t f) -- Rescale drawn histogram by given factor. Histogram drawing options. DrawOption(const char* opt) -- Select ROOT draw option for resulting TGraph object; LineStyle(Int_t style) -- Select line style by ROOT line style code, default is solid; LineColor(Int_t color) -- Select line color by ROOT color code, default is black; LineWidth(Int_t width) -- Select line with in pixels, default is 3; MarkerStyle(Int_t style) -- Select the ROOT marker style, default is 21; MarkerColor(Int_t color) -- Select the ROOT marker color, default is black; MarkerSize(Double_t size) -- Select the ROOT marker size; FillStyle(Int_t style) -- Select fill style, default is filled.; FillColor(Int_t color) -- Select fill color by ROOT color code; XErrorSize(Double_t frac) -- Select size of X error bar as fraction of the bin width, default is 1. Misc. other options. Name(const chat* name) -- Give curve specified name in frame. Useful if curve is to be referenced later; Invisble() ",MatchSource.WIKI,root/html602/RooAbsData.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsData.html
https://root.cern/root/html602/RooAbsData.html:8259,Energy Efficiency,reduce,reduce,8259,"const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()) const; virtual voidTObject::Pop(); virtual voidPrint(Option_t* options = 0) const; virtual voidRooPrintable::printAddress(ostream& os) const; virtual voidRooPrintable::printArgs(ostream& os) const; virtual voidprintClassName(ostream& os) const; virtual voidRooPrintable::printExtras(ostream& os) const; virtual voidprintMultiline(ostream& os, Int_t contents, Bool_t verbose = kFALSE, TString indent = """") const; virtual voidprintName(ostream& os) const; virtual voidRooPrintable::printStream(ostream& os, Int_t contents, RooPrintable::StyleOption style, TString indent = """") const; virtual voidprintTitle(ostream& os) const; virtual voidRooPrintable::printTree(ostream& os, TString indent = """") const; virtual voidRooPrintable::printValue(ostream& os) const; virtual Int_tTObject::Read(const char* name); virtual voidTObject::RecursiveRemove(TObject* obj); RooAbsData*reduce(const char* cut); RooAbsData*reduce(const RooFormulaVar& cutVar); RooAbsData*reduce(const RooArgSet& varSubset, const char* cut = 0); RooAbsData*reduce(const RooArgSet& varSubset, const RooFormulaVar& cutVar); RooAbsData*reduce(const RooCmdArg& arg1, const RooCmdArg& arg2 = RooCmdArg(), const RooCmdArg& arg3 = RooCmdArg(), const RooCmdArg& arg4 = RooCmdArg(), const RooCmdArg& arg5 = RooCmdArg(), const RooCmdArg& arg6 = RooCmdArg(), const RooCmdArg& arg7 = RooCmdArg(), const RooCmdArg& arg8 = RooCmdArg()); static Bool_treleaseVars(RooAbsData*); virtual voidreset(); voidTObject::ResetBit(UInt_t f); voidresetBuffers(); RooRealVar*rmsVar(RooRealVar& var, const char* cutSpec = 0, const char* cutRange = 0) const; RooAbsData(); RooAbsData(const RooAbsData& other, const char* newname = 0); RooAbsData(const char* name, const char* title, const RooArgSet& vars, RooAbsDataStore* store = 0); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTO",MatchSource.WIKI,root/html602/RooAbsData.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsData.html
https://root.cern/root/html602/RooAbsData.html:8295,Energy Efficiency,reduce,reduce,8295,"one(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()) const; virtual voidTObject::Pop(); virtual voidPrint(Option_t* options = 0) const; virtual voidRooPrintable::printAddress(ostream& os) const; virtual voidRooPrintable::printArgs(ostream& os) const; virtual voidprintClassName(ostream& os) const; virtual voidRooPrintable::printExtras(ostream& os) const; virtual voidprintMultiline(ostream& os, Int_t contents, Bool_t verbose = kFALSE, TString indent = """") const; virtual voidprintName(ostream& os) const; virtual voidRooPrintable::printStream(ostream& os, Int_t contents, RooPrintable::StyleOption style, TString indent = """") const; virtual voidprintTitle(ostream& os) const; virtual voidRooPrintable::printTree(ostream& os, TString indent = """") const; virtual voidRooPrintable::printValue(ostream& os) const; virtual Int_tTObject::Read(const char* name); virtual voidTObject::RecursiveRemove(TObject* obj); RooAbsData*reduce(const char* cut); RooAbsData*reduce(const RooFormulaVar& cutVar); RooAbsData*reduce(const RooArgSet& varSubset, const char* cut = 0); RooAbsData*reduce(const RooArgSet& varSubset, const RooFormulaVar& cutVar); RooAbsData*reduce(const RooCmdArg& arg1, const RooCmdArg& arg2 = RooCmdArg(), const RooCmdArg& arg3 = RooCmdArg(), const RooCmdArg& arg4 = RooCmdArg(), const RooCmdArg& arg5 = RooCmdArg(), const RooCmdArg& arg6 = RooCmdArg(), const RooCmdArg& arg7 = RooCmdArg(), const RooCmdArg& arg8 = RooCmdArg()); static Bool_treleaseVars(RooAbsData*); virtual voidreset(); voidTObject::ResetBit(UInt_t f); voidresetBuffers(); RooRealVar*rmsVar(RooRealVar& var, const char* cutSpec = 0, const char* cutRange = 0) const; RooAbsData(); RooAbsData(const RooAbsData& other, const char* newname = 0); RooAbsData(const char* name, const char* title, const RooArgSet& vars, RooAbsDataStore* store = 0); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(ostream& out, O",MatchSource.WIKI,root/html602/RooAbsData.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsData.html
https://root.cern/root/html602/RooAbsData.html:8343,Energy Efficiency,reduce,reduce,8343,", const RooCmdArg& arg8 = RooCmdArg::none()) const; virtual voidTObject::Pop(); virtual voidPrint(Option_t* options = 0) const; virtual voidRooPrintable::printAddress(ostream& os) const; virtual voidRooPrintable::printArgs(ostream& os) const; virtual voidprintClassName(ostream& os) const; virtual voidRooPrintable::printExtras(ostream& os) const; virtual voidprintMultiline(ostream& os, Int_t contents, Bool_t verbose = kFALSE, TString indent = """") const; virtual voidprintName(ostream& os) const; virtual voidRooPrintable::printStream(ostream& os, Int_t contents, RooPrintable::StyleOption style, TString indent = """") const; virtual voidprintTitle(ostream& os) const; virtual voidRooPrintable::printTree(ostream& os, TString indent = """") const; virtual voidRooPrintable::printValue(ostream& os) const; virtual Int_tTObject::Read(const char* name); virtual voidTObject::RecursiveRemove(TObject* obj); RooAbsData*reduce(const char* cut); RooAbsData*reduce(const RooFormulaVar& cutVar); RooAbsData*reduce(const RooArgSet& varSubset, const char* cut = 0); RooAbsData*reduce(const RooArgSet& varSubset, const RooFormulaVar& cutVar); RooAbsData*reduce(const RooCmdArg& arg1, const RooCmdArg& arg2 = RooCmdArg(), const RooCmdArg& arg3 = RooCmdArg(), const RooCmdArg& arg4 = RooCmdArg(), const RooCmdArg& arg5 = RooCmdArg(), const RooCmdArg& arg6 = RooCmdArg(), const RooCmdArg& arg7 = RooCmdArg(), const RooCmdArg& arg8 = RooCmdArg()); static Bool_treleaseVars(RooAbsData*); virtual voidreset(); voidTObject::ResetBit(UInt_t f); voidresetBuffers(); RooRealVar*rmsVar(RooRealVar& var, const char* cutSpec = 0, const char* cutRange = 0) const; RooAbsData(); RooAbsData(const RooAbsData& other, const char* newname = 0); RooAbsData(const char* name, const char* title, const RooArgSet& vars, RooAbsDataStore* store = 0); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); voidTObject::SetBit(UInt_",MatchSource.WIKI,root/html602/RooAbsData.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsData.html
https://root.cern/root/html602/RooAbsData.html:8411,Energy Efficiency,reduce,reduce,8411,"ect::Pop(); virtual voidPrint(Option_t* options = 0) const; virtual voidRooPrintable::printAddress(ostream& os) const; virtual voidRooPrintable::printArgs(ostream& os) const; virtual voidprintClassName(ostream& os) const; virtual voidRooPrintable::printExtras(ostream& os) const; virtual voidprintMultiline(ostream& os, Int_t contents, Bool_t verbose = kFALSE, TString indent = """") const; virtual voidprintName(ostream& os) const; virtual voidRooPrintable::printStream(ostream& os, Int_t contents, RooPrintable::StyleOption style, TString indent = """") const; virtual voidprintTitle(ostream& os) const; virtual voidRooPrintable::printTree(ostream& os, TString indent = """") const; virtual voidRooPrintable::printValue(ostream& os) const; virtual Int_tTObject::Read(const char* name); virtual voidTObject::RecursiveRemove(TObject* obj); RooAbsData*reduce(const char* cut); RooAbsData*reduce(const RooFormulaVar& cutVar); RooAbsData*reduce(const RooArgSet& varSubset, const char* cut = 0); RooAbsData*reduce(const RooArgSet& varSubset, const RooFormulaVar& cutVar); RooAbsData*reduce(const RooCmdArg& arg1, const RooCmdArg& arg2 = RooCmdArg(), const RooCmdArg& arg3 = RooCmdArg(), const RooCmdArg& arg4 = RooCmdArg(), const RooCmdArg& arg5 = RooCmdArg(), const RooCmdArg& arg6 = RooCmdArg(), const RooCmdArg& arg7 = RooCmdArg(), const RooCmdArg& arg8 = RooCmdArg()); static Bool_treleaseVars(RooAbsData*); virtual voidreset(); voidTObject::ResetBit(UInt_t f); voidresetBuffers(); RooRealVar*rmsVar(RooRealVar& var, const char* cutSpec = 0, const char* cutRange = 0) const; RooAbsData(); RooAbsData(const RooAbsData& other, const char* newname = 0); RooAbsData(const char* name, const char* title, const RooArgSet& vars, RooAbsDataStore* store = 0); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); static voidsetDefau",MatchSource.WIKI,root/html602/RooAbsData.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsData.html
https://root.cern/root/html602/RooAbsData.html:8487,Energy Efficiency,reduce,reduce,8487,"rintable::printAddress(ostream& os) const; virtual voidRooPrintable::printArgs(ostream& os) const; virtual voidprintClassName(ostream& os) const; virtual voidRooPrintable::printExtras(ostream& os) const; virtual voidprintMultiline(ostream& os, Int_t contents, Bool_t verbose = kFALSE, TString indent = """") const; virtual voidprintName(ostream& os) const; virtual voidRooPrintable::printStream(ostream& os, Int_t contents, RooPrintable::StyleOption style, TString indent = """") const; virtual voidprintTitle(ostream& os) const; virtual voidRooPrintable::printTree(ostream& os, TString indent = """") const; virtual voidRooPrintable::printValue(ostream& os) const; virtual Int_tTObject::Read(const char* name); virtual voidTObject::RecursiveRemove(TObject* obj); RooAbsData*reduce(const char* cut); RooAbsData*reduce(const RooFormulaVar& cutVar); RooAbsData*reduce(const RooArgSet& varSubset, const char* cut = 0); RooAbsData*reduce(const RooArgSet& varSubset, const RooFormulaVar& cutVar); RooAbsData*reduce(const RooCmdArg& arg1, const RooCmdArg& arg2 = RooCmdArg(), const RooCmdArg& arg3 = RooCmdArg(), const RooCmdArg& arg4 = RooCmdArg(), const RooCmdArg& arg5 = RooCmdArg(), const RooCmdArg& arg6 = RooCmdArg(), const RooCmdArg& arg7 = RooCmdArg(), const RooCmdArg& arg8 = RooCmdArg()); static Bool_treleaseVars(RooAbsData*); virtual voidreset(); voidTObject::ResetBit(UInt_t f); voidresetBuffers(); RooRealVar*rmsVar(RooRealVar& var, const char* cutSpec = 0, const char* cutRange = 0) const; RooAbsData(); RooAbsData(const RooAbsData& other, const char* newname = 0); RooAbsData(const char* name, const char* title, const RooArgSet& vars, RooAbsDataStore* store = 0); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); static voidsetDefaultStorageType(RooAbsData::StorageType s); voidsetDirtyProp(Bool_t flag); vir",MatchSource.WIKI,root/html602/RooAbsData.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsData.html
https://root.cern/root/html602/RooAbsData.html:13526,Energy Efficiency,reduce,reduceEng,13526,"orType etype = Poisson) const; virtual Double_tweightSquared() const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const. protected:. Bool_tallClientsCached(RooAbsArg*, const RooArgSet&); virtual voidattachCache(const RooAbsArg* newOwner, const RooArgSet& cachedVars); virtual voidcacheArgs(const RooAbsArg* owner, RooArgSet& varSet, const RooArgSet* nset = 0, Bool_t skipZeroWeights = kFALSE); virtual RooAbsData*cacheClone(const RooAbsArg* newCacheOwner, const RooArgSet* newCacheVars, const char* newName = 0); Double_tcorrcov(RooRealVar& x, RooRealVar& y, const char* cutSpec, const char* cutRange, Bool_t corr) const; TMatrixDSym*corrcovMatrix(const RooArgList& vars, const char* cutSpec, const char* cutRange, Bool_t corr) const; RooRealVar*dataRealVar(const char* methodname, RooRealVar& extVar) const; virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; voidTObject::MakeZombie(); virtual voidoptimizeReadingWithCaching(RooAbsArg& arg, const RooArgSet& cacheList, const RooArgSet& keepObsList); virtual RooPlot*plotAsymOn(RooPlot* frame, const RooAbsCategoryLValue& asymCat, RooAbsData::PlotOpt o) const; virtual RooPlot*plotEffOn(RooPlot* frame, const RooAbsCategoryLValue& effCat, RooAbsData::PlotOpt o) const; virtual RooPlot*plotOn(RooPlot* frame, RooAbsData::PlotOpt o) const; virtual RooAbsData*reduceEng(const RooArgSet& varSubset, const RooFormulaVar* cutVar, const char* cutRange = 0, Int_t nStart = 0, Int_t nStop = 2000000000, Bool_t copyCache = kTRUE); virtual voidresetCache(); virtual voidsetArgStatus(const RooArgSet& set, Bool_t active). Data Members; public:. static RooAbsData::ErrorTypeAuto; static RooAbsData::ErrorTypeExpected; static RooAbsData::ErrorTypeNone; static RooAbsData::ErrorTypePoisson; static RooAbsData::ErrorTypeSumW2; static RooAbsData::StorageTypeTree; static RooAbsData::Storag",MatchSource.WIKI,root/html602/RooAbsData.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsData.html
https://root.cern/root/html602/RooAbsData.html:17516,Energy Efficiency,reduce,reduce,17516,"ooAbsData(); Destructor. void convertToVectorStore(); Convert tree-based storage to vector-based storage. Bool_t changeObservableName(const char* from, const char* to). void fill(). Int_t numEntries() const. void reset(). const RooArgSet* get(Int_t index) const. void cacheArgs(const RooAbsArg* owner, RooArgSet& varSet, const RooArgSet* nset = 0, Bool_t skipZeroWeights = kFALSE); Internal method -- Cache given set of functions with data. void resetCache(); Internal method -- Remove cached function values. void attachCache(const RooAbsArg* newOwner, const RooArgSet& cachedVars); Internal method -- Attach dataset copied with cache contents to copied instances of functions. void setArgStatus(const RooArgSet& set, Bool_t active). void setDirtyProp(Bool_t flag); Control propagation of dirty flags from observables in dataset. RooAbsData* reduce(const RooCmdArg& arg1, const RooCmdArg& arg2 = RooCmdArg(), const RooCmdArg& arg3 = RooCmdArg(), const RooCmdArg& arg4 = RooCmdArg(), const RooCmdArg& arg5 = RooCmdArg(), const RooCmdArg& arg6 = RooCmdArg(), const RooCmdArg& arg7 = RooCmdArg(), const RooCmdArg& arg8 = RooCmdArg()); Create a reduced copy of this dataset. The caller takes ownership of the returned dataset. The following optional named arguments are accepted. SelectVars(const RooArgSet& vars) -- Only retain the listed observables in the output dataset; Cut(const char* expression) -- Only retain event surviving the given cut expression; Cut(const RooFormulaVar& expr) -- Only retain event surviving the given cut formula; CutRange(const char* name) -- Only retain events inside range with given name. Multiple CutRange; arguments may be given to select multiple ranges; EventRange(int lo, int hi) -- Only retain events with given sequential event numbers; Name(const char* name) -- Give specified name to output dataset; Title(const char* name) -- Give specified title to output dataset. RooAbsData* reduce(const char* cut); Create a subset of the data set by applying the given cu",MatchSource.WIKI,root/html602/RooAbsData.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsData.html
https://root.cern/root/html602/RooAbsData.html:17815,Energy Efficiency,reduce,reduced,17815,"ooAbsData(); Destructor. void convertToVectorStore(); Convert tree-based storage to vector-based storage. Bool_t changeObservableName(const char* from, const char* to). void fill(). Int_t numEntries() const. void reset(). const RooArgSet* get(Int_t index) const. void cacheArgs(const RooAbsArg* owner, RooArgSet& varSet, const RooArgSet* nset = 0, Bool_t skipZeroWeights = kFALSE); Internal method -- Cache given set of functions with data. void resetCache(); Internal method -- Remove cached function values. void attachCache(const RooAbsArg* newOwner, const RooArgSet& cachedVars); Internal method -- Attach dataset copied with cache contents to copied instances of functions. void setArgStatus(const RooArgSet& set, Bool_t active). void setDirtyProp(Bool_t flag); Control propagation of dirty flags from observables in dataset. RooAbsData* reduce(const RooCmdArg& arg1, const RooCmdArg& arg2 = RooCmdArg(), const RooCmdArg& arg3 = RooCmdArg(), const RooCmdArg& arg4 = RooCmdArg(), const RooCmdArg& arg5 = RooCmdArg(), const RooCmdArg& arg6 = RooCmdArg(), const RooCmdArg& arg7 = RooCmdArg(), const RooCmdArg& arg8 = RooCmdArg()); Create a reduced copy of this dataset. The caller takes ownership of the returned dataset. The following optional named arguments are accepted. SelectVars(const RooArgSet& vars) -- Only retain the listed observables in the output dataset; Cut(const char* expression) -- Only retain event surviving the given cut expression; Cut(const RooFormulaVar& expr) -- Only retain event surviving the given cut formula; CutRange(const char* name) -- Only retain events inside range with given name. Multiple CutRange; arguments may be given to select multiple ranges; EventRange(int lo, int hi) -- Only retain events with given sequential event numbers; Name(const char* name) -- Give specified name to output dataset; Title(const char* name) -- Give specified title to output dataset. RooAbsData* reduce(const char* cut); Create a subset of the data set by applying the given cu",MatchSource.WIKI,root/html602/RooAbsData.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsData.html
https://root.cern/root/html602/RooAbsData.html:18593,Energy Efficiency,reduce,reduce,18593,"arg4 = RooCmdArg(), const RooCmdArg& arg5 = RooCmdArg(), const RooCmdArg& arg6 = RooCmdArg(), const RooCmdArg& arg7 = RooCmdArg(), const RooCmdArg& arg8 = RooCmdArg()); Create a reduced copy of this dataset. The caller takes ownership of the returned dataset. The following optional named arguments are accepted. SelectVars(const RooArgSet& vars) -- Only retain the listed observables in the output dataset; Cut(const char* expression) -- Only retain event surviving the given cut expression; Cut(const RooFormulaVar& expr) -- Only retain event surviving the given cut formula; CutRange(const char* name) -- Only retain events inside range with given name. Multiple CutRange; arguments may be given to select multiple ranges; EventRange(int lo, int hi) -- Only retain events with given sequential event numbers; Name(const char* name) -- Give specified name to output dataset; Title(const char* name) -- Give specified title to output dataset. RooAbsData* reduce(const char* cut); Create a subset of the data set by applying the given cut on the data points.; The cut expression can refer to any variable in the data set. For cuts involving; other variables, such as intermediate formula objects, use the equivalent; reduce method specifying the as a RooFormulVar reference. RooAbsData* reduce(const RooFormulaVar& cutVar); Create a subset of the data set by applying the given cut on the data points.; The 'cutVar' formula variable is used to select the subset of data points to be; retained in the reduced data collection. RooAbsData* reduce(const RooArgSet& varSubset, const char* cut = 0); Create a subset of the data set by applying the given cut on the data points; and reducing the dimensions to the specified set. The cut expression can refer to any variable in the data set. For cuts involving; other variables, such as intermediate formula objects, use the equivalent; reduce method specifying the as a RooFormulVar reference. RooAbsData* reduce(const RooArgSet& varSubset, const RooFormulaV",MatchSource.WIKI,root/html602/RooAbsData.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsData.html
https://root.cern/root/html602/RooAbsData.html:18854,Energy Efficiency,reduce,reduce,18854,"s dataset. The caller takes ownership of the returned dataset. The following optional named arguments are accepted. SelectVars(const RooArgSet& vars) -- Only retain the listed observables in the output dataset; Cut(const char* expression) -- Only retain event surviving the given cut expression; Cut(const RooFormulaVar& expr) -- Only retain event surviving the given cut formula; CutRange(const char* name) -- Only retain events inside range with given name. Multiple CutRange; arguments may be given to select multiple ranges; EventRange(int lo, int hi) -- Only retain events with given sequential event numbers; Name(const char* name) -- Give specified name to output dataset; Title(const char* name) -- Give specified title to output dataset. RooAbsData* reduce(const char* cut); Create a subset of the data set by applying the given cut on the data points.; The cut expression can refer to any variable in the data set. For cuts involving; other variables, such as intermediate formula objects, use the equivalent; reduce method specifying the as a RooFormulVar reference. RooAbsData* reduce(const RooFormulaVar& cutVar); Create a subset of the data set by applying the given cut on the data points.; The 'cutVar' formula variable is used to select the subset of data points to be; retained in the reduced data collection. RooAbsData* reduce(const RooArgSet& varSubset, const char* cut = 0); Create a subset of the data set by applying the given cut on the data points; and reducing the dimensions to the specified set. The cut expression can refer to any variable in the data set. For cuts involving; other variables, such as intermediate formula objects, use the equivalent; reduce method specifying the as a RooFormulVar reference. RooAbsData* reduce(const RooArgSet& varSubset, const RooFormulaVar& cutVar); Create a subset of the data set by applying the given cut on the data points; and reducing the dimensions to the specified set. The 'cutVar' formula variable is used to select the subs",MatchSource.WIKI,root/html602/RooAbsData.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsData.html
https://root.cern/root/html602/RooAbsData.html:18924,Energy Efficiency,reduce,reduce,18924,"et& vars) -- Only retain the listed observables in the output dataset; Cut(const char* expression) -- Only retain event surviving the given cut expression; Cut(const RooFormulaVar& expr) -- Only retain event surviving the given cut formula; CutRange(const char* name) -- Only retain events inside range with given name. Multiple CutRange; arguments may be given to select multiple ranges; EventRange(int lo, int hi) -- Only retain events with given sequential event numbers; Name(const char* name) -- Give specified name to output dataset; Title(const char* name) -- Give specified title to output dataset. RooAbsData* reduce(const char* cut); Create a subset of the data set by applying the given cut on the data points.; The cut expression can refer to any variable in the data set. For cuts involving; other variables, such as intermediate formula objects, use the equivalent; reduce method specifying the as a RooFormulVar reference. RooAbsData* reduce(const RooFormulaVar& cutVar); Create a subset of the data set by applying the given cut on the data points.; The 'cutVar' formula variable is used to select the subset of data points to be; retained in the reduced data collection. RooAbsData* reduce(const RooArgSet& varSubset, const char* cut = 0); Create a subset of the data set by applying the given cut on the data points; and reducing the dimensions to the specified set. The cut expression can refer to any variable in the data set. For cuts involving; other variables, such as intermediate formula objects, use the equivalent; reduce method specifying the as a RooFormulVar reference. RooAbsData* reduce(const RooArgSet& varSubset, const RooFormulaVar& cutVar); Create a subset of the data set by applying the given cut on the data points; and reducing the dimensions to the specified set. The 'cutVar' formula variable is used to select the subset of data points to be; retained in the reduced data collection. Double_t weightError(RooAbsData::ErrorType etype = Poisson) const; Return ",MatchSource.WIKI,root/html602/RooAbsData.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsData.html
https://root.cern/root/html602/RooAbsData.html:19137,Energy Efficiency,reduce,reduced,19137,"ving the given cut expression; Cut(const RooFormulaVar& expr) -- Only retain event surviving the given cut formula; CutRange(const char* name) -- Only retain events inside range with given name. Multiple CutRange; arguments may be given to select multiple ranges; EventRange(int lo, int hi) -- Only retain events with given sequential event numbers; Name(const char* name) -- Give specified name to output dataset; Title(const char* name) -- Give specified title to output dataset. RooAbsData* reduce(const char* cut); Create a subset of the data set by applying the given cut on the data points.; The cut expression can refer to any variable in the data set. For cuts involving; other variables, such as intermediate formula objects, use the equivalent; reduce method specifying the as a RooFormulVar reference. RooAbsData* reduce(const RooFormulaVar& cutVar); Create a subset of the data set by applying the given cut on the data points.; The 'cutVar' formula variable is used to select the subset of data points to be; retained in the reduced data collection. RooAbsData* reduce(const RooArgSet& varSubset, const char* cut = 0); Create a subset of the data set by applying the given cut on the data points; and reducing the dimensions to the specified set. The cut expression can refer to any variable in the data set. For cuts involving; other variables, such as intermediate formula objects, use the equivalent; reduce method specifying the as a RooFormulVar reference. RooAbsData* reduce(const RooArgSet& varSubset, const RooFormulaVar& cutVar); Create a subset of the data set by applying the given cut on the data points; and reducing the dimensions to the specified set. The 'cutVar' formula variable is used to select the subset of data points to be; retained in the reduced data collection. Double_t weightError(RooAbsData::ErrorType etype = Poisson) const; Return error on current weight (dummy implementation returning zero). void weightError(Double_t& lo, Double_t& hi, RooAbsData::Error",MatchSource.WIKI,root/html602/RooAbsData.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsData.html
https://root.cern/root/html602/RooAbsData.html:19174,Energy Efficiency,reduce,reduce,19174,"ents inside range with given name. Multiple CutRange; arguments may be given to select multiple ranges; EventRange(int lo, int hi) -- Only retain events with given sequential event numbers; Name(const char* name) -- Give specified name to output dataset; Title(const char* name) -- Give specified title to output dataset. RooAbsData* reduce(const char* cut); Create a subset of the data set by applying the given cut on the data points.; The cut expression can refer to any variable in the data set. For cuts involving; other variables, such as intermediate formula objects, use the equivalent; reduce method specifying the as a RooFormulVar reference. RooAbsData* reduce(const RooFormulaVar& cutVar); Create a subset of the data set by applying the given cut on the data points.; The 'cutVar' formula variable is used to select the subset of data points to be; retained in the reduced data collection. RooAbsData* reduce(const RooArgSet& varSubset, const char* cut = 0); Create a subset of the data set by applying the given cut on the data points; and reducing the dimensions to the specified set. The cut expression can refer to any variable in the data set. For cuts involving; other variables, such as intermediate formula objects, use the equivalent; reduce method specifying the as a RooFormulVar reference. RooAbsData* reduce(const RooArgSet& varSubset, const RooFormulaVar& cutVar); Create a subset of the data set by applying the given cut on the data points; and reducing the dimensions to the specified set. The 'cutVar' formula variable is used to select the subset of data points to be; retained in the reduced data collection. Double_t weightError(RooAbsData::ErrorType etype = Poisson) const; Return error on current weight (dummy implementation returning zero). void weightError(Double_t& lo, Double_t& hi, RooAbsData::ErrorType etype = Poisson) const; Return asymmetric error on weight. (Dummy implementation returning zero). RooPlot* plotOn(RooPlot* frame, const RooCmdArg& arg1 = R",MatchSource.WIKI,root/html602/RooAbsData.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsData.html
https://root.cern/root/html602/RooAbsData.html:19516,Energy Efficiency,reduce,reduce,19516,"o output dataset; Title(const char* name) -- Give specified title to output dataset. RooAbsData* reduce(const char* cut); Create a subset of the data set by applying the given cut on the data points.; The cut expression can refer to any variable in the data set. For cuts involving; other variables, such as intermediate formula objects, use the equivalent; reduce method specifying the as a RooFormulVar reference. RooAbsData* reduce(const RooFormulaVar& cutVar); Create a subset of the data set by applying the given cut on the data points.; The 'cutVar' formula variable is used to select the subset of data points to be; retained in the reduced data collection. RooAbsData* reduce(const RooArgSet& varSubset, const char* cut = 0); Create a subset of the data set by applying the given cut on the data points; and reducing the dimensions to the specified set. The cut expression can refer to any variable in the data set. For cuts involving; other variables, such as intermediate formula objects, use the equivalent; reduce method specifying the as a RooFormulVar reference. RooAbsData* reduce(const RooArgSet& varSubset, const RooFormulaVar& cutVar); Create a subset of the data set by applying the given cut on the data points; and reducing the dimensions to the specified set. The 'cutVar' formula variable is used to select the subset of data points to be; retained in the reduced data collection. Double_t weightError(RooAbsData::ErrorType etype = Poisson) const; Return error on current weight (dummy implementation returning zero). void weightError(Double_t& lo, Double_t& hi, RooAbsData::ErrorType etype = Poisson) const; Return asymmetric error on weight. (Dummy implementation returning zero). RooPlot* plotOn(RooPlot* frame, const RooCmdArg& arg1 = RooCmdArg::none(), const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), cons",MatchSource.WIKI,root/html602/RooAbsData.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsData.html
https://root.cern/root/html602/RooAbsData.html:19586,Energy Efficiency,reduce,reduce,19586," on the data points.; The cut expression can refer to any variable in the data set. For cuts involving; other variables, such as intermediate formula objects, use the equivalent; reduce method specifying the as a RooFormulVar reference. RooAbsData* reduce(const RooFormulaVar& cutVar); Create a subset of the data set by applying the given cut on the data points.; The 'cutVar' formula variable is used to select the subset of data points to be; retained in the reduced data collection. RooAbsData* reduce(const RooArgSet& varSubset, const char* cut = 0); Create a subset of the data set by applying the given cut on the data points; and reducing the dimensions to the specified set. The cut expression can refer to any variable in the data set. For cuts involving; other variables, such as intermediate formula objects, use the equivalent; reduce method specifying the as a RooFormulVar reference. RooAbsData* reduce(const RooArgSet& varSubset, const RooFormulaVar& cutVar); Create a subset of the data set by applying the given cut on the data points; and reducing the dimensions to the specified set. The 'cutVar' formula variable is used to select the subset of data points to be; retained in the reduced data collection. Double_t weightError(RooAbsData::ErrorType etype = Poisson) const; Return error on current weight (dummy implementation returning zero). void weightError(Double_t& lo, Double_t& hi, RooAbsData::ErrorType etype = Poisson) const; Return asymmetric error on weight. (Dummy implementation returning zero). RooPlot* plotOn(RooPlot* frame, const RooCmdArg& arg1 = RooCmdArg::none(), const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()) const; Plot dataset on specified frame. By default an unbinned dataset will use the default binni",MatchSource.WIKI,root/html602/RooAbsData.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsData.html
https://root.cern/root/html602/RooAbsData.html:19876,Energy Efficiency,reduce,reduced,19876,"he equivalent; reduce method specifying the as a RooFormulVar reference. RooAbsData* reduce(const RooFormulaVar& cutVar); Create a subset of the data set by applying the given cut on the data points.; The 'cutVar' formula variable is used to select the subset of data points to be; retained in the reduced data collection. RooAbsData* reduce(const RooArgSet& varSubset, const char* cut = 0); Create a subset of the data set by applying the given cut on the data points; and reducing the dimensions to the specified set. The cut expression can refer to any variable in the data set. For cuts involving; other variables, such as intermediate formula objects, use the equivalent; reduce method specifying the as a RooFormulVar reference. RooAbsData* reduce(const RooArgSet& varSubset, const RooFormulaVar& cutVar); Create a subset of the data set by applying the given cut on the data points; and reducing the dimensions to the specified set. The 'cutVar' formula variable is used to select the subset of data points to be; retained in the reduced data collection. Double_t weightError(RooAbsData::ErrorType etype = Poisson) const; Return error on current weight (dummy implementation returning zero). void weightError(Double_t& lo, Double_t& hi, RooAbsData::ErrorType etype = Poisson) const; Return asymmetric error on weight. (Dummy implementation returning zero). RooPlot* plotOn(RooPlot* frame, const RooCmdArg& arg1 = RooCmdArg::none(), const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()) const; Plot dataset on specified frame. By default an unbinned dataset will use the default binning of; the target frame. A binned dataset will by default retain its intrinsic binning. The following optional named arguments can be used to modify the default be",MatchSource.WIKI,root/html602/RooAbsData.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsData.html
https://root.cern/root/html602/RooAbsData.html:40724,Energy Efficiency,reduce,reduceEng,40724,"cutRange = 0) const; { return moment(var,1,0,cutSpec,cutRange) ; }. Double_t sigma(RooRealVar& var, const char* cutSpec = 0, const char* cutRange = 0) const; { return sqrt(moment(var,2,cutSpec,cutRange)) ; }. Double_t skewness(RooRealVar& var, const char* cutSpec = 0, const char* cutRange = 0) const; { return standMoment(var,3,cutSpec,cutRange) ; }. Double_t kurtosis(RooRealVar& var, const char* cutSpec = 0, const char* cutRange = 0) const; { return standMoment(var,4,cutSpec,cutRange) ; }. Double_t covariance(RooRealVar& x, RooRealVar& y, const char* cutSpec = 0, const char* cutRange = 0) const; { return corrcov(x,y,cutSpec,cutRange,kFALSE) ; }. Double_t correlation(RooRealVar& x, RooRealVar& y, const char* cutSpec = 0, const char* cutRange = 0) const; { return corrcov(x,y,cutSpec,cutRange,kTRUE) ; }. TMatrixDSym* covarianceMatrix(const char* cutSpec = 0, const char* cutRange = 0) const; { return covarianceMatrix(*get(),cutSpec,cutRange) ; }. TMatrixDSym* correlationMatrix(const char* cutSpec = 0, const char* cutRange = 0) const; { return correlationMatrix(*get(),cutSpec,cutRange) ; }. TMatrixDSym* covarianceMatrix(const RooArgList& vars, const char* cutSpec = 0, const char* cutRange = 0) const; { return corrcovMatrix(vars,cutSpec,cutRange,kFALSE) ; }. TMatrixDSym* correlationMatrix(const RooArgList& vars, const char* cutSpec = 0, const char* cutRange = 0) const; { return corrcovMatrix(vars,cutSpec,cutRange,kTRUE) ; }. StorageType getDefaultStorageType(). RooAbsData* cacheClone(const RooAbsArg* newCacheOwner, const RooArgSet* newCacheVars, const char* newName = 0). RooAbsData* reduceEng(const RooArgSet& varSubset, const RooFormulaVar* cutVar, const char* cutRange = 0, Int_t nStart = 0, Int_t nStop = 2000000000, Bool_t copyCache = kTRUE). » Last changed: Tue Jun 30 14:30:05 2015 » Last generated: 2015-06-30 14:30; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html602/RooAbsData.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsData.html
https://root.cern/root/html602/RooAbsData.html:412,Integrability,interface,interface,412,". RooAbsData. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » ROOFIT; » ROOFITCORE; » RooAbsData. class RooAbsData: public TNamed, public RooPrintable. RooAbsData is the common abstract base class for binned and unbinned; datasets. The abstract interface defines plotting and tabulating entry; points for its contents and provides an iterator over its elements; (bins for binned data sets, data points for unbinned datasets).; . Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~RooAbsData(); voidTObject::AbstractMethod(const char* method) const; virtual voidadd(const RooArgSet& row, Double_t weight = 1, Double_t weightError = 0); voidaddOwnedComponent(const char* idxlabel, RooAbsData& data); virtual voidTObject::AppendPad(Option_t* option = """"); voidattachBuffers(const RooArgSet& extObs); virtual voidTObject::Browse(TBrowser* b); Bool_tcanSplitFast() const; virtual Bool_tchangeObservableName(const char* from, const char* to); voidcheckInit() const; static voidclaimVars(RooAbsData*); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; voidconvertToVectorStore(); virtual voidTNamed::Copy(TObject& named) const; Double_tcorrelation(RooRealVar& x, RooRealVar& y, const char* cutSpec = 0, const char* cutRange = 0) const; TMatrixDSym*correlationMatrix(const char* cutSpec = 0, const char* cutRange = 0) const; TMatrixDSym*correlationMatrix(const RooArgList& vars, const char* cutSpec = 0, const char* cutRange = 0) const; Double_tcovariance(RooRealVar& x, RooRealVar& y, const char* cutSpec = 0, const char* cutRa",MatchSource.WIKI,root/html602/RooAbsData.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsData.html
https://root.cern/root/html602/RooAbsData.html:39024,Integrability,interface,interface,39024,"TBuffer& ); Stream an object of class RooAbsData. void checkInit() const. void Draw(Option_t* option = """"); Forward draw command to data store. Bool_t hasFilledCache() const. const TTree* tree() const. RooAbsData* emptyClone(const char* newName = 0, const char* newTitle = 0, const RooArgSet* vars = 0, const char* wgtVarName = 0) const. RooAbsDataStore* store(); { return _dstore ; }. const RooAbsDataStore* store() const; { return _dstore ; }. void add(const RooArgSet& row, Double_t weight = 1, Double_t weightError = 0); Add one ore more rows of data. const RooArgSet* get() const; Load a given row of data. Double_t weight() const. Double_t weightSquared() const. Bool_t valid() const; { return kTRUE ; }. Double_t sumEntries() const. Double_t sumEntries(const char* cutSpec, const char* cutRange = 0) const. Bool_t isWeighted() const; Do events in dataset have weights?. Bool_t isNonPoissonWeighted() const; Do events in dataset have non-integer weights?. void Print(Option_t* options = 0) const; Printing interface (human readable). Double_t mean(RooRealVar& var, const char* cutSpec = 0, const char* cutRange = 0) const; { return moment(var,1,0,cutSpec,cutRange) ; }. Double_t sigma(RooRealVar& var, const char* cutSpec = 0, const char* cutRange = 0) const; { return sqrt(moment(var,2,cutSpec,cutRange)) ; }. Double_t skewness(RooRealVar& var, const char* cutSpec = 0, const char* cutRange = 0) const; { return standMoment(var,3,cutSpec,cutRange) ; }. Double_t kurtosis(RooRealVar& var, const char* cutSpec = 0, const char* cutRange = 0) const; { return standMoment(var,4,cutSpec,cutRange) ; }. Double_t covariance(RooRealVar& x, RooRealVar& y, const char* cutSpec = 0, const char* cutRange = 0) const; { return corrcov(x,y,cutSpec,cutRange,kFALSE) ; }. Double_t correlation(RooRealVar& x, RooRealVar& y, const char* cutSpec = 0, const char* cutRange = 0) const; { return corrcov(x,y,cutSpec,cutRange,kTRUE) ; }. TMatrixDSym* covarianceMatrix(const char* cutSpec = 0, const char* cutRange = 0",MatchSource.WIKI,root/html602/RooAbsData.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsData.html
https://root.cern/root/html602/RooAbsData.html:15601,Modifiability,variab,variables,15601,"ooPrintable::ContentsOptionRooPrintable::kName; static TObject::EStatusBitsTObject::kNoContextMenu; static TObject::(anonymous)TObject::kNotDeleted; static TObject::EStatusBitsTObject::kObjInCanvas; static TObject::(anonymous)TObject::kOverwrite; static TObject::(anonymous)TObject::kSingleKey; static RooPrintable::StyleOptionRooPrintable::kSingleLine; static RooPrintable::StyleOptionRooPrintable::kStandard; static RooPrintable::ContentsOptionRooPrintable::kTitle; static RooPrintable::StyleOptionRooPrintable::kTreeStructure; static RooPrintable::ContentsOptionRooPrintable::kValue; static RooPrintable::StyleOptionRooPrintable::kVerbose; static TObject::(anonymous)TObject::kWriteDelete; static TObject::(anonymous)TObject::kZombie. protected:. TIterator*_cacheIter! Iterator over cached variables; RooArgSet_cachedVars! External variables cached with this data set; RooAbsDataStore*_dstoreData storage implementation; TIterator*_iterator! Iterator over dimension variables; static Int_tRooPrintable::_nameLength; map<string,RooAbsData*>_ownedComponentsOwned external components; RooArgSet_varsDimensions of this data set; static RooAbsData::StorageTypedefaultStorageType; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; void setDefaultStorageType(RooAbsData::StorageType s). void claimVars(RooAbsData* ). Bool_t releaseVars(RooAbsData* ); If return value is true variables can be deleted. RooAbsData(); Default constructor. RooAbsData(const char* name, const char* title, const RooArgSet& vars, RooAbsDataStore* store = 0); Constructor from a set of variables. Only fundamental elements of vars; (RooRealVar,RooCategory etc) are stored as part of the dataset. RooAbsData(const RooAbsData& other, const char* newname = 0); Copy constructor. ~RooAbsData(); Destructor. void convertToVectorStore(); Convert tree-based storage to vector-based storage. Bool_t changeObservableName(c",MatchSource.WIKI,root/html602/RooAbsData.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsData.html
https://root.cern/root/html602/RooAbsData.html:15643,Modifiability,variab,variables,15643,"ooPrintable::ContentsOptionRooPrintable::kName; static TObject::EStatusBitsTObject::kNoContextMenu; static TObject::(anonymous)TObject::kNotDeleted; static TObject::EStatusBitsTObject::kObjInCanvas; static TObject::(anonymous)TObject::kOverwrite; static TObject::(anonymous)TObject::kSingleKey; static RooPrintable::StyleOptionRooPrintable::kSingleLine; static RooPrintable::StyleOptionRooPrintable::kStandard; static RooPrintable::ContentsOptionRooPrintable::kTitle; static RooPrintable::StyleOptionRooPrintable::kTreeStructure; static RooPrintable::ContentsOptionRooPrintable::kValue; static RooPrintable::StyleOptionRooPrintable::kVerbose; static TObject::(anonymous)TObject::kWriteDelete; static TObject::(anonymous)TObject::kZombie. protected:. TIterator*_cacheIter! Iterator over cached variables; RooArgSet_cachedVars! External variables cached with this data set; RooAbsDataStore*_dstoreData storage implementation; TIterator*_iterator! Iterator over dimension variables; static Int_tRooPrintable::_nameLength; map<string,RooAbsData*>_ownedComponentsOwned external components; RooArgSet_varsDimensions of this data set; static RooAbsData::StorageTypedefaultStorageType; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; void setDefaultStorageType(RooAbsData::StorageType s). void claimVars(RooAbsData* ). Bool_t releaseVars(RooAbsData* ); If return value is true variables can be deleted. RooAbsData(); Default constructor. RooAbsData(const char* name, const char* title, const RooArgSet& vars, RooAbsDataStore* store = 0); Constructor from a set of variables. Only fundamental elements of vars; (RooRealVar,RooCategory etc) are stored as part of the dataset. RooAbsData(const RooAbsData& other, const char* newname = 0); Copy constructor. ~RooAbsData(); Destructor. void convertToVectorStore(); Convert tree-based storage to vector-based storage. Bool_t changeObservableName(c",MatchSource.WIKI,root/html602/RooAbsData.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsData.html
https://root.cern/root/html602/RooAbsData.html:15777,Modifiability,variab,variables,15777,"ooPrintable::ContentsOptionRooPrintable::kName; static TObject::EStatusBitsTObject::kNoContextMenu; static TObject::(anonymous)TObject::kNotDeleted; static TObject::EStatusBitsTObject::kObjInCanvas; static TObject::(anonymous)TObject::kOverwrite; static TObject::(anonymous)TObject::kSingleKey; static RooPrintable::StyleOptionRooPrintable::kSingleLine; static RooPrintable::StyleOptionRooPrintable::kStandard; static RooPrintable::ContentsOptionRooPrintable::kTitle; static RooPrintable::StyleOptionRooPrintable::kTreeStructure; static RooPrintable::ContentsOptionRooPrintable::kValue; static RooPrintable::StyleOptionRooPrintable::kVerbose; static TObject::(anonymous)TObject::kWriteDelete; static TObject::(anonymous)TObject::kZombie. protected:. TIterator*_cacheIter! Iterator over cached variables; RooArgSet_cachedVars! External variables cached with this data set; RooAbsDataStore*_dstoreData storage implementation; TIterator*_iterator! Iterator over dimension variables; static Int_tRooPrintable::_nameLength; map<string,RooAbsData*>_ownedComponentsOwned external components; RooArgSet_varsDimensions of this data set; static RooAbsData::StorageTypedefaultStorageType; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; void setDefaultStorageType(RooAbsData::StorageType s). void claimVars(RooAbsData* ). Bool_t releaseVars(RooAbsData* ); If return value is true variables can be deleted. RooAbsData(); Default constructor. RooAbsData(const char* name, const char* title, const RooArgSet& vars, RooAbsDataStore* store = 0); Constructor from a set of variables. Only fundamental elements of vars; (RooRealVar,RooCategory etc) are stored as part of the dataset. RooAbsData(const RooAbsData& other, const char* newname = 0); Copy constructor. ~RooAbsData(); Destructor. void convertToVectorStore(); Convert tree-based storage to vector-based storage. Bool_t changeObservableName(c",MatchSource.WIKI,root/html602/RooAbsData.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsData.html
https://root.cern/root/html602/RooAbsData.html:16294,Modifiability,variab,variables,16294,"tatic RooPrintable::StyleOptionRooPrintable::kTreeStructure; static RooPrintable::ContentsOptionRooPrintable::kValue; static RooPrintable::StyleOptionRooPrintable::kVerbose; static TObject::(anonymous)TObject::kWriteDelete; static TObject::(anonymous)TObject::kZombie. protected:. TIterator*_cacheIter! Iterator over cached variables; RooArgSet_cachedVars! External variables cached with this data set; RooAbsDataStore*_dstoreData storage implementation; TIterator*_iterator! Iterator over dimension variables; static Int_tRooPrintable::_nameLength; map<string,RooAbsData*>_ownedComponentsOwned external components; RooArgSet_varsDimensions of this data set; static RooAbsData::StorageTypedefaultStorageType; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; void setDefaultStorageType(RooAbsData::StorageType s). void claimVars(RooAbsData* ). Bool_t releaseVars(RooAbsData* ); If return value is true variables can be deleted. RooAbsData(); Default constructor. RooAbsData(const char* name, const char* title, const RooArgSet& vars, RooAbsDataStore* store = 0); Constructor from a set of variables. Only fundamental elements of vars; (RooRealVar,RooCategory etc) are stored as part of the dataset. RooAbsData(const RooAbsData& other, const char* newname = 0); Copy constructor. ~RooAbsData(); Destructor. void convertToVectorStore(); Convert tree-based storage to vector-based storage. Bool_t changeObservableName(const char* from, const char* to). void fill(). Int_t numEntries() const. void reset(). const RooArgSet* get(Int_t index) const. void cacheArgs(const RooAbsArg* owner, RooArgSet& varSet, const RooArgSet* nset = 0, Bool_t skipZeroWeights = kFALSE); Internal method -- Cache given set of functions with data. void resetCache(); Internal method -- Remove cached function values. void attachCache(const RooAbsArg* newOwner, const RooArgSet& cachedVars); Internal method -- A",MatchSource.WIKI,root/html602/RooAbsData.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsData.html
https://root.cern/root/html602/RooAbsData.html:16481,Modifiability,variab,variables,16481,"ptionRooPrintable::kVerbose; static TObject::(anonymous)TObject::kWriteDelete; static TObject::(anonymous)TObject::kZombie. protected:. TIterator*_cacheIter! Iterator over cached variables; RooArgSet_cachedVars! External variables cached with this data set; RooAbsDataStore*_dstoreData storage implementation; TIterator*_iterator! Iterator over dimension variables; static Int_tRooPrintable::_nameLength; map<string,RooAbsData*>_ownedComponentsOwned external components; RooArgSet_varsDimensions of this data set; static RooAbsData::StorageTypedefaultStorageType; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; void setDefaultStorageType(RooAbsData::StorageType s). void claimVars(RooAbsData* ). Bool_t releaseVars(RooAbsData* ); If return value is true variables can be deleted. RooAbsData(); Default constructor. RooAbsData(const char* name, const char* title, const RooArgSet& vars, RooAbsDataStore* store = 0); Constructor from a set of variables. Only fundamental elements of vars; (RooRealVar,RooCategory etc) are stored as part of the dataset. RooAbsData(const RooAbsData& other, const char* newname = 0); Copy constructor. ~RooAbsData(); Destructor. void convertToVectorStore(); Convert tree-based storage to vector-based storage. Bool_t changeObservableName(const char* from, const char* to). void fill(). Int_t numEntries() const. void reset(). const RooArgSet* get(Int_t index) const. void cacheArgs(const RooAbsArg* owner, RooArgSet& varSet, const RooArgSet* nset = 0, Bool_t skipZeroWeights = kFALSE); Internal method -- Cache given set of functions with data. void resetCache(); Internal method -- Remove cached function values. void attachCache(const RooAbsArg* newOwner, const RooArgSet& cachedVars); Internal method -- Attach dataset copied with cache contents to copied instances of functions. void setArgStatus(const RooArgSet& set, Bool_t active). void setDirtyPr",MatchSource.WIKI,root/html602/RooAbsData.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsData.html
https://root.cern/root/html602/RooAbsData.html:18733,Modifiability,variab,variable,18733,"g(), const RooCmdArg& arg7 = RooCmdArg(), const RooCmdArg& arg8 = RooCmdArg()); Create a reduced copy of this dataset. The caller takes ownership of the returned dataset. The following optional named arguments are accepted. SelectVars(const RooArgSet& vars) -- Only retain the listed observables in the output dataset; Cut(const char* expression) -- Only retain event surviving the given cut expression; Cut(const RooFormulaVar& expr) -- Only retain event surviving the given cut formula; CutRange(const char* name) -- Only retain events inside range with given name. Multiple CutRange; arguments may be given to select multiple ranges; EventRange(int lo, int hi) -- Only retain events with given sequential event numbers; Name(const char* name) -- Give specified name to output dataset; Title(const char* name) -- Give specified title to output dataset. RooAbsData* reduce(const char* cut); Create a subset of the data set by applying the given cut on the data points.; The cut expression can refer to any variable in the data set. For cuts involving; other variables, such as intermediate formula objects, use the equivalent; reduce method specifying the as a RooFormulVar reference. RooAbsData* reduce(const RooFormulaVar& cutVar); Create a subset of the data set by applying the given cut on the data points.; The 'cutVar' formula variable is used to select the subset of data points to be; retained in the reduced data collection. RooAbsData* reduce(const RooArgSet& varSubset, const char* cut = 0); Create a subset of the data set by applying the given cut on the data points; and reducing the dimensions to the specified set. The cut expression can refer to any variable in the data set. For cuts involving; other variables, such as intermediate formula objects, use the equivalent; reduce method specifying the as a RooFormulVar reference. RooAbsData* reduce(const RooArgSet& varSubset, const RooFormulaVar& cutVar); Create a subset of the data set by applying the given cut on the data points",MatchSource.WIKI,root/html602/RooAbsData.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsData.html
https://root.cern/root/html602/RooAbsData.html:18785,Modifiability,variab,variables,18785,"s dataset. The caller takes ownership of the returned dataset. The following optional named arguments are accepted. SelectVars(const RooArgSet& vars) -- Only retain the listed observables in the output dataset; Cut(const char* expression) -- Only retain event surviving the given cut expression; Cut(const RooFormulaVar& expr) -- Only retain event surviving the given cut formula; CutRange(const char* name) -- Only retain events inside range with given name. Multiple CutRange; arguments may be given to select multiple ranges; EventRange(int lo, int hi) -- Only retain events with given sequential event numbers; Name(const char* name) -- Give specified name to output dataset; Title(const char* name) -- Give specified title to output dataset. RooAbsData* reduce(const char* cut); Create a subset of the data set by applying the given cut on the data points.; The cut expression can refer to any variable in the data set. For cuts involving; other variables, such as intermediate formula objects, use the equivalent; reduce method specifying the as a RooFormulVar reference. RooAbsData* reduce(const RooFormulaVar& cutVar); Create a subset of the data set by applying the given cut on the data points.; The 'cutVar' formula variable is used to select the subset of data points to be; retained in the reduced data collection. RooAbsData* reduce(const RooArgSet& varSubset, const char* cut = 0); Create a subset of the data set by applying the given cut on the data points; and reducing the dimensions to the specified set. The cut expression can refer to any variable in the data set. For cuts involving; other variables, such as intermediate formula objects, use the equivalent; reduce method specifying the as a RooFormulVar reference. RooAbsData* reduce(const RooArgSet& varSubset, const RooFormulaVar& cutVar); Create a subset of the data set by applying the given cut on the data points; and reducing the dimensions to the specified set. The 'cutVar' formula variable is used to select the subs",MatchSource.WIKI,root/html602/RooAbsData.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsData.html
https://root.cern/root/html602/RooAbsData.html:19061,Modifiability,variab,variable,19061,"ving the given cut expression; Cut(const RooFormulaVar& expr) -- Only retain event surviving the given cut formula; CutRange(const char* name) -- Only retain events inside range with given name. Multiple CutRange; arguments may be given to select multiple ranges; EventRange(int lo, int hi) -- Only retain events with given sequential event numbers; Name(const char* name) -- Give specified name to output dataset; Title(const char* name) -- Give specified title to output dataset. RooAbsData* reduce(const char* cut); Create a subset of the data set by applying the given cut on the data points.; The cut expression can refer to any variable in the data set. For cuts involving; other variables, such as intermediate formula objects, use the equivalent; reduce method specifying the as a RooFormulVar reference. RooAbsData* reduce(const RooFormulaVar& cutVar); Create a subset of the data set by applying the given cut on the data points.; The 'cutVar' formula variable is used to select the subset of data points to be; retained in the reduced data collection. RooAbsData* reduce(const RooArgSet& varSubset, const char* cut = 0); Create a subset of the data set by applying the given cut on the data points; and reducing the dimensions to the specified set. The cut expression can refer to any variable in the data set. For cuts involving; other variables, such as intermediate formula objects, use the equivalent; reduce method specifying the as a RooFormulVar reference. RooAbsData* reduce(const RooArgSet& varSubset, const RooFormulaVar& cutVar); Create a subset of the data set by applying the given cut on the data points; and reducing the dimensions to the specified set. The 'cutVar' formula variable is used to select the subset of data points to be; retained in the reduced data collection. Double_t weightError(RooAbsData::ErrorType etype = Poisson) const; Return error on current weight (dummy implementation returning zero). void weightError(Double_t& lo, Double_t& hi, RooAbsData::Error",MatchSource.WIKI,root/html602/RooAbsData.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsData.html
https://root.cern/root/html602/RooAbsData.html:19395,Modifiability,variab,variable,19395," -- Only retain events with given sequential event numbers; Name(const char* name) -- Give specified name to output dataset; Title(const char* name) -- Give specified title to output dataset. RooAbsData* reduce(const char* cut); Create a subset of the data set by applying the given cut on the data points.; The cut expression can refer to any variable in the data set. For cuts involving; other variables, such as intermediate formula objects, use the equivalent; reduce method specifying the as a RooFormulVar reference. RooAbsData* reduce(const RooFormulaVar& cutVar); Create a subset of the data set by applying the given cut on the data points.; The 'cutVar' formula variable is used to select the subset of data points to be; retained in the reduced data collection. RooAbsData* reduce(const RooArgSet& varSubset, const char* cut = 0); Create a subset of the data set by applying the given cut on the data points; and reducing the dimensions to the specified set. The cut expression can refer to any variable in the data set. For cuts involving; other variables, such as intermediate formula objects, use the equivalent; reduce method specifying the as a RooFormulVar reference. RooAbsData* reduce(const RooArgSet& varSubset, const RooFormulaVar& cutVar); Create a subset of the data set by applying the given cut on the data points; and reducing the dimensions to the specified set. The 'cutVar' formula variable is used to select the subset of data points to be; retained in the reduced data collection. Double_t weightError(RooAbsData::ErrorType etype = Poisson) const; Return error on current weight (dummy implementation returning zero). void weightError(Double_t& lo, Double_t& hi, RooAbsData::ErrorType etype = Poisson) const; Return asymmetric error on weight. (Dummy implementation returning zero). RooPlot* plotOn(RooPlot* frame, const RooCmdArg& arg1 = RooCmdArg::none(), const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = R",MatchSource.WIKI,root/html602/RooAbsData.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsData.html
https://root.cern/root/html602/RooAbsData.html:19447,Modifiability,variab,variables,19447,"o output dataset; Title(const char* name) -- Give specified title to output dataset. RooAbsData* reduce(const char* cut); Create a subset of the data set by applying the given cut on the data points.; The cut expression can refer to any variable in the data set. For cuts involving; other variables, such as intermediate formula objects, use the equivalent; reduce method specifying the as a RooFormulVar reference. RooAbsData* reduce(const RooFormulaVar& cutVar); Create a subset of the data set by applying the given cut on the data points.; The 'cutVar' formula variable is used to select the subset of data points to be; retained in the reduced data collection. RooAbsData* reduce(const RooArgSet& varSubset, const char* cut = 0); Create a subset of the data set by applying the given cut on the data points; and reducing the dimensions to the specified set. The cut expression can refer to any variable in the data set. For cuts involving; other variables, such as intermediate formula objects, use the equivalent; reduce method specifying the as a RooFormulVar reference. RooAbsData* reduce(const RooArgSet& varSubset, const RooFormulaVar& cutVar); Create a subset of the data set by applying the given cut on the data points; and reducing the dimensions to the specified set. The 'cutVar' formula variable is used to select the subset of data points to be; retained in the reduced data collection. Double_t weightError(RooAbsData::ErrorType etype = Poisson) const; Return error on current weight (dummy implementation returning zero). void weightError(Double_t& lo, Double_t& hi, RooAbsData::ErrorType etype = Poisson) const; Return asymmetric error on weight. (Dummy implementation returning zero). RooPlot* plotOn(RooPlot* frame, const RooCmdArg& arg1 = RooCmdArg::none(), const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), cons",MatchSource.WIKI,root/html602/RooAbsData.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsData.html
https://root.cern/root/html602/RooAbsData.html:19800,Modifiability,variab,variable,19800,"he equivalent; reduce method specifying the as a RooFormulVar reference. RooAbsData* reduce(const RooFormulaVar& cutVar); Create a subset of the data set by applying the given cut on the data points.; The 'cutVar' formula variable is used to select the subset of data points to be; retained in the reduced data collection. RooAbsData* reduce(const RooArgSet& varSubset, const char* cut = 0); Create a subset of the data set by applying the given cut on the data points; and reducing the dimensions to the specified set. The cut expression can refer to any variable in the data set. For cuts involving; other variables, such as intermediate formula objects, use the equivalent; reduce method specifying the as a RooFormulVar reference. RooAbsData* reduce(const RooArgSet& varSubset, const RooFormulaVar& cutVar); Create a subset of the data set by applying the given cut on the data points; and reducing the dimensions to the specified set. The 'cutVar' formula variable is used to select the subset of data points to be; retained in the reduced data collection. Double_t weightError(RooAbsData::ErrorType etype = Poisson) const; Return error on current weight (dummy implementation returning zero). void weightError(Double_t& lo, Double_t& hi, RooAbsData::ErrorType etype = Poisson) const; Return asymmetric error on weight. (Dummy implementation returning zero). RooPlot* plotOn(RooPlot* frame, const RooCmdArg& arg1 = RooCmdArg::none(), const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()) const; Plot dataset on specified frame. By default an unbinned dataset will use the default binning of; the target frame. A binned dataset will by default retain its intrinsic binning. The following optional named arguments can be used to modify the default be",MatchSource.WIKI,root/html602/RooAbsData.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsData.html
https://root.cern/root/html602/RooAbsData.html:23107,Modifiability,variab,variables,23107,"color) -- Select line color by ROOT color code, default is black; LineWidth(Int_t width) -- Select line with in pixels, default is 3; MarkerStyle(Int_t style) -- Select the ROOT marker style, default is 21; MarkerColor(Int_t color) -- Select the ROOT marker color, default is black; MarkerSize(Double_t size) -- Select the ROOT marker size; XErrorSize(Double_t frac) -- Select size of X error bar as fraction of the bin width, default is 1. Misc. other options. Name(const chat* name) -- Give curve specified name in frame. Useful if curve is to be referenced later; Invisble(Bool_t flag) -- Add curve to frame, but do not display. Useful in combination AddTo(); AddTo(const char* name, -- Add constructed histogram to already existing histogram with given name and relative weight factors; double_t wgtSelf, double_t wgtOther). TH1 * createHistogram(const char* varNameList, Int_t xbins = 0, Int_t ybins = 0, Int_t zbins = 0) const; Create and fill a ROOT histogram TH1,TH2 or TH3 with the values of this dataset for the variables with given names; The range of each observable that is histogrammed is always automatically calculated from the distribution in; the dataset. The number of bins can be controlled using the [xyz]bins parameters. For a greater degree of control; use the createHistogram() method below with named arguments. The caller takes ownership of the returned histogram. TH1 * createHistogram(const char* name, const RooAbsRealLValue& xvar, const RooCmdArg& arg1 = RooCmdArg::none(), const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()) const; Create and fill a ROOT histogram TH1,TH2 or TH3 with the values of this dataset. This function accepts the following arguments. name -- Name of the ROOT histogram; xvar -- Observable to be ",MatchSource.WIKI,root/html602/RooAbsData.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsData.html
https://root.cern/root/html602/RooAbsData.html:28904,Modifiability,variab,variable,28904,"nt is calculated on the subset of the data which pass the C++; cut specification expression 'cutSpec' and/or are inside the; range named 'cutRange'. RooRealVar* rmsVar(RooRealVar& var, const char* cutSpec = 0, const char* cutRange = 0) const; Create a RooRealVar containing the RMS of observable 'var' in; this dataset. If cutSpec and/or cutRange are specified the; moment is calculated on the subset of the data which pass the C++; cut specification expression 'cutSpec' and/or are inside the; range named 'cutRange'. RooPlot* statOn(RooPlot* frame, const RooCmdArg& arg1 = RooCmdArg::none(), const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()); Add a box with statistics information to the specified frame. By default a box with the; event count, mean and rms of the plotted variable is added. The following optional named arguments are accepted. What(const char* whatstr) -- Controls what is printed: ""N"" = count, ""M"" is mean, ""R"" is RMS.; Format(const char* optStr) -- Classing [arameter formatting options, provided for backward compatibility; Format(const char* what,...) -- Parameter formatting options, details given below; Label(const chat* label) -- Add header label to parameter box; Layout(Double_t xmin, -- Specify relative position of left,right side of box and top of box. Position of; Double_t xmax, Double_t ymax) bottom of box is calculated automatically from number lines in box; Cut(const char* expression) -- Apply given cut expression to data when calculating statistics; CutRange(const char* rangeName) -- Only consider events within given range when calculating statistics. Multiple; CutRange() argument may be specified to combine ranges. The Format(const char* what,...) has the following structure. const char* what -- Contro",MatchSource.WIKI,root/html602/RooAbsData.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsData.html
https://root.cern/root/html602/RooAbsData.html:30250,Modifiability,variab,variable,30250,"at,...) -- Parameter formatting options, details given below; Label(const chat* label) -- Add header label to parameter box; Layout(Double_t xmin, -- Specify relative position of left,right side of box and top of box. Position of; Double_t xmax, Double_t ymax) bottom of box is calculated automatically from number lines in box; Cut(const char* expression) -- Apply given cut expression to data when calculating statistics; CutRange(const char* rangeName) -- Only consider events within given range when calculating statistics. Multiple; CutRange() argument may be specified to combine ranges. The Format(const char* what,...) has the following structure. const char* what -- Controls what is shown. ""N"" adds name, ""E"" adds error,; ""A"" shows asymmetric error, ""U"" shows unit, ""H"" hides the value; FixedPrecision(int n) -- Controls precision, set fixed number of digits; AutoPrecision(int n) -- Controls precision. Number of shown digits is calculated from error; + n specified additional digits (1 is sensible default); VerbatimName(Bool_t flag) -- Put variable name in a \verb+ + clause. RooPlot* statOn(RooPlot* frame, const char* what, const char* label = """", Int_t sigDigits = 2, Option_t* options = ""NELU"", Double_t xmin = 0.14999999999999999, Double_t xmax = 0.65000000000000002, Double_t ymax = 0.84999999999999998, const char* cutSpec = 0, const char* cutRange = 0, const RooCmdArg* formatCmd = 0); Implementation back-end of statOn() mehtod with named arguments. TH1 * fillHistogram(TH1* hist, const RooArgList& plotVars, const char* cuts = """", const char* cutRange = 0) const; Loop over columns of our tree data and fill the input histogram. Returns a pointer to the; input histogram, or zero in case of an error. The input histogram can be any TH1 subclass, and; therefore of arbitrary dimension. Variables are matched with the (x,y,...) dimensions of the input; histogram according to the order in which they appear in the input plotVars list. TList* split(const RooAbsCategory& splitCat, ",MatchSource.WIKI,root/html602/RooAbsData.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsData.html
https://root.cern/root/html602/RooAbsData.html:34598,Modifiability,variab,variable,34598,"line color by ROOT color code, default is black; LineWidth(Int_t width) -- Select line with in pixels, default is 3; MarkerStyle(Int_t style) -- Select the ROOT marker style, default is 21; MarkerColor(Int_t color) -- Select the ROOT marker color, default is black; MarkerSize(Double_t size) -- Select the ROOT marker size; FillStyle(Int_t style) -- Select fill style, default is filled.; FillColor(Int_t color) -- Select fill color by ROOT color code; XErrorSize(Double_t frac) -- Select size of X error bar as fraction of the bin width, default is 1. Misc. other options. Name(const chat* name) -- Give curve specified name in frame. Useful if curve is to be referenced later; Invisble() -- Add curve to frame, but do not display. Useful in combination AddTo(); AddTo(const char* name, -- Add constructed histogram to already existing histogram with given name and relative weight factors; double_t wgtSelf, double_t wgtOther). RooPlot * plotOn(RooPlot* frame, RooAbsData::PlotOpt o) const; Create and fill a histogram of the frame's variable and append it to the frame.; The frame variable must be one of the data sets dimensions. The plot range and the number of plot bins is determined by the parameters; of the plot variable of the frame (RooAbsReal::setPlotRange(), RooAbsReal::setPlotBins()). The optional cut string expression can be used to select the events to be plotted.; The cut specification may refer to any variable contained in the data set. The drawOptions are passed to the TH1::Draw() method. RooPlot* plotAsymOn(RooPlot* frame, const RooAbsCategoryLValue& asymCat, RooAbsData::PlotOpt o) const; Create and fill a histogram with the asymmetry N[+] - N[-] / ( N[+] + N[-] ),; where N(+/-) is the number of data points with asymCat=+1 and asymCat=-1; as function of the frames variable. The asymmetry category 'asymCat' must; have exactly 2 (or 3) states defined with index values +1,-1 (and 0). The plot range and the number of plot bins is determined by the parameters; of the plo",MatchSource.WIKI,root/html602/RooAbsData.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsData.html
https://root.cern/root/html602/RooAbsData.html:34646,Modifiability,variab,variable,34646," default is 3; MarkerStyle(Int_t style) -- Select the ROOT marker style, default is 21; MarkerColor(Int_t color) -- Select the ROOT marker color, default is black; MarkerSize(Double_t size) -- Select the ROOT marker size; FillStyle(Int_t style) -- Select fill style, default is filled.; FillColor(Int_t color) -- Select fill color by ROOT color code; XErrorSize(Double_t frac) -- Select size of X error bar as fraction of the bin width, default is 1. Misc. other options. Name(const chat* name) -- Give curve specified name in frame. Useful if curve is to be referenced later; Invisble() -- Add curve to frame, but do not display. Useful in combination AddTo(); AddTo(const char* name, -- Add constructed histogram to already existing histogram with given name and relative weight factors; double_t wgtSelf, double_t wgtOther). RooPlot * plotOn(RooPlot* frame, RooAbsData::PlotOpt o) const; Create and fill a histogram of the frame's variable and append it to the frame.; The frame variable must be one of the data sets dimensions. The plot range and the number of plot bins is determined by the parameters; of the plot variable of the frame (RooAbsReal::setPlotRange(), RooAbsReal::setPlotBins()). The optional cut string expression can be used to select the events to be plotted.; The cut specification may refer to any variable contained in the data set. The drawOptions are passed to the TH1::Draw() method. RooPlot* plotAsymOn(RooPlot* frame, const RooAbsCategoryLValue& asymCat, RooAbsData::PlotOpt o) const; Create and fill a histogram with the asymmetry N[+] - N[-] / ( N[+] + N[-] ),; where N(+/-) is the number of data points with asymCat=+1 and asymCat=-1; as function of the frames variable. The asymmetry category 'asymCat' must; have exactly 2 (or 3) states defined with index values +1,-1 (and 0). The plot range and the number of plot bins is determined by the parameters; of the plot variable of the frame (RooAbsReal::setPlotRange(), RooAbsReal::setPlotBins()). The optional cut stri",MatchSource.WIKI,root/html602/RooAbsData.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsData.html
https://root.cern/root/html602/RooAbsData.html:34784,Modifiability,variab,variable,34784,"- Select the ROOT marker color, default is black; MarkerSize(Double_t size) -- Select the ROOT marker size; FillStyle(Int_t style) -- Select fill style, default is filled.; FillColor(Int_t color) -- Select fill color by ROOT color code; XErrorSize(Double_t frac) -- Select size of X error bar as fraction of the bin width, default is 1. Misc. other options. Name(const chat* name) -- Give curve specified name in frame. Useful if curve is to be referenced later; Invisble() -- Add curve to frame, but do not display. Useful in combination AddTo(); AddTo(const char* name, -- Add constructed histogram to already existing histogram with given name and relative weight factors; double_t wgtSelf, double_t wgtOther). RooPlot * plotOn(RooPlot* frame, RooAbsData::PlotOpt o) const; Create and fill a histogram of the frame's variable and append it to the frame.; The frame variable must be one of the data sets dimensions. The plot range and the number of plot bins is determined by the parameters; of the plot variable of the frame (RooAbsReal::setPlotRange(), RooAbsReal::setPlotBins()). The optional cut string expression can be used to select the events to be plotted.; The cut specification may refer to any variable contained in the data set. The drawOptions are passed to the TH1::Draw() method. RooPlot* plotAsymOn(RooPlot* frame, const RooAbsCategoryLValue& asymCat, RooAbsData::PlotOpt o) const; Create and fill a histogram with the asymmetry N[+] - N[-] / ( N[+] + N[-] ),; where N(+/-) is the number of data points with asymCat=+1 and asymCat=-1; as function of the frames variable. The asymmetry category 'asymCat' must; have exactly 2 (or 3) states defined with index values +1,-1 (and 0). The plot range and the number of plot bins is determined by the parameters; of the plot variable of the frame (RooAbsReal::setPlotRange(), RooAbsReal::setPlotBins()). The optional cut string expression can be used to select the events to be plotted.; The cut specification may refer to any variable con",MatchSource.WIKI,root/html602/RooAbsData.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsData.html
https://root.cern/root/html602/RooAbsData.html:34986,Modifiability,variab,variable,34986," fill color by ROOT color code; XErrorSize(Double_t frac) -- Select size of X error bar as fraction of the bin width, default is 1. Misc. other options. Name(const chat* name) -- Give curve specified name in frame. Useful if curve is to be referenced later; Invisble() -- Add curve to frame, but do not display. Useful in combination AddTo(); AddTo(const char* name, -- Add constructed histogram to already existing histogram with given name and relative weight factors; double_t wgtSelf, double_t wgtOther). RooPlot * plotOn(RooPlot* frame, RooAbsData::PlotOpt o) const; Create and fill a histogram of the frame's variable and append it to the frame.; The frame variable must be one of the data sets dimensions. The plot range and the number of plot bins is determined by the parameters; of the plot variable of the frame (RooAbsReal::setPlotRange(), RooAbsReal::setPlotBins()). The optional cut string expression can be used to select the events to be plotted.; The cut specification may refer to any variable contained in the data set. The drawOptions are passed to the TH1::Draw() method. RooPlot* plotAsymOn(RooPlot* frame, const RooAbsCategoryLValue& asymCat, RooAbsData::PlotOpt o) const; Create and fill a histogram with the asymmetry N[+] - N[-] / ( N[+] + N[-] ),; where N(+/-) is the number of data points with asymCat=+1 and asymCat=-1; as function of the frames variable. The asymmetry category 'asymCat' must; have exactly 2 (or 3) states defined with index values +1,-1 (and 0). The plot range and the number of plot bins is determined by the parameters; of the plot variable of the frame (RooAbsReal::setPlotRange(), RooAbsReal::setPlotBins()). The optional cut string expression can be used to select the events to be plotted.; The cut specification may refer to any variable contained in the data set. The drawOptions are passed to the TH1::Draw() method. RooPlot* plotEffOn(RooPlot* frame, const RooAbsCategoryLValue& effCat, RooAbsData::PlotOpt o) const; Create and fill a histogr",MatchSource.WIKI,root/html602/RooAbsData.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsData.html
https://root.cern/root/html602/RooAbsData.html:35358,Modifiability,variab,variable,35358,"e referenced later; Invisble() -- Add curve to frame, but do not display. Useful in combination AddTo(); AddTo(const char* name, -- Add constructed histogram to already existing histogram with given name and relative weight factors; double_t wgtSelf, double_t wgtOther). RooPlot * plotOn(RooPlot* frame, RooAbsData::PlotOpt o) const; Create and fill a histogram of the frame's variable and append it to the frame.; The frame variable must be one of the data sets dimensions. The plot range and the number of plot bins is determined by the parameters; of the plot variable of the frame (RooAbsReal::setPlotRange(), RooAbsReal::setPlotBins()). The optional cut string expression can be used to select the events to be plotted.; The cut specification may refer to any variable contained in the data set. The drawOptions are passed to the TH1::Draw() method. RooPlot* plotAsymOn(RooPlot* frame, const RooAbsCategoryLValue& asymCat, RooAbsData::PlotOpt o) const; Create and fill a histogram with the asymmetry N[+] - N[-] / ( N[+] + N[-] ),; where N(+/-) is the number of data points with asymCat=+1 and asymCat=-1; as function of the frames variable. The asymmetry category 'asymCat' must; have exactly 2 (or 3) states defined with index values +1,-1 (and 0). The plot range and the number of plot bins is determined by the parameters; of the plot variable of the frame (RooAbsReal::setPlotRange(), RooAbsReal::setPlotBins()). The optional cut string expression can be used to select the events to be plotted.; The cut specification may refer to any variable contained in the data set. The drawOptions are passed to the TH1::Draw() method. RooPlot* plotEffOn(RooPlot* frame, const RooAbsCategoryLValue& effCat, RooAbsData::PlotOpt o) const; Create and fill a histogram with the effiency N[1] / ( N[1] + N[0] ),; where N(1/0) is the number of data points with effCat=1 and effCat=0; as function of the frames variable. The efficiency category 'effCat' must; have exactly 2 +1 and 0. The plot range and the",MatchSource.WIKI,root/html602/RooAbsData.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsData.html
https://root.cern/root/html602/RooAbsData.html:35565,Modifiability,variab,variable,35565,"te and fill a histogram of the frame's variable and append it to the frame.; The frame variable must be one of the data sets dimensions. The plot range and the number of plot bins is determined by the parameters; of the plot variable of the frame (RooAbsReal::setPlotRange(), RooAbsReal::setPlotBins()). The optional cut string expression can be used to select the events to be plotted.; The cut specification may refer to any variable contained in the data set. The drawOptions are passed to the TH1::Draw() method. RooPlot* plotAsymOn(RooPlot* frame, const RooAbsCategoryLValue& asymCat, RooAbsData::PlotOpt o) const; Create and fill a histogram with the asymmetry N[+] - N[-] / ( N[+] + N[-] ),; where N(+/-) is the number of data points with asymCat=+1 and asymCat=-1; as function of the frames variable. The asymmetry category 'asymCat' must; have exactly 2 (or 3) states defined with index values +1,-1 (and 0). The plot range and the number of plot bins is determined by the parameters; of the plot variable of the frame (RooAbsReal::setPlotRange(), RooAbsReal::setPlotBins()). The optional cut string expression can be used to select the events to be plotted.; The cut specification may refer to any variable contained in the data set. The drawOptions are passed to the TH1::Draw() method. RooPlot* plotEffOn(RooPlot* frame, const RooAbsCategoryLValue& effCat, RooAbsData::PlotOpt o) const; Create and fill a histogram with the effiency N[1] / ( N[1] + N[0] ),; where N(1/0) is the number of data points with effCat=1 and effCat=0; as function of the frames variable. The efficiency category 'effCat' must; have exactly 2 +1 and 0. The plot range and the number of plot bins is determined by the parameters; of the plot variable of the frame (RooAbsReal::setPlotRange(), RooAbsReal::setPlotBins()). The optional cut string expression can be used to select the events to be plotted.; The cut specification may refer to any variable contained in the data set. The drawOptions are passed to the T",MatchSource.WIKI,root/html602/RooAbsData.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsData.html
https://root.cern/root/html602/RooAbsData.html:35767,Modifiability,variab,variable,35767,"meters; of the plot variable of the frame (RooAbsReal::setPlotRange(), RooAbsReal::setPlotBins()). The optional cut string expression can be used to select the events to be plotted.; The cut specification may refer to any variable contained in the data set. The drawOptions are passed to the TH1::Draw() method. RooPlot* plotAsymOn(RooPlot* frame, const RooAbsCategoryLValue& asymCat, RooAbsData::PlotOpt o) const; Create and fill a histogram with the asymmetry N[+] - N[-] / ( N[+] + N[-] ),; where N(+/-) is the number of data points with asymCat=+1 and asymCat=-1; as function of the frames variable. The asymmetry category 'asymCat' must; have exactly 2 (or 3) states defined with index values +1,-1 (and 0). The plot range and the number of plot bins is determined by the parameters; of the plot variable of the frame (RooAbsReal::setPlotRange(), RooAbsReal::setPlotBins()). The optional cut string expression can be used to select the events to be plotted.; The cut specification may refer to any variable contained in the data set. The drawOptions are passed to the TH1::Draw() method. RooPlot* plotEffOn(RooPlot* frame, const RooAbsCategoryLValue& effCat, RooAbsData::PlotOpt o) const; Create and fill a histogram with the effiency N[1] / ( N[1] + N[0] ),; where N(1/0) is the number of data points with effCat=1 and effCat=0; as function of the frames variable. The efficiency category 'effCat' must; have exactly 2 +1 and 0. The plot range and the number of plot bins is determined by the parameters; of the plot variable of the frame (RooAbsReal::setPlotRange(), RooAbsReal::setPlotBins()). The optional cut string expression can be used to select the events to be plotted.; The cut specification may refer to any variable contained in the data set. The drawOptions are passed to the TH1::Draw() method. Roo1DTable* table(const RooAbsCategory& cat, const char* cuts = """", const char* opts = """") const; Create and fill a 1-dimensional table for given category column; This functions is the ",MatchSource.WIKI,root/html602/RooAbsData.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsData.html
https://root.cern/root/html602/RooAbsData.html:36125,Modifiability,variab,variable,36125,"contained in the data set. The drawOptions are passed to the TH1::Draw() method. RooPlot* plotAsymOn(RooPlot* frame, const RooAbsCategoryLValue& asymCat, RooAbsData::PlotOpt o) const; Create and fill a histogram with the asymmetry N[+] - N[-] / ( N[+] + N[-] ),; where N(+/-) is the number of data points with asymCat=+1 and asymCat=-1; as function of the frames variable. The asymmetry category 'asymCat' must; have exactly 2 (or 3) states defined with index values +1,-1 (and 0). The plot range and the number of plot bins is determined by the parameters; of the plot variable of the frame (RooAbsReal::setPlotRange(), RooAbsReal::setPlotBins()). The optional cut string expression can be used to select the events to be plotted.; The cut specification may refer to any variable contained in the data set. The drawOptions are passed to the TH1::Draw() method. RooPlot* plotEffOn(RooPlot* frame, const RooAbsCategoryLValue& effCat, RooAbsData::PlotOpt o) const; Create and fill a histogram with the effiency N[1] / ( N[1] + N[0] ),; where N(1/0) is the number of data points with effCat=1 and effCat=0; as function of the frames variable. The efficiency category 'effCat' must; have exactly 2 +1 and 0. The plot range and the number of plot bins is determined by the parameters; of the plot variable of the frame (RooAbsReal::setPlotRange(), RooAbsReal::setPlotBins()). The optional cut string expression can be used to select the events to be plotted.; The cut specification may refer to any variable contained in the data set. The drawOptions are passed to the TH1::Draw() method. Roo1DTable* table(const RooAbsCategory& cat, const char* cuts = """", const char* opts = """") const; Create and fill a 1-dimensional table for given category column; This functions is the equivalent of plotOn() for category dimensions. The optional cut string expression can be used to select the events to be tabulated; The cut specification may refer to any variable contained in the data set. The option string is cu",MatchSource.WIKI,root/html602/RooAbsData.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsData.html
https://root.cern/root/html602/RooAbsData.html:36287,Modifiability,variab,variable,36287,"ber of data points with asymCat=+1 and asymCat=-1; as function of the frames variable. The asymmetry category 'asymCat' must; have exactly 2 (or 3) states defined with index values +1,-1 (and 0). The plot range and the number of plot bins is determined by the parameters; of the plot variable of the frame (RooAbsReal::setPlotRange(), RooAbsReal::setPlotBins()). The optional cut string expression can be used to select the events to be plotted.; The cut specification may refer to any variable contained in the data set. The drawOptions are passed to the TH1::Draw() method. RooPlot* plotEffOn(RooPlot* frame, const RooAbsCategoryLValue& effCat, RooAbsData::PlotOpt o) const; Create and fill a histogram with the effiency N[1] / ( N[1] + N[0] ),; where N(1/0) is the number of data points with effCat=1 and effCat=0; as function of the frames variable. The efficiency category 'effCat' must; have exactly 2 +1 and 0. The plot range and the number of plot bins is determined by the parameters; of the plot variable of the frame (RooAbsReal::setPlotRange(), RooAbsReal::setPlotBins()). The optional cut string expression can be used to select the events to be plotted.; The cut specification may refer to any variable contained in the data set. The drawOptions are passed to the TH1::Draw() method. Roo1DTable* table(const RooAbsCategory& cat, const char* cuts = """", const char* opts = """") const; Create and fill a 1-dimensional table for given category column; This functions is the equivalent of plotOn() for category dimensions. The optional cut string expression can be used to select the events to be tabulated; The cut specification may refer to any variable contained in the data set. The option string is currently not used. Bool_t getRange(RooRealVar& var, Double_t& lowest, Double_t& highest, Double_t marginFrac = 0, Bool_t symMode = kFALSE) const; Fill Doubles 'lowest' and 'highest' with the lowest and highest value of; observable 'var' in this dataset. If the return value is kTRUE and e",MatchSource.WIKI,root/html602/RooAbsData.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsData.html
https://root.cern/root/html602/RooAbsData.html:36489,Modifiability,variab,variable,36489,"range and the number of plot bins is determined by the parameters; of the plot variable of the frame (RooAbsReal::setPlotRange(), RooAbsReal::setPlotBins()). The optional cut string expression can be used to select the events to be plotted.; The cut specification may refer to any variable contained in the data set. The drawOptions are passed to the TH1::Draw() method. RooPlot* plotEffOn(RooPlot* frame, const RooAbsCategoryLValue& effCat, RooAbsData::PlotOpt o) const; Create and fill a histogram with the effiency N[1] / ( N[1] + N[0] ),; where N(1/0) is the number of data points with effCat=1 and effCat=0; as function of the frames variable. The efficiency category 'effCat' must; have exactly 2 +1 and 0. The plot range and the number of plot bins is determined by the parameters; of the plot variable of the frame (RooAbsReal::setPlotRange(), RooAbsReal::setPlotBins()). The optional cut string expression can be used to select the events to be plotted.; The cut specification may refer to any variable contained in the data set. The drawOptions are passed to the TH1::Draw() method. Roo1DTable* table(const RooAbsCategory& cat, const char* cuts = """", const char* opts = """") const; Create and fill a 1-dimensional table for given category column; This functions is the equivalent of plotOn() for category dimensions. The optional cut string expression can be used to select the events to be tabulated; The cut specification may refer to any variable contained in the data set. The option string is currently not used. Bool_t getRange(RooRealVar& var, Double_t& lowest, Double_t& highest, Double_t marginFrac = 0, Bool_t symMode = kFALSE) const; Fill Doubles 'lowest' and 'highest' with the lowest and highest value of; observable 'var' in this dataset. If the return value is kTRUE and error; occurred. void optimizeReadingWithCaching(RooAbsArg& arg, const RooArgSet& cacheList, const RooArgSet& keepObsList); Prepare dataset for use with cached constant terms listed in; 'cacheList' of expr",MatchSource.WIKI,root/html602/RooAbsData.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsData.html
https://root.cern/root/html602/RooAbsData.html:36936,Modifiability,variab,variable,36936," const RooAbsCategoryLValue& effCat, RooAbsData::PlotOpt o) const; Create and fill a histogram with the effiency N[1] / ( N[1] + N[0] ),; where N(1/0) is the number of data points with effCat=1 and effCat=0; as function of the frames variable. The efficiency category 'effCat' must; have exactly 2 +1 and 0. The plot range and the number of plot bins is determined by the parameters; of the plot variable of the frame (RooAbsReal::setPlotRange(), RooAbsReal::setPlotBins()). The optional cut string expression can be used to select the events to be plotted.; The cut specification may refer to any variable contained in the data set. The drawOptions are passed to the TH1::Draw() method. Roo1DTable* table(const RooAbsCategory& cat, const char* cuts = """", const char* opts = """") const; Create and fill a 1-dimensional table for given category column; This functions is the equivalent of plotOn() for category dimensions. The optional cut string expression can be used to select the events to be tabulated; The cut specification may refer to any variable contained in the data set. The option string is currently not used. Bool_t getRange(RooRealVar& var, Double_t& lowest, Double_t& highest, Double_t marginFrac = 0, Bool_t symMode = kFALSE) const; Fill Doubles 'lowest' and 'highest' with the lowest and highest value of; observable 'var' in this dataset. If the return value is kTRUE and error; occurred. void optimizeReadingWithCaching(RooAbsArg& arg, const RooArgSet& cacheList, const RooArgSet& keepObsList); Prepare dataset for use with cached constant terms listed in; 'cacheList' of expression 'arg'. Deactivate tree branches; for any dataset observable that is either not used at all,; or is used exclusively by cached branch nodes. Bool_t allClientsCached(RooAbsArg* , const RooArgSet& ); Utility function that determines if all clients of object 'var'; appear in given list of cached nodes. void attachBuffers(const RooArgSet& extObs). void resetBuffers(). Bool_t canSplitFast() const. Roo",MatchSource.WIKI,root/html602/RooAbsData.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsData.html
https://root.cern/root/html602/RooAbsData.html:12427,Performance,cache,cachedVars,12427,"orType etype = Poisson) const; virtual Double_tweightSquared() const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const. protected:. Bool_tallClientsCached(RooAbsArg*, const RooArgSet&); virtual voidattachCache(const RooAbsArg* newOwner, const RooArgSet& cachedVars); virtual voidcacheArgs(const RooAbsArg* owner, RooArgSet& varSet, const RooArgSet* nset = 0, Bool_t skipZeroWeights = kFALSE); virtual RooAbsData*cacheClone(const RooAbsArg* newCacheOwner, const RooArgSet* newCacheVars, const char* newName = 0); Double_tcorrcov(RooRealVar& x, RooRealVar& y, const char* cutSpec, const char* cutRange, Bool_t corr) const; TMatrixDSym*corrcovMatrix(const RooArgList& vars, const char* cutSpec, const char* cutRange, Bool_t corr) const; RooRealVar*dataRealVar(const char* methodname, RooRealVar& extVar) const; virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; voidTObject::MakeZombie(); virtual voidoptimizeReadingWithCaching(RooAbsArg& arg, const RooArgSet& cacheList, const RooArgSet& keepObsList); virtual RooPlot*plotAsymOn(RooPlot* frame, const RooAbsCategoryLValue& asymCat, RooAbsData::PlotOpt o) const; virtual RooPlot*plotEffOn(RooPlot* frame, const RooAbsCategoryLValue& effCat, RooAbsData::PlotOpt o) const; virtual RooPlot*plotOn(RooPlot* frame, RooAbsData::PlotOpt o) const; virtual RooAbsData*reduceEng(const RooArgSet& varSubset, const RooFormulaVar* cutVar, const char* cutRange = 0, Int_t nStart = 0, Int_t nStop = 2000000000, Bool_t copyCache = kTRUE); virtual voidresetCache(); virtual voidsetArgStatus(const RooArgSet& set, Bool_t active). Data Members; public:. static RooAbsData::ErrorTypeAuto; static RooAbsData::ErrorTypeExpected; static RooAbsData::ErrorTypeNone; static RooAbsData::ErrorTypePoisson; static RooAbsData::ErrorTypeSumW2; static RooAbsData::StorageTypeTree; static RooAbsData::Storag",MatchSource.WIKI,root/html602/RooAbsData.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsData.html
https://root.cern/root/html602/RooAbsData.html:12585,Performance,cache,cacheClone,12585,"orType etype = Poisson) const; virtual Double_tweightSquared() const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const. protected:. Bool_tallClientsCached(RooAbsArg*, const RooArgSet&); virtual voidattachCache(const RooAbsArg* newOwner, const RooArgSet& cachedVars); virtual voidcacheArgs(const RooAbsArg* owner, RooArgSet& varSet, const RooArgSet* nset = 0, Bool_t skipZeroWeights = kFALSE); virtual RooAbsData*cacheClone(const RooAbsArg* newCacheOwner, const RooArgSet* newCacheVars, const char* newName = 0); Double_tcorrcov(RooRealVar& x, RooRealVar& y, const char* cutSpec, const char* cutRange, Bool_t corr) const; TMatrixDSym*corrcovMatrix(const RooArgList& vars, const char* cutSpec, const char* cutRange, Bool_t corr) const; RooRealVar*dataRealVar(const char* methodname, RooRealVar& extVar) const; virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; voidTObject::MakeZombie(); virtual voidoptimizeReadingWithCaching(RooAbsArg& arg, const RooArgSet& cacheList, const RooArgSet& keepObsList); virtual RooPlot*plotAsymOn(RooPlot* frame, const RooAbsCategoryLValue& asymCat, RooAbsData::PlotOpt o) const; virtual RooPlot*plotEffOn(RooPlot* frame, const RooAbsCategoryLValue& effCat, RooAbsData::PlotOpt o) const; virtual RooPlot*plotOn(RooPlot* frame, RooAbsData::PlotOpt o) const; virtual RooAbsData*reduceEng(const RooArgSet& varSubset, const RooFormulaVar* cutVar, const char* cutRange = 0, Int_t nStart = 0, Int_t nStop = 2000000000, Bool_t copyCache = kTRUE); virtual voidresetCache(); virtual voidsetArgStatus(const RooArgSet& set, Bool_t active). Data Members; public:. static RooAbsData::ErrorTypeAuto; static RooAbsData::ErrorTypeExpected; static RooAbsData::ErrorTypeNone; static RooAbsData::ErrorTypePoisson; static RooAbsData::ErrorTypeSumW2; static RooAbsData::StorageTypeTree; static RooAbsData::Storag",MatchSource.WIKI,root/html602/RooAbsData.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsData.html
https://root.cern/root/html602/RooAbsData.html:13178,Performance,cache,cacheList,13178,"orType etype = Poisson) const; virtual Double_tweightSquared() const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const. protected:. Bool_tallClientsCached(RooAbsArg*, const RooArgSet&); virtual voidattachCache(const RooAbsArg* newOwner, const RooArgSet& cachedVars); virtual voidcacheArgs(const RooAbsArg* owner, RooArgSet& varSet, const RooArgSet* nset = 0, Bool_t skipZeroWeights = kFALSE); virtual RooAbsData*cacheClone(const RooAbsArg* newCacheOwner, const RooArgSet* newCacheVars, const char* newName = 0); Double_tcorrcov(RooRealVar& x, RooRealVar& y, const char* cutSpec, const char* cutRange, Bool_t corr) const; TMatrixDSym*corrcovMatrix(const RooArgList& vars, const char* cutSpec, const char* cutRange, Bool_t corr) const; RooRealVar*dataRealVar(const char* methodname, RooRealVar& extVar) const; virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; voidTObject::MakeZombie(); virtual voidoptimizeReadingWithCaching(RooAbsArg& arg, const RooArgSet& cacheList, const RooArgSet& keepObsList); virtual RooPlot*plotAsymOn(RooPlot* frame, const RooAbsCategoryLValue& asymCat, RooAbsData::PlotOpt o) const; virtual RooPlot*plotEffOn(RooPlot* frame, const RooAbsCategoryLValue& effCat, RooAbsData::PlotOpt o) const; virtual RooPlot*plotOn(RooPlot* frame, RooAbsData::PlotOpt o) const; virtual RooAbsData*reduceEng(const RooArgSet& varSubset, const RooFormulaVar* cutVar, const char* cutRange = 0, Int_t nStart = 0, Int_t nStop = 2000000000, Bool_t copyCache = kTRUE); virtual voidresetCache(); virtual voidsetArgStatus(const RooArgSet& set, Bool_t active). Data Members; public:. static RooAbsData::ErrorTypeAuto; static RooAbsData::ErrorTypeExpected; static RooAbsData::ErrorTypeNone; static RooAbsData::ErrorTypePoisson; static RooAbsData::ErrorTypeSumW2; static RooAbsData::StorageTypeTree; static RooAbsData::Storag",MatchSource.WIKI,root/html602/RooAbsData.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsData.html
https://root.cern/root/html602/RooAbsData.html:15594,Performance,cache,cached,15594,"ooPrintable::ContentsOptionRooPrintable::kName; static TObject::EStatusBitsTObject::kNoContextMenu; static TObject::(anonymous)TObject::kNotDeleted; static TObject::EStatusBitsTObject::kObjInCanvas; static TObject::(anonymous)TObject::kOverwrite; static TObject::(anonymous)TObject::kSingleKey; static RooPrintable::StyleOptionRooPrintable::kSingleLine; static RooPrintable::StyleOptionRooPrintable::kStandard; static RooPrintable::ContentsOptionRooPrintable::kTitle; static RooPrintable::StyleOptionRooPrintable::kTreeStructure; static RooPrintable::ContentsOptionRooPrintable::kValue; static RooPrintable::StyleOptionRooPrintable::kVerbose; static TObject::(anonymous)TObject::kWriteDelete; static TObject::(anonymous)TObject::kZombie. protected:. TIterator*_cacheIter! Iterator over cached variables; RooArgSet_cachedVars! External variables cached with this data set; RooAbsDataStore*_dstoreData storage implementation; TIterator*_iterator! Iterator over dimension variables; static Int_tRooPrintable::_nameLength; map<string,RooAbsData*>_ownedComponentsOwned external components; RooArgSet_varsDimensions of this data set; static RooAbsData::StorageTypedefaultStorageType; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; void setDefaultStorageType(RooAbsData::StorageType s). void claimVars(RooAbsData* ). Bool_t releaseVars(RooAbsData* ); If return value is true variables can be deleted. RooAbsData(); Default constructor. RooAbsData(const char* name, const char* title, const RooArgSet& vars, RooAbsDataStore* store = 0); Constructor from a set of variables. Only fundamental elements of vars; (RooRealVar,RooCategory etc) are stored as part of the dataset. RooAbsData(const RooAbsData& other, const char* newname = 0); Copy constructor. ~RooAbsData(); Destructor. void convertToVectorStore(); Convert tree-based storage to vector-based storage. Bool_t changeObservableName(c",MatchSource.WIKI,root/html602/RooAbsData.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsData.html
https://root.cern/root/html602/RooAbsData.html:15653,Performance,cache,cached,15653,"ooPrintable::ContentsOptionRooPrintable::kName; static TObject::EStatusBitsTObject::kNoContextMenu; static TObject::(anonymous)TObject::kNotDeleted; static TObject::EStatusBitsTObject::kObjInCanvas; static TObject::(anonymous)TObject::kOverwrite; static TObject::(anonymous)TObject::kSingleKey; static RooPrintable::StyleOptionRooPrintable::kSingleLine; static RooPrintable::StyleOptionRooPrintable::kStandard; static RooPrintable::ContentsOptionRooPrintable::kTitle; static RooPrintable::StyleOptionRooPrintable::kTreeStructure; static RooPrintable::ContentsOptionRooPrintable::kValue; static RooPrintable::StyleOptionRooPrintable::kVerbose; static TObject::(anonymous)TObject::kWriteDelete; static TObject::(anonymous)TObject::kZombie. protected:. TIterator*_cacheIter! Iterator over cached variables; RooArgSet_cachedVars! External variables cached with this data set; RooAbsDataStore*_dstoreData storage implementation; TIterator*_iterator! Iterator over dimension variables; static Int_tRooPrintable::_nameLength; map<string,RooAbsData*>_ownedComponentsOwned external components; RooArgSet_varsDimensions of this data set; static RooAbsData::StorageTypedefaultStorageType; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; void setDefaultStorageType(RooAbsData::StorageType s). void claimVars(RooAbsData* ). Bool_t releaseVars(RooAbsData* ); If return value is true variables can be deleted. RooAbsData(); Default constructor. RooAbsData(const char* name, const char* title, const RooArgSet& vars, RooAbsDataStore* store = 0); Constructor from a set of variables. Only fundamental elements of vars; (RooRealVar,RooCategory etc) are stored as part of the dataset. RooAbsData(const RooAbsData& other, const char* newname = 0); Copy constructor. ~RooAbsData(); Destructor. void convertToVectorStore(); Convert tree-based storage to vector-based storage. Bool_t changeObservableName(c",MatchSource.WIKI,root/html602/RooAbsData.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsData.html
https://root.cern/root/html602/RooAbsData.html:16941,Performance,cache,cacheArgs,16941," TStringTNamed::fTitleobject title. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; void setDefaultStorageType(RooAbsData::StorageType s). void claimVars(RooAbsData* ). Bool_t releaseVars(RooAbsData* ); If return value is true variables can be deleted. RooAbsData(); Default constructor. RooAbsData(const char* name, const char* title, const RooArgSet& vars, RooAbsDataStore* store = 0); Constructor from a set of variables. Only fundamental elements of vars; (RooRealVar,RooCategory etc) are stored as part of the dataset. RooAbsData(const RooAbsData& other, const char* newname = 0); Copy constructor. ~RooAbsData(); Destructor. void convertToVectorStore(); Convert tree-based storage to vector-based storage. Bool_t changeObservableName(const char* from, const char* to). void fill(). Int_t numEntries() const. void reset(). const RooArgSet* get(Int_t index) const. void cacheArgs(const RooAbsArg* owner, RooArgSet& varSet, const RooArgSet* nset = 0, Bool_t skipZeroWeights = kFALSE); Internal method -- Cache given set of functions with data. void resetCache(); Internal method -- Remove cached function values. void attachCache(const RooAbsArg* newOwner, const RooArgSet& cachedVars); Internal method -- Attach dataset copied with cache contents to copied instances of functions. void setArgStatus(const RooArgSet& set, Bool_t active). void setDirtyProp(Bool_t flag); Control propagation of dirty flags from observables in dataset. RooAbsData* reduce(const RooCmdArg& arg1, const RooCmdArg& arg2 = RooCmdArg(), const RooCmdArg& arg3 = RooCmdArg(), const RooCmdArg& arg4 = RooCmdArg(), const RooCmdArg& arg5 = RooCmdArg(), const RooCmdArg& arg6 = RooCmdArg(), const RooCmdArg& arg7 = RooCmdArg(), const RooCmdArg& arg8 = RooCmdArg()); Create a reduced copy of this dataset. The caller takes ownership of the returned dataset. The following optional named arguments are accepted. SelectVars(const RooArgSet& vars) -- Only retain the listed observables in",MatchSource.WIKI,root/html602/RooAbsData.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsData.html
https://root.cern/root/html602/RooAbsData.html:17159,Performance,cache,cached,17159,"on; void setDefaultStorageType(RooAbsData::StorageType s). void claimVars(RooAbsData* ). Bool_t releaseVars(RooAbsData* ); If return value is true variables can be deleted. RooAbsData(); Default constructor. RooAbsData(const char* name, const char* title, const RooArgSet& vars, RooAbsDataStore* store = 0); Constructor from a set of variables. Only fundamental elements of vars; (RooRealVar,RooCategory etc) are stored as part of the dataset. RooAbsData(const RooAbsData& other, const char* newname = 0); Copy constructor. ~RooAbsData(); Destructor. void convertToVectorStore(); Convert tree-based storage to vector-based storage. Bool_t changeObservableName(const char* from, const char* to). void fill(). Int_t numEntries() const. void reset(). const RooArgSet* get(Int_t index) const. void cacheArgs(const RooAbsArg* owner, RooArgSet& varSet, const RooArgSet* nset = 0, Bool_t skipZeroWeights = kFALSE); Internal method -- Cache given set of functions with data. void resetCache(); Internal method -- Remove cached function values. void attachCache(const RooAbsArg* newOwner, const RooArgSet& cachedVars); Internal method -- Attach dataset copied with cache contents to copied instances of functions. void setArgStatus(const RooArgSet& set, Bool_t active). void setDirtyProp(Bool_t flag); Control propagation of dirty flags from observables in dataset. RooAbsData* reduce(const RooCmdArg& arg1, const RooCmdArg& arg2 = RooCmdArg(), const RooCmdArg& arg3 = RooCmdArg(), const RooCmdArg& arg4 = RooCmdArg(), const RooCmdArg& arg5 = RooCmdArg(), const RooCmdArg& arg6 = RooCmdArg(), const RooCmdArg& arg7 = RooCmdArg(), const RooCmdArg& arg8 = RooCmdArg()); Create a reduced copy of this dataset. The caller takes ownership of the returned dataset. The following optional named arguments are accepted. SelectVars(const RooArgSet& vars) -- Only retain the listed observables in the output dataset; Cut(const char* expression) -- Only retain event surviving the given cut expression; Cut(const RooFormu",MatchSource.WIKI,root/html602/RooAbsData.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsData.html
https://root.cern/root/html602/RooAbsData.html:17244,Performance,cache,cachedVars,17244," ); If return value is true variables can be deleted. RooAbsData(); Default constructor. RooAbsData(const char* name, const char* title, const RooArgSet& vars, RooAbsDataStore* store = 0); Constructor from a set of variables. Only fundamental elements of vars; (RooRealVar,RooCategory etc) are stored as part of the dataset. RooAbsData(const RooAbsData& other, const char* newname = 0); Copy constructor. ~RooAbsData(); Destructor. void convertToVectorStore(); Convert tree-based storage to vector-based storage. Bool_t changeObservableName(const char* from, const char* to). void fill(). Int_t numEntries() const. void reset(). const RooArgSet* get(Int_t index) const. void cacheArgs(const RooAbsArg* owner, RooArgSet& varSet, const RooArgSet* nset = 0, Bool_t skipZeroWeights = kFALSE); Internal method -- Cache given set of functions with data. void resetCache(); Internal method -- Remove cached function values. void attachCache(const RooAbsArg* newOwner, const RooArgSet& cachedVars); Internal method -- Attach dataset copied with cache contents to copied instances of functions. void setArgStatus(const RooArgSet& set, Bool_t active). void setDirtyProp(Bool_t flag); Control propagation of dirty flags from observables in dataset. RooAbsData* reduce(const RooCmdArg& arg1, const RooCmdArg& arg2 = RooCmdArg(), const RooCmdArg& arg3 = RooCmdArg(), const RooCmdArg& arg4 = RooCmdArg(), const RooCmdArg& arg5 = RooCmdArg(), const RooCmdArg& arg6 = RooCmdArg(), const RooCmdArg& arg7 = RooCmdArg(), const RooCmdArg& arg8 = RooCmdArg()); Create a reduced copy of this dataset. The caller takes ownership of the returned dataset. The following optional named arguments are accepted. SelectVars(const RooArgSet& vars) -- Only retain the listed observables in the output dataset; Cut(const char* expression) -- Only retain event surviving the given cut expression; Cut(const RooFormulaVar& expr) -- Only retain event surviving the given cut formula; CutRange(const char* name) -- Only retain events ins",MatchSource.WIKI,root/html602/RooAbsData.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsData.html
https://root.cern/root/html602/RooAbsData.html:17303,Performance,cache,cache,17303," ); If return value is true variables can be deleted. RooAbsData(); Default constructor. RooAbsData(const char* name, const char* title, const RooArgSet& vars, RooAbsDataStore* store = 0); Constructor from a set of variables. Only fundamental elements of vars; (RooRealVar,RooCategory etc) are stored as part of the dataset. RooAbsData(const RooAbsData& other, const char* newname = 0); Copy constructor. ~RooAbsData(); Destructor. void convertToVectorStore(); Convert tree-based storage to vector-based storage. Bool_t changeObservableName(const char* from, const char* to). void fill(). Int_t numEntries() const. void reset(). const RooArgSet* get(Int_t index) const. void cacheArgs(const RooAbsArg* owner, RooArgSet& varSet, const RooArgSet* nset = 0, Bool_t skipZeroWeights = kFALSE); Internal method -- Cache given set of functions with data. void resetCache(); Internal method -- Remove cached function values. void attachCache(const RooAbsArg* newOwner, const RooArgSet& cachedVars); Internal method -- Attach dataset copied with cache contents to copied instances of functions. void setArgStatus(const RooArgSet& set, Bool_t active). void setDirtyProp(Bool_t flag); Control propagation of dirty flags from observables in dataset. RooAbsData* reduce(const RooCmdArg& arg1, const RooCmdArg& arg2 = RooCmdArg(), const RooCmdArg& arg3 = RooCmdArg(), const RooCmdArg& arg4 = RooCmdArg(), const RooCmdArg& arg5 = RooCmdArg(), const RooCmdArg& arg6 = RooCmdArg(), const RooCmdArg& arg7 = RooCmdArg(), const RooCmdArg& arg8 = RooCmdArg()); Create a reduced copy of this dataset. The caller takes ownership of the returned dataset. The following optional named arguments are accepted. SelectVars(const RooArgSet& vars) -- Only retain the listed observables in the output dataset; Cut(const char* expression) -- Only retain event surviving the given cut expression; Cut(const RooFormulaVar& expr) -- Only retain event surviving the given cut formula; CutRange(const char* name) -- Only retain events ins",MatchSource.WIKI,root/html602/RooAbsData.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsData.html
https://root.cern/root/html602/RooAbsData.html:37303,Performance,optimiz,optimizeReadingWithCaching,37303,"on can be used to select the events to be plotted.; The cut specification may refer to any variable contained in the data set. The drawOptions are passed to the TH1::Draw() method. Roo1DTable* table(const RooAbsCategory& cat, const char* cuts = """", const char* opts = """") const; Create and fill a 1-dimensional table for given category column; This functions is the equivalent of plotOn() for category dimensions. The optional cut string expression can be used to select the events to be tabulated; The cut specification may refer to any variable contained in the data set. The option string is currently not used. Bool_t getRange(RooRealVar& var, Double_t& lowest, Double_t& highest, Double_t marginFrac = 0, Bool_t symMode = kFALSE) const; Fill Doubles 'lowest' and 'highest' with the lowest and highest value of; observable 'var' in this dataset. If the return value is kTRUE and error; occurred. void optimizeReadingWithCaching(RooAbsArg& arg, const RooArgSet& cacheList, const RooArgSet& keepObsList); Prepare dataset for use with cached constant terms listed in; 'cacheList' of expression 'arg'. Deactivate tree branches; for any dataset observable that is either not used at all,; or is used exclusively by cached branch nodes. Bool_t allClientsCached(RooAbsArg* , const RooArgSet& ); Utility function that determines if all clients of object 'var'; appear in given list of cached nodes. void attachBuffers(const RooArgSet& extObs). void resetBuffers(). Bool_t canSplitFast() const. RooAbsData* getSimData(const char* idxstate). void addOwnedComponent(const char* idxlabel, RooAbsData& data). void Streamer(TBuffer& ); Stream an object of class RooAbsData. void checkInit() const. void Draw(Option_t* option = """"); Forward draw command to data store. Bool_t hasFilledCache() const. const TTree* tree() const. RooAbsData* emptyClone(const char* newName = 0, const char* newTitle = 0, const RooArgSet* vars = 0, const char* wgtVarName = 0) const. RooAbsDataStore* store(); { return _dstore ; }. ",MatchSource.WIKI,root/html602/RooAbsData.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsData.html
https://root.cern/root/html602/RooAbsData.html:37363,Performance,cache,cacheList,37363,"on can be used to select the events to be plotted.; The cut specification may refer to any variable contained in the data set. The drawOptions are passed to the TH1::Draw() method. Roo1DTable* table(const RooAbsCategory& cat, const char* cuts = """", const char* opts = """") const; Create and fill a 1-dimensional table for given category column; This functions is the equivalent of plotOn() for category dimensions. The optional cut string expression can be used to select the events to be tabulated; The cut specification may refer to any variable contained in the data set. The option string is currently not used. Bool_t getRange(RooRealVar& var, Double_t& lowest, Double_t& highest, Double_t marginFrac = 0, Bool_t symMode = kFALSE) const; Fill Doubles 'lowest' and 'highest' with the lowest and highest value of; observable 'var' in this dataset. If the return value is kTRUE and error; occurred. void optimizeReadingWithCaching(RooAbsArg& arg, const RooArgSet& cacheList, const RooArgSet& keepObsList); Prepare dataset for use with cached constant terms listed in; 'cacheList' of expression 'arg'. Deactivate tree branches; for any dataset observable that is either not used at all,; or is used exclusively by cached branch nodes. Bool_t allClientsCached(RooAbsArg* , const RooArgSet& ); Utility function that determines if all clients of object 'var'; appear in given list of cached nodes. void attachBuffers(const RooArgSet& extObs). void resetBuffers(). Bool_t canSplitFast() const. RooAbsData* getSimData(const char* idxstate). void addOwnedComponent(const char* idxlabel, RooAbsData& data). void Streamer(TBuffer& ); Stream an object of class RooAbsData. void checkInit() const. void Draw(Option_t* option = """"); Forward draw command to data store. Bool_t hasFilledCache() const. const TTree* tree() const. RooAbsData* emptyClone(const char* newName = 0, const char* newTitle = 0, const RooArgSet* vars = 0, const char* wgtVarName = 0) const. RooAbsDataStore* store(); { return _dstore ; }. ",MatchSource.WIKI,root/html602/RooAbsData.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsData.html
https://root.cern/root/html602/RooAbsData.html:37434,Performance,cache,cached,37434,"on can be used to select the events to be plotted.; The cut specification may refer to any variable contained in the data set. The drawOptions are passed to the TH1::Draw() method. Roo1DTable* table(const RooAbsCategory& cat, const char* cuts = """", const char* opts = """") const; Create and fill a 1-dimensional table for given category column; This functions is the equivalent of plotOn() for category dimensions. The optional cut string expression can be used to select the events to be tabulated; The cut specification may refer to any variable contained in the data set. The option string is currently not used. Bool_t getRange(RooRealVar& var, Double_t& lowest, Double_t& highest, Double_t marginFrac = 0, Bool_t symMode = kFALSE) const; Fill Doubles 'lowest' and 'highest' with the lowest and highest value of; observable 'var' in this dataset. If the return value is kTRUE and error; occurred. void optimizeReadingWithCaching(RooAbsArg& arg, const RooArgSet& cacheList, const RooArgSet& keepObsList); Prepare dataset for use with cached constant terms listed in; 'cacheList' of expression 'arg'. Deactivate tree branches; for any dataset observable that is either not used at all,; or is used exclusively by cached branch nodes. Bool_t allClientsCached(RooAbsArg* , const RooArgSet& ); Utility function that determines if all clients of object 'var'; appear in given list of cached nodes. void attachBuffers(const RooArgSet& extObs). void resetBuffers(). Bool_t canSplitFast() const. RooAbsData* getSimData(const char* idxstate). void addOwnedComponent(const char* idxlabel, RooAbsData& data). void Streamer(TBuffer& ); Stream an object of class RooAbsData. void checkInit() const. void Draw(Option_t* option = """"); Forward draw command to data store. Bool_t hasFilledCache() const. const TTree* tree() const. RooAbsData* emptyClone(const char* newName = 0, const char* newTitle = 0, const RooArgSet* vars = 0, const char* wgtVarName = 0) const. RooAbsDataStore* store(); { return _dstore ; }. ",MatchSource.WIKI,root/html602/RooAbsData.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsData.html
https://root.cern/root/html602/RooAbsData.html:37468,Performance,cache,cacheList,37468,"on can be used to select the events to be plotted.; The cut specification may refer to any variable contained in the data set. The drawOptions are passed to the TH1::Draw() method. Roo1DTable* table(const RooAbsCategory& cat, const char* cuts = """", const char* opts = """") const; Create and fill a 1-dimensional table for given category column; This functions is the equivalent of plotOn() for category dimensions. The optional cut string expression can be used to select the events to be tabulated; The cut specification may refer to any variable contained in the data set. The option string is currently not used. Bool_t getRange(RooRealVar& var, Double_t& lowest, Double_t& highest, Double_t marginFrac = 0, Bool_t symMode = kFALSE) const; Fill Doubles 'lowest' and 'highest' with the lowest and highest value of; observable 'var' in this dataset. If the return value is kTRUE and error; occurred. void optimizeReadingWithCaching(RooAbsArg& arg, const RooArgSet& cacheList, const RooArgSet& keepObsList); Prepare dataset for use with cached constant terms listed in; 'cacheList' of expression 'arg'. Deactivate tree branches; for any dataset observable that is either not used at all,; or is used exclusively by cached branch nodes. Bool_t allClientsCached(RooAbsArg* , const RooArgSet& ); Utility function that determines if all clients of object 'var'; appear in given list of cached nodes. void attachBuffers(const RooArgSet& extObs). void resetBuffers(). Bool_t canSplitFast() const. RooAbsData* getSimData(const char* idxstate). void addOwnedComponent(const char* idxlabel, RooAbsData& data). void Streamer(TBuffer& ); Stream an object of class RooAbsData. void checkInit() const. void Draw(Option_t* option = """"); Forward draw command to data store. Bool_t hasFilledCache() const. const TTree* tree() const. RooAbsData* emptyClone(const char* newName = 0, const char* newTitle = 0, const RooArgSet* vars = 0, const char* wgtVarName = 0) const. RooAbsDataStore* store(); { return _dstore ; }. ",MatchSource.WIKI,root/html602/RooAbsData.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsData.html
https://root.cern/root/html602/RooAbsData.html:37612,Performance,cache,cached,37612,"raw() method. Roo1DTable* table(const RooAbsCategory& cat, const char* cuts = """", const char* opts = """") const; Create and fill a 1-dimensional table for given category column; This functions is the equivalent of plotOn() for category dimensions. The optional cut string expression can be used to select the events to be tabulated; The cut specification may refer to any variable contained in the data set. The option string is currently not used. Bool_t getRange(RooRealVar& var, Double_t& lowest, Double_t& highest, Double_t marginFrac = 0, Bool_t symMode = kFALSE) const; Fill Doubles 'lowest' and 'highest' with the lowest and highest value of; observable 'var' in this dataset. If the return value is kTRUE and error; occurred. void optimizeReadingWithCaching(RooAbsArg& arg, const RooArgSet& cacheList, const RooArgSet& keepObsList); Prepare dataset for use with cached constant terms listed in; 'cacheList' of expression 'arg'. Deactivate tree branches; for any dataset observable that is either not used at all,; or is used exclusively by cached branch nodes. Bool_t allClientsCached(RooAbsArg* , const RooArgSet& ); Utility function that determines if all clients of object 'var'; appear in given list of cached nodes. void attachBuffers(const RooArgSet& extObs). void resetBuffers(). Bool_t canSplitFast() const. RooAbsData* getSimData(const char* idxstate). void addOwnedComponent(const char* idxlabel, RooAbsData& data). void Streamer(TBuffer& ); Stream an object of class RooAbsData. void checkInit() const. void Draw(Option_t* option = """"); Forward draw command to data store. Bool_t hasFilledCache() const. const TTree* tree() const. RooAbsData* emptyClone(const char* newName = 0, const char* newTitle = 0, const RooArgSet* vars = 0, const char* wgtVarName = 0) const. RooAbsDataStore* store(); { return _dstore ; }. const RooAbsDataStore* store() const; { return _dstore ; }. void add(const RooArgSet& row, Double_t weight = 1, Double_t weightError = 0); Add one ore more rows of data",MatchSource.WIKI,root/html602/RooAbsData.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsData.html
https://root.cern/root/html602/RooAbsData.html:37779,Performance,cache,cached,37779,"le for given category column; This functions is the equivalent of plotOn() for category dimensions. The optional cut string expression can be used to select the events to be tabulated; The cut specification may refer to any variable contained in the data set. The option string is currently not used. Bool_t getRange(RooRealVar& var, Double_t& lowest, Double_t& highest, Double_t marginFrac = 0, Bool_t symMode = kFALSE) const; Fill Doubles 'lowest' and 'highest' with the lowest and highest value of; observable 'var' in this dataset. If the return value is kTRUE and error; occurred. void optimizeReadingWithCaching(RooAbsArg& arg, const RooArgSet& cacheList, const RooArgSet& keepObsList); Prepare dataset for use with cached constant terms listed in; 'cacheList' of expression 'arg'. Deactivate tree branches; for any dataset observable that is either not used at all,; or is used exclusively by cached branch nodes. Bool_t allClientsCached(RooAbsArg* , const RooArgSet& ); Utility function that determines if all clients of object 'var'; appear in given list of cached nodes. void attachBuffers(const RooArgSet& extObs). void resetBuffers(). Bool_t canSplitFast() const. RooAbsData* getSimData(const char* idxstate). void addOwnedComponent(const char* idxlabel, RooAbsData& data). void Streamer(TBuffer& ); Stream an object of class RooAbsData. void checkInit() const. void Draw(Option_t* option = """"); Forward draw command to data store. Bool_t hasFilledCache() const. const TTree* tree() const. RooAbsData* emptyClone(const char* newName = 0, const char* newTitle = 0, const RooArgSet* vars = 0, const char* wgtVarName = 0) const. RooAbsDataStore* store(); { return _dstore ; }. const RooAbsDataStore* store() const; { return _dstore ; }. void add(const RooArgSet& row, Double_t weight = 1, Double_t weightError = 0); Add one ore more rows of data. const RooArgSet* get() const; Load a given row of data. Double_t weight() const. Double_t weightSquared() const. Bool_t valid() const; { return ",MatchSource.WIKI,root/html602/RooAbsData.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsData.html
https://root.cern/root/html602/RooAbsData.html:40612,Performance,cache,cacheClone,40612,"cutRange = 0) const; { return moment(var,1,0,cutSpec,cutRange) ; }. Double_t sigma(RooRealVar& var, const char* cutSpec = 0, const char* cutRange = 0) const; { return sqrt(moment(var,2,cutSpec,cutRange)) ; }. Double_t skewness(RooRealVar& var, const char* cutSpec = 0, const char* cutRange = 0) const; { return standMoment(var,3,cutSpec,cutRange) ; }. Double_t kurtosis(RooRealVar& var, const char* cutSpec = 0, const char* cutRange = 0) const; { return standMoment(var,4,cutSpec,cutRange) ; }. Double_t covariance(RooRealVar& x, RooRealVar& y, const char* cutSpec = 0, const char* cutRange = 0) const; { return corrcov(x,y,cutSpec,cutRange,kFALSE) ; }. Double_t correlation(RooRealVar& x, RooRealVar& y, const char* cutSpec = 0, const char* cutRange = 0) const; { return corrcov(x,y,cutSpec,cutRange,kTRUE) ; }. TMatrixDSym* covarianceMatrix(const char* cutSpec = 0, const char* cutRange = 0) const; { return covarianceMatrix(*get(),cutSpec,cutRange) ; }. TMatrixDSym* correlationMatrix(const char* cutSpec = 0, const char* cutRange = 0) const; { return correlationMatrix(*get(),cutSpec,cutRange) ; }. TMatrixDSym* covarianceMatrix(const RooArgList& vars, const char* cutSpec = 0, const char* cutRange = 0) const; { return corrcovMatrix(vars,cutSpec,cutRange,kFALSE) ; }. TMatrixDSym* correlationMatrix(const RooArgList& vars, const char* cutSpec = 0, const char* cutRange = 0) const; { return corrcovMatrix(vars,cutSpec,cutRange,kTRUE) ; }. StorageType getDefaultStorageType(). RooAbsData* cacheClone(const RooAbsArg* newCacheOwner, const RooArgSet* newCacheVars, const char* newName = 0). RooAbsData* reduceEng(const RooArgSet& varSubset, const RooFormulaVar* cutVar, const char* cutRange = 0, Int_t nStart = 0, Int_t nStop = 2000000000, Bool_t copyCache = kTRUE). » Last changed: Tue Jun 30 14:30:05 2015 » Last generated: 2015-06-30 14:30; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html602/RooAbsData.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsData.html
https://root.cern/root/html602/RooAbsDataStore.html:582,Availability,avail,available,582,". RooAbsDataStore. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » ROOFIT; » ROOFITCORE; » RooAbsDataStore. class RooAbsDataStore: public TNamed, public RooPrintable. RooAbsDataStore is the abstract base class for data collection that; use a TTree as internal storage mechanism; . Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~RooAbsDataStore(); voidTObject::AbstractMethod(const char* method) const; virtual RooAbsArg*addColumn(RooAbsArg& var, Bool_t adjustRange = kTRUE); virtual RooArgSet*addColumns(const RooArgList& varList); virtual voidappend(RooAbsDataStore& other); virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidattachBuffers(const RooArgSet& extObs); virtual voidattachCache(const RooAbsArg* newOwner, const RooArgSet& cachedVars); virtual voidTObject::Browse(TBrowser* b); virtual voidcacheArgs(const RooAbsArg* cacheOwner, RooArgSet& varSet, const RooArgSet* nset = 0, Bool_t skipZeroWeights = kFALSE); const RooArgSet&cachedVars() const; virtual const RooAbsArg*cacheOwner(); virtual Bool_tchangeObservableName(const char* from, const char* to); virtual voidcheckInit() const; static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual RooAbsDataStore*clone(const char* newname = 0) const; virtual TObject*TNamed::Clone(const char* newname = """") const; virtual RooAbsDataStore*clone(const RooArgSet& vars, const char* newname = 0) const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual Int_tdefaultPrintContents(Option_t* opt) const; static ostream&RooPrintable::defaultPrintStream(ostream* os = 0); virtual RooPrintable::StyleOptionRooP",MatchSource.WIKI,root/html602/RooAbsDataStore.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsDataStore.html
https://root.cern/root/html602/RooAbsDataStore.html:2571,Availability,error,error,2571,"ame = 0) const; virtual TObject*TNamed::Clone(const char* newname = """") const; virtual RooAbsDataStore*clone(const RooArgSet& vars, const char* newname = 0) const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual Int_tdefaultPrintContents(Option_t* opt) const; static ostream&RooPrintable::defaultPrintStream(ostream* os = 0); virtual RooPrintable::StyleOptionRooPrintable::defaultPrintStyle(Option_t* opt) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; Bool_tdirtyProp() const; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voiddump(); virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual Int_tfill(); virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual voidforceCacheUpdate(); virtual const RooArgSet*get() const; virtual const RooArgSet*get(Int_t index) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual const char*TNamed::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual const char*TNamed::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer",MatchSource.WIKI,root/html602/RooAbsDataStore.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsDataStore.html
https://root.cern/root/html602/RooAbsDataStore.html:2655,Availability,error,error,2655,"al RooAbsDataStore*clone(const RooArgSet& vars, const char* newname = 0) const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual Int_tdefaultPrintContents(Option_t* opt) const; static ostream&RooPrintable::defaultPrintStream(ostream* os = 0); virtual RooPrintable::StyleOptionRooPrintable::defaultPrintStyle(Option_t* opt) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; Bool_tdirtyProp() const; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voiddump(); virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual Int_tfill(); virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual voidforceCacheUpdate(); virtual const RooArgSet*get() const; virtual const RooArgSet*get(Int_t index) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual const char*TNamed::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual const char*TNamed::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual Bool_thasFilledCache() const; virtual ULong_tTNamed::Hash() const;",MatchSource.WIKI,root/html602/RooAbsDataStore.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsDataStore.html
https://root.cern/root/html602/RooAbsDataStore.html:11502,Integrability,interface,interface,11502,"tructor. RooAbsDataStore(const char* name, const char* title, const RooArgSet& vars); Default constructor. RooAbsDataStore(const RooAbsDataStore& other, const char* newname = 0). RooAbsDataStore(const RooAbsDataStore& other, const RooArgSet& vars, const char* newname = 0). ~RooAbsDataStore(); Destructor. Bool_t valid() const; Return true if currently loaded coordinate is considered valid within; the current range definitions of all observables. void printName(ostream& os) const; Print name of dataset. void printTitle(ostream& os) const; Print title of dataset. void printClassName(ostream& os) const; Print class name of dataset. void printValue(ostream& os) const; Print value of the dataset, i.e. the sum of weights contained in the dataset. void printArgs(ostream& os) const; Print argument of dataset, i.e. the observable names. Int_t defaultPrintContents(Option_t* opt) const; Define default print options, for a given print style. void printMultiline(ostream& os, Int_t content, Bool_t verbose, TString indent) const; Detailed printing interface. RooAbsDataStore* clone(const char* newname = 0) const. RooAbsDataStore* clone(const RooArgSet& vars, const char* newname = 0) const. Int_t fill(); Write current row. const RooArgSet* get(Int_t index) const; Retrieve a row. const RooArgSet* get() const; { return &_vars ; }. Double_t weight() const. Double_t weightError(RooAbsData::ErrorType etype = RooAbsData::Poisson) const. void weightError(Double_t& lo, Double_t& hi, RooAbsData::ErrorType etype = RooAbsData::Poisson) const. Double_t weight(Int_t index) const. Bool_t isWeighted() const. Bool_t changeObservableName(const char* from, const char* to); Change observable name. RooAbsArg* addColumn(RooAbsArg& var, Bool_t adjustRange = kTRUE); Add one or more columns. RooArgSet* addColumns(const RooArgList& varList). RooAbsDataStore* merge(const RooArgSet& allvars, list<RooAbsDataStore*> dstoreList); Merge column-wise. void append(RooAbsDataStore& other); Add rows. Int_t numEntries()",MatchSource.WIKI,root/html602/RooAbsDataStore.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsDataStore.html
https://root.cern/root/html602/RooAbsDataStore.html:12585,Integrability,rout,routines,12585,"taStore* clone(const RooArgSet& vars, const char* newname = 0) const. Int_t fill(); Write current row. const RooArgSet* get(Int_t index) const; Retrieve a row. const RooArgSet* get() const; { return &_vars ; }. Double_t weight() const. Double_t weightError(RooAbsData::ErrorType etype = RooAbsData::Poisson) const. void weightError(Double_t& lo, Double_t& hi, RooAbsData::ErrorType etype = RooAbsData::Poisson) const. Double_t weight(Int_t index) const. Bool_t isWeighted() const. Bool_t changeObservableName(const char* from, const char* to); Change observable name. RooAbsArg* addColumn(RooAbsArg& var, Bool_t adjustRange = kTRUE); Add one or more columns. RooArgSet* addColumns(const RooArgList& varList). RooAbsDataStore* merge(const RooArgSet& allvars, list<RooAbsDataStore*> dstoreList); Merge column-wise. void append(RooAbsDataStore& other); Add rows. Int_t numEntries() const. Double_t sumEntries() const; { return 0 ; }. void reset(). void attachBuffers(const RooArgSet& extObs); Buffer redirection routines used in inside RooAbsOptTestStatistics. void resetBuffers(). void setExternalWeightArray(Double_t* , Double_t* , Double_t* , Double_t* ); {}. void Print(Option_t* options = 0) const; Printing interface (human readable). void cacheArgs(const RooAbsArg* cacheOwner, RooArgSet& varSet, const RooArgSet* nset = 0, Bool_t skipZeroWeights = kFALSE); Constant term optimizer interface. const RooAbsArg* cacheOwner(). void attachCache(const RooAbsArg* newOwner, const RooArgSet& cachedVars). void setArgStatus(const RooArgSet& set, Bool_t active). const RooArgSet& cachedVars() const; { return _cachedVars ; }. void resetCache(). void recalculateCache(const RooArgSet* , Int_t , Int_t , Int_t , Bool_t ); {}. void setDirtyProp(Bool_t flag); { _doDirtyProp = flag ; }. Bool_t dirtyProp() const; { return _doDirtyProp ; }. void checkInit() const; {}. Bool_t hasFilledCache() const; { return kFALSE ; }. const TTree* tree() const; { return 0 ; }. void dump(); {}. void loadValues(const RooAbsDa",MatchSource.WIKI,root/html602/RooAbsDataStore.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsDataStore.html
https://root.cern/root/html602/RooAbsDataStore.html:12786,Integrability,interface,interface,12786," &_vars ; }. Double_t weight() const. Double_t weightError(RooAbsData::ErrorType etype = RooAbsData::Poisson) const. void weightError(Double_t& lo, Double_t& hi, RooAbsData::ErrorType etype = RooAbsData::Poisson) const. Double_t weight(Int_t index) const. Bool_t isWeighted() const. Bool_t changeObservableName(const char* from, const char* to); Change observable name. RooAbsArg* addColumn(RooAbsArg& var, Bool_t adjustRange = kTRUE); Add one or more columns. RooArgSet* addColumns(const RooArgList& varList). RooAbsDataStore* merge(const RooArgSet& allvars, list<RooAbsDataStore*> dstoreList); Merge column-wise. void append(RooAbsDataStore& other); Add rows. Int_t numEntries() const. Double_t sumEntries() const; { return 0 ; }. void reset(). void attachBuffers(const RooArgSet& extObs); Buffer redirection routines used in inside RooAbsOptTestStatistics. void resetBuffers(). void setExternalWeightArray(Double_t* , Double_t* , Double_t* , Double_t* ); {}. void Print(Option_t* options = 0) const; Printing interface (human readable). void cacheArgs(const RooAbsArg* cacheOwner, RooArgSet& varSet, const RooArgSet* nset = 0, Bool_t skipZeroWeights = kFALSE); Constant term optimizer interface. const RooAbsArg* cacheOwner(). void attachCache(const RooAbsArg* newOwner, const RooArgSet& cachedVars). void setArgStatus(const RooArgSet& set, Bool_t active). const RooArgSet& cachedVars() const; { return _cachedVars ; }. void resetCache(). void recalculateCache(const RooArgSet* , Int_t , Int_t , Int_t , Bool_t ); {}. void setDirtyProp(Bool_t flag); { _doDirtyProp = flag ; }. Bool_t dirtyProp() const; { return _doDirtyProp ; }. void checkInit() const; {}. Bool_t hasFilledCache() const; { return kFALSE ; }. const TTree* tree() const; { return 0 ; }. void dump(); {}. void loadValues(const RooAbsDataStore* tds, const RooFormulaVar* select = 0, const char* rangeName = 0, Int_t nStart = 0, Int_t nStop = 2000000000). void forceCacheUpdate(); {}. » Last changed: Tue Jun 30 14:30:06 2015 » Last g",MatchSource.WIKI,root/html602/RooAbsDataStore.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsDataStore.html
https://root.cern/root/html602/RooAbsDataStore.html:12962,Integrability,interface,interface,12962,"oid weightError(Double_t& lo, Double_t& hi, RooAbsData::ErrorType etype = RooAbsData::Poisson) const. Double_t weight(Int_t index) const. Bool_t isWeighted() const. Bool_t changeObservableName(const char* from, const char* to); Change observable name. RooAbsArg* addColumn(RooAbsArg& var, Bool_t adjustRange = kTRUE); Add one or more columns. RooArgSet* addColumns(const RooArgList& varList). RooAbsDataStore* merge(const RooArgSet& allvars, list<RooAbsDataStore*> dstoreList); Merge column-wise. void append(RooAbsDataStore& other); Add rows. Int_t numEntries() const. Double_t sumEntries() const; { return 0 ; }. void reset(). void attachBuffers(const RooArgSet& extObs); Buffer redirection routines used in inside RooAbsOptTestStatistics. void resetBuffers(). void setExternalWeightArray(Double_t* , Double_t* , Double_t* , Double_t* ); {}. void Print(Option_t* options = 0) const; Printing interface (human readable). void cacheArgs(const RooAbsArg* cacheOwner, RooArgSet& varSet, const RooArgSet* nset = 0, Bool_t skipZeroWeights = kFALSE); Constant term optimizer interface. const RooAbsArg* cacheOwner(). void attachCache(const RooAbsArg* newOwner, const RooArgSet& cachedVars). void setArgStatus(const RooArgSet& set, Bool_t active). const RooArgSet& cachedVars() const; { return _cachedVars ; }. void resetCache(). void recalculateCache(const RooArgSet* , Int_t , Int_t , Int_t , Bool_t ); {}. void setDirtyProp(Bool_t flag); { _doDirtyProp = flag ; }. Bool_t dirtyProp() const; { return _doDirtyProp ; }. void checkInit() const; {}. Bool_t hasFilledCache() const; { return kFALSE ; }. const TTree* tree() const; { return 0 ; }. void dump(); {}. void loadValues(const RooAbsDataStore* tds, const RooFormulaVar* select = 0, const char* rangeName = 0, Int_t nStart = 0, Int_t nStop = 2000000000). void forceCacheUpdate(); {}. » Last changed: Tue Jun 30 14:30:06 2015 » Last generated: 2015-06-30 14:30; This page has been automatically generated. For comments or suggestions regarding the docum",MatchSource.WIKI,root/html602/RooAbsDataStore.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsDataStore.html
https://root.cern/root/html602/RooAbsDataStore.html:10022,Modifiability,variab,variables,10022,"::kIsReferenced; static TObject::EStatusBitsTObject::kMustCleanup; static RooPrintable::ContentsOptionRooPrintable::kName; static TObject::EStatusBitsTObject::kNoContextMenu; static TObject::(anonymous)TObject::kNotDeleted; static TObject::EStatusBitsTObject::kObjInCanvas; static TObject::(anonymous)TObject::kOverwrite; static TObject::(anonymous)TObject::kSingleKey; static RooPrintable::StyleOptionRooPrintable::kSingleLine; static RooPrintable::StyleOptionRooPrintable::kStandard; static RooPrintable::ContentsOptionRooPrintable::kTitle; static RooPrintable::StyleOptionRooPrintable::kTreeStructure; static RooPrintable::ContentsOptionRooPrintable::kValue; static RooPrintable::StyleOptionRooPrintable::kVerbose; static TObject::(anonymous)TObject::kWriteDelete; static TObject::(anonymous)TObject::kZombie. protected:. TIterator*_cacheIter! Iterator over cached variables; RooArgSet_cachedVars; Bool_t_doDirtyPropSwitch do (de)activate dirty state propagation when loading a data point; TIterator*_iterator! Iterator over dimension variables; static Int_tRooPrintable::_nameLength; RooArgSet_vars; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; RooAbsDataStore(); Default constructor. RooAbsDataStore(const char* name, const char* title, const RooArgSet& vars); Default constructor. RooAbsDataStore(const RooAbsDataStore& other, const char* newname = 0). RooAbsDataStore(const RooAbsDataStore& other, const RooArgSet& vars, const char* newname = 0). ~RooAbsDataStore(); Destructor. Bool_t valid() const; Return true if currently loaded coordinate is considered valid within; the current range definitions of all observables. void printName(ostream& os) const; Print name of dataset. void printTitle(ostream& os) const; Print title of dataset. void printClassName(ostream& os) const; Print class name of dataset. void printValue(ostream& os) const; Print value of the dataset, i",MatchSource.WIKI,root/html602/RooAbsDataStore.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsDataStore.html
https://root.cern/root/html602/RooAbsDataStore.html:10192,Modifiability,variab,variables,10192,"::kIsReferenced; static TObject::EStatusBitsTObject::kMustCleanup; static RooPrintable::ContentsOptionRooPrintable::kName; static TObject::EStatusBitsTObject::kNoContextMenu; static TObject::(anonymous)TObject::kNotDeleted; static TObject::EStatusBitsTObject::kObjInCanvas; static TObject::(anonymous)TObject::kOverwrite; static TObject::(anonymous)TObject::kSingleKey; static RooPrintable::StyleOptionRooPrintable::kSingleLine; static RooPrintable::StyleOptionRooPrintable::kStandard; static RooPrintable::ContentsOptionRooPrintable::kTitle; static RooPrintable::StyleOptionRooPrintable::kTreeStructure; static RooPrintable::ContentsOptionRooPrintable::kValue; static RooPrintable::StyleOptionRooPrintable::kVerbose; static TObject::(anonymous)TObject::kWriteDelete; static TObject::(anonymous)TObject::kZombie. protected:. TIterator*_cacheIter! Iterator over cached variables; RooArgSet_cachedVars; Bool_t_doDirtyPropSwitch do (de)activate dirty state propagation when loading a data point; TIterator*_iterator! Iterator over dimension variables; static Int_tRooPrintable::_nameLength; RooArgSet_vars; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; RooAbsDataStore(); Default constructor. RooAbsDataStore(const char* name, const char* title, const RooArgSet& vars); Default constructor. RooAbsDataStore(const RooAbsDataStore& other, const char* newname = 0). RooAbsDataStore(const RooAbsDataStore& other, const RooArgSet& vars, const char* newname = 0). ~RooAbsDataStore(); Destructor. Bool_t valid() const; Return true if currently loaded coordinate is considered valid within; the current range definitions of all observables. void printName(ostream& os) const; Print name of dataset. void printTitle(ostream& os) const; Print title of dataset. void printClassName(ostream& os) const; Print class name of dataset. void printValue(ostream& os) const; Print value of the dataset, i",MatchSource.WIKI,root/html602/RooAbsDataStore.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsDataStore.html
https://root.cern/root/html602/RooAbsDataStore.html:1047,Performance,cache,cachedVars,1047," virtual~RooAbsDataStore(); voidTObject::AbstractMethod(const char* method) const; virtual RooAbsArg*addColumn(RooAbsArg& var, Bool_t adjustRange = kTRUE); virtual RooArgSet*addColumns(const RooArgList& varList); virtual voidappend(RooAbsDataStore& other); virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidattachBuffers(const RooArgSet& extObs); virtual voidattachCache(const RooAbsArg* newOwner, const RooArgSet& cachedVars); virtual voidTObject::Browse(TBrowser* b); virtual voidcacheArgs(const RooAbsArg* cacheOwner, RooArgSet& varSet, const RooArgSet* nset = 0, Bool_t skipZeroWeights = kFALSE); const RooArgSet&cachedVars() const; virtual const RooAbsArg*cacheOwner(); virtual Bool_tchangeObservableName(const char* from, const char* to); virtual voidcheckInit() const; static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual RooAbsDataStore*clone(const char* newname = 0) const; virtual TObject*TNamed::Clone(const char* newname = """") const; virtual RooAbsDataStore*clone(const RooArgSet& vars, const char* newname = 0) const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual Int_tdefaultPrintContents(Option_t* opt) const; static ostream&RooPrintable::defaultPrintStream(ostream* os = 0); virtual RooPrintable::StyleOptionRooP",MatchSource.WIKI,root/html602/RooAbsDataStore.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsDataStore.html
https://root.cern/root/html602/RooAbsDataStore.html:1141,Performance,cache,cacheOwner,1141," virtual~RooAbsDataStore(); voidTObject::AbstractMethod(const char* method) const; virtual RooAbsArg*addColumn(RooAbsArg& var, Bool_t adjustRange = kTRUE); virtual RooArgSet*addColumns(const RooArgList& varList); virtual voidappend(RooAbsDataStore& other); virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidattachBuffers(const RooArgSet& extObs); virtual voidattachCache(const RooAbsArg* newOwner, const RooArgSet& cachedVars); virtual voidTObject::Browse(TBrowser* b); virtual voidcacheArgs(const RooAbsArg* cacheOwner, RooArgSet& varSet, const RooArgSet* nset = 0, Bool_t skipZeroWeights = kFALSE); const RooArgSet&cachedVars() const; virtual const RooAbsArg*cacheOwner(); virtual Bool_tchangeObservableName(const char* from, const char* to); virtual voidcheckInit() const; static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual RooAbsDataStore*clone(const char* newname = 0) const; virtual TObject*TNamed::Clone(const char* newname = """") const; virtual RooAbsDataStore*clone(const RooArgSet& vars, const char* newname = 0) const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual Int_tdefaultPrintContents(Option_t* opt) const; static ostream&RooPrintable::defaultPrintStream(ostream* os = 0); virtual RooPrintable::StyleOptionRooP",MatchSource.WIKI,root/html602/RooAbsDataStore.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsDataStore.html
https://root.cern/root/html602/RooAbsDataStore.html:1249,Performance,cache,cachedVars,1249," virtual~RooAbsDataStore(); voidTObject::AbstractMethod(const char* method) const; virtual RooAbsArg*addColumn(RooAbsArg& var, Bool_t adjustRange = kTRUE); virtual RooArgSet*addColumns(const RooArgList& varList); virtual voidappend(RooAbsDataStore& other); virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidattachBuffers(const RooArgSet& extObs); virtual voidattachCache(const RooAbsArg* newOwner, const RooArgSet& cachedVars); virtual voidTObject::Browse(TBrowser* b); virtual voidcacheArgs(const RooAbsArg* cacheOwner, RooArgSet& varSet, const RooArgSet* nset = 0, Bool_t skipZeroWeights = kFALSE); const RooArgSet&cachedVars() const; virtual const RooAbsArg*cacheOwner(); virtual Bool_tchangeObservableName(const char* from, const char* to); virtual voidcheckInit() const; static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual RooAbsDataStore*clone(const char* newname = 0) const; virtual TObject*TNamed::Clone(const char* newname = """") const; virtual RooAbsDataStore*clone(const RooArgSet& vars, const char* newname = 0) const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual Int_tdefaultPrintContents(Option_t* opt) const; static ostream&RooPrintable::defaultPrintStream(ostream* os = 0); virtual RooPrintable::StyleOptionRooP",MatchSource.WIKI,root/html602/RooAbsDataStore.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsDataStore.html
https://root.cern/root/html602/RooAbsDataStore.html:1293,Performance,cache,cacheOwner,1293," virtual~RooAbsDataStore(); voidTObject::AbstractMethod(const char* method) const; virtual RooAbsArg*addColumn(RooAbsArg& var, Bool_t adjustRange = kTRUE); virtual RooArgSet*addColumns(const RooArgList& varList); virtual voidappend(RooAbsDataStore& other); virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidattachBuffers(const RooArgSet& extObs); virtual voidattachCache(const RooAbsArg* newOwner, const RooArgSet& cachedVars); virtual voidTObject::Browse(TBrowser* b); virtual voidcacheArgs(const RooAbsArg* cacheOwner, RooArgSet& varSet, const RooArgSet* nset = 0, Bool_t skipZeroWeights = kFALSE); const RooArgSet&cachedVars() const; virtual const RooAbsArg*cacheOwner(); virtual Bool_tchangeObservableName(const char* from, const char* to); virtual voidcheckInit() const; static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual RooAbsDataStore*clone(const char* newname = 0) const; virtual TObject*TNamed::Clone(const char* newname = """") const; virtual RooAbsDataStore*clone(const RooArgSet& vars, const char* newname = 0) const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual Int_tdefaultPrintContents(Option_t* opt) const; static ostream&RooPrintable::defaultPrintStream(ostream* os = 0); virtual RooPrintable::StyleOptionRooP",MatchSource.WIKI,root/html602/RooAbsDataStore.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsDataStore.html
https://root.cern/root/html602/RooAbsDataStore.html:10015,Performance,cache,cached,10015,"::kIsReferenced; static TObject::EStatusBitsTObject::kMustCleanup; static RooPrintable::ContentsOptionRooPrintable::kName; static TObject::EStatusBitsTObject::kNoContextMenu; static TObject::(anonymous)TObject::kNotDeleted; static TObject::EStatusBitsTObject::kObjInCanvas; static TObject::(anonymous)TObject::kOverwrite; static TObject::(anonymous)TObject::kSingleKey; static RooPrintable::StyleOptionRooPrintable::kSingleLine; static RooPrintable::StyleOptionRooPrintable::kStandard; static RooPrintable::ContentsOptionRooPrintable::kTitle; static RooPrintable::StyleOptionRooPrintable::kTreeStructure; static RooPrintable::ContentsOptionRooPrintable::kValue; static RooPrintable::StyleOptionRooPrintable::kVerbose; static TObject::(anonymous)TObject::kWriteDelete; static TObject::(anonymous)TObject::kZombie. protected:. TIterator*_cacheIter! Iterator over cached variables; RooArgSet_cachedVars; Bool_t_doDirtyPropSwitch do (de)activate dirty state propagation when loading a data point; TIterator*_iterator! Iterator over dimension variables; static Int_tRooPrintable::_nameLength; RooArgSet_vars; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; RooAbsDataStore(); Default constructor. RooAbsDataStore(const char* name, const char* title, const RooArgSet& vars); Default constructor. RooAbsDataStore(const RooAbsDataStore& other, const char* newname = 0). RooAbsDataStore(const RooAbsDataStore& other, const RooArgSet& vars, const char* newname = 0). ~RooAbsDataStore(); Destructor. Bool_t valid() const; Return true if currently loaded coordinate is considered valid within; the current range definitions of all observables. void printName(ostream& os) const; Print name of dataset. void printTitle(ostream& os) const; Print title of dataset. void printClassName(ostream& os) const; Print class name of dataset. void printValue(ostream& os) const; Print value of the dataset, i",MatchSource.WIKI,root/html602/RooAbsDataStore.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsDataStore.html
https://root.cern/root/html602/RooAbsDataStore.html:10125,Performance,load,loading,10125,"::kIsReferenced; static TObject::EStatusBitsTObject::kMustCleanup; static RooPrintable::ContentsOptionRooPrintable::kName; static TObject::EStatusBitsTObject::kNoContextMenu; static TObject::(anonymous)TObject::kNotDeleted; static TObject::EStatusBitsTObject::kObjInCanvas; static TObject::(anonymous)TObject::kOverwrite; static TObject::(anonymous)TObject::kSingleKey; static RooPrintable::StyleOptionRooPrintable::kSingleLine; static RooPrintable::StyleOptionRooPrintable::kStandard; static RooPrintable::ContentsOptionRooPrintable::kTitle; static RooPrintable::StyleOptionRooPrintable::kTreeStructure; static RooPrintable::ContentsOptionRooPrintable::kValue; static RooPrintable::StyleOptionRooPrintable::kVerbose; static TObject::(anonymous)TObject::kWriteDelete; static TObject::(anonymous)TObject::kZombie. protected:. TIterator*_cacheIter! Iterator over cached variables; RooArgSet_cachedVars; Bool_t_doDirtyPropSwitch do (de)activate dirty state propagation when loading a data point; TIterator*_iterator! Iterator over dimension variables; static Int_tRooPrintable::_nameLength; RooArgSet_vars; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; RooAbsDataStore(); Default constructor. RooAbsDataStore(const char* name, const char* title, const RooArgSet& vars); Default constructor. RooAbsDataStore(const RooAbsDataStore& other, const char* newname = 0). RooAbsDataStore(const RooAbsDataStore& other, const RooArgSet& vars, const char* newname = 0). ~RooAbsDataStore(); Destructor. Bool_t valid() const; Return true if currently loaded coordinate is considered valid within; the current range definitions of all observables. void printName(ostream& os) const; Print name of dataset. void printTitle(ostream& os) const; Print title of dataset. void printClassName(ostream& os) const; Print class name of dataset. void printValue(ostream& os) const; Print value of the dataset, i",MatchSource.WIKI,root/html602/RooAbsDataStore.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsDataStore.html
https://root.cern/root/html602/RooAbsDataStore.html:10807,Performance,load,loaded,10807,"table::StyleOptionRooPrintable::kVerbose; static TObject::(anonymous)TObject::kWriteDelete; static TObject::(anonymous)TObject::kZombie. protected:. TIterator*_cacheIter! Iterator over cached variables; RooArgSet_cachedVars; Bool_t_doDirtyPropSwitch do (de)activate dirty state propagation when loading a data point; TIterator*_iterator! Iterator over dimension variables; static Int_tRooPrintable::_nameLength; RooArgSet_vars; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; RooAbsDataStore(); Default constructor. RooAbsDataStore(const char* name, const char* title, const RooArgSet& vars); Default constructor. RooAbsDataStore(const RooAbsDataStore& other, const char* newname = 0). RooAbsDataStore(const RooAbsDataStore& other, const RooArgSet& vars, const char* newname = 0). ~RooAbsDataStore(); Destructor. Bool_t valid() const; Return true if currently loaded coordinate is considered valid within; the current range definitions of all observables. void printName(ostream& os) const; Print name of dataset. void printTitle(ostream& os) const; Print title of dataset. void printClassName(ostream& os) const; Print class name of dataset. void printValue(ostream& os) const; Print value of the dataset, i.e. the sum of weights contained in the dataset. void printArgs(ostream& os) const; Print argument of dataset, i.e. the observable names. Int_t defaultPrintContents(Option_t* opt) const; Define default print options, for a given print style. void printMultiline(ostream& os, Int_t content, Bool_t verbose, TString indent) const; Detailed printing interface. RooAbsDataStore* clone(const char* newname = 0) const. RooAbsDataStore* clone(const RooArgSet& vars, const char* newname = 0) const. Int_t fill(); Write current row. const RooArgSet* get(Int_t index) const; Retrieve a row. const RooArgSet* get() const; { return &_vars ; }. Double_t weight() const. Double_t weightErro",MatchSource.WIKI,root/html602/RooAbsDataStore.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsDataStore.html
https://root.cern/root/html602/RooAbsDataStore.html:12819,Performance,cache,cacheArgs,12819,"oid weightError(Double_t& lo, Double_t& hi, RooAbsData::ErrorType etype = RooAbsData::Poisson) const. Double_t weight(Int_t index) const. Bool_t isWeighted() const. Bool_t changeObservableName(const char* from, const char* to); Change observable name. RooAbsArg* addColumn(RooAbsArg& var, Bool_t adjustRange = kTRUE); Add one or more columns. RooArgSet* addColumns(const RooArgList& varList). RooAbsDataStore* merge(const RooArgSet& allvars, list<RooAbsDataStore*> dstoreList); Merge column-wise. void append(RooAbsDataStore& other); Add rows. Int_t numEntries() const. Double_t sumEntries() const; { return 0 ; }. void reset(). void attachBuffers(const RooArgSet& extObs); Buffer redirection routines used in inside RooAbsOptTestStatistics. void resetBuffers(). void setExternalWeightArray(Double_t* , Double_t* , Double_t* , Double_t* ); {}. void Print(Option_t* options = 0) const; Printing interface (human readable). void cacheArgs(const RooAbsArg* cacheOwner, RooArgSet& varSet, const RooArgSet* nset = 0, Bool_t skipZeroWeights = kFALSE); Constant term optimizer interface. const RooAbsArg* cacheOwner(). void attachCache(const RooAbsArg* newOwner, const RooArgSet& cachedVars). void setArgStatus(const RooArgSet& set, Bool_t active). const RooArgSet& cachedVars() const; { return _cachedVars ; }. void resetCache(). void recalculateCache(const RooArgSet* , Int_t , Int_t , Int_t , Bool_t ); {}. void setDirtyProp(Bool_t flag); { _doDirtyProp = flag ; }. Bool_t dirtyProp() const; { return _doDirtyProp ; }. void checkInit() const; {}. Bool_t hasFilledCache() const; { return kFALSE ; }. const TTree* tree() const; { return 0 ; }. void dump(); {}. void loadValues(const RooAbsDataStore* tds, const RooFormulaVar* select = 0, const char* rangeName = 0, Int_t nStart = 0, Int_t nStop = 2000000000). void forceCacheUpdate(); {}. » Last changed: Tue Jun 30 14:30:06 2015 » Last generated: 2015-06-30 14:30; This page has been automatically generated. For comments or suggestions regarding the docum",MatchSource.WIKI,root/html602/RooAbsDataStore.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsDataStore.html
https://root.cern/root/html602/RooAbsDataStore.html:12846,Performance,cache,cacheOwner,12846,"oid weightError(Double_t& lo, Double_t& hi, RooAbsData::ErrorType etype = RooAbsData::Poisson) const. Double_t weight(Int_t index) const. Bool_t isWeighted() const. Bool_t changeObservableName(const char* from, const char* to); Change observable name. RooAbsArg* addColumn(RooAbsArg& var, Bool_t adjustRange = kTRUE); Add one or more columns. RooArgSet* addColumns(const RooArgList& varList). RooAbsDataStore* merge(const RooArgSet& allvars, list<RooAbsDataStore*> dstoreList); Merge column-wise. void append(RooAbsDataStore& other); Add rows. Int_t numEntries() const. Double_t sumEntries() const; { return 0 ; }. void reset(). void attachBuffers(const RooArgSet& extObs); Buffer redirection routines used in inside RooAbsOptTestStatistics. void resetBuffers(). void setExternalWeightArray(Double_t* , Double_t* , Double_t* , Double_t* ); {}. void Print(Option_t* options = 0) const; Printing interface (human readable). void cacheArgs(const RooAbsArg* cacheOwner, RooArgSet& varSet, const RooArgSet* nset = 0, Bool_t skipZeroWeights = kFALSE); Constant term optimizer interface. const RooAbsArg* cacheOwner(). void attachCache(const RooAbsArg* newOwner, const RooArgSet& cachedVars). void setArgStatus(const RooArgSet& set, Bool_t active). const RooArgSet& cachedVars() const; { return _cachedVars ; }. void resetCache(). void recalculateCache(const RooArgSet* , Int_t , Int_t , Int_t , Bool_t ); {}. void setDirtyProp(Bool_t flag); { _doDirtyProp = flag ; }. Bool_t dirtyProp() const; { return _doDirtyProp ; }. void checkInit() const; {}. Bool_t hasFilledCache() const; { return kFALSE ; }. const TTree* tree() const; { return 0 ; }. void dump(); {}. void loadValues(const RooAbsDataStore* tds, const RooFormulaVar* select = 0, const char* rangeName = 0, Int_t nStart = 0, Int_t nStop = 2000000000). void forceCacheUpdate(); {}. » Last changed: Tue Jun 30 14:30:06 2015 » Last generated: 2015-06-30 14:30; This page has been automatically generated. For comments or suggestions regarding the docum",MatchSource.WIKI,root/html602/RooAbsDataStore.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsDataStore.html
https://root.cern/root/html602/RooAbsDataStore.html:12952,Performance,optimiz,optimizer,12952,"oid weightError(Double_t& lo, Double_t& hi, RooAbsData::ErrorType etype = RooAbsData::Poisson) const. Double_t weight(Int_t index) const. Bool_t isWeighted() const. Bool_t changeObservableName(const char* from, const char* to); Change observable name. RooAbsArg* addColumn(RooAbsArg& var, Bool_t adjustRange = kTRUE); Add one or more columns. RooArgSet* addColumns(const RooArgList& varList). RooAbsDataStore* merge(const RooArgSet& allvars, list<RooAbsDataStore*> dstoreList); Merge column-wise. void append(RooAbsDataStore& other); Add rows. Int_t numEntries() const. Double_t sumEntries() const; { return 0 ; }. void reset(). void attachBuffers(const RooArgSet& extObs); Buffer redirection routines used in inside RooAbsOptTestStatistics. void resetBuffers(). void setExternalWeightArray(Double_t* , Double_t* , Double_t* , Double_t* ); {}. void Print(Option_t* options = 0) const; Printing interface (human readable). void cacheArgs(const RooAbsArg* cacheOwner, RooArgSet& varSet, const RooArgSet* nset = 0, Bool_t skipZeroWeights = kFALSE); Constant term optimizer interface. const RooAbsArg* cacheOwner(). void attachCache(const RooAbsArg* newOwner, const RooArgSet& cachedVars). void setArgStatus(const RooArgSet& set, Bool_t active). const RooArgSet& cachedVars() const; { return _cachedVars ; }. void resetCache(). void recalculateCache(const RooArgSet* , Int_t , Int_t , Int_t , Bool_t ); {}. void setDirtyProp(Bool_t flag); { _doDirtyProp = flag ; }. Bool_t dirtyProp() const; { return _doDirtyProp ; }. void checkInit() const; {}. Bool_t hasFilledCache() const; { return kFALSE ; }. const TTree* tree() const; { return 0 ; }. void dump(); {}. void loadValues(const RooAbsDataStore* tds, const RooFormulaVar* select = 0, const char* rangeName = 0, Int_t nStart = 0, Int_t nStop = 2000000000). void forceCacheUpdate(); {}. » Last changed: Tue Jun 30 14:30:06 2015 » Last generated: 2015-06-30 14:30; This page has been automatically generated. For comments or suggestions regarding the docum",MatchSource.WIKI,root/html602/RooAbsDataStore.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsDataStore.html
https://root.cern/root/html602/RooAbsDataStore.html:12990,Performance,cache,cacheOwner,12990," etype = RooAbsData::Poisson) const. Double_t weight(Int_t index) const. Bool_t isWeighted() const. Bool_t changeObservableName(const char* from, const char* to); Change observable name. RooAbsArg* addColumn(RooAbsArg& var, Bool_t adjustRange = kTRUE); Add one or more columns. RooArgSet* addColumns(const RooArgList& varList). RooAbsDataStore* merge(const RooArgSet& allvars, list<RooAbsDataStore*> dstoreList); Merge column-wise. void append(RooAbsDataStore& other); Add rows. Int_t numEntries() const. Double_t sumEntries() const; { return 0 ; }. void reset(). void attachBuffers(const RooArgSet& extObs); Buffer redirection routines used in inside RooAbsOptTestStatistics. void resetBuffers(). void setExternalWeightArray(Double_t* , Double_t* , Double_t* , Double_t* ); {}. void Print(Option_t* options = 0) const; Printing interface (human readable). void cacheArgs(const RooAbsArg* cacheOwner, RooArgSet& varSet, const RooArgSet* nset = 0, Bool_t skipZeroWeights = kFALSE); Constant term optimizer interface. const RooAbsArg* cacheOwner(). void attachCache(const RooAbsArg* newOwner, const RooArgSet& cachedVars). void setArgStatus(const RooArgSet& set, Bool_t active). const RooArgSet& cachedVars() const; { return _cachedVars ; }. void resetCache(). void recalculateCache(const RooArgSet* , Int_t , Int_t , Int_t , Bool_t ); {}. void setDirtyProp(Bool_t flag); { _doDirtyProp = flag ; }. Bool_t dirtyProp() const; { return _doDirtyProp ; }. void checkInit() const; {}. Bool_t hasFilledCache() const; { return kFALSE ; }. const TTree* tree() const; { return 0 ; }. void dump(); {}. void loadValues(const RooAbsDataStore* tds, const RooFormulaVar* select = 0, const char* rangeName = 0, Int_t nStart = 0, Int_t nStop = 2000000000). void forceCacheUpdate(); {}. » Last changed: Tue Jun 30 14:30:06 2015 » Last generated: 2015-06-30 14:30; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html602/RooAbsDataStore.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsDataStore.html
https://root.cern/root/html602/RooAbsDataStore.html:13065,Performance,cache,cachedVars,13065," etype = RooAbsData::Poisson) const. Double_t weight(Int_t index) const. Bool_t isWeighted() const. Bool_t changeObservableName(const char* from, const char* to); Change observable name. RooAbsArg* addColumn(RooAbsArg& var, Bool_t adjustRange = kTRUE); Add one or more columns. RooArgSet* addColumns(const RooArgList& varList). RooAbsDataStore* merge(const RooArgSet& allvars, list<RooAbsDataStore*> dstoreList); Merge column-wise. void append(RooAbsDataStore& other); Add rows. Int_t numEntries() const. Double_t sumEntries() const; { return 0 ; }. void reset(). void attachBuffers(const RooArgSet& extObs); Buffer redirection routines used in inside RooAbsOptTestStatistics. void resetBuffers(). void setExternalWeightArray(Double_t* , Double_t* , Double_t* , Double_t* ); {}. void Print(Option_t* options = 0) const; Printing interface (human readable). void cacheArgs(const RooAbsArg* cacheOwner, RooArgSet& varSet, const RooArgSet* nset = 0, Bool_t skipZeroWeights = kFALSE); Constant term optimizer interface. const RooAbsArg* cacheOwner(). void attachCache(const RooAbsArg* newOwner, const RooArgSet& cachedVars). void setArgStatus(const RooArgSet& set, Bool_t active). const RooArgSet& cachedVars() const; { return _cachedVars ; }. void resetCache(). void recalculateCache(const RooArgSet* , Int_t , Int_t , Int_t , Bool_t ); {}. void setDirtyProp(Bool_t flag); { _doDirtyProp = flag ; }. Bool_t dirtyProp() const; { return _doDirtyProp ; }. void checkInit() const; {}. Bool_t hasFilledCache() const; { return kFALSE ; }. const TTree* tree() const; { return 0 ; }. void dump(); {}. void loadValues(const RooAbsDataStore* tds, const RooFormulaVar* select = 0, const char* rangeName = 0, Int_t nStart = 0, Int_t nStop = 2000000000). void forceCacheUpdate(); {}. » Last changed: Tue Jun 30 14:30:06 2015 » Last generated: 2015-06-30 14:30; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html602/RooAbsDataStore.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsDataStore.html
https://root.cern/root/html602/RooAbsDataStore.html:13151,Performance,cache,cachedVars,13151," etype = RooAbsData::Poisson) const. Double_t weight(Int_t index) const. Bool_t isWeighted() const. Bool_t changeObservableName(const char* from, const char* to); Change observable name. RooAbsArg* addColumn(RooAbsArg& var, Bool_t adjustRange = kTRUE); Add one or more columns. RooArgSet* addColumns(const RooArgList& varList). RooAbsDataStore* merge(const RooArgSet& allvars, list<RooAbsDataStore*> dstoreList); Merge column-wise. void append(RooAbsDataStore& other); Add rows. Int_t numEntries() const. Double_t sumEntries() const; { return 0 ; }. void reset(). void attachBuffers(const RooArgSet& extObs); Buffer redirection routines used in inside RooAbsOptTestStatistics. void resetBuffers(). void setExternalWeightArray(Double_t* , Double_t* , Double_t* , Double_t* ); {}. void Print(Option_t* options = 0) const; Printing interface (human readable). void cacheArgs(const RooAbsArg* cacheOwner, RooArgSet& varSet, const RooArgSet* nset = 0, Bool_t skipZeroWeights = kFALSE); Constant term optimizer interface. const RooAbsArg* cacheOwner(). void attachCache(const RooAbsArg* newOwner, const RooArgSet& cachedVars). void setArgStatus(const RooArgSet& set, Bool_t active). const RooArgSet& cachedVars() const; { return _cachedVars ; }. void resetCache(). void recalculateCache(const RooArgSet* , Int_t , Int_t , Int_t , Bool_t ); {}. void setDirtyProp(Bool_t flag); { _doDirtyProp = flag ; }. Bool_t dirtyProp() const; { return _doDirtyProp ; }. void checkInit() const; {}. Bool_t hasFilledCache() const; { return kFALSE ; }. const TTree* tree() const; { return 0 ; }. void dump(); {}. void loadValues(const RooAbsDataStore* tds, const RooFormulaVar* select = 0, const char* rangeName = 0, Int_t nStart = 0, Int_t nStop = 2000000000). void forceCacheUpdate(); {}. » Last changed: Tue Jun 30 14:30:06 2015 » Last generated: 2015-06-30 14:30; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html602/RooAbsDataStore.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsDataStore.html
https://root.cern/root/html602/RooAbsDataStore.html:13552,Performance,load,loadValues,13552," etype = RooAbsData::Poisson) const. Double_t weight(Int_t index) const. Bool_t isWeighted() const. Bool_t changeObservableName(const char* from, const char* to); Change observable name. RooAbsArg* addColumn(RooAbsArg& var, Bool_t adjustRange = kTRUE); Add one or more columns. RooArgSet* addColumns(const RooArgList& varList). RooAbsDataStore* merge(const RooArgSet& allvars, list<RooAbsDataStore*> dstoreList); Merge column-wise. void append(RooAbsDataStore& other); Add rows. Int_t numEntries() const. Double_t sumEntries() const; { return 0 ; }. void reset(). void attachBuffers(const RooArgSet& extObs); Buffer redirection routines used in inside RooAbsOptTestStatistics. void resetBuffers(). void setExternalWeightArray(Double_t* , Double_t* , Double_t* , Double_t* ); {}. void Print(Option_t* options = 0) const; Printing interface (human readable). void cacheArgs(const RooAbsArg* cacheOwner, RooArgSet& varSet, const RooArgSet* nset = 0, Bool_t skipZeroWeights = kFALSE); Constant term optimizer interface. const RooAbsArg* cacheOwner(). void attachCache(const RooAbsArg* newOwner, const RooArgSet& cachedVars). void setArgStatus(const RooArgSet& set, Bool_t active). const RooArgSet& cachedVars() const; { return _cachedVars ; }. void resetCache(). void recalculateCache(const RooArgSet* , Int_t , Int_t , Int_t , Bool_t ); {}. void setDirtyProp(Bool_t flag); { _doDirtyProp = flag ; }. Bool_t dirtyProp() const; { return _doDirtyProp ; }. void checkInit() const; {}. Bool_t hasFilledCache() const; { return kFALSE ; }. const TTree* tree() const; { return 0 ; }. void dump(); {}. void loadValues(const RooAbsDataStore* tds, const RooFormulaVar* select = 0, const char* rangeName = 0, Int_t nStart = 0, Int_t nStop = 2000000000). void forceCacheUpdate(); {}. » Last changed: Tue Jun 30 14:30:06 2015 » Last generated: 2015-06-30 14:30; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html602/RooAbsDataStore.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsDataStore.html
https://root.cern/root/html602/RooAbsFunc.html:856,Availability,avail,available,856,". RooAbsFunc. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » ROOFIT; » ROOFITCORE; » RooAbsFunc. class RooAbsFunc. Abstract interface for evaluating a real-valued function of one real variable; and performing numerical algorithms on it. The purpose of this interface is; to decouple RooAbsArg-specific implementations from numerical algorithms that; only need a simple function evaluation interface. The domain of the function; is assumed to be an n-dimensional box with edge coordinates specified by the; the getMinLimit() and getMaxLimit() methods.; . Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~RooAbsFunc(); virtual list<Double_t>*binBoundaries(Int_t) const; static TClass*Class(); UInt_tgetDimension() const; virtual Double_tgetMaxLimit(UInt_t dimension) const; virtual Double_tgetMinLimit(UInt_t dimension) const; virtual const char*getName() const; virtual TClass*IsA() const; Bool_tisValid() const; Int_tnumCall() const; virtual Double_toperator()(const Double_t[] xvector) const; RooAbsFunc&operator=(const RooAbsFunc&); virtual list<Double_t>*plotSamplingHint(RooAbsRealLValue&, Double_t, Double_t) const; voidresetNumCall() const; virtual voidrestoreXVec() const; RooAbsFunc(UInt_t dimension); RooAbsFunc(const RooAbsFunc& other); virtual voidsaveXVec() const; virtual voidShowMembers(TMemberInspector& insp) const; virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b). Data Members; protected:. UInt_t_dimensionNumber of observables; Int_t_ncallFunction call counter; Bool_t_validIs binding in valid state?. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; inline RooAbsFunc(UInt_t dimension); { }. inline Roo",MatchSource.WIKI,root/html602/RooAbsFunc.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsFunc.html
https://root.cern/root/html602/RooAbsFunc.html:292,Integrability,interface,interface,292,". RooAbsFunc. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » ROOFIT; » ROOFITCORE; » RooAbsFunc. class RooAbsFunc. Abstract interface for evaluating a real-valued function of one real variable; and performing numerical algorithms on it. The purpose of this interface is; to decouple RooAbsArg-specific implementations from numerical algorithms that; only need a simple function evaluation interface. The domain of the function; is assumed to be an n-dimensional box with edge coordinates specified by the; the getMinLimit() and getMaxLimit() methods.; . Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~RooAbsFunc(); virtual list<Double_t>*binBoundaries(Int_t) const; static TClass*Class(); UInt_tgetDimension() const; virtual Double_tgetMaxLimit(UInt_t dimension) const; virtual Double_tgetMinLimit(UInt_t dimension) const; virtual const char*getName() const; virtual TClass*IsA() const; Bool_tisValid() const; Int_tnumCall() const; virtual Double_toperator()(const Double_t[] xvector) const; RooAbsFunc&operator=(const RooAbsFunc&); virtual list<Double_t>*plotSamplingHint(RooAbsRealLValue&, Double_t, Double_t) const; voidresetNumCall() const; virtual voidrestoreXVec() const; RooAbsFunc(UInt_t dimension); RooAbsFunc(const RooAbsFunc& other); virtual voidsaveXVec() const; virtual voidShowMembers(TMemberInspector& insp) const; virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b). Data Members; protected:. UInt_t_dimensionNumber of observables; Int_t_ncallFunction call counter; Bool_t_validIs binding in valid state?. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; inline RooAbsFunc(UInt_t dimension); { }. inline Roo",MatchSource.WIKI,root/html602/RooAbsFunc.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsFunc.html
https://root.cern/root/html602/RooAbsFunc.html:425,Integrability,interface,interface,425,". RooAbsFunc. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » ROOFIT; » ROOFITCORE; » RooAbsFunc. class RooAbsFunc. Abstract interface for evaluating a real-valued function of one real variable; and performing numerical algorithms on it. The purpose of this interface is; to decouple RooAbsArg-specific implementations from numerical algorithms that; only need a simple function evaluation interface. The domain of the function; is assumed to be an n-dimensional box with edge coordinates specified by the; the getMinLimit() and getMaxLimit() methods.; . Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~RooAbsFunc(); virtual list<Double_t>*binBoundaries(Int_t) const; static TClass*Class(); UInt_tgetDimension() const; virtual Double_tgetMaxLimit(UInt_t dimension) const; virtual Double_tgetMinLimit(UInt_t dimension) const; virtual const char*getName() const; virtual TClass*IsA() const; Bool_tisValid() const; Int_tnumCall() const; virtual Double_toperator()(const Double_t[] xvector) const; RooAbsFunc&operator=(const RooAbsFunc&); virtual list<Double_t>*plotSamplingHint(RooAbsRealLValue&, Double_t, Double_t) const; voidresetNumCall() const; virtual voidrestoreXVec() const; RooAbsFunc(UInt_t dimension); RooAbsFunc(const RooAbsFunc& other); virtual voidsaveXVec() const; virtual voidShowMembers(TMemberInspector& insp) const; virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b). Data Members; protected:. UInt_t_dimensionNumber of observables; Int_t_ncallFunction call counter; Bool_t_validIs binding in valid state?. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; inline RooAbsFunc(UInt_t dimension); { }. inline Roo",MatchSource.WIKI,root/html602/RooAbsFunc.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsFunc.html
https://root.cern/root/html602/RooAbsFunc.html:557,Integrability,interface,interface,557,". RooAbsFunc. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » ROOFIT; » ROOFITCORE; » RooAbsFunc. class RooAbsFunc. Abstract interface for evaluating a real-valued function of one real variable; and performing numerical algorithms on it. The purpose of this interface is; to decouple RooAbsArg-specific implementations from numerical algorithms that; only need a simple function evaluation interface. The domain of the function; is assumed to be an n-dimensional box with edge coordinates specified by the; the getMinLimit() and getMaxLimit() methods.; . Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~RooAbsFunc(); virtual list<Double_t>*binBoundaries(Int_t) const; static TClass*Class(); UInt_tgetDimension() const; virtual Double_tgetMaxLimit(UInt_t dimension) const; virtual Double_tgetMinLimit(UInt_t dimension) const; virtual const char*getName() const; virtual TClass*IsA() const; Bool_tisValid() const; Int_tnumCall() const; virtual Double_toperator()(const Double_t[] xvector) const; RooAbsFunc&operator=(const RooAbsFunc&); virtual list<Double_t>*plotSamplingHint(RooAbsRealLValue&, Double_t, Double_t) const; voidresetNumCall() const; virtual voidrestoreXVec() const; RooAbsFunc(UInt_t dimension); RooAbsFunc(const RooAbsFunc& other); virtual voidsaveXVec() const; virtual voidShowMembers(TMemberInspector& insp) const; virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b). Data Members; protected:. UInt_t_dimensionNumber of observables; Int_t_ncallFunction call counter; Bool_t_validIs binding in valid state?. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; inline RooAbsFunc(UInt_t dimension); { }. inline Roo",MatchSource.WIKI,root/html602/RooAbsFunc.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsFunc.html
https://root.cern/root/html602/RooAbsFunc.html:352,Modifiability,variab,variable,352,". RooAbsFunc. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » ROOFIT; » ROOFITCORE; » RooAbsFunc. class RooAbsFunc. Abstract interface for evaluating a real-valued function of one real variable; and performing numerical algorithms on it. The purpose of this interface is; to decouple RooAbsArg-specific implementations from numerical algorithms that; only need a simple function evaluation interface. The domain of the function; is assumed to be an n-dimensional box with edge coordinates specified by the; the getMinLimit() and getMaxLimit() methods.; . Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~RooAbsFunc(); virtual list<Double_t>*binBoundaries(Int_t) const; static TClass*Class(); UInt_tgetDimension() const; virtual Double_tgetMaxLimit(UInt_t dimension) const; virtual Double_tgetMinLimit(UInt_t dimension) const; virtual const char*getName() const; virtual TClass*IsA() const; Bool_tisValid() const; Int_tnumCall() const; virtual Double_toperator()(const Double_t[] xvector) const; RooAbsFunc&operator=(const RooAbsFunc&); virtual list<Double_t>*plotSamplingHint(RooAbsRealLValue&, Double_t, Double_t) const; voidresetNumCall() const; virtual voidrestoreXVec() const; RooAbsFunc(UInt_t dimension); RooAbsFunc(const RooAbsFunc& other); virtual voidsaveXVec() const; virtual voidShowMembers(TMemberInspector& insp) const; virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b). Data Members; protected:. UInt_t_dimensionNumber of observables; Int_t_ncallFunction call counter; Bool_t_validIs binding in valid state?. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; inline RooAbsFunc(UInt_t dimension); { }. inline Roo",MatchSource.WIKI,root/html602/RooAbsFunc.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsFunc.html
https://root.cern/root/html602/RooAbsFunc.html:366,Performance,perform,performing,366,". RooAbsFunc. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » ROOFIT; » ROOFITCORE; » RooAbsFunc. class RooAbsFunc. Abstract interface for evaluating a real-valued function of one real variable; and performing numerical algorithms on it. The purpose of this interface is; to decouple RooAbsArg-specific implementations from numerical algorithms that; only need a simple function evaluation interface. The domain of the function; is assumed to be an n-dimensional box with edge coordinates specified by the; the getMinLimit() and getMaxLimit() methods.; . Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~RooAbsFunc(); virtual list<Double_t>*binBoundaries(Int_t) const; static TClass*Class(); UInt_tgetDimension() const; virtual Double_tgetMaxLimit(UInt_t dimension) const; virtual Double_tgetMinLimit(UInt_t dimension) const; virtual const char*getName() const; virtual TClass*IsA() const; Bool_tisValid() const; Int_tnumCall() const; virtual Double_toperator()(const Double_t[] xvector) const; RooAbsFunc&operator=(const RooAbsFunc&); virtual list<Double_t>*plotSamplingHint(RooAbsRealLValue&, Double_t, Double_t) const; voidresetNumCall() const; virtual voidrestoreXVec() const; RooAbsFunc(UInt_t dimension); RooAbsFunc(const RooAbsFunc& other); virtual voidsaveXVec() const; virtual voidShowMembers(TMemberInspector& insp) const; virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b). Data Members; protected:. UInt_t_dimensionNumber of observables; Int_t_ncallFunction call counter; Bool_t_validIs binding in valid state?. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; inline RooAbsFunc(UInt_t dimension); { }. inline Roo",MatchSource.WIKI,root/html602/RooAbsFunc.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsFunc.html
https://root.cern/root/html602/RooAbsFunc.html:530,Usability,simpl,simple,530,". RooAbsFunc. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » ROOFIT; » ROOFITCORE; » RooAbsFunc. class RooAbsFunc. Abstract interface for evaluating a real-valued function of one real variable; and performing numerical algorithms on it. The purpose of this interface is; to decouple RooAbsArg-specific implementations from numerical algorithms that; only need a simple function evaluation interface. The domain of the function; is assumed to be an n-dimensional box with edge coordinates specified by the; the getMinLimit() and getMaxLimit() methods.; . Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~RooAbsFunc(); virtual list<Double_t>*binBoundaries(Int_t) const; static TClass*Class(); UInt_tgetDimension() const; virtual Double_tgetMaxLimit(UInt_t dimension) const; virtual Double_tgetMinLimit(UInt_t dimension) const; virtual const char*getName() const; virtual TClass*IsA() const; Bool_tisValid() const; Int_tnumCall() const; virtual Double_toperator()(const Double_t[] xvector) const; RooAbsFunc&operator=(const RooAbsFunc&); virtual list<Double_t>*plotSamplingHint(RooAbsRealLValue&, Double_t, Double_t) const; voidresetNumCall() const; virtual voidrestoreXVec() const; RooAbsFunc(UInt_t dimension); RooAbsFunc(const RooAbsFunc& other); virtual voidsaveXVec() const; virtual voidShowMembers(TMemberInspector& insp) const; virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b). Data Members; protected:. UInt_t_dimensionNumber of observables; Int_t_ncallFunction call counter; Bool_t_validIs binding in valid state?. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; inline RooAbsFunc(UInt_t dimension); { }. inline Roo",MatchSource.WIKI,root/html602/RooAbsFunc.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsFunc.html
https://root.cern/root/html602/RooAbsGenContext.html:853,Availability,avail,available,853,". RooAbsGenContext. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » ROOFIT; » ROOFITCORE; » RooAbsGenContext. class RooAbsGenContext: public TNamed, public RooPrintable. RooAbsGenContext is the abstract base class for generator contexts of ; RooAbsPdf objects. A generator context is an object that controls; the generation of events from a given p.d.f in one or more sessions.; This class defines the common interface for all such contexts and organizes; storage of common components, such as the observables definition, the ; prototype data etc..; . Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~RooAbsGenContext(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidattach(const RooArgSet& params); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual Int_tdefaultPrintContents(Option_t* opt) const; static ostream&RooPrintable::defaultPrintStream(ostream* os = 0); virtual RooPrintable::StyleOptiondefaultPrintStyle(Option_t* opt) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual ",MatchSource.WIKI,root/html602/RooAbsGenContext.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsGenContext.html
https://root.cern/root/html602/RooAbsGenContext.html:2069,Availability,error,error,2069,"rtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual Int_tdefaultPrintContents(Option_t* opt) const; static ostream&RooPrintable::defaultPrintStream(ostream* os = 0); virtual RooPrintable::StyleOptiondefaultPrintStyle(Option_t* opt) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual RooDataSet*generate(Double_t nEvents = 0, Bool_t skipInit = kFALSE, Bool_t extendedMode = kFALSE); virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual const char*TNamed::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual const char*TNamed::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTNamed",MatchSource.WIKI,root/html602/RooAbsGenContext.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsGenContext.html
https://root.cern/root/html602/RooAbsGenContext.html:2153,Availability,error,error,2153,"bject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual Int_tdefaultPrintContents(Option_t* opt) const; static ostream&RooPrintable::defaultPrintStream(ostream* os = 0); virtual RooPrintable::StyleOptiondefaultPrintStyle(Option_t* opt) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual RooDataSet*generate(Double_t nEvents = 0, Bool_t skipInit = kFALSE, Bool_t extendedMode = kFALSE); virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual const char*TNamed::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual const char*TNamed::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTNamed::Hash() const; virtual voidTObject::Info(const char* method, const char* msgfmt) co",MatchSource.WIKI,root/html602/RooAbsGenContext.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsGenContext.html
https://root.cern/root/html602/RooAbsGenContext.html:10315,Availability,avail,available,10315,"ArgSet*_theEventPointer to observable event being generated; Bool_t_verboseVerbose messaging?; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; RooAbsGenContext(const RooAbsPdf& model, const RooArgSet& vars, const RooDataSet* prototype = 0, const RooArgSet* auxProto = 0, Bool_t _verbose = kFALSE); Constructor. ~RooAbsGenContext(); Destructor. void attach(const RooArgSet& params); Interface to attach given parameters to object in this context. RooDataSet* createDataSet(const char* name, const char* title, const RooArgSet& obs); Create an empty dataset to hold the events that will be generated. RooDataSet * generate(Double_t nEvents = 0, Bool_t skipInit = kFALSE, Bool_t extendedMode = kFALSE); Generate the specified number of events with nEvents>0 and; and return a dataset containing the generated events. With nEvents<=0,; generate the number of events in the prototype dataset, if available,; or else the expected number of events, if non-zero.; If extendedMode = true generate according to a Poisson(nEvents); The returned dataset belongs to the caller. Return zero in case of an error.; Generation of individual events is delegated to a virtual generateEvent(); method. A virtual initGenerator() method is also called just before the; first call to generateEvent(). void initGenerator(const RooArgSet& theEvent); Interface function to initialize context for generation for given; set of observables. void printName(ostream& os) const; Print name of context. void printTitle(ostream& os) const; Print title of context. void printClassName(ostream& os) const; Print class name of context. void printArgs(ostream& os) const; Print arguments of context, i.e. the observables being generated in this context. void printMultiline(ostream& os, Int_t contents, Bool_t verbose = kFALSE, TString indent = """") const; Interface for multi-line printing. void setProtoDataOrder(Int_t* l",MatchSource.WIKI,root/html602/RooAbsGenContext.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsGenContext.html
https://root.cern/root/html602/RooAbsGenContext.html:10515,Availability,error,error,10515,"nherited Members; Includes; Libraries. Function documentation; RooAbsGenContext(const RooAbsPdf& model, const RooArgSet& vars, const RooDataSet* prototype = 0, const RooArgSet* auxProto = 0, Bool_t _verbose = kFALSE); Constructor. ~RooAbsGenContext(); Destructor. void attach(const RooArgSet& params); Interface to attach given parameters to object in this context. RooDataSet* createDataSet(const char* name, const char* title, const RooArgSet& obs); Create an empty dataset to hold the events that will be generated. RooDataSet * generate(Double_t nEvents = 0, Bool_t skipInit = kFALSE, Bool_t extendedMode = kFALSE); Generate the specified number of events with nEvents>0 and; and return a dataset containing the generated events. With nEvents<=0,; generate the number of events in the prototype dataset, if available,; or else the expected number of events, if non-zero.; If extendedMode = true generate according to a Poisson(nEvents); The returned dataset belongs to the caller. Return zero in case of an error.; Generation of individual events is delegated to a virtual generateEvent(); method. A virtual initGenerator() method is also called just before the; first call to generateEvent(). void initGenerator(const RooArgSet& theEvent); Interface function to initialize context for generation for given; set of observables. void printName(ostream& os) const; Print name of context. void printTitle(ostream& os) const; Print title of context. void printClassName(ostream& os) const; Print class name of context. void printArgs(ostream& os) const; Print arguments of context, i.e. the observables being generated in this context. void printMultiline(ostream& os, Int_t contents, Bool_t verbose = kFALSE, TString indent = """") const; Interface for multi-line printing. void setProtoDataOrder(Int_t* lut); Set the traversal order of prototype data to that in the lookup tables; passed as argument. The LUT must be an array of integers with the same; size as the number of entries in the prototype d",MatchSource.WIKI,root/html602/RooAbsGenContext.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsGenContext.html
https://root.cern/root/html602/RooAbsGenContext.html:576,Integrability,interface,interface,576,". RooAbsGenContext. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » ROOFIT; » ROOFITCORE; » RooAbsGenContext. class RooAbsGenContext: public TNamed, public RooPrintable. RooAbsGenContext is the abstract base class for generator contexts of ; RooAbsPdf objects. A generator context is an object that controls; the generation of events from a given p.d.f in one or more sessions.; This class defines the common interface for all such contexts and organizes; storage of common components, such as the observables definition, the ; prototype data etc..; . Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~RooAbsGenContext(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidattach(const RooArgSet& params); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual Int_tdefaultPrintContents(Option_t* opt) const; static ostream&RooPrintable::defaultPrintStream(ostream* os = 0); virtual RooPrintable::StyleOptiondefaultPrintStyle(Option_t* opt) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual ",MatchSource.WIKI,root/html602/RooAbsGenContext.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsGenContext.html
https://root.cern/root/html602/RooAbsGenContext.html:2561,Modifiability,extend,extendedMode,2561,"tyle(Option_t* opt) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual RooDataSet*generate(Double_t nEvents = 0, Bool_t skipInit = kFALSE, Bool_t extendedMode = kFALSE); virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual const char*TNamed::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual const char*TNamed::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTNamed::Hash() const; virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) const; virtual Bool_tTObject::InheritsFrom(const TClass* cl) const; virtual voidTObject::Inspect() constMENU ; voidTObject::InvertBit(UInt_t f); virtual TClass*IsA() const; virtual Bool_tTObject::IsEqual(const TObject* obj) const; virtual Bool_tTObject::IsFolder() const; Bool_tTObject::IsOnHeap() const; virtual Bool_tTNamed::IsSortable() const; B",MatchSource.WIKI,root/html602/RooAbsGenContext.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsGenContext.html
https://root.cern/root/html602/RooAbsGenContext.html:8822,Modifiability,extend,extended,8822,"::kInline; static TObject::EStatusBitsTObject::kInvalidObject; static TObject::(anonymous)TObject::kIsOnHeap; static TObject::EStatusBitsTObject::kIsReferenced; static TObject::EStatusBitsTObject::kMustCleanup; static RooPrintable::ContentsOptionRooPrintable::kName; static TObject::EStatusBitsTObject::kNoContextMenu; static TObject::(anonymous)TObject::kNotDeleted; static TObject::EStatusBitsTObject::kObjInCanvas; static TObject::(anonymous)TObject::kOverwrite; static TObject::(anonymous)TObject::kSingleKey; static RooPrintable::StyleOptionRooPrintable::kSingleLine; static RooPrintable::StyleOptionRooPrintable::kStandard; static RooPrintable::ContentsOptionRooPrintable::kTitle; static RooPrintable::StyleOptionRooPrintable::kTreeStructure; static RooPrintable::ContentsOptionRooPrintable::kValue; static RooPrintable::StyleOptionRooPrintable::kVerbose; static TObject::(anonymous)TObject::kWriteDelete; static TObject::(anonymous)TObject::kZombie. protected:. UInt_t_expectedEventsNumber of expected events from extended p.d.f; RooAbsPdf::ExtendMode_extendModeExtended mode capabilities of p.d.f.; RooDataSet*_genData! Data being generated; Bool_t_isValidIs context in valid state?; static Int_tRooPrintable::_nameLength; Int_t_nextProtoIndexNext prototype event to load according to LUT; TString_normRangeNormalization range of pdf; Int_t*_protoOrderLUT with traversal order of prototype data; RooArgSet_protoVarsPrototype observables; const RooDataSet*_prototypePointer to prototype dataset; RooArgSet*_theEventPointer to observable event being generated; Bool_t_verboseVerbose messaging?; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; RooAbsGenContext(const RooAbsPdf& model, const RooArgSet& vars, const RooDataSet* prototype = 0, const RooArgSet* auxProto = 0, Bool_t _verbose = kFALSE); Constructor. ~RooAbsGenContext(); Destructor. void attach(const RooArgSet& para",MatchSource.WIKI,root/html602/RooAbsGenContext.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsGenContext.html
https://root.cern/root/html602/RooAbsGenContext.html:10100,Modifiability,extend,extendedMode,10100," range of pdf; Int_t*_protoOrderLUT with traversal order of prototype data; RooArgSet_protoVarsPrototype observables; const RooDataSet*_prototypePointer to prototype dataset; RooArgSet*_theEventPointer to observable event being generated; Bool_t_verboseVerbose messaging?; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; RooAbsGenContext(const RooAbsPdf& model, const RooArgSet& vars, const RooDataSet* prototype = 0, const RooArgSet* auxProto = 0, Bool_t _verbose = kFALSE); Constructor. ~RooAbsGenContext(); Destructor. void attach(const RooArgSet& params); Interface to attach given parameters to object in this context. RooDataSet* createDataSet(const char* name, const char* title, const RooArgSet& obs); Create an empty dataset to hold the events that will be generated. RooDataSet * generate(Double_t nEvents = 0, Bool_t skipInit = kFALSE, Bool_t extendedMode = kFALSE); Generate the specified number of events with nEvents>0 and; and return a dataset containing the generated events. With nEvents<=0,; generate the number of events in the prototype dataset, if available,; or else the expected number of events, if non-zero.; If extendedMode = true generate according to a Poisson(nEvents); The returned dataset belongs to the caller. Return zero in case of an error.; Generation of individual events is delegated to a virtual generateEvent(); method. A virtual initGenerator() method is also called just before the; first call to generateEvent(). void initGenerator(const RooArgSet& theEvent); Interface function to initialize context for generation for given; set of observables. void printName(ostream& os) const; Print name of context. void printTitle(ostream& os) const; Print title of context. void printClassName(ostream& os) const; Print class name of context. void printArgs(ostream& os) const; Print arguments of context, i.e. the observables being generated in this",MatchSource.WIKI,root/html602/RooAbsGenContext.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsGenContext.html
https://root.cern/root/html602/RooAbsGenContext.html:10383,Modifiability,extend,extendedMode,10383,"tifier; TStringTNamed::fTitleobject title. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; RooAbsGenContext(const RooAbsPdf& model, const RooArgSet& vars, const RooDataSet* prototype = 0, const RooArgSet* auxProto = 0, Bool_t _verbose = kFALSE); Constructor. ~RooAbsGenContext(); Destructor. void attach(const RooArgSet& params); Interface to attach given parameters to object in this context. RooDataSet* createDataSet(const char* name, const char* title, const RooArgSet& obs); Create an empty dataset to hold the events that will be generated. RooDataSet * generate(Double_t nEvents = 0, Bool_t skipInit = kFALSE, Bool_t extendedMode = kFALSE); Generate the specified number of events with nEvents>0 and; and return a dataset containing the generated events. With nEvents<=0,; generate the number of events in the prototype dataset, if available,; or else the expected number of events, if non-zero.; If extendedMode = true generate according to a Poisson(nEvents); The returned dataset belongs to the caller. Return zero in case of an error.; Generation of individual events is delegated to a virtual generateEvent(); method. A virtual initGenerator() method is also called just before the; first call to generateEvent(). void initGenerator(const RooArgSet& theEvent); Interface function to initialize context for generation for given; set of observables. void printName(ostream& os) const; Print name of context. void printTitle(ostream& os) const; Print title of context. void printClassName(ostream& os) const; Print class name of context. void printArgs(ostream& os) const; Print arguments of context, i.e. the observables being generated in this context. void printMultiline(ostream& os, Int_t contents, Bool_t verbose = kFALSE, TString indent = """") const; Interface for multi-line printing. void setProtoDataOrder(Int_t* lut); Set the traversal order of prototype data to that in the lookup tables; passed as argument. The LUT must be an array of ",MatchSource.WIKI,root/html602/RooAbsGenContext.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsGenContext.html
https://root.cern/root/html602/RooAbsGenContext.html:9076,Performance,load,load,9076,"usBitsTObject::kObjInCanvas; static TObject::(anonymous)TObject::kOverwrite; static TObject::(anonymous)TObject::kSingleKey; static RooPrintable::StyleOptionRooPrintable::kSingleLine; static RooPrintable::StyleOptionRooPrintable::kStandard; static RooPrintable::ContentsOptionRooPrintable::kTitle; static RooPrintable::StyleOptionRooPrintable::kTreeStructure; static RooPrintable::ContentsOptionRooPrintable::kValue; static RooPrintable::StyleOptionRooPrintable::kVerbose; static TObject::(anonymous)TObject::kWriteDelete; static TObject::(anonymous)TObject::kZombie. protected:. UInt_t_expectedEventsNumber of expected events from extended p.d.f; RooAbsPdf::ExtendMode_extendModeExtended mode capabilities of p.d.f.; RooDataSet*_genData! Data being generated; Bool_t_isValidIs context in valid state?; static Int_tRooPrintable::_nameLength; Int_t_nextProtoIndexNext prototype event to load according to LUT; TString_normRangeNormalization range of pdf; Int_t*_protoOrderLUT with traversal order of prototype data; RooArgSet_protoVarsPrototype observables; const RooDataSet*_prototypePointer to prototype dataset; RooArgSet*_theEventPointer to observable event being generated; Bool_t_verboseVerbose messaging?; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; RooAbsGenContext(const RooAbsPdf& model, const RooArgSet& vars, const RooDataSet* prototype = 0, const RooArgSet* auxProto = 0, Bool_t _verbose = kFALSE); Constructor. ~RooAbsGenContext(); Destructor. void attach(const RooArgSet& params); Interface to attach given parameters to object in this context. RooDataSet* createDataSet(const char* name, const char* title, const RooArgSet& obs); Create an empty dataset to hold the events that will be generated. RooDataSet * generate(Double_t nEvents = 0, Bool_t skipInit = kFALSE, Bool_t extendedMode = kFALSE); Generate the specified number of events with nEvents>0 and; and ret",MatchSource.WIKI,root/html602/RooAbsGenContext.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsGenContext.html
https://root.cern/root/html602/RooAbsGenContext.html:12108,Usability,clear,clear,12108,"ethod. A virtual initGenerator() method is also called just before the; first call to generateEvent(). void initGenerator(const RooArgSet& theEvent); Interface function to initialize context for generation for given; set of observables. void printName(ostream& os) const; Print name of context. void printTitle(ostream& os) const; Print title of context. void printClassName(ostream& os) const; Print class name of context. void printArgs(ostream& os) const; Print arguments of context, i.e. the observables being generated in this context. void printMultiline(ostream& os, Int_t contents, Bool_t verbose = kFALSE, TString indent = """") const; Interface for multi-line printing. void setProtoDataOrder(Int_t* lut); Set the traversal order of prototype data to that in the lookup tables; passed as argument. The LUT must be an array of integers with the same; size as the number of entries in the prototype dataset and must contain; integer values in the range [0,Nevt-1]. void resampleData(Double_t& ratio); Rescale existing output buffer with given ratio. Int_t defaultPrintContents(Option_t* opt) const; Define default contents when printing. RooPrintable::StyleOption defaultPrintStyle(Option_t* opt) const; Define default print style. RooAbsGenContext(const RooAbsPdf& model, const RooArgSet& vars, const RooDataSet* prototype = 0, const RooArgSet* auxProto = 0, Bool_t _verbose = kFALSE). Bool_t isValid() const; If true generator context is in a valid state. void setVerbose(Bool_t verbose = kTRUE); Set/clear verbose messaging. Bool_t isVerbose() const; If true verbose messaging is active. void Print(Option_t* options = 0) const; Print context information on stdout. void setExpectedData(Bool_t ); {}. void generateEvent(RooArgSet& theEvent, Int_t remaining). » Last changed: Tue Jun 30 14:30:07 2015 » Last generated: 2015-06-30 14:30; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html602/RooAbsGenContext.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsGenContext.html
https://root.cern/root/html602/RooAbsHiddenReal.html:761,Availability,avail,available,761,". RooAbsHiddenReal. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » ROOFIT; » ROOFITCORE; » RooAbsHiddenReal. class RooAbsHiddenReal: public RooAbsReal. RooAbsHiddenReal is a base class for objects that want to hide; their return value from interactive use, e.g. for implementations; of parameter unblinding functions. This class overrides all; printing methods with versions that do not reveal the objects value; and it has a protected version of getVal(); . Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~RooAbsHiddenReal(); voidTObject::AbstractMethod(const char* method) const; Bool_tRooAbsArg::addOwnedComponents(const RooArgSet& comps); voidRooAbsArg::addParameters(RooArgSet& params, const RooArgSet* nset = 0, Bool_t stripDisconnected = kTRUE) const; voidRooAbsArg::addServer(RooAbsArg& server, Bool_t valueProp = kTRUE, Bool_t shapeProp = kFALSE); voidRooAbsArg::addServerList(RooAbsCollection& serverList, Bool_t valueProp = kTRUE, Bool_t shapeProp = kFALSE); const char*RooAbsArg::aggregateCacheUniqueSuffix() const; virtual Double_tRooAbsReal::analyticalIntegral(Int_t code, const char* rangeName = 0) const; virtual Double_tRooAbsReal::analyticalIntegralWN(Int_t code, const RooArgSet* normSet, const char* rangeName = 0) const; virtual voidTObject::AppendPad(Option_t* option = """"); TF1*RooAbsReal::asTF(const RooArgList& obs, const RooArgList& pars = RooArgList(), const RooArgSet& nset = RooArgSet()) const; voidRooAbsArg::attachDataSet(const RooAbsData& set); voidRooAbsArg::attachDataStore(const RooAbsDataStore& set); const set<string>&RooAbsArg::attributes() const; virtual list<Double_t>*RooAbsReal::binBoundaries(RooAbsRealLValue&, Double_t, Double_t) const; RooAbsFunc*RooAbsReal::b",MatchSource.WIKI,root/html602/RooAbsHiddenReal.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsHiddenReal.html
https://root.cern/root/html602/RooAbsHiddenReal.html:10335,Availability,error,error,10335,,MatchSource.WIKI,root/html602/RooAbsHiddenReal.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsHiddenReal.html
https://root.cern/root/html602/RooAbsHiddenReal.html:10419,Availability,error,error,10419,,MatchSource.WIKI,root/html602/RooAbsHiddenReal.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsHiddenReal.html
https://root.cern/root/html602/RooAbsHiddenReal.html:35424,Deployability,integrat,integration,35424,"tected:. set<string>RooAbsArg::_boolAttribBoolean attributes; set<string>RooAbsArg::_boolAttribTransient! Transient boolean attributes (not copied in ctor); Bool_tRooAbsReal::_boolValue! Transient cache for bool values from tree branches; UChar_tRooAbsReal::_byteValue! Transient cache for byte values from tree branches; static Bool_tRooAbsReal::_cacheCheckIf true, always validate contents of clean which outcome of evaluate(); deque<RooAbsCache*>RooAbsArg::_cacheListlist of caches; RooRefCountListRooAbsArg::_clientListlist of client objects; RooRefCountListRooAbsArg::_clientListShapesubset of clients that requested shape dirty flag propagation; RooRefCountListRooAbsArg::_clientListValuesubset of clients that requested value dirty flag propagation; TIterator*RooAbsArg::_clientShapeIter! Iterator over _clientListShape; TIterator*RooAbsArg::_clientValueIter! Iterator over _clientListValue; Bool_tRooAbsArg::_deleteWatch! Delete watch flag; static RooCategory*_dummyBlindState; RooExpensiveObjectCache*RooAbsArg::_eocachePointer to global cache manager for any expensive components created by this object; Bool_tRooAbsArg::_fastAllow fast access mode in getVal() and proxies; Float_tRooAbsReal::_floatValue! Transient cache for floating point values from tree branches; Bool_tRooAbsReal::_forceNumIntForce numerical integration if flag set; static Bool_tRooAbsReal::_globalSelectCompGlobal activation switch for component selection; static Bool_tRooAbsReal::_hideOffsetOffset hiding flag; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; Int_tRooAbsReal::_intValue! Transient cache for integer values from tree branches; Bool_tRooAbsArg::_isConstant! Cached isConstant status; TStringRooAbsReal::_labelPlot label for objects value; RooArgSet*RooAbsReal::_lastNSet!; Bool_tRooAbsArg::_localNoInhibitDirty! Prevent 'AlwaysDirty' mode for this node; static Int_tRooPrintable::_nameLength; TNamed*RooAbsArg::_namePtr! Do not persist. Pointer",MatchSource.WIKI,root/html602/RooAbsHiddenReal.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsHiddenReal.html
https://root.cern/root/html602/RooAbsHiddenReal.html:36962,Deployability,integrat,integrator,36962,"label for objects value; RooArgSet*RooAbsReal::_lastNSet!; Bool_tRooAbsArg::_localNoInhibitDirty! Prevent 'AlwaysDirty' mode for this node; static Int_tRooPrintable::_nameLength; TNamed*RooAbsArg::_namePtr! Do not persist. Pointer to global instance of string that matches object named; RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; Int_tRooAbsReal::_plotBinsNumber of plot bins; Double_tRooAbsReal::_plotMaxMaximum of plot range; Double_tRooAbsReal::_plotMinMinimum of plot range; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; RooRefArrayRooAbsArg::_proxyListlist of proxies; Char_tRooAbsReal::_sbyteValue! Transient cache for signed byte values from tree branches; Bool_tRooAbsReal::_selectComp! Component selection flag for RooAbsPdf::plotCompOn; RooRefCountListRooAbsArg::_serverListlist of server objects; Bool_tRooAbsArg::_shapeDirtyFlag set if value needs recalculating because input shapes modified; RooNumIntConfig*RooAbsReal::_specIntegratorConfigNumeric integrator configuration specific for this object; RooCategoryProxy_stateProxy to hiding state category; map<string,string>RooAbsArg::_stringAttribString attributes; Bool_tRooAbsReal::_treeVar!do not persist; UInt_tRooAbsReal::_uintValue! Transient cache for unsigned integer values from tree branches; TStringRooAbsReal::_unitUnit for objects value; Double_tRooAbsReal::_valueCache for current value of object; Bool_tRooAbsArg::_valueDirtyFlag set if value needs recalculating because input values modified; static Bool_tRooAbsArg::_verboseDirtyStatic flag controlling verbose messaging for dirty state changes; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; RooAbsHiddenReal(const char* name, const char* title, const char* unit = """"); Constructor. RooAbsHiddenReal(const char* name, cons",MatchSource.WIKI,root/html602/RooAbsHiddenReal.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsHiddenReal.html
https://root.cern/root/html602/RooAbsHiddenReal.html:36973,Deployability,configurat,configuration,36973,"label for objects value; RooArgSet*RooAbsReal::_lastNSet!; Bool_tRooAbsArg::_localNoInhibitDirty! Prevent 'AlwaysDirty' mode for this node; static Int_tRooPrintable::_nameLength; TNamed*RooAbsArg::_namePtr! Do not persist. Pointer to global instance of string that matches object named; RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; Int_tRooAbsReal::_plotBinsNumber of plot bins; Double_tRooAbsReal::_plotMaxMaximum of plot range; Double_tRooAbsReal::_plotMinMinimum of plot range; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; RooRefArrayRooAbsArg::_proxyListlist of proxies; Char_tRooAbsReal::_sbyteValue! Transient cache for signed byte values from tree branches; Bool_tRooAbsReal::_selectComp! Component selection flag for RooAbsPdf::plotCompOn; RooRefCountListRooAbsArg::_serverListlist of server objects; Bool_tRooAbsArg::_shapeDirtyFlag set if value needs recalculating because input shapes modified; RooNumIntConfig*RooAbsReal::_specIntegratorConfigNumeric integrator configuration specific for this object; RooCategoryProxy_stateProxy to hiding state category; map<string,string>RooAbsArg::_stringAttribString attributes; Bool_tRooAbsReal::_treeVar!do not persist; UInt_tRooAbsReal::_uintValue! Transient cache for unsigned integer values from tree branches; TStringRooAbsReal::_unitUnit for objects value; Double_tRooAbsReal::_valueCache for current value of object; Bool_tRooAbsArg::_valueDirtyFlag set if value needs recalculating because input values modified; static Bool_tRooAbsArg::_verboseDirtyStatic flag controlling verbose messaging for dirty state changes; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; RooAbsHiddenReal(const char* name, const char* title, const char* unit = """"); Constructor. RooAbsHiddenReal(const char* name, cons",MatchSource.WIKI,root/html602/RooAbsHiddenReal.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsHiddenReal.html
https://root.cern/root/html602/RooAbsHiddenReal.html:7664,Integrability,depend,dependentVars,7664,"const char* rangeName = 0) const; virtual RooAbsReal*RooAbsReal::createIntegral(const RooArgSet& iset, const RooArgSet* nset = 0, const RooNumIntConfig* cfg = 0, const char* rangeName = 0) const; RooAbsReal*RooAbsReal::createIntegral(const RooArgSet& iset, const RooCmdArg& arg1, const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()) const; RooAbsReal*RooAbsReal::createIntRI(const RooArgSet& iset, const RooArgSet& nset = RooArgSet()); const RooAbsReal*RooAbsReal::createPlotProjection(const RooArgSet& depVars, const RooArgSet& projVars) const; const RooAbsReal*RooAbsReal::createPlotProjection(const RooArgSet& depVars, const RooArgSet& projVars, RooArgSet*& cloneSet) const; const RooAbsReal*RooAbsReal::createPlotProjection(const RooArgSet& dependentVars, const RooArgSet* projectedVars, RooArgSet*& cloneSet, const char* rangeName = 0, const RooArgSet* condObs = 0) const; virtual RooAbsReal*RooAbsReal::createProfile(const RooArgSet& paramsOfInterest); RooAbsReal*RooAbsReal::createRunningIntegral(const RooArgSet& iset, const RooArgSet& nset = RooArgSet()); RooAbsReal*RooAbsReal::createRunningIntegral(const RooArgSet& iset, const RooCmdArg& arg1, const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()); RooAbsReal*RooAbsReal::createScanRI(const RooArgSet& iset, const RooArgSet& nset, Int_t numScanBins, Int_t intOrder); virtual Double_tRooAbsReal::defaultErrorLevel() const; static RooNumIntConfig*RooAbsReal::defaultIntegratorConfig(); virtual Int_tRooAbsArg::defaultPrintContents(Option_t* opt)",MatchSource.WIKI,root/html602/RooAbsHiddenReal.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsHiddenReal.html
https://root.cern/root/html602/RooAbsHiddenReal.html:8906,Integrability,depend,dependentOverlaps,8906,"l*RooAbsReal::createPlotProjection(const RooArgSet& dependentVars, const RooArgSet* projectedVars, RooArgSet*& cloneSet, const char* rangeName = 0, const RooArgSet* condObs = 0) const; virtual RooAbsReal*RooAbsReal::createProfile(const RooArgSet& paramsOfInterest); RooAbsReal*RooAbsReal::createRunningIntegral(const RooArgSet& iset, const RooArgSet& nset = RooArgSet()); RooAbsReal*RooAbsReal::createRunningIntegral(const RooArgSet& iset, const RooCmdArg& arg1, const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()); RooAbsReal*RooAbsReal::createScanRI(const RooArgSet& iset, const RooArgSet& nset, Int_t numScanBins, Int_t intOrder); virtual Double_tRooAbsReal::defaultErrorLevel() const; static RooNumIntConfig*RooAbsReal::defaultIntegratorConfig(); virtual Int_tRooAbsArg::defaultPrintContents(Option_t* opt) const; static ostream&RooPrintable::defaultPrintStream(ostream* os = 0); virtual RooPrintable::StyleOptionRooPrintable::defaultPrintStyle(Option_t* opt) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; Bool_tRooAbsArg::dependentOverlaps(const RooAbsData* dset, const RooAbsArg& testArg) const; Bool_tRooAbsArg::dependentOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; Bool_tRooAbsArg::dependsOn(const RooAbsCollection& serverList, const RooAbsArg* ignoreArg = 0, Bool_t valueOnly = kFALSE) const; Bool_tRooAbsArg::dependsOn(const RooAbsArg& server, const RooAbsArg* ignoreArg = 0, Bool_t valueOnly = kFALSE) const; Bool_tRooAbsArg::dependsOnValue(const RooAbsCollection& serverList, const RooAbsArg* ignoreArg = 0) const; Bool_tRooAbsArg::dependsOnValue(const RooAbsArg& server, const RooAbsArg* ignoreArg = 0) const; RooDerivative*RooAbsReal::derivative(RooRealVar& obs, Int_t order = 1, Double_t eps = 0.",MatchSource.WIKI,root/html602/RooAbsHiddenReal.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsHiddenReal.html
https://root.cern/root/html602/RooAbsHiddenReal.html:8998,Integrability,depend,dependentOverlaps,8998,"l*RooAbsReal::createPlotProjection(const RooArgSet& dependentVars, const RooArgSet* projectedVars, RooArgSet*& cloneSet, const char* rangeName = 0, const RooArgSet* condObs = 0) const; virtual RooAbsReal*RooAbsReal::createProfile(const RooArgSet& paramsOfInterest); RooAbsReal*RooAbsReal::createRunningIntegral(const RooArgSet& iset, const RooArgSet& nset = RooArgSet()); RooAbsReal*RooAbsReal::createRunningIntegral(const RooArgSet& iset, const RooCmdArg& arg1, const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()); RooAbsReal*RooAbsReal::createScanRI(const RooArgSet& iset, const RooArgSet& nset, Int_t numScanBins, Int_t intOrder); virtual Double_tRooAbsReal::defaultErrorLevel() const; static RooNumIntConfig*RooAbsReal::defaultIntegratorConfig(); virtual Int_tRooAbsArg::defaultPrintContents(Option_t* opt) const; static ostream&RooPrintable::defaultPrintStream(ostream* os = 0); virtual RooPrintable::StyleOptionRooPrintable::defaultPrintStyle(Option_t* opt) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; Bool_tRooAbsArg::dependentOverlaps(const RooAbsData* dset, const RooAbsArg& testArg) const; Bool_tRooAbsArg::dependentOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; Bool_tRooAbsArg::dependsOn(const RooAbsCollection& serverList, const RooAbsArg* ignoreArg = 0, Bool_t valueOnly = kFALSE) const; Bool_tRooAbsArg::dependsOn(const RooAbsArg& server, const RooAbsArg* ignoreArg = 0, Bool_t valueOnly = kFALSE) const; Bool_tRooAbsArg::dependsOnValue(const RooAbsCollection& serverList, const RooAbsArg* ignoreArg = 0) const; Bool_tRooAbsArg::dependsOnValue(const RooAbsArg& server, const RooAbsArg* ignoreArg = 0) const; RooDerivative*RooAbsReal::derivative(RooRealVar& obs, Int_t order = 1, Double_t eps = 0.",MatchSource.WIKI,root/html602/RooAbsHiddenReal.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsHiddenReal.html
https://root.cern/root/html602/RooAbsHiddenReal.html:9092,Integrability,depend,dependsOn,9092,"l*RooAbsReal::createPlotProjection(const RooArgSet& dependentVars, const RooArgSet* projectedVars, RooArgSet*& cloneSet, const char* rangeName = 0, const RooArgSet* condObs = 0) const; virtual RooAbsReal*RooAbsReal::createProfile(const RooArgSet& paramsOfInterest); RooAbsReal*RooAbsReal::createRunningIntegral(const RooArgSet& iset, const RooArgSet& nset = RooArgSet()); RooAbsReal*RooAbsReal::createRunningIntegral(const RooArgSet& iset, const RooCmdArg& arg1, const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()); RooAbsReal*RooAbsReal::createScanRI(const RooArgSet& iset, const RooArgSet& nset, Int_t numScanBins, Int_t intOrder); virtual Double_tRooAbsReal::defaultErrorLevel() const; static RooNumIntConfig*RooAbsReal::defaultIntegratorConfig(); virtual Int_tRooAbsArg::defaultPrintContents(Option_t* opt) const; static ostream&RooPrintable::defaultPrintStream(ostream* os = 0); virtual RooPrintable::StyleOptionRooPrintable::defaultPrintStyle(Option_t* opt) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; Bool_tRooAbsArg::dependentOverlaps(const RooAbsData* dset, const RooAbsArg& testArg) const; Bool_tRooAbsArg::dependentOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; Bool_tRooAbsArg::dependsOn(const RooAbsCollection& serverList, const RooAbsArg* ignoreArg = 0, Bool_t valueOnly = kFALSE) const; Bool_tRooAbsArg::dependsOn(const RooAbsArg& server, const RooAbsArg* ignoreArg = 0, Bool_t valueOnly = kFALSE) const; Bool_tRooAbsArg::dependsOnValue(const RooAbsCollection& serverList, const RooAbsArg* ignoreArg = 0) const; Bool_tRooAbsArg::dependsOnValue(const RooAbsArg& server, const RooAbsArg* ignoreArg = 0) const; RooDerivative*RooAbsReal::derivative(RooRealVar& obs, Int_t order = 1, Double_t eps = 0.",MatchSource.WIKI,root/html602/RooAbsHiddenReal.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsHiddenReal.html
https://root.cern/root/html602/RooAbsHiddenReal.html:9221,Integrability,depend,dependsOn,9221,"l*RooAbsReal::createPlotProjection(const RooArgSet& dependentVars, const RooArgSet* projectedVars, RooArgSet*& cloneSet, const char* rangeName = 0, const RooArgSet* condObs = 0) const; virtual RooAbsReal*RooAbsReal::createProfile(const RooArgSet& paramsOfInterest); RooAbsReal*RooAbsReal::createRunningIntegral(const RooArgSet& iset, const RooArgSet& nset = RooArgSet()); RooAbsReal*RooAbsReal::createRunningIntegral(const RooArgSet& iset, const RooCmdArg& arg1, const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()); RooAbsReal*RooAbsReal::createScanRI(const RooArgSet& iset, const RooArgSet& nset, Int_t numScanBins, Int_t intOrder); virtual Double_tRooAbsReal::defaultErrorLevel() const; static RooNumIntConfig*RooAbsReal::defaultIntegratorConfig(); virtual Int_tRooAbsArg::defaultPrintContents(Option_t* opt) const; static ostream&RooPrintable::defaultPrintStream(ostream* os = 0); virtual RooPrintable::StyleOptionRooPrintable::defaultPrintStyle(Option_t* opt) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; Bool_tRooAbsArg::dependentOverlaps(const RooAbsData* dset, const RooAbsArg& testArg) const; Bool_tRooAbsArg::dependentOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; Bool_tRooAbsArg::dependsOn(const RooAbsCollection& serverList, const RooAbsArg* ignoreArg = 0, Bool_t valueOnly = kFALSE) const; Bool_tRooAbsArg::dependsOn(const RooAbsArg& server, const RooAbsArg* ignoreArg = 0, Bool_t valueOnly = kFALSE) const; Bool_tRooAbsArg::dependsOnValue(const RooAbsCollection& serverList, const RooAbsArg* ignoreArg = 0) const; Bool_tRooAbsArg::dependsOnValue(const RooAbsArg& server, const RooAbsArg* ignoreArg = 0) const; RooDerivative*RooAbsReal::derivative(RooRealVar& obs, Int_t order = 1, Double_t eps = 0.",MatchSource.WIKI,root/html602/RooAbsHiddenReal.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsHiddenReal.html
https://root.cern/root/html602/RooAbsHiddenReal.html:9339,Integrability,depend,dependsOnValue,9339,"l*RooAbsReal::createPlotProjection(const RooArgSet& dependentVars, const RooArgSet* projectedVars, RooArgSet*& cloneSet, const char* rangeName = 0, const RooArgSet* condObs = 0) const; virtual RooAbsReal*RooAbsReal::createProfile(const RooArgSet& paramsOfInterest); RooAbsReal*RooAbsReal::createRunningIntegral(const RooArgSet& iset, const RooArgSet& nset = RooArgSet()); RooAbsReal*RooAbsReal::createRunningIntegral(const RooArgSet& iset, const RooCmdArg& arg1, const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()); RooAbsReal*RooAbsReal::createScanRI(const RooArgSet& iset, const RooArgSet& nset, Int_t numScanBins, Int_t intOrder); virtual Double_tRooAbsReal::defaultErrorLevel() const; static RooNumIntConfig*RooAbsReal::defaultIntegratorConfig(); virtual Int_tRooAbsArg::defaultPrintContents(Option_t* opt) const; static ostream&RooPrintable::defaultPrintStream(ostream* os = 0); virtual RooPrintable::StyleOptionRooPrintable::defaultPrintStyle(Option_t* opt) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; Bool_tRooAbsArg::dependentOverlaps(const RooAbsData* dset, const RooAbsArg& testArg) const; Bool_tRooAbsArg::dependentOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; Bool_tRooAbsArg::dependsOn(const RooAbsCollection& serverList, const RooAbsArg* ignoreArg = 0, Bool_t valueOnly = kFALSE) const; Bool_tRooAbsArg::dependsOn(const RooAbsArg& server, const RooAbsArg* ignoreArg = 0, Bool_t valueOnly = kFALSE) const; Bool_tRooAbsArg::dependsOnValue(const RooAbsCollection& serverList, const RooAbsArg* ignoreArg = 0) const; Bool_tRooAbsArg::dependsOnValue(const RooAbsArg& server, const RooAbsArg* ignoreArg = 0) const; RooDerivative*RooAbsReal::derivative(RooRealVar& obs, Int_t order = 1, Double_t eps = 0.",MatchSource.WIKI,root/html602/RooAbsHiddenReal.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsHiddenReal.html
https://root.cern/root/html602/RooAbsHiddenReal.html:9446,Integrability,depend,dependsOnValue,9446,"l*RooAbsReal::createPlotProjection(const RooArgSet& dependentVars, const RooArgSet* projectedVars, RooArgSet*& cloneSet, const char* rangeName = 0, const RooArgSet* condObs = 0) const; virtual RooAbsReal*RooAbsReal::createProfile(const RooArgSet& paramsOfInterest); RooAbsReal*RooAbsReal::createRunningIntegral(const RooArgSet& iset, const RooArgSet& nset = RooArgSet()); RooAbsReal*RooAbsReal::createRunningIntegral(const RooArgSet& iset, const RooCmdArg& arg1, const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()); RooAbsReal*RooAbsReal::createScanRI(const RooArgSet& iset, const RooArgSet& nset, Int_t numScanBins, Int_t intOrder); virtual Double_tRooAbsReal::defaultErrorLevel() const; static RooNumIntConfig*RooAbsReal::defaultIntegratorConfig(); virtual Int_tRooAbsArg::defaultPrintContents(Option_t* opt) const; static ostream&RooPrintable::defaultPrintStream(ostream* os = 0); virtual RooPrintable::StyleOptionRooPrintable::defaultPrintStyle(Option_t* opt) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; Bool_tRooAbsArg::dependentOverlaps(const RooAbsData* dset, const RooAbsArg& testArg) const; Bool_tRooAbsArg::dependentOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; Bool_tRooAbsArg::dependsOn(const RooAbsCollection& serverList, const RooAbsArg* ignoreArg = 0, Bool_t valueOnly = kFALSE) const; Bool_tRooAbsArg::dependsOn(const RooAbsArg& server, const RooAbsArg* ignoreArg = 0, Bool_t valueOnly = kFALSE) const; Bool_tRooAbsArg::dependsOnValue(const RooAbsCollection& serverList, const RooAbsArg* ignoreArg = 0) const; Bool_tRooAbsArg::dependsOnValue(const RooAbsArg& server, const RooAbsArg* ignoreArg = 0) const; RooDerivative*RooAbsReal::derivative(RooRealVar& obs, Int_t order = 1, Double_t eps = 0.",MatchSource.WIKI,root/html602/RooAbsHiddenReal.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsHiddenReal.html
https://root.cern/root/html602/RooAbsHiddenReal.html:17639,Integrability,message,message,17639,"t; virtual Bool_tRooAbsArg::isFundamental() const; Bool_tisHidden() const; virtual Bool_tRooAbsReal::isIdentical(const RooAbsArg& other, Bool_t assumeSameType = kFALSE); virtual Bool_tRooAbsArg::isLValue() const; virtual Bool_tRooAbsReal::isOffsetting() const; Bool_tTObject::IsOnHeap() const; Bool_tRooAbsArg::isShapeDirty() const; Bool_tRooAbsArg::isShapeServer(const RooAbsArg& arg) const; Bool_tRooAbsArg::isShapeServer(const char* name) const; virtual Bool_tRooAbsArg::IsSortable() const; Bool_tRooAbsArg::isValueDirty() const; Bool_tRooAbsArg::isValueDirtyAndClear() const; Bool_tRooAbsArg::isValueOrShapeDirtyAndClear() const; Bool_tRooAbsArg::isValueServer(const RooAbsArg& arg) const; Bool_tRooAbsArg::isValueServer(const char* name) const; Bool_tTObject::IsZombie() const; voidRooAbsArg::leafNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t recurseNonDerived = kFALSE) const; Bool_tRooAbsArg::localNoDirtyInhibit() const; voidRooAbsReal::logEvalError(const char* message, const char* serverValueString = 0) const; static voidRooAbsReal::logEvalError(const RooAbsReal* originator, const char* origName, const char* message, const char* serverValueString = 0); virtual voidTNamed::ls(Option_t* option = """") const; virtual Double_tRooAbsReal::maxVal(Int_t code) const; voidTObject::MayNotUse(const char* method) const; RooAbsMoment*RooAbsReal::mean(RooRealVar& obs); RooAbsMoment*RooAbsReal::mean(RooRealVar& obs, const RooArgSet& nset); virtual Int_tRooAbsReal::minTrialSamples(const RooArgSet&) const; RooAbsMoment*RooAbsReal::moment(RooRealVar& obs, Int_t order, Bool_t central, Bool_t takeRoot); RooAbsMoment*RooAbsReal::moment(RooRealVar& obs, const RooArgSet& normObs, Int_t order, Bool_t central, Bool_t takeRoot, Bool_t intNormObs); static voidRooPrintable::nameFieldLength(Int_t newLen); const TNamed*RooAbsArg::namePtr() const; virtual Bool_tTObject::Notify(); Int_tRooAbsArg::numCaches() const; static Int_tRooAbsReal::numEvalErrorItems(); static Int_tRooAbsR",MatchSource.WIKI,root/html602/RooAbsHiddenReal.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsHiddenReal.html
https://root.cern/root/html602/RooAbsHiddenReal.html:17790,Integrability,message,message,17790,"ameType = kFALSE); virtual Bool_tRooAbsArg::isLValue() const; virtual Bool_tRooAbsReal::isOffsetting() const; Bool_tTObject::IsOnHeap() const; Bool_tRooAbsArg::isShapeDirty() const; Bool_tRooAbsArg::isShapeServer(const RooAbsArg& arg) const; Bool_tRooAbsArg::isShapeServer(const char* name) const; virtual Bool_tRooAbsArg::IsSortable() const; Bool_tRooAbsArg::isValueDirty() const; Bool_tRooAbsArg::isValueDirtyAndClear() const; Bool_tRooAbsArg::isValueOrShapeDirtyAndClear() const; Bool_tRooAbsArg::isValueServer(const RooAbsArg& arg) const; Bool_tRooAbsArg::isValueServer(const char* name) const; Bool_tTObject::IsZombie() const; voidRooAbsArg::leafNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t recurseNonDerived = kFALSE) const; Bool_tRooAbsArg::localNoDirtyInhibit() const; voidRooAbsReal::logEvalError(const char* message, const char* serverValueString = 0) const; static voidRooAbsReal::logEvalError(const RooAbsReal* originator, const char* origName, const char* message, const char* serverValueString = 0); virtual voidTNamed::ls(Option_t* option = """") const; virtual Double_tRooAbsReal::maxVal(Int_t code) const; voidTObject::MayNotUse(const char* method) const; RooAbsMoment*RooAbsReal::mean(RooRealVar& obs); RooAbsMoment*RooAbsReal::mean(RooRealVar& obs, const RooArgSet& nset); virtual Int_tRooAbsReal::minTrialSamples(const RooArgSet&) const; RooAbsMoment*RooAbsReal::moment(RooRealVar& obs, Int_t order, Bool_t central, Bool_t takeRoot); RooAbsMoment*RooAbsReal::moment(RooRealVar& obs, const RooArgSet& normObs, Int_t order, Bool_t central, Bool_t takeRoot, Bool_t intNormObs); static voidRooPrintable::nameFieldLength(Int_t newLen); const TNamed*RooAbsArg::namePtr() const; virtual Bool_tTObject::Notify(); Int_tRooAbsArg::numCaches() const; static Int_tRooAbsReal::numEvalErrorItems(); static Int_tRooAbsReal::numEvalErrors(); Bool_tRooAbsArg::observableOverlaps(const RooAbsData* dset, const RooAbsArg& testArg) const; Bool_tRooAbsArg::observableOverlaps(",MatchSource.WIKI,root/html602/RooAbsHiddenReal.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsHiddenReal.html
https://root.cern/root/html602/RooAbsHiddenReal.html:35424,Integrability,integrat,integration,35424,"tected:. set<string>RooAbsArg::_boolAttribBoolean attributes; set<string>RooAbsArg::_boolAttribTransient! Transient boolean attributes (not copied in ctor); Bool_tRooAbsReal::_boolValue! Transient cache for bool values from tree branches; UChar_tRooAbsReal::_byteValue! Transient cache for byte values from tree branches; static Bool_tRooAbsReal::_cacheCheckIf true, always validate contents of clean which outcome of evaluate(); deque<RooAbsCache*>RooAbsArg::_cacheListlist of caches; RooRefCountListRooAbsArg::_clientListlist of client objects; RooRefCountListRooAbsArg::_clientListShapesubset of clients that requested shape dirty flag propagation; RooRefCountListRooAbsArg::_clientListValuesubset of clients that requested value dirty flag propagation; TIterator*RooAbsArg::_clientShapeIter! Iterator over _clientListShape; TIterator*RooAbsArg::_clientValueIter! Iterator over _clientListValue; Bool_tRooAbsArg::_deleteWatch! Delete watch flag; static RooCategory*_dummyBlindState; RooExpensiveObjectCache*RooAbsArg::_eocachePointer to global cache manager for any expensive components created by this object; Bool_tRooAbsArg::_fastAllow fast access mode in getVal() and proxies; Float_tRooAbsReal::_floatValue! Transient cache for floating point values from tree branches; Bool_tRooAbsReal::_forceNumIntForce numerical integration if flag set; static Bool_tRooAbsReal::_globalSelectCompGlobal activation switch for component selection; static Bool_tRooAbsReal::_hideOffsetOffset hiding flag; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; Int_tRooAbsReal::_intValue! Transient cache for integer values from tree branches; Bool_tRooAbsArg::_isConstant! Cached isConstant status; TStringRooAbsReal::_labelPlot label for objects value; RooArgSet*RooAbsReal::_lastNSet!; Bool_tRooAbsArg::_localNoInhibitDirty! Prevent 'AlwaysDirty' mode for this node; static Int_tRooPrintable::_nameLength; TNamed*RooAbsArg::_namePtr! Do not persist. Pointer",MatchSource.WIKI,root/html602/RooAbsHiddenReal.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsHiddenReal.html
https://root.cern/root/html602/RooAbsHiddenReal.html:36962,Integrability,integrat,integrator,36962,"label for objects value; RooArgSet*RooAbsReal::_lastNSet!; Bool_tRooAbsArg::_localNoInhibitDirty! Prevent 'AlwaysDirty' mode for this node; static Int_tRooPrintable::_nameLength; TNamed*RooAbsArg::_namePtr! Do not persist. Pointer to global instance of string that matches object named; RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; Int_tRooAbsReal::_plotBinsNumber of plot bins; Double_tRooAbsReal::_plotMaxMaximum of plot range; Double_tRooAbsReal::_plotMinMinimum of plot range; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; RooRefArrayRooAbsArg::_proxyListlist of proxies; Char_tRooAbsReal::_sbyteValue! Transient cache for signed byte values from tree branches; Bool_tRooAbsReal::_selectComp! Component selection flag for RooAbsPdf::plotCompOn; RooRefCountListRooAbsArg::_serverListlist of server objects; Bool_tRooAbsArg::_shapeDirtyFlag set if value needs recalculating because input shapes modified; RooNumIntConfig*RooAbsReal::_specIntegratorConfigNumeric integrator configuration specific for this object; RooCategoryProxy_stateProxy to hiding state category; map<string,string>RooAbsArg::_stringAttribString attributes; Bool_tRooAbsReal::_treeVar!do not persist; UInt_tRooAbsReal::_uintValue! Transient cache for unsigned integer values from tree branches; TStringRooAbsReal::_unitUnit for objects value; Double_tRooAbsReal::_valueCache for current value of object; Bool_tRooAbsArg::_valueDirtyFlag set if value needs recalculating because input values modified; static Bool_tRooAbsArg::_verboseDirtyStatic flag controlling verbose messaging for dirty state changes; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; RooAbsHiddenReal(const char* name, const char* title, const char* unit = """"); Constructor. RooAbsHiddenReal(const char* name, cons",MatchSource.WIKI,root/html602/RooAbsHiddenReal.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsHiddenReal.html
https://root.cern/root/html602/RooAbsHiddenReal.html:24746,Modifiability,config,config,24746,"e(ostream& out, Option_t* option = """"); TIterator*RooAbsArg::serverIterator() const; RooFIterRooAbsArg::serverMIterator() const; virtual voidRooAbsArg::serverNameChangeHook(const RooAbsArg*, const RooAbsArg*); voidRooAbsArg::setAttribute(const Text_t* name, Bool_t value = kTRUE); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); virtual voidRooAbsArg::setCacheAndTrackHints(RooArgSet&); static voidRooAbsReal::setCacheCheck(Bool_t flag); virtual Bool_tRooAbsReal::setData(RooAbsData&, Bool_t = kTRUE); static voidRooAbsArg::setDirtyInhibit(Bool_t flag); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); static voidRooAbsReal::setEvalErrorLoggingMode(RooAbsReal::ErrorLoggingMode m); virtual voidRooAbsArg::setExpensiveObjectCache(RooExpensiveObjectCache& cache); static voidRooAbsReal::setHideOffset(Bool_t flag); voidRooAbsReal::setIntegratorConfig(); voidRooAbsReal::setIntegratorConfig(const RooNumIntConfig& config); voidRooAbsArg::setLocalNoDirtyInhibit(Bool_t flag) const; virtual voidRooAbsArg::SetName(const char* name); virtual voidRooAbsArg::SetNameTitle(const char* name, const char* title); static voidTObject::SetObjectStat(Bool_t stat); voidRooAbsArg::setOperMode(RooAbsArg::OperMode mode, Bool_t recurseADirty = kTRUE); voidRooAbsReal::setParameterizeIntegral(const RooArgSet& paramVars); voidRooAbsReal::setPlotLabel(const char* label); voidRooAbsArg::setProhibitServerRedirect(Bool_t flag); voidRooAbsArg::setShapeDirty() const; voidRooAbsArg::setStringAttribute(const Text_t* key, const Text_t* value); virtual voidTNamed::SetTitle(const char* title = """")MENU ; voidRooAbsArg::setTransientAttribute(const Text_t* name, Bool_t value = kTRUE); virtual voidTObject::SetUniqueID(UInt_t uid); voidRooAbsReal::setUnit(const char* unit); voidRooAbsArg::setValueDirty() const; TIterator*RooAbsArg::shapeClientIterator() const; RooFIterRooAbsArg::shapeClientMIterator() const; virtual voidShowMembers(TMembe",MatchSource.WIKI,root/html602/RooAbsHiddenReal.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsHiddenReal.html
https://root.cern/root/html602/RooAbsHiddenReal.html:36973,Modifiability,config,configuration,36973,"label for objects value; RooArgSet*RooAbsReal::_lastNSet!; Bool_tRooAbsArg::_localNoInhibitDirty! Prevent 'AlwaysDirty' mode for this node; static Int_tRooPrintable::_nameLength; TNamed*RooAbsArg::_namePtr! Do not persist. Pointer to global instance of string that matches object named; RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; Int_tRooAbsReal::_plotBinsNumber of plot bins; Double_tRooAbsReal::_plotMaxMaximum of plot range; Double_tRooAbsReal::_plotMinMinimum of plot range; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; RooRefArrayRooAbsArg::_proxyListlist of proxies; Char_tRooAbsReal::_sbyteValue! Transient cache for signed byte values from tree branches; Bool_tRooAbsReal::_selectComp! Component selection flag for RooAbsPdf::plotCompOn; RooRefCountListRooAbsArg::_serverListlist of server objects; Bool_tRooAbsArg::_shapeDirtyFlag set if value needs recalculating because input shapes modified; RooNumIntConfig*RooAbsReal::_specIntegratorConfigNumeric integrator configuration specific for this object; RooCategoryProxy_stateProxy to hiding state category; map<string,string>RooAbsArg::_stringAttribString attributes; Bool_tRooAbsReal::_treeVar!do not persist; UInt_tRooAbsReal::_uintValue! Transient cache for unsigned integer values from tree branches; TStringRooAbsReal::_unitUnit for objects value; Double_tRooAbsReal::_valueCache for current value of object; Bool_tRooAbsArg::_valueDirtyFlag set if value needs recalculating because input values modified; static Bool_tRooAbsArg::_verboseDirtyStatic flag controlling verbose messaging for dirty state changes; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; RooAbsHiddenReal(const char* name, const char* title, const char* unit = """"); Constructor. RooAbsHiddenReal(const char* name, cons",MatchSource.WIKI,root/html602/RooAbsHiddenReal.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsHiddenReal.html
https://root.cern/root/html602/RooAbsHiddenReal.html:2295,Performance,cache,cacheUniqueSuffix,2295,"iqueSuffix() const; virtual Double_tRooAbsReal::analyticalIntegral(Int_t code, const char* rangeName = 0) const; virtual Double_tRooAbsReal::analyticalIntegralWN(Int_t code, const RooArgSet* normSet, const char* rangeName = 0) const; virtual voidTObject::AppendPad(Option_t* option = """"); TF1*RooAbsReal::asTF(const RooArgList& obs, const RooArgList& pars = RooArgList(), const RooArgSet& nset = RooArgSet()) const; voidRooAbsArg::attachDataSet(const RooAbsData& set); voidRooAbsArg::attachDataStore(const RooAbsDataStore& set); const set<string>&RooAbsArg::attributes() const; virtual list<Double_t>*RooAbsReal::binBoundaries(RooAbsRealLValue&, Double_t, Double_t) const; RooAbsFunc*RooAbsReal::bindVars(const RooArgSet& vars, const RooArgSet* nset = 0, Bool_t clipInvalid = kFALSE) const; voidRooAbsArg::branchNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t recurseNonDerived = kFALSE) const; virtual voidTObject::Browse(TBrowser* b); virtual const char*RooAbsArg::cacheUniqueSuffix() const; virtual RooAbsArg::CacheModeRooAbsArg::canNodeBeCached() const; voidRooAbsArg::changeServer(RooAbsArg& server, Bool_t valueProp, Bool_t shapeProp); Bool_tRooAbsArg::checkDependents(const RooArgSet* nset) const; virtual Bool_tRooAbsArg::checkObservables(const RooArgSet* nset) const; virtual RooFitResult*RooAbsReal::chi2FitTo(RooDataHist& data, const RooLinkedList& cmdList); virtual RooFitResult*RooAbsReal::chi2FitTo(RooDataSet& xydata, const RooLinkedList& cmdList); virtual RooFitResult*RooAbsReal::chi2FitTo(RooDataHist& data, const RooCmdArg& arg1 = RooCmdArg::none(), const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()); virtual RooFitResult*RooAbsReal::chi2FitTo(RooDataSet& xydata, const RooCmdArg& arg1 = RooCmdArg::none(),",MatchSource.WIKI,root/html602/RooAbsHiddenReal.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsHiddenReal.html
https://root.cern/root/html602/RooAbsHiddenReal.html:11153,Performance,cache,cacheList,11153,"rRooAbsReal::evalErrorIter(); static RooAbsReal::ErrorLoggingModeRooAbsReal::evalErrorLoggingMode(); virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); RooExpensiveObjectCache&RooAbsArg::expensiveObjectCache() const; virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); RooDataHist*RooAbsReal::fillDataHist(RooDataHist* hist, const RooArgSet* nset, Double_t scaleFactor, Bool_t correctForBinVolume = kFALSE, Bool_t showProgress = kFALSE) const; TH1*RooAbsReal::fillHistogram(TH1* hist, const RooArgList& plotVars, Double_t scaleFactor = 1, const RooArgSet* projectedVars = 0, Bool_t scaling = kTRUE, const RooArgSet* condObs = 0, Bool_t setError = kTRUE) const; Bool_tRooAbsArg::findConstantNodes(const RooArgSet& observables, RooArgSet& cacheList); Bool_tRooAbsArg::findConstantNodes(const RooArgSet& observables, RooArgSet& cacheList, RooLinkedList& processedNodes); RooAbsArg*RooAbsArg::findNewServer(const RooAbsCollection& newSet, Bool_t nameChange) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; Double_tRooAbsReal::findRoot(RooRealVar& x, Double_t xmin, Double_t xmax, Double_t yval); RooAbsArg*RooAbsArg::findServer(const char* name) const; RooAbsArg*RooAbsArg::findServer(const RooAbsArg& arg) const; RooAbsArg*RooAbsArg::findServer(Int_t index) const; virtual voidRooAbsReal::fixAddCoefNormalization(const RooArgSet& addNormSet = RooArgSet(), Bool_t force = kTRUE); virtual voidRooAbsReal::fixAddCoefRange(const char* rangeName = 0, Bool_t force = kTRUE); static UInt_tRooAbsArg::fnv1a32(const char* data); static UInt_tRooAbsArg::fnv1a32(const char* data, ULong_t sz, UInt_t hash = fnv1a32start); static ULong64_tRooAbsArg::fnv1a64(const char* data",MatchSource.WIKI,root/html602/RooAbsHiddenReal.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsHiddenReal.html
https://root.cern/root/html602/RooAbsHiddenReal.html:11241,Performance,cache,cacheList,11241,"ggingMode(); virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); RooExpensiveObjectCache&RooAbsArg::expensiveObjectCache() const; virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); RooDataHist*RooAbsReal::fillDataHist(RooDataHist* hist, const RooArgSet* nset, Double_t scaleFactor, Bool_t correctForBinVolume = kFALSE, Bool_t showProgress = kFALSE) const; TH1*RooAbsReal::fillHistogram(TH1* hist, const RooArgList& plotVars, Double_t scaleFactor = 1, const RooArgSet* projectedVars = 0, Bool_t scaling = kTRUE, const RooArgSet* condObs = 0, Bool_t setError = kTRUE) const; Bool_tRooAbsArg::findConstantNodes(const RooArgSet& observables, RooArgSet& cacheList); Bool_tRooAbsArg::findConstantNodes(const RooArgSet& observables, RooArgSet& cacheList, RooLinkedList& processedNodes); RooAbsArg*RooAbsArg::findNewServer(const RooAbsCollection& newSet, Bool_t nameChange) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; Double_tRooAbsReal::findRoot(RooRealVar& x, Double_t xmin, Double_t xmax, Double_t yval); RooAbsArg*RooAbsArg::findServer(const char* name) const; RooAbsArg*RooAbsArg::findServer(const RooAbsArg& arg) const; RooAbsArg*RooAbsArg::findServer(Int_t index) const; virtual voidRooAbsReal::fixAddCoefNormalization(const RooArgSet& addNormSet = RooArgSet(), Bool_t force = kTRUE); virtual voidRooAbsReal::fixAddCoefRange(const char* rangeName = 0, Bool_t force = kTRUE); static UInt_tRooAbsArg::fnv1a32(const char* data); static UInt_tRooAbsArg::fnv1a32(const char* data, ULong_t sz, UInt_t hash = fnv1a32start); static ULong64_tRooAbsArg::fnv1a64(const char* data); static ULong64_tRooAbsArg::fnv1a64(const char* data, ULong_t sz, ULong64_t hash = fnv",MatchSource.WIKI,root/html602/RooAbsHiddenReal.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsHiddenReal.html
https://root.cern/root/html602/RooAbsHiddenReal.html:19603,Performance,optimiz,optimizeCacheMode,19603,"rorItems(); static Int_tRooAbsReal::numEvalErrors(); Bool_tRooAbsArg::observableOverlaps(const RooAbsData* dset, const RooAbsArg& testArg) const; Bool_tRooAbsArg::observableOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; virtual Double_tRooAbsReal::offset() const; voidTObject::operator delete(void* ptr); voidTObject::operator delete(void* ptr, void* vp); voidTObject::operator delete[](void* ptr); voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); RooAbsHiddenReal&operator=(const RooAbsHiddenReal&); Bool_tRooAbsReal::operator==(Double_t value) const; virtual Bool_tRooAbsReal::operator==(const RooAbsArg& other); RooAbsArg::OperModeRooAbsArg::operMode() const; virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables); virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables, RooArgSet& optNodes, RooLinkedList& processedNodes); Bool_tRooAbsArg::overlaps(const RooAbsArg& testArg, Bool_t valueOnly = kFALSE) const; const RooArgSet*RooAbsArg::ownedComponents() const; virtual voidTObject::Paint(Option_t* option = """"); virtual RooPlot*RooAbsReal::plotOn(RooPlot* frame, RooLinkedList& cmdList) const; virtual RooPlot*RooAbsReal::plotOn(RooPlot* frame, const RooCmdArg& arg1 = RooCmdArg(), const RooCmdArg& arg2 = RooCmdArg(), const RooCmdArg& arg3 = RooCmdArg(), const RooCmdArg& arg4 = RooCmdArg(), const RooCmdArg& arg5 = RooCmdArg(), const RooCmdArg& arg6 = RooCmdArg(), const RooCmdArg& arg7 = RooCmdArg(), const RooCmdArg& arg8 = RooCmdArg(), const RooCmdArg& arg9 = RooCmdArg(), const RooCmdArg& arg10 = RooCmdArg()) const; virtual list<Double_t>*RooAbsReal::plotSamplingHint(RooAbsRealLValue&, Double_t, Double_t) const; virtual RooPlot*RooAbsReal::plotSliceO",MatchSource.WIKI,root/html602/RooAbsHiddenReal.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsHiddenReal.html
https://root.cern/root/html602/RooAbsHiddenReal.html:19675,Performance,optimiz,optimizeCacheMode,19675,"servableOverlaps(const RooAbsData* dset, const RooAbsArg& testArg) const; Bool_tRooAbsArg::observableOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; virtual Double_tRooAbsReal::offset() const; voidTObject::operator delete(void* ptr); voidTObject::operator delete(void* ptr, void* vp); voidTObject::operator delete[](void* ptr); voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); RooAbsHiddenReal&operator=(const RooAbsHiddenReal&); Bool_tRooAbsReal::operator==(Double_t value) const; virtual Bool_tRooAbsReal::operator==(const RooAbsArg& other); RooAbsArg::OperModeRooAbsArg::operMode() const; virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables); virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables, RooArgSet& optNodes, RooLinkedList& processedNodes); Bool_tRooAbsArg::overlaps(const RooAbsArg& testArg, Bool_t valueOnly = kFALSE) const; const RooArgSet*RooAbsArg::ownedComponents() const; virtual voidTObject::Paint(Option_t* option = """"); virtual RooPlot*RooAbsReal::plotOn(RooPlot* frame, RooLinkedList& cmdList) const; virtual RooPlot*RooAbsReal::plotOn(RooPlot* frame, const RooCmdArg& arg1 = RooCmdArg(), const RooCmdArg& arg2 = RooCmdArg(), const RooCmdArg& arg3 = RooCmdArg(), const RooCmdArg& arg4 = RooCmdArg(), const RooCmdArg& arg5 = RooCmdArg(), const RooCmdArg& arg6 = RooCmdArg(), const RooCmdArg& arg7 = RooCmdArg(), const RooCmdArg& arg8 = RooCmdArg(), const RooCmdArg& arg9 = RooCmdArg(), const RooCmdArg& arg10 = RooCmdArg()) const; virtual list<Double_t>*RooAbsReal::plotSamplingHint(RooAbsRealLValue&, Double_t, Double_t) const; virtual RooPlot*RooAbsReal::plotSliceOn(RooPlot* frame, const RooArgSet& sliceSet, Option_t* drawOptions = ""L""",MatchSource.WIKI,root/html602/RooAbsHiddenReal.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsHiddenReal.html
https://root.cern/root/html602/RooAbsHiddenReal.html:23129,Performance,cache,cache,23129,"dent = """") const; virtual voidRooAbsArg::printTitle(ostream& os) const; virtual voidRooAbsArg::printTree(ostream& os, TString indent = """") const; virtual voidprintValue(ostream& stream) const; virtual Int_tTObject::Read(const char* name); virtual Bool_treadFromStream(istream& is, Bool_t compact, Bool_t verbose = kFALSE); Bool_tRooAbsArg::recursiveCheckDependents(const RooArgSet* nset) const; Bool_tRooAbsArg::recursiveCheckObservables(const RooArgSet* nset) const; Bool_tRooAbsArg::recursiveRedirectServers(const RooAbsCollection& newServerList, Bool_t mustReplaceAll = kFALSE, Bool_t nameChange = kFALSE, Bool_t recurseInNewSet = kTRUE); virtual voidTObject::RecursiveRemove(TObject* obj); Bool_tRooAbsArg::redirectServers(const RooAbsCollection& newServerList, Bool_t mustReplaceAll = kFALSE, Bool_t nameChange = kFALSE, Bool_t isRecursionStep = kFALSE); virtual Bool_tRooAbsArg::redirectServersHook(const RooAbsCollection&, Bool_t, Bool_t, Bool_t); voidRooAbsArg::registerCache(RooAbsCache& cache); voidRooAbsArg::removeServer(RooAbsArg& server, Bool_t force = kFALSE); voidRooAbsArg::replaceServer(RooAbsArg& oldServer, RooAbsArg& newServer, Bool_t valueProp, Bool_t shapeProp); voidTObject::ResetBit(UInt_t f); RooAbsHiddenReal(); RooAbsHiddenReal(const RooAbsHiddenReal& other, const char* name = 0); RooAbsHiddenReal(const char* name, const char* title, const char* unit = """"); RooAbsHiddenReal(const char* name, const char* title, RooAbsCategory& blindState, const char* unit = """"); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); TIterator*RooAbsArg::serverIterator() const; RooFIterRooAbsArg::serverMIterator() const; virtual voidRooAbsArg::serverNameChangeHook(const RooAbsArg*, const RooAbsArg*); voidRooAbsArg::setAttribute(const Text_t* name, Bool_t value = kTRUE); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); virtual voidRooAbsArg::setCa",MatchSource.WIKI,root/html602/RooAbsHiddenReal.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsHiddenReal.html
https://root.cern/root/html602/RooAbsHiddenReal.html:24589,Performance,cache,cache,24589,"indState, const char* unit = """"); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); TIterator*RooAbsArg::serverIterator() const; RooFIterRooAbsArg::serverMIterator() const; virtual voidRooAbsArg::serverNameChangeHook(const RooAbsArg*, const RooAbsArg*); voidRooAbsArg::setAttribute(const Text_t* name, Bool_t value = kTRUE); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); virtual voidRooAbsArg::setCacheAndTrackHints(RooArgSet&); static voidRooAbsReal::setCacheCheck(Bool_t flag); virtual Bool_tRooAbsReal::setData(RooAbsData&, Bool_t = kTRUE); static voidRooAbsArg::setDirtyInhibit(Bool_t flag); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); static voidRooAbsReal::setEvalErrorLoggingMode(RooAbsReal::ErrorLoggingMode m); virtual voidRooAbsArg::setExpensiveObjectCache(RooExpensiveObjectCache& cache); static voidRooAbsReal::setHideOffset(Bool_t flag); voidRooAbsReal::setIntegratorConfig(); voidRooAbsReal::setIntegratorConfig(const RooNumIntConfig& config); voidRooAbsArg::setLocalNoDirtyInhibit(Bool_t flag) const; virtual voidRooAbsArg::SetName(const char* name); virtual voidRooAbsArg::SetNameTitle(const char* name, const char* title); static voidTObject::SetObjectStat(Bool_t stat); voidRooAbsArg::setOperMode(RooAbsArg::OperMode mode, Bool_t recurseADirty = kTRUE); voidRooAbsReal::setParameterizeIntegral(const RooArgSet& paramVars); voidRooAbsReal::setPlotLabel(const char* label); voidRooAbsArg::setProhibitServerRedirect(Bool_t flag); voidRooAbsArg::setShapeDirty() const; voidRooAbsArg::setStringAttribute(const Text_t* key, const Text_t* value); virtual voidTNamed::SetTitle(const char* title = """")MENU ; voidRooAbsArg::setTransientAttribute(const Text_t* name, Bool_t value = kTRUE); virtual voidTObject::SetUniqueID(UInt_t uid); voidRooAbsReal::setUnit(const char* unit); voidRooAb",MatchSource.WIKI,root/html602/RooAbsHiddenReal.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsHiddenReal.html
https://root.cern/root/html602/RooAbsHiddenReal.html:26684,Performance,cache,cache,26684,"ol_t flag); voidRooAbsArg::setShapeDirty() const; voidRooAbsArg::setStringAttribute(const Text_t* key, const Text_t* value); virtual voidTNamed::SetTitle(const char* title = """")MENU ; voidRooAbsArg::setTransientAttribute(const Text_t* name, Bool_t value = kTRUE); virtual voidTObject::SetUniqueID(UInt_t uid); voidRooAbsReal::setUnit(const char* unit); voidRooAbsArg::setValueDirty() const; TIterator*RooAbsArg::shapeClientIterator() const; RooFIterRooAbsArg::shapeClientMIterator() const; virtual voidShowMembers(TMemberInspector& insp) const; RooAbsMoment*RooAbsReal::sigma(RooRealVar& obs); RooAbsMoment*RooAbsReal::sigma(RooRealVar& obs, const RooArgSet& nset); virtual Int_tTNamed::Sizeof() const; RooNumIntConfig*RooAbsReal::specialIntegratorConfig() const; RooNumIntConfig*RooAbsReal::specialIntegratorConfig(Bool_t createOnTheFly); virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); const map<string,string>&RooAbsArg::stringAttributes() const; virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; const set<string>&RooAbsArg::transientAttributes() const; voidRooAbsArg::treeNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t doBranch = kTRUE, Bool_t doLeaf = kTRUE, Bool_t valueOnly = kFALSE, Bool_t recurseNonDerived = kFALSE) const; voidRooAbsArg::unRegisterCache(RooAbsCache& cache); virtual voidTObject::UseCurrentStyle(); TIterator*RooAbsArg::valueClientIterator() const; RooFIterRooAbsArg::valueClientMIterator() const; static voidRooAbsArg::verboseDirty(Bool_t flag); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; voidRooAbsArg::wireAllCaches(); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const; virtual voidwriteToStream(ostream& os, Bool_t compact) const.",MatchSource.WIKI,root/html602/RooAbsHiddenReal.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsHiddenReal.html
https://root.cern/root/html602/RooAbsHiddenReal.html:29839,Performance,optimiz,optimizeDirtyHook,29839,"ual Bool_tRooAbsReal::isValidReal(Double_t value, Bool_t printError = kFALSE) const; voidRooAbsReal::makeProjectionSet(const RooAbsArg* plotVar, const RooArgSet* allVars, RooArgSet& projectedVars, Bool_t silent) const; voidTObject::MakeZombie(); Bool_tRooAbsReal::matchArgs(const RooArgSet& allDeps, RooArgSet& numDeps, const RooArgProxy& a) const; Bool_tRooAbsReal::matchArgs(const RooArgSet& allDeps, RooArgSet& numDeps, const RooArgSet& set) const; Bool_tRooAbsReal::matchArgs(const RooArgSet& allDeps, RooArgSet& numDeps, const RooArgProxy& a, const RooArgProxy& b) const; Bool_tRooAbsReal::matchArgs(const RooArgSet& allDeps, RooArgSet& numDeps, const RooArgProxy& a, const RooArgProxy& b, const RooArgProxy& c) const; Bool_tRooAbsReal::matchArgs(const RooArgSet& allDeps, RooArgSet& numDeps, const RooArgProxy& a, const RooArgProxy& b, const RooArgProxy& c, const RooArgProxy& d) const; Int_tRooAbsArg::numProxies() const; virtual voidRooAbsArg::operModeHook(); virtual voidRooAbsArg::optimizeDirtyHook(const RooArgSet*); virtual RooPlot*RooAbsReal::plotAsymOn(RooPlot* frame, const RooAbsCategoryLValue& asymCat, RooAbsReal::PlotOpt o) const; virtual RooPlot*RooAbsReal::plotOn(RooPlot* frame, RooAbsReal::PlotOpt o) const; voidRooAbsReal::plotOnCompSelect(RooArgSet* selNodes) const; RooPlot*RooAbsReal::plotOnWithErrorBand(RooPlot* frame, const RooFitResult& fr, Double_t Z, const RooArgSet* params, const RooLinkedList& argList, Bool_t method1) const; Bool_tRooAbsReal::plotSanityChecks(RooPlot* frame) const; voidRooAbsArg::printAttribList(ostream& os) const; voidRooAbsArg::registerProxy(RooArgProxy& proxy); voidRooAbsArg::registerProxy(RooSetProxy& proxy); voidRooAbsArg::registerProxy(RooListProxy& proxy); voidRooAbsReal::selectComp(Bool_t flag); virtual voidRooAbsReal::selectNormalization(const RooArgSet* depSet = 0, Bool_t force = kFALSE); virtual voidRooAbsReal::selectNormalizationRange(const char* rangeName = 0, Bool_t force = kFALSE); voidRooAbsArg::setProxyNormSet(const Roo",MatchSource.WIKI,root/html602/RooAbsHiddenReal.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsHiddenReal.html
https://root.cern/root/html602/RooAbsHiddenReal.html:34297,Performance,cache,cache,34297,"tected:. set<string>RooAbsArg::_boolAttribBoolean attributes; set<string>RooAbsArg::_boolAttribTransient! Transient boolean attributes (not copied in ctor); Bool_tRooAbsReal::_boolValue! Transient cache for bool values from tree branches; UChar_tRooAbsReal::_byteValue! Transient cache for byte values from tree branches; static Bool_tRooAbsReal::_cacheCheckIf true, always validate contents of clean which outcome of evaluate(); deque<RooAbsCache*>RooAbsArg::_cacheListlist of caches; RooRefCountListRooAbsArg::_clientListlist of client objects; RooRefCountListRooAbsArg::_clientListShapesubset of clients that requested shape dirty flag propagation; RooRefCountListRooAbsArg::_clientListValuesubset of clients that requested value dirty flag propagation; TIterator*RooAbsArg::_clientShapeIter! Iterator over _clientListShape; TIterator*RooAbsArg::_clientValueIter! Iterator over _clientListValue; Bool_tRooAbsArg::_deleteWatch! Delete watch flag; static RooCategory*_dummyBlindState; RooExpensiveObjectCache*RooAbsArg::_eocachePointer to global cache manager for any expensive components created by this object; Bool_tRooAbsArg::_fastAllow fast access mode in getVal() and proxies; Float_tRooAbsReal::_floatValue! Transient cache for floating point values from tree branches; Bool_tRooAbsReal::_forceNumIntForce numerical integration if flag set; static Bool_tRooAbsReal::_globalSelectCompGlobal activation switch for component selection; static Bool_tRooAbsReal::_hideOffsetOffset hiding flag; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; Int_tRooAbsReal::_intValue! Transient cache for integer values from tree branches; Bool_tRooAbsArg::_isConstant! Cached isConstant status; TStringRooAbsReal::_labelPlot label for objects value; RooArgSet*RooAbsReal::_lastNSet!; Bool_tRooAbsArg::_localNoInhibitDirty! Prevent 'AlwaysDirty' mode for this node; static Int_tRooPrintable::_nameLength; TNamed*RooAbsArg::_namePtr! Do not persist. Pointer",MatchSource.WIKI,root/html602/RooAbsHiddenReal.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsHiddenReal.html
https://root.cern/root/html602/RooAbsHiddenReal.html:34380,Performance,cache,cache,34380,"tected:. set<string>RooAbsArg::_boolAttribBoolean attributes; set<string>RooAbsArg::_boolAttribTransient! Transient boolean attributes (not copied in ctor); Bool_tRooAbsReal::_boolValue! Transient cache for bool values from tree branches; UChar_tRooAbsReal::_byteValue! Transient cache for byte values from tree branches; static Bool_tRooAbsReal::_cacheCheckIf true, always validate contents of clean which outcome of evaluate(); deque<RooAbsCache*>RooAbsArg::_cacheListlist of caches; RooRefCountListRooAbsArg::_clientListlist of client objects; RooRefCountListRooAbsArg::_clientListShapesubset of clients that requested shape dirty flag propagation; RooRefCountListRooAbsArg::_clientListValuesubset of clients that requested value dirty flag propagation; TIterator*RooAbsArg::_clientShapeIter! Iterator over _clientListShape; TIterator*RooAbsArg::_clientValueIter! Iterator over _clientListValue; Bool_tRooAbsArg::_deleteWatch! Delete watch flag; static RooCategory*_dummyBlindState; RooExpensiveObjectCache*RooAbsArg::_eocachePointer to global cache manager for any expensive components created by this object; Bool_tRooAbsArg::_fastAllow fast access mode in getVal() and proxies; Float_tRooAbsReal::_floatValue! Transient cache for floating point values from tree branches; Bool_tRooAbsReal::_forceNumIntForce numerical integration if flag set; static Bool_tRooAbsReal::_globalSelectCompGlobal activation switch for component selection; static Bool_tRooAbsReal::_hideOffsetOffset hiding flag; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; Int_tRooAbsReal::_intValue! Transient cache for integer values from tree branches; Bool_tRooAbsArg::_isConstant! Cached isConstant status; TStringRooAbsReal::_labelPlot label for objects value; RooArgSet*RooAbsReal::_lastNSet!; Bool_tRooAbsArg::_localNoInhibitDirty! Prevent 'AlwaysDirty' mode for this node; static Int_tRooPrintable::_nameLength; TNamed*RooAbsArg::_namePtr! Do not persist. Pointer",MatchSource.WIKI,root/html602/RooAbsHiddenReal.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsHiddenReal.html
https://root.cern/root/html602/RooAbsHiddenReal.html:34578,Performance,cache,caches,34578,"tected:. set<string>RooAbsArg::_boolAttribBoolean attributes; set<string>RooAbsArg::_boolAttribTransient! Transient boolean attributes (not copied in ctor); Bool_tRooAbsReal::_boolValue! Transient cache for bool values from tree branches; UChar_tRooAbsReal::_byteValue! Transient cache for byte values from tree branches; static Bool_tRooAbsReal::_cacheCheckIf true, always validate contents of clean which outcome of evaluate(); deque<RooAbsCache*>RooAbsArg::_cacheListlist of caches; RooRefCountListRooAbsArg::_clientListlist of client objects; RooRefCountListRooAbsArg::_clientListShapesubset of clients that requested shape dirty flag propagation; RooRefCountListRooAbsArg::_clientListValuesubset of clients that requested value dirty flag propagation; TIterator*RooAbsArg::_clientShapeIter! Iterator over _clientListShape; TIterator*RooAbsArg::_clientValueIter! Iterator over _clientListValue; Bool_tRooAbsArg::_deleteWatch! Delete watch flag; static RooCategory*_dummyBlindState; RooExpensiveObjectCache*RooAbsArg::_eocachePointer to global cache manager for any expensive components created by this object; Bool_tRooAbsArg::_fastAllow fast access mode in getVal() and proxies; Float_tRooAbsReal::_floatValue! Transient cache for floating point values from tree branches; Bool_tRooAbsReal::_forceNumIntForce numerical integration if flag set; static Bool_tRooAbsReal::_globalSelectCompGlobal activation switch for component selection; static Bool_tRooAbsReal::_hideOffsetOffset hiding flag; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; Int_tRooAbsReal::_intValue! Transient cache for integer values from tree branches; Bool_tRooAbsArg::_isConstant! Cached isConstant status; TStringRooAbsReal::_labelPlot label for objects value; RooArgSet*RooAbsReal::_lastNSet!; Bool_tRooAbsArg::_localNoInhibitDirty! Prevent 'AlwaysDirty' mode for this node; static Int_tRooPrintable::_nameLength; TNamed*RooAbsArg::_namePtr! Do not persist. Pointer",MatchSource.WIKI,root/html602/RooAbsHiddenReal.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsHiddenReal.html
https://root.cern/root/html602/RooAbsHiddenReal.html:35147,Performance,cache,cache,35147,"tected:. set<string>RooAbsArg::_boolAttribBoolean attributes; set<string>RooAbsArg::_boolAttribTransient! Transient boolean attributes (not copied in ctor); Bool_tRooAbsReal::_boolValue! Transient cache for bool values from tree branches; UChar_tRooAbsReal::_byteValue! Transient cache for byte values from tree branches; static Bool_tRooAbsReal::_cacheCheckIf true, always validate contents of clean which outcome of evaluate(); deque<RooAbsCache*>RooAbsArg::_cacheListlist of caches; RooRefCountListRooAbsArg::_clientListlist of client objects; RooRefCountListRooAbsArg::_clientListShapesubset of clients that requested shape dirty flag propagation; RooRefCountListRooAbsArg::_clientListValuesubset of clients that requested value dirty flag propagation; TIterator*RooAbsArg::_clientShapeIter! Iterator over _clientListShape; TIterator*RooAbsArg::_clientValueIter! Iterator over _clientListValue; Bool_tRooAbsArg::_deleteWatch! Delete watch flag; static RooCategory*_dummyBlindState; RooExpensiveObjectCache*RooAbsArg::_eocachePointer to global cache manager for any expensive components created by this object; Bool_tRooAbsArg::_fastAllow fast access mode in getVal() and proxies; Float_tRooAbsReal::_floatValue! Transient cache for floating point values from tree branches; Bool_tRooAbsReal::_forceNumIntForce numerical integration if flag set; static Bool_tRooAbsReal::_globalSelectCompGlobal activation switch for component selection; static Bool_tRooAbsReal::_hideOffsetOffset hiding flag; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; Int_tRooAbsReal::_intValue! Transient cache for integer values from tree branches; Bool_tRooAbsArg::_isConstant! Cached isConstant status; TStringRooAbsReal::_labelPlot label for objects value; RooArgSet*RooAbsReal::_lastNSet!; Bool_tRooAbsArg::_localNoInhibitDirty! Prevent 'AlwaysDirty' mode for this node; static Int_tRooPrintable::_nameLength; TNamed*RooAbsArg::_namePtr! Do not persist. Pointer",MatchSource.WIKI,root/html602/RooAbsHiddenReal.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsHiddenReal.html
https://root.cern/root/html602/RooAbsHiddenReal.html:35326,Performance,cache,cache,35326,"tected:. set<string>RooAbsArg::_boolAttribBoolean attributes; set<string>RooAbsArg::_boolAttribTransient! Transient boolean attributes (not copied in ctor); Bool_tRooAbsReal::_boolValue! Transient cache for bool values from tree branches; UChar_tRooAbsReal::_byteValue! Transient cache for byte values from tree branches; static Bool_tRooAbsReal::_cacheCheckIf true, always validate contents of clean which outcome of evaluate(); deque<RooAbsCache*>RooAbsArg::_cacheListlist of caches; RooRefCountListRooAbsArg::_clientListlist of client objects; RooRefCountListRooAbsArg::_clientListShapesubset of clients that requested shape dirty flag propagation; RooRefCountListRooAbsArg::_clientListValuesubset of clients that requested value dirty flag propagation; TIterator*RooAbsArg::_clientShapeIter! Iterator over _clientListShape; TIterator*RooAbsArg::_clientValueIter! Iterator over _clientListValue; Bool_tRooAbsArg::_deleteWatch! Delete watch flag; static RooCategory*_dummyBlindState; RooExpensiveObjectCache*RooAbsArg::_eocachePointer to global cache manager for any expensive components created by this object; Bool_tRooAbsArg::_fastAllow fast access mode in getVal() and proxies; Float_tRooAbsReal::_floatValue! Transient cache for floating point values from tree branches; Bool_tRooAbsReal::_forceNumIntForce numerical integration if flag set; static Bool_tRooAbsReal::_globalSelectCompGlobal activation switch for component selection; static Bool_tRooAbsReal::_hideOffsetOffset hiding flag; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; Int_tRooAbsReal::_intValue! Transient cache for integer values from tree branches; Bool_tRooAbsArg::_isConstant! Cached isConstant status; TStringRooAbsReal::_labelPlot label for objects value; RooArgSet*RooAbsReal::_lastNSet!; Bool_tRooAbsArg::_localNoInhibitDirty! Prevent 'AlwaysDirty' mode for this node; static Int_tRooPrintable::_nameLength; TNamed*RooAbsArg::_namePtr! Do not persist. Pointer",MatchSource.WIKI,root/html602/RooAbsHiddenReal.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsHiddenReal.html
https://root.cern/root/html602/RooAbsHiddenReal.html:35739,Performance,cache,cache,35739,"tected:. set<string>RooAbsArg::_boolAttribBoolean attributes; set<string>RooAbsArg::_boolAttribTransient! Transient boolean attributes (not copied in ctor); Bool_tRooAbsReal::_boolValue! Transient cache for bool values from tree branches; UChar_tRooAbsReal::_byteValue! Transient cache for byte values from tree branches; static Bool_tRooAbsReal::_cacheCheckIf true, always validate contents of clean which outcome of evaluate(); deque<RooAbsCache*>RooAbsArg::_cacheListlist of caches; RooRefCountListRooAbsArg::_clientListlist of client objects; RooRefCountListRooAbsArg::_clientListShapesubset of clients that requested shape dirty flag propagation; RooRefCountListRooAbsArg::_clientListValuesubset of clients that requested value dirty flag propagation; TIterator*RooAbsArg::_clientShapeIter! Iterator over _clientListShape; TIterator*RooAbsArg::_clientValueIter! Iterator over _clientListValue; Bool_tRooAbsArg::_deleteWatch! Delete watch flag; static RooCategory*_dummyBlindState; RooExpensiveObjectCache*RooAbsArg::_eocachePointer to global cache manager for any expensive components created by this object; Bool_tRooAbsArg::_fastAllow fast access mode in getVal() and proxies; Float_tRooAbsReal::_floatValue! Transient cache for floating point values from tree branches; Bool_tRooAbsReal::_forceNumIntForce numerical integration if flag set; static Bool_tRooAbsReal::_globalSelectCompGlobal activation switch for component selection; static Bool_tRooAbsReal::_hideOffsetOffset hiding flag; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; Int_tRooAbsReal::_intValue! Transient cache for integer values from tree branches; Bool_tRooAbsArg::_isConstant! Cached isConstant status; TStringRooAbsReal::_labelPlot label for objects value; RooArgSet*RooAbsReal::_lastNSet!; Bool_tRooAbsArg::_localNoInhibitDirty! Prevent 'AlwaysDirty' mode for this node; static Int_tRooPrintable::_nameLength; TNamed*RooAbsArg::_namePtr! Do not persist. Pointer",MatchSource.WIKI,root/html602/RooAbsHiddenReal.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsHiddenReal.html
https://root.cern/root/html602/RooAbsHiddenReal.html:36615,Performance,cache,cache,36615,"label for objects value; RooArgSet*RooAbsReal::_lastNSet!; Bool_tRooAbsArg::_localNoInhibitDirty! Prevent 'AlwaysDirty' mode for this node; static Int_tRooPrintable::_nameLength; TNamed*RooAbsArg::_namePtr! Do not persist. Pointer to global instance of string that matches object named; RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; Int_tRooAbsReal::_plotBinsNumber of plot bins; Double_tRooAbsReal::_plotMaxMaximum of plot range; Double_tRooAbsReal::_plotMinMinimum of plot range; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; RooRefArrayRooAbsArg::_proxyListlist of proxies; Char_tRooAbsReal::_sbyteValue! Transient cache for signed byte values from tree branches; Bool_tRooAbsReal::_selectComp! Component selection flag for RooAbsPdf::plotCompOn; RooRefCountListRooAbsArg::_serverListlist of server objects; Bool_tRooAbsArg::_shapeDirtyFlag set if value needs recalculating because input shapes modified; RooNumIntConfig*RooAbsReal::_specIntegratorConfigNumeric integrator configuration specific for this object; RooCategoryProxy_stateProxy to hiding state category; map<string,string>RooAbsArg::_stringAttribString attributes; Bool_tRooAbsReal::_treeVar!do not persist; UInt_tRooAbsReal::_uintValue! Transient cache for unsigned integer values from tree branches; TStringRooAbsReal::_unitUnit for objects value; Double_tRooAbsReal::_valueCache for current value of object; Bool_tRooAbsArg::_valueDirtyFlag set if value needs recalculating because input values modified; static Bool_tRooAbsArg::_verboseDirtyStatic flag controlling verbose messaging for dirty state changes; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; RooAbsHiddenReal(const char* name, const char* title, const char* unit = """"); Constructor. RooAbsHiddenReal(const char* name, cons",MatchSource.WIKI,root/html602/RooAbsHiddenReal.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsHiddenReal.html
https://root.cern/root/html602/RooAbsHiddenReal.html:37211,Performance,cache,cache,37211,"label for objects value; RooArgSet*RooAbsReal::_lastNSet!; Bool_tRooAbsArg::_localNoInhibitDirty! Prevent 'AlwaysDirty' mode for this node; static Int_tRooPrintable::_nameLength; TNamed*RooAbsArg::_namePtr! Do not persist. Pointer to global instance of string that matches object named; RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; Int_tRooAbsReal::_plotBinsNumber of plot bins; Double_tRooAbsReal::_plotMaxMaximum of plot range; Double_tRooAbsReal::_plotMinMinimum of plot range; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; RooRefArrayRooAbsArg::_proxyListlist of proxies; Char_tRooAbsReal::_sbyteValue! Transient cache for signed byte values from tree branches; Bool_tRooAbsReal::_selectComp! Component selection flag for RooAbsPdf::plotCompOn; RooRefCountListRooAbsArg::_serverListlist of server objects; Bool_tRooAbsArg::_shapeDirtyFlag set if value needs recalculating because input shapes modified; RooNumIntConfig*RooAbsReal::_specIntegratorConfigNumeric integrator configuration specific for this object; RooCategoryProxy_stateProxy to hiding state category; map<string,string>RooAbsArg::_stringAttribString attributes; Bool_tRooAbsReal::_treeVar!do not persist; UInt_tRooAbsReal::_uintValue! Transient cache for unsigned integer values from tree branches; TStringRooAbsReal::_unitUnit for objects value; Double_tRooAbsReal::_valueCache for current value of object; Bool_tRooAbsArg::_valueDirtyFlag set if value needs recalculating because input values modified; static Bool_tRooAbsArg::_verboseDirtyStatic flag controlling verbose messaging for dirty state changes; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; RooAbsHiddenReal(const char* name, const char* title, const char* unit = """"); Constructor. RooAbsHiddenReal(const char* name, cons",MatchSource.WIKI,root/html602/RooAbsHiddenReal.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsHiddenReal.html
https://root.cern/root/html602/RooAbsHiddenReal.html:12085,Security,hash,hash,12085,"bsArg::findConstantNodes(const RooArgSet& observables, RooArgSet& cacheList); Bool_tRooAbsArg::findConstantNodes(const RooArgSet& observables, RooArgSet& cacheList, RooLinkedList& processedNodes); RooAbsArg*RooAbsArg::findNewServer(const RooAbsCollection& newSet, Bool_t nameChange) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; Double_tRooAbsReal::findRoot(RooRealVar& x, Double_t xmin, Double_t xmax, Double_t yval); RooAbsArg*RooAbsArg::findServer(const char* name) const; RooAbsArg*RooAbsArg::findServer(const RooAbsArg& arg) const; RooAbsArg*RooAbsArg::findServer(Int_t index) const; virtual voidRooAbsReal::fixAddCoefNormalization(const RooArgSet& addNormSet = RooArgSet(), Bool_t force = kTRUE); virtual voidRooAbsReal::fixAddCoefRange(const char* rangeName = 0, Bool_t force = kTRUE); static UInt_tRooAbsArg::fnv1a32(const char* data); static UInt_tRooAbsArg::fnv1a32(const char* data, ULong_t sz, UInt_t hash = fnv1a32start); static ULong64_tRooAbsArg::fnv1a64(const char* data); static ULong64_tRooAbsArg::fnv1a64(const char* data, ULong_t sz, ULong64_t hash = fnv1a64start); virtual Bool_tRooAbsReal::forceAnalyticalInt(const RooAbsArg&) const; virtual voidRooAbsReal::forceNumInt(Bool_t flag = kTRUE); RooFunctor*RooAbsReal::functor(const RooArgList& obs, const RooArgList& pars = RooArgList(), const RooArgSet& nset = RooArgSet()) const; virtual Int_tRooAbsReal::getAnalyticalIntegral(RooArgSet& allVars, RooArgSet& analVars, const char* rangeName = 0) const; virtual Int_tRooAbsReal::getAnalyticalIntegralWN(RooArgSet& allVars, RooArgSet& analVars, const RooArgSet* normSet, const char* rangeName = 0) const; Bool_tRooAbsArg::getAttribute(const Text_t* name) const; RooAbsCache*RooAbsArg::getCache(Int_t index) const; RooLinkedListRooAbsArg::getCloningAncestors() const; RooArgSet*RooAbsArg::getComponents() const; RooArgSet*RooAbsArg::getDependents(const RooArgSet& set) const; RooArgSet*RooAbsArg::ge",MatchSource.WIKI,root/html602/RooAbsHiddenReal.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsHiddenReal.html
https://root.cern/root/html602/RooAbsHiddenReal.html:12236,Security,hash,hash,12236,"t& cacheList, RooLinkedList& processedNodes); RooAbsArg*RooAbsArg::findNewServer(const RooAbsCollection& newSet, Bool_t nameChange) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; Double_tRooAbsReal::findRoot(RooRealVar& x, Double_t xmin, Double_t xmax, Double_t yval); RooAbsArg*RooAbsArg::findServer(const char* name) const; RooAbsArg*RooAbsArg::findServer(const RooAbsArg& arg) const; RooAbsArg*RooAbsArg::findServer(Int_t index) const; virtual voidRooAbsReal::fixAddCoefNormalization(const RooArgSet& addNormSet = RooArgSet(), Bool_t force = kTRUE); virtual voidRooAbsReal::fixAddCoefRange(const char* rangeName = 0, Bool_t force = kTRUE); static UInt_tRooAbsArg::fnv1a32(const char* data); static UInt_tRooAbsArg::fnv1a32(const char* data, ULong_t sz, UInt_t hash = fnv1a32start); static ULong64_tRooAbsArg::fnv1a64(const char* data); static ULong64_tRooAbsArg::fnv1a64(const char* data, ULong_t sz, ULong64_t hash = fnv1a64start); virtual Bool_tRooAbsReal::forceAnalyticalInt(const RooAbsArg&) const; virtual voidRooAbsReal::forceNumInt(Bool_t flag = kTRUE); RooFunctor*RooAbsReal::functor(const RooArgList& obs, const RooArgList& pars = RooArgList(), const RooArgSet& nset = RooArgSet()) const; virtual Int_tRooAbsReal::getAnalyticalIntegral(RooArgSet& allVars, RooArgSet& analVars, const char* rangeName = 0) const; virtual Int_tRooAbsReal::getAnalyticalIntegralWN(RooArgSet& allVars, RooArgSet& analVars, const RooArgSet* normSet, const char* rangeName = 0) const; Bool_tRooAbsArg::getAttribute(const Text_t* name) const; RooAbsCache*RooAbsArg::getCache(Int_t index) const; RooLinkedListRooAbsArg::getCloningAncestors() const; RooArgSet*RooAbsArg::getComponents() const; RooArgSet*RooAbsArg::getDependents(const RooArgSet& set) const; RooArgSet*RooAbsArg::getDependents(const RooAbsData* set) const; RooArgSet*RooAbsArg::getDependents(const RooArgSet* depList) const; virtual Option_t*TObject::GetDrawOption()",MatchSource.WIKI,root/html602/RooAbsHiddenReal.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsHiddenReal.html
https://root.cern/root/html602/RooAbsHiddenReal.html:34474,Security,validat,validate,34474,"tected:. set<string>RooAbsArg::_boolAttribBoolean attributes; set<string>RooAbsArg::_boolAttribTransient! Transient boolean attributes (not copied in ctor); Bool_tRooAbsReal::_boolValue! Transient cache for bool values from tree branches; UChar_tRooAbsReal::_byteValue! Transient cache for byte values from tree branches; static Bool_tRooAbsReal::_cacheCheckIf true, always validate contents of clean which outcome of evaluate(); deque<RooAbsCache*>RooAbsArg::_cacheListlist of caches; RooRefCountListRooAbsArg::_clientListlist of client objects; RooRefCountListRooAbsArg::_clientListShapesubset of clients that requested shape dirty flag propagation; RooRefCountListRooAbsArg::_clientListValuesubset of clients that requested value dirty flag propagation; TIterator*RooAbsArg::_clientShapeIter! Iterator over _clientListShape; TIterator*RooAbsArg::_clientValueIter! Iterator over _clientListValue; Bool_tRooAbsArg::_deleteWatch! Delete watch flag; static RooCategory*_dummyBlindState; RooExpensiveObjectCache*RooAbsArg::_eocachePointer to global cache manager for any expensive components created by this object; Bool_tRooAbsArg::_fastAllow fast access mode in getVal() and proxies; Float_tRooAbsReal::_floatValue! Transient cache for floating point values from tree branches; Bool_tRooAbsReal::_forceNumIntForce numerical integration if flag set; static Bool_tRooAbsReal::_globalSelectCompGlobal activation switch for component selection; static Bool_tRooAbsReal::_hideOffsetOffset hiding flag; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; Int_tRooAbsReal::_intValue! Transient cache for integer values from tree branches; Bool_tRooAbsArg::_isConstant! Cached isConstant status; TStringRooAbsReal::_labelPlot label for objects value; RooArgSet*RooAbsReal::_lastNSet!; Bool_tRooAbsArg::_localNoInhibitDirty! Prevent 'AlwaysDirty' mode for this node; static Int_tRooPrintable::_nameLength; TNamed*RooAbsArg::_namePtr! Do not persist. Pointer",MatchSource.WIKI,root/html602/RooAbsHiddenReal.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsHiddenReal.html
https://root.cern/root/html602/RooAbsHiddenReal.html:35247,Security,access,access,35247,"tected:. set<string>RooAbsArg::_boolAttribBoolean attributes; set<string>RooAbsArg::_boolAttribTransient! Transient boolean attributes (not copied in ctor); Bool_tRooAbsReal::_boolValue! Transient cache for bool values from tree branches; UChar_tRooAbsReal::_byteValue! Transient cache for byte values from tree branches; static Bool_tRooAbsReal::_cacheCheckIf true, always validate contents of clean which outcome of evaluate(); deque<RooAbsCache*>RooAbsArg::_cacheListlist of caches; RooRefCountListRooAbsArg::_clientListlist of client objects; RooRefCountListRooAbsArg::_clientListShapesubset of clients that requested shape dirty flag propagation; RooRefCountListRooAbsArg::_clientListValuesubset of clients that requested value dirty flag propagation; TIterator*RooAbsArg::_clientShapeIter! Iterator over _clientListShape; TIterator*RooAbsArg::_clientValueIter! Iterator over _clientListValue; Bool_tRooAbsArg::_deleteWatch! Delete watch flag; static RooCategory*_dummyBlindState; RooExpensiveObjectCache*RooAbsArg::_eocachePointer to global cache manager for any expensive components created by this object; Bool_tRooAbsArg::_fastAllow fast access mode in getVal() and proxies; Float_tRooAbsReal::_floatValue! Transient cache for floating point values from tree branches; Bool_tRooAbsReal::_forceNumIntForce numerical integration if flag set; static Bool_tRooAbsReal::_globalSelectCompGlobal activation switch for component selection; static Bool_tRooAbsReal::_hideOffsetOffset hiding flag; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; Int_tRooAbsReal::_intValue! Transient cache for integer values from tree branches; Bool_tRooAbsArg::_isConstant! Cached isConstant status; TStringRooAbsReal::_labelPlot label for objects value; RooArgSet*RooAbsReal::_lastNSet!; Bool_tRooAbsArg::_localNoInhibitDirty! Prevent 'AlwaysDirty' mode for this node; static Int_tRooPrintable::_nameLength; TNamed*RooAbsArg::_namePtr! Do not persist. Pointer",MatchSource.WIKI,root/html602/RooAbsHiddenReal.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsHiddenReal.html
https://root.cern/root/html602/RooAbsHiddenReal.html:38756,Security,access,accessor,38756,"AbsReal::_unitUnit for objects value; Double_tRooAbsReal::_valueCache for current value of object; Bool_tRooAbsArg::_valueDirtyFlag set if value needs recalculating because input values modified; static Bool_tRooAbsArg::_verboseDirtyStatic flag controlling verbose messaging for dirty state changes; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; RooAbsHiddenReal(const char* name, const char* title, const char* unit = """"); Constructor. RooAbsHiddenReal(const char* name, const char* title, RooAbsCategory& blindState, const char* unit = """"); Constructor. RooAbsHiddenReal(const RooAbsHiddenReal& other, const char* name = 0); Copy constructor. ~RooAbsHiddenReal(); Destructor. void printValue(ostream& stream) const; Special version of printValue that doesn't reveal the objects value. Bool_t readFromStream(istream& is, Bool_t compact, Bool_t verbose = kFALSE); Special version of readFromStream that disallows reading from stream. void writeToStream(ostream& os, Bool_t compact) const; Special version of writeToStream that disallows reading from stream. RooAbsCategory& dummyBlindState() const; Return reference to internal dummy RooCategory implementation; blinding state switch. inline RooAbsHiddenReal(); Constructors, assignment etc. Bool_t isHidden() const; If true, hiding mode is active. Double_t getHiddenVal(const RooArgSet* nset = 0) const; Bypass accessor to function value that also works in hidden mode. Double_t getValV(const RooArgSet* nset = 0) const; This is dubious from a C++ point of view, but it blocks the interactive user; from accidentally calling getVal() without explicit cast, which is the whole; point of this class. » Last changed: Tue Jun 30 14:30:08 2015 » Last generated: 2015-06-30 14:30; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html602/RooAbsHiddenReal.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsHiddenReal.html
https://root.cern/root/html602/RooAbsHiddenReal.html:8965,Testability,test,testArg,8965,"l*RooAbsReal::createPlotProjection(const RooArgSet& dependentVars, const RooArgSet* projectedVars, RooArgSet*& cloneSet, const char* rangeName = 0, const RooArgSet* condObs = 0) const; virtual RooAbsReal*RooAbsReal::createProfile(const RooArgSet& paramsOfInterest); RooAbsReal*RooAbsReal::createRunningIntegral(const RooArgSet& iset, const RooArgSet& nset = RooArgSet()); RooAbsReal*RooAbsReal::createRunningIntegral(const RooArgSet& iset, const RooCmdArg& arg1, const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()); RooAbsReal*RooAbsReal::createScanRI(const RooArgSet& iset, const RooArgSet& nset, Int_t numScanBins, Int_t intOrder); virtual Double_tRooAbsReal::defaultErrorLevel() const; static RooNumIntConfig*RooAbsReal::defaultIntegratorConfig(); virtual Int_tRooAbsArg::defaultPrintContents(Option_t* opt) const; static ostream&RooPrintable::defaultPrintStream(ostream* os = 0); virtual RooPrintable::StyleOptionRooPrintable::defaultPrintStyle(Option_t* opt) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; Bool_tRooAbsArg::dependentOverlaps(const RooAbsData* dset, const RooAbsArg& testArg) const; Bool_tRooAbsArg::dependentOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; Bool_tRooAbsArg::dependsOn(const RooAbsCollection& serverList, const RooAbsArg* ignoreArg = 0, Bool_t valueOnly = kFALSE) const; Bool_tRooAbsArg::dependsOn(const RooAbsArg& server, const RooAbsArg* ignoreArg = 0, Bool_t valueOnly = kFALSE) const; Bool_tRooAbsArg::dependsOnValue(const RooAbsCollection& serverList, const RooAbsArg* ignoreArg = 0) const; Bool_tRooAbsArg::dependsOnValue(const RooAbsArg& server, const RooAbsArg* ignoreArg = 0) const; RooDerivative*RooAbsReal::derivative(RooRealVar& obs, Int_t order = 1, Double_t eps = 0.",MatchSource.WIKI,root/html602/RooAbsHiddenReal.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsHiddenReal.html
https://root.cern/root/html602/RooAbsHiddenReal.html:9059,Testability,test,testArg,9059,"l*RooAbsReal::createPlotProjection(const RooArgSet& dependentVars, const RooArgSet* projectedVars, RooArgSet*& cloneSet, const char* rangeName = 0, const RooArgSet* condObs = 0) const; virtual RooAbsReal*RooAbsReal::createProfile(const RooArgSet& paramsOfInterest); RooAbsReal*RooAbsReal::createRunningIntegral(const RooArgSet& iset, const RooArgSet& nset = RooArgSet()); RooAbsReal*RooAbsReal::createRunningIntegral(const RooArgSet& iset, const RooCmdArg& arg1, const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()); RooAbsReal*RooAbsReal::createScanRI(const RooArgSet& iset, const RooArgSet& nset, Int_t numScanBins, Int_t intOrder); virtual Double_tRooAbsReal::defaultErrorLevel() const; static RooNumIntConfig*RooAbsReal::defaultIntegratorConfig(); virtual Int_tRooAbsArg::defaultPrintContents(Option_t* opt) const; static ostream&RooPrintable::defaultPrintStream(ostream* os = 0); virtual RooPrintable::StyleOptionRooPrintable::defaultPrintStyle(Option_t* opt) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; Bool_tRooAbsArg::dependentOverlaps(const RooAbsData* dset, const RooAbsArg& testArg) const; Bool_tRooAbsArg::dependentOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; Bool_tRooAbsArg::dependsOn(const RooAbsCollection& serverList, const RooAbsArg* ignoreArg = 0, Bool_t valueOnly = kFALSE) const; Bool_tRooAbsArg::dependsOn(const RooAbsArg& server, const RooAbsArg* ignoreArg = 0, Bool_t valueOnly = kFALSE) const; Bool_tRooAbsArg::dependsOnValue(const RooAbsCollection& serverList, const RooAbsArg* ignoreArg = 0) const; Bool_tRooAbsArg::dependsOnValue(const RooAbsArg& server, const RooAbsArg* ignoreArg = 0) const; RooDerivative*RooAbsReal::derivative(RooRealVar& obs, Int_t order = 1, Double_t eps = 0.",MatchSource.WIKI,root/html602/RooAbsHiddenReal.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsHiddenReal.html
https://root.cern/root/html602/RooAbsHiddenReal.html:17614,Testability,log,logEvalError,17614,"Object::IsFolder() const; virtual Bool_tRooAbsArg::isFundamental() const; Bool_tisHidden() const; virtual Bool_tRooAbsReal::isIdentical(const RooAbsArg& other, Bool_t assumeSameType = kFALSE); virtual Bool_tRooAbsArg::isLValue() const; virtual Bool_tRooAbsReal::isOffsetting() const; Bool_tTObject::IsOnHeap() const; Bool_tRooAbsArg::isShapeDirty() const; Bool_tRooAbsArg::isShapeServer(const RooAbsArg& arg) const; Bool_tRooAbsArg::isShapeServer(const char* name) const; virtual Bool_tRooAbsArg::IsSortable() const; Bool_tRooAbsArg::isValueDirty() const; Bool_tRooAbsArg::isValueDirtyAndClear() const; Bool_tRooAbsArg::isValueOrShapeDirtyAndClear() const; Bool_tRooAbsArg::isValueServer(const RooAbsArg& arg) const; Bool_tRooAbsArg::isValueServer(const char* name) const; Bool_tTObject::IsZombie() const; voidRooAbsArg::leafNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t recurseNonDerived = kFALSE) const; Bool_tRooAbsArg::localNoDirtyInhibit() const; voidRooAbsReal::logEvalError(const char* message, const char* serverValueString = 0) const; static voidRooAbsReal::logEvalError(const RooAbsReal* originator, const char* origName, const char* message, const char* serverValueString = 0); virtual voidTNamed::ls(Option_t* option = """") const; virtual Double_tRooAbsReal::maxVal(Int_t code) const; voidTObject::MayNotUse(const char* method) const; RooAbsMoment*RooAbsReal::mean(RooRealVar& obs); RooAbsMoment*RooAbsReal::mean(RooRealVar& obs, const RooArgSet& nset); virtual Int_tRooAbsReal::minTrialSamples(const RooArgSet&) const; RooAbsMoment*RooAbsReal::moment(RooRealVar& obs, Int_t order, Bool_t central, Bool_t takeRoot); RooAbsMoment*RooAbsReal::moment(RooRealVar& obs, const RooArgSet& normObs, Int_t order, Bool_t central, Bool_t takeRoot, Bool_t intNormObs); static voidRooPrintable::nameFieldLength(Int_t newLen); const TNamed*RooAbsArg::namePtr() const; virtual Bool_tTObject::Notify(); Int_tRooAbsArg::numCaches() const; static Int_tRooAbsReal::numEvalErrorItems(",MatchSource.WIKI,root/html602/RooAbsHiddenReal.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsHiddenReal.html
https://root.cern/root/html602/RooAbsHiddenReal.html:17713,Testability,log,logEvalError,17713,"irtual Bool_tRooAbsReal::isIdentical(const RooAbsArg& other, Bool_t assumeSameType = kFALSE); virtual Bool_tRooAbsArg::isLValue() const; virtual Bool_tRooAbsReal::isOffsetting() const; Bool_tTObject::IsOnHeap() const; Bool_tRooAbsArg::isShapeDirty() const; Bool_tRooAbsArg::isShapeServer(const RooAbsArg& arg) const; Bool_tRooAbsArg::isShapeServer(const char* name) const; virtual Bool_tRooAbsArg::IsSortable() const; Bool_tRooAbsArg::isValueDirty() const; Bool_tRooAbsArg::isValueDirtyAndClear() const; Bool_tRooAbsArg::isValueOrShapeDirtyAndClear() const; Bool_tRooAbsArg::isValueServer(const RooAbsArg& arg) const; Bool_tRooAbsArg::isValueServer(const char* name) const; Bool_tTObject::IsZombie() const; voidRooAbsArg::leafNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t recurseNonDerived = kFALSE) const; Bool_tRooAbsArg::localNoDirtyInhibit() const; voidRooAbsReal::logEvalError(const char* message, const char* serverValueString = 0) const; static voidRooAbsReal::logEvalError(const RooAbsReal* originator, const char* origName, const char* message, const char* serverValueString = 0); virtual voidTNamed::ls(Option_t* option = """") const; virtual Double_tRooAbsReal::maxVal(Int_t code) const; voidTObject::MayNotUse(const char* method) const; RooAbsMoment*RooAbsReal::mean(RooRealVar& obs); RooAbsMoment*RooAbsReal::mean(RooRealVar& obs, const RooArgSet& nset); virtual Int_tRooAbsReal::minTrialSamples(const RooArgSet&) const; RooAbsMoment*RooAbsReal::moment(RooRealVar& obs, Int_t order, Bool_t central, Bool_t takeRoot); RooAbsMoment*RooAbsReal::moment(RooRealVar& obs, const RooArgSet& normObs, Int_t order, Bool_t central, Bool_t takeRoot, Bool_t intNormObs); static voidRooPrintable::nameFieldLength(Int_t newLen); const TNamed*RooAbsArg::namePtr() const; virtual Bool_tTObject::Notify(); Int_tRooAbsArg::numCaches() const; static Int_tRooAbsReal::numEvalErrorItems(); static Int_tRooAbsReal::numEvalErrors(); Bool_tRooAbsArg::observableOverlaps(const RooAbsData* d",MatchSource.WIKI,root/html602/RooAbsHiddenReal.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsHiddenReal.html
https://root.cern/root/html602/RooAbsHiddenReal.html:18742,Testability,test,testArg,18742,"iginator, const char* origName, const char* message, const char* serverValueString = 0); virtual voidTNamed::ls(Option_t* option = """") const; virtual Double_tRooAbsReal::maxVal(Int_t code) const; voidTObject::MayNotUse(const char* method) const; RooAbsMoment*RooAbsReal::mean(RooRealVar& obs); RooAbsMoment*RooAbsReal::mean(RooRealVar& obs, const RooArgSet& nset); virtual Int_tRooAbsReal::minTrialSamples(const RooArgSet&) const; RooAbsMoment*RooAbsReal::moment(RooRealVar& obs, Int_t order, Bool_t central, Bool_t takeRoot); RooAbsMoment*RooAbsReal::moment(RooRealVar& obs, const RooArgSet& normObs, Int_t order, Bool_t central, Bool_t takeRoot, Bool_t intNormObs); static voidRooPrintable::nameFieldLength(Int_t newLen); const TNamed*RooAbsArg::namePtr() const; virtual Bool_tTObject::Notify(); Int_tRooAbsArg::numCaches() const; static Int_tRooAbsReal::numEvalErrorItems(); static Int_tRooAbsReal::numEvalErrors(); Bool_tRooAbsArg::observableOverlaps(const RooAbsData* dset, const RooAbsArg& testArg) const; Bool_tRooAbsArg::observableOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; virtual Double_tRooAbsReal::offset() const; voidTObject::operator delete(void* ptr); voidTObject::operator delete(void* ptr, void* vp); voidTObject::operator delete[](void* ptr); voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); RooAbsHiddenReal&operator=(const RooAbsHiddenReal&); Bool_tRooAbsReal::operator==(Double_t value) const; virtual Bool_tRooAbsReal::operator==(const RooAbsArg& other); RooAbsArg::OperModeRooAbsArg::operMode() const; virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables); virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables, RooArgSet& optNodes, Ro",MatchSource.WIKI,root/html602/RooAbsHiddenReal.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsHiddenReal.html
https://root.cern/root/html602/RooAbsHiddenReal.html:18837,Testability,test,testArg,18837,"l voidTNamed::ls(Option_t* option = """") const; virtual Double_tRooAbsReal::maxVal(Int_t code) const; voidTObject::MayNotUse(const char* method) const; RooAbsMoment*RooAbsReal::mean(RooRealVar& obs); RooAbsMoment*RooAbsReal::mean(RooRealVar& obs, const RooArgSet& nset); virtual Int_tRooAbsReal::minTrialSamples(const RooArgSet&) const; RooAbsMoment*RooAbsReal::moment(RooRealVar& obs, Int_t order, Bool_t central, Bool_t takeRoot); RooAbsMoment*RooAbsReal::moment(RooRealVar& obs, const RooArgSet& normObs, Int_t order, Bool_t central, Bool_t takeRoot, Bool_t intNormObs); static voidRooPrintable::nameFieldLength(Int_t newLen); const TNamed*RooAbsArg::namePtr() const; virtual Bool_tTObject::Notify(); Int_tRooAbsArg::numCaches() const; static Int_tRooAbsReal::numEvalErrorItems(); static Int_tRooAbsReal::numEvalErrors(); Bool_tRooAbsArg::observableOverlaps(const RooAbsData* dset, const RooAbsArg& testArg) const; Bool_tRooAbsArg::observableOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; virtual Double_tRooAbsReal::offset() const; voidTObject::operator delete(void* ptr); voidTObject::operator delete(void* ptr, void* vp); voidTObject::operator delete[](void* ptr); voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); RooAbsHiddenReal&operator=(const RooAbsHiddenReal&); Bool_tRooAbsReal::operator==(Double_t value) const; virtual Bool_tRooAbsReal::operator==(const RooAbsArg& other); RooAbsArg::OperModeRooAbsArg::operMode() const; virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables); virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables, RooArgSet& optNodes, RooLinkedList& processedNodes); Bool_tRooAbsArg::overlaps(const RooAbsArg& testArg, Bool_t valueO",MatchSource.WIKI,root/html602/RooAbsHiddenReal.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsHiddenReal.html
https://root.cern/root/html602/RooAbsHiddenReal.html:19819,Testability,test,testArg,19819,"AbsData* dset, const RooAbsArg& testArg) const; Bool_tRooAbsArg::observableOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; virtual Double_tRooAbsReal::offset() const; voidTObject::operator delete(void* ptr); voidTObject::operator delete(void* ptr, void* vp); voidTObject::operator delete[](void* ptr); voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); RooAbsHiddenReal&operator=(const RooAbsHiddenReal&); Bool_tRooAbsReal::operator==(Double_t value) const; virtual Bool_tRooAbsReal::operator==(const RooAbsArg& other); RooAbsArg::OperModeRooAbsArg::operMode() const; virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables); virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables, RooArgSet& optNodes, RooLinkedList& processedNodes); Bool_tRooAbsArg::overlaps(const RooAbsArg& testArg, Bool_t valueOnly = kFALSE) const; const RooArgSet*RooAbsArg::ownedComponents() const; virtual voidTObject::Paint(Option_t* option = """"); virtual RooPlot*RooAbsReal::plotOn(RooPlot* frame, RooLinkedList& cmdList) const; virtual RooPlot*RooAbsReal::plotOn(RooPlot* frame, const RooCmdArg& arg1 = RooCmdArg(), const RooCmdArg& arg2 = RooCmdArg(), const RooCmdArg& arg3 = RooCmdArg(), const RooCmdArg& arg4 = RooCmdArg(), const RooCmdArg& arg5 = RooCmdArg(), const RooCmdArg& arg6 = RooCmdArg(), const RooCmdArg& arg7 = RooCmdArg(), const RooCmdArg& arg8 = RooCmdArg(), const RooCmdArg& arg9 = RooCmdArg(), const RooCmdArg& arg10 = RooCmdArg()) const; virtual list<Double_t>*RooAbsReal::plotSamplingHint(RooAbsRealLValue&, Double_t, Double_t) const; virtual RooPlot*RooAbsReal::plotSliceOn(RooPlot* frame, const RooArgSet& sliceSet, Option_t* drawOptions = ""L"", Double_t scaleFactor = 1.",MatchSource.WIKI,root/html602/RooAbsHiddenReal.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsHiddenReal.html
https://root.cern/root/html602/RooAbsHiddenReal.html:3750,Usability,clear,clearEvalErrorLog,3750,", const RooLinkedList& cmdList); virtual RooFitResult*RooAbsReal::chi2FitTo(RooDataHist& data, const RooCmdArg& arg1 = RooCmdArg::none(), const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()); virtual RooFitResult*RooAbsReal::chi2FitTo(RooDataSet& xydata, const RooCmdArg& arg1 = RooCmdArg::none(), const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); static voidRooAbsReal::clearEvalErrorLog(); voidRooAbsArg::clearShapeDirty() const; voidRooAbsArg::clearValueAndShapeDirty() const; voidRooAbsArg::clearValueDirty() const; TIterator*RooAbsArg::clientIterator() const; virtual TObject*RooAbsArg::clone(const char* newname = 0) const; virtual TObject*RooAbsArg::Clone(const char* newname = 0) const; virtual RooAbsArg*RooAbsArg::cloneTree(const char* newname = 0) const; virtual Int_tRooAbsArg::Compare(const TObject* other) const; virtual voidRooAbsArg::constOptimizeTestStatistic(RooAbsArg::ConstOpCode opcode, Bool_t doAlsoTrackingOpt = kTRUE); virtual voidTNamed::Copy(TObject& named) const; static UInt_tRooAbsArg::crc32(const char* data); static UInt_tRooAbsArg::crc32(const char* data, ULong_t sz, UInt_t crc = 0); virtual RooAbsReal*RooAbsReal::createChi2(RooDataHist& data, const RooLinkedList& cmdList); virtual RooAbsReal*RooAbsReal::createChi2(RooDataSet& data, const RooLinkedList& cmdList); virtual RooAbsReal*RooAbsReal::createChi2(RooDataHist& data, const RooCmdArg& ar",MatchSource.WIKI,root/html602/RooAbsHiddenReal.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsHiddenReal.html
https://root.cern/root/html602/RooAbsHiddenReal.html:3786,Usability,clear,clearShapeDirty,3786,"rtual RooFitResult*RooAbsReal::chi2FitTo(RooDataHist& data, const RooCmdArg& arg1 = RooCmdArg::none(), const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()); virtual RooFitResult*RooAbsReal::chi2FitTo(RooDataSet& xydata, const RooCmdArg& arg1 = RooCmdArg::none(), const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); static voidRooAbsReal::clearEvalErrorLog(); voidRooAbsArg::clearShapeDirty() const; voidRooAbsArg::clearValueAndShapeDirty() const; voidRooAbsArg::clearValueDirty() const; TIterator*RooAbsArg::clientIterator() const; virtual TObject*RooAbsArg::clone(const char* newname = 0) const; virtual TObject*RooAbsArg::Clone(const char* newname = 0) const; virtual RooAbsArg*RooAbsArg::cloneTree(const char* newname = 0) const; virtual Int_tRooAbsArg::Compare(const TObject* other) const; virtual voidRooAbsArg::constOptimizeTestStatistic(RooAbsArg::ConstOpCode opcode, Bool_t doAlsoTrackingOpt = kTRUE); virtual voidTNamed::Copy(TObject& named) const; static UInt_tRooAbsArg::crc32(const char* data); static UInt_tRooAbsArg::crc32(const char* data, ULong_t sz, UInt_t crc = 0); virtual RooAbsReal*RooAbsReal::createChi2(RooDataHist& data, const RooLinkedList& cmdList); virtual RooAbsReal*RooAbsReal::createChi2(RooDataSet& data, const RooLinkedList& cmdList); virtual RooAbsReal*RooAbsReal::createChi2(RooDataHist& data, const RooCmdArg& arg1 = RooCmdArg::none(), const RooCm",MatchSource.WIKI,root/html602/RooAbsHiddenReal.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsHiddenReal.html
https://root.cern/root/html602/RooAbsHiddenReal.html:3826,Usability,clear,clearValueAndShapeDirty,3826,"DataHist& data, const RooCmdArg& arg1 = RooCmdArg::none(), const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()); virtual RooFitResult*RooAbsReal::chi2FitTo(RooDataSet& xydata, const RooCmdArg& arg1 = RooCmdArg::none(), const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); static voidRooAbsReal::clearEvalErrorLog(); voidRooAbsArg::clearShapeDirty() const; voidRooAbsArg::clearValueAndShapeDirty() const; voidRooAbsArg::clearValueDirty() const; TIterator*RooAbsArg::clientIterator() const; virtual TObject*RooAbsArg::clone(const char* newname = 0) const; virtual TObject*RooAbsArg::Clone(const char* newname = 0) const; virtual RooAbsArg*RooAbsArg::cloneTree(const char* newname = 0) const; virtual Int_tRooAbsArg::Compare(const TObject* other) const; virtual voidRooAbsArg::constOptimizeTestStatistic(RooAbsArg::ConstOpCode opcode, Bool_t doAlsoTrackingOpt = kTRUE); virtual voidTNamed::Copy(TObject& named) const; static UInt_tRooAbsArg::crc32(const char* data); static UInt_tRooAbsArg::crc32(const char* data, ULong_t sz, UInt_t crc = 0); virtual RooAbsReal*RooAbsReal::createChi2(RooDataHist& data, const RooLinkedList& cmdList); virtual RooAbsReal*RooAbsReal::createChi2(RooDataSet& data, const RooLinkedList& cmdList); virtual RooAbsReal*RooAbsReal::createChi2(RooDataHist& data, const RooCmdArg& arg1 = RooCmdArg::none(), const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmd",MatchSource.WIKI,root/html602/RooAbsHiddenReal.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsHiddenReal.html
https://root.cern/root/html602/RooAbsHiddenReal.html:3874,Usability,clear,clearValueDirty,3874,"mdArg::none(), const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()); virtual RooFitResult*RooAbsReal::chi2FitTo(RooDataSet& xydata, const RooCmdArg& arg1 = RooCmdArg::none(), const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); static voidRooAbsReal::clearEvalErrorLog(); voidRooAbsArg::clearShapeDirty() const; voidRooAbsArg::clearValueAndShapeDirty() const; voidRooAbsArg::clearValueDirty() const; TIterator*RooAbsArg::clientIterator() const; virtual TObject*RooAbsArg::clone(const char* newname = 0) const; virtual TObject*RooAbsArg::Clone(const char* newname = 0) const; virtual RooAbsArg*RooAbsArg::cloneTree(const char* newname = 0) const; virtual Int_tRooAbsArg::Compare(const TObject* other) const; virtual voidRooAbsArg::constOptimizeTestStatistic(RooAbsArg::ConstOpCode opcode, Bool_t doAlsoTrackingOpt = kTRUE); virtual voidTNamed::Copy(TObject& named) const; static UInt_tRooAbsArg::crc32(const char* data); static UInt_tRooAbsArg::crc32(const char* data, ULong_t sz, UInt_t crc = 0); virtual RooAbsReal*RooAbsReal::createChi2(RooDataHist& data, const RooLinkedList& cmdList); virtual RooAbsReal*RooAbsReal::createChi2(RooDataSet& data, const RooLinkedList& cmdList); virtual RooAbsReal*RooAbsReal::createChi2(RooDataHist& data, const RooCmdArg& arg1 = RooCmdArg::none(), const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdA",MatchSource.WIKI,root/html602/RooAbsHiddenReal.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsHiddenReal.html
https://root.cern/root/html602/RooAbsIntegrator.html:580,Availability,avail,available,580,". RooAbsIntegrator. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » ROOFIT; » ROOFITCORE; » RooAbsIntegrator. class RooAbsIntegrator: public TObject. RooAbsIntegrator is the abstract interface for integrators of real-valued; functions that implement the RooAbsFunc interface.; . Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~RooAbsIntegrator(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); Double_tcalculate(const Double_t* yvec = 0); virtual Bool_tcanIntegrate1D() const; virtual Bool_tcanIntegrate2D() const; virtual Bool_tcanIntegrateND() const; virtual Bool_tcanIntegrateOpenEnded() const; virtual Bool_tcheckLimits() const; static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual RooAbsIntegrator*clone(const RooAbsFunc& function, const RooNumIntConfig& config) const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTOb",MatchSource.WIKI,root/html602/RooAbsIntegrator.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsIntegrator.html
https://root.cern/root/html602/RooAbsIntegrator.html:1890,Availability,error,error,1890,"nIntegrate2D() const; virtual Bool_tcanIntegrateND() const; virtual Bool_tcanIntegrateOpenEnded() const; virtual Bool_tcheckLimits() const; static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual RooAbsIntegrator*clone(const RooAbsFunc& function, const RooNumIntConfig& config) const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual const char*TObject::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual const char*TObject::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTObject::Hash() const; virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) con",MatchSource.WIKI,root/html602/RooAbsIntegrator.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsIntegrator.html
https://root.cern/root/html602/RooAbsIntegrator.html:1974,Availability,error,error,1974,"teOpenEnded() const; virtual Bool_tcheckLimits() const; static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual RooAbsIntegrator*clone(const RooAbsFunc& function, const RooNumIntConfig& config) const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual const char*TObject::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual const char*TObject::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTObject::Hash() const; virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) const; virtual Bool_tTObject::InheritsFrom(const TClass* cl) const; virtual voidTObject",MatchSource.WIKI,root/html602/RooAbsIntegrator.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsIntegrator.html
https://root.cern/root/html602/RooAbsIntegrator.html:364,Deployability,integrat,integrators,364,". RooAbsIntegrator. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » ROOFIT; » ROOFITCORE; » RooAbsIntegrator. class RooAbsIntegrator: public TObject. RooAbsIntegrator is the abstract interface for integrators of real-valued; functions that implement the RooAbsFunc interface.; . Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~RooAbsIntegrator(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); Double_tcalculate(const Double_t* yvec = 0); virtual Bool_tcanIntegrate1D() const; virtual Bool_tcanIntegrate2D() const; virtual Bool_tcanIntegrateND() const; virtual Bool_tcanIntegrateOpenEnded() const; virtual Bool_tcheckLimits() const; static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual RooAbsIntegrator*clone(const RooAbsFunc& function, const RooNumIntConfig& config) const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTOb",MatchSource.WIKI,root/html602/RooAbsIntegrator.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsIntegrator.html
https://root.cern/root/html602/RooAbsIntegrator.html:6810,Deployability,integrat,integration,6810,"ected:. virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; voidTObject::MakeZombie(). Data Members; public:. static TObject::(anonymous)TObject::kBitMask; static TObject::EStatusBitsTObject::kCanDelete; static TObject::EStatusBitsTObject::kCannotPick; static TObject::EStatusBitsTObject::kHasUUID; static TObject::EStatusBitsTObject::kInvalidObject; static TObject::(anonymous)TObject::kIsOnHeap; static TObject::EStatusBitsTObject::kIsReferenced; static TObject::EStatusBitsTObject::kMustCleanup; static TObject::EStatusBitsTObject::kNoContextMenu; static TObject::(anonymous)TObject::kNotDeleted; static TObject::EStatusBitsTObject::kObjInCanvas; static TObject::(anonymous)TObject::kOverwrite; static TObject::(anonymous)TObject::kSingleKey; static TObject::(anonymous)TObject::kWriteDelete; static TObject::(anonymous)TObject::kZombie. protected:. const RooAbsFunc*_functionPointer to function binding of integrand; Bool_t_printEvalCounterIf true print number of function evaluation required for integration; Bool_t_validIs integrator in valid state?. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; RooAbsIntegrator(); Default constructor. RooAbsIntegrator(const RooAbsFunc& function, Bool_t printEvalCounter = kFALSE); Copy constructor. Double_t calculate(const Double_t* yvec = 0); Calculate integral value with given array of parameter values. Bool_t setLimits(Double_t xmin, Double_t xmax); Interface to set limits on integration. Bool_t setUseIntegrandLimits(Bool_t flag); Interface function that allows to defer limit definition to integrand definition. RooAbsIntegrator(). virtual ~RooAbsIntegrator(); Destructor. RooAbsIntegrator* clone(const RooAbsFunc& function, const RooNumIntConfig& config) const. Bool_t isValid() const; Is integrator in valid state. Double_t integrand(const Double_t[] x) const; Return value of integrand at given observable values. const RooAbsFunc * integrand() const; Re",MatchSource.WIKI,root/html602/RooAbsIntegrator.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsIntegrator.html
https://root.cern/root/html602/RooAbsIntegrator.html:6838,Deployability,integrat,integrator,6838,"ected:. virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; voidTObject::MakeZombie(). Data Members; public:. static TObject::(anonymous)TObject::kBitMask; static TObject::EStatusBitsTObject::kCanDelete; static TObject::EStatusBitsTObject::kCannotPick; static TObject::EStatusBitsTObject::kHasUUID; static TObject::EStatusBitsTObject::kInvalidObject; static TObject::(anonymous)TObject::kIsOnHeap; static TObject::EStatusBitsTObject::kIsReferenced; static TObject::EStatusBitsTObject::kMustCleanup; static TObject::EStatusBitsTObject::kNoContextMenu; static TObject::(anonymous)TObject::kNotDeleted; static TObject::EStatusBitsTObject::kObjInCanvas; static TObject::(anonymous)TObject::kOverwrite; static TObject::(anonymous)TObject::kSingleKey; static TObject::(anonymous)TObject::kWriteDelete; static TObject::(anonymous)TObject::kZombie. protected:. const RooAbsFunc*_functionPointer to function binding of integrand; Bool_t_printEvalCounterIf true print number of function evaluation required for integration; Bool_t_validIs integrator in valid state?. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; RooAbsIntegrator(); Default constructor. RooAbsIntegrator(const RooAbsFunc& function, Bool_t printEvalCounter = kFALSE); Copy constructor. Double_t calculate(const Double_t* yvec = 0); Calculate integral value with given array of parameter values. Bool_t setLimits(Double_t xmin, Double_t xmax); Interface to set limits on integration. Bool_t setUseIntegrandLimits(Bool_t flag); Interface function that allows to defer limit definition to integrand definition. RooAbsIntegrator(). virtual ~RooAbsIntegrator(); Destructor. RooAbsIntegrator* clone(const RooAbsFunc& function, const RooNumIntConfig& config) const. Bool_t isValid() const; Is integrator in valid state. Double_t integrand(const Double_t[] x) const; Return value of integrand at given observable values. const RooAbsFunc * integrand() const; Re",MatchSource.WIKI,root/html602/RooAbsIntegrator.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsIntegrator.html
https://root.cern/root/html602/RooAbsIntegrator.html:7280,Deployability,integrat,integration,7280,"ferenced; static TObject::EStatusBitsTObject::kMustCleanup; static TObject::EStatusBitsTObject::kNoContextMenu; static TObject::(anonymous)TObject::kNotDeleted; static TObject::EStatusBitsTObject::kObjInCanvas; static TObject::(anonymous)TObject::kOverwrite; static TObject::(anonymous)TObject::kSingleKey; static TObject::(anonymous)TObject::kWriteDelete; static TObject::(anonymous)TObject::kZombie. protected:. const RooAbsFunc*_functionPointer to function binding of integrand; Bool_t_printEvalCounterIf true print number of function evaluation required for integration; Bool_t_validIs integrator in valid state?. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; RooAbsIntegrator(); Default constructor. RooAbsIntegrator(const RooAbsFunc& function, Bool_t printEvalCounter = kFALSE); Copy constructor. Double_t calculate(const Double_t* yvec = 0); Calculate integral value with given array of parameter values. Bool_t setLimits(Double_t xmin, Double_t xmax); Interface to set limits on integration. Bool_t setUseIntegrandLimits(Bool_t flag); Interface function that allows to defer limit definition to integrand definition. RooAbsIntegrator(). virtual ~RooAbsIntegrator(); Destructor. RooAbsIntegrator* clone(const RooAbsFunc& function, const RooNumIntConfig& config) const. Bool_t isValid() const; Is integrator in valid state. Double_t integrand(const Double_t[] x) const; Return value of integrand at given observable values. const RooAbsFunc * integrand() const; Return integrand function binding. Bool_t checkLimits() const; If true, finite limits are required on the observable range. Double_t integral(const Double_t* yvec = 0). Bool_t canIntegrate1D() const. Bool_t canIntegrate2D() const. Bool_t canIntegrateND() const. Bool_t canIntegrateOpenEnded() const. Bool_t printEvalCounter() const; { return _printEvalCounter ; }. void setPrintEvalCounter(Bool_t value); { _printEvalCounter = value ; }. Bool_t setLimits(Double_t* , Double_t* ); { retur",MatchSource.WIKI,root/html602/RooAbsIntegrator.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsIntegrator.html
https://root.cern/root/html602/RooAbsIntegrator.html:7596,Deployability,integrat,integrator,7596,":kOverwrite; static TObject::(anonymous)TObject::kSingleKey; static TObject::(anonymous)TObject::kWriteDelete; static TObject::(anonymous)TObject::kZombie. protected:. const RooAbsFunc*_functionPointer to function binding of integrand; Bool_t_printEvalCounterIf true print number of function evaluation required for integration; Bool_t_validIs integrator in valid state?. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; RooAbsIntegrator(); Default constructor. RooAbsIntegrator(const RooAbsFunc& function, Bool_t printEvalCounter = kFALSE); Copy constructor. Double_t calculate(const Double_t* yvec = 0); Calculate integral value with given array of parameter values. Bool_t setLimits(Double_t xmin, Double_t xmax); Interface to set limits on integration. Bool_t setUseIntegrandLimits(Bool_t flag); Interface function that allows to defer limit definition to integrand definition. RooAbsIntegrator(). virtual ~RooAbsIntegrator(); Destructor. RooAbsIntegrator* clone(const RooAbsFunc& function, const RooNumIntConfig& config) const. Bool_t isValid() const; Is integrator in valid state. Double_t integrand(const Double_t[] x) const; Return value of integrand at given observable values. const RooAbsFunc * integrand() const; Return integrand function binding. Bool_t checkLimits() const; If true, finite limits are required on the observable range. Double_t integral(const Double_t* yvec = 0). Bool_t canIntegrate1D() const. Bool_t canIntegrate2D() const. Bool_t canIntegrateND() const. Bool_t canIntegrateOpenEnded() const. Bool_t printEvalCounter() const; { return _printEvalCounter ; }. void setPrintEvalCounter(Bool_t value); { _printEvalCounter = value ; }. Bool_t setLimits(Double_t* , Double_t* ); { return kFALSE ; }. » Last changed: Tue Jun 30 14:30:10 2015 » Last generated: 2015-06-30 14:30; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html602/RooAbsIntegrator.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsIntegrator.html
https://root.cern/root/html602/RooAbsIntegrator.html:350,Integrability,interface,interface,350,". RooAbsIntegrator. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » ROOFIT; » ROOFITCORE; » RooAbsIntegrator. class RooAbsIntegrator: public TObject. RooAbsIntegrator is the abstract interface for integrators of real-valued; functions that implement the RooAbsFunc interface.; . Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~RooAbsIntegrator(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); Double_tcalculate(const Double_t* yvec = 0); virtual Bool_tcanIntegrate1D() const; virtual Bool_tcanIntegrate2D() const; virtual Bool_tcanIntegrateND() const; virtual Bool_tcanIntegrateOpenEnded() const; virtual Bool_tcheckLimits() const; static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual RooAbsIntegrator*clone(const RooAbsFunc& function, const RooNumIntConfig& config) const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTOb",MatchSource.WIKI,root/html602/RooAbsIntegrator.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsIntegrator.html
https://root.cern/root/html602/RooAbsIntegrator.html:364,Integrability,integrat,integrators,364,". RooAbsIntegrator. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » ROOFIT; » ROOFITCORE; » RooAbsIntegrator. class RooAbsIntegrator: public TObject. RooAbsIntegrator is the abstract interface for integrators of real-valued; functions that implement the RooAbsFunc interface.; . Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~RooAbsIntegrator(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); Double_tcalculate(const Double_t* yvec = 0); virtual Bool_tcanIntegrate1D() const; virtual Bool_tcanIntegrate2D() const; virtual Bool_tcanIntegrateND() const; virtual Bool_tcanIntegrateOpenEnded() const; virtual Bool_tcheckLimits() const; static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual RooAbsIntegrator*clone(const RooAbsFunc& function, const RooNumIntConfig& config) const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTOb",MatchSource.WIKI,root/html602/RooAbsIntegrator.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsIntegrator.html
https://root.cern/root/html602/RooAbsIntegrator.html:432,Integrability,interface,interface,432,". RooAbsIntegrator. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » ROOFIT; » ROOFITCORE; » RooAbsIntegrator. class RooAbsIntegrator: public TObject. RooAbsIntegrator is the abstract interface for integrators of real-valued; functions that implement the RooAbsFunc interface.; . Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~RooAbsIntegrator(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); Double_tcalculate(const Double_t* yvec = 0); virtual Bool_tcanIntegrate1D() const; virtual Bool_tcanIntegrate2D() const; virtual Bool_tcanIntegrateND() const; virtual Bool_tcanIntegrateOpenEnded() const; virtual Bool_tcheckLimits() const; static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual RooAbsIntegrator*clone(const RooAbsFunc& function, const RooNumIntConfig& config) const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTOb",MatchSource.WIKI,root/html602/RooAbsIntegrator.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsIntegrator.html
https://root.cern/root/html602/RooAbsIntegrator.html:6810,Integrability,integrat,integration,6810,"ected:. virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; voidTObject::MakeZombie(). Data Members; public:. static TObject::(anonymous)TObject::kBitMask; static TObject::EStatusBitsTObject::kCanDelete; static TObject::EStatusBitsTObject::kCannotPick; static TObject::EStatusBitsTObject::kHasUUID; static TObject::EStatusBitsTObject::kInvalidObject; static TObject::(anonymous)TObject::kIsOnHeap; static TObject::EStatusBitsTObject::kIsReferenced; static TObject::EStatusBitsTObject::kMustCleanup; static TObject::EStatusBitsTObject::kNoContextMenu; static TObject::(anonymous)TObject::kNotDeleted; static TObject::EStatusBitsTObject::kObjInCanvas; static TObject::(anonymous)TObject::kOverwrite; static TObject::(anonymous)TObject::kSingleKey; static TObject::(anonymous)TObject::kWriteDelete; static TObject::(anonymous)TObject::kZombie. protected:. const RooAbsFunc*_functionPointer to function binding of integrand; Bool_t_printEvalCounterIf true print number of function evaluation required for integration; Bool_t_validIs integrator in valid state?. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; RooAbsIntegrator(); Default constructor. RooAbsIntegrator(const RooAbsFunc& function, Bool_t printEvalCounter = kFALSE); Copy constructor. Double_t calculate(const Double_t* yvec = 0); Calculate integral value with given array of parameter values. Bool_t setLimits(Double_t xmin, Double_t xmax); Interface to set limits on integration. Bool_t setUseIntegrandLimits(Bool_t flag); Interface function that allows to defer limit definition to integrand definition. RooAbsIntegrator(). virtual ~RooAbsIntegrator(); Destructor. RooAbsIntegrator* clone(const RooAbsFunc& function, const RooNumIntConfig& config) const. Bool_t isValid() const; Is integrator in valid state. Double_t integrand(const Double_t[] x) const; Return value of integrand at given observable values. const RooAbsFunc * integrand() const; Re",MatchSource.WIKI,root/html602/RooAbsIntegrator.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsIntegrator.html
https://root.cern/root/html602/RooAbsIntegrator.html:6838,Integrability,integrat,integrator,6838,"ected:. virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; voidTObject::MakeZombie(). Data Members; public:. static TObject::(anonymous)TObject::kBitMask; static TObject::EStatusBitsTObject::kCanDelete; static TObject::EStatusBitsTObject::kCannotPick; static TObject::EStatusBitsTObject::kHasUUID; static TObject::EStatusBitsTObject::kInvalidObject; static TObject::(anonymous)TObject::kIsOnHeap; static TObject::EStatusBitsTObject::kIsReferenced; static TObject::EStatusBitsTObject::kMustCleanup; static TObject::EStatusBitsTObject::kNoContextMenu; static TObject::(anonymous)TObject::kNotDeleted; static TObject::EStatusBitsTObject::kObjInCanvas; static TObject::(anonymous)TObject::kOverwrite; static TObject::(anonymous)TObject::kSingleKey; static TObject::(anonymous)TObject::kWriteDelete; static TObject::(anonymous)TObject::kZombie. protected:. const RooAbsFunc*_functionPointer to function binding of integrand; Bool_t_printEvalCounterIf true print number of function evaluation required for integration; Bool_t_validIs integrator in valid state?. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; RooAbsIntegrator(); Default constructor. RooAbsIntegrator(const RooAbsFunc& function, Bool_t printEvalCounter = kFALSE); Copy constructor. Double_t calculate(const Double_t* yvec = 0); Calculate integral value with given array of parameter values. Bool_t setLimits(Double_t xmin, Double_t xmax); Interface to set limits on integration. Bool_t setUseIntegrandLimits(Bool_t flag); Interface function that allows to defer limit definition to integrand definition. RooAbsIntegrator(). virtual ~RooAbsIntegrator(); Destructor. RooAbsIntegrator* clone(const RooAbsFunc& function, const RooNumIntConfig& config) const. Bool_t isValid() const; Is integrator in valid state. Double_t integrand(const Double_t[] x) const; Return value of integrand at given observable values. const RooAbsFunc * integrand() const; Re",MatchSource.WIKI,root/html602/RooAbsIntegrator.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsIntegrator.html
https://root.cern/root/html602/RooAbsIntegrator.html:7280,Integrability,integrat,integration,7280,"ferenced; static TObject::EStatusBitsTObject::kMustCleanup; static TObject::EStatusBitsTObject::kNoContextMenu; static TObject::(anonymous)TObject::kNotDeleted; static TObject::EStatusBitsTObject::kObjInCanvas; static TObject::(anonymous)TObject::kOverwrite; static TObject::(anonymous)TObject::kSingleKey; static TObject::(anonymous)TObject::kWriteDelete; static TObject::(anonymous)TObject::kZombie. protected:. const RooAbsFunc*_functionPointer to function binding of integrand; Bool_t_printEvalCounterIf true print number of function evaluation required for integration; Bool_t_validIs integrator in valid state?. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; RooAbsIntegrator(); Default constructor. RooAbsIntegrator(const RooAbsFunc& function, Bool_t printEvalCounter = kFALSE); Copy constructor. Double_t calculate(const Double_t* yvec = 0); Calculate integral value with given array of parameter values. Bool_t setLimits(Double_t xmin, Double_t xmax); Interface to set limits on integration. Bool_t setUseIntegrandLimits(Bool_t flag); Interface function that allows to defer limit definition to integrand definition. RooAbsIntegrator(). virtual ~RooAbsIntegrator(); Destructor. RooAbsIntegrator* clone(const RooAbsFunc& function, const RooNumIntConfig& config) const. Bool_t isValid() const; Is integrator in valid state. Double_t integrand(const Double_t[] x) const; Return value of integrand at given observable values. const RooAbsFunc * integrand() const; Return integrand function binding. Bool_t checkLimits() const; If true, finite limits are required on the observable range. Double_t integral(const Double_t* yvec = 0). Bool_t canIntegrate1D() const. Bool_t canIntegrate2D() const. Bool_t canIntegrateND() const. Bool_t canIntegrateOpenEnded() const. Bool_t printEvalCounter() const; { return _printEvalCounter ; }. void setPrintEvalCounter(Bool_t value); { _printEvalCounter = value ; }. Bool_t setLimits(Double_t* , Double_t* ); { retur",MatchSource.WIKI,root/html602/RooAbsIntegrator.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsIntegrator.html
https://root.cern/root/html602/RooAbsIntegrator.html:7596,Integrability,integrat,integrator,7596,":kOverwrite; static TObject::(anonymous)TObject::kSingleKey; static TObject::(anonymous)TObject::kWriteDelete; static TObject::(anonymous)TObject::kZombie. protected:. const RooAbsFunc*_functionPointer to function binding of integrand; Bool_t_printEvalCounterIf true print number of function evaluation required for integration; Bool_t_validIs integrator in valid state?. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; RooAbsIntegrator(); Default constructor. RooAbsIntegrator(const RooAbsFunc& function, Bool_t printEvalCounter = kFALSE); Copy constructor. Double_t calculate(const Double_t* yvec = 0); Calculate integral value with given array of parameter values. Bool_t setLimits(Double_t xmin, Double_t xmax); Interface to set limits on integration. Bool_t setUseIntegrandLimits(Bool_t flag); Interface function that allows to defer limit definition to integrand definition. RooAbsIntegrator(). virtual ~RooAbsIntegrator(); Destructor. RooAbsIntegrator* clone(const RooAbsFunc& function, const RooNumIntConfig& config) const. Bool_t isValid() const; Is integrator in valid state. Double_t integrand(const Double_t[] x) const; Return value of integrand at given observable values. const RooAbsFunc * integrand() const; Return integrand function binding. Bool_t checkLimits() const; If true, finite limits are required on the observable range. Double_t integral(const Double_t* yvec = 0). Bool_t canIntegrate1D() const. Bool_t canIntegrate2D() const. Bool_t canIntegrateND() const. Bool_t canIntegrateOpenEnded() const. Bool_t printEvalCounter() const; { return _printEvalCounter ; }. void setPrintEvalCounter(Bool_t value); { _printEvalCounter = value ; }. Bool_t setLimits(Double_t* , Double_t* ); { return kFALSE ; }. » Last changed: Tue Jun 30 14:30:10 2015 » Last generated: 2015-06-30 14:30; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html602/RooAbsIntegrator.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsIntegrator.html
https://root.cern/root/html602/RooAbsIntegrator.html:1293,Modifiability,config,config,1293," virtual~RooAbsIntegrator(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); Double_tcalculate(const Double_t* yvec = 0); virtual Bool_tcanIntegrate1D() const; virtual Bool_tcanIntegrate2D() const; virtual Bool_tcanIntegrateND() const; virtual Bool_tcanIntegrateOpenEnded() const; virtual Bool_tcheckLimits() const; static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual RooAbsIntegrator*clone(const RooAbsFunc& function, const RooNumIntConfig& config) const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTOb",MatchSource.WIKI,root/html602/RooAbsIntegrator.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsIntegrator.html
https://root.cern/root/html602/RooAbsIntegrator.html:7554,Modifiability,config,config,7554,":kOverwrite; static TObject::(anonymous)TObject::kSingleKey; static TObject::(anonymous)TObject::kWriteDelete; static TObject::(anonymous)TObject::kZombie. protected:. const RooAbsFunc*_functionPointer to function binding of integrand; Bool_t_printEvalCounterIf true print number of function evaluation required for integration; Bool_t_validIs integrator in valid state?. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; RooAbsIntegrator(); Default constructor. RooAbsIntegrator(const RooAbsFunc& function, Bool_t printEvalCounter = kFALSE); Copy constructor. Double_t calculate(const Double_t* yvec = 0); Calculate integral value with given array of parameter values. Bool_t setLimits(Double_t xmin, Double_t xmax); Interface to set limits on integration. Bool_t setUseIntegrandLimits(Bool_t flag); Interface function that allows to defer limit definition to integrand definition. RooAbsIntegrator(). virtual ~RooAbsIntegrator(); Destructor. RooAbsIntegrator* clone(const RooAbsFunc& function, const RooNumIntConfig& config) const. Bool_t isValid() const; Is integrator in valid state. Double_t integrand(const Double_t[] x) const; Return value of integrand at given observable values. const RooAbsFunc * integrand() const; Return integrand function binding. Bool_t checkLimits() const; If true, finite limits are required on the observable range. Double_t integral(const Double_t* yvec = 0). Bool_t canIntegrate1D() const. Bool_t canIntegrate2D() const. Bool_t canIntegrateND() const. Bool_t canIntegrateOpenEnded() const. Bool_t printEvalCounter() const; { return _printEvalCounter ; }. void setPrintEvalCounter(Bool_t value); { _printEvalCounter = value ; }. Bool_t setLimits(Double_t* , Double_t* ); { return kFALSE ; }. » Last changed: Tue Jun 30 14:30:10 2015 » Last generated: 2015-06-30 14:30; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html602/RooAbsIntegrator.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsIntegrator.html
https://root.cern/root/html602/RooAbsLValue.html:730,Availability,avail,available,730,". RooAbsLValue. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » ROOFIT; » ROOFITCORE; » RooAbsLValue. class RooAbsLValue. Abstract base class for objects that are lvalues, i.e. objects; whose value can be modified directly. This class implements; abstract methods for binned fits that return the number of fit; bins and change the value of the object to the central value of a; given fit bin, regardless of the type of value.; . Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~RooAbsLValue(); static TClass*Class(); virtual Int_tgetBin(const char* rangeName = 0) const; virtual Int_tgetBin(const RooAbsBinning*) const; virtual list<string>getBinningNames() const; virtual const RooAbsBinning*getBinningPtr(const char* rangeName) const; virtual Double_tgetBinWidth(Int_t i, const char* rangeName = 0) const; virtual TClass*IsA() const; virtual Int_tnumBins(const char* rangeName = 0) const; RooAbsLValue&operator=(const RooAbsLValue&); virtual voidrandomize(const char* rangeName = 0); RooAbsLValue(); RooAbsLValue(const RooAbsLValue&); virtual voidsetBin(Int_t ibin, const char* rangeName = 0); virtual voidShowMembers(TMemberInspector& insp) const; virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); virtual Double_tvolume(const char* rangeName) const. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; RooAbsLValue(); Constructor. ~RooAbsLValue(); Destructor. RooAbsLValue(); Constructors, cloning and assignment. void setBin(Int_t ibin, const char* rangeName = 0). Int_t getBin(const char* rangeName = 0) const. Int_t numBins(const char* rangeName = 0) const. Double_t getBinWidth(Int_t i, const char* rangeName = 0) cons",MatchSource.WIKI,root/html602/RooAbsLValue.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsLValue.html
https://root.cern/root/html602/RooAbsMCStudyModule.html:1877,Availability,error,error,1877," virtual~RooAbsMCStudyModule(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); Bool_tdoInitializeInstance(RooMCStudy&); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::Execute",MatchSource.WIKI,root/html602/RooAbsMCStudyModule.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsMCStudyModule.html
https://root.cern/root/html602/RooAbsMCStudyModule.html:1961,Availability,error,error,1961,"thod) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); Bool_tdoInitializeInstance(RooMCStudy&); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual RooDataSet*finalizeRun(); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual const char*TNamed::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual const char*TNamed::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTNamed::Hash() const; virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) const; vi",MatchSource.WIKI,root/html602/RooAbsMCStudyModule.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsMCStudyModule.html
https://root.cern/root/html602/RooAbsMCStudyModule.html:10203,Deployability,configurat,configuration,10203,"ocessAfterFit(Int_t ); Method called after fit has been performed. RooFitResult* refit(RooAbsData* inGenSample = 0); Interface methods to RooMCStudy objects,; which are only functional after module has been attached to a RooMCStudy object. RooAbsData* genSample(); Return generate sample. RooAbsPdf* genModel(); Return generator pdf. RooAbsGenContext* genContext(); Accessor for generator context, generator parameters,	prototype data and projected dependents. RooArgSet* genInitParams(); Return initial value of generator model parameters. RooArgSet* genParams(); Return current value of generator model parameters. const RooDataSet* genProtoData(); Return generator prototype data provided by user. RooArgSet* projDeps(); Return projected observables. RooArgSet* dependents(); Accessors for fit observables, fit model, current and initial fit parameters and NLL value. RooArgSet* allDependents(); Returna all observables. RooAbsPdf* fitModel(); Return fit model. RooArgSet* fitInitParams(); Return initial value of parameters of fit model. RooArgSet* fitParams(); Return current value of parameters of fit model. RooRealVar* nllVar(); Return pointer to RooRealVar holding minimized -log(L) value. const char* fitOptions(); Accessors for fit options, generator annd MCstudy configuration flags. RooLinkedList* fitOptList(); Return list of fit options provided by user. Bool_t extendedGen(); If true extended mode generation is requested. Bool_t binGenData(); If true binning of data between generating and fitting is requested. Double_t numExpGen(); Return expected number of events from generator model. Bool_t randProto(); If true randomization of prototype data order is requested. Bool_t verboseGen(); If true verbose message in the generation step is requested. » Last changed: Tue Jun 30 14:30:12 2015 » Last generated: 2015-06-30 14:30; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html602/RooAbsMCStudyModule.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsMCStudyModule.html
https://root.cern/root/html602/RooAbsMCStudyModule.html:5901,Integrability,depend,dependents,5901,"tUniqueID(UInt_t uid); virtual voidShowMembers(TMemberInspector& insp) const; virtual Int_tTNamed::Sizeof() const; virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const. protected:. RooArgSet*allDependents(); Bool_tbinGenData(); RooArgSet*dependents(); virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; Bool_textendedGen(); RooArgSet*fitInitParams(); RooAbsPdf*fitModel(); const char*fitOptions(); RooLinkedList*fitOptList(); RooArgSet*fitParams(); RooAbsGenContext*genContext(); RooArgSet*genInitParams(); RooAbsPdf*genModel(); RooArgSet*genParams(); const RooDataSet*genProtoData(); RooAbsData*genSample(); voidTObject::MakeZombie(); RooRealVar*nllVar(); Double_tnumExpGen(); RooArgSet*projDeps(); Bool_trandProto(); RooFitResult*refit(RooAbsData* inGenSample = 0); Bool_tverboseGen(). Data Members; public:. static TObject::(anonymous)TObject::kBitMask; static TObject::EStatusBitsTObject::kCanDelete; static TObject::EStatusBitsTObject::kCannotPick; static TObject::EStatusBitsTObject::kHasUUID; static TObject::EStatusBitsTObject::kInvalidObject; static TObject::(anonymous)TObject::kIsOnHeap; static TObject::EStatusBitsTObject::kIsReferenced; static TObject::EStatusBitsTObject::kMustCleanup; static TObject::EStatusBitsTObject::kNoContextMenu; static TObject::(anonymous)TObject::kNotDeleted; static TObject::EStatusBitsTObject::kObjInCanvas; static TObject::(anonymous)TObject::kOverwrite; static TObject::(anonymous)TObject::kSingleKey; static TObjec",MatchSource.WIKI,root/html602/RooAbsMCStudyModule.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsMCStudyModule.html
https://root.cern/root/html602/RooAbsMCStudyModule.html:9377,Integrability,depend,dependents,9377,"(Int_t ); Method called after resetting of generator parameters to initial values and before call to generator context; Any modifications to generator parameters will affect next generation operation (only). Bool_t processBetweenGenAndFit(Int_t ); Method called after generation of toy data sample and resetting of fit parameters to initial values and before; actual fit is performed. Any modifications to fit parameters will apply to next fit operation. Note that setConstant; flag of fit parameters are not explicitly reset by RooMCStudy, so any changes made to these flags here will persist. Bool_t processAfterFit(Int_t ); Method called after fit has been performed. RooFitResult* refit(RooAbsData* inGenSample = 0); Interface methods to RooMCStudy objects,; which are only functional after module has been attached to a RooMCStudy object. RooAbsData* genSample(); Return generate sample. RooAbsPdf* genModel(); Return generator pdf. RooAbsGenContext* genContext(); Accessor for generator context, generator parameters,	prototype data and projected dependents. RooArgSet* genInitParams(); Return initial value of generator model parameters. RooArgSet* genParams(); Return current value of generator model parameters. const RooDataSet* genProtoData(); Return generator prototype data provided by user. RooArgSet* projDeps(); Return projected observables. RooArgSet* dependents(); Accessors for fit observables, fit model, current and initial fit parameters and NLL value. RooArgSet* allDependents(); Returna all observables. RooAbsPdf* fitModel(); Return fit model. RooArgSet* fitInitParams(); Return initial value of parameters of fit model. RooArgSet* fitParams(); Return current value of parameters of fit model. RooRealVar* nllVar(); Return pointer to RooRealVar holding minimized -log(L) value. const char* fitOptions(); Accessors for fit options, generator annd MCstudy configuration flags. RooLinkedList* fitOptList(); Return list of fit options provided by user. Bool_t extendedGen(); If tr",MatchSource.WIKI,root/html602/RooAbsMCStudyModule.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsMCStudyModule.html
https://root.cern/root/html602/RooAbsMCStudyModule.html:9693,Integrability,depend,dependents,9693,"eters will apply to next fit operation. Note that setConstant; flag of fit parameters are not explicitly reset by RooMCStudy, so any changes made to these flags here will persist. Bool_t processAfterFit(Int_t ); Method called after fit has been performed. RooFitResult* refit(RooAbsData* inGenSample = 0); Interface methods to RooMCStudy objects,; which are only functional after module has been attached to a RooMCStudy object. RooAbsData* genSample(); Return generate sample. RooAbsPdf* genModel(); Return generator pdf. RooAbsGenContext* genContext(); Accessor for generator context, generator parameters,	prototype data and projected dependents. RooArgSet* genInitParams(); Return initial value of generator model parameters. RooArgSet* genParams(); Return current value of generator model parameters. const RooDataSet* genProtoData(); Return generator prototype data provided by user. RooArgSet* projDeps(); Return projected observables. RooArgSet* dependents(); Accessors for fit observables, fit model, current and initial fit parameters and NLL value. RooArgSet* allDependents(); Returna all observables. RooAbsPdf* fitModel(); Return fit model. RooArgSet* fitInitParams(); Return initial value of parameters of fit model. RooArgSet* fitParams(); Return current value of parameters of fit model. RooRealVar* nllVar(); Return pointer to RooRealVar holding minimized -log(L) value. const char* fitOptions(); Accessors for fit options, generator annd MCstudy configuration flags. RooLinkedList* fitOptList(); Return list of fit options provided by user. Bool_t extendedGen(); If true extended mode generation is requested. Bool_t binGenData(); If true binning of data between generating and fitting is requested. Double_t numExpGen(); Return expected number of events from generator model. Bool_t randProto(); If true randomization of prototype data order is requested. Bool_t verboseGen(); If true verbose message in the generation step is requested. » Last changed: Tue Jun 30 14:30:12 2015 » L",MatchSource.WIKI,root/html602/RooAbsMCStudyModule.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsMCStudyModule.html
https://root.cern/root/html602/RooAbsMCStudyModule.html:10651,Integrability,message,message,10651,"ocessAfterFit(Int_t ); Method called after fit has been performed. RooFitResult* refit(RooAbsData* inGenSample = 0); Interface methods to RooMCStudy objects,; which are only functional after module has been attached to a RooMCStudy object. RooAbsData* genSample(); Return generate sample. RooAbsPdf* genModel(); Return generator pdf. RooAbsGenContext* genContext(); Accessor for generator context, generator parameters,	prototype data and projected dependents. RooArgSet* genInitParams(); Return initial value of generator model parameters. RooArgSet* genParams(); Return current value of generator model parameters. const RooDataSet* genProtoData(); Return generator prototype data provided by user. RooArgSet* projDeps(); Return projected observables. RooArgSet* dependents(); Accessors for fit observables, fit model, current and initial fit parameters and NLL value. RooArgSet* allDependents(); Returna all observables. RooAbsPdf* fitModel(); Return fit model. RooArgSet* fitInitParams(); Return initial value of parameters of fit model. RooArgSet* fitParams(); Return current value of parameters of fit model. RooRealVar* nllVar(); Return pointer to RooRealVar holding minimized -log(L) value. const char* fitOptions(); Accessors for fit options, generator annd MCstudy configuration flags. RooLinkedList* fitOptList(); Return list of fit options provided by user. Bool_t extendedGen(); If true extended mode generation is requested. Bool_t binGenData(); If true binning of data between generating and fitting is requested. Double_t numExpGen(); Return expected number of events from generator model. Bool_t randProto(); If true randomization of prototype data order is requested. Bool_t verboseGen(); If true verbose message in the generation step is requested. » Last changed: Tue Jun 30 14:30:12 2015 » Last generated: 2015-06-30 14:30; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html602/RooAbsMCStudyModule.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsMCStudyModule.html
https://root.cern/root/html602/RooAbsMCStudyModule.html:647,Modifiability,variab,variables,647,". RooAbsMCStudyModule. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » ROOFIT; » ROOFITCORE; » RooAbsMCStudyModule. class RooAbsMCStudyModule: public TNamed. RooAbsMCStudyModule is a base class for add-on modules to RooMCStudy that; can perform additional calculations on each generate+fit cycle managed; by RooMCStudy; This class can insert code to be executed before each generation step,; between the generation and fitting step and after the fitting step.; Any summary output variables declared in the RooDataSet exported through; summaryData() is merged with the 'master' summary dataset in RooMCStudy; Look at RooDLLSignificanceMCStudyModule for an example of an implementation; . Function Members (Methods); public:. virtual~RooAbsMCStudyModule(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); Bool_tdoInitializeInstance(RooMCStudy&); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::Execute",MatchSource.WIKI,root/html602/RooAbsMCStudyModule.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsMCStudyModule.html
https://root.cern/root/html602/RooAbsMCStudyModule.html:10203,Modifiability,config,configuration,10203,"ocessAfterFit(Int_t ); Method called after fit has been performed. RooFitResult* refit(RooAbsData* inGenSample = 0); Interface methods to RooMCStudy objects,; which are only functional after module has been attached to a RooMCStudy object. RooAbsData* genSample(); Return generate sample. RooAbsPdf* genModel(); Return generator pdf. RooAbsGenContext* genContext(); Accessor for generator context, generator parameters,	prototype data and projected dependents. RooArgSet* genInitParams(); Return initial value of generator model parameters. RooArgSet* genParams(); Return current value of generator model parameters. const RooDataSet* genProtoData(); Return generator prototype data provided by user. RooArgSet* projDeps(); Return projected observables. RooArgSet* dependents(); Accessors for fit observables, fit model, current and initial fit parameters and NLL value. RooArgSet* allDependents(); Returna all observables. RooAbsPdf* fitModel(); Return fit model. RooArgSet* fitInitParams(); Return initial value of parameters of fit model. RooArgSet* fitParams(); Return current value of parameters of fit model. RooRealVar* nllVar(); Return pointer to RooRealVar holding minimized -log(L) value. const char* fitOptions(); Accessors for fit options, generator annd MCstudy configuration flags. RooLinkedList* fitOptList(); Return list of fit options provided by user. Bool_t extendedGen(); If true extended mode generation is requested. Bool_t binGenData(); If true binning of data between generating and fitting is requested. Double_t numExpGen(); Return expected number of events from generator model. Bool_t randProto(); If true randomization of prototype data order is requested. Bool_t verboseGen(); If true verbose message in the generation step is requested. » Last changed: Tue Jun 30 14:30:12 2015 » Last generated: 2015-06-30 14:30; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html602/RooAbsMCStudyModule.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsMCStudyModule.html
https://root.cern/root/html602/RooAbsMCStudyModule.html:10305,Modifiability,extend,extendedGen,10305,"ocessAfterFit(Int_t ); Method called after fit has been performed. RooFitResult* refit(RooAbsData* inGenSample = 0); Interface methods to RooMCStudy objects,; which are only functional after module has been attached to a RooMCStudy object. RooAbsData* genSample(); Return generate sample. RooAbsPdf* genModel(); Return generator pdf. RooAbsGenContext* genContext(); Accessor for generator context, generator parameters,	prototype data and projected dependents. RooArgSet* genInitParams(); Return initial value of generator model parameters. RooArgSet* genParams(); Return current value of generator model parameters. const RooDataSet* genProtoData(); Return generator prototype data provided by user. RooArgSet* projDeps(); Return projected observables. RooArgSet* dependents(); Accessors for fit observables, fit model, current and initial fit parameters and NLL value. RooArgSet* allDependents(); Returna all observables. RooAbsPdf* fitModel(); Return fit model. RooArgSet* fitInitParams(); Return initial value of parameters of fit model. RooArgSet* fitParams(); Return current value of parameters of fit model. RooRealVar* nllVar(); Return pointer to RooRealVar holding minimized -log(L) value. const char* fitOptions(); Accessors for fit options, generator annd MCstudy configuration flags. RooLinkedList* fitOptList(); Return list of fit options provided by user. Bool_t extendedGen(); If true extended mode generation is requested. Bool_t binGenData(); If true binning of data between generating and fitting is requested. Double_t numExpGen(); Return expected number of events from generator model. Bool_t randProto(); If true randomization of prototype data order is requested. Bool_t verboseGen(); If true verbose message in the generation step is requested. » Last changed: Tue Jun 30 14:30:12 2015 » Last generated: 2015-06-30 14:30; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html602/RooAbsMCStudyModule.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsMCStudyModule.html
https://root.cern/root/html602/RooAbsMCStudyModule.html:10328,Modifiability,extend,extended,10328,"ocessAfterFit(Int_t ); Method called after fit has been performed. RooFitResult* refit(RooAbsData* inGenSample = 0); Interface methods to RooMCStudy objects,; which are only functional after module has been attached to a RooMCStudy object. RooAbsData* genSample(); Return generate sample. RooAbsPdf* genModel(); Return generator pdf. RooAbsGenContext* genContext(); Accessor for generator context, generator parameters,	prototype data and projected dependents. RooArgSet* genInitParams(); Return initial value of generator model parameters. RooArgSet* genParams(); Return current value of generator model parameters. const RooDataSet* genProtoData(); Return generator prototype data provided by user. RooArgSet* projDeps(); Return projected observables. RooArgSet* dependents(); Accessors for fit observables, fit model, current and initial fit parameters and NLL value. RooArgSet* allDependents(); Returna all observables. RooAbsPdf* fitModel(); Return fit model. RooArgSet* fitInitParams(); Return initial value of parameters of fit model. RooArgSet* fitParams(); Return current value of parameters of fit model. RooRealVar* nllVar(); Return pointer to RooRealVar holding minimized -log(L) value. const char* fitOptions(); Accessors for fit options, generator annd MCstudy configuration flags. RooLinkedList* fitOptList(); Return list of fit options provided by user. Bool_t extendedGen(); If true extended mode generation is requested. Bool_t binGenData(); If true binning of data between generating and fitting is requested. Double_t numExpGen(); Return expected number of events from generator model. Bool_t randProto(); If true randomization of prototype data order is requested. Bool_t verboseGen(); If true verbose message in the generation step is requested. » Last changed: Tue Jun 30 14:30:12 2015 » Last generated: 2015-06-30 14:30; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html602/RooAbsMCStudyModule.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsMCStudyModule.html
https://root.cern/root/html602/RooAbsMCStudyModule.html:404,Performance,perform,perform,404,". RooAbsMCStudyModule. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » ROOFIT; » ROOFITCORE; » RooAbsMCStudyModule. class RooAbsMCStudyModule: public TNamed. RooAbsMCStudyModule is a base class for add-on modules to RooMCStudy that; can perform additional calculations on each generate+fit cycle managed; by RooMCStudy; This class can insert code to be executed before each generation step,; between the generation and fitting step and after the fitting step.; Any summary output variables declared in the RooDataSet exported through; summaryData() is merged with the 'master' summary dataset in RooMCStudy; Look at RooDLLSignificanceMCStudyModule for an example of an implementation; . Function Members (Methods); public:. virtual~RooAbsMCStudyModule(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); Bool_tdoInitializeInstance(RooMCStudy&); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::Execute",MatchSource.WIKI,root/html602/RooAbsMCStudyModule.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsMCStudyModule.html
https://root.cern/root/html602/RooAbsMCStudyModule.html:8236,Performance,perform,performed,8236,":(anonymous)TObject::kZombie. protected:. TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title. private:. RooMCStudy*_mcsPointer to RooMCStudy object module is attached to. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; RooAbsMCStudyModule(const char* name, const char* title); Constructor. RooAbsMCStudyModule(const RooAbsMCStudyModule& other); Copy constructor. Bool_t doInitializeInstance(RooMCStudy& ); Store reference to RooMCStudy object that this module relates to and call internal module; initialization function. virtual ~RooAbsMCStudyModule(); {}. Bool_t initializeInstance(); Initializer called immediately after attachment to RooMCStudy object and initialization of module base class. Bool_t initializeRun(Int_t ); Method called at the beginning of each RooMCStudy run. RooDataSet* finalizeRun(); Method called at the end of each RooMCStudy run. If a RooDataSet is returned, it must have a length equal to; the number of toy experiments performed and will merged with the fitpar dataset of RooMCStudy. Bool_t processBeforeGen(Int_t ); Method called after resetting of generator parameters to initial values and before call to generator context; Any modifications to generator parameters will affect next generation operation (only). Bool_t processBetweenGenAndFit(Int_t ); Method called after generation of toy data sample and resetting of fit parameters to initial values and before; actual fit is performed. Any modifications to fit parameters will apply to next fit operation. Note that setConstant; flag of fit parameters are not explicitly reset by RooMCStudy, so any changes made to these flags here will persist. Bool_t processAfterFit(Int_t ); Method called after fit has been performed. RooFitResult* refit(RooAbsData* inGenSample = 0); Interface methods to RooMCStudy objects,; which are only functional after module has been attached to a RooMCStudy object. RooAbsData* genSample(); Return generate sample. RooAb",MatchSource.WIKI,root/html602/RooAbsMCStudyModule.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsMCStudyModule.html
https://root.cern/root/html602/RooAbsMCStudyModule.html:8698,Performance,perform,performed,8698,"ule& other); Copy constructor. Bool_t doInitializeInstance(RooMCStudy& ); Store reference to RooMCStudy object that this module relates to and call internal module; initialization function. virtual ~RooAbsMCStudyModule(); {}. Bool_t initializeInstance(); Initializer called immediately after attachment to RooMCStudy object and initialization of module base class. Bool_t initializeRun(Int_t ); Method called at the beginning of each RooMCStudy run. RooDataSet* finalizeRun(); Method called at the end of each RooMCStudy run. If a RooDataSet is returned, it must have a length equal to; the number of toy experiments performed and will merged with the fitpar dataset of RooMCStudy. Bool_t processBeforeGen(Int_t ); Method called after resetting of generator parameters to initial values and before call to generator context; Any modifications to generator parameters will affect next generation operation (only). Bool_t processBetweenGenAndFit(Int_t ); Method called after generation of toy data sample and resetting of fit parameters to initial values and before; actual fit is performed. Any modifications to fit parameters will apply to next fit operation. Note that setConstant; flag of fit parameters are not explicitly reset by RooMCStudy, so any changes made to these flags here will persist. Bool_t processAfterFit(Int_t ); Method called after fit has been performed. RooFitResult* refit(RooAbsData* inGenSample = 0); Interface methods to RooMCStudy objects,; which are only functional after module has been attached to a RooMCStudy object. RooAbsData* genSample(); Return generate sample. RooAbsPdf* genModel(); Return generator pdf. RooAbsGenContext* genContext(); Accessor for generator context, generator parameters,	prototype data and projected dependents. RooArgSet* genInitParams(); Return initial value of generator model parameters. RooArgSet* genParams(); Return current value of generator model parameters. const RooDataSet* genProtoData(); Return generator prototype data provided ",MatchSource.WIKI,root/html602/RooAbsMCStudyModule.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsMCStudyModule.html
https://root.cern/root/html602/RooAbsMCStudyModule.html:8984,Performance,perform,performed,8984,"ation of module base class. Bool_t initializeRun(Int_t ); Method called at the beginning of each RooMCStudy run. RooDataSet* finalizeRun(); Method called at the end of each RooMCStudy run. If a RooDataSet is returned, it must have a length equal to; the number of toy experiments performed and will merged with the fitpar dataset of RooMCStudy. Bool_t processBeforeGen(Int_t ); Method called after resetting of generator parameters to initial values and before call to generator context; Any modifications to generator parameters will affect next generation operation (only). Bool_t processBetweenGenAndFit(Int_t ); Method called after generation of toy data sample and resetting of fit parameters to initial values and before; actual fit is performed. Any modifications to fit parameters will apply to next fit operation. Note that setConstant; flag of fit parameters are not explicitly reset by RooMCStudy, so any changes made to these flags here will persist. Bool_t processAfterFit(Int_t ); Method called after fit has been performed. RooFitResult* refit(RooAbsData* inGenSample = 0); Interface methods to RooMCStudy objects,; which are only functional after module has been attached to a RooMCStudy object. RooAbsData* genSample(); Return generate sample. RooAbsPdf* genModel(); Return generator pdf. RooAbsGenContext* genContext(); Accessor for generator context, generator parameters,	prototype data and projected dependents. RooArgSet* genInitParams(); Return initial value of generator model parameters. RooArgSet* genParams(); Return current value of generator model parameters. const RooDataSet* genProtoData(); Return generator prototype data provided by user. RooArgSet* projDeps(); Return projected observables. RooArgSet* dependents(); Accessors for fit observables, fit model, current and initial fit parameters and NLL value. RooArgSet* allDependents(); Returna all observables. RooAbsPdf* fitModel(); Return fit model. RooArgSet* fitInitParams(); Return initial value of parameters ",MatchSource.WIKI,root/html602/RooAbsMCStudyModule.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsMCStudyModule.html
https://root.cern/root/html602/RooAbsMCStudyModule.html:10113,Testability,log,log,10113,"ocessAfterFit(Int_t ); Method called after fit has been performed. RooFitResult* refit(RooAbsData* inGenSample = 0); Interface methods to RooMCStudy objects,; which are only functional after module has been attached to a RooMCStudy object. RooAbsData* genSample(); Return generate sample. RooAbsPdf* genModel(); Return generator pdf. RooAbsGenContext* genContext(); Accessor for generator context, generator parameters,	prototype data and projected dependents. RooArgSet* genInitParams(); Return initial value of generator model parameters. RooArgSet* genParams(); Return current value of generator model parameters. const RooDataSet* genProtoData(); Return generator prototype data provided by user. RooArgSet* projDeps(); Return projected observables. RooArgSet* dependents(); Accessors for fit observables, fit model, current and initial fit parameters and NLL value. RooArgSet* allDependents(); Returna all observables. RooAbsPdf* fitModel(); Return fit model. RooArgSet* fitInitParams(); Return initial value of parameters of fit model. RooArgSet* fitParams(); Return current value of parameters of fit model. RooRealVar* nllVar(); Return pointer to RooRealVar holding minimized -log(L) value. const char* fitOptions(); Accessors for fit options, generator annd MCstudy configuration flags. RooLinkedList* fitOptList(); Return list of fit options provided by user. Bool_t extendedGen(); If true extended mode generation is requested. Bool_t binGenData(); If true binning of data between generating and fitting is requested. Double_t numExpGen(); Return expected number of events from generator model. Bool_t randProto(); If true randomization of prototype data order is requested. Bool_t verboseGen(); If true verbose message in the generation step is requested. » Last changed: Tue Jun 30 14:30:12 2015 » Last generated: 2015-06-30 14:30; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html602/RooAbsMCStudyModule.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsMCStudyModule.html
https://root.cern/root/html602/RooAbsMoment.html:606,Availability,avail,available,606,". RooAbsMoment. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » ROOFIT; » ROOFITCORE; » RooAbsMoment. class RooAbsMoment: public RooAbsReal. RooAbsMoment represents the first, second, or third order derivative; of any RooAbsReal as calculated (numerically) by the MathCore Richardson; derivator class.; . Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~RooAbsMoment(); voidTObject::AbstractMethod(const char* method) const; Bool_tRooAbsArg::addOwnedComponents(const RooArgSet& comps); voidRooAbsArg::addParameters(RooArgSet& params, const RooArgSet* nset = 0, Bool_t stripDisconnected = kTRUE) const; voidRooAbsArg::addServer(RooAbsArg& server, Bool_t valueProp = kTRUE, Bool_t shapeProp = kFALSE); voidRooAbsArg::addServerList(RooAbsCollection& serverList, Bool_t valueProp = kTRUE, Bool_t shapeProp = kFALSE); const char*RooAbsArg::aggregateCacheUniqueSuffix() const; virtual Double_tRooAbsReal::analyticalIntegral(Int_t code, const char* rangeName = 0) const; virtual Double_tRooAbsReal::analyticalIntegralWN(Int_t code, const RooArgSet* normSet, const char* rangeName = 0) const; virtual voidTObject::AppendPad(Option_t* option = """"); TF1*RooAbsReal::asTF(const RooArgList& obs, const RooArgList& pars = RooArgList(), const RooArgSet& nset = RooArgSet()) const; voidRooAbsArg::attachDataSet(const RooAbsData& set); voidRooAbsArg::attachDataStore(const RooAbsDataStore& set); const set<string>&RooAbsArg::attributes() const; virtual list<Double_t>*RooAbsReal::binBoundaries(RooAbsRealLValue&, Double_t, Double_t) const; RooAbsFunc*RooAbsReal::bindVars(const RooArgSet& vars, const RooArgSet* nset = 0, Bool_t clipInvalid = kFALSE) const; voidRooAbsArg::branchNodeServerList(RooAbsCollection* list, const",MatchSource.WIKI,root/html602/RooAbsMoment.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsMoment.html
https://root.cern/root/html602/RooAbsMoment.html:10199,Availability,error,error,10199,,MatchSource.WIKI,root/html602/RooAbsMoment.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsMoment.html
https://root.cern/root/html602/RooAbsMoment.html:10283,Availability,error,error,10283,,MatchSource.WIKI,root/html602/RooAbsMoment.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsMoment.html
https://root.cern/root/html602/RooAbsMoment.html:35018,Deployability,integrat,integration,35018,"lean attributes; set<string>RooAbsArg::_boolAttribTransient! Transient boolean attributes (not copied in ctor); Bool_tRooAbsReal::_boolValue! Transient cache for bool values from tree branches; UChar_tRooAbsReal::_byteValue! Transient cache for byte values from tree branches; static Bool_tRooAbsReal::_cacheCheckIf true, always validate contents of clean which outcome of evaluate(); deque<RooAbsCache*>RooAbsArg::_cacheListlist of caches; RooRefCountListRooAbsArg::_clientListlist of client objects; RooRefCountListRooAbsArg::_clientListShapesubset of clients that requested shape dirty flag propagation; RooRefCountListRooAbsArg::_clientListValuesubset of clients that requested value dirty flag propagation; TIterator*RooAbsArg::_clientShapeIter! Iterator over _clientListShape; TIterator*RooAbsArg::_clientValueIter! Iterator over _clientListValue; Bool_tRooAbsArg::_deleteWatch! Delete watch flag; RooExpensiveObjectCache*RooAbsArg::_eocachePointer to global cache manager for any expensive components created by this object; Bool_tRooAbsArg::_fastAllow fast access mode in getVal() and proxies; Float_tRooAbsReal::_floatValue! Transient cache for floating point values from tree branches; Bool_tRooAbsReal::_forceNumIntForce numerical integration if flag set; RooRealProxy_funcInput function; static Bool_tRooAbsReal::_globalSelectCompGlobal activation switch for component selection; static Bool_tRooAbsReal::_hideOffsetOffset hiding flag; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; Int_tRooAbsReal::_intValue! Transient cache for integer values from tree branches; Bool_tRooAbsArg::_isConstant! Cached isConstant status; TStringRooAbsReal::_labelPlot label for objects value; RooArgSet*RooAbsReal::_lastNSet!; Bool_tRooAbsArg::_localNoInhibitDirty! Prevent 'AlwaysDirty' mode for this node; RooRealProxy_meanMean (if calculated for central moment); static Int_tRooPrintable::_nameLength; TNamed*RooAbsArg::_namePtr! Do not persist.",MatchSource.WIKI,root/html602/RooAbsMoment.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsMoment.html
https://root.cern/root/html602/RooAbsMoment.html:36718,Deployability,integrat,integrator,36718,"ent 'AlwaysDirty' mode for this node; RooRealProxy_meanMean (if calculated for central moment); static Int_tRooPrintable::_nameLength; TNamed*RooAbsArg::_namePtr! Do not persist. Pointer to global instance of string that matches object named; RooSetProxy_nsetNormalization set (optional); RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; Int_t_orderMoment order; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; Int_tRooAbsReal::_plotBinsNumber of plot bins; Double_tRooAbsReal::_plotMaxMaximum of plot range; Double_tRooAbsReal::_plotMinMinimum of plot range; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; RooRefArrayRooAbsArg::_proxyListlist of proxies; Char_tRooAbsReal::_sbyteValue! Transient cache for signed byte values from tree branches; Bool_tRooAbsReal::_selectComp! Component selection flag for RooAbsPdf::plotCompOn; RooRefCountListRooAbsArg::_serverListlist of server objects; Bool_tRooAbsArg::_shapeDirtyFlag set if value needs recalculating because input shapes modified; RooNumIntConfig*RooAbsReal::_specIntegratorConfigNumeric integrator configuration specific for this object; map<string,string>RooAbsArg::_stringAttribString attributes; Int_t_takeRootReturn n-order root of moment; Bool_tRooAbsReal::_treeVar!do not persist; UInt_tRooAbsReal::_uintValue! Transient cache for unsigned integer values from tree branches; TStringRooAbsReal::_unitUnit for objects value; Double_tRooAbsReal::_valueCache for current value of object; Bool_tRooAbsArg::_valueDirtyFlag set if value needs recalculating because input values modified; static Bool_tRooAbsArg::_verboseDirtyStatic flag controlling verbose messaging for dirty state changes; RooRealProxy_xObservable; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; RooAbsMoment(); Default constructor. RooAbsMoment(const char* name, const char* title,",MatchSource.WIKI,root/html602/RooAbsMoment.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsMoment.html
https://root.cern/root/html602/RooAbsMoment.html:36729,Deployability,configurat,configuration,36729,"ent 'AlwaysDirty' mode for this node; RooRealProxy_meanMean (if calculated for central moment); static Int_tRooPrintable::_nameLength; TNamed*RooAbsArg::_namePtr! Do not persist. Pointer to global instance of string that matches object named; RooSetProxy_nsetNormalization set (optional); RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; Int_t_orderMoment order; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; Int_tRooAbsReal::_plotBinsNumber of plot bins; Double_tRooAbsReal::_plotMaxMaximum of plot range; Double_tRooAbsReal::_plotMinMinimum of plot range; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; RooRefArrayRooAbsArg::_proxyListlist of proxies; Char_tRooAbsReal::_sbyteValue! Transient cache for signed byte values from tree branches; Bool_tRooAbsReal::_selectComp! Component selection flag for RooAbsPdf::plotCompOn; RooRefCountListRooAbsArg::_serverListlist of server objects; Bool_tRooAbsArg::_shapeDirtyFlag set if value needs recalculating because input shapes modified; RooNumIntConfig*RooAbsReal::_specIntegratorConfigNumeric integrator configuration specific for this object; map<string,string>RooAbsArg::_stringAttribString attributes; Int_t_takeRootReturn n-order root of moment; Bool_tRooAbsReal::_treeVar!do not persist; UInt_tRooAbsReal::_uintValue! Transient cache for unsigned integer values from tree branches; TStringRooAbsReal::_unitUnit for objects value; Double_tRooAbsReal::_valueCache for current value of object; Bool_tRooAbsArg::_valueDirtyFlag set if value needs recalculating because input values modified; static Bool_tRooAbsArg::_verboseDirtyStatic flag controlling verbose messaging for dirty state changes; RooRealProxy_xObservable; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; RooAbsMoment(); Default constructor. RooAbsMoment(const char* name, const char* title,",MatchSource.WIKI,root/html602/RooAbsMoment.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsMoment.html
https://root.cern/root/html602/RooAbsMoment.html:7528,Integrability,depend,dependentVars,7528,"const char* rangeName = 0) const; virtual RooAbsReal*RooAbsReal::createIntegral(const RooArgSet& iset, const RooArgSet* nset = 0, const RooNumIntConfig* cfg = 0, const char* rangeName = 0) const; RooAbsReal*RooAbsReal::createIntegral(const RooArgSet& iset, const RooCmdArg& arg1, const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()) const; RooAbsReal*RooAbsReal::createIntRI(const RooArgSet& iset, const RooArgSet& nset = RooArgSet()); const RooAbsReal*RooAbsReal::createPlotProjection(const RooArgSet& depVars, const RooArgSet& projVars) const; const RooAbsReal*RooAbsReal::createPlotProjection(const RooArgSet& depVars, const RooArgSet& projVars, RooArgSet*& cloneSet) const; const RooAbsReal*RooAbsReal::createPlotProjection(const RooArgSet& dependentVars, const RooArgSet* projectedVars, RooArgSet*& cloneSet, const char* rangeName = 0, const RooArgSet* condObs = 0) const; virtual RooAbsReal*RooAbsReal::createProfile(const RooArgSet& paramsOfInterest); RooAbsReal*RooAbsReal::createRunningIntegral(const RooArgSet& iset, const RooArgSet& nset = RooArgSet()); RooAbsReal*RooAbsReal::createRunningIntegral(const RooArgSet& iset, const RooCmdArg& arg1, const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()); RooAbsReal*RooAbsReal::createScanRI(const RooArgSet& iset, const RooArgSet& nset, Int_t numScanBins, Int_t intOrder); virtual Double_tRooAbsReal::defaultErrorLevel() const; static RooNumIntConfig*RooAbsReal::defaultIntegratorConfig(); virtual Int_tRooAbsArg::defaultPrintContents(Option_t* opt)",MatchSource.WIKI,root/html602/RooAbsMoment.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsMoment.html
https://root.cern/root/html602/RooAbsMoment.html:8770,Integrability,depend,dependentOverlaps,8770,"l*RooAbsReal::createPlotProjection(const RooArgSet& dependentVars, const RooArgSet* projectedVars, RooArgSet*& cloneSet, const char* rangeName = 0, const RooArgSet* condObs = 0) const; virtual RooAbsReal*RooAbsReal::createProfile(const RooArgSet& paramsOfInterest); RooAbsReal*RooAbsReal::createRunningIntegral(const RooArgSet& iset, const RooArgSet& nset = RooArgSet()); RooAbsReal*RooAbsReal::createRunningIntegral(const RooArgSet& iset, const RooCmdArg& arg1, const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()); RooAbsReal*RooAbsReal::createScanRI(const RooArgSet& iset, const RooArgSet& nset, Int_t numScanBins, Int_t intOrder); virtual Double_tRooAbsReal::defaultErrorLevel() const; static RooNumIntConfig*RooAbsReal::defaultIntegratorConfig(); virtual Int_tRooAbsArg::defaultPrintContents(Option_t* opt) const; static ostream&RooPrintable::defaultPrintStream(ostream* os = 0); virtual RooPrintable::StyleOptionRooPrintable::defaultPrintStyle(Option_t* opt) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; Bool_tRooAbsArg::dependentOverlaps(const RooAbsData* dset, const RooAbsArg& testArg) const; Bool_tRooAbsArg::dependentOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; Bool_tRooAbsArg::dependsOn(const RooAbsCollection& serverList, const RooAbsArg* ignoreArg = 0, Bool_t valueOnly = kFALSE) const; Bool_tRooAbsArg::dependsOn(const RooAbsArg& server, const RooAbsArg* ignoreArg = 0, Bool_t valueOnly = kFALSE) const; Bool_tRooAbsArg::dependsOnValue(const RooAbsCollection& serverList, const RooAbsArg* ignoreArg = 0) const; Bool_tRooAbsArg::dependsOnValue(const RooAbsArg& server, const RooAbsArg* ignoreArg = 0) const; RooDerivative*RooAbsReal::derivative(RooRealVar& obs, Int_t order = 1, Double_t eps = 0.",MatchSource.WIKI,root/html602/RooAbsMoment.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsMoment.html
https://root.cern/root/html602/RooAbsMoment.html:8862,Integrability,depend,dependentOverlaps,8862,"l*RooAbsReal::createPlotProjection(const RooArgSet& dependentVars, const RooArgSet* projectedVars, RooArgSet*& cloneSet, const char* rangeName = 0, const RooArgSet* condObs = 0) const; virtual RooAbsReal*RooAbsReal::createProfile(const RooArgSet& paramsOfInterest); RooAbsReal*RooAbsReal::createRunningIntegral(const RooArgSet& iset, const RooArgSet& nset = RooArgSet()); RooAbsReal*RooAbsReal::createRunningIntegral(const RooArgSet& iset, const RooCmdArg& arg1, const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()); RooAbsReal*RooAbsReal::createScanRI(const RooArgSet& iset, const RooArgSet& nset, Int_t numScanBins, Int_t intOrder); virtual Double_tRooAbsReal::defaultErrorLevel() const; static RooNumIntConfig*RooAbsReal::defaultIntegratorConfig(); virtual Int_tRooAbsArg::defaultPrintContents(Option_t* opt) const; static ostream&RooPrintable::defaultPrintStream(ostream* os = 0); virtual RooPrintable::StyleOptionRooPrintable::defaultPrintStyle(Option_t* opt) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; Bool_tRooAbsArg::dependentOverlaps(const RooAbsData* dset, const RooAbsArg& testArg) const; Bool_tRooAbsArg::dependentOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; Bool_tRooAbsArg::dependsOn(const RooAbsCollection& serverList, const RooAbsArg* ignoreArg = 0, Bool_t valueOnly = kFALSE) const; Bool_tRooAbsArg::dependsOn(const RooAbsArg& server, const RooAbsArg* ignoreArg = 0, Bool_t valueOnly = kFALSE) const; Bool_tRooAbsArg::dependsOnValue(const RooAbsCollection& serverList, const RooAbsArg* ignoreArg = 0) const; Bool_tRooAbsArg::dependsOnValue(const RooAbsArg& server, const RooAbsArg* ignoreArg = 0) const; RooDerivative*RooAbsReal::derivative(RooRealVar& obs, Int_t order = 1, Double_t eps = 0.",MatchSource.WIKI,root/html602/RooAbsMoment.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsMoment.html
https://root.cern/root/html602/RooAbsMoment.html:8956,Integrability,depend,dependsOn,8956,"l*RooAbsReal::createPlotProjection(const RooArgSet& dependentVars, const RooArgSet* projectedVars, RooArgSet*& cloneSet, const char* rangeName = 0, const RooArgSet* condObs = 0) const; virtual RooAbsReal*RooAbsReal::createProfile(const RooArgSet& paramsOfInterest); RooAbsReal*RooAbsReal::createRunningIntegral(const RooArgSet& iset, const RooArgSet& nset = RooArgSet()); RooAbsReal*RooAbsReal::createRunningIntegral(const RooArgSet& iset, const RooCmdArg& arg1, const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()); RooAbsReal*RooAbsReal::createScanRI(const RooArgSet& iset, const RooArgSet& nset, Int_t numScanBins, Int_t intOrder); virtual Double_tRooAbsReal::defaultErrorLevel() const; static RooNumIntConfig*RooAbsReal::defaultIntegratorConfig(); virtual Int_tRooAbsArg::defaultPrintContents(Option_t* opt) const; static ostream&RooPrintable::defaultPrintStream(ostream* os = 0); virtual RooPrintable::StyleOptionRooPrintable::defaultPrintStyle(Option_t* opt) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; Bool_tRooAbsArg::dependentOverlaps(const RooAbsData* dset, const RooAbsArg& testArg) const; Bool_tRooAbsArg::dependentOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; Bool_tRooAbsArg::dependsOn(const RooAbsCollection& serverList, const RooAbsArg* ignoreArg = 0, Bool_t valueOnly = kFALSE) const; Bool_tRooAbsArg::dependsOn(const RooAbsArg& server, const RooAbsArg* ignoreArg = 0, Bool_t valueOnly = kFALSE) const; Bool_tRooAbsArg::dependsOnValue(const RooAbsCollection& serverList, const RooAbsArg* ignoreArg = 0) const; Bool_tRooAbsArg::dependsOnValue(const RooAbsArg& server, const RooAbsArg* ignoreArg = 0) const; RooDerivative*RooAbsReal::derivative(RooRealVar& obs, Int_t order = 1, Double_t eps = 0.",MatchSource.WIKI,root/html602/RooAbsMoment.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsMoment.html
https://root.cern/root/html602/RooAbsMoment.html:9085,Integrability,depend,dependsOn,9085,"l*RooAbsReal::createPlotProjection(const RooArgSet& dependentVars, const RooArgSet* projectedVars, RooArgSet*& cloneSet, const char* rangeName = 0, const RooArgSet* condObs = 0) const; virtual RooAbsReal*RooAbsReal::createProfile(const RooArgSet& paramsOfInterest); RooAbsReal*RooAbsReal::createRunningIntegral(const RooArgSet& iset, const RooArgSet& nset = RooArgSet()); RooAbsReal*RooAbsReal::createRunningIntegral(const RooArgSet& iset, const RooCmdArg& arg1, const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()); RooAbsReal*RooAbsReal::createScanRI(const RooArgSet& iset, const RooArgSet& nset, Int_t numScanBins, Int_t intOrder); virtual Double_tRooAbsReal::defaultErrorLevel() const; static RooNumIntConfig*RooAbsReal::defaultIntegratorConfig(); virtual Int_tRooAbsArg::defaultPrintContents(Option_t* opt) const; static ostream&RooPrintable::defaultPrintStream(ostream* os = 0); virtual RooPrintable::StyleOptionRooPrintable::defaultPrintStyle(Option_t* opt) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; Bool_tRooAbsArg::dependentOverlaps(const RooAbsData* dset, const RooAbsArg& testArg) const; Bool_tRooAbsArg::dependentOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; Bool_tRooAbsArg::dependsOn(const RooAbsCollection& serverList, const RooAbsArg* ignoreArg = 0, Bool_t valueOnly = kFALSE) const; Bool_tRooAbsArg::dependsOn(const RooAbsArg& server, const RooAbsArg* ignoreArg = 0, Bool_t valueOnly = kFALSE) const; Bool_tRooAbsArg::dependsOnValue(const RooAbsCollection& serverList, const RooAbsArg* ignoreArg = 0) const; Bool_tRooAbsArg::dependsOnValue(const RooAbsArg& server, const RooAbsArg* ignoreArg = 0) const; RooDerivative*RooAbsReal::derivative(RooRealVar& obs, Int_t order = 1, Double_t eps = 0.",MatchSource.WIKI,root/html602/RooAbsMoment.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsMoment.html
https://root.cern/root/html602/RooAbsMoment.html:9203,Integrability,depend,dependsOnValue,9203,"l*RooAbsReal::createPlotProjection(const RooArgSet& dependentVars, const RooArgSet* projectedVars, RooArgSet*& cloneSet, const char* rangeName = 0, const RooArgSet* condObs = 0) const; virtual RooAbsReal*RooAbsReal::createProfile(const RooArgSet& paramsOfInterest); RooAbsReal*RooAbsReal::createRunningIntegral(const RooArgSet& iset, const RooArgSet& nset = RooArgSet()); RooAbsReal*RooAbsReal::createRunningIntegral(const RooArgSet& iset, const RooCmdArg& arg1, const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()); RooAbsReal*RooAbsReal::createScanRI(const RooArgSet& iset, const RooArgSet& nset, Int_t numScanBins, Int_t intOrder); virtual Double_tRooAbsReal::defaultErrorLevel() const; static RooNumIntConfig*RooAbsReal::defaultIntegratorConfig(); virtual Int_tRooAbsArg::defaultPrintContents(Option_t* opt) const; static ostream&RooPrintable::defaultPrintStream(ostream* os = 0); virtual RooPrintable::StyleOptionRooPrintable::defaultPrintStyle(Option_t* opt) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; Bool_tRooAbsArg::dependentOverlaps(const RooAbsData* dset, const RooAbsArg& testArg) const; Bool_tRooAbsArg::dependentOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; Bool_tRooAbsArg::dependsOn(const RooAbsCollection& serverList, const RooAbsArg* ignoreArg = 0, Bool_t valueOnly = kFALSE) const; Bool_tRooAbsArg::dependsOn(const RooAbsArg& server, const RooAbsArg* ignoreArg = 0, Bool_t valueOnly = kFALSE) const; Bool_tRooAbsArg::dependsOnValue(const RooAbsCollection& serverList, const RooAbsArg* ignoreArg = 0) const; Bool_tRooAbsArg::dependsOnValue(const RooAbsArg& server, const RooAbsArg* ignoreArg = 0) const; RooDerivative*RooAbsReal::derivative(RooRealVar& obs, Int_t order = 1, Double_t eps = 0.",MatchSource.WIKI,root/html602/RooAbsMoment.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsMoment.html
https://root.cern/root/html602/RooAbsMoment.html:9310,Integrability,depend,dependsOnValue,9310,"l*RooAbsReal::createPlotProjection(const RooArgSet& dependentVars, const RooArgSet* projectedVars, RooArgSet*& cloneSet, const char* rangeName = 0, const RooArgSet* condObs = 0) const; virtual RooAbsReal*RooAbsReal::createProfile(const RooArgSet& paramsOfInterest); RooAbsReal*RooAbsReal::createRunningIntegral(const RooArgSet& iset, const RooArgSet& nset = RooArgSet()); RooAbsReal*RooAbsReal::createRunningIntegral(const RooArgSet& iset, const RooCmdArg& arg1, const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()); RooAbsReal*RooAbsReal::createScanRI(const RooArgSet& iset, const RooArgSet& nset, Int_t numScanBins, Int_t intOrder); virtual Double_tRooAbsReal::defaultErrorLevel() const; static RooNumIntConfig*RooAbsReal::defaultIntegratorConfig(); virtual Int_tRooAbsArg::defaultPrintContents(Option_t* opt) const; static ostream&RooPrintable::defaultPrintStream(ostream* os = 0); virtual RooPrintable::StyleOptionRooPrintable::defaultPrintStyle(Option_t* opt) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; Bool_tRooAbsArg::dependentOverlaps(const RooAbsData* dset, const RooAbsArg& testArg) const; Bool_tRooAbsArg::dependentOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; Bool_tRooAbsArg::dependsOn(const RooAbsCollection& serverList, const RooAbsArg* ignoreArg = 0, Bool_t valueOnly = kFALSE) const; Bool_tRooAbsArg::dependsOn(const RooAbsArg& server, const RooAbsArg* ignoreArg = 0, Bool_t valueOnly = kFALSE) const; Bool_tRooAbsArg::dependsOnValue(const RooAbsCollection& serverList, const RooAbsArg* ignoreArg = 0) const; Bool_tRooAbsArg::dependsOnValue(const RooAbsArg& server, const RooAbsArg* ignoreArg = 0) const; RooDerivative*RooAbsReal::derivative(RooRealVar& obs, Int_t order = 1, Double_t eps = 0.",MatchSource.WIKI,root/html602/RooAbsMoment.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsMoment.html
https://root.cern/root/html602/RooAbsMoment.html:17493,Integrability,message,message,17493,"TObject::IsFolder() const; virtual Bool_tRooAbsArg::isFundamental() const; virtual Bool_tRooAbsReal::isIdentical(const RooAbsArg& other, Bool_t assumeSameType = kFALSE); virtual Bool_tRooAbsArg::isLValue() const; virtual Bool_tRooAbsReal::isOffsetting() const; Bool_tTObject::IsOnHeap() const; Bool_tRooAbsArg::isShapeDirty() const; Bool_tRooAbsArg::isShapeServer(const RooAbsArg& arg) const; Bool_tRooAbsArg::isShapeServer(const char* name) const; virtual Bool_tRooAbsArg::IsSortable() const; Bool_tRooAbsArg::isValueDirty() const; Bool_tRooAbsArg::isValueDirtyAndClear() const; Bool_tRooAbsArg::isValueOrShapeDirtyAndClear() const; Bool_tRooAbsArg::isValueServer(const RooAbsArg& arg) const; Bool_tRooAbsArg::isValueServer(const char* name) const; Bool_tTObject::IsZombie() const; voidRooAbsArg::leafNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t recurseNonDerived = kFALSE) const; Bool_tRooAbsArg::localNoDirtyInhibit() const; voidRooAbsReal::logEvalError(const char* message, const char* serverValueString = 0) const; static voidRooAbsReal::logEvalError(const RooAbsReal* originator, const char* origName, const char* message, const char* serverValueString = 0); virtual voidTNamed::ls(Option_t* option = """") const; virtual Double_tRooAbsReal::maxVal(Int_t code) const; voidTObject::MayNotUse(const char* method) const; RooAbsReal*mean(); virtual Int_tRooAbsReal::minTrialSamples(const RooArgSet&) const; RooAbsMoment*RooAbsReal::moment(RooRealVar& obs, Int_t order, Bool_t central, Bool_t takeRoot); RooAbsMoment*RooAbsReal::moment(RooRealVar& obs, const RooArgSet& normObs, Int_t order, Bool_t central, Bool_t takeRoot, Bool_t intNormObs); static voidRooPrintable::nameFieldLength(Int_t newLen); const TNamed*RooAbsArg::namePtr() const; virtual Bool_tTObject::Notify(); Int_tRooAbsArg::numCaches() const; static Int_tRooAbsReal::numEvalErrorItems(); static Int_tRooAbsReal::numEvalErrors(); Bool_tRooAbsArg::observableOverlaps(const RooAbsData* dset, const RooAbsArg& t",MatchSource.WIKI,root/html602/RooAbsMoment.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsMoment.html
https://root.cern/root/html602/RooAbsMoment.html:17644,Integrability,message,message,17644,"ameType = kFALSE); virtual Bool_tRooAbsArg::isLValue() const; virtual Bool_tRooAbsReal::isOffsetting() const; Bool_tTObject::IsOnHeap() const; Bool_tRooAbsArg::isShapeDirty() const; Bool_tRooAbsArg::isShapeServer(const RooAbsArg& arg) const; Bool_tRooAbsArg::isShapeServer(const char* name) const; virtual Bool_tRooAbsArg::IsSortable() const; Bool_tRooAbsArg::isValueDirty() const; Bool_tRooAbsArg::isValueDirtyAndClear() const; Bool_tRooAbsArg::isValueOrShapeDirtyAndClear() const; Bool_tRooAbsArg::isValueServer(const RooAbsArg& arg) const; Bool_tRooAbsArg::isValueServer(const char* name) const; Bool_tTObject::IsZombie() const; voidRooAbsArg::leafNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t recurseNonDerived = kFALSE) const; Bool_tRooAbsArg::localNoDirtyInhibit() const; voidRooAbsReal::logEvalError(const char* message, const char* serverValueString = 0) const; static voidRooAbsReal::logEvalError(const RooAbsReal* originator, const char* origName, const char* message, const char* serverValueString = 0); virtual voidTNamed::ls(Option_t* option = """") const; virtual Double_tRooAbsReal::maxVal(Int_t code) const; voidTObject::MayNotUse(const char* method) const; RooAbsReal*mean(); virtual Int_tRooAbsReal::minTrialSamples(const RooArgSet&) const; RooAbsMoment*RooAbsReal::moment(RooRealVar& obs, Int_t order, Bool_t central, Bool_t takeRoot); RooAbsMoment*RooAbsReal::moment(RooRealVar& obs, const RooArgSet& normObs, Int_t order, Bool_t central, Bool_t takeRoot, Bool_t intNormObs); static voidRooPrintable::nameFieldLength(Int_t newLen); const TNamed*RooAbsArg::namePtr() const; virtual Bool_tTObject::Notify(); Int_tRooAbsArg::numCaches() const; static Int_tRooAbsReal::numEvalErrorItems(); static Int_tRooAbsReal::numEvalErrors(); Bool_tRooAbsArg::observableOverlaps(const RooAbsData* dset, const RooAbsArg& testArg) const; Bool_tRooAbsArg::observableOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; voidTObject::Obsolete(const char* method,",MatchSource.WIKI,root/html602/RooAbsMoment.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsMoment.html
https://root.cern/root/html602/RooAbsMoment.html:35018,Integrability,integrat,integration,35018,"lean attributes; set<string>RooAbsArg::_boolAttribTransient! Transient boolean attributes (not copied in ctor); Bool_tRooAbsReal::_boolValue! Transient cache for bool values from tree branches; UChar_tRooAbsReal::_byteValue! Transient cache for byte values from tree branches; static Bool_tRooAbsReal::_cacheCheckIf true, always validate contents of clean which outcome of evaluate(); deque<RooAbsCache*>RooAbsArg::_cacheListlist of caches; RooRefCountListRooAbsArg::_clientListlist of client objects; RooRefCountListRooAbsArg::_clientListShapesubset of clients that requested shape dirty flag propagation; RooRefCountListRooAbsArg::_clientListValuesubset of clients that requested value dirty flag propagation; TIterator*RooAbsArg::_clientShapeIter! Iterator over _clientListShape; TIterator*RooAbsArg::_clientValueIter! Iterator over _clientListValue; Bool_tRooAbsArg::_deleteWatch! Delete watch flag; RooExpensiveObjectCache*RooAbsArg::_eocachePointer to global cache manager for any expensive components created by this object; Bool_tRooAbsArg::_fastAllow fast access mode in getVal() and proxies; Float_tRooAbsReal::_floatValue! Transient cache for floating point values from tree branches; Bool_tRooAbsReal::_forceNumIntForce numerical integration if flag set; RooRealProxy_funcInput function; static Bool_tRooAbsReal::_globalSelectCompGlobal activation switch for component selection; static Bool_tRooAbsReal::_hideOffsetOffset hiding flag; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; Int_tRooAbsReal::_intValue! Transient cache for integer values from tree branches; Bool_tRooAbsArg::_isConstant! Cached isConstant status; TStringRooAbsReal::_labelPlot label for objects value; RooArgSet*RooAbsReal::_lastNSet!; Bool_tRooAbsArg::_localNoInhibitDirty! Prevent 'AlwaysDirty' mode for this node; RooRealProxy_meanMean (if calculated for central moment); static Int_tRooPrintable::_nameLength; TNamed*RooAbsArg::_namePtr! Do not persist.",MatchSource.WIKI,root/html602/RooAbsMoment.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsMoment.html
https://root.cern/root/html602/RooAbsMoment.html:36718,Integrability,integrat,integrator,36718,"ent 'AlwaysDirty' mode for this node; RooRealProxy_meanMean (if calculated for central moment); static Int_tRooPrintable::_nameLength; TNamed*RooAbsArg::_namePtr! Do not persist. Pointer to global instance of string that matches object named; RooSetProxy_nsetNormalization set (optional); RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; Int_t_orderMoment order; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; Int_tRooAbsReal::_plotBinsNumber of plot bins; Double_tRooAbsReal::_plotMaxMaximum of plot range; Double_tRooAbsReal::_plotMinMinimum of plot range; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; RooRefArrayRooAbsArg::_proxyListlist of proxies; Char_tRooAbsReal::_sbyteValue! Transient cache for signed byte values from tree branches; Bool_tRooAbsReal::_selectComp! Component selection flag for RooAbsPdf::plotCompOn; RooRefCountListRooAbsArg::_serverListlist of server objects; Bool_tRooAbsArg::_shapeDirtyFlag set if value needs recalculating because input shapes modified; RooNumIntConfig*RooAbsReal::_specIntegratorConfigNumeric integrator configuration specific for this object; map<string,string>RooAbsArg::_stringAttribString attributes; Int_t_takeRootReturn n-order root of moment; Bool_tRooAbsReal::_treeVar!do not persist; UInt_tRooAbsReal::_uintValue! Transient cache for unsigned integer values from tree branches; TStringRooAbsReal::_unitUnit for objects value; Double_tRooAbsReal::_valueCache for current value of object; Bool_tRooAbsArg::_valueDirtyFlag set if value needs recalculating because input values modified; static Bool_tRooAbsArg::_verboseDirtyStatic flag controlling verbose messaging for dirty state changes; RooRealProxy_xObservable; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; RooAbsMoment(); Default constructor. RooAbsMoment(const char* name, const char* title,",MatchSource.WIKI,root/html602/RooAbsMoment.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsMoment.html
https://root.cern/root/html602/RooAbsMoment.html:24463,Modifiability,config,config,24463,"e(ostream& out, Option_t* option = """"); TIterator*RooAbsArg::serverIterator() const; RooFIterRooAbsArg::serverMIterator() const; virtual voidRooAbsArg::serverNameChangeHook(const RooAbsArg*, const RooAbsArg*); voidRooAbsArg::setAttribute(const Text_t* name, Bool_t value = kTRUE); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); virtual voidRooAbsArg::setCacheAndTrackHints(RooArgSet&); static voidRooAbsReal::setCacheCheck(Bool_t flag); virtual Bool_tRooAbsReal::setData(RooAbsData&, Bool_t = kTRUE); static voidRooAbsArg::setDirtyInhibit(Bool_t flag); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); static voidRooAbsReal::setEvalErrorLoggingMode(RooAbsReal::ErrorLoggingMode m); virtual voidRooAbsArg::setExpensiveObjectCache(RooExpensiveObjectCache& cache); static voidRooAbsReal::setHideOffset(Bool_t flag); voidRooAbsReal::setIntegratorConfig(); voidRooAbsReal::setIntegratorConfig(const RooNumIntConfig& config); voidRooAbsArg::setLocalNoDirtyInhibit(Bool_t flag) const; virtual voidRooAbsArg::SetName(const char* name); virtual voidRooAbsArg::SetNameTitle(const char* name, const char* title); static voidTObject::SetObjectStat(Bool_t stat); voidRooAbsArg::setOperMode(RooAbsArg::OperMode mode, Bool_t recurseADirty = kTRUE); voidRooAbsReal::setParameterizeIntegral(const RooArgSet& paramVars); voidRooAbsReal::setPlotLabel(const char* label); voidRooAbsArg::setProhibitServerRedirect(Bool_t flag); voidRooAbsArg::setShapeDirty() const; voidRooAbsArg::setStringAttribute(const Text_t* key, const Text_t* value); virtual voidTNamed::SetTitle(const char* title = """")MENU ; voidRooAbsArg::setTransientAttribute(const Text_t* name, Bool_t value = kTRUE); virtual voidTObject::SetUniqueID(UInt_t uid); voidRooAbsReal::setUnit(const char* unit); voidRooAbsArg::setValueDirty() const; TIterator*RooAbsArg::shapeClientIterator() const; RooFIterRooAbsArg::shapeClientMIterator() const; virtual voidShowMembers(TMembe",MatchSource.WIKI,root/html602/RooAbsMoment.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsMoment.html
https://root.cern/root/html602/RooAbsMoment.html:36729,Modifiability,config,configuration,36729,"ent 'AlwaysDirty' mode for this node; RooRealProxy_meanMean (if calculated for central moment); static Int_tRooPrintable::_nameLength; TNamed*RooAbsArg::_namePtr! Do not persist. Pointer to global instance of string that matches object named; RooSetProxy_nsetNormalization set (optional); RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; Int_t_orderMoment order; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; Int_tRooAbsReal::_plotBinsNumber of plot bins; Double_tRooAbsReal::_plotMaxMaximum of plot range; Double_tRooAbsReal::_plotMinMinimum of plot range; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; RooRefArrayRooAbsArg::_proxyListlist of proxies; Char_tRooAbsReal::_sbyteValue! Transient cache for signed byte values from tree branches; Bool_tRooAbsReal::_selectComp! Component selection flag for RooAbsPdf::plotCompOn; RooRefCountListRooAbsArg::_serverListlist of server objects; Bool_tRooAbsArg::_shapeDirtyFlag set if value needs recalculating because input shapes modified; RooNumIntConfig*RooAbsReal::_specIntegratorConfigNumeric integrator configuration specific for this object; map<string,string>RooAbsArg::_stringAttribString attributes; Int_t_takeRootReturn n-order root of moment; Bool_tRooAbsReal::_treeVar!do not persist; UInt_tRooAbsReal::_uintValue! Transient cache for unsigned integer values from tree branches; TStringRooAbsReal::_unitUnit for objects value; Double_tRooAbsReal::_valueCache for current value of object; Bool_tRooAbsArg::_valueDirtyFlag set if value needs recalculating because input values modified; static Bool_tRooAbsArg::_verboseDirtyStatic flag controlling verbose messaging for dirty state changes; RooRealProxy_xObservable; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; RooAbsMoment(); Default constructor. RooAbsMoment(const char* name, const char* title,",MatchSource.WIKI,root/html602/RooAbsMoment.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsMoment.html
https://root.cern/root/html602/RooAbsMoment.html:2136,Performance,cache,cacheUniqueSuffix,2136,"iqueSuffix() const; virtual Double_tRooAbsReal::analyticalIntegral(Int_t code, const char* rangeName = 0) const; virtual Double_tRooAbsReal::analyticalIntegralWN(Int_t code, const RooArgSet* normSet, const char* rangeName = 0) const; virtual voidTObject::AppendPad(Option_t* option = """"); TF1*RooAbsReal::asTF(const RooArgList& obs, const RooArgList& pars = RooArgList(), const RooArgSet& nset = RooArgSet()) const; voidRooAbsArg::attachDataSet(const RooAbsData& set); voidRooAbsArg::attachDataStore(const RooAbsDataStore& set); const set<string>&RooAbsArg::attributes() const; virtual list<Double_t>*RooAbsReal::binBoundaries(RooAbsRealLValue&, Double_t, Double_t) const; RooAbsFunc*RooAbsReal::bindVars(const RooArgSet& vars, const RooArgSet* nset = 0, Bool_t clipInvalid = kFALSE) const; voidRooAbsArg::branchNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t recurseNonDerived = kFALSE) const; virtual voidTObject::Browse(TBrowser* b); virtual const char*RooAbsArg::cacheUniqueSuffix() const; virtual RooAbsArg::CacheModeRooAbsArg::canNodeBeCached() const; Bool_tcentral() const; voidRooAbsArg::changeServer(RooAbsArg& server, Bool_t valueProp, Bool_t shapeProp); Bool_tRooAbsArg::checkDependents(const RooArgSet* nset) const; virtual Bool_tRooAbsArg::checkObservables(const RooArgSet* nset) const; virtual RooFitResult*RooAbsReal::chi2FitTo(RooDataHist& data, const RooLinkedList& cmdList); virtual RooFitResult*RooAbsReal::chi2FitTo(RooDataSet& xydata, const RooLinkedList& cmdList); virtual RooFitResult*RooAbsReal::chi2FitTo(RooDataHist& data, const RooCmdArg& arg1 = RooCmdArg::none(), const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()); virtual RooFitResult*RooAbsReal::chi2FitTo(RooDataSet& xydata, const RooCmdArg& ar",MatchSource.WIKI,root/html602/RooAbsMoment.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsMoment.html
https://root.cern/root/html602/RooAbsMoment.html:11017,Performance,cache,cacheList,11017,"rRooAbsReal::evalErrorIter(); static RooAbsReal::ErrorLoggingModeRooAbsReal::evalErrorLoggingMode(); virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); RooExpensiveObjectCache&RooAbsArg::expensiveObjectCache() const; virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); RooDataHist*RooAbsReal::fillDataHist(RooDataHist* hist, const RooArgSet* nset, Double_t scaleFactor, Bool_t correctForBinVolume = kFALSE, Bool_t showProgress = kFALSE) const; TH1*RooAbsReal::fillHistogram(TH1* hist, const RooArgList& plotVars, Double_t scaleFactor = 1, const RooArgSet* projectedVars = 0, Bool_t scaling = kTRUE, const RooArgSet* condObs = 0, Bool_t setError = kTRUE) const; Bool_tRooAbsArg::findConstantNodes(const RooArgSet& observables, RooArgSet& cacheList); Bool_tRooAbsArg::findConstantNodes(const RooArgSet& observables, RooArgSet& cacheList, RooLinkedList& processedNodes); RooAbsArg*RooAbsArg::findNewServer(const RooAbsCollection& newSet, Bool_t nameChange) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; Double_tRooAbsReal::findRoot(RooRealVar& x, Double_t xmin, Double_t xmax, Double_t yval); RooAbsArg*RooAbsArg::findServer(const char* name) const; RooAbsArg*RooAbsArg::findServer(const RooAbsArg& arg) const; RooAbsArg*RooAbsArg::findServer(Int_t index) const; virtual voidRooAbsReal::fixAddCoefNormalization(const RooArgSet& addNormSet = RooArgSet(), Bool_t force = kTRUE); virtual voidRooAbsReal::fixAddCoefRange(const char* rangeName = 0, Bool_t force = kTRUE); static UInt_tRooAbsArg::fnv1a32(const char* data); static UInt_tRooAbsArg::fnv1a32(const char* data, ULong_t sz, UInt_t hash = fnv1a32start); static ULong64_tRooAbsArg::fnv1a64(const char* data",MatchSource.WIKI,root/html602/RooAbsMoment.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsMoment.html
https://root.cern/root/html602/RooAbsMoment.html:11105,Performance,cache,cacheList,11105,"ggingMode(); virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); RooExpensiveObjectCache&RooAbsArg::expensiveObjectCache() const; virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); RooDataHist*RooAbsReal::fillDataHist(RooDataHist* hist, const RooArgSet* nset, Double_t scaleFactor, Bool_t correctForBinVolume = kFALSE, Bool_t showProgress = kFALSE) const; TH1*RooAbsReal::fillHistogram(TH1* hist, const RooArgList& plotVars, Double_t scaleFactor = 1, const RooArgSet* projectedVars = 0, Bool_t scaling = kTRUE, const RooArgSet* condObs = 0, Bool_t setError = kTRUE) const; Bool_tRooAbsArg::findConstantNodes(const RooArgSet& observables, RooArgSet& cacheList); Bool_tRooAbsArg::findConstantNodes(const RooArgSet& observables, RooArgSet& cacheList, RooLinkedList& processedNodes); RooAbsArg*RooAbsArg::findNewServer(const RooAbsCollection& newSet, Bool_t nameChange) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; Double_tRooAbsReal::findRoot(RooRealVar& x, Double_t xmin, Double_t xmax, Double_t yval); RooAbsArg*RooAbsArg::findServer(const char* name) const; RooAbsArg*RooAbsArg::findServer(const RooAbsArg& arg) const; RooAbsArg*RooAbsArg::findServer(Int_t index) const; virtual voidRooAbsReal::fixAddCoefNormalization(const RooArgSet& addNormSet = RooArgSet(), Bool_t force = kTRUE); virtual voidRooAbsReal::fixAddCoefRange(const char* rangeName = 0, Bool_t force = kTRUE); static UInt_tRooAbsArg::fnv1a32(const char* data); static UInt_tRooAbsArg::fnv1a32(const char* data, ULong_t sz, UInt_t hash = fnv1a32start); static ULong64_tRooAbsArg::fnv1a64(const char* data); static ULong64_tRooAbsArg::fnv1a64(const char* data, ULong_t sz, ULong64_t hash = fnv",MatchSource.WIKI,root/html602/RooAbsMoment.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsMoment.html
https://root.cern/root/html602/RooAbsMoment.html:19349,Performance,optimiz,optimizeCacheMode,19349,"umEvalErrorItems(); static Int_tRooAbsReal::numEvalErrors(); Bool_tRooAbsArg::observableOverlaps(const RooAbsData* dset, const RooAbsArg& testArg) const; Bool_tRooAbsArg::observableOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; virtual Double_tRooAbsReal::offset() const; voidTObject::operator delete(void* ptr); voidTObject::operator delete(void* ptr, void* vp); voidTObject::operator delete[](void* ptr); voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); RooAbsMoment&operator=(const RooAbsMoment&); Bool_tRooAbsReal::operator==(Double_t value) const; virtual Bool_tRooAbsReal::operator==(const RooAbsArg& other); RooAbsArg::OperModeRooAbsArg::operMode() const; virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables); virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables, RooArgSet& optNodes, RooLinkedList& processedNodes); Int_torder() const; Bool_tRooAbsArg::overlaps(const RooAbsArg& testArg, Bool_t valueOnly = kFALSE) const; const RooArgSet*RooAbsArg::ownedComponents() const; virtual voidTObject::Paint(Option_t* option = """"); virtual RooPlot*RooAbsReal::plotOn(RooPlot* frame, RooLinkedList& cmdList) const; virtual RooPlot*RooAbsReal::plotOn(RooPlot* frame, const RooCmdArg& arg1 = RooCmdArg(), const RooCmdArg& arg2 = RooCmdArg(), const RooCmdArg& arg3 = RooCmdArg(), const RooCmdArg& arg4 = RooCmdArg(), const RooCmdArg& arg5 = RooCmdArg(), const RooCmdArg& arg6 = RooCmdArg(), const RooCmdArg& arg7 = RooCmdArg(), const RooCmdArg& arg8 = RooCmdArg(), const RooCmdArg& arg9 = RooCmdArg(), const RooCmdArg& arg10 = RooCmdArg()) const; virtual list<Double_t>*RooAbsReal::plotSamplingHint(RooAbsRealLValue&, Double_t, Double_t) const; virtual RooPlot*Ro",MatchSource.WIKI,root/html602/RooAbsMoment.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsMoment.html
https://root.cern/root/html602/RooAbsMoment.html:19421,Performance,optimiz,optimizeCacheMode,19421,"sArg::observableOverlaps(const RooAbsData* dset, const RooAbsArg& testArg) const; Bool_tRooAbsArg::observableOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; virtual Double_tRooAbsReal::offset() const; voidTObject::operator delete(void* ptr); voidTObject::operator delete(void* ptr, void* vp); voidTObject::operator delete[](void* ptr); voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); RooAbsMoment&operator=(const RooAbsMoment&); Bool_tRooAbsReal::operator==(Double_t value) const; virtual Bool_tRooAbsReal::operator==(const RooAbsArg& other); RooAbsArg::OperModeRooAbsArg::operMode() const; virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables); virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables, RooArgSet& optNodes, RooLinkedList& processedNodes); Int_torder() const; Bool_tRooAbsArg::overlaps(const RooAbsArg& testArg, Bool_t valueOnly = kFALSE) const; const RooArgSet*RooAbsArg::ownedComponents() const; virtual voidTObject::Paint(Option_t* option = """"); virtual RooPlot*RooAbsReal::plotOn(RooPlot* frame, RooLinkedList& cmdList) const; virtual RooPlot*RooAbsReal::plotOn(RooPlot* frame, const RooCmdArg& arg1 = RooCmdArg(), const RooCmdArg& arg2 = RooCmdArg(), const RooCmdArg& arg3 = RooCmdArg(), const RooCmdArg& arg4 = RooCmdArg(), const RooCmdArg& arg5 = RooCmdArg(), const RooCmdArg& arg6 = RooCmdArg(), const RooCmdArg& arg7 = RooCmdArg(), const RooCmdArg& arg8 = RooCmdArg(), const RooCmdArg& arg9 = RooCmdArg(), const RooCmdArg& arg10 = RooCmdArg()) const; virtual list<Double_t>*RooAbsReal::plotSamplingHint(RooAbsRealLValue&, Double_t, Double_t) const; virtual RooPlot*RooAbsReal::plotSliceOn(RooPlot* frame, const RooArgSet& sliceSet, Option_",MatchSource.WIKI,root/html602/RooAbsMoment.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsMoment.html
https://root.cern/root/html602/RooAbsMoment.html:22915,Performance,cache,cache,22915,"rtual voidRooAbsArg::printTitle(ostream& os) const; virtual voidRooAbsArg::printTree(ostream& os, TString indent = """") const; virtual voidRooAbsReal::printValue(ostream& os) const; virtual Int_tTObject::Read(const char* name); virtual Bool_tRooAbsReal::readFromStream(istream& is, Bool_t compact, Bool_t verbose = kFALSE); Bool_tRooAbsArg::recursiveCheckDependents(const RooArgSet* nset) const; Bool_tRooAbsArg::recursiveCheckObservables(const RooArgSet* nset) const; Bool_tRooAbsArg::recursiveRedirectServers(const RooAbsCollection& newServerList, Bool_t mustReplaceAll = kFALSE, Bool_t nameChange = kFALSE, Bool_t recurseInNewSet = kTRUE); virtual voidTObject::RecursiveRemove(TObject* obj); Bool_tRooAbsArg::redirectServers(const RooAbsCollection& newServerList, Bool_t mustReplaceAll = kFALSE, Bool_t nameChange = kFALSE, Bool_t isRecursionStep = kFALSE); virtual Bool_tRooAbsArg::redirectServersHook(const RooAbsCollection&, Bool_t, Bool_t, Bool_t); voidRooAbsArg::registerCache(RooAbsCache& cache); voidRooAbsArg::removeServer(RooAbsArg& server, Bool_t force = kFALSE); voidRooAbsArg::replaceServer(RooAbsArg& oldServer, RooAbsArg& newServer, Bool_t valueProp, Bool_t shapeProp); voidTObject::ResetBit(UInt_t f); RooAbsMoment(); RooAbsMoment(const RooAbsMoment& other, const char* name = 0); RooAbsMoment(const char* name, const char* title, RooAbsReal& func, RooRealVar& x, Int_t order = 1, Bool_t takeRoot = kFALSE); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); TIterator*RooAbsArg::serverIterator() const; RooFIterRooAbsArg::serverMIterator() const; virtual voidRooAbsArg::serverNameChangeHook(const RooAbsArg*, const RooAbsArg*); voidRooAbsArg::setAttribute(const Text_t* name, Bool_t value = kTRUE); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); virtual voidRooAbsArg::setCacheAndTrackHints(RooArgSet&); static voidRooAbsReal::setCacheCheck(Bo",MatchSource.WIKI,root/html602/RooAbsMoment.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsMoment.html
https://root.cern/root/html602/RooAbsMoment.html:24306,Performance,cache,cache,24306,"r = 1, Bool_t takeRoot = kFALSE); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); TIterator*RooAbsArg::serverIterator() const; RooFIterRooAbsArg::serverMIterator() const; virtual voidRooAbsArg::serverNameChangeHook(const RooAbsArg*, const RooAbsArg*); voidRooAbsArg::setAttribute(const Text_t* name, Bool_t value = kTRUE); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); virtual voidRooAbsArg::setCacheAndTrackHints(RooArgSet&); static voidRooAbsReal::setCacheCheck(Bool_t flag); virtual Bool_tRooAbsReal::setData(RooAbsData&, Bool_t = kTRUE); static voidRooAbsArg::setDirtyInhibit(Bool_t flag); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); static voidRooAbsReal::setEvalErrorLoggingMode(RooAbsReal::ErrorLoggingMode m); virtual voidRooAbsArg::setExpensiveObjectCache(RooExpensiveObjectCache& cache); static voidRooAbsReal::setHideOffset(Bool_t flag); voidRooAbsReal::setIntegratorConfig(); voidRooAbsReal::setIntegratorConfig(const RooNumIntConfig& config); voidRooAbsArg::setLocalNoDirtyInhibit(Bool_t flag) const; virtual voidRooAbsArg::SetName(const char* name); virtual voidRooAbsArg::SetNameTitle(const char* name, const char* title); static voidTObject::SetObjectStat(Bool_t stat); voidRooAbsArg::setOperMode(RooAbsArg::OperMode mode, Bool_t recurseADirty = kTRUE); voidRooAbsReal::setParameterizeIntegral(const RooArgSet& paramVars); voidRooAbsReal::setPlotLabel(const char* label); voidRooAbsArg::setProhibitServerRedirect(Bool_t flag); voidRooAbsArg::setShapeDirty() const; voidRooAbsArg::setStringAttribute(const Text_t* key, const Text_t* value); virtual voidTNamed::SetTitle(const char* title = """")MENU ; voidRooAbsArg::setTransientAttribute(const Text_t* name, Bool_t value = kTRUE); virtual voidTObject::SetUniqueID(UInt_t uid); voidRooAbsReal::setUnit(const char* unit); voidRooAb",MatchSource.WIKI,root/html602/RooAbsMoment.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsMoment.html
https://root.cern/root/html602/RooAbsMoment.html:26401,Performance,cache,cache,26401,"voidRooAbsArg::setShapeDirty() const; voidRooAbsArg::setStringAttribute(const Text_t* key, const Text_t* value); virtual voidTNamed::SetTitle(const char* title = """")MENU ; voidRooAbsArg::setTransientAttribute(const Text_t* name, Bool_t value = kTRUE); virtual voidTObject::SetUniqueID(UInt_t uid); voidRooAbsReal::setUnit(const char* unit); voidRooAbsArg::setValueDirty() const; TIterator*RooAbsArg::shapeClientIterator() const; RooFIterRooAbsArg::shapeClientMIterator() const; virtual voidShowMembers(TMemberInspector& insp) const; RooAbsMoment*RooAbsReal::sigma(RooRealVar& obs); RooAbsMoment*RooAbsReal::sigma(RooRealVar& obs, const RooArgSet& nset); virtual Int_tTNamed::Sizeof() const; RooNumIntConfig*RooAbsReal::specialIntegratorConfig() const; RooNumIntConfig*RooAbsReal::specialIntegratorConfig(Bool_t createOnTheFly); virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); const map<string,string>&RooAbsArg::stringAttributes() const; virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; const set<string>&RooAbsArg::transientAttributes() const; voidRooAbsArg::treeNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t doBranch = kTRUE, Bool_t doLeaf = kTRUE, Bool_t valueOnly = kFALSE, Bool_t recurseNonDerived = kFALSE) const; voidRooAbsArg::unRegisterCache(RooAbsCache& cache); virtual voidTObject::UseCurrentStyle(); TIterator*RooAbsArg::valueClientIterator() const; RooFIterRooAbsArg::valueClientMIterator() const; static voidRooAbsArg::verboseDirty(Bool_t flag); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; voidRooAbsArg::wireAllCaches(); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const; virtual voidRooAbsReal::writeToStream(ostream& os, Bool_t compact) const.",MatchSource.WIKI,root/html602/RooAbsMoment.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsMoment.html
https://root.cern/root/html602/RooAbsMoment.html:29470,Performance,optimiz,optimizeDirtyHook,29470,"ual Bool_tRooAbsReal::isValidReal(Double_t value, Bool_t printError = kFALSE) const; voidRooAbsReal::makeProjectionSet(const RooAbsArg* plotVar, const RooArgSet* allVars, RooArgSet& projectedVars, Bool_t silent) const; voidTObject::MakeZombie(); Bool_tRooAbsReal::matchArgs(const RooArgSet& allDeps, RooArgSet& numDeps, const RooArgProxy& a) const; Bool_tRooAbsReal::matchArgs(const RooArgSet& allDeps, RooArgSet& numDeps, const RooArgSet& set) const; Bool_tRooAbsReal::matchArgs(const RooArgSet& allDeps, RooArgSet& numDeps, const RooArgProxy& a, const RooArgProxy& b) const; Bool_tRooAbsReal::matchArgs(const RooArgSet& allDeps, RooArgSet& numDeps, const RooArgProxy& a, const RooArgProxy& b, const RooArgProxy& c) const; Bool_tRooAbsReal::matchArgs(const RooArgSet& allDeps, RooArgSet& numDeps, const RooArgProxy& a, const RooArgProxy& b, const RooArgProxy& c, const RooArgProxy& d) const; Int_tRooAbsArg::numProxies() const; virtual voidRooAbsArg::operModeHook(); virtual voidRooAbsArg::optimizeDirtyHook(const RooArgSet*); virtual RooPlot*RooAbsReal::plotAsymOn(RooPlot* frame, const RooAbsCategoryLValue& asymCat, RooAbsReal::PlotOpt o) const; virtual RooPlot*RooAbsReal::plotOn(RooPlot* frame, RooAbsReal::PlotOpt o) const; voidRooAbsReal::plotOnCompSelect(RooArgSet* selNodes) const; RooPlot*RooAbsReal::plotOnWithErrorBand(RooPlot* frame, const RooFitResult& fr, Double_t Z, const RooArgSet* params, const RooLinkedList& argList, Bool_t method1) const; Bool_tRooAbsReal::plotSanityChecks(RooPlot* frame) const; voidRooAbsArg::printAttribList(ostream& os) const; voidRooAbsArg::registerProxy(RooArgProxy& proxy); voidRooAbsArg::registerProxy(RooSetProxy& proxy); voidRooAbsArg::registerProxy(RooListProxy& proxy); voidRooAbsReal::selectComp(Bool_t flag); virtual voidRooAbsReal::selectNormalization(const RooArgSet* depSet = 0, Bool_t force = kFALSE); virtual voidRooAbsReal::selectNormalizationRange(const char* rangeName = 0, Bool_t force = kFALSE); voidRooAbsArg::setProxyNormSet(const Roo",MatchSource.WIKI,root/html602/RooAbsMoment.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsMoment.html
https://root.cern/root/html602/RooAbsMoment.html:33928,Performance,cache,cache,33928,,MatchSource.WIKI,root/html602/RooAbsMoment.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsMoment.html
https://root.cern/root/html602/RooAbsMoment.html:34011,Performance,cache,cache,34011,,MatchSource.WIKI,root/html602/RooAbsMoment.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsMoment.html
https://root.cern/root/html602/RooAbsMoment.html:34209,Performance,cache,caches,34209,,MatchSource.WIKI,root/html602/RooAbsMoment.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsMoment.html
https://root.cern/root/html602/RooAbsMoment.html:34741,Performance,cache,cache,34741,"string>RooAbsArg::_boolAttribBoolean attributes; set<string>RooAbsArg::_boolAttribTransient! Transient boolean attributes (not copied in ctor); Bool_tRooAbsReal::_boolValue! Transient cache for bool values from tree branches; UChar_tRooAbsReal::_byteValue! Transient cache for byte values from tree branches; static Bool_tRooAbsReal::_cacheCheckIf true, always validate contents of clean which outcome of evaluate(); deque<RooAbsCache*>RooAbsArg::_cacheListlist of caches; RooRefCountListRooAbsArg::_clientListlist of client objects; RooRefCountListRooAbsArg::_clientListShapesubset of clients that requested shape dirty flag propagation; RooRefCountListRooAbsArg::_clientListValuesubset of clients that requested value dirty flag propagation; TIterator*RooAbsArg::_clientShapeIter! Iterator over _clientListShape; TIterator*RooAbsArg::_clientValueIter! Iterator over _clientListValue; Bool_tRooAbsArg::_deleteWatch! Delete watch flag; RooExpensiveObjectCache*RooAbsArg::_eocachePointer to global cache manager for any expensive components created by this object; Bool_tRooAbsArg::_fastAllow fast access mode in getVal() and proxies; Float_tRooAbsReal::_floatValue! Transient cache for floating point values from tree branches; Bool_tRooAbsReal::_forceNumIntForce numerical integration if flag set; RooRealProxy_funcInput function; static Bool_tRooAbsReal::_globalSelectCompGlobal activation switch for component selection; static Bool_tRooAbsReal::_hideOffsetOffset hiding flag; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; Int_tRooAbsReal::_intValue! Transient cache for integer values from tree branches; Bool_tRooAbsArg::_isConstant! Cached isConstant status; TStringRooAbsReal::_labelPlot label for objects value; RooArgSet*RooAbsReal::_lastNSet!; Bool_tRooAbsArg::_localNoInhibitDirty! Prevent 'AlwaysDirty' mode for this node; RooRealProxy_meanMean (if calculated for central moment); static Int_tRooPrintable::_nameLength; TNamed*Roo",MatchSource.WIKI,root/html602/RooAbsMoment.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsMoment.html
https://root.cern/root/html602/RooAbsMoment.html:34920,Performance,cache,cache,34920,"lean attributes; set<string>RooAbsArg::_boolAttribTransient! Transient boolean attributes (not copied in ctor); Bool_tRooAbsReal::_boolValue! Transient cache for bool values from tree branches; UChar_tRooAbsReal::_byteValue! Transient cache for byte values from tree branches; static Bool_tRooAbsReal::_cacheCheckIf true, always validate contents of clean which outcome of evaluate(); deque<RooAbsCache*>RooAbsArg::_cacheListlist of caches; RooRefCountListRooAbsArg::_clientListlist of client objects; RooRefCountListRooAbsArg::_clientListShapesubset of clients that requested shape dirty flag propagation; RooRefCountListRooAbsArg::_clientListValuesubset of clients that requested value dirty flag propagation; TIterator*RooAbsArg::_clientShapeIter! Iterator over _clientListShape; TIterator*RooAbsArg::_clientValueIter! Iterator over _clientListValue; Bool_tRooAbsArg::_deleteWatch! Delete watch flag; RooExpensiveObjectCache*RooAbsArg::_eocachePointer to global cache manager for any expensive components created by this object; Bool_tRooAbsArg::_fastAllow fast access mode in getVal() and proxies; Float_tRooAbsReal::_floatValue! Transient cache for floating point values from tree branches; Bool_tRooAbsReal::_forceNumIntForce numerical integration if flag set; RooRealProxy_funcInput function; static Bool_tRooAbsReal::_globalSelectCompGlobal activation switch for component selection; static Bool_tRooAbsReal::_hideOffsetOffset hiding flag; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; Int_tRooAbsReal::_intValue! Transient cache for integer values from tree branches; Bool_tRooAbsArg::_isConstant! Cached isConstant status; TStringRooAbsReal::_labelPlot label for objects value; RooArgSet*RooAbsReal::_lastNSet!; Bool_tRooAbsArg::_localNoInhibitDirty! Prevent 'AlwaysDirty' mode for this node; RooRealProxy_meanMean (if calculated for central moment); static Int_tRooPrintable::_nameLength; TNamed*RooAbsArg::_namePtr! Do not persist.",MatchSource.WIKI,root/html602/RooAbsMoment.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsMoment.html
https://root.cern/root/html602/RooAbsMoment.html:35366,Performance,cache,cache,35366,"lean attributes; set<string>RooAbsArg::_boolAttribTransient! Transient boolean attributes (not copied in ctor); Bool_tRooAbsReal::_boolValue! Transient cache for bool values from tree branches; UChar_tRooAbsReal::_byteValue! Transient cache for byte values from tree branches; static Bool_tRooAbsReal::_cacheCheckIf true, always validate contents of clean which outcome of evaluate(); deque<RooAbsCache*>RooAbsArg::_cacheListlist of caches; RooRefCountListRooAbsArg::_clientListlist of client objects; RooRefCountListRooAbsArg::_clientListShapesubset of clients that requested shape dirty flag propagation; RooRefCountListRooAbsArg::_clientListValuesubset of clients that requested value dirty flag propagation; TIterator*RooAbsArg::_clientShapeIter! Iterator over _clientListShape; TIterator*RooAbsArg::_clientValueIter! Iterator over _clientListValue; Bool_tRooAbsArg::_deleteWatch! Delete watch flag; RooExpensiveObjectCache*RooAbsArg::_eocachePointer to global cache manager for any expensive components created by this object; Bool_tRooAbsArg::_fastAllow fast access mode in getVal() and proxies; Float_tRooAbsReal::_floatValue! Transient cache for floating point values from tree branches; Bool_tRooAbsReal::_forceNumIntForce numerical integration if flag set; RooRealProxy_funcInput function; static Bool_tRooAbsReal::_globalSelectCompGlobal activation switch for component selection; static Bool_tRooAbsReal::_hideOffsetOffset hiding flag; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; Int_tRooAbsReal::_intValue! Transient cache for integer values from tree branches; Bool_tRooAbsArg::_isConstant! Cached isConstant status; TStringRooAbsReal::_labelPlot label for objects value; RooArgSet*RooAbsReal::_lastNSet!; Bool_tRooAbsArg::_localNoInhibitDirty! Prevent 'AlwaysDirty' mode for this node; RooRealProxy_meanMean (if calculated for central moment); static Int_tRooPrintable::_nameLength; TNamed*RooAbsArg::_namePtr! Do not persist.",MatchSource.WIKI,root/html602/RooAbsMoment.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsMoment.html
https://root.cern/root/html602/RooAbsMoment.html:36371,Performance,cache,cache,36371,"ent 'AlwaysDirty' mode for this node; RooRealProxy_meanMean (if calculated for central moment); static Int_tRooPrintable::_nameLength; TNamed*RooAbsArg::_namePtr! Do not persist. Pointer to global instance of string that matches object named; RooSetProxy_nsetNormalization set (optional); RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; Int_t_orderMoment order; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; Int_tRooAbsReal::_plotBinsNumber of plot bins; Double_tRooAbsReal::_plotMaxMaximum of plot range; Double_tRooAbsReal::_plotMinMinimum of plot range; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; RooRefArrayRooAbsArg::_proxyListlist of proxies; Char_tRooAbsReal::_sbyteValue! Transient cache for signed byte values from tree branches; Bool_tRooAbsReal::_selectComp! Component selection flag for RooAbsPdf::plotCompOn; RooRefCountListRooAbsArg::_serverListlist of server objects; Bool_tRooAbsArg::_shapeDirtyFlag set if value needs recalculating because input shapes modified; RooNumIntConfig*RooAbsReal::_specIntegratorConfigNumeric integrator configuration specific for this object; map<string,string>RooAbsArg::_stringAttribString attributes; Int_t_takeRootReturn n-order root of moment; Bool_tRooAbsReal::_treeVar!do not persist; UInt_tRooAbsReal::_uintValue! Transient cache for unsigned integer values from tree branches; TStringRooAbsReal::_unitUnit for objects value; Double_tRooAbsReal::_valueCache for current value of object; Bool_tRooAbsArg::_valueDirtyFlag set if value needs recalculating because input values modified; static Bool_tRooAbsArg::_verboseDirtyStatic flag controlling verbose messaging for dirty state changes; RooRealProxy_xObservable; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; RooAbsMoment(); Default constructor. RooAbsMoment(const char* name, const char* title,",MatchSource.WIKI,root/html602/RooAbsMoment.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsMoment.html
https://root.cern/root/html602/RooAbsMoment.html:36958,Performance,cache,cache,36958,"ent 'AlwaysDirty' mode for this node; RooRealProxy_meanMean (if calculated for central moment); static Int_tRooPrintable::_nameLength; TNamed*RooAbsArg::_namePtr! Do not persist. Pointer to global instance of string that matches object named; RooSetProxy_nsetNormalization set (optional); RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; Int_t_orderMoment order; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; Int_tRooAbsReal::_plotBinsNumber of plot bins; Double_tRooAbsReal::_plotMaxMaximum of plot range; Double_tRooAbsReal::_plotMinMinimum of plot range; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; RooRefArrayRooAbsArg::_proxyListlist of proxies; Char_tRooAbsReal::_sbyteValue! Transient cache for signed byte values from tree branches; Bool_tRooAbsReal::_selectComp! Component selection flag for RooAbsPdf::plotCompOn; RooRefCountListRooAbsArg::_serverListlist of server objects; Bool_tRooAbsArg::_shapeDirtyFlag set if value needs recalculating because input shapes modified; RooNumIntConfig*RooAbsReal::_specIntegratorConfigNumeric integrator configuration specific for this object; map<string,string>RooAbsArg::_stringAttribString attributes; Int_t_takeRootReturn n-order root of moment; Bool_tRooAbsReal::_treeVar!do not persist; UInt_tRooAbsReal::_uintValue! Transient cache for unsigned integer values from tree branches; TStringRooAbsReal::_unitUnit for objects value; Double_tRooAbsReal::_valueCache for current value of object; Bool_tRooAbsArg::_valueDirtyFlag set if value needs recalculating because input values modified; static Bool_tRooAbsArg::_verboseDirtyStatic flag controlling verbose messaging for dirty state changes; RooRealProxy_xObservable; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; RooAbsMoment(); Default constructor. RooAbsMoment(const char* name, const char* title,",MatchSource.WIKI,root/html602/RooAbsMoment.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsMoment.html
https://root.cern/root/html602/RooAbsMoment.html:11949,Security,hash,hash,11949,"bsArg::findConstantNodes(const RooArgSet& observables, RooArgSet& cacheList); Bool_tRooAbsArg::findConstantNodes(const RooArgSet& observables, RooArgSet& cacheList, RooLinkedList& processedNodes); RooAbsArg*RooAbsArg::findNewServer(const RooAbsCollection& newSet, Bool_t nameChange) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; Double_tRooAbsReal::findRoot(RooRealVar& x, Double_t xmin, Double_t xmax, Double_t yval); RooAbsArg*RooAbsArg::findServer(const char* name) const; RooAbsArg*RooAbsArg::findServer(const RooAbsArg& arg) const; RooAbsArg*RooAbsArg::findServer(Int_t index) const; virtual voidRooAbsReal::fixAddCoefNormalization(const RooArgSet& addNormSet = RooArgSet(), Bool_t force = kTRUE); virtual voidRooAbsReal::fixAddCoefRange(const char* rangeName = 0, Bool_t force = kTRUE); static UInt_tRooAbsArg::fnv1a32(const char* data); static UInt_tRooAbsArg::fnv1a32(const char* data, ULong_t sz, UInt_t hash = fnv1a32start); static ULong64_tRooAbsArg::fnv1a64(const char* data); static ULong64_tRooAbsArg::fnv1a64(const char* data, ULong_t sz, ULong64_t hash = fnv1a64start); virtual Bool_tRooAbsReal::forceAnalyticalInt(const RooAbsArg&) const; virtual voidRooAbsReal::forceNumInt(Bool_t flag = kTRUE); RooFunctor*RooAbsReal::functor(const RooArgList& obs, const RooArgList& pars = RooArgList(), const RooArgSet& nset = RooArgSet()) const; virtual Int_tRooAbsReal::getAnalyticalIntegral(RooArgSet& allVars, RooArgSet& analVars, const char* rangeName = 0) const; virtual Int_tRooAbsReal::getAnalyticalIntegralWN(RooArgSet& allVars, RooArgSet& analVars, const RooArgSet* normSet, const char* rangeName = 0) const; Bool_tRooAbsArg::getAttribute(const Text_t* name) const; RooAbsCache*RooAbsArg::getCache(Int_t index) const; RooLinkedListRooAbsArg::getCloningAncestors() const; RooArgSet*RooAbsArg::getComponents() const; RooArgSet*RooAbsArg::getDependents(const RooArgSet& set) const; RooArgSet*RooAbsArg::ge",MatchSource.WIKI,root/html602/RooAbsMoment.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsMoment.html
https://root.cern/root/html602/RooAbsMoment.html:12100,Security,hash,hash,12100,"t& cacheList, RooLinkedList& processedNodes); RooAbsArg*RooAbsArg::findNewServer(const RooAbsCollection& newSet, Bool_t nameChange) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; Double_tRooAbsReal::findRoot(RooRealVar& x, Double_t xmin, Double_t xmax, Double_t yval); RooAbsArg*RooAbsArg::findServer(const char* name) const; RooAbsArg*RooAbsArg::findServer(const RooAbsArg& arg) const; RooAbsArg*RooAbsArg::findServer(Int_t index) const; virtual voidRooAbsReal::fixAddCoefNormalization(const RooArgSet& addNormSet = RooArgSet(), Bool_t force = kTRUE); virtual voidRooAbsReal::fixAddCoefRange(const char* rangeName = 0, Bool_t force = kTRUE); static UInt_tRooAbsArg::fnv1a32(const char* data); static UInt_tRooAbsArg::fnv1a32(const char* data, ULong_t sz, UInt_t hash = fnv1a32start); static ULong64_tRooAbsArg::fnv1a64(const char* data); static ULong64_tRooAbsArg::fnv1a64(const char* data, ULong_t sz, ULong64_t hash = fnv1a64start); virtual Bool_tRooAbsReal::forceAnalyticalInt(const RooAbsArg&) const; virtual voidRooAbsReal::forceNumInt(Bool_t flag = kTRUE); RooFunctor*RooAbsReal::functor(const RooArgList& obs, const RooArgList& pars = RooArgList(), const RooArgSet& nset = RooArgSet()) const; virtual Int_tRooAbsReal::getAnalyticalIntegral(RooArgSet& allVars, RooArgSet& analVars, const char* rangeName = 0) const; virtual Int_tRooAbsReal::getAnalyticalIntegralWN(RooArgSet& allVars, RooArgSet& analVars, const RooArgSet* normSet, const char* rangeName = 0) const; Bool_tRooAbsArg::getAttribute(const Text_t* name) const; RooAbsCache*RooAbsArg::getCache(Int_t index) const; RooLinkedListRooAbsArg::getCloningAncestors() const; RooArgSet*RooAbsArg::getComponents() const; RooArgSet*RooAbsArg::getDependents(const RooArgSet& set) const; RooArgSet*RooAbsArg::getDependents(const RooAbsData* set) const; RooArgSet*RooAbsArg::getDependents(const RooArgSet* depList) const; virtual Option_t*TObject::GetDrawOption()",MatchSource.WIKI,root/html602/RooAbsMoment.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsMoment.html
https://root.cern/root/html602/RooAbsMoment.html:34105,Security,validat,validate,34105,,MatchSource.WIKI,root/html602/RooAbsMoment.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsMoment.html
https://root.cern/root/html602/RooAbsMoment.html:34841,Security,access,access,34841,"lean attributes; set<string>RooAbsArg::_boolAttribTransient! Transient boolean attributes (not copied in ctor); Bool_tRooAbsReal::_boolValue! Transient cache for bool values from tree branches; UChar_tRooAbsReal::_byteValue! Transient cache for byte values from tree branches; static Bool_tRooAbsReal::_cacheCheckIf true, always validate contents of clean which outcome of evaluate(); deque<RooAbsCache*>RooAbsArg::_cacheListlist of caches; RooRefCountListRooAbsArg::_clientListlist of client objects; RooRefCountListRooAbsArg::_clientListShapesubset of clients that requested shape dirty flag propagation; RooRefCountListRooAbsArg::_clientListValuesubset of clients that requested value dirty flag propagation; TIterator*RooAbsArg::_clientShapeIter! Iterator over _clientListShape; TIterator*RooAbsArg::_clientValueIter! Iterator over _clientListValue; Bool_tRooAbsArg::_deleteWatch! Delete watch flag; RooExpensiveObjectCache*RooAbsArg::_eocachePointer to global cache manager for any expensive components created by this object; Bool_tRooAbsArg::_fastAllow fast access mode in getVal() and proxies; Float_tRooAbsReal::_floatValue! Transient cache for floating point values from tree branches; Bool_tRooAbsReal::_forceNumIntForce numerical integration if flag set; RooRealProxy_funcInput function; static Bool_tRooAbsReal::_globalSelectCompGlobal activation switch for component selection; static Bool_tRooAbsReal::_hideOffsetOffset hiding flag; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; Int_tRooAbsReal::_intValue! Transient cache for integer values from tree branches; Bool_tRooAbsArg::_isConstant! Cached isConstant status; TStringRooAbsReal::_labelPlot label for objects value; RooArgSet*RooAbsReal::_lastNSet!; Bool_tRooAbsArg::_localNoInhibitDirty! Prevent 'AlwaysDirty' mode for this node; RooRealProxy_meanMean (if calculated for central moment); static Int_tRooPrintable::_nameLength; TNamed*RooAbsArg::_namePtr! Do not persist.",MatchSource.WIKI,root/html602/RooAbsMoment.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsMoment.html
https://root.cern/root/html602/RooAbsMoment.html:8829,Testability,test,testArg,8829,"l*RooAbsReal::createPlotProjection(const RooArgSet& dependentVars, const RooArgSet* projectedVars, RooArgSet*& cloneSet, const char* rangeName = 0, const RooArgSet* condObs = 0) const; virtual RooAbsReal*RooAbsReal::createProfile(const RooArgSet& paramsOfInterest); RooAbsReal*RooAbsReal::createRunningIntegral(const RooArgSet& iset, const RooArgSet& nset = RooArgSet()); RooAbsReal*RooAbsReal::createRunningIntegral(const RooArgSet& iset, const RooCmdArg& arg1, const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()); RooAbsReal*RooAbsReal::createScanRI(const RooArgSet& iset, const RooArgSet& nset, Int_t numScanBins, Int_t intOrder); virtual Double_tRooAbsReal::defaultErrorLevel() const; static RooNumIntConfig*RooAbsReal::defaultIntegratorConfig(); virtual Int_tRooAbsArg::defaultPrintContents(Option_t* opt) const; static ostream&RooPrintable::defaultPrintStream(ostream* os = 0); virtual RooPrintable::StyleOptionRooPrintable::defaultPrintStyle(Option_t* opt) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; Bool_tRooAbsArg::dependentOverlaps(const RooAbsData* dset, const RooAbsArg& testArg) const; Bool_tRooAbsArg::dependentOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; Bool_tRooAbsArg::dependsOn(const RooAbsCollection& serverList, const RooAbsArg* ignoreArg = 0, Bool_t valueOnly = kFALSE) const; Bool_tRooAbsArg::dependsOn(const RooAbsArg& server, const RooAbsArg* ignoreArg = 0, Bool_t valueOnly = kFALSE) const; Bool_tRooAbsArg::dependsOnValue(const RooAbsCollection& serverList, const RooAbsArg* ignoreArg = 0) const; Bool_tRooAbsArg::dependsOnValue(const RooAbsArg& server, const RooAbsArg* ignoreArg = 0) const; RooDerivative*RooAbsReal::derivative(RooRealVar& obs, Int_t order = 1, Double_t eps = 0.",MatchSource.WIKI,root/html602/RooAbsMoment.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsMoment.html
https://root.cern/root/html602/RooAbsMoment.html:8923,Testability,test,testArg,8923,"l*RooAbsReal::createPlotProjection(const RooArgSet& dependentVars, const RooArgSet* projectedVars, RooArgSet*& cloneSet, const char* rangeName = 0, const RooArgSet* condObs = 0) const; virtual RooAbsReal*RooAbsReal::createProfile(const RooArgSet& paramsOfInterest); RooAbsReal*RooAbsReal::createRunningIntegral(const RooArgSet& iset, const RooArgSet& nset = RooArgSet()); RooAbsReal*RooAbsReal::createRunningIntegral(const RooArgSet& iset, const RooCmdArg& arg1, const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()); RooAbsReal*RooAbsReal::createScanRI(const RooArgSet& iset, const RooArgSet& nset, Int_t numScanBins, Int_t intOrder); virtual Double_tRooAbsReal::defaultErrorLevel() const; static RooNumIntConfig*RooAbsReal::defaultIntegratorConfig(); virtual Int_tRooAbsArg::defaultPrintContents(Option_t* opt) const; static ostream&RooPrintable::defaultPrintStream(ostream* os = 0); virtual RooPrintable::StyleOptionRooPrintable::defaultPrintStyle(Option_t* opt) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; Bool_tRooAbsArg::dependentOverlaps(const RooAbsData* dset, const RooAbsArg& testArg) const; Bool_tRooAbsArg::dependentOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; Bool_tRooAbsArg::dependsOn(const RooAbsCollection& serverList, const RooAbsArg* ignoreArg = 0, Bool_t valueOnly = kFALSE) const; Bool_tRooAbsArg::dependsOn(const RooAbsArg& server, const RooAbsArg* ignoreArg = 0, Bool_t valueOnly = kFALSE) const; Bool_tRooAbsArg::dependsOnValue(const RooAbsCollection& serverList, const RooAbsArg* ignoreArg = 0) const; Bool_tRooAbsArg::dependsOnValue(const RooAbsArg& server, const RooAbsArg* ignoreArg = 0) const; RooDerivative*RooAbsReal::derivative(RooRealVar& obs, Int_t order = 1, Double_t eps = 0.",MatchSource.WIKI,root/html602/RooAbsMoment.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsMoment.html
https://root.cern/root/html602/RooAbsMoment.html:17468,Testability,log,logEvalError,17468,") const; virtual Bool_tTObject::IsFolder() const; virtual Bool_tRooAbsArg::isFundamental() const; virtual Bool_tRooAbsReal::isIdentical(const RooAbsArg& other, Bool_t assumeSameType = kFALSE); virtual Bool_tRooAbsArg::isLValue() const; virtual Bool_tRooAbsReal::isOffsetting() const; Bool_tTObject::IsOnHeap() const; Bool_tRooAbsArg::isShapeDirty() const; Bool_tRooAbsArg::isShapeServer(const RooAbsArg& arg) const; Bool_tRooAbsArg::isShapeServer(const char* name) const; virtual Bool_tRooAbsArg::IsSortable() const; Bool_tRooAbsArg::isValueDirty() const; Bool_tRooAbsArg::isValueDirtyAndClear() const; Bool_tRooAbsArg::isValueOrShapeDirtyAndClear() const; Bool_tRooAbsArg::isValueServer(const RooAbsArg& arg) const; Bool_tRooAbsArg::isValueServer(const char* name) const; Bool_tTObject::IsZombie() const; voidRooAbsArg::leafNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t recurseNonDerived = kFALSE) const; Bool_tRooAbsArg::localNoDirtyInhibit() const; voidRooAbsReal::logEvalError(const char* message, const char* serverValueString = 0) const; static voidRooAbsReal::logEvalError(const RooAbsReal* originator, const char* origName, const char* message, const char* serverValueString = 0); virtual voidTNamed::ls(Option_t* option = """") const; virtual Double_tRooAbsReal::maxVal(Int_t code) const; voidTObject::MayNotUse(const char* method) const; RooAbsReal*mean(); virtual Int_tRooAbsReal::minTrialSamples(const RooArgSet&) const; RooAbsMoment*RooAbsReal::moment(RooRealVar& obs, Int_t order, Bool_t central, Bool_t takeRoot); RooAbsMoment*RooAbsReal::moment(RooRealVar& obs, const RooArgSet& normObs, Int_t order, Bool_t central, Bool_t takeRoot, Bool_t intNormObs); static voidRooPrintable::nameFieldLength(Int_t newLen); const TNamed*RooAbsArg::namePtr() const; virtual Bool_tTObject::Notify(); Int_tRooAbsArg::numCaches() const; static Int_tRooAbsReal::numEvalErrorItems(); static Int_tRooAbsReal::numEvalErrors(); Bool_tRooAbsArg::observableOverlaps(const RooAbsData* ds",MatchSource.WIKI,root/html602/RooAbsMoment.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsMoment.html
https://root.cern/root/html602/RooAbsMoment.html:17567,Testability,log,logEvalError,17567,"irtual Bool_tRooAbsReal::isIdentical(const RooAbsArg& other, Bool_t assumeSameType = kFALSE); virtual Bool_tRooAbsArg::isLValue() const; virtual Bool_tRooAbsReal::isOffsetting() const; Bool_tTObject::IsOnHeap() const; Bool_tRooAbsArg::isShapeDirty() const; Bool_tRooAbsArg::isShapeServer(const RooAbsArg& arg) const; Bool_tRooAbsArg::isShapeServer(const char* name) const; virtual Bool_tRooAbsArg::IsSortable() const; Bool_tRooAbsArg::isValueDirty() const; Bool_tRooAbsArg::isValueDirtyAndClear() const; Bool_tRooAbsArg::isValueOrShapeDirtyAndClear() const; Bool_tRooAbsArg::isValueServer(const RooAbsArg& arg) const; Bool_tRooAbsArg::isValueServer(const char* name) const; Bool_tTObject::IsZombie() const; voidRooAbsArg::leafNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t recurseNonDerived = kFALSE) const; Bool_tRooAbsArg::localNoDirtyInhibit() const; voidRooAbsReal::logEvalError(const char* message, const char* serverValueString = 0) const; static voidRooAbsReal::logEvalError(const RooAbsReal* originator, const char* origName, const char* message, const char* serverValueString = 0); virtual voidTNamed::ls(Option_t* option = """") const; virtual Double_tRooAbsReal::maxVal(Int_t code) const; voidTObject::MayNotUse(const char* method) const; RooAbsReal*mean(); virtual Int_tRooAbsReal::minTrialSamples(const RooArgSet&) const; RooAbsMoment*RooAbsReal::moment(RooRealVar& obs, Int_t order, Bool_t central, Bool_t takeRoot); RooAbsMoment*RooAbsReal::moment(RooRealVar& obs, const RooArgSet& normObs, Int_t order, Bool_t central, Bool_t takeRoot, Bool_t intNormObs); static voidRooPrintable::nameFieldLength(Int_t newLen); const TNamed*RooAbsArg::namePtr() const; virtual Bool_tTObject::Notify(); Int_tRooAbsArg::numCaches() const; static Int_tRooAbsReal::numEvalErrorItems(); static Int_tRooAbsReal::numEvalErrors(); Bool_tRooAbsArg::observableOverlaps(const RooAbsData* dset, const RooAbsArg& testArg) const; Bool_tRooAbsArg::observableOverlaps(const RooArgSet* depList, ",MatchSource.WIKI,root/html602/RooAbsMoment.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsMoment.html
https://root.cern/root/html602/RooAbsMoment.html:18496,Testability,test,testArg,18496,", const char* serverValueString = 0) const; static voidRooAbsReal::logEvalError(const RooAbsReal* originator, const char* origName, const char* message, const char* serverValueString = 0); virtual voidTNamed::ls(Option_t* option = """") const; virtual Double_tRooAbsReal::maxVal(Int_t code) const; voidTObject::MayNotUse(const char* method) const; RooAbsReal*mean(); virtual Int_tRooAbsReal::minTrialSamples(const RooArgSet&) const; RooAbsMoment*RooAbsReal::moment(RooRealVar& obs, Int_t order, Bool_t central, Bool_t takeRoot); RooAbsMoment*RooAbsReal::moment(RooRealVar& obs, const RooArgSet& normObs, Int_t order, Bool_t central, Bool_t takeRoot, Bool_t intNormObs); static voidRooPrintable::nameFieldLength(Int_t newLen); const TNamed*RooAbsArg::namePtr() const; virtual Bool_tTObject::Notify(); Int_tRooAbsArg::numCaches() const; static Int_tRooAbsReal::numEvalErrorItems(); static Int_tRooAbsReal::numEvalErrors(); Bool_tRooAbsArg::observableOverlaps(const RooAbsData* dset, const RooAbsArg& testArg) const; Bool_tRooAbsArg::observableOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; virtual Double_tRooAbsReal::offset() const; voidTObject::operator delete(void* ptr); voidTObject::operator delete(void* ptr, void* vp); voidTObject::operator delete[](void* ptr); voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); RooAbsMoment&operator=(const RooAbsMoment&); Bool_tRooAbsReal::operator==(Double_t value) const; virtual Bool_tRooAbsReal::operator==(const RooAbsArg& other); RooAbsArg::OperModeRooAbsArg::operMode() const; virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables); virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables, RooArgSet& optNodes, RooLinkedL",MatchSource.WIKI,root/html602/RooAbsMoment.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsMoment.html
https://root.cern/root/html602/RooAbsMoment.html:18591,Testability,test,testArg,18591,"l* originator, const char* origName, const char* message, const char* serverValueString = 0); virtual voidTNamed::ls(Option_t* option = """") const; virtual Double_tRooAbsReal::maxVal(Int_t code) const; voidTObject::MayNotUse(const char* method) const; RooAbsReal*mean(); virtual Int_tRooAbsReal::minTrialSamples(const RooArgSet&) const; RooAbsMoment*RooAbsReal::moment(RooRealVar& obs, Int_t order, Bool_t central, Bool_t takeRoot); RooAbsMoment*RooAbsReal::moment(RooRealVar& obs, const RooArgSet& normObs, Int_t order, Bool_t central, Bool_t takeRoot, Bool_t intNormObs); static voidRooPrintable::nameFieldLength(Int_t newLen); const TNamed*RooAbsArg::namePtr() const; virtual Bool_tTObject::Notify(); Int_tRooAbsArg::numCaches() const; static Int_tRooAbsReal::numEvalErrorItems(); static Int_tRooAbsReal::numEvalErrors(); Bool_tRooAbsArg::observableOverlaps(const RooAbsData* dset, const RooAbsArg& testArg) const; Bool_tRooAbsArg::observableOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; virtual Double_tRooAbsReal::offset() const; voidTObject::operator delete(void* ptr); voidTObject::operator delete(void* ptr, void* vp); voidTObject::operator delete[](void* ptr); voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); RooAbsMoment&operator=(const RooAbsMoment&); Bool_tRooAbsReal::operator==(Double_t value) const; virtual Bool_tRooAbsReal::operator==(const RooAbsArg& other); RooAbsArg::OperModeRooAbsArg::operMode() const; virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables); virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables, RooArgSet& optNodes, RooLinkedList& processedNodes); Int_torder() const; Bool_tRooAbsArg::overlaps(const RooAbsArg& testArg, B",MatchSource.WIKI,root/html602/RooAbsMoment.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsMoment.html
https://root.cern/root/html602/RooAbsMoment.html:19585,Testability,test,testArg,19585,"t, const RooAbsArg& testArg) const; Bool_tRooAbsArg::observableOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; virtual Double_tRooAbsReal::offset() const; voidTObject::operator delete(void* ptr); voidTObject::operator delete(void* ptr, void* vp); voidTObject::operator delete[](void* ptr); voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); RooAbsMoment&operator=(const RooAbsMoment&); Bool_tRooAbsReal::operator==(Double_t value) const; virtual Bool_tRooAbsReal::operator==(const RooAbsArg& other); RooAbsArg::OperModeRooAbsArg::operMode() const; virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables); virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables, RooArgSet& optNodes, RooLinkedList& processedNodes); Int_torder() const; Bool_tRooAbsArg::overlaps(const RooAbsArg& testArg, Bool_t valueOnly = kFALSE) const; const RooArgSet*RooAbsArg::ownedComponents() const; virtual voidTObject::Paint(Option_t* option = """"); virtual RooPlot*RooAbsReal::plotOn(RooPlot* frame, RooLinkedList& cmdList) const; virtual RooPlot*RooAbsReal::plotOn(RooPlot* frame, const RooCmdArg& arg1 = RooCmdArg(), const RooCmdArg& arg2 = RooCmdArg(), const RooCmdArg& arg3 = RooCmdArg(), const RooCmdArg& arg4 = RooCmdArg(), const RooCmdArg& arg5 = RooCmdArg(), const RooCmdArg& arg6 = RooCmdArg(), const RooCmdArg& arg7 = RooCmdArg(), const RooCmdArg& arg8 = RooCmdArg(), const RooCmdArg& arg9 = RooCmdArg(), const RooCmdArg& arg10 = RooCmdArg()) const; virtual list<Double_t>*RooAbsReal::plotSamplingHint(RooAbsRealLValue&, Double_t, Double_t) const; virtual RooPlot*RooAbsReal::plotSliceOn(RooPlot* frame, const RooArgSet& sliceSet, Option_t* drawOptions = ""L"", Double_t scaleFactor = 1.",MatchSource.WIKI,root/html602/RooAbsMoment.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsMoment.html
https://root.cern/root/html602/RooAbsMoment.html:3614,Usability,clear,clearEvalErrorLog,3614,", const RooLinkedList& cmdList); virtual RooFitResult*RooAbsReal::chi2FitTo(RooDataHist& data, const RooCmdArg& arg1 = RooCmdArg::none(), const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()); virtual RooFitResult*RooAbsReal::chi2FitTo(RooDataSet& xydata, const RooCmdArg& arg1 = RooCmdArg::none(), const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); static voidRooAbsReal::clearEvalErrorLog(); voidRooAbsArg::clearShapeDirty() const; voidRooAbsArg::clearValueAndShapeDirty() const; voidRooAbsArg::clearValueDirty() const; TIterator*RooAbsArg::clientIterator() const; virtual TObject*RooAbsArg::clone(const char* newname = 0) const; virtual TObject*RooAbsArg::Clone(const char* newname = 0) const; virtual RooAbsArg*RooAbsArg::cloneTree(const char* newname = 0) const; virtual Int_tRooAbsArg::Compare(const TObject* other) const; virtual voidRooAbsArg::constOptimizeTestStatistic(RooAbsArg::ConstOpCode opcode, Bool_t doAlsoTrackingOpt = kTRUE); virtual voidTNamed::Copy(TObject& named) const; static UInt_tRooAbsArg::crc32(const char* data); static UInt_tRooAbsArg::crc32(const char* data, ULong_t sz, UInt_t crc = 0); virtual RooAbsReal*RooAbsReal::createChi2(RooDataHist& data, const RooLinkedList& cmdList); virtual RooAbsReal*RooAbsReal::createChi2(RooDataSet& data, const RooLinkedList& cmdList); virtual RooAbsReal*RooAbsReal::createChi2(RooDataHist& data, const RooCmdArg& ar",MatchSource.WIKI,root/html602/RooAbsMoment.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsMoment.html
https://root.cern/root/html602/RooAbsMoment.html:3650,Usability,clear,clearShapeDirty,3650,"rtual RooFitResult*RooAbsReal::chi2FitTo(RooDataHist& data, const RooCmdArg& arg1 = RooCmdArg::none(), const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()); virtual RooFitResult*RooAbsReal::chi2FitTo(RooDataSet& xydata, const RooCmdArg& arg1 = RooCmdArg::none(), const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); static voidRooAbsReal::clearEvalErrorLog(); voidRooAbsArg::clearShapeDirty() const; voidRooAbsArg::clearValueAndShapeDirty() const; voidRooAbsArg::clearValueDirty() const; TIterator*RooAbsArg::clientIterator() const; virtual TObject*RooAbsArg::clone(const char* newname = 0) const; virtual TObject*RooAbsArg::Clone(const char* newname = 0) const; virtual RooAbsArg*RooAbsArg::cloneTree(const char* newname = 0) const; virtual Int_tRooAbsArg::Compare(const TObject* other) const; virtual voidRooAbsArg::constOptimizeTestStatistic(RooAbsArg::ConstOpCode opcode, Bool_t doAlsoTrackingOpt = kTRUE); virtual voidTNamed::Copy(TObject& named) const; static UInt_tRooAbsArg::crc32(const char* data); static UInt_tRooAbsArg::crc32(const char* data, ULong_t sz, UInt_t crc = 0); virtual RooAbsReal*RooAbsReal::createChi2(RooDataHist& data, const RooLinkedList& cmdList); virtual RooAbsReal*RooAbsReal::createChi2(RooDataSet& data, const RooLinkedList& cmdList); virtual RooAbsReal*RooAbsReal::createChi2(RooDataHist& data, const RooCmdArg& arg1 = RooCmdArg::none(), const RooCm",MatchSource.WIKI,root/html602/RooAbsMoment.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsMoment.html
https://root.cern/root/html602/RooAbsMoment.html:3690,Usability,clear,clearValueAndShapeDirty,3690,"DataHist& data, const RooCmdArg& arg1 = RooCmdArg::none(), const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()); virtual RooFitResult*RooAbsReal::chi2FitTo(RooDataSet& xydata, const RooCmdArg& arg1 = RooCmdArg::none(), const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); static voidRooAbsReal::clearEvalErrorLog(); voidRooAbsArg::clearShapeDirty() const; voidRooAbsArg::clearValueAndShapeDirty() const; voidRooAbsArg::clearValueDirty() const; TIterator*RooAbsArg::clientIterator() const; virtual TObject*RooAbsArg::clone(const char* newname = 0) const; virtual TObject*RooAbsArg::Clone(const char* newname = 0) const; virtual RooAbsArg*RooAbsArg::cloneTree(const char* newname = 0) const; virtual Int_tRooAbsArg::Compare(const TObject* other) const; virtual voidRooAbsArg::constOptimizeTestStatistic(RooAbsArg::ConstOpCode opcode, Bool_t doAlsoTrackingOpt = kTRUE); virtual voidTNamed::Copy(TObject& named) const; static UInt_tRooAbsArg::crc32(const char* data); static UInt_tRooAbsArg::crc32(const char* data, ULong_t sz, UInt_t crc = 0); virtual RooAbsReal*RooAbsReal::createChi2(RooDataHist& data, const RooLinkedList& cmdList); virtual RooAbsReal*RooAbsReal::createChi2(RooDataSet& data, const RooLinkedList& cmdList); virtual RooAbsReal*RooAbsReal::createChi2(RooDataHist& data, const RooCmdArg& arg1 = RooCmdArg::none(), const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmd",MatchSource.WIKI,root/html602/RooAbsMoment.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsMoment.html
https://root.cern/root/html602/RooAbsMoment.html:3738,Usability,clear,clearValueDirty,3738,"mdArg::none(), const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()); virtual RooFitResult*RooAbsReal::chi2FitTo(RooDataSet& xydata, const RooCmdArg& arg1 = RooCmdArg::none(), const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); static voidRooAbsReal::clearEvalErrorLog(); voidRooAbsArg::clearShapeDirty() const; voidRooAbsArg::clearValueAndShapeDirty() const; voidRooAbsArg::clearValueDirty() const; TIterator*RooAbsArg::clientIterator() const; virtual TObject*RooAbsArg::clone(const char* newname = 0) const; virtual TObject*RooAbsArg::Clone(const char* newname = 0) const; virtual RooAbsArg*RooAbsArg::cloneTree(const char* newname = 0) const; virtual Int_tRooAbsArg::Compare(const TObject* other) const; virtual voidRooAbsArg::constOptimizeTestStatistic(RooAbsArg::ConstOpCode opcode, Bool_t doAlsoTrackingOpt = kTRUE); virtual voidTNamed::Copy(TObject& named) const; static UInt_tRooAbsArg::crc32(const char* data); static UInt_tRooAbsArg::crc32(const char* data, ULong_t sz, UInt_t crc = 0); virtual RooAbsReal*RooAbsReal::createChi2(RooDataHist& data, const RooLinkedList& cmdList); virtual RooAbsReal*RooAbsReal::createChi2(RooDataSet& data, const RooLinkedList& cmdList); virtual RooAbsReal*RooAbsReal::createChi2(RooDataHist& data, const RooCmdArg& arg1 = RooCmdArg::none(), const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdA",MatchSource.WIKI,root/html602/RooAbsMoment.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsMoment.html
https://root.cern/root/html602/RooAbsNumGenerator.html:605,Availability,avail,available,605,". RooAbsNumGenerator. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » ROOFIT; » ROOFITCORE; » RooAbsNumGenerator. class RooAbsNumGenerator: public TNamed, public RooPrintable. Class RooAbsNumGenerator is the abstract base class for MC event generator; implementations like RooAcceptReject and RooFoam; . Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~RooAbsNumGenerator(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); voidattachParameters(const RooArgSet& vars); virtual voidTObject::Browse(TBrowser* b); virtual Bool_tcanSampleCategories() const; virtual Bool_tcanSampleConditional() const; static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual RooAbsNumGenerator*clone(const RooAbsReal&, const RooArgSet& genVars, const RooArgSet& condVars, const RooNumGenConfig& config, Bool_t verbose = kFALSE, const RooAbsReal* maxFuncVal = 0) const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual Int_tRooPrintable::defaultPrintContents(Option_t* opt) const; static ostream&RooPrintable::defaultPrintStream(ostream* os = 0); virtual RooPrintable::StyleOptionRooPrintable::defaultPrintStyle(Option_t* opt) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voi",MatchSource.WIKI,root/html602/RooAbsNumGenerator.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsNumGenerator.html
https://root.cern/root/html602/RooAbsNumGenerator.html:2140,Availability,error,error,2140," RooAbsNumGenerator*clone(const RooAbsReal&, const RooArgSet& genVars, const RooArgSet& condVars, const RooNumGenConfig& config, Bool_t verbose = kFALSE, const RooAbsReal* maxFuncVal = 0) const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual Int_tRooPrintable::defaultPrintContents(Option_t* opt) const; static ostream&RooPrintable::defaultPrintStream(ostream* os = 0); virtual RooPrintable::StyleOptionRooPrintable::defaultPrintStyle(Option_t* opt) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual const RooArgSet*generateEvent(UInt_t remaining, Double_t& resampleRatio); virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual Double_tgetFuncMax(); virtual const char*TObject::GetIconName() const; virtual const char*TNamed::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual const char*TNamed::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tT",MatchSource.WIKI,root/html602/RooAbsNumGenerator.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsNumGenerator.html
https://root.cern/root/html602/RooAbsNumGenerator.html:2224,Availability,error,error,2224,"et& condVars, const RooNumGenConfig& config, Bool_t verbose = kFALSE, const RooAbsReal* maxFuncVal = 0) const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual Int_tRooPrintable::defaultPrintContents(Option_t* opt) const; static ostream&RooPrintable::defaultPrintStream(ostream* os = 0); virtual RooPrintable::StyleOptionRooPrintable::defaultPrintStyle(Option_t* opt) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual const RooArgSet*generateEvent(UInt_t remaining, Double_t& resampleRatio); virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual Double_tgetFuncMax(); virtual const char*TObject::GetIconName() const; virtual const char*TNamed::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual const char*TNamed::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTNamed::Hash() const; virtual voidTObject::Info(const char* method, const char* msgfm",MatchSource.WIKI,root/html602/RooAbsNumGenerator.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsNumGenerator.html
https://root.cern/root/html602/RooAbsNumGenerator.html:9708,Integrability,depend,dependents,9708,"ClonePointer to top level node of cloned function; const RooAbsReal*_funcMaxValContainer for maximum function value; RooRealVar*_funcValPtrRRVs storing function value in context and in output dataset; RooRealVar*_funcValStoreRRVs storing function value in context and in output dataset; Bool_t_isValidVerbose and valid flag; static Int_tRooPrintable::_nameLength; RooArgSet_realVarsSets of discrete and real valued observabeles; Bool_t_verboseVerbose and valid flag; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; RooAbsNumGenerator(const RooAbsReal& func, const RooArgSet& genVars, Bool_t verbose = kFALSE, const RooAbsReal* maxFuncVal = 0); Initialize an accept-reject generator for the specified distribution function,; which must be non-negative but does not need to be normalized over the; variables to be generated, genVars. The function and its dependents are; cloned and so will not be disturbed during the generation process. ~RooAbsNumGenerator(); Destructor. void attachParameters(const RooArgSet& vars); Reattach original parameters to function clone. void printName(ostream& os) const; Print name of the generator. void printTitle(ostream& os) const; Print the title of the generator. void printClassName(ostream& os) const; Print the class name of the generator. void printArgs(ostream& os) const; Print the arguments of the generator. RooAbsNumGenerator(); {}. RooAbsNumGenerator(const RooAbsReal& func, const RooArgSet& genVars, Bool_t verbose = kFALSE, const RooAbsReal* maxFuncVal = 0). RooAbsNumGenerator* clone(const RooAbsReal& , const RooArgSet& genVars, const RooArgSet& condVars, const RooNumGenConfig& config, Bool_t verbose = kFALSE, const RooAbsReal* maxFuncVal = 0) const; If true, generator is in a valid state. void setVerbose(Bool_t verbose = kTRUE); If flag is true, verbose messaging will be active during generation. Bool_t isVerbose() const; Retur",MatchSource.WIKI,root/html602/RooAbsNumGenerator.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsNumGenerator.html
https://root.cern/root/html602/RooAbsNumGenerator.html:10945,Integrability,interface,interface,10945," Libraries. Function documentation; RooAbsNumGenerator(const RooAbsReal& func, const RooArgSet& genVars, Bool_t verbose = kFALSE, const RooAbsReal* maxFuncVal = 0); Initialize an accept-reject generator for the specified distribution function,; which must be non-negative but does not need to be normalized over the; variables to be generated, genVars. The function and its dependents are; cloned and so will not be disturbed during the generation process. ~RooAbsNumGenerator(); Destructor. void attachParameters(const RooArgSet& vars); Reattach original parameters to function clone. void printName(ostream& os) const; Print name of the generator. void printTitle(ostream& os) const; Print the title of the generator. void printClassName(ostream& os) const; Print the class name of the generator. void printArgs(ostream& os) const; Print the arguments of the generator. RooAbsNumGenerator(); {}. RooAbsNumGenerator(const RooAbsReal& func, const RooArgSet& genVars, Bool_t verbose = kFALSE, const RooAbsReal* maxFuncVal = 0). RooAbsNumGenerator* clone(const RooAbsReal& , const RooArgSet& genVars, const RooArgSet& condVars, const RooNumGenConfig& config, Bool_t verbose = kFALSE, const RooAbsReal* maxFuncVal = 0) const; If true, generator is in a valid state. void setVerbose(Bool_t verbose = kTRUE); If flag is true, verbose messaging will be active during generation. Bool_t isVerbose() const; Return status of verbose messaging flag. const RooArgSet * generateEvent(UInt_t remaining, Double_t& resampleRatio). Double_t getFuncMax(); { return 0 ; }. void Print(Option_t* options = 0) const; ascii printing interface. Bool_t canSampleCategories() const; Advertisement of capabilities. { return kFALSE ; }. Bool_t canSampleConditional() const; { return kFALSE ; }. » Last changed: Tue Jun 30 14:30:14 2015 » Last generated: 2015-06-30 14:30; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html602/RooAbsNumGenerator.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsNumGenerator.html
https://root.cern/root/html602/RooAbsNumGenerator.html:1264,Modifiability,config,config,1264," virtual~RooAbsNumGenerator(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); voidattachParameters(const RooArgSet& vars); virtual voidTObject::Browse(TBrowser* b); virtual Bool_tcanSampleCategories() const; virtual Bool_tcanSampleConditional() const; static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual RooAbsNumGenerator*clone(const RooAbsReal&, const RooArgSet& genVars, const RooArgSet& condVars, const RooNumGenConfig& config, Bool_t verbose = kFALSE, const RooAbsReal* maxFuncVal = 0) const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual Int_tRooPrintable::defaultPrintContents(Option_t* opt) const; static ostream&RooPrintable::defaultPrintStream(ostream* os = 0); virtual RooPrintable::StyleOptionRooPrintable::defaultPrintStyle(Option_t* opt) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voi",MatchSource.WIKI,root/html602/RooAbsNumGenerator.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsNumGenerator.html
https://root.cern/root/html602/RooAbsNumGenerator.html:9651,Modifiability,variab,variables,9651,":kZombie. protected:. RooDataSet*_cacheDataset holding generared values of observables; RooArgSet_catVarsSets of discrete and real valued observabeles; RooArgSet*_cloneSetSet owning clone of input function; RooAbsReal*_funcClonePointer to top level node of cloned function; const RooAbsReal*_funcMaxValContainer for maximum function value; RooRealVar*_funcValPtrRRVs storing function value in context and in output dataset; RooRealVar*_funcValStoreRRVs storing function value in context and in output dataset; Bool_t_isValidVerbose and valid flag; static Int_tRooPrintable::_nameLength; RooArgSet_realVarsSets of discrete and real valued observabeles; Bool_t_verboseVerbose and valid flag; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; RooAbsNumGenerator(const RooAbsReal& func, const RooArgSet& genVars, Bool_t verbose = kFALSE, const RooAbsReal* maxFuncVal = 0); Initialize an accept-reject generator for the specified distribution function,; which must be non-negative but does not need to be normalized over the; variables to be generated, genVars. The function and its dependents are; cloned and so will not be disturbed during the generation process. ~RooAbsNumGenerator(); Destructor. void attachParameters(const RooArgSet& vars); Reattach original parameters to function clone. void printName(ostream& os) const; Print name of the generator. void printTitle(ostream& os) const; Print the title of the generator. void printClassName(ostream& os) const; Print the class name of the generator. void printArgs(ostream& os) const; Print the arguments of the generator. RooAbsNumGenerator(); {}. RooAbsNumGenerator(const RooAbsReal& func, const RooArgSet& genVars, Bool_t verbose = kFALSE, const RooAbsReal* maxFuncVal = 0). RooAbsNumGenerator* clone(const RooAbsReal& , const RooArgSet& genVars, const RooArgSet& condVars, const RooNumGenConfig& config, Bool_t verbose = kFALSE, ",MatchSource.WIKI,root/html602/RooAbsNumGenerator.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsNumGenerator.html
https://root.cern/root/html602/RooAbsNumGenerator.html:10483,Modifiability,config,config,10483," Libraries. Function documentation; RooAbsNumGenerator(const RooAbsReal& func, const RooArgSet& genVars, Bool_t verbose = kFALSE, const RooAbsReal* maxFuncVal = 0); Initialize an accept-reject generator for the specified distribution function,; which must be non-negative but does not need to be normalized over the; variables to be generated, genVars. The function and its dependents are; cloned and so will not be disturbed during the generation process. ~RooAbsNumGenerator(); Destructor. void attachParameters(const RooArgSet& vars); Reattach original parameters to function clone. void printName(ostream& os) const; Print name of the generator. void printTitle(ostream& os) const; Print the title of the generator. void printClassName(ostream& os) const; Print the class name of the generator. void printArgs(ostream& os) const; Print the arguments of the generator. RooAbsNumGenerator(); {}. RooAbsNumGenerator(const RooAbsReal& func, const RooArgSet& genVars, Bool_t verbose = kFALSE, const RooAbsReal* maxFuncVal = 0). RooAbsNumGenerator* clone(const RooAbsReal& , const RooArgSet& genVars, const RooArgSet& condVars, const RooNumGenConfig& config, Bool_t verbose = kFALSE, const RooAbsReal* maxFuncVal = 0) const; If true, generator is in a valid state. void setVerbose(Bool_t verbose = kTRUE); If flag is true, verbose messaging will be active during generation. Bool_t isVerbose() const; Return status of verbose messaging flag. const RooArgSet * generateEvent(UInt_t remaining, Double_t& resampleRatio). Double_t getFuncMax(); { return 0 ; }. void Print(Option_t* options = 0) const; ascii printing interface. Bool_t canSampleCategories() const; Advertisement of capabilities. { return kFALSE ; }. Bool_t canSampleConditional() const; { return kFALSE ; }. » Last changed: Tue Jun 30 14:30:14 2015 » Last generated: 2015-06-30 14:30; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html602/RooAbsNumGenerator.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsNumGenerator.html
https://root.cern/root/html602/RooAbsOptTestStatistic.html:1212,Availability,avail,available,1212," data members; class charts. ROOT; » ROOFIT; » ROOFITCORE; » RooAbsOptTestStatistic. class RooAbsOptTestStatistic: public RooAbsTestStatistic. RooAbsOptTestStatistic is the abstract base class for test; statistics objects that evaluate a function or PDF at each point of a given; dataset. This class provides generic optimizations, such as; caching and precalculation of constant terms that can be made for; all such quantities; Implementations should define evaluatePartition(), which calculates the; value of a (sub)range of the dataset and optionally combinedValue(),; which combines the values calculated for each partition. If combinedValue(); is not overloaded, the default implementation will add the partition results; to obtain the combined result; Support for calculation in partitions is needed to allow multi-core; parallelized calculation of test statistics; . Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~RooAbsOptTestStatistic(); voidTObject::AbstractMethod(const char* method) const; Bool_tRooAbsArg::addOwnedComponents(const RooArgSet& comps); voidRooAbsArg::addParameters(RooArgSet& params, const RooArgSet* nset = 0, Bool_t stripDisconnected = kTRUE) const; voidRooAbsArg::addServer(RooAbsArg& server, Bool_t valueProp = kTRUE, Bool_t shapeProp = kFALSE); voidRooAbsArg::addServerList(RooAbsCollection& serverList, Bool_t valueProp = kTRUE, Bool_t shapeProp = kFALSE); const char*RooAbsArg::aggregateCacheUniqueSuffix() const; virtual Double_tRooAbsReal::analyticalIntegral(Int_t code, const char* rangeName = 0) const; virtual Double_tRooAbsReal::analyticalIntegralWN(Int_t code, const RooArgSet* normSet, const char* rangeName = 0) const; virtual voidTObject::AppendPad(Option_t* option = """"); TF1*RooAbsReal::asTF(const RooArgList& obs, const RooArgList& pars = RooArgList(), const RooArgSet& nset = RooArgSet()) const; voidRooAbsArg::attachDataSet",MatchSource.WIKI,root/html602/RooAbsOptTestStatistic.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsOptTestStatistic.html
https://root.cern/root/html602/RooAbsOptTestStatistic.html:11167,Availability,error,error,11167,,MatchSource.WIKI,root/html602/RooAbsOptTestStatistic.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsOptTestStatistic.html
https://root.cern/root/html602/RooAbsOptTestStatistic.html:11251,Availability,error,error,11251,,MatchSource.WIKI,root/html602/RooAbsOptTestStatistic.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsOptTestStatistic.html
https://root.cern/root/html602/RooAbsOptTestStatistic.html:38821,Deployability,integrat,integration,38821,esubset of clients that requested value dirty flag propagation; TIterator*RooAbsArg::_clientShapeIter! Iterator over _clientListShape; TIterator*RooAbsArg::_clientValueIter! Iterator over _clientListValue; RooAbsData*RooAbsTestStatistic::_dataPointer to original input dataset; RooAbsData*_dataClonePointer to internal clone if input data; Bool_tRooAbsArg::_deleteWatch! Delete watch flag; Bool_tRooAbsTestStatistic::_doOffsetApply interval value offset to control numeric precision?; RooExpensiveObjectCache*RooAbsArg::_eocachePointer to global cache manager for any expensive components created by this object; Double_tRooAbsTestStatistic::_evalCarry! carry of Kahan sum in evaluatePartition; Int_tRooAbsTestStatistic::_extSet! Number of designated set to calculated extended term; Bool_tRooAbsArg::_fastAllow fast access mode in getVal() and proxies; Float_tRooAbsReal::_floatValue! Transient cache for floating point values from tree branches; Bool_tRooAbsReal::_forceNumIntForce numerical integration if flag set; RooAbsReal*RooAbsTestStatistic::_funcPointer to original input function; RooAbsReal*_funcClonePointer to internal clone of input function; RooArgSet*_funcCloneSetSet owning all components of internal clone of input function; RooArgSet*_funcObsSetList of observables in the pdf expression; static Bool_tRooAbsReal::_globalSelectCompGlobal activation switch for component selection; pRooAbsTestStatistic*RooAbsTestStatistic::_gofArray! Array of sub-contexts representing part of the combined test statistic; RooAbsTestStatistic::GOFOpModeRooAbsTestStatistic::_gofOpModeOperation mode of test statistic instance; vector<RooFit::MPSplit>RooAbsTestStatistic::_gofSplitMode! GOF MP Split mode specified by component (when Auto is active); static Bool_tRooAbsReal::_hideOffsetOffset hiding flag; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; Bool_tRooAbsTestStatistic::_init! Is object initialized; Int_tRooAbsReal::_intValue! Tra,MatchSource.WIKI,root/html602/RooAbsOptTestStatistic.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsOptTestStatistic.html
https://root.cern/root/html602/RooAbsOptTestStatistic.html:42608,Deployability,integrat,integrator,42608,"ree branches; TString_sealNoticeUser-defined notice shown when reading a sealed likelihood; Bool_t_sealedIs test statistic sealed -- i.e. no access to data; Bool_tRooAbsReal::_selectComp! Component selection flag for RooAbsPdf::plotCompOn; RooRefCountListRooAbsArg::_serverListlist of server objects; Int_tRooAbsTestStatistic::_setNumPartition number of this instance in parallel calculation mode; Bool_tRooAbsArg::_shapeDirtyFlag set if value needs recalculating because input shapes modified; Int_tRooAbsTestStatistic::_simCountTotal number of component p.d.f.s in RooSimultaneous (if any); RooNumIntConfig*RooAbsReal::_specIntegratorConfigNumeric integrator configuration specific for this object; Bool_tRooAbsTestStatistic::_splitRangeSplit rangeName in RooSimultaneous index labels if true; map<string,string>RooAbsArg::_stringAttribString attributes; Bool_tRooAbsReal::_treeVar!do not persist; UInt_tRooAbsReal::_uintValue! Transient cache for unsigned integer values from tree branches; TStringRooAbsReal::_unitUnit for objects value; Double_tRooAbsReal::_valueCache for current value of object; Bool_tRooAbsArg::_valueDirtyFlag set if value needs recalculating because input values modified; Bool_tRooAbsTestStatistic::_verboseVerbose messaging if true; static Bool_tRooAbsArg::_verboseDirtyStatic flag controlling verbose messaging for dirty state changes; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; RooAbsOptTestStatistic(const char* name, const char* title, RooAbsReal& real, RooAbsData& data, const RooArgSet& projDeps, const char* rangeName = 0, const char* addCoefRangeName = 0, Int_t nCPU = 1, RooFit::MPSplit interleave = RooFit::BulkPartition, Bool_t verbose = kTRUE, Bool_t splitCutRange = kFALSE, Bool_t cloneInputData = kTRUE); Constructor taking function (real), a dataset (data), a set of projected observables (projSet). If; rangeName is not null, only eve",MatchSource.WIKI,root/html602/RooAbsOptTestStatistic.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsOptTestStatistic.html
https://root.cern/root/html602/RooAbsOptTestStatistic.html:42619,Deployability,configurat,configuration,42619,"ree branches; TString_sealNoticeUser-defined notice shown when reading a sealed likelihood; Bool_t_sealedIs test statistic sealed -- i.e. no access to data; Bool_tRooAbsReal::_selectComp! Component selection flag for RooAbsPdf::plotCompOn; RooRefCountListRooAbsArg::_serverListlist of server objects; Int_tRooAbsTestStatistic::_setNumPartition number of this instance in parallel calculation mode; Bool_tRooAbsArg::_shapeDirtyFlag set if value needs recalculating because input shapes modified; Int_tRooAbsTestStatistic::_simCountTotal number of component p.d.f.s in RooSimultaneous (if any); RooNumIntConfig*RooAbsReal::_specIntegratorConfigNumeric integrator configuration specific for this object; Bool_tRooAbsTestStatistic::_splitRangeSplit rangeName in RooSimultaneous index labels if true; map<string,string>RooAbsArg::_stringAttribString attributes; Bool_tRooAbsReal::_treeVar!do not persist; UInt_tRooAbsReal::_uintValue! Transient cache for unsigned integer values from tree branches; TStringRooAbsReal::_unitUnit for objects value; Double_tRooAbsReal::_valueCache for current value of object; Bool_tRooAbsArg::_valueDirtyFlag set if value needs recalculating because input values modified; Bool_tRooAbsTestStatistic::_verboseVerbose messaging if true; static Bool_tRooAbsArg::_verboseDirtyStatic flag controlling verbose messaging for dirty state changes; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; RooAbsOptTestStatistic(const char* name, const char* title, RooAbsReal& real, RooAbsData& data, const RooArgSet& projDeps, const char* rangeName = 0, const char* addCoefRangeName = 0, Int_t nCPU = 1, RooFit::MPSplit interleave = RooFit::BulkPartition, Bool_t verbose = kTRUE, Bool_t splitCutRange = kFALSE, Bool_t cloneInputData = kTRUE); Constructor taking function (real), a dataset (data), a set of projected observables (projSet). If; rangeName is not null, only eve",MatchSource.WIKI,root/html602/RooAbsOptTestStatistic.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsOptTestStatistic.html
https://root.cern/root/html602/RooAbsOptTestStatistic.html:8432,Integrability,depend,dependentVars,8432,"const char* rangeName = 0) const; virtual RooAbsReal*RooAbsReal::createIntegral(const RooArgSet& iset, const RooArgSet* nset = 0, const RooNumIntConfig* cfg = 0, const char* rangeName = 0) const; RooAbsReal*RooAbsReal::createIntegral(const RooArgSet& iset, const RooCmdArg& arg1, const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()) const; RooAbsReal*RooAbsReal::createIntRI(const RooArgSet& iset, const RooArgSet& nset = RooArgSet()); const RooAbsReal*RooAbsReal::createPlotProjection(const RooArgSet& depVars, const RooArgSet& projVars) const; const RooAbsReal*RooAbsReal::createPlotProjection(const RooArgSet& depVars, const RooArgSet& projVars, RooArgSet*& cloneSet) const; const RooAbsReal*RooAbsReal::createPlotProjection(const RooArgSet& dependentVars, const RooArgSet* projectedVars, RooArgSet*& cloneSet, const char* rangeName = 0, const RooArgSet* condObs = 0) const; virtual RooAbsReal*RooAbsReal::createProfile(const RooArgSet& paramsOfInterest); RooAbsReal*RooAbsReal::createRunningIntegral(const RooArgSet& iset, const RooArgSet& nset = RooArgSet()); RooAbsReal*RooAbsReal::createRunningIntegral(const RooArgSet& iset, const RooCmdArg& arg1, const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()); RooAbsReal*RooAbsReal::createScanRI(const RooArgSet& iset, const RooArgSet& nset, Int_t numScanBins, Int_t intOrder); RooAbsData&data(); const RooAbsData&data() const; virtual Double_tRooAbsReal::defaultErrorLevel() const; static RooNumIntConfig*RooAbsReal::defaultIntegratorConfig(); virtual I",MatchSource.WIKI,root/html602/RooAbsOptTestStatistic.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsOptTestStatistic.html
https://root.cern/root/html602/RooAbsOptTestStatistic.html:9724,Integrability,depend,dependentOverlaps,9724,"& dependentVars, const RooArgSet* projectedVars, RooArgSet*& cloneSet, const char* rangeName = 0, const RooArgSet* condObs = 0) const; virtual RooAbsReal*RooAbsReal::createProfile(const RooArgSet& paramsOfInterest); RooAbsReal*RooAbsReal::createRunningIntegral(const RooArgSet& iset, const RooArgSet& nset = RooArgSet()); RooAbsReal*RooAbsReal::createRunningIntegral(const RooArgSet& iset, const RooCmdArg& arg1, const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()); RooAbsReal*RooAbsReal::createScanRI(const RooArgSet& iset, const RooArgSet& nset, Int_t numScanBins, Int_t intOrder); RooAbsData&data(); const RooAbsData&data() const; virtual Double_tRooAbsReal::defaultErrorLevel() const; static RooNumIntConfig*RooAbsReal::defaultIntegratorConfig(); virtual Int_tRooAbsArg::defaultPrintContents(Option_t* opt) const; static ostream&RooPrintable::defaultPrintStream(ostream* os = 0); virtual RooPrintable::StyleOptionRooPrintable::defaultPrintStyle(Option_t* opt) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; Bool_tRooAbsArg::dependentOverlaps(const RooAbsData* dset, const RooAbsArg& testArg) const; Bool_tRooAbsArg::dependentOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; Bool_tRooAbsArg::dependsOn(const RooAbsCollection& serverList, const RooAbsArg* ignoreArg = 0, Bool_t valueOnly = kFALSE) const; Bool_tRooAbsArg::dependsOn(const RooAbsArg& server, const RooAbsArg* ignoreArg = 0, Bool_t valueOnly = kFALSE) const; Bool_tRooAbsArg::dependsOnValue(const RooAbsCollection& serverList, const RooAbsArg* ignoreArg = 0) const; Bool_tRooAbsArg::dependsOnValue(const RooAbsArg& server, const RooAbsArg* ignoreArg = 0) const; RooDerivative*RooAbsReal::derivative(RooRealVar& obs, Int_t order = 1, Double_t eps = 0.",MatchSource.WIKI,root/html602/RooAbsOptTestStatistic.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsOptTestStatistic.html
https://root.cern/root/html602/RooAbsOptTestStatistic.html:9816,Integrability,depend,dependentOverlaps,9816,"& dependentVars, const RooArgSet* projectedVars, RooArgSet*& cloneSet, const char* rangeName = 0, const RooArgSet* condObs = 0) const; virtual RooAbsReal*RooAbsReal::createProfile(const RooArgSet& paramsOfInterest); RooAbsReal*RooAbsReal::createRunningIntegral(const RooArgSet& iset, const RooArgSet& nset = RooArgSet()); RooAbsReal*RooAbsReal::createRunningIntegral(const RooArgSet& iset, const RooCmdArg& arg1, const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()); RooAbsReal*RooAbsReal::createScanRI(const RooArgSet& iset, const RooArgSet& nset, Int_t numScanBins, Int_t intOrder); RooAbsData&data(); const RooAbsData&data() const; virtual Double_tRooAbsReal::defaultErrorLevel() const; static RooNumIntConfig*RooAbsReal::defaultIntegratorConfig(); virtual Int_tRooAbsArg::defaultPrintContents(Option_t* opt) const; static ostream&RooPrintable::defaultPrintStream(ostream* os = 0); virtual RooPrintable::StyleOptionRooPrintable::defaultPrintStyle(Option_t* opt) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; Bool_tRooAbsArg::dependentOverlaps(const RooAbsData* dset, const RooAbsArg& testArg) const; Bool_tRooAbsArg::dependentOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; Bool_tRooAbsArg::dependsOn(const RooAbsCollection& serverList, const RooAbsArg* ignoreArg = 0, Bool_t valueOnly = kFALSE) const; Bool_tRooAbsArg::dependsOn(const RooAbsArg& server, const RooAbsArg* ignoreArg = 0, Bool_t valueOnly = kFALSE) const; Bool_tRooAbsArg::dependsOnValue(const RooAbsCollection& serverList, const RooAbsArg* ignoreArg = 0) const; Bool_tRooAbsArg::dependsOnValue(const RooAbsArg& server, const RooAbsArg* ignoreArg = 0) const; RooDerivative*RooAbsReal::derivative(RooRealVar& obs, Int_t order = 1, Double_t eps = 0.",MatchSource.WIKI,root/html602/RooAbsOptTestStatistic.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsOptTestStatistic.html
https://root.cern/root/html602/RooAbsOptTestStatistic.html:9910,Integrability,depend,dependsOn,9910,"& dependentVars, const RooArgSet* projectedVars, RooArgSet*& cloneSet, const char* rangeName = 0, const RooArgSet* condObs = 0) const; virtual RooAbsReal*RooAbsReal::createProfile(const RooArgSet& paramsOfInterest); RooAbsReal*RooAbsReal::createRunningIntegral(const RooArgSet& iset, const RooArgSet& nset = RooArgSet()); RooAbsReal*RooAbsReal::createRunningIntegral(const RooArgSet& iset, const RooCmdArg& arg1, const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()); RooAbsReal*RooAbsReal::createScanRI(const RooArgSet& iset, const RooArgSet& nset, Int_t numScanBins, Int_t intOrder); RooAbsData&data(); const RooAbsData&data() const; virtual Double_tRooAbsReal::defaultErrorLevel() const; static RooNumIntConfig*RooAbsReal::defaultIntegratorConfig(); virtual Int_tRooAbsArg::defaultPrintContents(Option_t* opt) const; static ostream&RooPrintable::defaultPrintStream(ostream* os = 0); virtual RooPrintable::StyleOptionRooPrintable::defaultPrintStyle(Option_t* opt) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; Bool_tRooAbsArg::dependentOverlaps(const RooAbsData* dset, const RooAbsArg& testArg) const; Bool_tRooAbsArg::dependentOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; Bool_tRooAbsArg::dependsOn(const RooAbsCollection& serverList, const RooAbsArg* ignoreArg = 0, Bool_t valueOnly = kFALSE) const; Bool_tRooAbsArg::dependsOn(const RooAbsArg& server, const RooAbsArg* ignoreArg = 0, Bool_t valueOnly = kFALSE) const; Bool_tRooAbsArg::dependsOnValue(const RooAbsCollection& serverList, const RooAbsArg* ignoreArg = 0) const; Bool_tRooAbsArg::dependsOnValue(const RooAbsArg& server, const RooAbsArg* ignoreArg = 0) const; RooDerivative*RooAbsReal::derivative(RooRealVar& obs, Int_t order = 1, Double_t eps = 0.",MatchSource.WIKI,root/html602/RooAbsOptTestStatistic.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsOptTestStatistic.html
https://root.cern/root/html602/RooAbsOptTestStatistic.html:10039,Integrability,depend,dependsOn,10039,"& dependentVars, const RooArgSet* projectedVars, RooArgSet*& cloneSet, const char* rangeName = 0, const RooArgSet* condObs = 0) const; virtual RooAbsReal*RooAbsReal::createProfile(const RooArgSet& paramsOfInterest); RooAbsReal*RooAbsReal::createRunningIntegral(const RooArgSet& iset, const RooArgSet& nset = RooArgSet()); RooAbsReal*RooAbsReal::createRunningIntegral(const RooArgSet& iset, const RooCmdArg& arg1, const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()); RooAbsReal*RooAbsReal::createScanRI(const RooArgSet& iset, const RooArgSet& nset, Int_t numScanBins, Int_t intOrder); RooAbsData&data(); const RooAbsData&data() const; virtual Double_tRooAbsReal::defaultErrorLevel() const; static RooNumIntConfig*RooAbsReal::defaultIntegratorConfig(); virtual Int_tRooAbsArg::defaultPrintContents(Option_t* opt) const; static ostream&RooPrintable::defaultPrintStream(ostream* os = 0); virtual RooPrintable::StyleOptionRooPrintable::defaultPrintStyle(Option_t* opt) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; Bool_tRooAbsArg::dependentOverlaps(const RooAbsData* dset, const RooAbsArg& testArg) const; Bool_tRooAbsArg::dependentOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; Bool_tRooAbsArg::dependsOn(const RooAbsCollection& serverList, const RooAbsArg* ignoreArg = 0, Bool_t valueOnly = kFALSE) const; Bool_tRooAbsArg::dependsOn(const RooAbsArg& server, const RooAbsArg* ignoreArg = 0, Bool_t valueOnly = kFALSE) const; Bool_tRooAbsArg::dependsOnValue(const RooAbsCollection& serverList, const RooAbsArg* ignoreArg = 0) const; Bool_tRooAbsArg::dependsOnValue(const RooAbsArg& server, const RooAbsArg* ignoreArg = 0) const; RooDerivative*RooAbsReal::derivative(RooRealVar& obs, Int_t order = 1, Double_t eps = 0.",MatchSource.WIKI,root/html602/RooAbsOptTestStatistic.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsOptTestStatistic.html
https://root.cern/root/html602/RooAbsOptTestStatistic.html:10157,Integrability,depend,dependsOnValue,10157,"& dependentVars, const RooArgSet* projectedVars, RooArgSet*& cloneSet, const char* rangeName = 0, const RooArgSet* condObs = 0) const; virtual RooAbsReal*RooAbsReal::createProfile(const RooArgSet& paramsOfInterest); RooAbsReal*RooAbsReal::createRunningIntegral(const RooArgSet& iset, const RooArgSet& nset = RooArgSet()); RooAbsReal*RooAbsReal::createRunningIntegral(const RooArgSet& iset, const RooCmdArg& arg1, const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()); RooAbsReal*RooAbsReal::createScanRI(const RooArgSet& iset, const RooArgSet& nset, Int_t numScanBins, Int_t intOrder); RooAbsData&data(); const RooAbsData&data() const; virtual Double_tRooAbsReal::defaultErrorLevel() const; static RooNumIntConfig*RooAbsReal::defaultIntegratorConfig(); virtual Int_tRooAbsArg::defaultPrintContents(Option_t* opt) const; static ostream&RooPrintable::defaultPrintStream(ostream* os = 0); virtual RooPrintable::StyleOptionRooPrintable::defaultPrintStyle(Option_t* opt) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; Bool_tRooAbsArg::dependentOverlaps(const RooAbsData* dset, const RooAbsArg& testArg) const; Bool_tRooAbsArg::dependentOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; Bool_tRooAbsArg::dependsOn(const RooAbsCollection& serverList, const RooAbsArg* ignoreArg = 0, Bool_t valueOnly = kFALSE) const; Bool_tRooAbsArg::dependsOn(const RooAbsArg& server, const RooAbsArg* ignoreArg = 0, Bool_t valueOnly = kFALSE) const; Bool_tRooAbsArg::dependsOnValue(const RooAbsCollection& serverList, const RooAbsArg* ignoreArg = 0) const; Bool_tRooAbsArg::dependsOnValue(const RooAbsArg& server, const RooAbsArg* ignoreArg = 0) const; RooDerivative*RooAbsReal::derivative(RooRealVar& obs, Int_t order = 1, Double_t eps = 0.",MatchSource.WIKI,root/html602/RooAbsOptTestStatistic.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsOptTestStatistic.html
https://root.cern/root/html602/RooAbsOptTestStatistic.html:10264,Integrability,depend,dependsOnValue,10264,"& dependentVars, const RooArgSet* projectedVars, RooArgSet*& cloneSet, const char* rangeName = 0, const RooArgSet* condObs = 0) const; virtual RooAbsReal*RooAbsReal::createProfile(const RooArgSet& paramsOfInterest); RooAbsReal*RooAbsReal::createRunningIntegral(const RooArgSet& iset, const RooArgSet& nset = RooArgSet()); RooAbsReal*RooAbsReal::createRunningIntegral(const RooArgSet& iset, const RooCmdArg& arg1, const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()); RooAbsReal*RooAbsReal::createScanRI(const RooArgSet& iset, const RooArgSet& nset, Int_t numScanBins, Int_t intOrder); RooAbsData&data(); const RooAbsData&data() const; virtual Double_tRooAbsReal::defaultErrorLevel() const; static RooNumIntConfig*RooAbsReal::defaultIntegratorConfig(); virtual Int_tRooAbsArg::defaultPrintContents(Option_t* opt) const; static ostream&RooPrintable::defaultPrintStream(ostream* os = 0); virtual RooPrintable::StyleOptionRooPrintable::defaultPrintStyle(Option_t* opt) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; Bool_tRooAbsArg::dependentOverlaps(const RooAbsData* dset, const RooAbsArg& testArg) const; Bool_tRooAbsArg::dependentOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; Bool_tRooAbsArg::dependsOn(const RooAbsCollection& serverList, const RooAbsArg* ignoreArg = 0, Bool_t valueOnly = kFALSE) const; Bool_tRooAbsArg::dependsOn(const RooAbsArg& server, const RooAbsArg* ignoreArg = 0, Bool_t valueOnly = kFALSE) const; Bool_tRooAbsArg::dependsOnValue(const RooAbsCollection& serverList, const RooAbsArg* ignoreArg = 0) const; Bool_tRooAbsArg::dependsOnValue(const RooAbsArg& server, const RooAbsArg* ignoreArg = 0) const; RooDerivative*RooAbsReal::derivative(RooRealVar& obs, Int_t order = 1, Double_t eps = 0.",MatchSource.WIKI,root/html602/RooAbsOptTestStatistic.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsOptTestStatistic.html
https://root.cern/root/html602/RooAbsOptTestStatistic.html:18607,Integrability,message,message,18607,"l Bool_tRooAbsArg::isFundamental() const; virtual Bool_tRooAbsReal::isIdentical(const RooAbsArg& other, Bool_t assumeSameType = kFALSE); virtual Bool_tRooAbsArg::isLValue() const; virtual Bool_tRooAbsTestStatistic::isOffsetting() const; Bool_tTObject::IsOnHeap() const; Bool_tisSealed() const; Bool_tRooAbsArg::isShapeDirty() const; Bool_tRooAbsArg::isShapeServer(const RooAbsArg& arg) const; Bool_tRooAbsArg::isShapeServer(const char* name) const; virtual Bool_tRooAbsArg::IsSortable() const; Bool_tRooAbsArg::isValueDirty() const; Bool_tRooAbsArg::isValueDirtyAndClear() const; Bool_tRooAbsArg::isValueOrShapeDirtyAndClear() const; Bool_tRooAbsArg::isValueServer(const RooAbsArg& arg) const; Bool_tRooAbsArg::isValueServer(const char* name) const; Bool_tTObject::IsZombie() const; voidRooAbsArg::leafNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t recurseNonDerived = kFALSE) const; Bool_tRooAbsArg::localNoDirtyInhibit() const; voidRooAbsReal::logEvalError(const char* message, const char* serverValueString = 0) const; static voidRooAbsReal::logEvalError(const RooAbsReal* originator, const char* origName, const char* message, const char* serverValueString = 0); virtual voidTNamed::ls(Option_t* option = """") const; virtual Double_tRooAbsReal::maxVal(Int_t code) const; voidTObject::MayNotUse(const char* method) const; RooAbsMoment*RooAbsReal::mean(RooRealVar& obs); RooAbsMoment*RooAbsReal::mean(RooRealVar& obs, const RooArgSet& nset); virtual Int_tRooAbsReal::minTrialSamples(const RooArgSet&) const; RooAbsMoment*RooAbsReal::moment(RooRealVar& obs, Int_t order, Bool_t central, Bool_t takeRoot); RooAbsMoment*RooAbsReal::moment(RooRealVar& obs, const RooArgSet& normObs, Int_t order, Bool_t central, Bool_t takeRoot, Bool_t intNormObs); static voidRooPrintable::nameFieldLength(Int_t newLen); const TNamed*RooAbsArg::namePtr() const; virtual Bool_tTObject::Notify(); Int_tRooAbsArg::numCaches() const; static Int_tRooAbsReal::numEvalErrorItems(); static Int_tRooAbsR",MatchSource.WIKI,root/html602/RooAbsOptTestStatistic.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsOptTestStatistic.html
https://root.cern/root/html602/RooAbsOptTestStatistic.html:18758,Integrability,message,message,18758,"RooAbsArg::isLValue() const; virtual Bool_tRooAbsTestStatistic::isOffsetting() const; Bool_tTObject::IsOnHeap() const; Bool_tisSealed() const; Bool_tRooAbsArg::isShapeDirty() const; Bool_tRooAbsArg::isShapeServer(const RooAbsArg& arg) const; Bool_tRooAbsArg::isShapeServer(const char* name) const; virtual Bool_tRooAbsArg::IsSortable() const; Bool_tRooAbsArg::isValueDirty() const; Bool_tRooAbsArg::isValueDirtyAndClear() const; Bool_tRooAbsArg::isValueOrShapeDirtyAndClear() const; Bool_tRooAbsArg::isValueServer(const RooAbsArg& arg) const; Bool_tRooAbsArg::isValueServer(const char* name) const; Bool_tTObject::IsZombie() const; voidRooAbsArg::leafNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t recurseNonDerived = kFALSE) const; Bool_tRooAbsArg::localNoDirtyInhibit() const; voidRooAbsReal::logEvalError(const char* message, const char* serverValueString = 0) const; static voidRooAbsReal::logEvalError(const RooAbsReal* originator, const char* origName, const char* message, const char* serverValueString = 0); virtual voidTNamed::ls(Option_t* option = """") const; virtual Double_tRooAbsReal::maxVal(Int_t code) const; voidTObject::MayNotUse(const char* method) const; RooAbsMoment*RooAbsReal::mean(RooRealVar& obs); RooAbsMoment*RooAbsReal::mean(RooRealVar& obs, const RooArgSet& nset); virtual Int_tRooAbsReal::minTrialSamples(const RooArgSet&) const; RooAbsMoment*RooAbsReal::moment(RooRealVar& obs, Int_t order, Bool_t central, Bool_t takeRoot); RooAbsMoment*RooAbsReal::moment(RooRealVar& obs, const RooArgSet& normObs, Int_t order, Bool_t central, Bool_t takeRoot, Bool_t intNormObs); static voidRooPrintable::nameFieldLength(Int_t newLen); const TNamed*RooAbsArg::namePtr() const; virtual Bool_tTObject::Notify(); Int_tRooAbsArg::numCaches() const; static Int_tRooAbsReal::numEvalErrorItems(); static Int_tRooAbsReal::numEvalErrors(); Bool_tRooAbsArg::observableOverlaps(const RooAbsData* dset, const RooAbsArg& testArg) const; Bool_tRooAbsArg::observableOverlaps(",MatchSource.WIKI,root/html602/RooAbsOptTestStatistic.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsOptTestStatistic.html
https://root.cern/root/html602/RooAbsOptTestStatistic.html:38821,Integrability,integrat,integration,38821,esubset of clients that requested value dirty flag propagation; TIterator*RooAbsArg::_clientShapeIter! Iterator over _clientListShape; TIterator*RooAbsArg::_clientValueIter! Iterator over _clientListValue; RooAbsData*RooAbsTestStatistic::_dataPointer to original input dataset; RooAbsData*_dataClonePointer to internal clone if input data; Bool_tRooAbsArg::_deleteWatch! Delete watch flag; Bool_tRooAbsTestStatistic::_doOffsetApply interval value offset to control numeric precision?; RooExpensiveObjectCache*RooAbsArg::_eocachePointer to global cache manager for any expensive components created by this object; Double_tRooAbsTestStatistic::_evalCarry! carry of Kahan sum in evaluatePartition; Int_tRooAbsTestStatistic::_extSet! Number of designated set to calculated extended term; Bool_tRooAbsArg::_fastAllow fast access mode in getVal() and proxies; Float_tRooAbsReal::_floatValue! Transient cache for floating point values from tree branches; Bool_tRooAbsReal::_forceNumIntForce numerical integration if flag set; RooAbsReal*RooAbsTestStatistic::_funcPointer to original input function; RooAbsReal*_funcClonePointer to internal clone of input function; RooArgSet*_funcCloneSetSet owning all components of internal clone of input function; RooArgSet*_funcObsSetList of observables in the pdf expression; static Bool_tRooAbsReal::_globalSelectCompGlobal activation switch for component selection; pRooAbsTestStatistic*RooAbsTestStatistic::_gofArray! Array of sub-contexts representing part of the combined test statistic; RooAbsTestStatistic::GOFOpModeRooAbsTestStatistic::_gofOpModeOperation mode of test statistic instance; vector<RooFit::MPSplit>RooAbsTestStatistic::_gofSplitMode! GOF MP Split mode specified by component (when Auto is active); static Bool_tRooAbsReal::_hideOffsetOffset hiding flag; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; Bool_tRooAbsTestStatistic::_init! Is object initialized; Int_tRooAbsReal::_intValue! Tra,MatchSource.WIKI,root/html602/RooAbsOptTestStatistic.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsOptTestStatistic.html
https://root.cern/root/html602/RooAbsOptTestStatistic.html:42608,Integrability,integrat,integrator,42608,"ree branches; TString_sealNoticeUser-defined notice shown when reading a sealed likelihood; Bool_t_sealedIs test statistic sealed -- i.e. no access to data; Bool_tRooAbsReal::_selectComp! Component selection flag for RooAbsPdf::plotCompOn; RooRefCountListRooAbsArg::_serverListlist of server objects; Int_tRooAbsTestStatistic::_setNumPartition number of this instance in parallel calculation mode; Bool_tRooAbsArg::_shapeDirtyFlag set if value needs recalculating because input shapes modified; Int_tRooAbsTestStatistic::_simCountTotal number of component p.d.f.s in RooSimultaneous (if any); RooNumIntConfig*RooAbsReal::_specIntegratorConfigNumeric integrator configuration specific for this object; Bool_tRooAbsTestStatistic::_splitRangeSplit rangeName in RooSimultaneous index labels if true; map<string,string>RooAbsArg::_stringAttribString attributes; Bool_tRooAbsReal::_treeVar!do not persist; UInt_tRooAbsReal::_uintValue! Transient cache for unsigned integer values from tree branches; TStringRooAbsReal::_unitUnit for objects value; Double_tRooAbsReal::_valueCache for current value of object; Bool_tRooAbsArg::_valueDirtyFlag set if value needs recalculating because input values modified; Bool_tRooAbsTestStatistic::_verboseVerbose messaging if true; static Bool_tRooAbsArg::_verboseDirtyStatic flag controlling verbose messaging for dirty state changes; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; RooAbsOptTestStatistic(const char* name, const char* title, RooAbsReal& real, RooAbsData& data, const RooArgSet& projDeps, const char* rangeName = 0, const char* addCoefRangeName = 0, Int_t nCPU = 1, RooFit::MPSplit interleave = RooFit::BulkPartition, Bool_t verbose = kTRUE, Bool_t splitCutRange = kFALSE, Bool_t cloneInputData = kTRUE); Constructor taking function (real), a dataset (data), a set of projected observables (projSet). If; rangeName is not null, only eve",MatchSource.WIKI,root/html602/RooAbsOptTestStatistic.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsOptTestStatistic.html
https://root.cern/root/html602/RooAbsOptTestStatistic.html:46310,Integrability,depend,depends,46310,"onst; Method to combined test statistic results calculated into partitions into; the global result. This default implementation adds the partition return; values. Bool_t redirectServersHook(const RooAbsCollection& newServerList, Bool_t mustReplaceAll, Bool_t nameChange, Bool_t isRecursive); Catch server redirect calls and forward to internal clone of function. void printCompactTreeHook(ostream& os, const char* indent = """"); Catch print hook function and forward to function clone. void constOptimizeTestStatistic(RooAbsArg::ConstOpCode opcode, Bool_t doAlsoTrackingOpt = kTRUE); Driver function to propagate constant term optimizations in test statistic.; If code Activate is sent, constant term optimization will be executed.; If code Deacivate is sent, any existing constant term optimizations will; be abanoned. If codes ConfigChange or ValueChange are sent, any existing; constant term optimizations will be redone. void optimizeCaching(); This method changes the value caching logic for all nodes that depends on any of the observables; as defined by the given dataset. When evaluating a test statistic constructed from the RooAbsReal; with a dataset the observables are guaranteed to change with every call, thus there is no point; in tracking these changes which result in a net overhead. Thus for observable-dependent nodes,; the evaluation mechanism is changed from being dependent on a 'valueDirty' flag to guaranteed evaluation.; On the dataset side, the observables objects are modified to no longer send valueDirty messages; to their client. void optimizeConstantTerms(Bool_t , Bool_t = kTRUE); Driver function to activate global constant term optimization.; If activated constant terms are found and cached with the dataset; The operation mode of cached nodes is set to AClean meaning that; their getVal() call will never result in an evaluate call.; Finally the branches in the dataset that correspond to observables; that are exclusively used in constant terms are disabled as; the",MatchSource.WIKI,root/html602/RooAbsOptTestStatistic.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsOptTestStatistic.html
https://root.cern/root/html602/RooAbsOptTestStatistic.html:46619,Integrability,depend,dependent,46619,"ntCompactTreeHook(ostream& os, const char* indent = """"); Catch print hook function and forward to function clone. void constOptimizeTestStatistic(RooAbsArg::ConstOpCode opcode, Bool_t doAlsoTrackingOpt = kTRUE); Driver function to propagate constant term optimizations in test statistic.; If code Activate is sent, constant term optimization will be executed.; If code Deacivate is sent, any existing constant term optimizations will; be abanoned. If codes ConfigChange or ValueChange are sent, any existing; constant term optimizations will be redone. void optimizeCaching(); This method changes the value caching logic for all nodes that depends on any of the observables; as defined by the given dataset. When evaluating a test statistic constructed from the RooAbsReal; with a dataset the observables are guaranteed to change with every call, thus there is no point; in tracking these changes which result in a net overhead. Thus for observable-dependent nodes,; the evaluation mechanism is changed from being dependent on a 'valueDirty' flag to guaranteed evaluation.; On the dataset side, the observables objects are modified to no longer send valueDirty messages; to their client. void optimizeConstantTerms(Bool_t , Bool_t = kTRUE); Driver function to activate global constant term optimization.; If activated constant terms are found and cached with the dataset; The operation mode of cached nodes is set to AClean meaning that; their getVal() call will never result in an evaluate call.; Finally the branches in the dataset that correspond to observables; that are exclusively used in constant terms are disabled as; they serve no more purpose. Bool_t setDataSlave(RooAbsData& data, Bool_t cloneData = kTRUE, Bool_t ownNewDataAnyway = kFALSE); cout << ""RAOTS::setDataSlave("" << this << "") START"" << endl ;; Change dataset that is used to given one. If cloneData is kTRUE, a clone of; in the input dataset is made. If the test statistic was constructed with; a range specification on the dat",MatchSource.WIKI,root/html602/RooAbsOptTestStatistic.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsOptTestStatistic.html
https://root.cern/root/html602/RooAbsOptTestStatistic.html:46684,Integrability,depend,dependent,46684,"ntCompactTreeHook(ostream& os, const char* indent = """"); Catch print hook function and forward to function clone. void constOptimizeTestStatistic(RooAbsArg::ConstOpCode opcode, Bool_t doAlsoTrackingOpt = kTRUE); Driver function to propagate constant term optimizations in test statistic.; If code Activate is sent, constant term optimization will be executed.; If code Deacivate is sent, any existing constant term optimizations will; be abanoned. If codes ConfigChange or ValueChange are sent, any existing; constant term optimizations will be redone. void optimizeCaching(); This method changes the value caching logic for all nodes that depends on any of the observables; as defined by the given dataset. When evaluating a test statistic constructed from the RooAbsReal; with a dataset the observables are guaranteed to change with every call, thus there is no point; in tracking these changes which result in a net overhead. Thus for observable-dependent nodes,; the evaluation mechanism is changed from being dependent on a 'valueDirty' flag to guaranteed evaluation.; On the dataset side, the observables objects are modified to no longer send valueDirty messages; to their client. void optimizeConstantTerms(Bool_t , Bool_t = kTRUE); Driver function to activate global constant term optimization.; If activated constant terms are found and cached with the dataset; The operation mode of cached nodes is set to AClean meaning that; their getVal() call will never result in an evaluate call.; Finally the branches in the dataset that correspond to observables; that are exclusively used in constant terms are disabled as; they serve no more purpose. Bool_t setDataSlave(RooAbsData& data, Bool_t cloneData = kTRUE, Bool_t ownNewDataAnyway = kFALSE); cout << ""RAOTS::setDataSlave("" << this << "") START"" << endl ;; Change dataset that is used to given one. If cloneData is kTRUE, a clone of; in the input dataset is made. If the test statistic was constructed with; a range specification on the dat",MatchSource.WIKI,root/html602/RooAbsOptTestStatistic.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsOptTestStatistic.html
https://root.cern/root/html602/RooAbsOptTestStatistic.html:46831,Integrability,message,messages,46831,"izeTestStatistic(RooAbsArg::ConstOpCode opcode, Bool_t doAlsoTrackingOpt = kTRUE); Driver function to propagate constant term optimizations in test statistic.; If code Activate is sent, constant term optimization will be executed.; If code Deacivate is sent, any existing constant term optimizations will; be abanoned. If codes ConfigChange or ValueChange are sent, any existing; constant term optimizations will be redone. void optimizeCaching(); This method changes the value caching logic for all nodes that depends on any of the observables; as defined by the given dataset. When evaluating a test statistic constructed from the RooAbsReal; with a dataset the observables are guaranteed to change with every call, thus there is no point; in tracking these changes which result in a net overhead. Thus for observable-dependent nodes,; the evaluation mechanism is changed from being dependent on a 'valueDirty' flag to guaranteed evaluation.; On the dataset side, the observables objects are modified to no longer send valueDirty messages; to their client. void optimizeConstantTerms(Bool_t , Bool_t = kTRUE); Driver function to activate global constant term optimization.; If activated constant terms are found and cached with the dataset; The operation mode of cached nodes is set to AClean meaning that; their getVal() call will never result in an evaluate call.; Finally the branches in the dataset that correspond to observables; that are exclusively used in constant terms are disabled as; they serve no more purpose. Bool_t setDataSlave(RooAbsData& data, Bool_t cloneData = kTRUE, Bool_t ownNewDataAnyway = kFALSE); cout << ""RAOTS::setDataSlave("" << this << "") START"" << endl ;; Change dataset that is used to given one. If cloneData is kTRUE, a clone of; in the input dataset is made. If the test statistic was constructed with; a range specification on the data, the cloneData argument is ignore and; the data is always cloned. RooAbsData& data(). const RooAbsData& data() const. RooAbsOptT",MatchSource.WIKI,root/html602/RooAbsOptTestStatistic.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsOptTestStatistic.html
https://root.cern/root/html602/RooAbsOptTestStatistic.html:25853,Modifiability,config,config,25853,"Notice() const; TIterator*RooAbsArg::serverIterator() const; RooFIterRooAbsArg::serverMIterator() const; virtual voidRooAbsArg::serverNameChangeHook(const RooAbsArg*, const RooAbsArg*); voidRooAbsArg::setAttribute(const Text_t* name, Bool_t value = kTRUE); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); virtual voidRooAbsArg::setCacheAndTrackHints(RooArgSet&); static voidRooAbsReal::setCacheCheck(Bool_t flag); virtual Bool_tRooAbsTestStatistic::setData(RooAbsData& data, Bool_t cloneData = kTRUE); static voidRooAbsArg::setDirtyInhibit(Bool_t flag); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); static voidRooAbsReal::setEvalErrorLoggingMode(RooAbsReal::ErrorLoggingMode m); virtual voidRooAbsArg::setExpensiveObjectCache(RooExpensiveObjectCache& cache); static voidRooAbsReal::setHideOffset(Bool_t flag); voidRooAbsReal::setIntegratorConfig(); voidRooAbsReal::setIntegratorConfig(const RooNumIntConfig& config); voidRooAbsArg::setLocalNoDirtyInhibit(Bool_t flag) const; virtual voidRooAbsArg::SetName(const char* name); virtual voidRooAbsArg::SetNameTitle(const char* name, const char* title); static voidTObject::SetObjectStat(Bool_t stat); voidRooAbsArg::setOperMode(RooAbsArg::OperMode mode, Bool_t recurseADirty = kTRUE); voidRooAbsReal::setParameterizeIntegral(const RooArgSet& paramVars); voidRooAbsReal::setPlotLabel(const char* label); voidRooAbsArg::setProhibitServerRedirect(Bool_t flag); voidRooAbsArg::setShapeDirty() const; voidRooAbsArg::setStringAttribute(const Text_t* key, const Text_t* value); virtual voidTNamed::SetTitle(const char* title = """")MENU ; voidRooAbsArg::setTransientAttribute(const Text_t* name, Bool_t value = kTRUE); virtual voidTObject::SetUniqueID(UInt_t uid); voidRooAbsReal::setUnit(const char* unit); voidRooAbsArg::setValueDirty() const; TIterator*RooAbsArg::shapeClientIterator() const; RooFIterRooAbsArg::shapeClientMIterator() const; virtual voidShowMembers(TMembe",MatchSource.WIKI,root/html602/RooAbsOptTestStatistic.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsOptTestStatistic.html
https://root.cern/root/html602/RooAbsOptTestStatistic.html:38596,Modifiability,extend,extended,38596,nstant expressions; RooRefCountListRooAbsArg::_clientListlist of client objects; RooRefCountListRooAbsArg::_clientListShapesubset of clients that requested shape dirty flag propagation; RooRefCountListRooAbsArg::_clientListValuesubset of clients that requested value dirty flag propagation; TIterator*RooAbsArg::_clientShapeIter! Iterator over _clientListShape; TIterator*RooAbsArg::_clientValueIter! Iterator over _clientListValue; RooAbsData*RooAbsTestStatistic::_dataPointer to original input dataset; RooAbsData*_dataClonePointer to internal clone if input data; Bool_tRooAbsArg::_deleteWatch! Delete watch flag; Bool_tRooAbsTestStatistic::_doOffsetApply interval value offset to control numeric precision?; RooExpensiveObjectCache*RooAbsArg::_eocachePointer to global cache manager for any expensive components created by this object; Double_tRooAbsTestStatistic::_evalCarry! carry of Kahan sum in evaluatePartition; Int_tRooAbsTestStatistic::_extSet! Number of designated set to calculated extended term; Bool_tRooAbsArg::_fastAllow fast access mode in getVal() and proxies; Float_tRooAbsReal::_floatValue! Transient cache for floating point values from tree branches; Bool_tRooAbsReal::_forceNumIntForce numerical integration if flag set; RooAbsReal*RooAbsTestStatistic::_funcPointer to original input function; RooAbsReal*_funcClonePointer to internal clone of input function; RooArgSet*_funcCloneSetSet owning all components of internal clone of input function; RooArgSet*_funcObsSetList of observables in the pdf expression; static Bool_tRooAbsReal::_globalSelectCompGlobal activation switch for component selection; pRooAbsTestStatistic*RooAbsTestStatistic::_gofArray! Array of sub-contexts representing part of the combined test statistic; RooAbsTestStatistic::GOFOpModeRooAbsTestStatistic::_gofOpModeOperation mode of test statistic instance; vector<RooFit::MPSplit>RooAbsTestStatistic::_gofSplitMode! GOF MP Split mode specified by component (when Auto is active); static Bool_tRooAbsRea,MatchSource.WIKI,root/html602/RooAbsOptTestStatistic.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsOptTestStatistic.html
https://root.cern/root/html602/RooAbsOptTestStatistic.html:42619,Modifiability,config,configuration,42619,"ree branches; TString_sealNoticeUser-defined notice shown when reading a sealed likelihood; Bool_t_sealedIs test statistic sealed -- i.e. no access to data; Bool_tRooAbsReal::_selectComp! Component selection flag for RooAbsPdf::plotCompOn; RooRefCountListRooAbsArg::_serverListlist of server objects; Int_tRooAbsTestStatistic::_setNumPartition number of this instance in parallel calculation mode; Bool_tRooAbsArg::_shapeDirtyFlag set if value needs recalculating because input shapes modified; Int_tRooAbsTestStatistic::_simCountTotal number of component p.d.f.s in RooSimultaneous (if any); RooNumIntConfig*RooAbsReal::_specIntegratorConfigNumeric integrator configuration specific for this object; Bool_tRooAbsTestStatistic::_splitRangeSplit rangeName in RooSimultaneous index labels if true; map<string,string>RooAbsArg::_stringAttribString attributes; Bool_tRooAbsReal::_treeVar!do not persist; UInt_tRooAbsReal::_uintValue! Transient cache for unsigned integer values from tree branches; TStringRooAbsReal::_unitUnit for objects value; Double_tRooAbsReal::_valueCache for current value of object; Bool_tRooAbsArg::_valueDirtyFlag set if value needs recalculating because input values modified; Bool_tRooAbsTestStatistic::_verboseVerbose messaging if true; static Bool_tRooAbsArg::_verboseDirtyStatic flag controlling verbose messaging for dirty state changes; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; RooAbsOptTestStatistic(const char* name, const char* title, RooAbsReal& real, RooAbsData& data, const RooArgSet& projDeps, const char* rangeName = 0, const char* addCoefRangeName = 0, Int_t nCPU = 1, RooFit::MPSplit interleave = RooFit::BulkPartition, Bool_t verbose = kTRUE, Bool_t splitCutRange = kFALSE, Bool_t cloneInputData = kTRUE); Constructor taking function (real), a dataset (data), a set of projected observables (projSet). If; rangeName is not null, only eve",MatchSource.WIKI,root/html602/RooAbsOptTestStatistic.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsOptTestStatistic.html
https://root.cern/root/html602/RooAbsOptTestStatistic.html:521,Performance,optimiz,optimizations,521,". RooAbsOptTestStatistic. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » ROOFIT; » ROOFITCORE; » RooAbsOptTestStatistic. class RooAbsOptTestStatistic: public RooAbsTestStatistic. RooAbsOptTestStatistic is the abstract base class for test; statistics objects that evaluate a function or PDF at each point of a given; dataset. This class provides generic optimizations, such as; caching and precalculation of constant terms that can be made for; all such quantities; Implementations should define evaluatePartition(), which calculates the; value of a (sub)range of the dataset and optionally combinedValue(),; which combines the values calculated for each partition. If combinedValue(); is not overloaded, the default implementation will add the partition results; to obtain the combined result; Support for calculation in partitions is needed to allow multi-core; parallelized calculation of test statistics; . Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~RooAbsOptTestStatistic(); voidTObject::AbstractMethod(const char* method) const; Bool_tRooAbsArg::addOwnedComponents(const RooArgSet& comps); voidRooAbsArg::addParameters(RooArgSet& params, const RooArgSet* nset = 0, Bool_t stripDisconnected = kTRUE) const; voidRooAbsArg::addServer(RooAbsArg& server, Bool_t valueProp = kTRUE, Bool_t shapeProp = kFALSE); voidRooAbsArg::addServerList(RooAbsCollection& serverList, Bool_t valueProp = kTRUE, Bool_t shapeProp = kFALSE); const char*RooAbsArg::aggregateCacheUniqueSuffix() const; virtual Double_tRooAbsReal::analyticalIntegral(Int_t code, const char* rangeName = 0) const; virtual Double_tRooAbsReal::analyticalIntegralWN(Int_t code, const RooArgSet* normSet, const char* rangeName = 0) const; virtua",MatchSource.WIKI,root/html602/RooAbsOptTestStatistic.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsOptTestStatistic.html
https://root.cern/root/html602/RooAbsOptTestStatistic.html:2741,Performance,cache,cacheUniqueSuffix,2741,"gateCacheUniqueSuffix() const; virtual Double_tRooAbsReal::analyticalIntegral(Int_t code, const char* rangeName = 0) const; virtual Double_tRooAbsReal::analyticalIntegralWN(Int_t code, const RooArgSet* normSet, const char* rangeName = 0) const; virtual voidTObject::AppendPad(Option_t* option = """"); TF1*RooAbsReal::asTF(const RooArgList& obs, const RooArgList& pars = RooArgList(), const RooArgSet& nset = RooArgSet()) const; voidRooAbsArg::attachDataSet(const RooAbsData& set); voidRooAbsArg::attachDataStore(const RooAbsDataStore& set); const set<string>&RooAbsArg::attributes() const; virtual list<Double_t>*RooAbsReal::binBoundaries(RooAbsRealLValue&, Double_t, Double_t) const; RooAbsFunc*RooAbsReal::bindVars(const RooArgSet& vars, const RooArgSet* nset = 0, Bool_t clipInvalid = kFALSE) const; voidRooAbsArg::branchNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t recurseNonDerived = kFALSE) const; virtual voidTObject::Browse(TBrowser* b); virtual const char*cacheUniqueSuffix() const; virtual RooAbsArg::CacheModeRooAbsArg::canNodeBeCached() const; voidRooAbsArg::changeServer(RooAbsArg& server, Bool_t valueProp, Bool_t shapeProp); Bool_tRooAbsArg::checkDependents(const RooArgSet* nset) const; virtual Bool_tRooAbsArg::checkObservables(const RooArgSet* nset) const; virtual RooFitResult*RooAbsReal::chi2FitTo(RooDataHist& data, const RooLinkedList& cmdList); virtual RooFitResult*RooAbsReal::chi2FitTo(RooDataSet& xydata, const RooLinkedList& cmdList); virtual RooFitResult*RooAbsReal::chi2FitTo(RooDataHist& data, const RooCmdArg& arg1 = RooCmdArg::none(), const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()); virtual RooFitResult*RooAbsReal::chi2FitTo(RooDataSet& xydata, const RooCmdArg& arg1 = RooCmdArg::none(),",MatchSource.WIKI,root/html602/RooAbsOptTestStatistic.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsOptTestStatistic.html
https://root.cern/root/html602/RooAbsOptTestStatistic.html:11985,Performance,cache,cacheList,11985,"rRooAbsReal::evalErrorIter(); static RooAbsReal::ErrorLoggingModeRooAbsReal::evalErrorLoggingMode(); virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); RooExpensiveObjectCache&RooAbsArg::expensiveObjectCache() const; virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); RooDataHist*RooAbsReal::fillDataHist(RooDataHist* hist, const RooArgSet* nset, Double_t scaleFactor, Bool_t correctForBinVolume = kFALSE, Bool_t showProgress = kFALSE) const; TH1*RooAbsReal::fillHistogram(TH1* hist, const RooArgList& plotVars, Double_t scaleFactor = 1, const RooArgSet* projectedVars = 0, Bool_t scaling = kTRUE, const RooArgSet* condObs = 0, Bool_t setError = kTRUE) const; Bool_tRooAbsArg::findConstantNodes(const RooArgSet& observables, RooArgSet& cacheList); Bool_tRooAbsArg::findConstantNodes(const RooArgSet& observables, RooArgSet& cacheList, RooLinkedList& processedNodes); RooAbsArg*RooAbsArg::findNewServer(const RooAbsCollection& newSet, Bool_t nameChange) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; Double_tRooAbsReal::findRoot(RooRealVar& x, Double_t xmin, Double_t xmax, Double_t yval); RooAbsArg*RooAbsArg::findServer(const char* name) const; RooAbsArg*RooAbsArg::findServer(const RooAbsArg& arg) const; RooAbsArg*RooAbsArg::findServer(Int_t index) const; virtual voidRooAbsReal::fixAddCoefNormalization(const RooArgSet& addNormSet = RooArgSet(), Bool_t force = kTRUE); virtual voidRooAbsReal::fixAddCoefRange(const char* rangeName = 0, Bool_t force = kTRUE); static UInt_tRooAbsArg::fnv1a32(const char* data); static UInt_tRooAbsArg::fnv1a32(const char* data, ULong_t sz, UInt_t hash = fnv1a32start); static ULong64_tRooAbsArg::fnv1a64(const char* data",MatchSource.WIKI,root/html602/RooAbsOptTestStatistic.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsOptTestStatistic.html
https://root.cern/root/html602/RooAbsOptTestStatistic.html:12073,Performance,cache,cacheList,12073,"ggingMode(); virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); RooExpensiveObjectCache&RooAbsArg::expensiveObjectCache() const; virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); RooDataHist*RooAbsReal::fillDataHist(RooDataHist* hist, const RooArgSet* nset, Double_t scaleFactor, Bool_t correctForBinVolume = kFALSE, Bool_t showProgress = kFALSE) const; TH1*RooAbsReal::fillHistogram(TH1* hist, const RooArgList& plotVars, Double_t scaleFactor = 1, const RooArgSet* projectedVars = 0, Bool_t scaling = kTRUE, const RooArgSet* condObs = 0, Bool_t setError = kTRUE) const; Bool_tRooAbsArg::findConstantNodes(const RooArgSet& observables, RooArgSet& cacheList); Bool_tRooAbsArg::findConstantNodes(const RooArgSet& observables, RooArgSet& cacheList, RooLinkedList& processedNodes); RooAbsArg*RooAbsArg::findNewServer(const RooAbsCollection& newSet, Bool_t nameChange) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; Double_tRooAbsReal::findRoot(RooRealVar& x, Double_t xmin, Double_t xmax, Double_t yval); RooAbsArg*RooAbsArg::findServer(const char* name) const; RooAbsArg*RooAbsArg::findServer(const RooAbsArg& arg) const; RooAbsArg*RooAbsArg::findServer(Int_t index) const; virtual voidRooAbsReal::fixAddCoefNormalization(const RooArgSet& addNormSet = RooArgSet(), Bool_t force = kTRUE); virtual voidRooAbsReal::fixAddCoefRange(const char* rangeName = 0, Bool_t force = kTRUE); static UInt_tRooAbsArg::fnv1a32(const char* data); static UInt_tRooAbsArg::fnv1a32(const char* data, ULong_t sz, UInt_t hash = fnv1a32start); static ULong64_tRooAbsArg::fnv1a64(const char* data); static ULong64_tRooAbsArg::fnv1a64(const char* data, ULong_t sz, ULong64_t hash = fnv",MatchSource.WIKI,root/html602/RooAbsOptTestStatistic.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsOptTestStatistic.html
https://root.cern/root/html602/RooAbsOptTestStatistic.html:20602,Performance,optimiz,optimizeCacheMode,20602,"eal::numEvalErrors(); Bool_tRooAbsArg::observableOverlaps(const RooAbsData* dset, const RooAbsArg& testArg) const; Bool_tRooAbsArg::observableOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; virtual Double_tRooAbsTestStatistic::offset() const; virtual Double_tRooAbsTestStatistic::offsetCarry() const; voidTObject::operator delete(void* ptr); voidTObject::operator delete(void* ptr, void* vp); voidTObject::operator delete[](void* ptr); voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); RooAbsOptTestStatistic&operator=(const RooAbsOptTestStatistic&); Bool_tRooAbsReal::operator==(Double_t value) const; virtual Bool_tRooAbsReal::operator==(const RooAbsArg& other); virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables); virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables, RooArgSet& optNodes, RooLinkedList& processedNodes); Bool_tRooAbsArg::overlaps(const RooAbsArg& testArg, Bool_t valueOnly = kFALSE) const; const RooArgSet*RooAbsArg::ownedComponents() const; virtual voidTObject::Paint(Option_t* option = """"); virtual RooPlot*RooAbsReal::plotOn(RooPlot* frame, RooLinkedList& cmdList) const; virtual RooPlot*RooAbsReal::plotOn(RooPlot* frame, const RooCmdArg& arg1 = RooCmdArg(), const RooCmdArg& arg2 = RooCmdArg(), const RooCmdArg& arg3 = RooCmdArg(), const RooCmdArg& arg4 = RooCmdArg(), const RooCmdArg& arg5 = RooCmdArg(), const RooCmdArg& arg6 = RooCmdArg(), const RooCmdArg& arg7 = RooCmdArg(), const RooCmdArg& arg8 = RooCmdArg(), const RooCmdArg& arg9 = RooCmdArg(), const RooCmdArg& arg10 = RooCmdArg()) const; virtual list<Double_t>*RooAbsReal::plotSamplingHint(RooAbsRealLValue&, Double_t, Double_t) const; virtual RooPlot*RooAbsReal::plotSliceO",MatchSource.WIKI,root/html602/RooAbsOptTestStatistic.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsOptTestStatistic.html
https://root.cern/root/html602/RooAbsOptTestStatistic.html:20674,Performance,optimiz,optimizeCacheMode,20674,"ta* dset, const RooAbsArg& testArg) const; Bool_tRooAbsArg::observableOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; virtual Double_tRooAbsTestStatistic::offset() const; virtual Double_tRooAbsTestStatistic::offsetCarry() const; voidTObject::operator delete(void* ptr); voidTObject::operator delete(void* ptr, void* vp); voidTObject::operator delete[](void* ptr); voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); RooAbsOptTestStatistic&operator=(const RooAbsOptTestStatistic&); Bool_tRooAbsReal::operator==(Double_t value) const; virtual Bool_tRooAbsReal::operator==(const RooAbsArg& other); virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables); virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables, RooArgSet& optNodes, RooLinkedList& processedNodes); Bool_tRooAbsArg::overlaps(const RooAbsArg& testArg, Bool_t valueOnly = kFALSE) const; const RooArgSet*RooAbsArg::ownedComponents() const; virtual voidTObject::Paint(Option_t* option = """"); virtual RooPlot*RooAbsReal::plotOn(RooPlot* frame, RooLinkedList& cmdList) const; virtual RooPlot*RooAbsReal::plotOn(RooPlot* frame, const RooCmdArg& arg1 = RooCmdArg(), const RooCmdArg& arg2 = RooCmdArg(), const RooCmdArg& arg3 = RooCmdArg(), const RooCmdArg& arg4 = RooCmdArg(), const RooCmdArg& arg5 = RooCmdArg(), const RooCmdArg& arg6 = RooCmdArg(), const RooCmdArg& arg7 = RooCmdArg(), const RooCmdArg& arg8 = RooCmdArg(), const RooCmdArg& arg9 = RooCmdArg(), const RooCmdArg& arg10 = RooCmdArg()) const; virtual list<Double_t>*RooAbsReal::plotSamplingHint(RooAbsRealLValue&, Double_t, Double_t) const; virtual RooPlot*RooAbsReal::plotSliceOn(RooPlot* frame, const RooArgSet& sliceSet, Option_t* drawOptions = ""L""",MatchSource.WIKI,root/html602/RooAbsOptTestStatistic.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsOptTestStatistic.html
https://root.cern/root/html602/RooAbsOptTestStatistic.html:23973,Performance,cache,cache,23973,"am(ostream& os, Int_t contents, RooPrintable::StyleOption style, TString indent = """") const; virtual voidRooAbsArg::printTitle(ostream& os) const; virtual voidRooAbsArg::printTree(ostream& os, TString indent = """") const; virtual voidRooAbsReal::printValue(ostream& os) const; virtual Int_tTObject::Read(const char* name); virtual Bool_tRooAbsReal::readFromStream(istream& is, Bool_t compact, Bool_t verbose = kFALSE); Bool_tRooAbsArg::recursiveCheckDependents(const RooArgSet* nset) const; Bool_tRooAbsArg::recursiveCheckObservables(const RooArgSet* nset) const; Bool_tRooAbsArg::recursiveRedirectServers(const RooAbsCollection& newServerList, Bool_t mustReplaceAll = kFALSE, Bool_t nameChange = kFALSE, Bool_t recurseInNewSet = kTRUE); virtual voidTObject::RecursiveRemove(TObject* obj); Bool_tRooAbsArg::redirectServers(const RooAbsCollection& newServerList, Bool_t mustReplaceAll = kFALSE, Bool_t nameChange = kFALSE, Bool_t isRecursionStep = kFALSE); voidRooAbsArg::registerCache(RooAbsCache& cache); voidRooAbsArg::removeServer(RooAbsArg& server, Bool_t force = kFALSE); voidRooAbsArg::replaceServer(RooAbsArg& oldServer, RooAbsArg& newServer, Bool_t valueProp, Bool_t shapeProp); voidTObject::ResetBit(UInt_t f); RooAbsOptTestStatistic(); RooAbsOptTestStatistic(const RooAbsOptTestStatistic& other, const char* name = 0); RooAbsOptTestStatistic(const char* name, const char* title, RooAbsReal& real, RooAbsData& data, const RooArgSet& projDeps, const char* rangeName = 0, const char* addCoefRangeName = 0, Int_t nCPU = 1, RooFit::MPSplit interleave = RooFit::BulkPartition, Bool_t verbose = kTRUE, Bool_t splitCutRange = kFALSE, Bool_t cloneInputData = kTRUE); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); voidseal(const char* notice = """"); const char*sealNotice() const; TIterator*RooAbsArg::serverIterator() const; RooFIterRooAbsArg::serverMIterator() const; virtual voidRoo",MatchSource.WIKI,root/html602/RooAbsOptTestStatistic.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsOptTestStatistic.html
https://root.cern/root/html602/RooAbsOptTestStatistic.html:25696,Performance,cache,cache,25696,"ption_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); voidseal(const char* notice = """"); const char*sealNotice() const; TIterator*RooAbsArg::serverIterator() const; RooFIterRooAbsArg::serverMIterator() const; virtual voidRooAbsArg::serverNameChangeHook(const RooAbsArg*, const RooAbsArg*); voidRooAbsArg::setAttribute(const Text_t* name, Bool_t value = kTRUE); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); virtual voidRooAbsArg::setCacheAndTrackHints(RooArgSet&); static voidRooAbsReal::setCacheCheck(Bool_t flag); virtual Bool_tRooAbsTestStatistic::setData(RooAbsData& data, Bool_t cloneData = kTRUE); static voidRooAbsArg::setDirtyInhibit(Bool_t flag); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); static voidRooAbsReal::setEvalErrorLoggingMode(RooAbsReal::ErrorLoggingMode m); virtual voidRooAbsArg::setExpensiveObjectCache(RooExpensiveObjectCache& cache); static voidRooAbsReal::setHideOffset(Bool_t flag); voidRooAbsReal::setIntegratorConfig(); voidRooAbsReal::setIntegratorConfig(const RooNumIntConfig& config); voidRooAbsArg::setLocalNoDirtyInhibit(Bool_t flag) const; virtual voidRooAbsArg::SetName(const char* name); virtual voidRooAbsArg::SetNameTitle(const char* name, const char* title); static voidTObject::SetObjectStat(Bool_t stat); voidRooAbsArg::setOperMode(RooAbsArg::OperMode mode, Bool_t recurseADirty = kTRUE); voidRooAbsReal::setParameterizeIntegral(const RooArgSet& paramVars); voidRooAbsReal::setPlotLabel(const char* label); voidRooAbsArg::setProhibitServerRedirect(Bool_t flag); voidRooAbsArg::setShapeDirty() const; voidRooAbsArg::setStringAttribute(const Text_t* key, const Text_t* value); virtual voidTNamed::SetTitle(const char* title = """")MENU ; voidRooAbsArg::setTransientAttribute(const Text_t* name, Bool_t value = kTRUE); virtual voidTObject::SetUniqueID(UInt_t uid); voidRooAbsReal::setUnit(const char* unit); voidRooAb",MatchSource.WIKI,root/html602/RooAbsOptTestStatistic.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsOptTestStatistic.html
https://root.cern/root/html602/RooAbsOptTestStatistic.html:27791,Performance,cache,cache,27791,"voidRooAbsArg::setShapeDirty() const; voidRooAbsArg::setStringAttribute(const Text_t* key, const Text_t* value); virtual voidTNamed::SetTitle(const char* title = """")MENU ; voidRooAbsArg::setTransientAttribute(const Text_t* name, Bool_t value = kTRUE); virtual voidTObject::SetUniqueID(UInt_t uid); voidRooAbsReal::setUnit(const char* unit); voidRooAbsArg::setValueDirty() const; TIterator*RooAbsArg::shapeClientIterator() const; RooFIterRooAbsArg::shapeClientMIterator() const; virtual voidShowMembers(TMemberInspector& insp) const; RooAbsMoment*RooAbsReal::sigma(RooRealVar& obs); RooAbsMoment*RooAbsReal::sigma(RooRealVar& obs, const RooArgSet& nset); virtual Int_tTNamed::Sizeof() const; RooNumIntConfig*RooAbsReal::specialIntegratorConfig() const; RooNumIntConfig*RooAbsReal::specialIntegratorConfig(Bool_t createOnTheFly); virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); const map<string,string>&RooAbsArg::stringAttributes() const; virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; const set<string>&RooAbsArg::transientAttributes() const; voidRooAbsArg::treeNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t doBranch = kTRUE, Bool_t doLeaf = kTRUE, Bool_t valueOnly = kFALSE, Bool_t recurseNonDerived = kFALSE) const; voidRooAbsArg::unRegisterCache(RooAbsCache& cache); virtual voidTObject::UseCurrentStyle(); TIterator*RooAbsArg::valueClientIterator() const; RooFIterRooAbsArg::valueClientMIterator() const; static voidRooAbsArg::verboseDirty(Bool_t flag); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; voidRooAbsArg::wireAllCaches(); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const; virtual voidRooAbsReal::writeToStream(ostream& os, Bool_t compact) const.",MatchSource.WIKI,root/html602/RooAbsOptTestStatistic.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsOptTestStatistic.html
https://root.cern/root/html602/RooAbsOptTestStatistic.html:31849,Performance,optimiz,optimizeDirtyHook,31849,"ectedVars, Bool_t silent) const; voidTObject::MakeZombie(); Bool_tRooAbsReal::matchArgs(const RooArgSet& allDeps, RooArgSet& numDeps, const RooArgProxy& a) const; Bool_tRooAbsReal::matchArgs(const RooArgSet& allDeps, RooArgSet& numDeps, const RooArgSet& set) const; Bool_tRooAbsReal::matchArgs(const RooArgSet& allDeps, RooArgSet& numDeps, const RooArgProxy& a, const RooArgProxy& b) const; Bool_tRooAbsReal::matchArgs(const RooArgSet& allDeps, RooArgSet& numDeps, const RooArgProxy& a, const RooArgProxy& b, const RooArgProxy& c) const; Bool_tRooAbsReal::matchArgs(const RooArgSet& allDeps, RooArgSet& numDeps, const RooArgProxy& a, const RooArgProxy& b, const RooArgProxy& c, const RooArgProxy& d) const; Int_tRooAbsArg::numProxies() const; Int_tRooAbsTestStatistic::numSets() const; RooAbsTestStatistic::GOFOpModeRooAbsTestStatistic::operMode() const; virtual voidRooAbsArg::operModeHook(); voidoptimizeCaching(); voidoptimizeConstantTerms(Bool_t, Bool_t = kTRUE); virtual voidRooAbsArg::optimizeDirtyHook(const RooArgSet*); virtual RooPlot*RooAbsReal::plotAsymOn(RooPlot* frame, const RooAbsCategoryLValue& asymCat, RooAbsReal::PlotOpt o) const; virtual RooPlot*RooAbsReal::plotOn(RooPlot* frame, RooAbsReal::PlotOpt o) const; voidRooAbsReal::plotOnCompSelect(RooArgSet* selNodes) const; RooPlot*RooAbsReal::plotOnWithErrorBand(RooPlot* frame, const RooFitResult& fr, Double_t Z, const RooArgSet* params, const RooLinkedList& argList, Bool_t method1) const; Bool_tRooAbsReal::plotSanityChecks(RooPlot* frame) const; voidRooAbsArg::printAttribList(ostream& os) const; virtual voidprintCompactTreeHook(ostream& os, const char* indent = """"); virtual Bool_tRooAbsTestStatistic::processEmptyDataSets() const; virtual Bool_tredirectServersHook(const RooAbsCollection& newServerList, Bool_t mustReplaceAll, Bool_t nameChange, Bool_t isRecursive); voidRooAbsArg::registerProxy(RooArgProxy& proxy); voidRooAbsArg::registerProxy(RooSetProxy& proxy); voidRooAbsArg::registerProxy(RooListProxy& proxy); virtu",MatchSource.WIKI,root/html602/RooAbsOptTestStatistic.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsOptTestStatistic.html
https://root.cern/root/html602/RooAbsOptTestStatistic.html:37253,Performance,cache,cache,37253,,MatchSource.WIKI,root/html602/RooAbsOptTestStatistic.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsOptTestStatistic.html
https://root.cern/root/html602/RooAbsOptTestStatistic.html:37336,Performance,cache,cache,37336,,MatchSource.WIKI,root/html602/RooAbsOptTestStatistic.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsOptTestStatistic.html
https://root.cern/root/html602/RooAbsOptTestStatistic.html:37534,Performance,cache,caches,37534,,MatchSource.WIKI,root/html602/RooAbsOptTestStatistic.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsOptTestStatistic.html
https://root.cern/root/html602/RooAbsOptTestStatistic.html:37588,Performance,cache,cached,37588,,MatchSource.WIKI,root/html602/RooAbsOptTestStatistic.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsOptTestStatistic.html
https://root.cern/root/html602/RooAbsOptTestStatistic.html:38373,Performance,cache,cache,38373,"; static Bool_tRooAbsReal::_cacheCheckIf true, always validate contents of clean which outcome of evaluate(); deque<RooAbsCache*>RooAbsArg::_cacheListlist of caches; RooArgSet_cachedNodes! List of nodes that are cached as constant expressions; RooRefCountListRooAbsArg::_clientListlist of client objects; RooRefCountListRooAbsArg::_clientListShapesubset of clients that requested shape dirty flag propagation; RooRefCountListRooAbsArg::_clientListValuesubset of clients that requested value dirty flag propagation; TIterator*RooAbsArg::_clientShapeIter! Iterator over _clientListShape; TIterator*RooAbsArg::_clientValueIter! Iterator over _clientListValue; RooAbsData*RooAbsTestStatistic::_dataPointer to original input dataset; RooAbsData*_dataClonePointer to internal clone if input data; Bool_tRooAbsArg::_deleteWatch! Delete watch flag; Bool_tRooAbsTestStatistic::_doOffsetApply interval value offset to control numeric precision?; RooExpensiveObjectCache*RooAbsArg::_eocachePointer to global cache manager for any expensive components created by this object; Double_tRooAbsTestStatistic::_evalCarry! carry of Kahan sum in evaluatePartition; Int_tRooAbsTestStatistic::_extSet! Number of designated set to calculated extended term; Bool_tRooAbsArg::_fastAllow fast access mode in getVal() and proxies; Float_tRooAbsReal::_floatValue! Transient cache for floating point values from tree branches; Bool_tRooAbsReal::_forceNumIntForce numerical integration if flag set; RooAbsReal*RooAbsTestStatistic::_funcPointer to original input function; RooAbsReal*_funcClonePointer to internal clone of input function; RooArgSet*_funcCloneSetSet owning all components of internal clone of input function; RooArgSet*_funcObsSetList of observables in the pdf expression; static Bool_tRooAbsReal::_globalSelectCompGlobal activation switch for component selection; pRooAbsTestStatistic*RooAbsTestStatistic::_gofArray! Array of sub-contexts representing part of the combined test statistic; RooAbsTestStatistic::GOF",MatchSource.WIKI,root/html602/RooAbsOptTestStatistic.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsOptTestStatistic.html
https://root.cern/root/html602/RooAbsOptTestStatistic.html:38723,Performance,cache,cache,38723,set of clients that requested shape dirty flag propagation; RooRefCountListRooAbsArg::_clientListValuesubset of clients that requested value dirty flag propagation; TIterator*RooAbsArg::_clientShapeIter! Iterator over _clientListShape; TIterator*RooAbsArg::_clientValueIter! Iterator over _clientListValue; RooAbsData*RooAbsTestStatistic::_dataPointer to original input dataset; RooAbsData*_dataClonePointer to internal clone if input data; Bool_tRooAbsArg::_deleteWatch! Delete watch flag; Bool_tRooAbsTestStatistic::_doOffsetApply interval value offset to control numeric precision?; RooExpensiveObjectCache*RooAbsArg::_eocachePointer to global cache manager for any expensive components created by this object; Double_tRooAbsTestStatistic::_evalCarry! carry of Kahan sum in evaluatePartition; Int_tRooAbsTestStatistic::_extSet! Number of designated set to calculated extended term; Bool_tRooAbsArg::_fastAllow fast access mode in getVal() and proxies; Float_tRooAbsReal::_floatValue! Transient cache for floating point values from tree branches; Bool_tRooAbsReal::_forceNumIntForce numerical integration if flag set; RooAbsReal*RooAbsTestStatistic::_funcPointer to original input function; RooAbsReal*_funcClonePointer to internal clone of input function; RooArgSet*_funcCloneSetSet owning all components of internal clone of input function; RooArgSet*_funcObsSetList of observables in the pdf expression; static Bool_tRooAbsReal::_globalSelectCompGlobal activation switch for component selection; pRooAbsTestStatistic*RooAbsTestStatistic::_gofArray! Array of sub-contexts representing part of the combined test statistic; RooAbsTestStatistic::GOFOpModeRooAbsTestStatistic::_gofOpModeOperation mode of test statistic instance; vector<RooFit::MPSplit>RooAbsTestStatistic::_gofSplitMode! GOF MP Split mode specified by component (when Auto is active); static Bool_tRooAbsReal::_hideOffsetOffset hiding flag; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state ,MatchSource.WIKI,root/html602/RooAbsOptTestStatistic.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsOptTestStatistic.html
https://root.cern/root/html602/RooAbsOptTestStatistic.html:39834,Performance,cache,cache,39834,ode in getVal() and proxies; Float_tRooAbsReal::_floatValue! Transient cache for floating point values from tree branches; Bool_tRooAbsReal::_forceNumIntForce numerical integration if flag set; RooAbsReal*RooAbsTestStatistic::_funcPointer to original input function; RooAbsReal*_funcClonePointer to internal clone of input function; RooArgSet*_funcCloneSetSet owning all components of internal clone of input function; RooArgSet*_funcObsSetList of observables in the pdf expression; static Bool_tRooAbsReal::_globalSelectCompGlobal activation switch for component selection; pRooAbsTestStatistic*RooAbsTestStatistic::_gofArray! Array of sub-contexts representing part of the combined test statistic; RooAbsTestStatistic::GOFOpModeRooAbsTestStatistic::_gofOpModeOperation mode of test statistic instance; vector<RooFit::MPSplit>RooAbsTestStatistic::_gofSplitMode! GOF MP Split mode specified by component (when Auto is active); static Bool_tRooAbsReal::_hideOffsetOffset hiding flag; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; Bool_tRooAbsTestStatistic::_init! Is object initialized; Int_tRooAbsReal::_intValue! Transient cache for integer values from tree branches; Bool_tRooAbsArg::_isConstant! Cached isConstant status; TStringRooAbsReal::_labelPlot label for objects value; RooArgSet*RooAbsReal::_lastNSet!; Bool_tRooAbsArg::_localNoInhibitDirty! Prevent 'AlwaysDirty' mode for this node; pRooRealMPFE*RooAbsTestStatistic::_mpfeArray! Array of parallel execution frond ends; RooFit::MPSplitRooAbsTestStatistic::_mpinterlUse interleaving strategy rather than N-wise split for partioning of dataset for multiprocessor-split; Int_tRooAbsTestStatistic::_nCPUNumber of processors to use in parallel calculation mode; Int_tRooAbsTestStatistic::_nEventsTotal number of events in test statistic calculation; Int_tRooAbsTestStatistic::_nGofNumber of sub-contexts; static Int_tRooPrintable::_nameLength; TNamed*RooAbsArg::_namePtr! Do not persist.,MatchSource.WIKI,root/html602/RooAbsOptTestStatistic.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsOptTestStatistic.html
https://root.cern/root/html602/RooAbsOptTestStatistic.html:41923,Performance,cache,cache,41923,ber of processors to use in parallel calculation mode; Int_tRooAbsTestStatistic::_nEventsTotal number of events in test statistic calculation; Int_tRooAbsTestStatistic::_nGofNumber of sub-contexts; static Int_tRooPrintable::_nameLength; TNamed*RooAbsArg::_namePtr! Do not persist. Pointer to global instance of string that matches object named; RooArgSet*_normSetPointer to set with observables used for normalization; Int_tRooAbsTestStatistic::_numSetsTotal number of partitions in parallel calculation mode; Double_tRooAbsTestStatistic::_offset! Offset; Double_tRooAbsTestStatistic::_offsetCarry! avoids loss of precision; RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; Bool_t_optimized!; RooAbsData*_origDataOriginal data; RooAbsReal*_origFuncOriginal function; Bool_t_ownDataDo we own the dataset; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; RooSetProxyRooAbsTestStatistic::_paramSetParameters of the test statistic (=parameters of the input function); Int_tRooAbsReal::_plotBinsNumber of plot bins; Double_tRooAbsReal::_plotMaxMaximum of plot range; Double_tRooAbsReal::_plotMinMinimum of plot range; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; RooArgSet*_projDepsSet of projected observable; const RooArgSet*RooAbsTestStatistic::_projDepsPointer to set with projected observables; RooRefArrayRooAbsArg::_proxyListlist of proxies; stringRooAbsTestStatistic::_rangeNameName of range in which to calculate test statistic; Char_tRooAbsReal::_sbyteValue! Transient cache for signed byte values from tree branches; TString_sealNoticeUser-defined notice shown when reading a sealed likelihood; Bool_t_sealedIs test statistic sealed -- i.e. no access to data; Bool_tRooAbsReal::_selectComp! Component selection flag for RooAbsPdf::plotCompOn; RooRefCountListRooAbsArg::_serverListlist of server objects; Int_tRooAbsTestStatistic::_setNumPartition number of this instance in parallel calculation mode; Bool_tRooAbsArg::,MatchSource.WIKI,root/html602/RooAbsOptTestStatistic.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsOptTestStatistic.html
https://root.cern/root/html602/RooAbsOptTestStatistic.html:42898,Performance,cache,cache,42898,"ree branches; TString_sealNoticeUser-defined notice shown when reading a sealed likelihood; Bool_t_sealedIs test statistic sealed -- i.e. no access to data; Bool_tRooAbsReal::_selectComp! Component selection flag for RooAbsPdf::plotCompOn; RooRefCountListRooAbsArg::_serverListlist of server objects; Int_tRooAbsTestStatistic::_setNumPartition number of this instance in parallel calculation mode; Bool_tRooAbsArg::_shapeDirtyFlag set if value needs recalculating because input shapes modified; Int_tRooAbsTestStatistic::_simCountTotal number of component p.d.f.s in RooSimultaneous (if any); RooNumIntConfig*RooAbsReal::_specIntegratorConfigNumeric integrator configuration specific for this object; Bool_tRooAbsTestStatistic::_splitRangeSplit rangeName in RooSimultaneous index labels if true; map<string,string>RooAbsArg::_stringAttribString attributes; Bool_tRooAbsReal::_treeVar!do not persist; UInt_tRooAbsReal::_uintValue! Transient cache for unsigned integer values from tree branches; TStringRooAbsReal::_unitUnit for objects value; Double_tRooAbsReal::_valueCache for current value of object; Bool_tRooAbsArg::_valueDirtyFlag set if value needs recalculating because input values modified; Bool_tRooAbsTestStatistic::_verboseVerbose messaging if true; static Bool_tRooAbsArg::_verboseDirtyStatic flag controlling verbose messaging for dirty state changes; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; RooAbsOptTestStatistic(const char* name, const char* title, RooAbsReal& real, RooAbsData& data, const RooArgSet& projDeps, const char* rangeName = 0, const char* addCoefRangeName = 0, Int_t nCPU = 1, RooFit::MPSplit interleave = RooFit::BulkPartition, Bool_t verbose = kTRUE, Bool_t splitCutRange = kFALSE, Bool_t cloneInputData = kTRUE); Constructor taking function (real), a dataset (data), a set of projected observables (projSet). If; rangeName is not null, only eve",MatchSource.WIKI,root/html602/RooAbsOptTestStatistic.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsOptTestStatistic.html
https://root.cern/root/html602/RooAbsOptTestStatistic.html:45925,Performance,optimiz,optimizations,45925,"angeName_{catName} will be used; as range definition for each index state of a RooSimultaneous. RooAbsOptTestStatistic(const RooAbsOptTestStatistic& other, const char* name = 0); Copy constructor. void initSlave(RooAbsReal& real, RooAbsData& indata, const RooArgSet& projDeps, const char* rangeName, const char* addCoefRangeName). ~RooAbsOptTestStatistic(); Destructor. Double_t combinedValue(RooAbsReal** gofArray, Int_t nVal) const; Method to combined test statistic results calculated into partitions into; the global result. This default implementation adds the partition return; values. Bool_t redirectServersHook(const RooAbsCollection& newServerList, Bool_t mustReplaceAll, Bool_t nameChange, Bool_t isRecursive); Catch server redirect calls and forward to internal clone of function. void printCompactTreeHook(ostream& os, const char* indent = """"); Catch print hook function and forward to function clone. void constOptimizeTestStatistic(RooAbsArg::ConstOpCode opcode, Bool_t doAlsoTrackingOpt = kTRUE); Driver function to propagate constant term optimizations in test statistic.; If code Activate is sent, constant term optimization will be executed.; If code Deacivate is sent, any existing constant term optimizations will; be abanoned. If codes ConfigChange or ValueChange are sent, any existing; constant term optimizations will be redone. void optimizeCaching(); This method changes the value caching logic for all nodes that depends on any of the observables; as defined by the given dataset. When evaluating a test statistic constructed from the RooAbsReal; with a dataset the observables are guaranteed to change with every call, thus there is no point; in tracking these changes which result in a net overhead. Thus for observable-dependent nodes,; the evaluation mechanism is changed from being dependent on a 'valueDirty' flag to guaranteed evaluation.; On the dataset side, the observables objects are modified to no longer send valueDirty messages; to their client. void optimiz",MatchSource.WIKI,root/html602/RooAbsOptTestStatistic.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsOptTestStatistic.html
https://root.cern/root/html602/RooAbsOptTestStatistic.html:45999,Performance,optimiz,optimization,45999,"t RooAbsOptTestStatistic& other, const char* name = 0); Copy constructor. void initSlave(RooAbsReal& real, RooAbsData& indata, const RooArgSet& projDeps, const char* rangeName, const char* addCoefRangeName). ~RooAbsOptTestStatistic(); Destructor. Double_t combinedValue(RooAbsReal** gofArray, Int_t nVal) const; Method to combined test statistic results calculated into partitions into; the global result. This default implementation adds the partition return; values. Bool_t redirectServersHook(const RooAbsCollection& newServerList, Bool_t mustReplaceAll, Bool_t nameChange, Bool_t isRecursive); Catch server redirect calls and forward to internal clone of function. void printCompactTreeHook(ostream& os, const char* indent = """"); Catch print hook function and forward to function clone. void constOptimizeTestStatistic(RooAbsArg::ConstOpCode opcode, Bool_t doAlsoTrackingOpt = kTRUE); Driver function to propagate constant term optimizations in test statistic.; If code Activate is sent, constant term optimization will be executed.; If code Deacivate is sent, any existing constant term optimizations will; be abanoned. If codes ConfigChange or ValueChange are sent, any existing; constant term optimizations will be redone. void optimizeCaching(); This method changes the value caching logic for all nodes that depends on any of the observables; as defined by the given dataset. When evaluating a test statistic constructed from the RooAbsReal; with a dataset the observables are guaranteed to change with every call, thus there is no point; in tracking these changes which result in a net overhead. Thus for observable-dependent nodes,; the evaluation mechanism is changed from being dependent on a 'valueDirty' flag to guaranteed evaluation.; On the dataset side, the observables objects are modified to no longer send valueDirty messages; to their client. void optimizeConstantTerms(Bool_t , Bool_t = kTRUE); Driver function to activate global constant term optimization.; If activated const",MatchSource.WIKI,root/html602/RooAbsOptTestStatistic.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsOptTestStatistic.html
https://root.cern/root/html602/RooAbsOptTestStatistic.html:46085,Performance,optimiz,optimizations,46085,"nitSlave(RooAbsReal& real, RooAbsData& indata, const RooArgSet& projDeps, const char* rangeName, const char* addCoefRangeName). ~RooAbsOptTestStatistic(); Destructor. Double_t combinedValue(RooAbsReal** gofArray, Int_t nVal) const; Method to combined test statistic results calculated into partitions into; the global result. This default implementation adds the partition return; values. Bool_t redirectServersHook(const RooAbsCollection& newServerList, Bool_t mustReplaceAll, Bool_t nameChange, Bool_t isRecursive); Catch server redirect calls and forward to internal clone of function. void printCompactTreeHook(ostream& os, const char* indent = """"); Catch print hook function and forward to function clone. void constOptimizeTestStatistic(RooAbsArg::ConstOpCode opcode, Bool_t doAlsoTrackingOpt = kTRUE); Driver function to propagate constant term optimizations in test statistic.; If code Activate is sent, constant term optimization will be executed.; If code Deacivate is sent, any existing constant term optimizations will; be abanoned. If codes ConfigChange or ValueChange are sent, any existing; constant term optimizations will be redone. void optimizeCaching(); This method changes the value caching logic for all nodes that depends on any of the observables; as defined by the given dataset. When evaluating a test statistic constructed from the RooAbsReal; with a dataset the observables are guaranteed to change with every call, thus there is no point; in tracking these changes which result in a net overhead. Thus for observable-dependent nodes,; the evaluation mechanism is changed from being dependent on a 'valueDirty' flag to guaranteed evaluation.; On the dataset side, the observables objects are modified to no longer send valueDirty messages; to their client. void optimizeConstantTerms(Bool_t , Bool_t = kTRUE); Driver function to activate global constant term optimization.; If activated constant terms are found and cached with the dataset; The operation mode of cached no",MatchSource.WIKI,root/html602/RooAbsOptTestStatistic.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsOptTestStatistic.html
https://root.cern/root/html602/RooAbsOptTestStatistic.html:46193,Performance,optimiz,optimizations,46193," const char* addCoefRangeName). ~RooAbsOptTestStatistic(); Destructor. Double_t combinedValue(RooAbsReal** gofArray, Int_t nVal) const; Method to combined test statistic results calculated into partitions into; the global result. This default implementation adds the partition return; values. Bool_t redirectServersHook(const RooAbsCollection& newServerList, Bool_t mustReplaceAll, Bool_t nameChange, Bool_t isRecursive); Catch server redirect calls and forward to internal clone of function. void printCompactTreeHook(ostream& os, const char* indent = """"); Catch print hook function and forward to function clone. void constOptimizeTestStatistic(RooAbsArg::ConstOpCode opcode, Bool_t doAlsoTrackingOpt = kTRUE); Driver function to propagate constant term optimizations in test statistic.; If code Activate is sent, constant term optimization will be executed.; If code Deacivate is sent, any existing constant term optimizations will; be abanoned. If codes ConfigChange or ValueChange are sent, any existing; constant term optimizations will be redone. void optimizeCaching(); This method changes the value caching logic for all nodes that depends on any of the observables; as defined by the given dataset. When evaluating a test statistic constructed from the RooAbsReal; with a dataset the observables are guaranteed to change with every call, thus there is no point; in tracking these changes which result in a net overhead. Thus for observable-dependent nodes,; the evaluation mechanism is changed from being dependent on a 'valueDirty' flag to guaranteed evaluation.; On the dataset side, the observables objects are modified to no longer send valueDirty messages; to their client. void optimizeConstantTerms(Bool_t , Bool_t = kTRUE); Driver function to activate global constant term optimization.; If activated constant terms are found and cached with the dataset; The operation mode of cached nodes is set to AClean meaning that; their getVal() call will never result in an evaluate call.; Fi",MatchSource.WIKI,root/html602/RooAbsOptTestStatistic.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsOptTestStatistic.html
https://root.cern/root/html602/RooAbsOptTestStatistic.html:46228,Performance,optimiz,optimizeCaching,46228,"onst; Method to combined test statistic results calculated into partitions into; the global result. This default implementation adds the partition return; values. Bool_t redirectServersHook(const RooAbsCollection& newServerList, Bool_t mustReplaceAll, Bool_t nameChange, Bool_t isRecursive); Catch server redirect calls and forward to internal clone of function. void printCompactTreeHook(ostream& os, const char* indent = """"); Catch print hook function and forward to function clone. void constOptimizeTestStatistic(RooAbsArg::ConstOpCode opcode, Bool_t doAlsoTrackingOpt = kTRUE); Driver function to propagate constant term optimizations in test statistic.; If code Activate is sent, constant term optimization will be executed.; If code Deacivate is sent, any existing constant term optimizations will; be abanoned. If codes ConfigChange or ValueChange are sent, any existing; constant term optimizations will be redone. void optimizeCaching(); This method changes the value caching logic for all nodes that depends on any of the observables; as defined by the given dataset. When evaluating a test statistic constructed from the RooAbsReal; with a dataset the observables are guaranteed to change with every call, thus there is no point; in tracking these changes which result in a net overhead. Thus for observable-dependent nodes,; the evaluation mechanism is changed from being dependent on a 'valueDirty' flag to guaranteed evaluation.; On the dataset side, the observables objects are modified to no longer send valueDirty messages; to their client. void optimizeConstantTerms(Bool_t , Bool_t = kTRUE); Driver function to activate global constant term optimization.; If activated constant terms are found and cached with the dataset; The operation mode of cached nodes is set to AClean meaning that; their getVal() call will never result in an evaluate call.; Finally the branches in the dataset that correspond to observables; that are exclusively used in constant terms are disabled as; the",MatchSource.WIKI,root/html602/RooAbsOptTestStatistic.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsOptTestStatistic.html
https://root.cern/root/html602/RooAbsOptTestStatistic.html:46863,Performance,optimiz,optimizeConstantTerms,46863,"tant term optimizations in test statistic.; If code Activate is sent, constant term optimization will be executed.; If code Deacivate is sent, any existing constant term optimizations will; be abanoned. If codes ConfigChange or ValueChange are sent, any existing; constant term optimizations will be redone. void optimizeCaching(); This method changes the value caching logic for all nodes that depends on any of the observables; as defined by the given dataset. When evaluating a test statistic constructed from the RooAbsReal; with a dataset the observables are guaranteed to change with every call, thus there is no point; in tracking these changes which result in a net overhead. Thus for observable-dependent nodes,; the evaluation mechanism is changed from being dependent on a 'valueDirty' flag to guaranteed evaluation.; On the dataset side, the observables objects are modified to no longer send valueDirty messages; to their client. void optimizeConstantTerms(Bool_t , Bool_t = kTRUE); Driver function to activate global constant term optimization.; If activated constant terms are found and cached with the dataset; The operation mode of cached nodes is set to AClean meaning that; their getVal() call will never result in an evaluate call.; Finally the branches in the dataset that correspond to observables; that are exclusively used in constant terms are disabled as; they serve no more purpose. Bool_t setDataSlave(RooAbsData& data, Bool_t cloneData = kTRUE, Bool_t ownNewDataAnyway = kFALSE); cout << ""RAOTS::setDataSlave("" << this << "") START"" << endl ;; Change dataset that is used to given one. If cloneData is kTRUE, a clone of; in the input dataset is made. If the test statistic was constructed with; a range specification on the data, the cloneData argument is ignore and; the data is always cloned. RooAbsData& data(). const RooAbsData& data() const. RooAbsOptTestStatistic(); Constructors, assignment etc. RooAbsReal& function(); { return *_funcClone ; }. const RooAbsReal& f",MatchSource.WIKI,root/html602/RooAbsOptTestStatistic.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsOptTestStatistic.html
https://root.cern/root/html602/RooAbsOptTestStatistic.html:46960,Performance,optimiz,optimization,46960,"tant term optimizations in test statistic.; If code Activate is sent, constant term optimization will be executed.; If code Deacivate is sent, any existing constant term optimizations will; be abanoned. If codes ConfigChange or ValueChange are sent, any existing; constant term optimizations will be redone. void optimizeCaching(); This method changes the value caching logic for all nodes that depends on any of the observables; as defined by the given dataset. When evaluating a test statistic constructed from the RooAbsReal; with a dataset the observables are guaranteed to change with every call, thus there is no point; in tracking these changes which result in a net overhead. Thus for observable-dependent nodes,; the evaluation mechanism is changed from being dependent on a 'valueDirty' flag to guaranteed evaluation.; On the dataset side, the observables objects are modified to no longer send valueDirty messages; to their client. void optimizeConstantTerms(Bool_t , Bool_t = kTRUE); Driver function to activate global constant term optimization.; If activated constant terms are found and cached with the dataset; The operation mode of cached nodes is set to AClean meaning that; their getVal() call will never result in an evaluate call.; Finally the branches in the dataset that correspond to observables; that are exclusively used in constant terms are disabled as; they serve no more purpose. Bool_t setDataSlave(RooAbsData& data, Bool_t cloneData = kTRUE, Bool_t ownNewDataAnyway = kFALSE); cout << ""RAOTS::setDataSlave("" << this << "") START"" << endl ;; Change dataset that is used to given one. If cloneData is kTRUE, a clone of; in the input dataset is made. If the test statistic was constructed with; a range specification on the data, the cloneData argument is ignore and; the data is always cloned. RooAbsData& data(). const RooAbsData& data() const. RooAbsOptTestStatistic(); Constructors, assignment etc. RooAbsReal& function(); { return *_funcClone ; }. const RooAbsReal& f",MatchSource.WIKI,root/html602/RooAbsOptTestStatistic.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsOptTestStatistic.html
https://root.cern/root/html602/RooAbsOptTestStatistic.html:47017,Performance,cache,cached,47017,"g constant term optimizations will; be abanoned. If codes ConfigChange or ValueChange are sent, any existing; constant term optimizations will be redone. void optimizeCaching(); This method changes the value caching logic for all nodes that depends on any of the observables; as defined by the given dataset. When evaluating a test statistic constructed from the RooAbsReal; with a dataset the observables are guaranteed to change with every call, thus there is no point; in tracking these changes which result in a net overhead. Thus for observable-dependent nodes,; the evaluation mechanism is changed from being dependent on a 'valueDirty' flag to guaranteed evaluation.; On the dataset side, the observables objects are modified to no longer send valueDirty messages; to their client. void optimizeConstantTerms(Bool_t , Bool_t = kTRUE); Driver function to activate global constant term optimization.; If activated constant terms are found and cached with the dataset; The operation mode of cached nodes is set to AClean meaning that; their getVal() call will never result in an evaluate call.; Finally the branches in the dataset that correspond to observables; that are exclusively used in constant terms are disabled as; they serve no more purpose. Bool_t setDataSlave(RooAbsData& data, Bool_t cloneData = kTRUE, Bool_t ownNewDataAnyway = kFALSE); cout << ""RAOTS::setDataSlave("" << this << "") START"" << endl ;; Change dataset that is used to given one. If cloneData is kTRUE, a clone of; in the input dataset is made. If the test statistic was constructed with; a range specification on the data, the cloneData argument is ignore and; the data is always cloned. RooAbsData& data(). const RooAbsData& data() const. RooAbsOptTestStatistic(); Constructors, assignment etc. RooAbsReal& function(); { return *_funcClone ; }. const RooAbsReal& function() const; { return *_funcClone ; }. const char* cacheUniqueSuffix() const; { return Form(""_%lx"", (ULong_t)_dataClone) ; }. Bool_t isDerived() const;",MatchSource.WIKI,root/html602/RooAbsOptTestStatistic.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsOptTestStatistic.html
https://root.cern/root/html602/RooAbsOptTestStatistic.html:47064,Performance,cache,cached,47064,"g constant term optimizations will; be abanoned. If codes ConfigChange or ValueChange are sent, any existing; constant term optimizations will be redone. void optimizeCaching(); This method changes the value caching logic for all nodes that depends on any of the observables; as defined by the given dataset. When evaluating a test statistic constructed from the RooAbsReal; with a dataset the observables are guaranteed to change with every call, thus there is no point; in tracking these changes which result in a net overhead. Thus for observable-dependent nodes,; the evaluation mechanism is changed from being dependent on a 'valueDirty' flag to guaranteed evaluation.; On the dataset side, the observables objects are modified to no longer send valueDirty messages; to their client. void optimizeConstantTerms(Bool_t , Bool_t = kTRUE); Driver function to activate global constant term optimization.; If activated constant terms are found and cached with the dataset; The operation mode of cached nodes is set to AClean meaning that; their getVal() call will never result in an evaluate call.; Finally the branches in the dataset that correspond to observables; that are exclusively used in constant terms are disabled as; they serve no more purpose. Bool_t setDataSlave(RooAbsData& data, Bool_t cloneData = kTRUE, Bool_t ownNewDataAnyway = kFALSE); cout << ""RAOTS::setDataSlave("" << this << "") START"" << endl ;; Change dataset that is used to given one. If cloneData is kTRUE, a clone of; in the input dataset is made. If the test statistic was constructed with; a range specification on the data, the cloneData argument is ignore and; the data is always cloned. RooAbsData& data(). const RooAbsData& data() const. RooAbsOptTestStatistic(); Constructors, assignment etc. RooAbsReal& function(); { return *_funcClone ; }. const RooAbsReal& function() const; { return *_funcClone ; }. const char* cacheUniqueSuffix() const; { return Form(""_%lx"", (ULong_t)_dataClone) ; }. Bool_t isDerived() const;",MatchSource.WIKI,root/html602/RooAbsOptTestStatistic.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsOptTestStatistic.html
https://root.cern/root/html602/RooAbsOptTestStatistic.html:47970,Performance,cache,cacheUniqueSuffix,47970,"ranteed evaluation.; On the dataset side, the observables objects are modified to no longer send valueDirty messages; to their client. void optimizeConstantTerms(Bool_t , Bool_t = kTRUE); Driver function to activate global constant term optimization.; If activated constant terms are found and cached with the dataset; The operation mode of cached nodes is set to AClean meaning that; their getVal() call will never result in an evaluate call.; Finally the branches in the dataset that correspond to observables; that are exclusively used in constant terms are disabled as; they serve no more purpose. Bool_t setDataSlave(RooAbsData& data, Bool_t cloneData = kTRUE, Bool_t ownNewDataAnyway = kFALSE); cout << ""RAOTS::setDataSlave("" << this << "") START"" << endl ;; Change dataset that is used to given one. If cloneData is kTRUE, a clone of; in the input dataset is made. If the test statistic was constructed with; a range specification on the data, the cloneData argument is ignore and; the data is always cloned. RooAbsData& data(). const RooAbsData& data() const. RooAbsOptTestStatistic(); Constructors, assignment etc. RooAbsReal& function(); { return *_funcClone ; }. const RooAbsReal& function() const; { return *_funcClone ; }. const char* cacheUniqueSuffix() const; { return Form(""_%lx"", (ULong_t)_dataClone) ; }. Bool_t isDerived() const; Override this to be always true to force calculation of likelihood without parameters. { return kTRUE ; }. void seal(const char* notice = """"); { _sealed = kTRUE ; _sealNotice = notice ; }. Bool_t isSealed() const; { return _sealed ; }. const char* sealNotice() const; { return _sealNotice.Data() ; }. Bool_t allowFunctionCache(); { return kTRUE ; }. RooArgSet requiredExtraObservables() const; { return RooArgSet() ; }. » Last changed: Tue Jun 30 14:30:16 2015 » Last generated: 2015-06-30 14:30; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html602/RooAbsOptTestStatistic.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsOptTestStatistic.html
https://root.cern/root/html602/RooAbsOptTestStatistic.html:40972,Safety,avoid,avoids,40972,ber of processors to use in parallel calculation mode; Int_tRooAbsTestStatistic::_nEventsTotal number of events in test statistic calculation; Int_tRooAbsTestStatistic::_nGofNumber of sub-contexts; static Int_tRooPrintable::_nameLength; TNamed*RooAbsArg::_namePtr! Do not persist. Pointer to global instance of string that matches object named; RooArgSet*_normSetPointer to set with observables used for normalization; Int_tRooAbsTestStatistic::_numSetsTotal number of partitions in parallel calculation mode; Double_tRooAbsTestStatistic::_offset! Offset; Double_tRooAbsTestStatistic::_offsetCarry! avoids loss of precision; RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; Bool_t_optimized!; RooAbsData*_origDataOriginal data; RooAbsReal*_origFuncOriginal function; Bool_t_ownDataDo we own the dataset; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; RooSetProxyRooAbsTestStatistic::_paramSetParameters of the test statistic (=parameters of the input function); Int_tRooAbsReal::_plotBinsNumber of plot bins; Double_tRooAbsReal::_plotMaxMaximum of plot range; Double_tRooAbsReal::_plotMinMinimum of plot range; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; RooArgSet*_projDepsSet of projected observable; const RooArgSet*RooAbsTestStatistic::_projDepsPointer to set with projected observables; RooRefArrayRooAbsArg::_proxyListlist of proxies; stringRooAbsTestStatistic::_rangeNameName of range in which to calculate test statistic; Char_tRooAbsReal::_sbyteValue! Transient cache for signed byte values from tree branches; TString_sealNoticeUser-defined notice shown when reading a sealed likelihood; Bool_t_sealedIs test statistic sealed -- i.e. no access to data; Bool_tRooAbsReal::_selectComp! Component selection flag for RooAbsPdf::plotCompOn; RooRefCountListRooAbsArg::_serverListlist of server objects; Int_tRooAbsTestStatistic::_setNumPartition number of this instance in parallel calculation mode; Bool_tRooAbsArg::,MatchSource.WIKI,root/html602/RooAbsOptTestStatistic.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsOptTestStatistic.html
https://root.cern/root/html602/RooAbsOptTestStatistic.html:12917,Security,hash,hash,12917,"bsArg::findConstantNodes(const RooArgSet& observables, RooArgSet& cacheList); Bool_tRooAbsArg::findConstantNodes(const RooArgSet& observables, RooArgSet& cacheList, RooLinkedList& processedNodes); RooAbsArg*RooAbsArg::findNewServer(const RooAbsCollection& newSet, Bool_t nameChange) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; Double_tRooAbsReal::findRoot(RooRealVar& x, Double_t xmin, Double_t xmax, Double_t yval); RooAbsArg*RooAbsArg::findServer(const char* name) const; RooAbsArg*RooAbsArg::findServer(const RooAbsArg& arg) const; RooAbsArg*RooAbsArg::findServer(Int_t index) const; virtual voidRooAbsReal::fixAddCoefNormalization(const RooArgSet& addNormSet = RooArgSet(), Bool_t force = kTRUE); virtual voidRooAbsReal::fixAddCoefRange(const char* rangeName = 0, Bool_t force = kTRUE); static UInt_tRooAbsArg::fnv1a32(const char* data); static UInt_tRooAbsArg::fnv1a32(const char* data, ULong_t sz, UInt_t hash = fnv1a32start); static ULong64_tRooAbsArg::fnv1a64(const char* data); static ULong64_tRooAbsArg::fnv1a64(const char* data, ULong_t sz, ULong64_t hash = fnv1a64start); virtual Bool_tRooAbsReal::forceAnalyticalInt(const RooAbsArg&) const; virtual voidRooAbsReal::forceNumInt(Bool_t flag = kTRUE); RooAbsReal&function(); const RooAbsReal&function() const; RooFunctor*RooAbsReal::functor(const RooArgList& obs, const RooArgList& pars = RooArgList(), const RooArgSet& nset = RooArgSet()) const; virtual Int_tRooAbsReal::getAnalyticalIntegral(RooArgSet& allVars, RooArgSet& analVars, const char* rangeName = 0) const; virtual Int_tRooAbsReal::getAnalyticalIntegralWN(RooArgSet& allVars, RooArgSet& analVars, const RooArgSet* normSet, const char* rangeName = 0) const; Bool_tRooAbsArg::getAttribute(const Text_t* name) const; RooAbsCache*RooAbsArg::getCache(Int_t index) const; RooLinkedListRooAbsArg::getCloningAncestors() const; RooArgSet*RooAbsArg::getComponents() const; RooArgSet*RooAbsArg::getDepen",MatchSource.WIKI,root/html602/RooAbsOptTestStatistic.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsOptTestStatistic.html
https://root.cern/root/html602/RooAbsOptTestStatistic.html:13068,Security,hash,hash,13068,"t& cacheList, RooLinkedList& processedNodes); RooAbsArg*RooAbsArg::findNewServer(const RooAbsCollection& newSet, Bool_t nameChange) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; Double_tRooAbsReal::findRoot(RooRealVar& x, Double_t xmin, Double_t xmax, Double_t yval); RooAbsArg*RooAbsArg::findServer(const char* name) const; RooAbsArg*RooAbsArg::findServer(const RooAbsArg& arg) const; RooAbsArg*RooAbsArg::findServer(Int_t index) const; virtual voidRooAbsReal::fixAddCoefNormalization(const RooArgSet& addNormSet = RooArgSet(), Bool_t force = kTRUE); virtual voidRooAbsReal::fixAddCoefRange(const char* rangeName = 0, Bool_t force = kTRUE); static UInt_tRooAbsArg::fnv1a32(const char* data); static UInt_tRooAbsArg::fnv1a32(const char* data, ULong_t sz, UInt_t hash = fnv1a32start); static ULong64_tRooAbsArg::fnv1a64(const char* data); static ULong64_tRooAbsArg::fnv1a64(const char* data, ULong_t sz, ULong64_t hash = fnv1a64start); virtual Bool_tRooAbsReal::forceAnalyticalInt(const RooAbsArg&) const; virtual voidRooAbsReal::forceNumInt(Bool_t flag = kTRUE); RooAbsReal&function(); const RooAbsReal&function() const; RooFunctor*RooAbsReal::functor(const RooArgList& obs, const RooArgList& pars = RooArgList(), const RooArgSet& nset = RooArgSet()) const; virtual Int_tRooAbsReal::getAnalyticalIntegral(RooArgSet& allVars, RooArgSet& analVars, const char* rangeName = 0) const; virtual Int_tRooAbsReal::getAnalyticalIntegralWN(RooArgSet& allVars, RooArgSet& analVars, const RooArgSet* normSet, const char* rangeName = 0) const; Bool_tRooAbsArg::getAttribute(const Text_t* name) const; RooAbsCache*RooAbsArg::getCache(Int_t index) const; RooLinkedListRooAbsArg::getCloningAncestors() const; RooArgSet*RooAbsArg::getComponents() const; RooArgSet*RooAbsArg::getDependents(const RooArgSet& set) const; RooArgSet*RooAbsArg::getDependents(const RooAbsData* set) const; RooArgSet*RooAbsArg::getDependents(const RooArgSet*",MatchSource.WIKI,root/html602/RooAbsOptTestStatistic.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsOptTestStatistic.html
https://root.cern/root/html602/RooAbsOptTestStatistic.html:37430,Security,validat,validate,37430,,MatchSource.WIKI,root/html602/RooAbsOptTestStatistic.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsOptTestStatistic.html
https://root.cern/root/html602/RooAbsOptTestStatistic.html:38644,Security,access,access,38644,clientListlist of client objects; RooRefCountListRooAbsArg::_clientListShapesubset of clients that requested shape dirty flag propagation; RooRefCountListRooAbsArg::_clientListValuesubset of clients that requested value dirty flag propagation; TIterator*RooAbsArg::_clientShapeIter! Iterator over _clientListShape; TIterator*RooAbsArg::_clientValueIter! Iterator over _clientListValue; RooAbsData*RooAbsTestStatistic::_dataPointer to original input dataset; RooAbsData*_dataClonePointer to internal clone if input data; Bool_tRooAbsArg::_deleteWatch! Delete watch flag; Bool_tRooAbsTestStatistic::_doOffsetApply interval value offset to control numeric precision?; RooExpensiveObjectCache*RooAbsArg::_eocachePointer to global cache manager for any expensive components created by this object; Double_tRooAbsTestStatistic::_evalCarry! carry of Kahan sum in evaluatePartition; Int_tRooAbsTestStatistic::_extSet! Number of designated set to calculated extended term; Bool_tRooAbsArg::_fastAllow fast access mode in getVal() and proxies; Float_tRooAbsReal::_floatValue! Transient cache for floating point values from tree branches; Bool_tRooAbsReal::_forceNumIntForce numerical integration if flag set; RooAbsReal*RooAbsTestStatistic::_funcPointer to original input function; RooAbsReal*_funcClonePointer to internal clone of input function; RooArgSet*_funcCloneSetSet owning all components of internal clone of input function; RooArgSet*_funcObsSetList of observables in the pdf expression; static Bool_tRooAbsReal::_globalSelectCompGlobal activation switch for component selection; pRooAbsTestStatistic*RooAbsTestStatistic::_gofArray! Array of sub-contexts representing part of the combined test statistic; RooAbsTestStatistic::GOFOpModeRooAbsTestStatistic::_gofOpModeOperation mode of test statistic instance; vector<RooFit::MPSplit>RooAbsTestStatistic::_gofSplitMode! GOF MP Split mode specified by component (when Auto is active); static Bool_tRooAbsReal::_hideOffsetOffset hiding flag; static Bool_t,MatchSource.WIKI,root/html602/RooAbsOptTestStatistic.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsOptTestStatistic.html
https://root.cern/root/html602/RooAbsOptTestStatistic.html:42099,Security,access,access,42099,"meters of the test statistic (=parameters of the input function); Int_tRooAbsReal::_plotBinsNumber of plot bins; Double_tRooAbsReal::_plotMaxMaximum of plot range; Double_tRooAbsReal::_plotMinMinimum of plot range; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; RooArgSet*_projDepsSet of projected observable; const RooArgSet*RooAbsTestStatistic::_projDepsPointer to set with projected observables; RooRefArrayRooAbsArg::_proxyListlist of proxies; stringRooAbsTestStatistic::_rangeNameName of range in which to calculate test statistic; Char_tRooAbsReal::_sbyteValue! Transient cache for signed byte values from tree branches; TString_sealNoticeUser-defined notice shown when reading a sealed likelihood; Bool_t_sealedIs test statistic sealed -- i.e. no access to data; Bool_tRooAbsReal::_selectComp! Component selection flag for RooAbsPdf::plotCompOn; RooRefCountListRooAbsArg::_serverListlist of server objects; Int_tRooAbsTestStatistic::_setNumPartition number of this instance in parallel calculation mode; Bool_tRooAbsArg::_shapeDirtyFlag set if value needs recalculating because input shapes modified; Int_tRooAbsTestStatistic::_simCountTotal number of component p.d.f.s in RooSimultaneous (if any); RooNumIntConfig*RooAbsReal::_specIntegratorConfigNumeric integrator configuration specific for this object; Bool_tRooAbsTestStatistic::_splitRangeSplit rangeName in RooSimultaneous index labels if true; map<string,string>RooAbsArg::_stringAttribString attributes; Bool_tRooAbsReal::_treeVar!do not persist; UInt_tRooAbsReal::_uintValue! Transient cache for unsigned integer values from tree branches; TStringRooAbsReal::_unitUnit for objects value; Double_tRooAbsReal::_valueCache for current value of object; Bool_tRooAbsArg::_valueDirtyFlag set if value needs recalculating because input values modified; Bool_tRooAbsTestStatistic::_verboseVerbose messaging if true; static Bool_tRooAbsArg::_verboseDirtyStatic flag controlling verbose messaging for dir",MatchSource.WIKI,root/html602/RooAbsOptTestStatistic.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsOptTestStatistic.html
https://root.cern/root/html602/RooAbsOptTestStatistic.html:401,Testability,test,test,401,". RooAbsOptTestStatistic. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » ROOFIT; » ROOFITCORE; » RooAbsOptTestStatistic. class RooAbsOptTestStatistic: public RooAbsTestStatistic. RooAbsOptTestStatistic is the abstract base class for test; statistics objects that evaluate a function or PDF at each point of a given; dataset. This class provides generic optimizations, such as; caching and precalculation of constant terms that can be made for; all such quantities; Implementations should define evaluatePartition(), which calculates the; value of a (sub)range of the dataset and optionally combinedValue(),; which combines the values calculated for each partition. If combinedValue(); is not overloaded, the default implementation will add the partition results; to obtain the combined result; Support for calculation in partitions is needed to allow multi-core; parallelized calculation of test statistics; . Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~RooAbsOptTestStatistic(); voidTObject::AbstractMethod(const char* method) const; Bool_tRooAbsArg::addOwnedComponents(const RooArgSet& comps); voidRooAbsArg::addParameters(RooArgSet& params, const RooArgSet* nset = 0, Bool_t stripDisconnected = kTRUE) const; voidRooAbsArg::addServer(RooAbsArg& server, Bool_t valueProp = kTRUE, Bool_t shapeProp = kFALSE); voidRooAbsArg::addServerList(RooAbsCollection& serverList, Bool_t valueProp = kTRUE, Bool_t shapeProp = kFALSE); const char*RooAbsArg::aggregateCacheUniqueSuffix() const; virtual Double_tRooAbsReal::analyticalIntegral(Int_t code, const char* rangeName = 0) const; virtual Double_tRooAbsReal::analyticalIntegralWN(Int_t code, const RooArgSet* normSet, const char* rangeName = 0) const; virtua",MatchSource.WIKI,root/html602/RooAbsOptTestStatistic.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsOptTestStatistic.html
https://root.cern/root/html602/RooAbsOptTestStatistic.html:1059,Testability,test,test,1059,". RooAbsOptTestStatistic. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » ROOFIT; » ROOFITCORE; » RooAbsOptTestStatistic. class RooAbsOptTestStatistic: public RooAbsTestStatistic. RooAbsOptTestStatistic is the abstract base class for test; statistics objects that evaluate a function or PDF at each point of a given; dataset. This class provides generic optimizations, such as; caching and precalculation of constant terms that can be made for; all such quantities; Implementations should define evaluatePartition(), which calculates the; value of a (sub)range of the dataset and optionally combinedValue(),; which combines the values calculated for each partition. If combinedValue(); is not overloaded, the default implementation will add the partition results; to obtain the combined result; Support for calculation in partitions is needed to allow multi-core; parallelized calculation of test statistics; . Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~RooAbsOptTestStatistic(); voidTObject::AbstractMethod(const char* method) const; Bool_tRooAbsArg::addOwnedComponents(const RooArgSet& comps); voidRooAbsArg::addParameters(RooArgSet& params, const RooArgSet* nset = 0, Bool_t stripDisconnected = kTRUE) const; voidRooAbsArg::addServer(RooAbsArg& server, Bool_t valueProp = kTRUE, Bool_t shapeProp = kFALSE); voidRooAbsArg::addServerList(RooAbsCollection& serverList, Bool_t valueProp = kTRUE, Bool_t shapeProp = kFALSE); const char*RooAbsArg::aggregateCacheUniqueSuffix() const; virtual Double_tRooAbsReal::analyticalIntegral(Int_t code, const char* rangeName = 0) const; virtual Double_tRooAbsReal::analyticalIntegralWN(Int_t code, const RooArgSet* normSet, const char* rangeName = 0) const; virtua",MatchSource.WIKI,root/html602/RooAbsOptTestStatistic.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsOptTestStatistic.html
https://root.cern/root/html602/RooAbsOptTestStatistic.html:9783,Testability,test,testArg,9783,"& dependentVars, const RooArgSet* projectedVars, RooArgSet*& cloneSet, const char* rangeName = 0, const RooArgSet* condObs = 0) const; virtual RooAbsReal*RooAbsReal::createProfile(const RooArgSet& paramsOfInterest); RooAbsReal*RooAbsReal::createRunningIntegral(const RooArgSet& iset, const RooArgSet& nset = RooArgSet()); RooAbsReal*RooAbsReal::createRunningIntegral(const RooArgSet& iset, const RooCmdArg& arg1, const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()); RooAbsReal*RooAbsReal::createScanRI(const RooArgSet& iset, const RooArgSet& nset, Int_t numScanBins, Int_t intOrder); RooAbsData&data(); const RooAbsData&data() const; virtual Double_tRooAbsReal::defaultErrorLevel() const; static RooNumIntConfig*RooAbsReal::defaultIntegratorConfig(); virtual Int_tRooAbsArg::defaultPrintContents(Option_t* opt) const; static ostream&RooPrintable::defaultPrintStream(ostream* os = 0); virtual RooPrintable::StyleOptionRooPrintable::defaultPrintStyle(Option_t* opt) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; Bool_tRooAbsArg::dependentOverlaps(const RooAbsData* dset, const RooAbsArg& testArg) const; Bool_tRooAbsArg::dependentOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; Bool_tRooAbsArg::dependsOn(const RooAbsCollection& serverList, const RooAbsArg* ignoreArg = 0, Bool_t valueOnly = kFALSE) const; Bool_tRooAbsArg::dependsOn(const RooAbsArg& server, const RooAbsArg* ignoreArg = 0, Bool_t valueOnly = kFALSE) const; Bool_tRooAbsArg::dependsOnValue(const RooAbsCollection& serverList, const RooAbsArg* ignoreArg = 0) const; Bool_tRooAbsArg::dependsOnValue(const RooAbsArg& server, const RooAbsArg* ignoreArg = 0) const; RooDerivative*RooAbsReal::derivative(RooRealVar& obs, Int_t order = 1, Double_t eps = 0.",MatchSource.WIKI,root/html602/RooAbsOptTestStatistic.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsOptTestStatistic.html
https://root.cern/root/html602/RooAbsOptTestStatistic.html:9877,Testability,test,testArg,9877,"& dependentVars, const RooArgSet* projectedVars, RooArgSet*& cloneSet, const char* rangeName = 0, const RooArgSet* condObs = 0) const; virtual RooAbsReal*RooAbsReal::createProfile(const RooArgSet& paramsOfInterest); RooAbsReal*RooAbsReal::createRunningIntegral(const RooArgSet& iset, const RooArgSet& nset = RooArgSet()); RooAbsReal*RooAbsReal::createRunningIntegral(const RooArgSet& iset, const RooCmdArg& arg1, const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()); RooAbsReal*RooAbsReal::createScanRI(const RooArgSet& iset, const RooArgSet& nset, Int_t numScanBins, Int_t intOrder); RooAbsData&data(); const RooAbsData&data() const; virtual Double_tRooAbsReal::defaultErrorLevel() const; static RooNumIntConfig*RooAbsReal::defaultIntegratorConfig(); virtual Int_tRooAbsArg::defaultPrintContents(Option_t* opt) const; static ostream&RooPrintable::defaultPrintStream(ostream* os = 0); virtual RooPrintable::StyleOptionRooPrintable::defaultPrintStyle(Option_t* opt) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; Bool_tRooAbsArg::dependentOverlaps(const RooAbsData* dset, const RooAbsArg& testArg) const; Bool_tRooAbsArg::dependentOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; Bool_tRooAbsArg::dependsOn(const RooAbsCollection& serverList, const RooAbsArg* ignoreArg = 0, Bool_t valueOnly = kFALSE) const; Bool_tRooAbsArg::dependsOn(const RooAbsArg& server, const RooAbsArg* ignoreArg = 0, Bool_t valueOnly = kFALSE) const; Bool_tRooAbsArg::dependsOnValue(const RooAbsCollection& serverList, const RooAbsArg* ignoreArg = 0) const; Bool_tRooAbsArg::dependsOnValue(const RooAbsArg& server, const RooAbsArg* ignoreArg = 0) const; RooDerivative*RooAbsReal::derivative(RooRealVar& obs, Int_t order = 1, Double_t eps = 0.",MatchSource.WIKI,root/html602/RooAbsOptTestStatistic.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsOptTestStatistic.html
https://root.cern/root/html602/RooAbsOptTestStatistic.html:18582,Testability,log,logEvalError,18582,"sFolder() const; virtual Bool_tRooAbsArg::isFundamental() const; virtual Bool_tRooAbsReal::isIdentical(const RooAbsArg& other, Bool_t assumeSameType = kFALSE); virtual Bool_tRooAbsArg::isLValue() const; virtual Bool_tRooAbsTestStatistic::isOffsetting() const; Bool_tTObject::IsOnHeap() const; Bool_tisSealed() const; Bool_tRooAbsArg::isShapeDirty() const; Bool_tRooAbsArg::isShapeServer(const RooAbsArg& arg) const; Bool_tRooAbsArg::isShapeServer(const char* name) const; virtual Bool_tRooAbsArg::IsSortable() const; Bool_tRooAbsArg::isValueDirty() const; Bool_tRooAbsArg::isValueDirtyAndClear() const; Bool_tRooAbsArg::isValueOrShapeDirtyAndClear() const; Bool_tRooAbsArg::isValueServer(const RooAbsArg& arg) const; Bool_tRooAbsArg::isValueServer(const char* name) const; Bool_tTObject::IsZombie() const; voidRooAbsArg::leafNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t recurseNonDerived = kFALSE) const; Bool_tRooAbsArg::localNoDirtyInhibit() const; voidRooAbsReal::logEvalError(const char* message, const char* serverValueString = 0) const; static voidRooAbsReal::logEvalError(const RooAbsReal* originator, const char* origName, const char* message, const char* serverValueString = 0); virtual voidTNamed::ls(Option_t* option = """") const; virtual Double_tRooAbsReal::maxVal(Int_t code) const; voidTObject::MayNotUse(const char* method) const; RooAbsMoment*RooAbsReal::mean(RooRealVar& obs); RooAbsMoment*RooAbsReal::mean(RooRealVar& obs, const RooArgSet& nset); virtual Int_tRooAbsReal::minTrialSamples(const RooArgSet&) const; RooAbsMoment*RooAbsReal::moment(RooRealVar& obs, Int_t order, Bool_t central, Bool_t takeRoot); RooAbsMoment*RooAbsReal::moment(RooRealVar& obs, const RooArgSet& normObs, Int_t order, Bool_t central, Bool_t takeRoot, Bool_t intNormObs); static voidRooPrintable::nameFieldLength(Int_t newLen); const TNamed*RooAbsArg::namePtr() const; virtual Bool_tTObject::Notify(); Int_tRooAbsArg::numCaches() const; static Int_tRooAbsReal::numEvalErrorItems(",MatchSource.WIKI,root/html602/RooAbsOptTestStatistic.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsOptTestStatistic.html
https://root.cern/root/html602/RooAbsOptTestStatistic.html:18681,Testability,log,logEvalError,18681,"cal(const RooAbsArg& other, Bool_t assumeSameType = kFALSE); virtual Bool_tRooAbsArg::isLValue() const; virtual Bool_tRooAbsTestStatistic::isOffsetting() const; Bool_tTObject::IsOnHeap() const; Bool_tisSealed() const; Bool_tRooAbsArg::isShapeDirty() const; Bool_tRooAbsArg::isShapeServer(const RooAbsArg& arg) const; Bool_tRooAbsArg::isShapeServer(const char* name) const; virtual Bool_tRooAbsArg::IsSortable() const; Bool_tRooAbsArg::isValueDirty() const; Bool_tRooAbsArg::isValueDirtyAndClear() const; Bool_tRooAbsArg::isValueOrShapeDirtyAndClear() const; Bool_tRooAbsArg::isValueServer(const RooAbsArg& arg) const; Bool_tRooAbsArg::isValueServer(const char* name) const; Bool_tTObject::IsZombie() const; voidRooAbsArg::leafNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t recurseNonDerived = kFALSE) const; Bool_tRooAbsArg::localNoDirtyInhibit() const; voidRooAbsReal::logEvalError(const char* message, const char* serverValueString = 0) const; static voidRooAbsReal::logEvalError(const RooAbsReal* originator, const char* origName, const char* message, const char* serverValueString = 0); virtual voidTNamed::ls(Option_t* option = """") const; virtual Double_tRooAbsReal::maxVal(Int_t code) const; voidTObject::MayNotUse(const char* method) const; RooAbsMoment*RooAbsReal::mean(RooRealVar& obs); RooAbsMoment*RooAbsReal::mean(RooRealVar& obs, const RooArgSet& nset); virtual Int_tRooAbsReal::minTrialSamples(const RooArgSet&) const; RooAbsMoment*RooAbsReal::moment(RooRealVar& obs, Int_t order, Bool_t central, Bool_t takeRoot); RooAbsMoment*RooAbsReal::moment(RooRealVar& obs, const RooArgSet& normObs, Int_t order, Bool_t central, Bool_t takeRoot, Bool_t intNormObs); static voidRooPrintable::nameFieldLength(Int_t newLen); const TNamed*RooAbsArg::namePtr() const; virtual Bool_tTObject::Notify(); Int_tRooAbsArg::numCaches() const; static Int_tRooAbsReal::numEvalErrorItems(); static Int_tRooAbsReal::numEvalErrors(); Bool_tRooAbsArg::observableOverlaps(const RooAbsData* d",MatchSource.WIKI,root/html602/RooAbsOptTestStatistic.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsOptTestStatistic.html
https://root.cern/root/html602/RooAbsOptTestStatistic.html:19710,Testability,test,testArg,19710,"iginator, const char* origName, const char* message, const char* serverValueString = 0); virtual voidTNamed::ls(Option_t* option = """") const; virtual Double_tRooAbsReal::maxVal(Int_t code) const; voidTObject::MayNotUse(const char* method) const; RooAbsMoment*RooAbsReal::mean(RooRealVar& obs); RooAbsMoment*RooAbsReal::mean(RooRealVar& obs, const RooArgSet& nset); virtual Int_tRooAbsReal::minTrialSamples(const RooArgSet&) const; RooAbsMoment*RooAbsReal::moment(RooRealVar& obs, Int_t order, Bool_t central, Bool_t takeRoot); RooAbsMoment*RooAbsReal::moment(RooRealVar& obs, const RooArgSet& normObs, Int_t order, Bool_t central, Bool_t takeRoot, Bool_t intNormObs); static voidRooPrintable::nameFieldLength(Int_t newLen); const TNamed*RooAbsArg::namePtr() const; virtual Bool_tTObject::Notify(); Int_tRooAbsArg::numCaches() const; static Int_tRooAbsReal::numEvalErrorItems(); static Int_tRooAbsReal::numEvalErrors(); Bool_tRooAbsArg::observableOverlaps(const RooAbsData* dset, const RooAbsArg& testArg) const; Bool_tRooAbsArg::observableOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; virtual Double_tRooAbsTestStatistic::offset() const; virtual Double_tRooAbsTestStatistic::offsetCarry() const; voidTObject::operator delete(void* ptr); voidTObject::operator delete(void* ptr, void* vp); voidTObject::operator delete[](void* ptr); voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); RooAbsOptTestStatistic&operator=(const RooAbsOptTestStatistic&); Bool_tRooAbsReal::operator==(Double_t value) const; virtual Bool_tRooAbsReal::operator==(const RooAbsArg& other); virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables); virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& obser",MatchSource.WIKI,root/html602/RooAbsOptTestStatistic.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsOptTestStatistic.html
https://root.cern/root/html602/RooAbsOptTestStatistic.html:19805,Testability,test,testArg,19805,"l voidTNamed::ls(Option_t* option = """") const; virtual Double_tRooAbsReal::maxVal(Int_t code) const; voidTObject::MayNotUse(const char* method) const; RooAbsMoment*RooAbsReal::mean(RooRealVar& obs); RooAbsMoment*RooAbsReal::mean(RooRealVar& obs, const RooArgSet& nset); virtual Int_tRooAbsReal::minTrialSamples(const RooArgSet&) const; RooAbsMoment*RooAbsReal::moment(RooRealVar& obs, Int_t order, Bool_t central, Bool_t takeRoot); RooAbsMoment*RooAbsReal::moment(RooRealVar& obs, const RooArgSet& normObs, Int_t order, Bool_t central, Bool_t takeRoot, Bool_t intNormObs); static voidRooPrintable::nameFieldLength(Int_t newLen); const TNamed*RooAbsArg::namePtr() const; virtual Bool_tTObject::Notify(); Int_tRooAbsArg::numCaches() const; static Int_tRooAbsReal::numEvalErrorItems(); static Int_tRooAbsReal::numEvalErrors(); Bool_tRooAbsArg::observableOverlaps(const RooAbsData* dset, const RooAbsArg& testArg) const; Bool_tRooAbsArg::observableOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; virtual Double_tRooAbsTestStatistic::offset() const; virtual Double_tRooAbsTestStatistic::offsetCarry() const; voidTObject::operator delete(void* ptr); voidTObject::operator delete(void* ptr, void* vp); voidTObject::operator delete[](void* ptr); voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); RooAbsOptTestStatistic&operator=(const RooAbsOptTestStatistic&); Bool_tRooAbsReal::operator==(Double_t value) const; virtual Bool_tRooAbsReal::operator==(const RooAbsArg& other); virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables); virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables, RooArgSet& optNodes, RooLinkedList& processedNodes); Bool_tRooAbsArg::overlaps(const Ro",MatchSource.WIKI,root/html602/RooAbsOptTestStatistic.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsOptTestStatistic.html
https://root.cern/root/html602/RooAbsOptTestStatistic.html:20818,Testability,test,testArg,20818," testArg) const; Bool_tRooAbsArg::observableOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; virtual Double_tRooAbsTestStatistic::offset() const; virtual Double_tRooAbsTestStatistic::offsetCarry() const; voidTObject::operator delete(void* ptr); voidTObject::operator delete(void* ptr, void* vp); voidTObject::operator delete[](void* ptr); voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); RooAbsOptTestStatistic&operator=(const RooAbsOptTestStatistic&); Bool_tRooAbsReal::operator==(Double_t value) const; virtual Bool_tRooAbsReal::operator==(const RooAbsArg& other); virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables); virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables, RooArgSet& optNodes, RooLinkedList& processedNodes); Bool_tRooAbsArg::overlaps(const RooAbsArg& testArg, Bool_t valueOnly = kFALSE) const; const RooArgSet*RooAbsArg::ownedComponents() const; virtual voidTObject::Paint(Option_t* option = """"); virtual RooPlot*RooAbsReal::plotOn(RooPlot* frame, RooLinkedList& cmdList) const; virtual RooPlot*RooAbsReal::plotOn(RooPlot* frame, const RooCmdArg& arg1 = RooCmdArg(), const RooCmdArg& arg2 = RooCmdArg(), const RooCmdArg& arg3 = RooCmdArg(), const RooCmdArg& arg4 = RooCmdArg(), const RooCmdArg& arg5 = RooCmdArg(), const RooCmdArg& arg6 = RooCmdArg(), const RooCmdArg& arg7 = RooCmdArg(), const RooCmdArg& arg8 = RooCmdArg(), const RooCmdArg& arg9 = RooCmdArg(), const RooCmdArg& arg10 = RooCmdArg()) const; virtual list<Double_t>*RooAbsReal::plotSamplingHint(RooAbsRealLValue&, Double_t, Double_t) const; virtual RooPlot*RooAbsReal::plotSliceOn(RooPlot* frame, const RooArgSet& sliceSet, Option_t* drawOptions = ""L"", Double_t scaleFactor = 1.",MatchSource.WIKI,root/html602/RooAbsOptTestStatistic.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsOptTestStatistic.html
https://root.cern/root/html602/RooAbsOptTestStatistic.html:39336,Testability,test,test,39336,oAbsArg::_eocachePointer to global cache manager for any expensive components created by this object; Double_tRooAbsTestStatistic::_evalCarry! carry of Kahan sum in evaluatePartition; Int_tRooAbsTestStatistic::_extSet! Number of designated set to calculated extended term; Bool_tRooAbsArg::_fastAllow fast access mode in getVal() and proxies; Float_tRooAbsReal::_floatValue! Transient cache for floating point values from tree branches; Bool_tRooAbsReal::_forceNumIntForce numerical integration if flag set; RooAbsReal*RooAbsTestStatistic::_funcPointer to original input function; RooAbsReal*_funcClonePointer to internal clone of input function; RooArgSet*_funcCloneSetSet owning all components of internal clone of input function; RooArgSet*_funcObsSetList of observables in the pdf expression; static Bool_tRooAbsReal::_globalSelectCompGlobal activation switch for component selection; pRooAbsTestStatistic*RooAbsTestStatistic::_gofArray! Array of sub-contexts representing part of the combined test statistic; RooAbsTestStatistic::GOFOpModeRooAbsTestStatistic::_gofOpModeOperation mode of test statistic instance; vector<RooFit::MPSplit>RooAbsTestStatistic::_gofSplitMode! GOF MP Split mode specified by component (when Auto is active); static Bool_tRooAbsReal::_hideOffsetOffset hiding flag; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; Bool_tRooAbsTestStatistic::_init! Is object initialized; Int_tRooAbsReal::_intValue! Transient cache for integer values from tree branches; Bool_tRooAbsArg::_isConstant! Cached isConstant status; TStringRooAbsReal::_labelPlot label for objects value; RooArgSet*RooAbsReal::_lastNSet!; Bool_tRooAbsArg::_localNoInhibitDirty! Prevent 'AlwaysDirty' mode for this node; pRooRealMPFE*RooAbsTestStatistic::_mpfeArray! Array of parallel execution frond ends; RooFit::MPSplitRooAbsTestStatistic::_mpinterlUse interleaving strategy rather than N-wise split for partioning of dataset for multiprocessor-split; ,MatchSource.WIKI,root/html602/RooAbsOptTestStatistic.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsOptTestStatistic.html
https://root.cern/root/html602/RooAbsOptTestStatistic.html:39431,Testability,test,test,39431,bject; Double_tRooAbsTestStatistic::_evalCarry! carry of Kahan sum in evaluatePartition; Int_tRooAbsTestStatistic::_extSet! Number of designated set to calculated extended term; Bool_tRooAbsArg::_fastAllow fast access mode in getVal() and proxies; Float_tRooAbsReal::_floatValue! Transient cache for floating point values from tree branches; Bool_tRooAbsReal::_forceNumIntForce numerical integration if flag set; RooAbsReal*RooAbsTestStatistic::_funcPointer to original input function; RooAbsReal*_funcClonePointer to internal clone of input function; RooArgSet*_funcCloneSetSet owning all components of internal clone of input function; RooArgSet*_funcObsSetList of observables in the pdf expression; static Bool_tRooAbsReal::_globalSelectCompGlobal activation switch for component selection; pRooAbsTestStatistic*RooAbsTestStatistic::_gofArray! Array of sub-contexts representing part of the combined test statistic; RooAbsTestStatistic::GOFOpModeRooAbsTestStatistic::_gofOpModeOperation mode of test statistic instance; vector<RooFit::MPSplit>RooAbsTestStatistic::_gofSplitMode! GOF MP Split mode specified by component (when Auto is active); static Bool_tRooAbsReal::_hideOffsetOffset hiding flag; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; Bool_tRooAbsTestStatistic::_init! Is object initialized; Int_tRooAbsReal::_intValue! Transient cache for integer values from tree branches; Bool_tRooAbsArg::_isConstant! Cached isConstant status; TStringRooAbsReal::_labelPlot label for objects value; RooArgSet*RooAbsReal::_lastNSet!; Bool_tRooAbsArg::_localNoInhibitDirty! Prevent 'AlwaysDirty' mode for this node; pRooRealMPFE*RooAbsTestStatistic::_mpfeArray! Array of parallel execution frond ends; RooFit::MPSplitRooAbsTestStatistic::_mpinterlUse interleaving strategy rather than N-wise split for partioning of dataset for multiprocessor-split; Int_tRooAbsTestStatistic::_nCPUNumber of processors to use in parallel calculation mode; Int_tR,MatchSource.WIKI,root/html602/RooAbsOptTestStatistic.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsOptTestStatistic.html
https://root.cern/root/html602/RooAbsOptTestStatistic.html:40488,Testability,test,test,40488,ode in getVal() and proxies; Float_tRooAbsReal::_floatValue! Transient cache for floating point values from tree branches; Bool_tRooAbsReal::_forceNumIntForce numerical integration if flag set; RooAbsReal*RooAbsTestStatistic::_funcPointer to original input function; RooAbsReal*_funcClonePointer to internal clone of input function; RooArgSet*_funcCloneSetSet owning all components of internal clone of input function; RooArgSet*_funcObsSetList of observables in the pdf expression; static Bool_tRooAbsReal::_globalSelectCompGlobal activation switch for component selection; pRooAbsTestStatistic*RooAbsTestStatistic::_gofArray! Array of sub-contexts representing part of the combined test statistic; RooAbsTestStatistic::GOFOpModeRooAbsTestStatistic::_gofOpModeOperation mode of test statistic instance; vector<RooFit::MPSplit>RooAbsTestStatistic::_gofSplitMode! GOF MP Split mode specified by component (when Auto is active); static Bool_tRooAbsReal::_hideOffsetOffset hiding flag; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; Bool_tRooAbsTestStatistic::_init! Is object initialized; Int_tRooAbsReal::_intValue! Transient cache for integer values from tree branches; Bool_tRooAbsArg::_isConstant! Cached isConstant status; TStringRooAbsReal::_labelPlot label for objects value; RooArgSet*RooAbsReal::_lastNSet!; Bool_tRooAbsArg::_localNoInhibitDirty! Prevent 'AlwaysDirty' mode for this node; pRooRealMPFE*RooAbsTestStatistic::_mpfeArray! Array of parallel execution frond ends; RooFit::MPSplitRooAbsTestStatistic::_mpinterlUse interleaving strategy rather than N-wise split for partioning of dataset for multiprocessor-split; Int_tRooAbsTestStatistic::_nCPUNumber of processors to use in parallel calculation mode; Int_tRooAbsTestStatistic::_nEventsTotal number of events in test statistic calculation; Int_tRooAbsTestStatistic::_nGofNumber of sub-contexts; static Int_tRooPrintable::_nameLength; TNamed*RooAbsArg::_namePtr! Do not persist.,MatchSource.WIKI,root/html602/RooAbsOptTestStatistic.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsOptTestStatistic.html
https://root.cern/root/html602/RooAbsOptTestStatistic.html:41319,Testability,test,test,41319,ber of processors to use in parallel calculation mode; Int_tRooAbsTestStatistic::_nEventsTotal number of events in test statistic calculation; Int_tRooAbsTestStatistic::_nGofNumber of sub-contexts; static Int_tRooPrintable::_nameLength; TNamed*RooAbsArg::_namePtr! Do not persist. Pointer to global instance of string that matches object named; RooArgSet*_normSetPointer to set with observables used for normalization; Int_tRooAbsTestStatistic::_numSetsTotal number of partitions in parallel calculation mode; Double_tRooAbsTestStatistic::_offset! Offset; Double_tRooAbsTestStatistic::_offsetCarry! avoids loss of precision; RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; Bool_t_optimized!; RooAbsData*_origDataOriginal data; RooAbsReal*_origFuncOriginal function; Bool_t_ownDataDo we own the dataset; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; RooSetProxyRooAbsTestStatistic::_paramSetParameters of the test statistic (=parameters of the input function); Int_tRooAbsReal::_plotBinsNumber of plot bins; Double_tRooAbsReal::_plotMaxMaximum of plot range; Double_tRooAbsReal::_plotMinMinimum of plot range; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; RooArgSet*_projDepsSet of projected observable; const RooArgSet*RooAbsTestStatistic::_projDepsPointer to set with projected observables; RooRefArrayRooAbsArg::_proxyListlist of proxies; stringRooAbsTestStatistic::_rangeNameName of range in which to calculate test statistic; Char_tRooAbsReal::_sbyteValue! Transient cache for signed byte values from tree branches; TString_sealNoticeUser-defined notice shown when reading a sealed likelihood; Bool_t_sealedIs test statistic sealed -- i.e. no access to data; Bool_tRooAbsReal::_selectComp! Component selection flag for RooAbsPdf::plotCompOn; RooRefCountListRooAbsArg::_serverListlist of server objects; Int_tRooAbsTestStatistic::_setNumPartition number of this instance in parallel calculation mode; Bool_tRooAbsArg::,MatchSource.WIKI,root/html602/RooAbsOptTestStatistic.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsOptTestStatistic.html
https://root.cern/root/html602/RooAbsOptTestStatistic.html:41866,Testability,test,test,41866,ber of processors to use in parallel calculation mode; Int_tRooAbsTestStatistic::_nEventsTotal number of events in test statistic calculation; Int_tRooAbsTestStatistic::_nGofNumber of sub-contexts; static Int_tRooPrintable::_nameLength; TNamed*RooAbsArg::_namePtr! Do not persist. Pointer to global instance of string that matches object named; RooArgSet*_normSetPointer to set with observables used for normalization; Int_tRooAbsTestStatistic::_numSetsTotal number of partitions in parallel calculation mode; Double_tRooAbsTestStatistic::_offset! Offset; Double_tRooAbsTestStatistic::_offsetCarry! avoids loss of precision; RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; Bool_t_optimized!; RooAbsData*_origDataOriginal data; RooAbsReal*_origFuncOriginal function; Bool_t_ownDataDo we own the dataset; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; RooSetProxyRooAbsTestStatistic::_paramSetParameters of the test statistic (=parameters of the input function); Int_tRooAbsReal::_plotBinsNumber of plot bins; Double_tRooAbsReal::_plotMaxMaximum of plot range; Double_tRooAbsReal::_plotMinMinimum of plot range; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; RooArgSet*_projDepsSet of projected observable; const RooArgSet*RooAbsTestStatistic::_projDepsPointer to set with projected observables; RooRefArrayRooAbsArg::_proxyListlist of proxies; stringRooAbsTestStatistic::_rangeNameName of range in which to calculate test statistic; Char_tRooAbsReal::_sbyteValue! Transient cache for signed byte values from tree branches; TString_sealNoticeUser-defined notice shown when reading a sealed likelihood; Bool_t_sealedIs test statistic sealed -- i.e. no access to data; Bool_tRooAbsReal::_selectComp! Component selection flag for RooAbsPdf::plotCompOn; RooRefCountListRooAbsArg::_serverListlist of server objects; Int_tRooAbsTestStatistic::_setNumPartition number of this instance in parallel calculation mode; Bool_tRooAbsArg::,MatchSource.WIKI,root/html602/RooAbsOptTestStatistic.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsOptTestStatistic.html
https://root.cern/root/html602/RooAbsOptTestStatistic.html:42066,Testability,test,test,42066,ber of processors to use in parallel calculation mode; Int_tRooAbsTestStatistic::_nEventsTotal number of events in test statistic calculation; Int_tRooAbsTestStatistic::_nGofNumber of sub-contexts; static Int_tRooPrintable::_nameLength; TNamed*RooAbsArg::_namePtr! Do not persist. Pointer to global instance of string that matches object named; RooArgSet*_normSetPointer to set with observables used for normalization; Int_tRooAbsTestStatistic::_numSetsTotal number of partitions in parallel calculation mode; Double_tRooAbsTestStatistic::_offset! Offset; Double_tRooAbsTestStatistic::_offsetCarry! avoids loss of precision; RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; Bool_t_optimized!; RooAbsData*_origDataOriginal data; RooAbsReal*_origFuncOriginal function; Bool_t_ownDataDo we own the dataset; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; RooSetProxyRooAbsTestStatistic::_paramSetParameters of the test statistic (=parameters of the input function); Int_tRooAbsReal::_plotBinsNumber of plot bins; Double_tRooAbsReal::_plotMaxMaximum of plot range; Double_tRooAbsReal::_plotMinMinimum of plot range; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; RooArgSet*_projDepsSet of projected observable; const RooArgSet*RooAbsTestStatistic::_projDepsPointer to set with projected observables; RooRefArrayRooAbsArg::_proxyListlist of proxies; stringRooAbsTestStatistic::_rangeNameName of range in which to calculate test statistic; Char_tRooAbsReal::_sbyteValue! Transient cache for signed byte values from tree branches; TString_sealNoticeUser-defined notice shown when reading a sealed likelihood; Bool_t_sealedIs test statistic sealed -- i.e. no access to data; Bool_tRooAbsReal::_selectComp! Component selection flag for RooAbsPdf::plotCompOn; RooRefCountListRooAbsArg::_serverListlist of server objects; Int_tRooAbsTestStatistic::_setNumPartition number of this instance in parallel calculation mode; Bool_tRooAbsArg::,MatchSource.WIKI,root/html602/RooAbsOptTestStatistic.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsOptTestStatistic.html
https://root.cern/root/html602/RooAbsOptTestStatistic.html:44015,Testability,test,test,44015,"r objects value; Double_tRooAbsReal::_valueCache for current value of object; Bool_tRooAbsArg::_valueDirtyFlag set if value needs recalculating because input values modified; Bool_tRooAbsTestStatistic::_verboseVerbose messaging if true; static Bool_tRooAbsArg::_verboseDirtyStatic flag controlling verbose messaging for dirty state changes; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; RooAbsOptTestStatistic(const char* name, const char* title, RooAbsReal& real, RooAbsData& data, const RooArgSet& projDeps, const char* rangeName = 0, const char* addCoefRangeName = 0, Int_t nCPU = 1, RooFit::MPSplit interleave = RooFit::BulkPartition, Bool_t verbose = kTRUE, Bool_t splitCutRange = kFALSE, Bool_t cloneInputData = kTRUE); Constructor taking function (real), a dataset (data), a set of projected observables (projSet). If; rangeName is not null, only events in the dataset inside the range will be used in the test; statistic calculation. If addCoefRangeName is not null, all RooAddPdf component of 'real' will be; instructed to fix their fraction definitions to the given named range. If nCPU is greater than; 1 the test statistic calculation will be paralellized over multiple processes. By default the data; is split with 'bulk' partitioning (each process calculates a contigious block of fraction 1/nCPU; of the data). For binned data this approach may be suboptimal as the number of bins with >0 entries; in each processing block many vary greatly thereby distributing the workload rather unevenly.; If interleave is set to true, the interleave partitioning strategy is used where each partition; i takes all bins for which (ibin % ncpu == i) which is more likely to result in an even workload.; If splitCutRange is true, a different rangeName constructed as rangeName_{catName} will be used; as range definition for each index state of a RooSimultaneous. RooAbsOptTestStat",MatchSource.WIKI,root/html602/RooAbsOptTestStatistic.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsOptTestStatistic.html
https://root.cern/root/html602/RooAbsOptTestStatistic.html:44222,Testability,test,test,44222,"::_verboseDirtyStatic flag controlling verbose messaging for dirty state changes; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; RooAbsOptTestStatistic(const char* name, const char* title, RooAbsReal& real, RooAbsData& data, const RooArgSet& projDeps, const char* rangeName = 0, const char* addCoefRangeName = 0, Int_t nCPU = 1, RooFit::MPSplit interleave = RooFit::BulkPartition, Bool_t verbose = kTRUE, Bool_t splitCutRange = kFALSE, Bool_t cloneInputData = kTRUE); Constructor taking function (real), a dataset (data), a set of projected observables (projSet). If; rangeName is not null, only events in the dataset inside the range will be used in the test; statistic calculation. If addCoefRangeName is not null, all RooAddPdf component of 'real' will be; instructed to fix their fraction definitions to the given named range. If nCPU is greater than; 1 the test statistic calculation will be paralellized over multiple processes. By default the data; is split with 'bulk' partitioning (each process calculates a contigious block of fraction 1/nCPU; of the data). For binned data this approach may be suboptimal as the number of bins with >0 entries; in each processing block many vary greatly thereby distributing the workload rather unevenly.; If interleave is set to true, the interleave partitioning strategy is used where each partition; i takes all bins for which (ibin % ncpu == i) which is more likely to result in an even workload.; If splitCutRange is true, a different rangeName constructed as rangeName_{catName} will be used; as range definition for each index state of a RooSimultaneous. RooAbsOptTestStatistic(const RooAbsOptTestStatistic& other, const char* name = 0); Copy constructor. void initSlave(RooAbsReal& real, RooAbsData& indata, const RooArgSet& projDeps, const char* rangeName, const char* addCoefRangeName). ~RooAbsOptTestStatistic(); Destructor. Do",MatchSource.WIKI,root/html602/RooAbsOptTestStatistic.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsOptTestStatistic.html
https://root.cern/root/html602/RooAbsOptTestStatistic.html:45324,Testability,test,test,45324," split with 'bulk' partitioning (each process calculates a contigious block of fraction 1/nCPU; of the data). For binned data this approach may be suboptimal as the number of bins with >0 entries; in each processing block many vary greatly thereby distributing the workload rather unevenly.; If interleave is set to true, the interleave partitioning strategy is used where each partition; i takes all bins for which (ibin % ncpu == i) which is more likely to result in an even workload.; If splitCutRange is true, a different rangeName constructed as rangeName_{catName} will be used; as range definition for each index state of a RooSimultaneous. RooAbsOptTestStatistic(const RooAbsOptTestStatistic& other, const char* name = 0); Copy constructor. void initSlave(RooAbsReal& real, RooAbsData& indata, const RooArgSet& projDeps, const char* rangeName, const char* addCoefRangeName). ~RooAbsOptTestStatistic(); Destructor. Double_t combinedValue(RooAbsReal** gofArray, Int_t nVal) const; Method to combined test statistic results calculated into partitions into; the global result. This default implementation adds the partition return; values. Bool_t redirectServersHook(const RooAbsCollection& newServerList, Bool_t mustReplaceAll, Bool_t nameChange, Bool_t isRecursive); Catch server redirect calls and forward to internal clone of function. void printCompactTreeHook(ostream& os, const char* indent = """"); Catch print hook function and forward to function clone. void constOptimizeTestStatistic(RooAbsArg::ConstOpCode opcode, Bool_t doAlsoTrackingOpt = kTRUE); Driver function to propagate constant term optimizations in test statistic.; If code Activate is sent, constant term optimization will be executed.; If code Deacivate is sent, any existing constant term optimizations will; be abanoned. If codes ConfigChange or ValueChange are sent, any existing; constant term optimizations will be redone. void optimizeCaching(); This method changes the value caching logic for all nodes that depends o",MatchSource.WIKI,root/html602/RooAbsOptTestStatistic.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsOptTestStatistic.html
https://root.cern/root/html602/RooAbsOptTestStatistic.html:45942,Testability,test,test,45942,"angeName_{catName} will be used; as range definition for each index state of a RooSimultaneous. RooAbsOptTestStatistic(const RooAbsOptTestStatistic& other, const char* name = 0); Copy constructor. void initSlave(RooAbsReal& real, RooAbsData& indata, const RooArgSet& projDeps, const char* rangeName, const char* addCoefRangeName). ~RooAbsOptTestStatistic(); Destructor. Double_t combinedValue(RooAbsReal** gofArray, Int_t nVal) const; Method to combined test statistic results calculated into partitions into; the global result. This default implementation adds the partition return; values. Bool_t redirectServersHook(const RooAbsCollection& newServerList, Bool_t mustReplaceAll, Bool_t nameChange, Bool_t isRecursive); Catch server redirect calls and forward to internal clone of function. void printCompactTreeHook(ostream& os, const char* indent = """"); Catch print hook function and forward to function clone. void constOptimizeTestStatistic(RooAbsArg::ConstOpCode opcode, Bool_t doAlsoTrackingOpt = kTRUE); Driver function to propagate constant term optimizations in test statistic.; If code Activate is sent, constant term optimization will be executed.; If code Deacivate is sent, any existing constant term optimizations will; be abanoned. If codes ConfigChange or ValueChange are sent, any existing; constant term optimizations will be redone. void optimizeCaching(); This method changes the value caching logic for all nodes that depends on any of the observables; as defined by the given dataset. When evaluating a test statistic constructed from the RooAbsReal; with a dataset the observables are guaranteed to change with every call, thus there is no point; in tracking these changes which result in a net overhead. Thus for observable-dependent nodes,; the evaluation mechanism is changed from being dependent on a 'valueDirty' flag to guaranteed evaluation.; On the dataset side, the observables objects are modified to no longer send valueDirty messages; to their client. void optimiz",MatchSource.WIKI,root/html602/RooAbsOptTestStatistic.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsOptTestStatistic.html
https://root.cern/root/html602/RooAbsOptTestStatistic.html:46285,Testability,log,logic,46285,"onst; Method to combined test statistic results calculated into partitions into; the global result. This default implementation adds the partition return; values. Bool_t redirectServersHook(const RooAbsCollection& newServerList, Bool_t mustReplaceAll, Bool_t nameChange, Bool_t isRecursive); Catch server redirect calls and forward to internal clone of function. void printCompactTreeHook(ostream& os, const char* indent = """"); Catch print hook function and forward to function clone. void constOptimizeTestStatistic(RooAbsArg::ConstOpCode opcode, Bool_t doAlsoTrackingOpt = kTRUE); Driver function to propagate constant term optimizations in test statistic.; If code Activate is sent, constant term optimization will be executed.; If code Deacivate is sent, any existing constant term optimizations will; be abanoned. If codes ConfigChange or ValueChange are sent, any existing; constant term optimizations will be redone. void optimizeCaching(); This method changes the value caching logic for all nodes that depends on any of the observables; as defined by the given dataset. When evaluating a test statistic constructed from the RooAbsReal; with a dataset the observables are guaranteed to change with every call, thus there is no point; in tracking these changes which result in a net overhead. Thus for observable-dependent nodes,; the evaluation mechanism is changed from being dependent on a 'valueDirty' flag to guaranteed evaluation.; On the dataset side, the observables objects are modified to no longer send valueDirty messages; to their client. void optimizeConstantTerms(Bool_t , Bool_t = kTRUE); Driver function to activate global constant term optimization.; If activated constant terms are found and cached with the dataset; The operation mode of cached nodes is set to AClean meaning that; their getVal() call will never result in an evaluate call.; Finally the branches in the dataset that correspond to observables; that are exclusively used in constant terms are disabled as; the",MatchSource.WIKI,root/html602/RooAbsOptTestStatistic.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsOptTestStatistic.html
https://root.cern/root/html602/RooAbsOptTestStatistic.html:46396,Testability,test,test,46396,"k(const RooAbsCollection& newServerList, Bool_t mustReplaceAll, Bool_t nameChange, Bool_t isRecursive); Catch server redirect calls and forward to internal clone of function. void printCompactTreeHook(ostream& os, const char* indent = """"); Catch print hook function and forward to function clone. void constOptimizeTestStatistic(RooAbsArg::ConstOpCode opcode, Bool_t doAlsoTrackingOpt = kTRUE); Driver function to propagate constant term optimizations in test statistic.; If code Activate is sent, constant term optimization will be executed.; If code Deacivate is sent, any existing constant term optimizations will; be abanoned. If codes ConfigChange or ValueChange are sent, any existing; constant term optimizations will be redone. void optimizeCaching(); This method changes the value caching logic for all nodes that depends on any of the observables; as defined by the given dataset. When evaluating a test statistic constructed from the RooAbsReal; with a dataset the observables are guaranteed to change with every call, thus there is no point; in tracking these changes which result in a net overhead. Thus for observable-dependent nodes,; the evaluation mechanism is changed from being dependent on a 'valueDirty' flag to guaranteed evaluation.; On the dataset side, the observables objects are modified to no longer send valueDirty messages; to their client. void optimizeConstantTerms(Bool_t , Bool_t = kTRUE); Driver function to activate global constant term optimization.; If activated constant terms are found and cached with the dataset; The operation mode of cached nodes is set to AClean meaning that; their getVal() call will never result in an evaluate call.; Finally the branches in the dataset that correspond to observables; that are exclusively used in constant terms are disabled as; they serve no more purpose. Bool_t setDataSlave(RooAbsData& data, Bool_t cloneData = kTRUE, Bool_t ownNewDataAnyway = kFALSE); cout << ""RAOTS::setDataSlave("" << this << "") START"" << endl ;; C",MatchSource.WIKI,root/html602/RooAbsOptTestStatistic.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsOptTestStatistic.html
https://root.cern/root/html602/RooAbsOptTestStatistic.html:47601,Testability,test,test,47601,"changed from being dependent on a 'valueDirty' flag to guaranteed evaluation.; On the dataset side, the observables objects are modified to no longer send valueDirty messages; to their client. void optimizeConstantTerms(Bool_t , Bool_t = kTRUE); Driver function to activate global constant term optimization.; If activated constant terms are found and cached with the dataset; The operation mode of cached nodes is set to AClean meaning that; their getVal() call will never result in an evaluate call.; Finally the branches in the dataset that correspond to observables; that are exclusively used in constant terms are disabled as; they serve no more purpose. Bool_t setDataSlave(RooAbsData& data, Bool_t cloneData = kTRUE, Bool_t ownNewDataAnyway = kFALSE); cout << ""RAOTS::setDataSlave("" << this << "") START"" << endl ;; Change dataset that is used to given one. If cloneData is kTRUE, a clone of; in the input dataset is made. If the test statistic was constructed with; a range specification on the data, the cloneData argument is ignore and; the data is always cloned. RooAbsData& data(). const RooAbsData& data() const. RooAbsOptTestStatistic(); Constructors, assignment etc. RooAbsReal& function(); { return *_funcClone ; }. const RooAbsReal& function() const; { return *_funcClone ; }. const char* cacheUniqueSuffix() const; { return Form(""_%lx"", (ULong_t)_dataClone) ; }. Bool_t isDerived() const; Override this to be always true to force calculation of likelihood without parameters. { return kTRUE ; }. void seal(const char* notice = """"); { _sealed = kTRUE ; _sealNotice = notice ; }. Bool_t isSealed() const; { return _sealed ; }. const char* sealNotice() const; { return _sealNotice.Data() ; }. Bool_t allowFunctionCache(); { return kTRUE ; }. RooArgSet requiredExtraObservables() const; { return RooArgSet() ; }. » Last changed: Tue Jun 30 14:30:16 2015 » Last generated: 2015-06-30 14:30; This page has been automatically generated. For comments or suggestions regarding the documentati",MatchSource.WIKI,root/html602/RooAbsOptTestStatistic.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsOptTestStatistic.html
https://root.cern/root/html602/RooAbsOptTestStatistic.html:4196,Usability,clear,clearEvalErrorLog,4196,", const RooLinkedList& cmdList); virtual RooFitResult*RooAbsReal::chi2FitTo(RooDataHist& data, const RooCmdArg& arg1 = RooCmdArg::none(), const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()); virtual RooFitResult*RooAbsReal::chi2FitTo(RooDataSet& xydata, const RooCmdArg& arg1 = RooCmdArg::none(), const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); static voidRooAbsReal::clearEvalErrorLog(); voidRooAbsArg::clearShapeDirty() const; voidRooAbsArg::clearValueAndShapeDirty() const; voidRooAbsArg::clearValueDirty() const; TIterator*RooAbsArg::clientIterator() const; virtual TObject*RooAbsArg::clone(const char* newname = 0) const; virtual TObject*RooAbsArg::Clone(const char* newname = 0) const; virtual RooAbsArg*RooAbsArg::cloneTree(const char* newname = 0) const; virtual Double_tcombinedValue(RooAbsReal** gofArray, Int_t nVal) const; virtual Int_tRooAbsArg::Compare(const TObject* other) const; virtual voidTNamed::Copy(TObject& named) const; static UInt_tRooAbsArg::crc32(const char* data); static UInt_tRooAbsArg::crc32(const char* data, ULong_t sz, UInt_t crc = 0); virtual RooAbsTestStatistic*RooAbsTestStatistic::create(const char* name, const char* title, RooAbsReal& real, RooAbsData& data, const RooArgSet& projDeps, const char* rangeName = 0, const char* addCoefRangeName = 0, Int_t nCPU = 1, RooFit::MPSplit interleave = RooFit::BulkPartition, Bool_t verbose = kTRUE",MatchSource.WIKI,root/html602/RooAbsOptTestStatistic.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsOptTestStatistic.html
https://root.cern/root/html602/RooAbsOptTestStatistic.html:4232,Usability,clear,clearShapeDirty,4232,"rtual RooFitResult*RooAbsReal::chi2FitTo(RooDataHist& data, const RooCmdArg& arg1 = RooCmdArg::none(), const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()); virtual RooFitResult*RooAbsReal::chi2FitTo(RooDataSet& xydata, const RooCmdArg& arg1 = RooCmdArg::none(), const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); static voidRooAbsReal::clearEvalErrorLog(); voidRooAbsArg::clearShapeDirty() const; voidRooAbsArg::clearValueAndShapeDirty() const; voidRooAbsArg::clearValueDirty() const; TIterator*RooAbsArg::clientIterator() const; virtual TObject*RooAbsArg::clone(const char* newname = 0) const; virtual TObject*RooAbsArg::Clone(const char* newname = 0) const; virtual RooAbsArg*RooAbsArg::cloneTree(const char* newname = 0) const; virtual Double_tcombinedValue(RooAbsReal** gofArray, Int_t nVal) const; virtual Int_tRooAbsArg::Compare(const TObject* other) const; virtual voidTNamed::Copy(TObject& named) const; static UInt_tRooAbsArg::crc32(const char* data); static UInt_tRooAbsArg::crc32(const char* data, ULong_t sz, UInt_t crc = 0); virtual RooAbsTestStatistic*RooAbsTestStatistic::create(const char* name, const char* title, RooAbsReal& real, RooAbsData& data, const RooArgSet& projDeps, const char* rangeName = 0, const char* addCoefRangeName = 0, Int_t nCPU = 1, RooFit::MPSplit interleave = RooFit::BulkPartition, Bool_t verbose = kTRUE, Bool_t splitCutRange = kFALSE, Bo",MatchSource.WIKI,root/html602/RooAbsOptTestStatistic.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsOptTestStatistic.html
https://root.cern/root/html602/RooAbsOptTestStatistic.html:4272,Usability,clear,clearValueAndShapeDirty,4272,"DataHist& data, const RooCmdArg& arg1 = RooCmdArg::none(), const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()); virtual RooFitResult*RooAbsReal::chi2FitTo(RooDataSet& xydata, const RooCmdArg& arg1 = RooCmdArg::none(), const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); static voidRooAbsReal::clearEvalErrorLog(); voidRooAbsArg::clearShapeDirty() const; voidRooAbsArg::clearValueAndShapeDirty() const; voidRooAbsArg::clearValueDirty() const; TIterator*RooAbsArg::clientIterator() const; virtual TObject*RooAbsArg::clone(const char* newname = 0) const; virtual TObject*RooAbsArg::Clone(const char* newname = 0) const; virtual RooAbsArg*RooAbsArg::cloneTree(const char* newname = 0) const; virtual Double_tcombinedValue(RooAbsReal** gofArray, Int_t nVal) const; virtual Int_tRooAbsArg::Compare(const TObject* other) const; virtual voidTNamed::Copy(TObject& named) const; static UInt_tRooAbsArg::crc32(const char* data); static UInt_tRooAbsArg::crc32(const char* data, ULong_t sz, UInt_t crc = 0); virtual RooAbsTestStatistic*RooAbsTestStatistic::create(const char* name, const char* title, RooAbsReal& real, RooAbsData& data, const RooArgSet& projDeps, const char* rangeName = 0, const char* addCoefRangeName = 0, Int_t nCPU = 1, RooFit::MPSplit interleave = RooFit::BulkPartition, Bool_t verbose = kTRUE, Bool_t splitCutRange = kFALSE, Bool_t binnedL = kFALSE); virtual RooAbsReal*R",MatchSource.WIKI,root/html602/RooAbsOptTestStatistic.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsOptTestStatistic.html
https://root.cern/root/html602/RooAbsOptTestStatistic.html:4320,Usability,clear,clearValueDirty,4320,"mdArg::none(), const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()); virtual RooFitResult*RooAbsReal::chi2FitTo(RooDataSet& xydata, const RooCmdArg& arg1 = RooCmdArg::none(), const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); static voidRooAbsReal::clearEvalErrorLog(); voidRooAbsArg::clearShapeDirty() const; voidRooAbsArg::clearValueAndShapeDirty() const; voidRooAbsArg::clearValueDirty() const; TIterator*RooAbsArg::clientIterator() const; virtual TObject*RooAbsArg::clone(const char* newname = 0) const; virtual TObject*RooAbsArg::Clone(const char* newname = 0) const; virtual RooAbsArg*RooAbsArg::cloneTree(const char* newname = 0) const; virtual Double_tcombinedValue(RooAbsReal** gofArray, Int_t nVal) const; virtual Int_tRooAbsArg::Compare(const TObject* other) const; virtual voidTNamed::Copy(TObject& named) const; static UInt_tRooAbsArg::crc32(const char* data); static UInt_tRooAbsArg::crc32(const char* data, ULong_t sz, UInt_t crc = 0); virtual RooAbsTestStatistic*RooAbsTestStatistic::create(const char* name, const char* title, RooAbsReal& real, RooAbsData& data, const RooArgSet& projDeps, const char* rangeName = 0, const char* addCoefRangeName = 0, Int_t nCPU = 1, RooFit::MPSplit interleave = RooFit::BulkPartition, Bool_t verbose = kTRUE, Bool_t splitCutRange = kFALSE, Bool_t binnedL = kFALSE); virtual RooAbsReal*RooAbsReal::createChi2(RooDataHist& data, con",MatchSource.WIKI,root/html602/RooAbsOptTestStatistic.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsOptTestStatistic.html
https://root.cern/root/html602/RooAbsPdf.html:461,Availability,error,error,461,". RooAbsPdf. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » ROOFIT; » ROOFITCORE; » RooAbsPdf. class RooAbsPdf: public RooAbsReal. RooAbsPdf is the abstract interface for all probability density; functions The class provides hybrid analytical/numerical; normalization for its implementations, error tracing and a MC; generator interface. A minimal implementation of a PDF class derived from RooAbsPdf; should overload the evaluate() function. This functions should; return PDFs value. [Normalization/Integration]. Although the normalization of a PDF is an integral part of a; probability density function, normalization is treated separately; in RooAbsPdf. The reason is that a RooAbsPdf object is more than a; PDF: it can be a building block for a more complex, composite PDF; if any of its variables are functions instead of variables. In; such cases the normalization of the composite may not be simply the; integral over the dependents of the top level PDF as these are; functions with potentially non-trivial Jacobian terms themselves.; Therefore. --> No explicit attempt should be made to normalize; the functions output in evaluate(). In addition, RooAbsPdf objects do not have a static concept of what; variables are parameters and what variables are dependents (which; need to be integrated over for a correct PDF normalization).; Instead the choice of normalization is always specified each time a; normalized values is requested from the PDF via the getVal(); method. RooAbsPdf manages the entire normalization logic of each PDF with; help of a RooRealIntegral object, which coordinates the integration; of a given choice of normalization. By default, RooRealIntegral will; perform a fully numeric integration of all dependents. However,; PDFs can advertise one or more (partial) analytical integrals of; their function, a",MatchSource.WIKI,root/html602/RooAbsPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsPdf.html
https://root.cern/root/html602/RooAbsPdf.html:4441,Availability,avail,available,4441,"d with the accept/reject method,; but for certain PDFs more efficient methods may be implemented. To; implement direct generation of one or more observables, two; functions need to be implemented, similar to those for analytical; integrals:. Int_t getGenerator(const RooArgSet& generateVars, RooArgSet& directVars) and; void generateEvent(Int_t code). The first function advertises observables that can be generated,; similar to the way analytical integrals are advertised. The second; function implements the generator for the advertised observables. The generated dependent values should be store in the proxy; objects. For this the assignment operator can be used (i.e. xProxy; = 3.0 ). Never call assign to any proxy not known to be a dependent; via the generation code. Doing so may be ill-defined, e.g. in case; the proxy holds a function, and will trigger an assert. Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~RooAbsPdf(); voidTObject::AbstractMethod(const char* method) const; Bool_tRooAbsArg::addOwnedComponents(const RooArgSet& comps); voidRooAbsArg::addParameters(RooArgSet& params, const RooArgSet* nset = 0, Bool_t stripDisconnected = kTRUE) const; voidRooAbsArg::addServer(RooAbsArg& server, Bool_t valueProp = kTRUE, Bool_t shapeProp = kFALSE); voidRooAbsArg::addServerList(RooAbsCollection& serverList, Bool_t valueProp = kTRUE, Bool_t shapeProp = kFALSE); const char*RooAbsArg::aggregateCacheUniqueSuffix() const; virtual Double_tRooAbsReal::analyticalIntegral(Int_t code, const char* rangeName = 0) const; virtual Double_tanalyticalIntegralWN(Int_t code, const RooArgSet* normSet, const char* rangeName = 0) const; virtual voidTObject::AppendPad(Option_t* option = """"); TF1*RooAbsReal::asTF(const RooArgList& obs, const RooArgList& pars = RooArgList(), const RooArgSet& nset = RooArgSet()) const; voidRooAbsArg::attachDataSet(const RooAbsData& set); ",MatchSource.WIKI,root/html602/RooAbsPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsPdf.html
https://root.cern/root/html602/RooAbsPdf.html:13774,Availability,error,error,13774,,MatchSource.WIKI,root/html602/RooAbsPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsPdf.html
https://root.cern/root/html602/RooAbsPdf.html:13858,Availability,error,error,13858,,MatchSource.WIKI,root/html602/RooAbsPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsPdf.html
https://root.cern/root/html602/RooAbsPdf.html:44767,Availability,error,errors,44767,"boolAttribBoolean attributes; set<string>RooAbsArg::_boolAttribTransient! Transient boolean attributes (not copied in ctor); Bool_tRooAbsReal::_boolValue! Transient cache for bool values from tree branches; UChar_tRooAbsReal::_byteValue! Transient cache for byte values from tree branches; static Bool_tRooAbsReal::_cacheCheckIf true, always validate contents of clean which outcome of evaluate(); deque<RooAbsCache*>RooAbsArg::_cacheListlist of caches; RooRefCountListRooAbsArg::_clientListlist of client objects; RooRefCountListRooAbsArg::_clientListShapesubset of clients that requested shape dirty flag propagation; RooRefCountListRooAbsArg::_clientListValuesubset of clients that requested value dirty flag propagation; TIterator*RooAbsArg::_clientShapeIter! Iterator over _clientListShape; TIterator*RooAbsArg::_clientValueIter! Iterator over _clientListValue; Bool_tRooAbsArg::_deleteWatch! Delete watch flag; RooExpensiveObjectCache*RooAbsArg::_eocachePointer to global cache manager for any expensive components created by this object; Int_t_errorCountNumber of errors remaining to print; static Bool_t_evalError; Bool_tRooAbsArg::_fastAllow fast access mode in getVal() and proxies; Float_tRooAbsReal::_floatValue! Transient cache for floating point values from tree branches; Bool_tRooAbsReal::_forceNumIntForce numerical integration if flag set; static Bool_tRooAbsReal::_globalSelectCompGlobal activation switch for component selection; static Bool_tRooAbsReal::_hideOffsetOffset hiding flag; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; Int_tRooAbsReal::_intValue! Transient cache for integer values from tree branches; Bool_tRooAbsArg::_isConstant! Cached isConstant status; TStringRooAbsReal::_labelPlot label for objects value; RooArgSet*RooAbsReal::_lastNSet!; Bool_tRooAbsArg::_localNoInhibitDirty! Prevent 'AlwaysDirty' mode for this node; static Int_tRooPrintable::_nameLength; TNamed*RooAbsArg::_namePtr! Do not persist.",MatchSource.WIKI,root/html602/RooAbsPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsPdf.html
https://root.cern/root/html602/RooAbsPdf.html:49232,Availability,error,error,49232,"0) const; Return current value, normalizated by integrating over; the observables in 'nset'. If 'nset' is 0, the unnormalized value.; is returned. All elements of 'nset' must be lvalues. Unnormalized values are not cached; Doing so would be complicated as _norm->getVal() could; spoil the cache and interfere with returning the cached; return value. Since unnormalized calls are typically; done in integration calls, there is no performance hit. Double_t analyticalIntegralWN(Int_t code, const RooArgSet* normSet, const char* rangeName = 0) const; Analytical integral with normalization (see RooAbsReal::analyticalIntegralWN() for further information). This function applies the normalization specified by 'normSet' to the integral returned; by RooAbsReal::analyticalIntegral(). The passthrough scenario (code=0) is also changed; to return a normalized answer. Bool_t traceEvalPdf(Double_t value) const; Check that passed value is positive and not 'not-a-number'. If; not, print an error, until the error counter reaches its set; maximum. Double_t getNorm(const RooArgSet* set = 0) const; Return the integral of this PDF over all observables listed in 'nset'. const RooAbsReal* getNormObj(const RooArgSet* set, const RooArgSet* iset, const TNamed* rangeName = 0) const; Return pointer to RooAbsReal object that implements calculation of integral over observables iset in range; rangeName, optionally taking the integrand normalized over observables nset. Bool_t syncNormalization(const RooArgSet* dset, Bool_t adjustProxies = kTRUE) const; Verify that the normalization integral cached with this PDF; is valid for given set of normalization observables. If not, the cached normalization integral (if any) is deleted; and a new integral is constructed for use with 'nset'; Elements in 'nset' can be discrete and real, but must be lvalues. For functions that declare to be self-normalized by overloading the; selfNormalized() function, a unit normalization is always constructed. Bool_t traceEvalHook(Do",MatchSource.WIKI,root/html602/RooAbsPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsPdf.html
https://root.cern/root/html602/RooAbsPdf.html:49249,Availability,error,error,49249,"0) const; Return current value, normalizated by integrating over; the observables in 'nset'. If 'nset' is 0, the unnormalized value.; is returned. All elements of 'nset' must be lvalues. Unnormalized values are not cached; Doing so would be complicated as _norm->getVal() could; spoil the cache and interfere with returning the cached; return value. Since unnormalized calls are typically; done in integration calls, there is no performance hit. Double_t analyticalIntegralWN(Int_t code, const RooArgSet* normSet, const char* rangeName = 0) const; Analytical integral with normalization (see RooAbsReal::analyticalIntegralWN() for further information). This function applies the normalization specified by 'normSet' to the integral returned; by RooAbsReal::analyticalIntegral(). The passthrough scenario (code=0) is also changed; to return a normalized answer. Bool_t traceEvalPdf(Double_t value) const; Check that passed value is positive and not 'not-a-number'. If; not, print an error, until the error counter reaches its set; maximum. Double_t getNorm(const RooArgSet* set = 0) const; Return the integral of this PDF over all observables listed in 'nset'. const RooAbsReal* getNormObj(const RooArgSet* set, const RooArgSet* iset, const TNamed* rangeName = 0) const; Return pointer to RooAbsReal object that implements calculation of integral over observables iset in range; rangeName, optionally taking the integrand normalized over observables nset. Bool_t syncNormalization(const RooArgSet* dset, Bool_t adjustProxies = kTRUE) const; Verify that the normalization integral cached with this PDF; is valid for given set of normalization observables. If not, the cached normalization integral (if any) is deleted; and a new integral is constructed for use with 'nset'; Elements in 'nset' can be discrete and real, but must be lvalues. For functions that declare to be self-normalized by overloading the; selfNormalized() function, a unit normalization is always constructed. Bool_t traceEvalHook(Do",MatchSource.WIKI,root/html602/RooAbsPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsPdf.html
https://root.cern/root/html602/RooAbsPdf.html:50362,Availability,error,error,50362,"bles listed in 'nset'. const RooAbsReal* getNormObj(const RooArgSet* set, const RooArgSet* iset, const TNamed* rangeName = 0) const; Return pointer to RooAbsReal object that implements calculation of integral over observables iset in range; rangeName, optionally taking the integrand normalized over observables nset. Bool_t syncNormalization(const RooArgSet* dset, Bool_t adjustProxies = kTRUE) const; Verify that the normalization integral cached with this PDF; is valid for given set of normalization observables. If not, the cached normalization integral (if any) is deleted; and a new integral is constructed for use with 'nset'; Elements in 'nset' can be discrete and real, but must be lvalues. For functions that declare to be self-normalized by overloading the; selfNormalized() function, a unit normalization is always constructed. Bool_t traceEvalHook(Double_t value) const; WVE 08/21/01 Probably obsolete now. void resetErrorCounters(Int_t resetValue = 10); Reset error counter to given value, limiting the number; of future error messages for this pdf to 'resetValue'. void setTraceCounter(Int_t value, Bool_t allNodes = kFALSE); Reset trace counter to given value, limiting the; number of future trace messages for this pdf to 'value'. Double_t getLogVal(const RooArgSet* set = 0) const; Return the log of the current value with given normalization; An error message is printed if the argument of the log is negative. Double_t extendedTerm(Double_t observedEvents, const RooArgSet* nset = 0) const; Returned the extended likelihood term (Nexpect - Nobserved*log(NExpected); of this PDF for the given number of observed events. For successfull operation the PDF implementation must indicate; it is extendable by overloading canBeExtended() and must; implemented the expectedEvents() function. RooAbsReal* createNLL(RooAbsData& data, const RooCmdArg& arg1 = RooCmdArg::none(), const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = Ro",MatchSource.WIKI,root/html602/RooAbsPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsPdf.html
https://root.cern/root/html602/RooAbsPdf.html:50423,Availability,error,error,50423,"bles listed in 'nset'. const RooAbsReal* getNormObj(const RooArgSet* set, const RooArgSet* iset, const TNamed* rangeName = 0) const; Return pointer to RooAbsReal object that implements calculation of integral over observables iset in range; rangeName, optionally taking the integrand normalized over observables nset. Bool_t syncNormalization(const RooArgSet* dset, Bool_t adjustProxies = kTRUE) const; Verify that the normalization integral cached with this PDF; is valid for given set of normalization observables. If not, the cached normalization integral (if any) is deleted; and a new integral is constructed for use with 'nset'; Elements in 'nset' can be discrete and real, but must be lvalues. For functions that declare to be self-normalized by overloading the; selfNormalized() function, a unit normalization is always constructed. Bool_t traceEvalHook(Double_t value) const; WVE 08/21/01 Probably obsolete now. void resetErrorCounters(Int_t resetValue = 10); Reset error counter to given value, limiting the number; of future error messages for this pdf to 'resetValue'. void setTraceCounter(Int_t value, Bool_t allNodes = kFALSE); Reset trace counter to given value, limiting the; number of future trace messages for this pdf to 'value'. Double_t getLogVal(const RooArgSet* set = 0) const; Return the log of the current value with given normalization; An error message is printed if the argument of the log is negative. Double_t extendedTerm(Double_t observedEvents, const RooArgSet* nset = 0) const; Returned the extended likelihood term (Nexpect - Nobserved*log(NExpected); of this PDF for the given number of observed events. For successfull operation the PDF implementation must indicate; it is extendable by overloading canBeExtended() and must; implemented the expectedEvents() function. RooAbsReal* createNLL(RooAbsData& data, const RooCmdArg& arg1 = RooCmdArg::none(), const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = Ro",MatchSource.WIKI,root/html602/RooAbsPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsPdf.html
https://root.cern/root/html602/RooAbsPdf.html:50753,Availability,error,error,50753,"ion(const RooArgSet* dset, Bool_t adjustProxies = kTRUE) const; Verify that the normalization integral cached with this PDF; is valid for given set of normalization observables. If not, the cached normalization integral (if any) is deleted; and a new integral is constructed for use with 'nset'; Elements in 'nset' can be discrete and real, but must be lvalues. For functions that declare to be self-normalized by overloading the; selfNormalized() function, a unit normalization is always constructed. Bool_t traceEvalHook(Double_t value) const; WVE 08/21/01 Probably obsolete now. void resetErrorCounters(Int_t resetValue = 10); Reset error counter to given value, limiting the number; of future error messages for this pdf to 'resetValue'. void setTraceCounter(Int_t value, Bool_t allNodes = kFALSE); Reset trace counter to given value, limiting the; number of future trace messages for this pdf to 'value'. Double_t getLogVal(const RooArgSet* set = 0) const; Return the log of the current value with given normalization; An error message is printed if the argument of the log is negative. Double_t extendedTerm(Double_t observedEvents, const RooArgSet* nset = 0) const; Returned the extended likelihood term (Nexpect - Nobserved*log(NExpected); of this PDF for the given number of observed events. For successfull operation the PDF implementation must indicate; it is extendable by overloading canBeExtended() and must; implemented the expectedEvents() function. RooAbsReal* createNLL(RooAbsData& data, const RooCmdArg& arg1 = RooCmdArg::none(), const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()); Construct representation of -log(L) of PDFwith given dataset. If dataset is unbinned, an unbinned likelihood is constructed. If the dataset; is binne",MatchSource.WIKI,root/html602/RooAbsPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsPdf.html
https://root.cern/root/html602/RooAbsPdf.html:60254,Availability,error,errors,60254,"Minuit2 migrad, simplex, minimize, scan; GSLMultiMin conjugatefr, conjugatepr, bfgs, bfgs2, steepestdescent; GSLSimAn -. InitialHesse(Bool_t flag) -- Flag controls if HESSE before MIGRAD as well, off by default; Optimize(Bool_t flag) -- Activate constant term optimization of test statistic during minimization (on by default); Hesse(Bool_t flag) -- Flag controls if HESSE is run after MIGRAD, on by default; Minos(Bool_t flag) -- Flag controls if MINOS is run after HESSE, off by default; Minos(const RooArgSet& set) -- Only run MINOS on given subset of arguments; Save(Bool_t flag) -- Flac controls if RooFitResult object is produced and returned, off by default; Strategy(Int_t flag) -- Set Minuit strategy (0 through 2, default is 1); FitOptions(const char* optStr) -- Steer fit with classic options string (for backward compatibility). Use of this option; excludes use of any of the new style steering options. SumW2Error(Bool_t flag) -- Apply correaction to errors and covariance matrix using sum-of-weights covariance matrix; to obtain correct error for weighted likelihood fits. If this option is activated the; corrected covariance matrix is calculated as Vcorr = V C-1 V, where V is the original; covariance matrix and C is the inverse of the covariance matrix calculated using the; weights squared. Options to control informational output. Verbose(Bool_t flag) -- Flag controls if verbose output is printed (NLL, parameter changes during fit; Timer(Bool_t flag) -- Time CPU and wall clock consumption of fit steps, off by default; PrintLevel(Int_t level) -- Set Minuit print level (-1 through 3, default is 1). At -1 all RooFit informational; messages are suppressed as well; Warnings(Bool_t flag) -- Enable or disable MINUIT warnings (enabled by default); PrintEvalErrors(Int_t numErr) -- Control number of p.d.f evaluation errors printed per likelihood evaluation. A negative; value suppress output completely, a zero value will only print the error count per p.d.f component,; a positive",MatchSource.WIKI,root/html602/RooAbsPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsPdf.html
https://root.cern/root/html602/RooAbsPdf.html:60341,Availability,error,error,60341,"Minuit2 migrad, simplex, minimize, scan; GSLMultiMin conjugatefr, conjugatepr, bfgs, bfgs2, steepestdescent; GSLSimAn -. InitialHesse(Bool_t flag) -- Flag controls if HESSE before MIGRAD as well, off by default; Optimize(Bool_t flag) -- Activate constant term optimization of test statistic during minimization (on by default); Hesse(Bool_t flag) -- Flag controls if HESSE is run after MIGRAD, on by default; Minos(Bool_t flag) -- Flag controls if MINOS is run after HESSE, off by default; Minos(const RooArgSet& set) -- Only run MINOS on given subset of arguments; Save(Bool_t flag) -- Flac controls if RooFitResult object is produced and returned, off by default; Strategy(Int_t flag) -- Set Minuit strategy (0 through 2, default is 1); FitOptions(const char* optStr) -- Steer fit with classic options string (for backward compatibility). Use of this option; excludes use of any of the new style steering options. SumW2Error(Bool_t flag) -- Apply correaction to errors and covariance matrix using sum-of-weights covariance matrix; to obtain correct error for weighted likelihood fits. If this option is activated the; corrected covariance matrix is calculated as Vcorr = V C-1 V, where V is the original; covariance matrix and C is the inverse of the covariance matrix calculated using the; weights squared. Options to control informational output. Verbose(Bool_t flag) -- Flag controls if verbose output is printed (NLL, parameter changes during fit; Timer(Bool_t flag) -- Time CPU and wall clock consumption of fit steps, off by default; PrintLevel(Int_t level) -- Set Minuit print level (-1 through 3, default is 1). At -1 all RooFit informational; messages are suppressed as well; Warnings(Bool_t flag) -- Enable or disable MINUIT warnings (enabled by default); PrintEvalErrors(Int_t numErr) -- Control number of p.d.f evaluation errors printed per likelihood evaluation. A negative; value suppress output completely, a zero value will only print the error count per p.d.f component,; a positive",MatchSource.WIKI,root/html602/RooAbsPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsPdf.html
https://root.cern/root/html602/RooAbsPdf.html:61126,Availability,error,errors,61126,"is option; excludes use of any of the new style steering options. SumW2Error(Bool_t flag) -- Apply correaction to errors and covariance matrix using sum-of-weights covariance matrix; to obtain correct error for weighted likelihood fits. If this option is activated the; corrected covariance matrix is calculated as Vcorr = V C-1 V, where V is the original; covariance matrix and C is the inverse of the covariance matrix calculated using the; weights squared. Options to control informational output. Verbose(Bool_t flag) -- Flag controls if verbose output is printed (NLL, parameter changes during fit; Timer(Bool_t flag) -- Time CPU and wall clock consumption of fit steps, off by default; PrintLevel(Int_t level) -- Set Minuit print level (-1 through 3, default is 1). At -1 all RooFit informational; messages are suppressed as well; Warnings(Bool_t flag) -- Enable or disable MINUIT warnings (enabled by default); PrintEvalErrors(Int_t numErr) -- Control number of p.d.f evaluation errors printed per likelihood evaluation. A negative; value suppress output completely, a zero value will only print the error count per p.d.f component,; a positive value is will print details of each error up to numErr messages per p.d.f component. RooFitResult* fitTo(RooAbsData& data, const RooLinkedList& cmdList); Fit PDF to given dataset. If dataset is unbinned, an unbinned maximum likelihood is performed. If the dataset; is binned, a binned maximum likelihood is performed. By default the fit is executed through the MINUIT; commands MIGRAD, HESSE and MINOS in succession. See RooAbsPdf::fitTo(RooAbsData& data, RooCmdArg arg1, RooCmdArg arg2, RooCmdArg arg3, RooCmdArg arg4,; RooCmdArg arg5, RooCmdArg arg6, RooCmdArg arg7, RooCmdArg arg8). for documentation of options. RooFitResult* chi2FitTo(RooDataHist& data, const RooLinkedList& cmdList); Internal back-end function to steer chi2 fits. RooAbsReal* createChi2(RooDataHist& data, const RooCmdArg& arg1 = RooCmdArg::none(), const RooCmdArg& arg2 = Ro",MatchSource.WIKI,root/html602/RooAbsPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsPdf.html
https://root.cern/root/html602/RooAbsPdf.html:61247,Availability,error,error,61247,"(Bool_t flag) -- Apply correaction to errors and covariance matrix using sum-of-weights covariance matrix; to obtain correct error for weighted likelihood fits. If this option is activated the; corrected covariance matrix is calculated as Vcorr = V C-1 V, where V is the original; covariance matrix and C is the inverse of the covariance matrix calculated using the; weights squared. Options to control informational output. Verbose(Bool_t flag) -- Flag controls if verbose output is printed (NLL, parameter changes during fit; Timer(Bool_t flag) -- Time CPU and wall clock consumption of fit steps, off by default; PrintLevel(Int_t level) -- Set Minuit print level (-1 through 3, default is 1). At -1 all RooFit informational; messages are suppressed as well; Warnings(Bool_t flag) -- Enable or disable MINUIT warnings (enabled by default); PrintEvalErrors(Int_t numErr) -- Control number of p.d.f evaluation errors printed per likelihood evaluation. A negative; value suppress output completely, a zero value will only print the error count per p.d.f component,; a positive value is will print details of each error up to numErr messages per p.d.f component. RooFitResult* fitTo(RooAbsData& data, const RooLinkedList& cmdList); Fit PDF to given dataset. If dataset is unbinned, an unbinned maximum likelihood is performed. If the dataset; is binned, a binned maximum likelihood is performed. By default the fit is executed through the MINUIT; commands MIGRAD, HESSE and MINOS in succession. See RooAbsPdf::fitTo(RooAbsData& data, RooCmdArg arg1, RooCmdArg arg2, RooCmdArg arg3, RooCmdArg arg4,; RooCmdArg arg5, RooCmdArg arg6, RooCmdArg arg7, RooCmdArg arg8). for documentation of options. RooFitResult* chi2FitTo(RooDataHist& data, const RooLinkedList& cmdList); Internal back-end function to steer chi2 fits. RooAbsReal* createChi2(RooDataHist& data, const RooCmdArg& arg1 = RooCmdArg::none(), const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg&",MatchSource.WIKI,root/html602/RooAbsPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsPdf.html
https://root.cern/root/html602/RooAbsPdf.html:61328,Availability,error,error,61328," matrix; to obtain correct error for weighted likelihood fits. If this option is activated the; corrected covariance matrix is calculated as Vcorr = V C-1 V, where V is the original; covariance matrix and C is the inverse of the covariance matrix calculated using the; weights squared. Options to control informational output. Verbose(Bool_t flag) -- Flag controls if verbose output is printed (NLL, parameter changes during fit; Timer(Bool_t flag) -- Time CPU and wall clock consumption of fit steps, off by default; PrintLevel(Int_t level) -- Set Minuit print level (-1 through 3, default is 1). At -1 all RooFit informational; messages are suppressed as well; Warnings(Bool_t flag) -- Enable or disable MINUIT warnings (enabled by default); PrintEvalErrors(Int_t numErr) -- Control number of p.d.f evaluation errors printed per likelihood evaluation. A negative; value suppress output completely, a zero value will only print the error count per p.d.f component,; a positive value is will print details of each error up to numErr messages per p.d.f component. RooFitResult* fitTo(RooAbsData& data, const RooLinkedList& cmdList); Fit PDF to given dataset. If dataset is unbinned, an unbinned maximum likelihood is performed. If the dataset; is binned, a binned maximum likelihood is performed. By default the fit is executed through the MINUIT; commands MIGRAD, HESSE and MINOS in succession. See RooAbsPdf::fitTo(RooAbsData& data, RooCmdArg arg1, RooCmdArg arg2, RooCmdArg arg3, RooCmdArg arg4,; RooCmdArg arg5, RooCmdArg arg6, RooCmdArg arg7, RooCmdArg arg8). for documentation of options. RooFitResult* chi2FitTo(RooDataHist& data, const RooLinkedList& cmdList); Internal back-end function to steer chi2 fits. RooAbsReal* createChi2(RooDataHist& data, const RooCmdArg& arg1 = RooCmdArg::none(), const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCm",MatchSource.WIKI,root/html602/RooAbsPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsPdf.html
https://root.cern/root/html602/RooAbsPdf.html:62680,Availability,error,error,62680,", HESSE and MINOS in succession. See RooAbsPdf::fitTo(RooAbsData& data, RooCmdArg arg1, RooCmdArg arg2, RooCmdArg arg3, RooCmdArg arg4,; RooCmdArg arg5, RooCmdArg arg6, RooCmdArg arg7, RooCmdArg arg8). for documentation of options. RooFitResult* chi2FitTo(RooDataHist& data, const RooLinkedList& cmdList); Internal back-end function to steer chi2 fits. RooAbsReal* createChi2(RooDataHist& data, const RooCmdArg& arg1 = RooCmdArg::none(), const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()); Create a chi-2 from a histogram and this function. The following named arguments are supported. Options to control construction of the chi^2. Extended() -- Use expected number of events of an extended p.d.f as normalization; DataError() -- Choose between Expected error [RooAbsData::Expected] , or Observed error (e.g. Sum-of-weights [RooAbsData:SumW2] or Poisson interval [RooAbsData::Poisson] ); Default is AUTO : Expected error for unweighted data, Sum-of-weights for weighted data; NumCPU() -- Activate parallel processing feature; Range() -- Fit only selected region; SumCoefRange() -- Set the range in which to interpret the coefficients of RooAddPdf components; SplitRange() -- Fit range is split by index catory of simultaneous PDF; ConditionalObservables() -- Define projected observables. RooAbsReal* createChi2(RooDataSet& data, const RooLinkedList& cmdList); Internal back-end function to create a chi^2 from a p.d.f. and a dataset. void printValue(ostream& os) const; Print value of p.d.f, also print normalization integral that was last used, if any. void printMultiline(ostream& os, Int_t contents, Bool_t verbose = kFALSE, TString indent = """") const; Print multi line detailed information of this RooAbsPdf. RooAbsGenContext* binnedGenContext(co",MatchSource.WIKI,root/html602/RooAbsPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsPdf.html
https://root.cern/root/html602/RooAbsPdf.html:62723,Availability,error,error,62723,", HESSE and MINOS in succession. See RooAbsPdf::fitTo(RooAbsData& data, RooCmdArg arg1, RooCmdArg arg2, RooCmdArg arg3, RooCmdArg arg4,; RooCmdArg arg5, RooCmdArg arg6, RooCmdArg arg7, RooCmdArg arg8). for documentation of options. RooFitResult* chi2FitTo(RooDataHist& data, const RooLinkedList& cmdList); Internal back-end function to steer chi2 fits. RooAbsReal* createChi2(RooDataHist& data, const RooCmdArg& arg1 = RooCmdArg::none(), const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()); Create a chi-2 from a histogram and this function. The following named arguments are supported. Options to control construction of the chi^2. Extended() -- Use expected number of events of an extended p.d.f as normalization; DataError() -- Choose between Expected error [RooAbsData::Expected] , or Observed error (e.g. Sum-of-weights [RooAbsData:SumW2] or Poisson interval [RooAbsData::Poisson] ); Default is AUTO : Expected error for unweighted data, Sum-of-weights for weighted data; NumCPU() -- Activate parallel processing feature; Range() -- Fit only selected region; SumCoefRange() -- Set the range in which to interpret the coefficients of RooAddPdf components; SplitRange() -- Fit range is split by index catory of simultaneous PDF; ConditionalObservables() -- Define projected observables. RooAbsReal* createChi2(RooDataSet& data, const RooLinkedList& cmdList); Internal back-end function to create a chi^2 from a p.d.f. and a dataset. void printValue(ostream& os) const; Print value of p.d.f, also print normalization integral that was last used, if any. void printMultiline(ostream& os, Int_t contents, Bool_t verbose = kFALSE, TString indent = """") const; Print multi line detailed information of this RooAbsPdf. RooAbsGenContext* binnedGenContext(co",MatchSource.WIKI,root/html602/RooAbsPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsPdf.html
https://root.cern/root/html602/RooAbsPdf.html:62841,Availability,error,error,62841,"dList); Internal back-end function to steer chi2 fits. RooAbsReal* createChi2(RooDataHist& data, const RooCmdArg& arg1 = RooCmdArg::none(), const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()); Create a chi-2 from a histogram and this function. The following named arguments are supported. Options to control construction of the chi^2. Extended() -- Use expected number of events of an extended p.d.f as normalization; DataError() -- Choose between Expected error [RooAbsData::Expected] , or Observed error (e.g. Sum-of-weights [RooAbsData:SumW2] or Poisson interval [RooAbsData::Poisson] ); Default is AUTO : Expected error for unweighted data, Sum-of-weights for weighted data; NumCPU() -- Activate parallel processing feature; Range() -- Fit only selected region; SumCoefRange() -- Set the range in which to interpret the coefficients of RooAddPdf components; SplitRange() -- Fit range is split by index catory of simultaneous PDF; ConditionalObservables() -- Define projected observables. RooAbsReal* createChi2(RooDataSet& data, const RooLinkedList& cmdList); Internal back-end function to create a chi^2 from a p.d.f. and a dataset. void printValue(ostream& os) const; Print value of p.d.f, also print normalization integral that was last used, if any. void printMultiline(ostream& os, Int_t contents, Bool_t verbose = kFALSE, TString indent = """") const; Print multi line detailed information of this RooAbsPdf. RooAbsGenContext* binnedGenContext(const RooArgSet& vars, Bool_t verbose = kFALSE) const; Return a binned generator context. RooAbsGenContext* genContext(const RooArgSet& vars, const RooDataSet* prototype = 0, const RooArgSet* auxProto = 0, Bool_t verbose = kFALSE) const; Interface function to create a generator context from a p.d.f",MatchSource.WIKI,root/html602/RooAbsPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsPdf.html
https://root.cern/root/html602/RooAbsPdf.html:64853,Availability,error,error,64853,"ype = 0, const RooArgSet* auxProto = 0, Bool_t verbose = kFALSE) const; Interface function to create a generator context from a p.d.f. This default; implementation returns a 'standard' context that works for any p.d.f. RooAbsGenContext* autoGenContext(const RooArgSet& vars, const RooDataSet* prototype = 0, const RooArgSet* auxProto = 0, Bool_t verbose = kFALSE, Bool_t autoBinned = kTRUE, const char* binnedTag = """") const. RooDataSet * generate(const RooArgSet& whatVars, Int_t nEvents, const RooCmdArg& arg1, const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none()); Generate a new dataset containing the specified variables with events sampled from our distribution.; Generate the specified number of events or expectedEvents() if not specified. Any variables of this PDF that are not in whatVars will use their; current values and be treated as fixed parameters. Returns zero; in case of an error. The caller takes ownership of the returned; dataset. The following named arguments are supported. Name(const char* name) -- Name of the output dataset; Verbose(Bool_t flag) -- Print informational messages during event generation; Extended() -- The actual number of events generated will be sampled from a Poisson distribution; with mu=nevt. For use with extended maximum likelihood fits; AutoBinned(Bool_t flag) -- Automatically deploy binned generation for binned distributions (e.g. RooHistPdf, sums and products of RooHistPdfs etc); NB: Datasets that are generated in binned mode are returned as weighted unbinned datasets. GenBinned(const char* tag) -- Use binned generation for all component pdfs that have 'setAttribute(tag)' set; AllBinned() -- As above, but for all components. Note that the notion of components is only meaningful for simultaneous pdf; as binned generation is always executed at the top-level node for a regular; pdf, so for those it only mattes that the t",MatchSource.WIKI,root/html602/RooAbsPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsPdf.html
https://root.cern/root/html602/RooAbsPdf.html:67418,Availability,error,error,67418,"copied into the new dataset for each generated event and also used to set our PDF parameters.; The user can specify a number of events to generate that will override the default. The result is a; copy of the prototype dataset with only variables in whatVars randomized. Variables in whatVars that; are not in the prototype will be added as new columns to the generated dataset. RooDataSet * generate(const RooArgSet& whatVars, const RooCmdArg& arg1 = RooCmdArg::none(), const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none()); Generate a new dataset containing the specified variables with events sampled from our distribution.; Generate the specified number of events or expectedEvents() if not specified. Any variables of this PDF that are not in whatVars will use their; current values and be treated as fixed parameters. Returns zero; in case of an error. The caller takes ownership of the returned; dataset. The following named arguments are supported. Name(const char* name) -- Name of the output dataset; Verbose(Bool_t flag) -- Print informational messages during event generation; NumEvent(int nevt) -- Generate specified number of events. AutoBinned(Bool_t flag) -- Automatically deploy binned generation for binned distributions (e.g. RooHistPdf, sums and products of RooHistPdfs etc); NB: Datasets that are generated in binned mode are returned as weighted unbinned datasets. GenBinned(const char* tag) -- Use binned generation for all component pdfs that have 'setAttribute(tag)' set; AllBinned() -- As above, but for all components. Note that the notion of components is only meaningful for simultaneous pdf; as binned generation is always executed at the top-level node for a regular; pdf, so for those it only mattes that the top-level node is tagged. Binned generation cannot be used when prototype data is supplied; Extended",MatchSource.WIKI,root/html602/RooAbsPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsPdf.html
https://root.cern/root/html602/RooAbsPdf.html:70628,Availability,error,error,70628,"l be added as new columns to the generated dataset. RooDataSet * generate(RooAbsPdf::GenSpec& ) const; Generate data according to a pre-configured specification created by; RooAbsPdf::prepareMultiGen(). If many identical generation requests; are needed, e.g. in toy MC studies, it is more efficient to use the prepareMultiGen()/generate(); combination than calling the standard generate() multiple times as; initialization overhead is only incurred once. RooDataSet * generate(const RooArgSet& whatVars, Double_t nEvents = 0, Bool_t verbose = kFALSE, Bool_t autoBinned = kTRUE, const char* binnedTag = """", Bool_t expectedData = kFALSE, Bool_t extended = kFALSE) const; Generate a new dataset containing the specified variables with; events sampled from our distribution. Generate the specified; number of events or else try to use expectedEvents() if nEvents <= 0.; Any variables of this PDF that are not in whatVars will use their; current values and be treated as fixed parameters. Returns zero; in case of an error. The caller takes ownership of the returned; dataset. RooDataSet * generate(RooAbsGenContext& context, const RooArgSet& whatVars, const RooDataSet* prototype, Double_t nEvents, Bool_t verbose, Bool_t randProtoOrder, Bool_t resampleProto, Bool_t skipInit = kFALSE, Bool_t extended = kFALSE) const; Internal method. RooDataSet * generate(const RooArgSet& whatVars, const RooDataSet& prototype, Int_t nEvents = 0, Bool_t verbose = kFALSE, Bool_t randProtoOrder = kFALSE, Bool_t resampleProto = kFALSE) const; Generate a new dataset with values of the whatVars variables; sampled from our distribution. Use the specified existing dataset; as a prototype: the new dataset will contain the same number of; events as the prototype (by default), and any prototype variables not in; whatVars will be copied into the new dataset for each generated; event and also used to set our PDF parameters. The user can specify a; number of events to generate that will override the default. The result i",MatchSource.WIKI,root/html602/RooAbsPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsPdf.html
https://root.cern/root/html602/RooAbsPdf.html:71833,Availability,error,error,71833,"bose, Bool_t randProtoOrder, Bool_t resampleProto, Bool_t skipInit = kFALSE, Bool_t extended = kFALSE) const; Internal method. RooDataSet * generate(const RooArgSet& whatVars, const RooDataSet& prototype, Int_t nEvents = 0, Bool_t verbose = kFALSE, Bool_t randProtoOrder = kFALSE, Bool_t resampleProto = kFALSE) const; Generate a new dataset with values of the whatVars variables; sampled from our distribution. Use the specified existing dataset; as a prototype: the new dataset will contain the same number of; events as the prototype (by default), and any prototype variables not in; whatVars will be copied into the new dataset for each generated; event and also used to set our PDF parameters. The user can specify a; number of events to generate that will override the default. The result is a; copy of the prototype dataset with only variables in whatVars; randomized. Variables in whatVars that are not in the prototype; will be added as new columns to the generated dataset. Returns; zero in case of an error. The caller takes ownership of the; returned dataset. Int_t* randomizeProtoOrder(Int_t nProto, Int_t nGen, Bool_t resample = kFALSE) const; Return lookup table with randomized access order for prototype events,; given nProto prototype data events and nGen events that will actually; be accessed. Int_t getGenerator(const RooArgSet& directVars, RooArgSet& generateVars, Bool_t staticInitOK = kTRUE) const; Load generatedVars with the subset of directVars that we can generate events for,; and return a code that specifies the generator algorithm we will use. A code of; zero indicates that we cannot generate any of the directVars (in this case, nothing; should be added to generatedVars). Any non-zero codes will be passed to our generateEvent(); implementation, but otherwise its value is arbitrary. The default implemetation of; this method returns zero. Subclasses will usually implement this method using the; matchArgs() methods to advertise the algorithms they provide. void in",MatchSource.WIKI,root/html602/RooAbsPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsPdf.html
https://root.cern/root/html602/RooAbsPdf.html:74117,Availability,error,error,74117,"getGenerator() implementation. The default; implementation does nothing. Bool_t isDirectGenSafe(const RooAbsArg& arg) const; Check if given observable can be safely generated using the; pdfs internal generator mechanism (if that existsP). Observables; on which a PDF depends via more than route are not safe; for use with internal generators because they introduce; correlations not known to the internal generator. RooDataHist * generateBinned(const RooArgSet& whatVars, Double_t nEvents, const RooCmdArg& arg1, const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none()); Generate a new dataset containing the specified variables with events sampled from our distribution.; Generate the specified number of events or expectedEvents() if not specified. Any variables of this PDF that are not in whatVars will use their; current values and be treated as fixed parameters. Returns zero; in case of an error. The caller takes ownership of the returned; dataset. The following named arguments are supported. Name(const char* name) -- Name of the output dataset; Verbose(Bool_t flag) -- Print informational messages during event generation; Extended() -- The actual number of events generated will be sampled from a Poisson distribution; with mu=nevt. For use with extended maximum likelihood fits; ExpectedData() -- Return a binned dataset _without_ statistical fluctuations (also aliased as Asimov()). RooDataHist * generateBinned(const RooArgSet& whatVars, const RooCmdArg& arg1 = RooCmdArg::none(), const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none()); Generate a new dataset containing the specified variables with events sampled from our distribution.; Generate the specified number of events or expectedEvents() if not speci",MatchSource.WIKI,root/html602/RooAbsPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsPdf.html
https://root.cern/root/html602/RooAbsPdf.html:75258,Availability,error,error,75258,"- Name of the output dataset; Verbose(Bool_t flag) -- Print informational messages during event generation; Extended() -- The actual number of events generated will be sampled from a Poisson distribution; with mu=nevt. For use with extended maximum likelihood fits; ExpectedData() -- Return a binned dataset _without_ statistical fluctuations (also aliased as Asimov()). RooDataHist * generateBinned(const RooArgSet& whatVars, const RooCmdArg& arg1 = RooCmdArg::none(), const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none()); Generate a new dataset containing the specified variables with events sampled from our distribution.; Generate the specified number of events or expectedEvents() if not specified. Any variables of this PDF that are not in whatVars will use their; current values and be treated as fixed parameters. Returns zero; in case of an error. The caller takes ownership of the returned; dataset. The following named arguments are supported. Name(const char* name) -- Name of the output dataset; Verbose(Bool_t flag) -- Print informational messages during event generation; NumEvent(int nevt) -- Generate specified number of events; Extended() -- The actual number of events generated will be sampled from a Poisson distribution; with mu=nevt. For use with extended maximum likelihood fits; ExpectedData() -- Return a binned dataset _without_ statistical fluctuations (also aliased as Asimov()). RooDataHist * generateBinned(const RooArgSet& whatVars, Double_t nEvents, Bool_t expectedData = kFALSE, Bool_t extended = kFALSE) const; Generate a new dataset containing the specified variables with; events sampled from our distribution. Generate the specified; number of events or else try to use expectedEvents() if nEvents <= 0. If expectedData is kTRUE (it is kFALSE by default), the returned histogram returns the 'expected'",MatchSource.WIKI,root/html602/RooAbsPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsPdf.html
https://root.cern/root/html602/RooAbsPdf.html:76454,Availability,error,error,76454,"rint informational messages during event generation; NumEvent(int nevt) -- Generate specified number of events; Extended() -- The actual number of events generated will be sampled from a Poisson distribution; with mu=nevt. For use with extended maximum likelihood fits; ExpectedData() -- Return a binned dataset _without_ statistical fluctuations (also aliased as Asimov()). RooDataHist * generateBinned(const RooArgSet& whatVars, Double_t nEvents, Bool_t expectedData = kFALSE, Bool_t extended = kFALSE) const; Generate a new dataset containing the specified variables with; events sampled from our distribution. Generate the specified; number of events or else try to use expectedEvents() if nEvents <= 0. If expectedData is kTRUE (it is kFALSE by default), the returned histogram returns the 'expected'; data sample, i.e. no statistical fluctuations are present. Any variables of this PDF that are not in whatVars will use their; current values and be treated as fixed parameters. Returns zero; in case of an error. The caller takes ownership of the returned; dataset. RooDataSet* generateSimGlobal(const RooArgSet& whatVars, Int_t nEvents); Special generator interface for generation of 'global observables' -- for RooStats tools. RooPlot* plotOn(RooPlot* frame, RooLinkedList& cmdList) const; Plot (project) PDF on specified frame. If a PDF is plotted in an empty frame, it; will show a unit normalized curve in the frame variable, taken at the present value; of other observables defined for this PDF. If a PDF is plotted in a frame in which a dataset has already been plotted, it will; show a projected curve integrated over all variables that were present in the shown; dataset except for the one on the x-axis. The normalization of the curve will also; be adjusted to the event count of the plotted dataset. An informational message; will be printed for each projection step that is performed. This function takes the following named arguments. Projection control. Slice(const RooArgSet& set)",MatchSource.WIKI,root/html602/RooAbsPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsPdf.html
https://root.cern/root/html602/RooAbsPdf.html:80119,Availability,down,downward,80119,"rather than; the PDF projection. Category must have two states with indices -1 and +1 or three states with; indeces -1,0 and +1.; ShiftToZero(Bool_t flag) -- Shift entire curve such that lowest visible point is at exactly zero. Mostly useful when; plotting -log(L) or chi^2 distributions; AddTo(const char* name, -- Add constructed projection to already existing curve with given name and relative weight factors; double_t wgtSelf, double_t wgtOther). Plotting control. LineStyle(Int_t style) -- Select line style by ROOT line style code, default is solid; LineColor(Int_t color) -- Select line color by ROOT color code, default is blue; LineWidth(Int_t width) -- Select line with in pixels, default is 3; FillStyle(Int_t style) -- Select fill style, default is not filled. If a filled style is selected, also use VLines(); to add vertical downward lines at end of curve to ensure proper closure; FillColor(Int_t color) -- Select fill color by ROOT color code; Range(const char* name) -- Only draw curve in range defined by given name; Range(double lo, double hi) -- Only draw curve in specified range; VLines() -- Add vertical lines to y=0 at end points of curve; Precision(Double_t eps) -- Control precision of drawn curve w.r.t to scale of plot, default is 1e-3. Higher precision; will result in more and more densely spaced curve points; A negative precision value will disable adaptive point spacing and restrict sampling to; the grid point of points defined by the binning of the plotted observabled (recommended for; expensive functions such as profile likelihoods); Invisble(Bool_t flag) -- Add curve to frame, but do not display. Useful in combination AddTo(). RooPlot* plotOn(RooPlot* frame, RooAbsReal::PlotOpt o) const; Plot oneself on 'frame'. In addition to features detailed in RooAbsReal::plotOn(),; the scale factor for a PDF can be interpreted in three different ways. The interpretation; is controlled by ScaleType. Relative - Scale factor is applied on top of PDF normalization sc",MatchSource.WIKI,root/html602/RooAbsPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsPdf.html
https://root.cern/root/html602/RooAbsPdf.html:82005,Availability,error,errors,82005," functions such as profile likelihoods); Invisble(Bool_t flag) -- Add curve to frame, but do not display. Useful in combination AddTo(). RooPlot* plotOn(RooPlot* frame, RooAbsReal::PlotOpt o) const; Plot oneself on 'frame'. In addition to features detailed in RooAbsReal::plotOn(),; the scale factor for a PDF can be interpreted in three different ways. The interpretation; is controlled by ScaleType. Relative - Scale factor is applied on top of PDF normalization scale factor; NumEvent - Scale factor is interpreted as a number of events. The surface area; under the PDF curve will match that of a histogram containing the specified; number of event; Raw - Scale factor is applied to the raw (projected) probability density.; Not too useful, option provided for completeness. RooPlot* paramOn(RooPlot* frame, const RooCmdArg& arg1 = RooCmdArg::none(), const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()); Add a box with parameter values (and errors) to the specified frame. The following named arguments are supported. Parameters(const RooArgSet& param) -- Only the specified subset of parameters will be shown.; By default all non-contant parameters are shown; ShowConstants(Bool_t flag) -- Also display constant parameters; Format(const char* optStr) -- Classing [arameter formatting options, provided for backward compatibility; Format(const char* what,...) -- Parameter formatting options, details given below; Label(const chat* label) -- Add header label to parameter box; Layout(Double_t xmin, -- Specify relative position of left,right side of box and top of box. Position of; Double_t xmax, Double_t ymax) bottom of box is calculated automatically from number lines in box. The Format(const char* what,...) has the following structure. const ",MatchSource.WIKI,root/html602/RooAbsPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsPdf.html
https://root.cern/root/html602/RooAbsPdf.html:82875,Availability,error,error,82875,"::none()); Add a box with parameter values (and errors) to the specified frame. The following named arguments are supported. Parameters(const RooArgSet& param) -- Only the specified subset of parameters will be shown.; By default all non-contant parameters are shown; ShowConstants(Bool_t flag) -- Also display constant parameters; Format(const char* optStr) -- Classing [arameter formatting options, provided for backward compatibility; Format(const char* what,...) -- Parameter formatting options, details given below; Label(const chat* label) -- Add header label to parameter box; Layout(Double_t xmin, -- Specify relative position of left,right side of box and top of box. Position of; Double_t xmax, Double_t ymax) bottom of box is calculated automatically from number lines in box. The Format(const char* what,...) has the following structure. const char* what -- Controls what is shown. ""N"" adds name, ""E"" adds error,; ""A"" shows asymmetric error, ""U"" shows unit, ""H"" hides the value; FixedPrecision(int n) -- Controls precision, set fixed number of digits; AutoPrecision(int n) -- Controls precision. Number of shown digits is calculated from error; + n specified additional digits (1 is sensible default). Example use: pdf.paramOn(frame, Label(""fit result""), Format(""NEU"",AutoPrecision(1)) ) ;. RooPlot* paramOn(RooPlot* frame, const RooAbsData* data, const char* label = """", Int_t sigDigits = 2, Option_t* options = ""NELU"", Double_t xmin = 0.5, Double_t xmax = 0.98999999999999999, Double_t ymax = 0.94999999999999996); OBSOLETE FUNCTION PROVIDED FOR BACKWARD COMPATIBILITY. RooPlot* paramOn(RooPlot* frame, const RooArgSet& params, Bool_t showConstants = kFALSE, const char* label = """", Int_t sigDigits = 2, Option_t* options = ""NELU"", Double_t xmin = 0.65000000000000002, Double_t xmax = 0.98999999999999999, Double_t ymax = 0.94999999999999996, const RooCmdArg* formatCmd = 0); Add a text box with the current parameter values and their errors to the frame.; Observables of this PDF appea",MatchSource.WIKI,root/html602/RooAbsPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsPdf.html
https://root.cern/root/html602/RooAbsPdf.html:82904,Availability,error,error,82904,"::none()); Add a box with parameter values (and errors) to the specified frame. The following named arguments are supported. Parameters(const RooArgSet& param) -- Only the specified subset of parameters will be shown.; By default all non-contant parameters are shown; ShowConstants(Bool_t flag) -- Also display constant parameters; Format(const char* optStr) -- Classing [arameter formatting options, provided for backward compatibility; Format(const char* what,...) -- Parameter formatting options, details given below; Label(const chat* label) -- Add header label to parameter box; Layout(Double_t xmin, -- Specify relative position of left,right side of box and top of box. Position of; Double_t xmax, Double_t ymax) bottom of box is calculated automatically from number lines in box. The Format(const char* what,...) has the following structure. const char* what -- Controls what is shown. ""N"" adds name, ""E"" adds error,; ""A"" shows asymmetric error, ""U"" shows unit, ""H"" hides the value; FixedPrecision(int n) -- Controls precision, set fixed number of digits; AutoPrecision(int n) -- Controls precision. Number of shown digits is calculated from error; + n specified additional digits (1 is sensible default). Example use: pdf.paramOn(frame, Label(""fit result""), Format(""NEU"",AutoPrecision(1)) ) ;. RooPlot* paramOn(RooPlot* frame, const RooAbsData* data, const char* label = """", Int_t sigDigits = 2, Option_t* options = ""NELU"", Double_t xmin = 0.5, Double_t xmax = 0.98999999999999999, Double_t ymax = 0.94999999999999996); OBSOLETE FUNCTION PROVIDED FOR BACKWARD COMPATIBILITY. RooPlot* paramOn(RooPlot* frame, const RooArgSet& params, Bool_t showConstants = kFALSE, const char* label = """", Int_t sigDigits = 2, Option_t* options = ""NELU"", Double_t xmin = 0.65000000000000002, Double_t xmax = 0.98999999999999999, Double_t ymax = 0.94999999999999996, const RooCmdArg* formatCmd = 0); Add a text box with the current parameter values and their errors to the frame.; Observables of this PDF appea",MatchSource.WIKI,root/html602/RooAbsPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsPdf.html
https://root.cern/root/html602/RooAbsPdf.html:83107,Availability,error,error,83107,"-- Only the specified subset of parameters will be shown.; By default all non-contant parameters are shown; ShowConstants(Bool_t flag) -- Also display constant parameters; Format(const char* optStr) -- Classing [arameter formatting options, provided for backward compatibility; Format(const char* what,...) -- Parameter formatting options, details given below; Label(const chat* label) -- Add header label to parameter box; Layout(Double_t xmin, -- Specify relative position of left,right side of box and top of box. Position of; Double_t xmax, Double_t ymax) bottom of box is calculated automatically from number lines in box. The Format(const char* what,...) has the following structure. const char* what -- Controls what is shown. ""N"" adds name, ""E"" adds error,; ""A"" shows asymmetric error, ""U"" shows unit, ""H"" hides the value; FixedPrecision(int n) -- Controls precision, set fixed number of digits; AutoPrecision(int n) -- Controls precision. Number of shown digits is calculated from error; + n specified additional digits (1 is sensible default). Example use: pdf.paramOn(frame, Label(""fit result""), Format(""NEU"",AutoPrecision(1)) ) ;. RooPlot* paramOn(RooPlot* frame, const RooAbsData* data, const char* label = """", Int_t sigDigits = 2, Option_t* options = ""NELU"", Double_t xmin = 0.5, Double_t xmax = 0.98999999999999999, Double_t ymax = 0.94999999999999996); OBSOLETE FUNCTION PROVIDED FOR BACKWARD COMPATIBILITY. RooPlot* paramOn(RooPlot* frame, const RooArgSet& params, Bool_t showConstants = kFALSE, const char* label = """", Int_t sigDigits = 2, Option_t* options = ""NELU"", Double_t xmin = 0.65000000000000002, Double_t xmax = 0.98999999999999999, Double_t ymax = 0.94999999999999996, const RooCmdArg* formatCmd = 0); Add a text box with the current parameter values and their errors to the frame.; Observables of this PDF appearing in the 'data' dataset will be omitted. Optional label will be inserted as first line of the text box. Use 'sigDigits'; to modify the default number of sign",MatchSource.WIKI,root/html602/RooAbsPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsPdf.html
https://root.cern/root/html602/RooAbsPdf.html:83906,Availability,error,errors,83906,"name, ""E"" adds error,; ""A"" shows asymmetric error, ""U"" shows unit, ""H"" hides the value; FixedPrecision(int n) -- Controls precision, set fixed number of digits; AutoPrecision(int n) -- Controls precision. Number of shown digits is calculated from error; + n specified additional digits (1 is sensible default). Example use: pdf.paramOn(frame, Label(""fit result""), Format(""NEU"",AutoPrecision(1)) ) ;. RooPlot* paramOn(RooPlot* frame, const RooAbsData* data, const char* label = """", Int_t sigDigits = 2, Option_t* options = ""NELU"", Double_t xmin = 0.5, Double_t xmax = 0.98999999999999999, Double_t ymax = 0.94999999999999996); OBSOLETE FUNCTION PROVIDED FOR BACKWARD COMPATIBILITY. RooPlot* paramOn(RooPlot* frame, const RooArgSet& params, Bool_t showConstants = kFALSE, const char* label = """", Int_t sigDigits = 2, Option_t* options = ""NELU"", Double_t xmin = 0.65000000000000002, Double_t xmax = 0.98999999999999999, Double_t ymax = 0.94999999999999996, const RooCmdArg* formatCmd = 0); Add a text box with the current parameter values and their errors to the frame.; Observables of this PDF appearing in the 'data' dataset will be omitted. Optional label will be inserted as first line of the text box. Use 'sigDigits'; to modify the default number of significant digits printed. The 'xmin,xmax,ymax'; values specify the inital relative position of the text box in the plot frame. Double_t expectedEvents(const RooArgSet* nset) const; Return expected number of events from this p.d.f for use in extended; likelihood calculations. This default implementation returns zero. void verboseEval(Int_t stat); Change global level of verbosity for p.d.f. evaluations. Int_t verboseEval(); Return global level of verbosity for p.d.f. evaluations. RooAbsPdf* createProjection(const RooArgSet& iset); Return a p.d.f that represent a projection of this p.d.f integrated over given observables. RooAbsReal* createCdf(const RooArgSet& iset, const RooArgSet& nset = RooArgSet()); Create a cumulative distribution fun",MatchSource.WIKI,root/html602/RooAbsPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsPdf.html
https://root.cern/root/html602/RooAbsPdf.html:87046,Availability,error,error,87046,"unction, the variables; it integrates and the range integrates over. The following named arguments are accepted. SupNormSet(const RooArgSet&) -- Observables over which should be normalized _in_addition_ to the; integration observables; ScanNumCdf() -- Apply scanning technique if cdf integral involves numeric integration [ default ]; ScanAllCdf() -- Always apply scanning technique; ScanNoCdf() -- Never apply scanning technique; ScanParameters(Int_t nbins, -- Parameters for scanning technique of making CDF: number; Int_t intOrder) of sampled bins and order of interpolation applied on numeric cdf. RooAbsReal* createScanCdf(const RooArgSet& iset, const RooArgSet& nset, Int_t numScanBins, Int_t intOrder). RooArgSet* getAllConstraints(const RooArgSet& observables, RooArgSet& constrainedParams, Bool_t stripDisconnected = kTRUE) const; This helper function finds and collects all constraints terms of all coponent p.d.f.s; and returns a RooArgSet with all those terms. void clearEvalError(); Clear the evaluation error flag. Bool_t evalError(); Return the evaluation error flag. void raiseEvalError(); Raise the evaluation error flag. RooNumGenConfig* defaultGeneratorConfig(); Returns the default numeric MC generator configuration for all RooAbsReals. RooNumGenConfig* specialGeneratorConfig() const; Returns the specialized integrator configuration for _this_ RooAbsReal.; If this object has no specialized configuration, a null pointer is returned. RooNumGenConfig* specialGeneratorConfig(Bool_t createOnTheFly); Returns the specialized integrator configuration for _this_ RooAbsReal.; If this object has no specialized configuration, a null pointer is returned,; unless createOnTheFly is kTRUE in which case a clone of the default integrator; configuration is created, installed as specialized configuration, and returned. const RooNumGenConfig* getGeneratorConfig() const; Return the numeric MC generator configuration used for this object. If; a specialized configuration was associated wi",MatchSource.WIKI,root/html602/RooAbsPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsPdf.html
https://root.cern/root/html602/RooAbsPdf.html:87100,Availability,error,error,87100,"egrates over. The following named arguments are accepted. SupNormSet(const RooArgSet&) -- Observables over which should be normalized _in_addition_ to the; integration observables; ScanNumCdf() -- Apply scanning technique if cdf integral involves numeric integration [ default ]; ScanAllCdf() -- Always apply scanning technique; ScanNoCdf() -- Never apply scanning technique; ScanParameters(Int_t nbins, -- Parameters for scanning technique of making CDF: number; Int_t intOrder) of sampled bins and order of interpolation applied on numeric cdf. RooAbsReal* createScanCdf(const RooArgSet& iset, const RooArgSet& nset, Int_t numScanBins, Int_t intOrder). RooArgSet* getAllConstraints(const RooArgSet& observables, RooArgSet& constrainedParams, Bool_t stripDisconnected = kTRUE) const; This helper function finds and collects all constraints terms of all coponent p.d.f.s; and returns a RooArgSet with all those terms. void clearEvalError(); Clear the evaluation error flag. Bool_t evalError(); Return the evaluation error flag. void raiseEvalError(); Raise the evaluation error flag. RooNumGenConfig* defaultGeneratorConfig(); Returns the default numeric MC generator configuration for all RooAbsReals. RooNumGenConfig* specialGeneratorConfig() const; Returns the specialized integrator configuration for _this_ RooAbsReal.; If this object has no specialized configuration, a null pointer is returned. RooNumGenConfig* specialGeneratorConfig(Bool_t createOnTheFly); Returns the specialized integrator configuration for _this_ RooAbsReal.; If this object has no specialized configuration, a null pointer is returned,; unless createOnTheFly is kTRUE in which case a clone of the default integrator; configuration is created, installed as specialized configuration, and returned. const RooNumGenConfig* getGeneratorConfig() const; Return the numeric MC generator configuration used for this object. If; a specialized configuration was associated with this object, that configuration; is returned, otherw",MatchSource.WIKI,root/html602/RooAbsPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsPdf.html
https://root.cern/root/html602/RooAbsPdf.html:87156,Availability,error,error,87156,"d. SupNormSet(const RooArgSet&) -- Observables over which should be normalized _in_addition_ to the; integration observables; ScanNumCdf() -- Apply scanning technique if cdf integral involves numeric integration [ default ]; ScanAllCdf() -- Always apply scanning technique; ScanNoCdf() -- Never apply scanning technique; ScanParameters(Int_t nbins, -- Parameters for scanning technique of making CDF: number; Int_t intOrder) of sampled bins and order of interpolation applied on numeric cdf. RooAbsReal* createScanCdf(const RooArgSet& iset, const RooArgSet& nset, Int_t numScanBins, Int_t intOrder). RooArgSet* getAllConstraints(const RooArgSet& observables, RooArgSet& constrainedParams, Bool_t stripDisconnected = kTRUE) const; This helper function finds and collects all constraints terms of all coponent p.d.f.s; and returns a RooArgSet with all those terms. void clearEvalError(); Clear the evaluation error flag. Bool_t evalError(); Return the evaluation error flag. void raiseEvalError(); Raise the evaluation error flag. RooNumGenConfig* defaultGeneratorConfig(); Returns the default numeric MC generator configuration for all RooAbsReals. RooNumGenConfig* specialGeneratorConfig() const; Returns the specialized integrator configuration for _this_ RooAbsReal.; If this object has no specialized configuration, a null pointer is returned. RooNumGenConfig* specialGeneratorConfig(Bool_t createOnTheFly); Returns the specialized integrator configuration for _this_ RooAbsReal.; If this object has no specialized configuration, a null pointer is returned,; unless createOnTheFly is kTRUE in which case a clone of the default integrator; configuration is created, installed as specialized configuration, and returned. const RooNumGenConfig* getGeneratorConfig() const; Return the numeric MC generator configuration used for this object. If; a specialized configuration was associated with this object, that configuration; is returned, otherwise the default configuration for all RooAbsReals is re",MatchSource.WIKI,root/html602/RooAbsPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsPdf.html
https://root.cern/root/html602/RooAbsPdf.html:1457,Deployability,integrat,integrated,1457,"cal/numerical; normalization for its implementations, error tracing and a MC; generator interface. A minimal implementation of a PDF class derived from RooAbsPdf; should overload the evaluate() function. This functions should; return PDFs value. [Normalization/Integration]. Although the normalization of a PDF is an integral part of a; probability density function, normalization is treated separately; in RooAbsPdf. The reason is that a RooAbsPdf object is more than a; PDF: it can be a building block for a more complex, composite PDF; if any of its variables are functions instead of variables. In; such cases the normalization of the composite may not be simply the; integral over the dependents of the top level PDF as these are; functions with potentially non-trivial Jacobian terms themselves.; Therefore. --> No explicit attempt should be made to normalize; the functions output in evaluate(). In addition, RooAbsPdf objects do not have a static concept of what; variables are parameters and what variables are dependents (which; need to be integrated over for a correct PDF normalization).; Instead the choice of normalization is always specified each time a; normalized values is requested from the PDF via the getVal(); method. RooAbsPdf manages the entire normalization logic of each PDF with; help of a RooRealIntegral object, which coordinates the integration; of a given choice of normalization. By default, RooRealIntegral will; perform a fully numeric integration of all dependents. However,; PDFs can advertise one or more (partial) analytical integrals of; their function, and these will be used by RooRealIntegral, if it; determines that this is safe (i.e. no hidden Jacobian terms,; multiplication with other PDFs that have one or more dependents in; commen etc). To implement analytical integrals, two functions must be implemented. First,. Int_t getAnalyticalIntegral(const RooArgSet& integSet, RooArgSet& anaIntSet). advertises the analytical integrals that are supported. 'in",MatchSource.WIKI,root/html602/RooAbsPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsPdf.html
https://root.cern/root/html602/RooAbsPdf.html:1770,Deployability,integrat,integration,1770," part of a; probability density function, normalization is treated separately; in RooAbsPdf. The reason is that a RooAbsPdf object is more than a; PDF: it can be a building block for a more complex, composite PDF; if any of its variables are functions instead of variables. In; such cases the normalization of the composite may not be simply the; integral over the dependents of the top level PDF as these are; functions with potentially non-trivial Jacobian terms themselves.; Therefore. --> No explicit attempt should be made to normalize; the functions output in evaluate(). In addition, RooAbsPdf objects do not have a static concept of what; variables are parameters and what variables are dependents (which; need to be integrated over for a correct PDF normalization).; Instead the choice of normalization is always specified each time a; normalized values is requested from the PDF via the getVal(); method. RooAbsPdf manages the entire normalization logic of each PDF with; help of a RooRealIntegral object, which coordinates the integration; of a given choice of normalization. By default, RooRealIntegral will; perform a fully numeric integration of all dependents. However,; PDFs can advertise one or more (partial) analytical integrals of; their function, and these will be used by RooRealIntegral, if it; determines that this is safe (i.e. no hidden Jacobian terms,; multiplication with other PDFs that have one or more dependents in; commen etc). To implement analytical integrals, two functions must be implemented. First,. Int_t getAnalyticalIntegral(const RooArgSet& integSet, RooArgSet& anaIntSet). advertises the analytical integrals that are supported. 'integSet'; is the set of dependents for which integration is requested. The; function should copy the subset of dependents it can analytically; integrate to anaIntSet and return a unique identification code for; this integration configuration. If no integration can be; performed, zero should be returned. Second,. Double_t an",MatchSource.WIKI,root/html602/RooAbsPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsPdf.html
https://root.cern/root/html602/RooAbsPdf.html:1877,Deployability,integrat,integration,1877," is more than a; PDF: it can be a building block for a more complex, composite PDF; if any of its variables are functions instead of variables. In; such cases the normalization of the composite may not be simply the; integral over the dependents of the top level PDF as these are; functions with potentially non-trivial Jacobian terms themselves.; Therefore. --> No explicit attempt should be made to normalize; the functions output in evaluate(). In addition, RooAbsPdf objects do not have a static concept of what; variables are parameters and what variables are dependents (which; need to be integrated over for a correct PDF normalization).; Instead the choice of normalization is always specified each time a; normalized values is requested from the PDF via the getVal(); method. RooAbsPdf manages the entire normalization logic of each PDF with; help of a RooRealIntegral object, which coordinates the integration; of a given choice of normalization. By default, RooRealIntegral will; perform a fully numeric integration of all dependents. However,; PDFs can advertise one or more (partial) analytical integrals of; their function, and these will be used by RooRealIntegral, if it; determines that this is safe (i.e. no hidden Jacobian terms,; multiplication with other PDFs that have one or more dependents in; commen etc). To implement analytical integrals, two functions must be implemented. First,. Int_t getAnalyticalIntegral(const RooArgSet& integSet, RooArgSet& anaIntSet). advertises the analytical integrals that are supported. 'integSet'; is the set of dependents for which integration is requested. The; function should copy the subset of dependents it can analytically; integrate to anaIntSet and return a unique identification code for; this integration configuration. If no integration can be; performed, zero should be returned. Second,. Double_t analyticalIntegral(Int_t code). Implements the actual analytical integral(s) advertised by; getAnalyticalIntegral. This functions wil",MatchSource.WIKI,root/html602/RooAbsPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsPdf.html
https://root.cern/root/html602/RooAbsPdf.html:2452,Deployability,integrat,integration,2452,"hich; need to be integrated over for a correct PDF normalization).; Instead the choice of normalization is always specified each time a; normalized values is requested from the PDF via the getVal(); method. RooAbsPdf manages the entire normalization logic of each PDF with; help of a RooRealIntegral object, which coordinates the integration; of a given choice of normalization. By default, RooRealIntegral will; perform a fully numeric integration of all dependents. However,; PDFs can advertise one or more (partial) analytical integrals of; their function, and these will be used by RooRealIntegral, if it; determines that this is safe (i.e. no hidden Jacobian terms,; multiplication with other PDFs that have one or more dependents in; commen etc). To implement analytical integrals, two functions must be implemented. First,. Int_t getAnalyticalIntegral(const RooArgSet& integSet, RooArgSet& anaIntSet). advertises the analytical integrals that are supported. 'integSet'; is the set of dependents for which integration is requested. The; function should copy the subset of dependents it can analytically; integrate to anaIntSet and return a unique identification code for; this integration configuration. If no integration can be; performed, zero should be returned. Second,. Double_t analyticalIntegral(Int_t code). Implements the actual analytical integral(s) advertised by; getAnalyticalIntegral. This functions will only be called with; codes returned by getAnalyticalIntegral, except code zero. The integration range for real each dependent to be integrated can; be obtained from the dependents' proxy functions min() and; max(). Never call these proxy functions for any proxy not known to; be a dependent via the integration code. Doing so may be; ill-defined, e.g. in case the proxy holds a function, and will; trigger an assert. Integrated category dependents should always be; summed over all of their states. [Direct generation of observables]. Any PDF dependent can be generated with t",MatchSource.WIKI,root/html602/RooAbsPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsPdf.html
https://root.cern/root/html602/RooAbsPdf.html:2550,Deployability,integrat,integrate,2550," each time a; normalized values is requested from the PDF via the getVal(); method. RooAbsPdf manages the entire normalization logic of each PDF with; help of a RooRealIntegral object, which coordinates the integration; of a given choice of normalization. By default, RooRealIntegral will; perform a fully numeric integration of all dependents. However,; PDFs can advertise one or more (partial) analytical integrals of; their function, and these will be used by RooRealIntegral, if it; determines that this is safe (i.e. no hidden Jacobian terms,; multiplication with other PDFs that have one or more dependents in; commen etc). To implement analytical integrals, two functions must be implemented. First,. Int_t getAnalyticalIntegral(const RooArgSet& integSet, RooArgSet& anaIntSet). advertises the analytical integrals that are supported. 'integSet'; is the set of dependents for which integration is requested. The; function should copy the subset of dependents it can analytically; integrate to anaIntSet and return a unique identification code for; this integration configuration. If no integration can be; performed, zero should be returned. Second,. Double_t analyticalIntegral(Int_t code). Implements the actual analytical integral(s) advertised by; getAnalyticalIntegral. This functions will only be called with; codes returned by getAnalyticalIntegral, except code zero. The integration range for real each dependent to be integrated can; be obtained from the dependents' proxy functions min() and; max(). Never call these proxy functions for any proxy not known to; be a dependent via the integration code. Doing so may be; ill-defined, e.g. in case the proxy holds a function, and will; trigger an assert. Integrated category dependents should always be; summed over all of their states. [Direct generation of observables]. Any PDF dependent can be generated with the accept/reject method,; but for certain PDFs more efficient methods may be implemented. To; implement direct generation ",MatchSource.WIKI,root/html602/RooAbsPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsPdf.html
https://root.cern/root/html602/RooAbsPdf.html:2623,Deployability,integrat,integration,2623," each time a; normalized values is requested from the PDF via the getVal(); method. RooAbsPdf manages the entire normalization logic of each PDF with; help of a RooRealIntegral object, which coordinates the integration; of a given choice of normalization. By default, RooRealIntegral will; perform a fully numeric integration of all dependents. However,; PDFs can advertise one or more (partial) analytical integrals of; their function, and these will be used by RooRealIntegral, if it; determines that this is safe (i.e. no hidden Jacobian terms,; multiplication with other PDFs that have one or more dependents in; commen etc). To implement analytical integrals, two functions must be implemented. First,. Int_t getAnalyticalIntegral(const RooArgSet& integSet, RooArgSet& anaIntSet). advertises the analytical integrals that are supported. 'integSet'; is the set of dependents for which integration is requested. The; function should copy the subset of dependents it can analytically; integrate to anaIntSet and return a unique identification code for; this integration configuration. If no integration can be; performed, zero should be returned. Second,. Double_t analyticalIntegral(Int_t code). Implements the actual analytical integral(s) advertised by; getAnalyticalIntegral. This functions will only be called with; codes returned by getAnalyticalIntegral, except code zero. The integration range for real each dependent to be integrated can; be obtained from the dependents' proxy functions min() and; max(). Never call these proxy functions for any proxy not known to; be a dependent via the integration code. Doing so may be; ill-defined, e.g. in case the proxy holds a function, and will; trigger an assert. Integrated category dependents should always be; summed over all of their states. [Direct generation of observables]. Any PDF dependent can be generated with the accept/reject method,; but for certain PDFs more efficient methods may be implemented. To; implement direct generation ",MatchSource.WIKI,root/html602/RooAbsPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsPdf.html
https://root.cern/root/html602/RooAbsPdf.html:2635,Deployability,configurat,configuration,2635," each time a; normalized values is requested from the PDF via the getVal(); method. RooAbsPdf manages the entire normalization logic of each PDF with; help of a RooRealIntegral object, which coordinates the integration; of a given choice of normalization. By default, RooRealIntegral will; perform a fully numeric integration of all dependents. However,; PDFs can advertise one or more (partial) analytical integrals of; their function, and these will be used by RooRealIntegral, if it; determines that this is safe (i.e. no hidden Jacobian terms,; multiplication with other PDFs that have one or more dependents in; commen etc). To implement analytical integrals, two functions must be implemented. First,. Int_t getAnalyticalIntegral(const RooArgSet& integSet, RooArgSet& anaIntSet). advertises the analytical integrals that are supported. 'integSet'; is the set of dependents for which integration is requested. The; function should copy the subset of dependents it can analytically; integrate to anaIntSet and return a unique identification code for; this integration configuration. If no integration can be; performed, zero should be returned. Second,. Double_t analyticalIntegral(Int_t code). Implements the actual analytical integral(s) advertised by; getAnalyticalIntegral. This functions will only be called with; codes returned by getAnalyticalIntegral, except code zero. The integration range for real each dependent to be integrated can; be obtained from the dependents' proxy functions min() and; max(). Never call these proxy functions for any proxy not known to; be a dependent via the integration code. Doing so may be; ill-defined, e.g. in case the proxy holds a function, and will; trigger an assert. Integrated category dependents should always be; summed over all of their states. [Direct generation of observables]. Any PDF dependent can be generated with the accept/reject method,; but for certain PDFs more efficient methods may be implemented. To; implement direct generation ",MatchSource.WIKI,root/html602/RooAbsPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsPdf.html
https://root.cern/root/html602/RooAbsPdf.html:2656,Deployability,integrat,integration,2656,"alization logic of each PDF with; help of a RooRealIntegral object, which coordinates the integration; of a given choice of normalization. By default, RooRealIntegral will; perform a fully numeric integration of all dependents. However,; PDFs can advertise one or more (partial) analytical integrals of; their function, and these will be used by RooRealIntegral, if it; determines that this is safe (i.e. no hidden Jacobian terms,; multiplication with other PDFs that have one or more dependents in; commen etc). To implement analytical integrals, two functions must be implemented. First,. Int_t getAnalyticalIntegral(const RooArgSet& integSet, RooArgSet& anaIntSet). advertises the analytical integrals that are supported. 'integSet'; is the set of dependents for which integration is requested. The; function should copy the subset of dependents it can analytically; integrate to anaIntSet and return a unique identification code for; this integration configuration. If no integration can be; performed, zero should be returned. Second,. Double_t analyticalIntegral(Int_t code). Implements the actual analytical integral(s) advertised by; getAnalyticalIntegral. This functions will only be called with; codes returned by getAnalyticalIntegral, except code zero. The integration range for real each dependent to be integrated can; be obtained from the dependents' proxy functions min() and; max(). Never call these proxy functions for any proxy not known to; be a dependent via the integration code. Doing so may be; ill-defined, e.g. in case the proxy holds a function, and will; trigger an assert. Integrated category dependents should always be; summed over all of their states. [Direct generation of observables]. Any PDF dependent can be generated with the accept/reject method,; but for certain PDFs more efficient methods may be implemented. To; implement direct generation of one or more observables, two; functions need to be implemented, similar to those for analytical; integrals:. Int_t",MatchSource.WIKI,root/html602/RooAbsPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsPdf.html
https://root.cern/root/html602/RooAbsPdf.html:2949,Deployability,integrat,integration,2949,"ill be used by RooRealIntegral, if it; determines that this is safe (i.e. no hidden Jacobian terms,; multiplication with other PDFs that have one or more dependents in; commen etc). To implement analytical integrals, two functions must be implemented. First,. Int_t getAnalyticalIntegral(const RooArgSet& integSet, RooArgSet& anaIntSet). advertises the analytical integrals that are supported. 'integSet'; is the set of dependents for which integration is requested. The; function should copy the subset of dependents it can analytically; integrate to anaIntSet and return a unique identification code for; this integration configuration. If no integration can be; performed, zero should be returned. Second,. Double_t analyticalIntegral(Int_t code). Implements the actual analytical integral(s) advertised by; getAnalyticalIntegral. This functions will only be called with; codes returned by getAnalyticalIntegral, except code zero. The integration range for real each dependent to be integrated can; be obtained from the dependents' proxy functions min() and; max(). Never call these proxy functions for any proxy not known to; be a dependent via the integration code. Doing so may be; ill-defined, e.g. in case the proxy holds a function, and will; trigger an assert. Integrated category dependents should always be; summed over all of their states. [Direct generation of observables]. Any PDF dependent can be generated with the accept/reject method,; but for certain PDFs more efficient methods may be implemented. To; implement direct generation of one or more observables, two; functions need to be implemented, similar to those for analytical; integrals:. Int_t getGenerator(const RooArgSet& generateVars, RooArgSet& directVars) and; void generateEvent(Int_t code). The first function advertises observables that can be generated,; similar to the way analytical integrals are advertised. The second; function implements the generator for the advertised observables. The generated dependent val",MatchSource.WIKI,root/html602/RooAbsPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsPdf.html
https://root.cern/root/html602/RooAbsPdf.html:2997,Deployability,integrat,integrated,2997,"ill be used by RooRealIntegral, if it; determines that this is safe (i.e. no hidden Jacobian terms,; multiplication with other PDFs that have one or more dependents in; commen etc). To implement analytical integrals, two functions must be implemented. First,. Int_t getAnalyticalIntegral(const RooArgSet& integSet, RooArgSet& anaIntSet). advertises the analytical integrals that are supported. 'integSet'; is the set of dependents for which integration is requested. The; function should copy the subset of dependents it can analytically; integrate to anaIntSet and return a unique identification code for; this integration configuration. If no integration can be; performed, zero should be returned. Second,. Double_t analyticalIntegral(Int_t code). Implements the actual analytical integral(s) advertised by; getAnalyticalIntegral. This functions will only be called with; codes returned by getAnalyticalIntegral, except code zero. The integration range for real each dependent to be integrated can; be obtained from the dependents' proxy functions min() and; max(). Never call these proxy functions for any proxy not known to; be a dependent via the integration code. Doing so may be; ill-defined, e.g. in case the proxy holds a function, and will; trigger an assert. Integrated category dependents should always be; summed over all of their states. [Direct generation of observables]. Any PDF dependent can be generated with the accept/reject method,; but for certain PDFs more efficient methods may be implemented. To; implement direct generation of one or more observables, two; functions need to be implemented, similar to those for analytical; integrals:. Int_t getGenerator(const RooArgSet& generateVars, RooArgSet& directVars) and; void generateEvent(Int_t code). The first function advertises observables that can be generated,; similar to the way analytical integrals are advertised. The second; function implements the generator for the advertised observables. The generated dependent val",MatchSource.WIKI,root/html602/RooAbsPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsPdf.html
https://root.cern/root/html602/RooAbsPdf.html:3164,Deployability,integrat,integration,3164,"h other PDFs that have one or more dependents in; commen etc). To implement analytical integrals, two functions must be implemented. First,. Int_t getAnalyticalIntegral(const RooArgSet& integSet, RooArgSet& anaIntSet). advertises the analytical integrals that are supported. 'integSet'; is the set of dependents for which integration is requested. The; function should copy the subset of dependents it can analytically; integrate to anaIntSet and return a unique identification code for; this integration configuration. If no integration can be; performed, zero should be returned. Second,. Double_t analyticalIntegral(Int_t code). Implements the actual analytical integral(s) advertised by; getAnalyticalIntegral. This functions will only be called with; codes returned by getAnalyticalIntegral, except code zero. The integration range for real each dependent to be integrated can; be obtained from the dependents' proxy functions min() and; max(). Never call these proxy functions for any proxy not known to; be a dependent via the integration code. Doing so may be; ill-defined, e.g. in case the proxy holds a function, and will; trigger an assert. Integrated category dependents should always be; summed over all of their states. [Direct generation of observables]. Any PDF dependent can be generated with the accept/reject method,; but for certain PDFs more efficient methods may be implemented. To; implement direct generation of one or more observables, two; functions need to be implemented, similar to those for analytical; integrals:. Int_t getGenerator(const RooArgSet& generateVars, RooArgSet& directVars) and; void generateEvent(Int_t code). The first function advertises observables that can be generated,; similar to the way analytical integrals are advertised. The second; function implements the generator for the advertised observables. The generated dependent values should be store in the proxy; objects. For this the assignment operator can be used (i.e. xProxy; = 3.0 ). Never c",MatchSource.WIKI,root/html602/RooAbsPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsPdf.html
https://root.cern/root/html602/RooAbsPdf.html:45029,Deployability,integrat,integration,45029,"boolAttribBoolean attributes; set<string>RooAbsArg::_boolAttribTransient! Transient boolean attributes (not copied in ctor); Bool_tRooAbsReal::_boolValue! Transient cache for bool values from tree branches; UChar_tRooAbsReal::_byteValue! Transient cache for byte values from tree branches; static Bool_tRooAbsReal::_cacheCheckIf true, always validate contents of clean which outcome of evaluate(); deque<RooAbsCache*>RooAbsArg::_cacheListlist of caches; RooRefCountListRooAbsArg::_clientListlist of client objects; RooRefCountListRooAbsArg::_clientListShapesubset of clients that requested shape dirty flag propagation; RooRefCountListRooAbsArg::_clientListValuesubset of clients that requested value dirty flag propagation; TIterator*RooAbsArg::_clientShapeIter! Iterator over _clientListShape; TIterator*RooAbsArg::_clientValueIter! Iterator over _clientListValue; Bool_tRooAbsArg::_deleteWatch! Delete watch flag; RooExpensiveObjectCache*RooAbsArg::_eocachePointer to global cache manager for any expensive components created by this object; Int_t_errorCountNumber of errors remaining to print; static Bool_t_evalError; Bool_tRooAbsArg::_fastAllow fast access mode in getVal() and proxies; Float_tRooAbsReal::_floatValue! Transient cache for floating point values from tree branches; Bool_tRooAbsReal::_forceNumIntForce numerical integration if flag set; static Bool_tRooAbsReal::_globalSelectCompGlobal activation switch for component selection; static Bool_tRooAbsReal::_hideOffsetOffset hiding flag; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; Int_tRooAbsReal::_intValue! Transient cache for integer values from tree branches; Bool_tRooAbsArg::_isConstant! Cached isConstant status; TStringRooAbsReal::_labelPlot label for objects value; RooArgSet*RooAbsReal::_lastNSet!; Bool_tRooAbsArg::_localNoInhibitDirty! Prevent 'AlwaysDirty' mode for this node; static Int_tRooPrintable::_nameLength; TNamed*RooAbsArg::_namePtr! Do not persist.",MatchSource.WIKI,root/html602/RooAbsPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsPdf.html
https://root.cern/root/html602/RooAbsPdf.html:46957,Deployability,configurat,configuration,46957,"t_t_negCountNumber of negative probablities remaining to print; RooAbsReal*_norm! Normalization integral (owned by _normMgr); RooObjCacheManager_normMgrThe cache manager; TString_normRangeNormalization range; static TString_normRangeOverride; RooArgSet*_normSet! Normalization set with for above integral; RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; Int_tRooAbsReal::_plotBinsNumber of plot bins; Double_tRooAbsReal::_plotMaxMaximum of plot range; Double_tRooAbsReal::_plotMinMinimum of plot range; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; RooRefArrayRooAbsArg::_proxyListlist of proxies; Double_t_rawValue; Char_tRooAbsReal::_sbyteValue! Transient cache for signed byte values from tree branches; Bool_t_selectCompComponent selection flag for RooAbsPdf::plotCompOn; Bool_tRooAbsReal::_selectComp! Component selection flag for RooAbsPdf::plotCompOn; RooRefCountListRooAbsArg::_serverListlist of server objects; Bool_tRooAbsArg::_shapeDirtyFlag set if value needs recalculating because input shapes modified; RooNumGenConfig*_specGeneratorConfig! MC generator configuration specific for this object; RooNumIntConfig*RooAbsReal::_specIntegratorConfigNumeric integrator configuration specific for this object; map<string,string>RooAbsArg::_stringAttribString attributes; Int_t_traceCountNumber of traces remaining to print; Bool_tRooAbsReal::_treeVar!do not persist; UInt_tRooAbsReal::_uintValue! Transient cache for unsigned integer values from tree branches; TStringRooAbsReal::_unitUnit for objects value; Double_tRooAbsReal::_valueCache for current value of object; Bool_tRooAbsArg::_valueDirtyFlag set if value needs recalculating because input values modified; static Bool_tRooAbsArg::_verboseDirtyStatic flag controlling verbose messaging for dirty state changes; static Int_t_verboseEval; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title.",MatchSource.WIKI,root/html602/RooAbsPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsPdf.html
https://root.cern/root/html602/RooAbsPdf.html:47054,Deployability,integrat,integrator,47054,"t_t_negCountNumber of negative probablities remaining to print; RooAbsReal*_norm! Normalization integral (owned by _normMgr); RooObjCacheManager_normMgrThe cache manager; TString_normRangeNormalization range; static TString_normRangeOverride; RooArgSet*_normSet! Normalization set with for above integral; RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; Int_tRooAbsReal::_plotBinsNumber of plot bins; Double_tRooAbsReal::_plotMaxMaximum of plot range; Double_tRooAbsReal::_plotMinMinimum of plot range; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; RooRefArrayRooAbsArg::_proxyListlist of proxies; Double_t_rawValue; Char_tRooAbsReal::_sbyteValue! Transient cache for signed byte values from tree branches; Bool_t_selectCompComponent selection flag for RooAbsPdf::plotCompOn; Bool_tRooAbsReal::_selectComp! Component selection flag for RooAbsPdf::plotCompOn; RooRefCountListRooAbsArg::_serverListlist of server objects; Bool_tRooAbsArg::_shapeDirtyFlag set if value needs recalculating because input shapes modified; RooNumGenConfig*_specGeneratorConfig! MC generator configuration specific for this object; RooNumIntConfig*RooAbsReal::_specIntegratorConfigNumeric integrator configuration specific for this object; map<string,string>RooAbsArg::_stringAttribString attributes; Int_t_traceCountNumber of traces remaining to print; Bool_tRooAbsReal::_treeVar!do not persist; UInt_tRooAbsReal::_uintValue! Transient cache for unsigned integer values from tree branches; TStringRooAbsReal::_unitUnit for objects value; Double_tRooAbsReal::_valueCache for current value of object; Bool_tRooAbsArg::_valueDirtyFlag set if value needs recalculating because input values modified; static Bool_tRooAbsArg::_verboseDirtyStatic flag controlling verbose messaging for dirty state changes; static Int_t_verboseEval; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title.",MatchSource.WIKI,root/html602/RooAbsPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsPdf.html
https://root.cern/root/html602/RooAbsPdf.html:47065,Deployability,configurat,configuration,47065,"t_t_negCountNumber of negative probablities remaining to print; RooAbsReal*_norm! Normalization integral (owned by _normMgr); RooObjCacheManager_normMgrThe cache manager; TString_normRangeNormalization range; static TString_normRangeOverride; RooArgSet*_normSet! Normalization set with for above integral; RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; Int_tRooAbsReal::_plotBinsNumber of plot bins; Double_tRooAbsReal::_plotMaxMaximum of plot range; Double_tRooAbsReal::_plotMinMinimum of plot range; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; RooRefArrayRooAbsArg::_proxyListlist of proxies; Double_t_rawValue; Char_tRooAbsReal::_sbyteValue! Transient cache for signed byte values from tree branches; Bool_t_selectCompComponent selection flag for RooAbsPdf::plotCompOn; Bool_tRooAbsReal::_selectComp! Component selection flag for RooAbsPdf::plotCompOn; RooRefCountListRooAbsArg::_serverListlist of server objects; Bool_tRooAbsArg::_shapeDirtyFlag set if value needs recalculating because input shapes modified; RooNumGenConfig*_specGeneratorConfig! MC generator configuration specific for this object; RooNumIntConfig*RooAbsReal::_specIntegratorConfigNumeric integrator configuration specific for this object; map<string,string>RooAbsArg::_stringAttribString attributes; Int_t_traceCountNumber of traces remaining to print; Bool_tRooAbsReal::_treeVar!do not persist; UInt_tRooAbsReal::_uintValue! Transient cache for unsigned integer values from tree branches; TStringRooAbsReal::_unitUnit for objects value; Double_tRooAbsReal::_valueCache for current value of object; Bool_tRooAbsArg::_valueDirtyFlag set if value needs recalculating because input values modified; static Bool_tRooAbsArg::_verboseDirtyStatic flag controlling verbose messaging for dirty state changes; static Int_t_verboseEval; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title.",MatchSource.WIKI,root/html602/RooAbsPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsPdf.html
https://root.cern/root/html602/RooAbsPdf.html:48298,Deployability,integrat,integrating,48298,"eal::_uintValue! Transient cache for unsigned integer values from tree branches; TStringRooAbsReal::_unitUnit for objects value; Double_tRooAbsReal::_valueCache for current value of object; Bool_tRooAbsArg::_valueDirtyFlag set if value needs recalculating because input values modified; static Bool_tRooAbsArg::_verboseDirtyStatic flag controlling verbose messaging for dirty state changes; static Int_t_verboseEval; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; RooAbsPdf(); Default constructor. RooAbsPdf(const char* name, const char* title = 0); Constructor with name and title only. RooAbsPdf(const char* name, const char* title, Double_t minVal, Double_t maxVal); Constructor with name, title, and plot range. RooAbsPdf(const RooAbsPdf& other, const char* name = 0); Copy constructor. ~RooAbsPdf(); Destructor. Double_t getValV(const RooArgSet* set = 0) const; Return current value, normalizated by integrating over; the observables in 'nset'. If 'nset' is 0, the unnormalized value.; is returned. All elements of 'nset' must be lvalues. Unnormalized values are not cached; Doing so would be complicated as _norm->getVal() could; spoil the cache and interfere with returning the cached; return value. Since unnormalized calls are typically; done in integration calls, there is no performance hit. Double_t analyticalIntegralWN(Int_t code, const RooArgSet* normSet, const char* rangeName = 0) const; Analytical integral with normalization (see RooAbsReal::analyticalIntegralWN() for further information). This function applies the normalization specified by 'normSet' to the integral returned; by RooAbsReal::analyticalIntegral(). The passthrough scenario (code=0) is also changed; to return a normalized answer. Bool_t traceEvalPdf(Double_t value) const; Check that passed value is positive and not 'not-a-number'. If; not, print an error, until the error counter reaches its s",MatchSource.WIKI,root/html602/RooAbsPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsPdf.html
https://root.cern/root/html602/RooAbsPdf.html:48648,Deployability,integrat,integration,48648,"rty state changes; static Int_t_verboseEval; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; RooAbsPdf(); Default constructor. RooAbsPdf(const char* name, const char* title = 0); Constructor with name and title only. RooAbsPdf(const char* name, const char* title, Double_t minVal, Double_t maxVal); Constructor with name, title, and plot range. RooAbsPdf(const RooAbsPdf& other, const char* name = 0); Copy constructor. ~RooAbsPdf(); Destructor. Double_t getValV(const RooArgSet* set = 0) const; Return current value, normalizated by integrating over; the observables in 'nset'. If 'nset' is 0, the unnormalized value.; is returned. All elements of 'nset' must be lvalues. Unnormalized values are not cached; Doing so would be complicated as _norm->getVal() could; spoil the cache and interfere with returning the cached; return value. Since unnormalized calls are typically; done in integration calls, there is no performance hit. Double_t analyticalIntegralWN(Int_t code, const RooArgSet* normSet, const char* rangeName = 0) const; Analytical integral with normalization (see RooAbsReal::analyticalIntegralWN() for further information). This function applies the normalization specified by 'normSet' to the integral returned; by RooAbsReal::analyticalIntegral(). The passthrough scenario (code=0) is also changed; to return a normalized answer. Bool_t traceEvalPdf(Double_t value) const; Check that passed value is positive and not 'not-a-number'. If; not, print an error, until the error counter reaches its set; maximum. Double_t getNorm(const RooArgSet* set = 0) const; Return the integral of this PDF over all observables listed in 'nset'. const RooAbsReal* getNormObj(const RooArgSet* set, const RooArgSet* iset, const TNamed* rangeName = 0) const; Return pointer to RooAbsReal object that implements calculation of integral over observables iset in range; rangeName, optional",MatchSource.WIKI,root/html602/RooAbsPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsPdf.html
https://root.cern/root/html602/RooAbsPdf.html:65289,Deployability,deploy,deploy,65289,"ataSet * generate(const RooArgSet& whatVars, Int_t nEvents, const RooCmdArg& arg1, const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none()); Generate a new dataset containing the specified variables with events sampled from our distribution.; Generate the specified number of events or expectedEvents() if not specified. Any variables of this PDF that are not in whatVars will use their; current values and be treated as fixed parameters. Returns zero; in case of an error. The caller takes ownership of the returned; dataset. The following named arguments are supported. Name(const char* name) -- Name of the output dataset; Verbose(Bool_t flag) -- Print informational messages during event generation; Extended() -- The actual number of events generated will be sampled from a Poisson distribution; with mu=nevt. For use with extended maximum likelihood fits; AutoBinned(Bool_t flag) -- Automatically deploy binned generation for binned distributions (e.g. RooHistPdf, sums and products of RooHistPdfs etc); NB: Datasets that are generated in binned mode are returned as weighted unbinned datasets. GenBinned(const char* tag) -- Use binned generation for all component pdfs that have 'setAttribute(tag)' set; AllBinned() -- As above, but for all components. Note that the notion of components is only meaningful for simultaneous pdf; as binned generation is always executed at the top-level node for a regular; pdf, so for those it only mattes that the top-level node is tagged. ProtoData(const RooDataSet& data, -- Use specified dataset as prototype dataset. If randOrder is set to true; Bool_t randOrder) the order of the events in the dataset will be read in a random order; if the requested number of events to be generated does not match the; number of events in the prototype dataset. If ProtoData() is used, the specified existing dataset as a prototype: the new dataset will ",MatchSource.WIKI,root/html602/RooAbsPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsPdf.html
https://root.cern/root/html602/RooAbsPdf.html:67755,Deployability,deploy,deploy,67755," the generated dataset. RooDataSet * generate(const RooArgSet& whatVars, const RooCmdArg& arg1 = RooCmdArg::none(), const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none()); Generate a new dataset containing the specified variables with events sampled from our distribution.; Generate the specified number of events or expectedEvents() if not specified. Any variables of this PDF that are not in whatVars will use their; current values and be treated as fixed parameters. Returns zero; in case of an error. The caller takes ownership of the returned; dataset. The following named arguments are supported. Name(const char* name) -- Name of the output dataset; Verbose(Bool_t flag) -- Print informational messages during event generation; NumEvent(int nevt) -- Generate specified number of events. AutoBinned(Bool_t flag) -- Automatically deploy binned generation for binned distributions (e.g. RooHistPdf, sums and products of RooHistPdfs etc); NB: Datasets that are generated in binned mode are returned as weighted unbinned datasets. GenBinned(const char* tag) -- Use binned generation for all component pdfs that have 'setAttribute(tag)' set; AllBinned() -- As above, but for all components. Note that the notion of components is only meaningful for simultaneous pdf; as binned generation is always executed at the top-level node for a regular; pdf, so for those it only mattes that the top-level node is tagged. Binned generation cannot be used when prototype data is supplied; Extended() -- The actual number of events generated will be sampled from a Poisson distribution; with mu=nevt. For use with extended maximum likelihood fits; ProtoData(const RooDataSet& data, -- Use specified dataset as prototype dataset. If randOrder is set to true; Bool_t randOrder, the order of the events in the dataset will be read in a random order; Bool_",MatchSource.WIKI,root/html602/RooAbsPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsPdf.html
https://root.cern/root/html602/RooAbsPdf.html:77058,Deployability,integrat,integrated,77058," Generate the specified; number of events or else try to use expectedEvents() if nEvents <= 0. If expectedData is kTRUE (it is kFALSE by default), the returned histogram returns the 'expected'; data sample, i.e. no statistical fluctuations are present. Any variables of this PDF that are not in whatVars will use their; current values and be treated as fixed parameters. Returns zero; in case of an error. The caller takes ownership of the returned; dataset. RooDataSet* generateSimGlobal(const RooArgSet& whatVars, Int_t nEvents); Special generator interface for generation of 'global observables' -- for RooStats tools. RooPlot* plotOn(RooPlot* frame, RooLinkedList& cmdList) const; Plot (project) PDF on specified frame. If a PDF is plotted in an empty frame, it; will show a unit normalized curve in the frame variable, taken at the present value; of other observables defined for this PDF. If a PDF is plotted in a frame in which a dataset has already been plotted, it will; show a projected curve integrated over all variables that were present in the shown; dataset except for the one on the x-axis. The normalization of the curve will also; be adjusted to the event count of the plotted dataset. An informational message; will be printed for each projection step that is performed. This function takes the following named arguments. Projection control. Slice(const RooArgSet& set) -- Override default projection behaviour by omittting observables listed; in set from the projection, resulting a 'slice' plot. Slicing is usually; only sensible in discrete observables; Project(const RooArgSet& set) -- Override default projection behaviour by projecting over observables; given in set and complete ignoring the default projection behavior. Advanced use only.; ProjWData(const RooAbsData& d) -- Override default projection _technique_ (integration). For observables present in given dataset; projection of PDF is achieved by constructing an average over all observable values in given set.; Con",MatchSource.WIKI,root/html602/RooAbsPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsPdf.html
https://root.cern/root/html602/RooAbsPdf.html:77897,Deployability,integrat,integration,77897,"ame variable, taken at the present value; of other observables defined for this PDF. If a PDF is plotted in a frame in which a dataset has already been plotted, it will; show a projected curve integrated over all variables that were present in the shown; dataset except for the one on the x-axis. The normalization of the curve will also; be adjusted to the event count of the plotted dataset. An informational message; will be printed for each projection step that is performed. This function takes the following named arguments. Projection control. Slice(const RooArgSet& set) -- Override default projection behaviour by omittting observables listed; in set from the projection, resulting a 'slice' plot. Slicing is usually; only sensible in discrete observables; Project(const RooArgSet& set) -- Override default projection behaviour by projecting over observables; given in set and complete ignoring the default projection behavior. Advanced use only.; ProjWData(const RooAbsData& d) -- Override default projection _technique_ (integration). For observables present in given dataset; projection of PDF is achieved by constructing an average over all observable values in given set.; Consult RooFit plotting tutorial for further explanation of meaning & use of this technique; ProjWData(const RooArgSet& s, -- As above but only consider subset 's' of observables in dataset 'd' for projection through data averaging; const RooAbsData& d); ProjectionRange(const char* rn) -- Override default range of projection integrals to a different range speficied by given range name.; This technique allows you to project a finite width slice in a real-valued observable; NormRange(const char* name) -- Calculate curve normalization w.r.t. only in specified ranges. NB: A Range() by default implies a NormRange(); on the same range, but this option allows to override the default, or specify a normalization ranges; when the full curve is to be drawn. Misc content control. Normalization(Double_t scale, -- A",MatchSource.WIKI,root/html602/RooAbsPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsPdf.html
https://root.cern/root/html602/RooAbsPdf.html:84707,Deployability,integrat,integrated,84707,"000000000000002, Double_t xmax = 0.98999999999999999, Double_t ymax = 0.94999999999999996, const RooCmdArg* formatCmd = 0); Add a text box with the current parameter values and their errors to the frame.; Observables of this PDF appearing in the 'data' dataset will be omitted. Optional label will be inserted as first line of the text box. Use 'sigDigits'; to modify the default number of significant digits printed. The 'xmin,xmax,ymax'; values specify the inital relative position of the text box in the plot frame. Double_t expectedEvents(const RooArgSet* nset) const; Return expected number of events from this p.d.f for use in extended; likelihood calculations. This default implementation returns zero. void verboseEval(Int_t stat); Change global level of verbosity for p.d.f. evaluations. Int_t verboseEval(); Return global level of verbosity for p.d.f. evaluations. RooAbsPdf* createProjection(const RooArgSet& iset); Return a p.d.f that represent a projection of this p.d.f integrated over given observables. RooAbsReal* createCdf(const RooArgSet& iset, const RooArgSet& nset = RooArgSet()); Create a cumulative distribution function of this p.d.f in terms; of the observables listed in iset. If no nset argument is given; the c.d.f normalization is constructed over the integrated; observables, so that its maximum value is precisely 1. It is also; possible to choose a different normalization for; multi-dimensional p.d.f.s: eg. for a pdf f(x,y,z) one can; construct a partial cdf c(x,y) that only when integrated itself; over z results in a maximum value of 1. To construct such a cdf pass; z as argument to the optional nset argument. RooAbsReal* createCdf(const RooArgSet& iset, const RooCmdArg& arg1, const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = R",MatchSource.WIKI,root/html602/RooAbsPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsPdf.html
https://root.cern/root/html602/RooAbsPdf.html:85004,Deployability,integrat,integrated,85004,"ill be inserted as first line of the text box. Use 'sigDigits'; to modify the default number of significant digits printed. The 'xmin,xmax,ymax'; values specify the inital relative position of the text box in the plot frame. Double_t expectedEvents(const RooArgSet* nset) const; Return expected number of events from this p.d.f for use in extended; likelihood calculations. This default implementation returns zero. void verboseEval(Int_t stat); Change global level of verbosity for p.d.f. evaluations. Int_t verboseEval(); Return global level of verbosity for p.d.f. evaluations. RooAbsPdf* createProjection(const RooArgSet& iset); Return a p.d.f that represent a projection of this p.d.f integrated over given observables. RooAbsReal* createCdf(const RooArgSet& iset, const RooArgSet& nset = RooArgSet()); Create a cumulative distribution function of this p.d.f in terms; of the observables listed in iset. If no nset argument is given; the c.d.f normalization is constructed over the integrated; observables, so that its maximum value is precisely 1. It is also; possible to choose a different normalization for; multi-dimensional p.d.f.s: eg. for a pdf f(x,y,z) one can; construct a partial cdf c(x,y) that only when integrated itself; over z results in a maximum value of 1. To construct such a cdf pass; z as argument to the optional nset argument. RooAbsReal* createCdf(const RooArgSet& iset, const RooCmdArg& arg1, const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()); Create an object that represents the integral of the function over one or more observables listed in iset; The actual integration calculation is only performed when the return object is evaluated. The name; of the integral object is automatically constructed from the name of",MatchSource.WIKI,root/html602/RooAbsPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsPdf.html
https://root.cern/root/html602/RooAbsPdf.html:85238,Deployability,integrat,integrated,85238," plot frame. Double_t expectedEvents(const RooArgSet* nset) const; Return expected number of events from this p.d.f for use in extended; likelihood calculations. This default implementation returns zero. void verboseEval(Int_t stat); Change global level of verbosity for p.d.f. evaluations. Int_t verboseEval(); Return global level of verbosity for p.d.f. evaluations. RooAbsPdf* createProjection(const RooArgSet& iset); Return a p.d.f that represent a projection of this p.d.f integrated over given observables. RooAbsReal* createCdf(const RooArgSet& iset, const RooArgSet& nset = RooArgSet()); Create a cumulative distribution function of this p.d.f in terms; of the observables listed in iset. If no nset argument is given; the c.d.f normalization is constructed over the integrated; observables, so that its maximum value is precisely 1. It is also; possible to choose a different normalization for; multi-dimensional p.d.f.s: eg. for a pdf f(x,y,z) one can; construct a partial cdf c(x,y) that only when integrated itself; over z results in a maximum value of 1. To construct such a cdf pass; z as argument to the optional nset argument. RooAbsReal* createCdf(const RooArgSet& iset, const RooCmdArg& arg1, const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()); Create an object that represents the integral of the function over one or more observables listed in iset; The actual integration calculation is only performed when the return object is evaluated. The name; of the integral object is automatically constructed from the name of the input function, the variables; it integrates and the range integrates over. The following named arguments are accepted. SupNormSet(const RooArgSet&) -- Observables over which should be normalized _in_addition",MatchSource.WIKI,root/html602/RooAbsPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsPdf.html
https://root.cern/root/html602/RooAbsPdf.html:85860,Deployability,integrat,integration,85860,"rn a p.d.f that represent a projection of this p.d.f integrated over given observables. RooAbsReal* createCdf(const RooArgSet& iset, const RooArgSet& nset = RooArgSet()); Create a cumulative distribution function of this p.d.f in terms; of the observables listed in iset. If no nset argument is given; the c.d.f normalization is constructed over the integrated; observables, so that its maximum value is precisely 1. It is also; possible to choose a different normalization for; multi-dimensional p.d.f.s: eg. for a pdf f(x,y,z) one can; construct a partial cdf c(x,y) that only when integrated itself; over z results in a maximum value of 1. To construct such a cdf pass; z as argument to the optional nset argument. RooAbsReal* createCdf(const RooArgSet& iset, const RooCmdArg& arg1, const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()); Create an object that represents the integral of the function over one or more observables listed in iset; The actual integration calculation is only performed when the return object is evaluated. The name; of the integral object is automatically constructed from the name of the input function, the variables; it integrates and the range integrates over. The following named arguments are accepted. SupNormSet(const RooArgSet&) -- Observables over which should be normalized _in_addition_ to the; integration observables; ScanNumCdf() -- Apply scanning technique if cdf integral involves numeric integration [ default ]; ScanAllCdf() -- Always apply scanning technique; ScanNoCdf() -- Never apply scanning technique; ScanParameters(Int_t nbins, -- Parameters for scanning technique of making CDF: number; Int_t intOrder) of sampled bins and order of interpolation applied on numeric cdf. RooAbsReal* createScanCd",MatchSource.WIKI,root/html602/RooAbsPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsPdf.html
https://root.cern/root/html602/RooAbsPdf.html:86056,Deployability,integrat,integrates,86056,"bservables, so that its maximum value is precisely 1. It is also; possible to choose a different normalization for; multi-dimensional p.d.f.s: eg. for a pdf f(x,y,z) one can; construct a partial cdf c(x,y) that only when integrated itself; over z results in a maximum value of 1. To construct such a cdf pass; z as argument to the optional nset argument. RooAbsReal* createCdf(const RooArgSet& iset, const RooCmdArg& arg1, const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()); Create an object that represents the integral of the function over one or more observables listed in iset; The actual integration calculation is only performed when the return object is evaluated. The name; of the integral object is automatically constructed from the name of the input function, the variables; it integrates and the range integrates over. The following named arguments are accepted. SupNormSet(const RooArgSet&) -- Observables over which should be normalized _in_addition_ to the; integration observables; ScanNumCdf() -- Apply scanning technique if cdf integral involves numeric integration [ default ]; ScanAllCdf() -- Always apply scanning technique; ScanNoCdf() -- Never apply scanning technique; ScanParameters(Int_t nbins, -- Parameters for scanning technique of making CDF: number; Int_t intOrder) of sampled bins and order of interpolation applied on numeric cdf. RooAbsReal* createScanCdf(const RooArgSet& iset, const RooArgSet& nset, Int_t numScanBins, Int_t intOrder). RooArgSet* getAllConstraints(const RooArgSet& observables, RooArgSet& constrainedParams, Bool_t stripDisconnected = kTRUE) const; This helper function finds and collects all constraints terms of all coponent p.d.f.s; and returns a RooArgSet with all those terms. void clearEvalEr",MatchSource.WIKI,root/html602/RooAbsPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsPdf.html
https://root.cern/root/html602/RooAbsPdf.html:86081,Deployability,integrat,integrates,86081,"bservables, so that its maximum value is precisely 1. It is also; possible to choose a different normalization for; multi-dimensional p.d.f.s: eg. for a pdf f(x,y,z) one can; construct a partial cdf c(x,y) that only when integrated itself; over z results in a maximum value of 1. To construct such a cdf pass; z as argument to the optional nset argument. RooAbsReal* createCdf(const RooArgSet& iset, const RooCmdArg& arg1, const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()); Create an object that represents the integral of the function over one or more observables listed in iset; The actual integration calculation is only performed when the return object is evaluated. The name; of the integral object is automatically constructed from the name of the input function, the variables; it integrates and the range integrates over. The following named arguments are accepted. SupNormSet(const RooArgSet&) -- Observables over which should be normalized _in_addition_ to the; integration observables; ScanNumCdf() -- Apply scanning technique if cdf integral involves numeric integration [ default ]; ScanAllCdf() -- Always apply scanning technique; ScanNoCdf() -- Never apply scanning technique; ScanParameters(Int_t nbins, -- Parameters for scanning technique of making CDF: number; Int_t intOrder) of sampled bins and order of interpolation applied on numeric cdf. RooAbsReal* createScanCdf(const RooArgSet& iset, const RooArgSet& nset, Int_t numScanBins, Int_t intOrder). RooArgSet* getAllConstraints(const RooArgSet& observables, RooArgSet& constrainedParams, Bool_t stripDisconnected = kTRUE) const; This helper function finds and collects all constraints terms of all coponent p.d.f.s; and returns a RooArgSet with all those terms. void clearEvalEr",MatchSource.WIKI,root/html602/RooAbsPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsPdf.html
https://root.cern/root/html602/RooAbsPdf.html:86240,Deployability,integrat,integration,86240,"reateCdf(const RooArgSet& iset, const RooCmdArg& arg1, const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()); Create an object that represents the integral of the function over one or more observables listed in iset; The actual integration calculation is only performed when the return object is evaluated. The name; of the integral object is automatically constructed from the name of the input function, the variables; it integrates and the range integrates over. The following named arguments are accepted. SupNormSet(const RooArgSet&) -- Observables over which should be normalized _in_addition_ to the; integration observables; ScanNumCdf() -- Apply scanning technique if cdf integral involves numeric integration [ default ]; ScanAllCdf() -- Always apply scanning technique; ScanNoCdf() -- Never apply scanning technique; ScanParameters(Int_t nbins, -- Parameters for scanning technique of making CDF: number; Int_t intOrder) of sampled bins and order of interpolation applied on numeric cdf. RooAbsReal* createScanCdf(const RooArgSet& iset, const RooArgSet& nset, Int_t numScanBins, Int_t intOrder). RooArgSet* getAllConstraints(const RooArgSet& observables, RooArgSet& constrainedParams, Bool_t stripDisconnected = kTRUE) const; This helper function finds and collects all constraints terms of all coponent p.d.f.s; and returns a RooArgSet with all those terms. void clearEvalError(); Clear the evaluation error flag. Bool_t evalError(); Return the evaluation error flag. void raiseEvalError(); Raise the evaluation error flag. RooNumGenConfig* defaultGeneratorConfig(); Returns the default numeric MC generator configuration for all RooAbsReals. RooNumGenConfig* specialGeneratorConfig() const; Returns the specialized integrator configuration f",MatchSource.WIKI,root/html602/RooAbsPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsPdf.html
https://root.cern/root/html602/RooAbsPdf.html:86339,Deployability,integrat,integration,86339,"reateCdf(const RooArgSet& iset, const RooCmdArg& arg1, const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()); Create an object that represents the integral of the function over one or more observables listed in iset; The actual integration calculation is only performed when the return object is evaluated. The name; of the integral object is automatically constructed from the name of the input function, the variables; it integrates and the range integrates over. The following named arguments are accepted. SupNormSet(const RooArgSet&) -- Observables over which should be normalized _in_addition_ to the; integration observables; ScanNumCdf() -- Apply scanning technique if cdf integral involves numeric integration [ default ]; ScanAllCdf() -- Always apply scanning technique; ScanNoCdf() -- Never apply scanning technique; ScanParameters(Int_t nbins, -- Parameters for scanning technique of making CDF: number; Int_t intOrder) of sampled bins and order of interpolation applied on numeric cdf. RooAbsReal* createScanCdf(const RooArgSet& iset, const RooArgSet& nset, Int_t numScanBins, Int_t intOrder). RooArgSet* getAllConstraints(const RooArgSet& observables, RooArgSet& constrainedParams, Bool_t stripDisconnected = kTRUE) const; This helper function finds and collects all constraints terms of all coponent p.d.f.s; and returns a RooArgSet with all those terms. void clearEvalError(); Clear the evaluation error flag. Bool_t evalError(); Return the evaluation error flag. void raiseEvalError(); Raise the evaluation error flag. RooNumGenConfig* defaultGeneratorConfig(); Returns the default numeric MC generator configuration for all RooAbsReals. RooNumGenConfig* specialGeneratorConfig() const; Returns the specialized integrator configuration f",MatchSource.WIKI,root/html602/RooAbsPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsPdf.html
https://root.cern/root/html602/RooAbsPdf.html:87252,Deployability,configurat,configuration,87252,"tion_ to the; integration observables; ScanNumCdf() -- Apply scanning technique if cdf integral involves numeric integration [ default ]; ScanAllCdf() -- Always apply scanning technique; ScanNoCdf() -- Never apply scanning technique; ScanParameters(Int_t nbins, -- Parameters for scanning technique of making CDF: number; Int_t intOrder) of sampled bins and order of interpolation applied on numeric cdf. RooAbsReal* createScanCdf(const RooArgSet& iset, const RooArgSet& nset, Int_t numScanBins, Int_t intOrder). RooArgSet* getAllConstraints(const RooArgSet& observables, RooArgSet& constrainedParams, Bool_t stripDisconnected = kTRUE) const; This helper function finds and collects all constraints terms of all coponent p.d.f.s; and returns a RooArgSet with all those terms. void clearEvalError(); Clear the evaluation error flag. Bool_t evalError(); Return the evaluation error flag. void raiseEvalError(); Raise the evaluation error flag. RooNumGenConfig* defaultGeneratorConfig(); Returns the default numeric MC generator configuration for all RooAbsReals. RooNumGenConfig* specialGeneratorConfig() const; Returns the specialized integrator configuration for _this_ RooAbsReal.; If this object has no specialized configuration, a null pointer is returned. RooNumGenConfig* specialGeneratorConfig(Bool_t createOnTheFly); Returns the specialized integrator configuration for _this_ RooAbsReal.; If this object has no specialized configuration, a null pointer is returned,; unless createOnTheFly is kTRUE in which case a clone of the default integrator; configuration is created, installed as specialized configuration, and returned. const RooNumGenConfig* getGeneratorConfig() const; Return the numeric MC generator configuration used for this object. If; a specialized configuration was associated with this object, that configuration; is returned, otherwise the default configuration for all RooAbsReals is returned. void setGeneratorConfig(const RooNumGenConfig& config); Set the given configurat",MatchSource.WIKI,root/html602/RooAbsPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsPdf.html
https://root.cern/root/html602/RooAbsPdf.html:87360,Deployability,integrat,integrator,87360,"tion [ default ]; ScanAllCdf() -- Always apply scanning technique; ScanNoCdf() -- Never apply scanning technique; ScanParameters(Int_t nbins, -- Parameters for scanning technique of making CDF: number; Int_t intOrder) of sampled bins and order of interpolation applied on numeric cdf. RooAbsReal* createScanCdf(const RooArgSet& iset, const RooArgSet& nset, Int_t numScanBins, Int_t intOrder). RooArgSet* getAllConstraints(const RooArgSet& observables, RooArgSet& constrainedParams, Bool_t stripDisconnected = kTRUE) const; This helper function finds and collects all constraints terms of all coponent p.d.f.s; and returns a RooArgSet with all those terms. void clearEvalError(); Clear the evaluation error flag. Bool_t evalError(); Return the evaluation error flag. void raiseEvalError(); Raise the evaluation error flag. RooNumGenConfig* defaultGeneratorConfig(); Returns the default numeric MC generator configuration for all RooAbsReals. RooNumGenConfig* specialGeneratorConfig() const; Returns the specialized integrator configuration for _this_ RooAbsReal.; If this object has no specialized configuration, a null pointer is returned. RooNumGenConfig* specialGeneratorConfig(Bool_t createOnTheFly); Returns the specialized integrator configuration for _this_ RooAbsReal.; If this object has no specialized configuration, a null pointer is returned,; unless createOnTheFly is kTRUE in which case a clone of the default integrator; configuration is created, installed as specialized configuration, and returned. const RooNumGenConfig* getGeneratorConfig() const; Return the numeric MC generator configuration used for this object. If; a specialized configuration was associated with this object, that configuration; is returned, otherwise the default configuration for all RooAbsReals is returned. void setGeneratorConfig(const RooNumGenConfig& config); Set the given configuration as default numeric MC generator; configuration for this object. void setGeneratorConfig(); Remove the specialized nu",MatchSource.WIKI,root/html602/RooAbsPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsPdf.html
https://root.cern/root/html602/RooAbsPdf.html:87371,Deployability,configurat,configuration,87371,"tion [ default ]; ScanAllCdf() -- Always apply scanning technique; ScanNoCdf() -- Never apply scanning technique; ScanParameters(Int_t nbins, -- Parameters for scanning technique of making CDF: number; Int_t intOrder) of sampled bins and order of interpolation applied on numeric cdf. RooAbsReal* createScanCdf(const RooArgSet& iset, const RooArgSet& nset, Int_t numScanBins, Int_t intOrder). RooArgSet* getAllConstraints(const RooArgSet& observables, RooArgSet& constrainedParams, Bool_t stripDisconnected = kTRUE) const; This helper function finds and collects all constraints terms of all coponent p.d.f.s; and returns a RooArgSet with all those terms. void clearEvalError(); Clear the evaluation error flag. Bool_t evalError(); Return the evaluation error flag. void raiseEvalError(); Raise the evaluation error flag. RooNumGenConfig* defaultGeneratorConfig(); Returns the default numeric MC generator configuration for all RooAbsReals. RooNumGenConfig* specialGeneratorConfig() const; Returns the specialized integrator configuration for _this_ RooAbsReal.; If this object has no specialized configuration, a null pointer is returned. RooNumGenConfig* specialGeneratorConfig(Bool_t createOnTheFly); Returns the specialized integrator configuration for _this_ RooAbsReal.; If this object has no specialized configuration, a null pointer is returned,; unless createOnTheFly is kTRUE in which case a clone of the default integrator; configuration is created, installed as specialized configuration, and returned. const RooNumGenConfig* getGeneratorConfig() const; Return the numeric MC generator configuration used for this object. If; a specialized configuration was associated with this object, that configuration; is returned, otherwise the default configuration for all RooAbsReals is returned. void setGeneratorConfig(const RooNumGenConfig& config); Set the given configuration as default numeric MC generator; configuration for this object. void setGeneratorConfig(); Remove the specialized nu",MatchSource.WIKI,root/html602/RooAbsPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsPdf.html
https://root.cern/root/html602/RooAbsPdf.html:87443,Deployability,configurat,configuration,87443,"ng technique; ScanParameters(Int_t nbins, -- Parameters for scanning technique of making CDF: number; Int_t intOrder) of sampled bins and order of interpolation applied on numeric cdf. RooAbsReal* createScanCdf(const RooArgSet& iset, const RooArgSet& nset, Int_t numScanBins, Int_t intOrder). RooArgSet* getAllConstraints(const RooArgSet& observables, RooArgSet& constrainedParams, Bool_t stripDisconnected = kTRUE) const; This helper function finds and collects all constraints terms of all coponent p.d.f.s; and returns a RooArgSet with all those terms. void clearEvalError(); Clear the evaluation error flag. Bool_t evalError(); Return the evaluation error flag. void raiseEvalError(); Raise the evaluation error flag. RooNumGenConfig* defaultGeneratorConfig(); Returns the default numeric MC generator configuration for all RooAbsReals. RooNumGenConfig* specialGeneratorConfig() const; Returns the specialized integrator configuration for _this_ RooAbsReal.; If this object has no specialized configuration, a null pointer is returned. RooNumGenConfig* specialGeneratorConfig(Bool_t createOnTheFly); Returns the specialized integrator configuration for _this_ RooAbsReal.; If this object has no specialized configuration, a null pointer is returned,; unless createOnTheFly is kTRUE in which case a clone of the default integrator; configuration is created, installed as specialized configuration, and returned. const RooNumGenConfig* getGeneratorConfig() const; Return the numeric MC generator configuration used for this object. If; a specialized configuration was associated with this object, that configuration; is returned, otherwise the default configuration for all RooAbsReals is returned. void setGeneratorConfig(const RooNumGenConfig& config); Set the given configuration as default numeric MC generator; configuration for this object. void setGeneratorConfig(); Remove the specialized numeric MC generator configuration associated; with this object. void setNormRange(const char* rangeN",MatchSource.WIKI,root/html602/RooAbsPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsPdf.html
https://root.cern/root/html602/RooAbsPdf.html:87574,Deployability,integrat,integrator,87574," intOrder) of sampled bins and order of interpolation applied on numeric cdf. RooAbsReal* createScanCdf(const RooArgSet& iset, const RooArgSet& nset, Int_t numScanBins, Int_t intOrder). RooArgSet* getAllConstraints(const RooArgSet& observables, RooArgSet& constrainedParams, Bool_t stripDisconnected = kTRUE) const; This helper function finds and collects all constraints terms of all coponent p.d.f.s; and returns a RooArgSet with all those terms. void clearEvalError(); Clear the evaluation error flag. Bool_t evalError(); Return the evaluation error flag. void raiseEvalError(); Raise the evaluation error flag. RooNumGenConfig* defaultGeneratorConfig(); Returns the default numeric MC generator configuration for all RooAbsReals. RooNumGenConfig* specialGeneratorConfig() const; Returns the specialized integrator configuration for _this_ RooAbsReal.; If this object has no specialized configuration, a null pointer is returned. RooNumGenConfig* specialGeneratorConfig(Bool_t createOnTheFly); Returns the specialized integrator configuration for _this_ RooAbsReal.; If this object has no specialized configuration, a null pointer is returned,; unless createOnTheFly is kTRUE in which case a clone of the default integrator; configuration is created, installed as specialized configuration, and returned. const RooNumGenConfig* getGeneratorConfig() const; Return the numeric MC generator configuration used for this object. If; a specialized configuration was associated with this object, that configuration; is returned, otherwise the default configuration for all RooAbsReals is returned. void setGeneratorConfig(const RooNumGenConfig& config); Set the given configuration as default numeric MC generator; configuration for this object. void setGeneratorConfig(); Remove the specialized numeric MC generator configuration associated; with this object. void setNormRange(const char* rangeName). void setNormRangeOverride(const char* rangeName). GenSpec* prepareMultiGen(const RooArgSet& whatVars,",MatchSource.WIKI,root/html602/RooAbsPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsPdf.html
https://root.cern/root/html602/RooAbsPdf.html:87585,Deployability,configurat,configuration,87585," intOrder) of sampled bins and order of interpolation applied on numeric cdf. RooAbsReal* createScanCdf(const RooArgSet& iset, const RooArgSet& nset, Int_t numScanBins, Int_t intOrder). RooArgSet* getAllConstraints(const RooArgSet& observables, RooArgSet& constrainedParams, Bool_t stripDisconnected = kTRUE) const; This helper function finds and collects all constraints terms of all coponent p.d.f.s; and returns a RooArgSet with all those terms. void clearEvalError(); Clear the evaluation error flag. Bool_t evalError(); Return the evaluation error flag. void raiseEvalError(); Raise the evaluation error flag. RooNumGenConfig* defaultGeneratorConfig(); Returns the default numeric MC generator configuration for all RooAbsReals. RooNumGenConfig* specialGeneratorConfig() const; Returns the specialized integrator configuration for _this_ RooAbsReal.; If this object has no specialized configuration, a null pointer is returned. RooNumGenConfig* specialGeneratorConfig(Bool_t createOnTheFly); Returns the specialized integrator configuration for _this_ RooAbsReal.; If this object has no specialized configuration, a null pointer is returned,; unless createOnTheFly is kTRUE in which case a clone of the default integrator; configuration is created, installed as specialized configuration, and returned. const RooNumGenConfig* getGeneratorConfig() const; Return the numeric MC generator configuration used for this object. If; a specialized configuration was associated with this object, that configuration; is returned, otherwise the default configuration for all RooAbsReals is returned. void setGeneratorConfig(const RooNumGenConfig& config); Set the given configuration as default numeric MC generator; configuration for this object. void setGeneratorConfig(); Remove the specialized numeric MC generator configuration associated; with this object. void setNormRange(const char* rangeName). void setNormRangeOverride(const char* rangeName). GenSpec* prepareMultiGen(const RooArgSet& whatVars,",MatchSource.WIKI,root/html602/RooAbsPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsPdf.html
https://root.cern/root/html602/RooAbsPdf.html:87657,Deployability,configurat,configuration,87657,"ooArgSet* getAllConstraints(const RooArgSet& observables, RooArgSet& constrainedParams, Bool_t stripDisconnected = kTRUE) const; This helper function finds and collects all constraints terms of all coponent p.d.f.s; and returns a RooArgSet with all those terms. void clearEvalError(); Clear the evaluation error flag. Bool_t evalError(); Return the evaluation error flag. void raiseEvalError(); Raise the evaluation error flag. RooNumGenConfig* defaultGeneratorConfig(); Returns the default numeric MC generator configuration for all RooAbsReals. RooNumGenConfig* specialGeneratorConfig() const; Returns the specialized integrator configuration for _this_ RooAbsReal.; If this object has no specialized configuration, a null pointer is returned. RooNumGenConfig* specialGeneratorConfig(Bool_t createOnTheFly); Returns the specialized integrator configuration for _this_ RooAbsReal.; If this object has no specialized configuration, a null pointer is returned,; unless createOnTheFly is kTRUE in which case a clone of the default integrator; configuration is created, installed as specialized configuration, and returned. const RooNumGenConfig* getGeneratorConfig() const; Return the numeric MC generator configuration used for this object. If; a specialized configuration was associated with this object, that configuration; is returned, otherwise the default configuration for all RooAbsReals is returned. void setGeneratorConfig(const RooNumGenConfig& config); Set the given configuration as default numeric MC generator; configuration for this object. void setGeneratorConfig(); Remove the specialized numeric MC generator configuration associated; with this object. void setNormRange(const char* rangeName). void setNormRangeOverride(const char* rangeName). GenSpec* prepareMultiGen(const RooArgSet& whatVars, const RooCmdArg& arg1 = RooCmdArg::none(), const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg",MatchSource.WIKI,root/html602/RooAbsPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsPdf.html
https://root.cern/root/html602/RooAbsPdf.html:87769,Deployability,integrat,integrator,87769,"ooArgSet* getAllConstraints(const RooArgSet& observables, RooArgSet& constrainedParams, Bool_t stripDisconnected = kTRUE) const; This helper function finds and collects all constraints terms of all coponent p.d.f.s; and returns a RooArgSet with all those terms. void clearEvalError(); Clear the evaluation error flag. Bool_t evalError(); Return the evaluation error flag. void raiseEvalError(); Raise the evaluation error flag. RooNumGenConfig* defaultGeneratorConfig(); Returns the default numeric MC generator configuration for all RooAbsReals. RooNumGenConfig* specialGeneratorConfig() const; Returns the specialized integrator configuration for _this_ RooAbsReal.; If this object has no specialized configuration, a null pointer is returned. RooNumGenConfig* specialGeneratorConfig(Bool_t createOnTheFly); Returns the specialized integrator configuration for _this_ RooAbsReal.; If this object has no specialized configuration, a null pointer is returned,; unless createOnTheFly is kTRUE in which case a clone of the default integrator; configuration is created, installed as specialized configuration, and returned. const RooNumGenConfig* getGeneratorConfig() const; Return the numeric MC generator configuration used for this object. If; a specialized configuration was associated with this object, that configuration; is returned, otherwise the default configuration for all RooAbsReals is returned. void setGeneratorConfig(const RooNumGenConfig& config); Set the given configuration as default numeric MC generator; configuration for this object. void setGeneratorConfig(); Remove the specialized numeric MC generator configuration associated; with this object. void setNormRange(const char* rangeName). void setNormRangeOverride(const char* rangeName). GenSpec* prepareMultiGen(const RooArgSet& whatVars, const RooCmdArg& arg1 = RooCmdArg::none(), const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg",MatchSource.WIKI,root/html602/RooAbsPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsPdf.html
https://root.cern/root/html602/RooAbsPdf.html:87781,Deployability,configurat,configuration,87781,"ooArgSet* getAllConstraints(const RooArgSet& observables, RooArgSet& constrainedParams, Bool_t stripDisconnected = kTRUE) const; This helper function finds and collects all constraints terms of all coponent p.d.f.s; and returns a RooArgSet with all those terms. void clearEvalError(); Clear the evaluation error flag. Bool_t evalError(); Return the evaluation error flag. void raiseEvalError(); Raise the evaluation error flag. RooNumGenConfig* defaultGeneratorConfig(); Returns the default numeric MC generator configuration for all RooAbsReals. RooNumGenConfig* specialGeneratorConfig() const; Returns the specialized integrator configuration for _this_ RooAbsReal.; If this object has no specialized configuration, a null pointer is returned. RooNumGenConfig* specialGeneratorConfig(Bool_t createOnTheFly); Returns the specialized integrator configuration for _this_ RooAbsReal.; If this object has no specialized configuration, a null pointer is returned,; unless createOnTheFly is kTRUE in which case a clone of the default integrator; configuration is created, installed as specialized configuration, and returned. const RooNumGenConfig* getGeneratorConfig() const; Return the numeric MC generator configuration used for this object. If; a specialized configuration was associated with this object, that configuration; is returned, otherwise the default configuration for all RooAbsReals is returned. void setGeneratorConfig(const RooNumGenConfig& config); Set the given configuration as default numeric MC generator; configuration for this object. void setGeneratorConfig(); Remove the specialized numeric MC generator configuration associated; with this object. void setNormRange(const char* rangeName). void setNormRangeOverride(const char* rangeName). GenSpec* prepareMultiGen(const RooArgSet& whatVars, const RooCmdArg& arg1 = RooCmdArg::none(), const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg",MatchSource.WIKI,root/html602/RooAbsPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsPdf.html
https://root.cern/root/html602/RooAbsPdf.html:87807,Deployability,install,installed,87807,"ooArgSet* getAllConstraints(const RooArgSet& observables, RooArgSet& constrainedParams, Bool_t stripDisconnected = kTRUE) const; This helper function finds and collects all constraints terms of all coponent p.d.f.s; and returns a RooArgSet with all those terms. void clearEvalError(); Clear the evaluation error flag. Bool_t evalError(); Return the evaluation error flag. void raiseEvalError(); Raise the evaluation error flag. RooNumGenConfig* defaultGeneratorConfig(); Returns the default numeric MC generator configuration for all RooAbsReals. RooNumGenConfig* specialGeneratorConfig() const; Returns the specialized integrator configuration for _this_ RooAbsReal.; If this object has no specialized configuration, a null pointer is returned. RooNumGenConfig* specialGeneratorConfig(Bool_t createOnTheFly); Returns the specialized integrator configuration for _this_ RooAbsReal.; If this object has no specialized configuration, a null pointer is returned,; unless createOnTheFly is kTRUE in which case a clone of the default integrator; configuration is created, installed as specialized configuration, and returned. const RooNumGenConfig* getGeneratorConfig() const; Return the numeric MC generator configuration used for this object. If; a specialized configuration was associated with this object, that configuration; is returned, otherwise the default configuration for all RooAbsReals is returned. void setGeneratorConfig(const RooNumGenConfig& config); Set the given configuration as default numeric MC generator; configuration for this object. void setGeneratorConfig(); Remove the specialized numeric MC generator configuration associated; with this object. void setNormRange(const char* rangeName). void setNormRangeOverride(const char* rangeName). GenSpec* prepareMultiGen(const RooArgSet& whatVars, const RooCmdArg& arg1 = RooCmdArg::none(), const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg",MatchSource.WIKI,root/html602/RooAbsPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsPdf.html
https://root.cern/root/html602/RooAbsPdf.html:87832,Deployability,configurat,configuration,87832,"ooArgSet* getAllConstraints(const RooArgSet& observables, RooArgSet& constrainedParams, Bool_t stripDisconnected = kTRUE) const; This helper function finds and collects all constraints terms of all coponent p.d.f.s; and returns a RooArgSet with all those terms. void clearEvalError(); Clear the evaluation error flag. Bool_t evalError(); Return the evaluation error flag. void raiseEvalError(); Raise the evaluation error flag. RooNumGenConfig* defaultGeneratorConfig(); Returns the default numeric MC generator configuration for all RooAbsReals. RooNumGenConfig* specialGeneratorConfig() const; Returns the specialized integrator configuration for _this_ RooAbsReal.; If this object has no specialized configuration, a null pointer is returned. RooNumGenConfig* specialGeneratorConfig(Bool_t createOnTheFly); Returns the specialized integrator configuration for _this_ RooAbsReal.; If this object has no specialized configuration, a null pointer is returned,; unless createOnTheFly is kTRUE in which case a clone of the default integrator; configuration is created, installed as specialized configuration, and returned. const RooNumGenConfig* getGeneratorConfig() const; Return the numeric MC generator configuration used for this object. If; a specialized configuration was associated with this object, that configuration; is returned, otherwise the default configuration for all RooAbsReals is returned. void setGeneratorConfig(const RooNumGenConfig& config); Set the given configuration as default numeric MC generator; configuration for this object. void setGeneratorConfig(); Remove the specialized numeric MC generator configuration associated; with this object. void setNormRange(const char* rangeName). void setNormRangeOverride(const char* rangeName). GenSpec* prepareMultiGen(const RooArgSet& whatVars, const RooCmdArg& arg1 = RooCmdArg::none(), const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg",MatchSource.WIKI,root/html602/RooAbsPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsPdf.html
https://root.cern/root/html602/RooAbsPdf.html:87944,Deployability,configurat,configuration,87944,"aints terms of all coponent p.d.f.s; and returns a RooArgSet with all those terms. void clearEvalError(); Clear the evaluation error flag. Bool_t evalError(); Return the evaluation error flag. void raiseEvalError(); Raise the evaluation error flag. RooNumGenConfig* defaultGeneratorConfig(); Returns the default numeric MC generator configuration for all RooAbsReals. RooNumGenConfig* specialGeneratorConfig() const; Returns the specialized integrator configuration for _this_ RooAbsReal.; If this object has no specialized configuration, a null pointer is returned. RooNumGenConfig* specialGeneratorConfig(Bool_t createOnTheFly); Returns the specialized integrator configuration for _this_ RooAbsReal.; If this object has no specialized configuration, a null pointer is returned,; unless createOnTheFly is kTRUE in which case a clone of the default integrator; configuration is created, installed as specialized configuration, and returned. const RooNumGenConfig* getGeneratorConfig() const; Return the numeric MC generator configuration used for this object. If; a specialized configuration was associated with this object, that configuration; is returned, otherwise the default configuration for all RooAbsReals is returned. void setGeneratorConfig(const RooNumGenConfig& config); Set the given configuration as default numeric MC generator; configuration for this object. void setGeneratorConfig(); Remove the specialized numeric MC generator configuration associated; with this object. void setNormRange(const char* rangeName). void setNormRangeOverride(const char* rangeName). GenSpec* prepareMultiGen(const RooArgSet& whatVars, const RooCmdArg& arg1 = RooCmdArg::none(), const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none()). RooPlot* plotOn(RooPlot* frame, const RooCmdArg& arg1 = RooCmdArg::none(), const RooCmdArg& arg2 = RooCmdAr",MatchSource.WIKI,root/html602/RooAbsPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsPdf.html
https://root.cern/root/html602/RooAbsPdf.html:87998,Deployability,configurat,configuration,87998,"_t evalError(); Return the evaluation error flag. void raiseEvalError(); Raise the evaluation error flag. RooNumGenConfig* defaultGeneratorConfig(); Returns the default numeric MC generator configuration for all RooAbsReals. RooNumGenConfig* specialGeneratorConfig() const; Returns the specialized integrator configuration for _this_ RooAbsReal.; If this object has no specialized configuration, a null pointer is returned. RooNumGenConfig* specialGeneratorConfig(Bool_t createOnTheFly); Returns the specialized integrator configuration for _this_ RooAbsReal.; If this object has no specialized configuration, a null pointer is returned,; unless createOnTheFly is kTRUE in which case a clone of the default integrator; configuration is created, installed as specialized configuration, and returned. const RooNumGenConfig* getGeneratorConfig() const; Return the numeric MC generator configuration used for this object. If; a specialized configuration was associated with this object, that configuration; is returned, otherwise the default configuration for all RooAbsReals is returned. void setGeneratorConfig(const RooNumGenConfig& config); Set the given configuration as default numeric MC generator; configuration for this object. void setGeneratorConfig(); Remove the specialized numeric MC generator configuration associated; with this object. void setNormRange(const char* rangeName). void setNormRangeOverride(const char* rangeName). GenSpec* prepareMultiGen(const RooArgSet& whatVars, const RooCmdArg& arg1 = RooCmdArg::none(), const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none()). RooPlot* plotOn(RooPlot* frame, const RooCmdArg& arg1 = RooCmdArg::none(), const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), con",MatchSource.WIKI,root/html602/RooAbsPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsPdf.html
https://root.cern/root/html602/RooAbsPdf.html:88050,Deployability,configurat,configuration,88050,"_t evalError(); Return the evaluation error flag. void raiseEvalError(); Raise the evaluation error flag. RooNumGenConfig* defaultGeneratorConfig(); Returns the default numeric MC generator configuration for all RooAbsReals. RooNumGenConfig* specialGeneratorConfig() const; Returns the specialized integrator configuration for _this_ RooAbsReal.; If this object has no specialized configuration, a null pointer is returned. RooNumGenConfig* specialGeneratorConfig(Bool_t createOnTheFly); Returns the specialized integrator configuration for _this_ RooAbsReal.; If this object has no specialized configuration, a null pointer is returned,; unless createOnTheFly is kTRUE in which case a clone of the default integrator; configuration is created, installed as specialized configuration, and returned. const RooNumGenConfig* getGeneratorConfig() const; Return the numeric MC generator configuration used for this object. If; a specialized configuration was associated with this object, that configuration; is returned, otherwise the default configuration for all RooAbsReals is returned. void setGeneratorConfig(const RooNumGenConfig& config); Set the given configuration as default numeric MC generator; configuration for this object. void setGeneratorConfig(); Remove the specialized numeric MC generator configuration associated; with this object. void setNormRange(const char* rangeName). void setNormRangeOverride(const char* rangeName). GenSpec* prepareMultiGen(const RooArgSet& whatVars, const RooCmdArg& arg1 = RooCmdArg::none(), const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none()). RooPlot* plotOn(RooPlot* frame, const RooCmdArg& arg1 = RooCmdArg::none(), const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), con",MatchSource.WIKI,root/html602/RooAbsPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsPdf.html
https://root.cern/root/html602/RooAbsPdf.html:88100,Deployability,configurat,configuration,88100,"_t evalError(); Return the evaluation error flag. void raiseEvalError(); Raise the evaluation error flag. RooNumGenConfig* defaultGeneratorConfig(); Returns the default numeric MC generator configuration for all RooAbsReals. RooNumGenConfig* specialGeneratorConfig() const; Returns the specialized integrator configuration for _this_ RooAbsReal.; If this object has no specialized configuration, a null pointer is returned. RooNumGenConfig* specialGeneratorConfig(Bool_t createOnTheFly); Returns the specialized integrator configuration for _this_ RooAbsReal.; If this object has no specialized configuration, a null pointer is returned,; unless createOnTheFly is kTRUE in which case a clone of the default integrator; configuration is created, installed as specialized configuration, and returned. const RooNumGenConfig* getGeneratorConfig() const; Return the numeric MC generator configuration used for this object. If; a specialized configuration was associated with this object, that configuration; is returned, otherwise the default configuration for all RooAbsReals is returned. void setGeneratorConfig(const RooNumGenConfig& config); Set the given configuration as default numeric MC generator; configuration for this object. void setGeneratorConfig(); Remove the specialized numeric MC generator configuration associated; with this object. void setNormRange(const char* rangeName). void setNormRangeOverride(const char* rangeName). GenSpec* prepareMultiGen(const RooArgSet& whatVars, const RooCmdArg& arg1 = RooCmdArg::none(), const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none()). RooPlot* plotOn(RooPlot* frame, const RooCmdArg& arg1 = RooCmdArg::none(), const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), con",MatchSource.WIKI,root/html602/RooAbsPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsPdf.html
https://root.cern/root/html602/RooAbsPdf.html:88217,Deployability,configurat,configuration,88217,"he default numeric MC generator configuration for all RooAbsReals. RooNumGenConfig* specialGeneratorConfig() const; Returns the specialized integrator configuration for _this_ RooAbsReal.; If this object has no specialized configuration, a null pointer is returned. RooNumGenConfig* specialGeneratorConfig(Bool_t createOnTheFly); Returns the specialized integrator configuration for _this_ RooAbsReal.; If this object has no specialized configuration, a null pointer is returned,; unless createOnTheFly is kTRUE in which case a clone of the default integrator; configuration is created, installed as specialized configuration, and returned. const RooNumGenConfig* getGeneratorConfig() const; Return the numeric MC generator configuration used for this object. If; a specialized configuration was associated with this object, that configuration; is returned, otherwise the default configuration for all RooAbsReals is returned. void setGeneratorConfig(const RooNumGenConfig& config); Set the given configuration as default numeric MC generator; configuration for this object. void setGeneratorConfig(); Remove the specialized numeric MC generator configuration associated; with this object. void setNormRange(const char* rangeName). void setNormRangeOverride(const char* rangeName). GenSpec* prepareMultiGen(const RooArgSet& whatVars, const RooCmdArg& arg1 = RooCmdArg::none(), const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none()). RooPlot* plotOn(RooPlot* frame, const RooCmdArg& arg1 = RooCmdArg::none(), const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none(), const RooCmdArg& arg9 = RooCmdA",MatchSource.WIKI,root/html602/RooAbsPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsPdf.html
https://root.cern/root/html602/RooAbsPdf.html:88264,Deployability,configurat,configuration,88264,"he default numeric MC generator configuration for all RooAbsReals. RooNumGenConfig* specialGeneratorConfig() const; Returns the specialized integrator configuration for _this_ RooAbsReal.; If this object has no specialized configuration, a null pointer is returned. RooNumGenConfig* specialGeneratorConfig(Bool_t createOnTheFly); Returns the specialized integrator configuration for _this_ RooAbsReal.; If this object has no specialized configuration, a null pointer is returned,; unless createOnTheFly is kTRUE in which case a clone of the default integrator; configuration is created, installed as specialized configuration, and returned. const RooNumGenConfig* getGeneratorConfig() const; Return the numeric MC generator configuration used for this object. If; a specialized configuration was associated with this object, that configuration; is returned, otherwise the default configuration for all RooAbsReals is returned. void setGeneratorConfig(const RooNumGenConfig& config); Set the given configuration as default numeric MC generator; configuration for this object. void setGeneratorConfig(); Remove the specialized numeric MC generator configuration associated; with this object. void setNormRange(const char* rangeName). void setNormRangeOverride(const char* rangeName). GenSpec* prepareMultiGen(const RooArgSet& whatVars, const RooCmdArg& arg1 = RooCmdArg::none(), const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none()). RooPlot* plotOn(RooPlot* frame, const RooCmdArg& arg1 = RooCmdArg::none(), const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none(), const RooCmdArg& arg9 = RooCmdA",MatchSource.WIKI,root/html602/RooAbsPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsPdf.html
https://root.cern/root/html602/RooAbsPdf.html:88366,Deployability,configurat,configuration,88366,"cialized integrator configuration for _this_ RooAbsReal.; If this object has no specialized configuration, a null pointer is returned. RooNumGenConfig* specialGeneratorConfig(Bool_t createOnTheFly); Returns the specialized integrator configuration for _this_ RooAbsReal.; If this object has no specialized configuration, a null pointer is returned,; unless createOnTheFly is kTRUE in which case a clone of the default integrator; configuration is created, installed as specialized configuration, and returned. const RooNumGenConfig* getGeneratorConfig() const; Return the numeric MC generator configuration used for this object. If; a specialized configuration was associated with this object, that configuration; is returned, otherwise the default configuration for all RooAbsReals is returned. void setGeneratorConfig(const RooNumGenConfig& config); Set the given configuration as default numeric MC generator; configuration for this object. void setGeneratorConfig(); Remove the specialized numeric MC generator configuration associated; with this object. void setNormRange(const char* rangeName). void setNormRangeOverride(const char* rangeName). GenSpec* prepareMultiGen(const RooArgSet& whatVars, const RooCmdArg& arg1 = RooCmdArg::none(), const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none()). RooPlot* plotOn(RooPlot* frame, const RooCmdArg& arg1 = RooCmdArg::none(), const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none(), const RooCmdArg& arg9 = RooCmdArg::none(), const RooCmdArg& arg10 = RooCmdArg::none()) const. RooArgSet* getConstraints(const RooArgSet& , RooArgSet& , Bool_t ) co",MatchSource.WIKI,root/html602/RooAbsPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsPdf.html
https://root.cern/root/html602/RooAbsPdf.html:3493,Energy Efficiency,efficient,efficient,3493,"is requested. The; function should copy the subset of dependents it can analytically; integrate to anaIntSet and return a unique identification code for; this integration configuration. If no integration can be; performed, zero should be returned. Second,. Double_t analyticalIntegral(Int_t code). Implements the actual analytical integral(s) advertised by; getAnalyticalIntegral. This functions will only be called with; codes returned by getAnalyticalIntegral, except code zero. The integration range for real each dependent to be integrated can; be obtained from the dependents' proxy functions min() and; max(). Never call these proxy functions for any proxy not known to; be a dependent via the integration code. Doing so may be; ill-defined, e.g. in case the proxy holds a function, and will; trigger an assert. Integrated category dependents should always be; summed over all of their states. [Direct generation of observables]. Any PDF dependent can be generated with the accept/reject method,; but for certain PDFs more efficient methods may be implemented. To; implement direct generation of one or more observables, two; functions need to be implemented, similar to those for analytical; integrals:. Int_t getGenerator(const RooArgSet& generateVars, RooArgSet& directVars) and; void generateEvent(Int_t code). The first function advertises observables that can be generated,; similar to the way analytical integrals are advertised. The second; function implements the generator for the advertised observables. The generated dependent values should be store in the proxy; objects. For this the assignment operator can be used (i.e. xProxy; = 3.0 ). Never call assign to any proxy not known to be a dependent; via the generation code. Doing so may be ill-defined, e.g. in case; the proxy holds a function, and will trigger an assert. Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.;",MatchSource.WIKI,root/html602/RooAbsPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsPdf.html
https://root.cern/root/html602/RooAbsPdf.html:60790,Energy Efficiency,consumption,consumption,60790,"ult; Minos(const RooArgSet& set) -- Only run MINOS on given subset of arguments; Save(Bool_t flag) -- Flac controls if RooFitResult object is produced and returned, off by default; Strategy(Int_t flag) -- Set Minuit strategy (0 through 2, default is 1); FitOptions(const char* optStr) -- Steer fit with classic options string (for backward compatibility). Use of this option; excludes use of any of the new style steering options. SumW2Error(Bool_t flag) -- Apply correaction to errors and covariance matrix using sum-of-weights covariance matrix; to obtain correct error for weighted likelihood fits. If this option is activated the; corrected covariance matrix is calculated as Vcorr = V C-1 V, where V is the original; covariance matrix and C is the inverse of the covariance matrix calculated using the; weights squared. Options to control informational output. Verbose(Bool_t flag) -- Flag controls if verbose output is printed (NLL, parameter changes during fit; Timer(Bool_t flag) -- Time CPU and wall clock consumption of fit steps, off by default; PrintLevel(Int_t level) -- Set Minuit print level (-1 through 3, default is 1). At -1 all RooFit informational; messages are suppressed as well; Warnings(Bool_t flag) -- Enable or disable MINUIT warnings (enabled by default); PrintEvalErrors(Int_t numErr) -- Control number of p.d.f evaluation errors printed per likelihood evaluation. A negative; value suppress output completely, a zero value will only print the error count per p.d.f component,; a positive value is will print details of each error up to numErr messages per p.d.f component. RooFitResult* fitTo(RooAbsData& data, const RooLinkedList& cmdList); Fit PDF to given dataset. If dataset is unbinned, an unbinned maximum likelihood is performed. If the dataset; is binned, a binned maximum likelihood is performed. By default the fit is executed through the MINUIT; commands MIGRAD, HESSE and MINOS in succession. See RooAbsPdf::fitTo(RooAbsData& data, RooCmdArg arg1, RooCmdArg ar",MatchSource.WIKI,root/html602/RooAbsPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsPdf.html
https://root.cern/root/html602/RooAbsPdf.html:69905,Energy Efficiency,efficient,efficient,69905,"be strictly; reshuffled. In this mode events of the protodata may be used more than; once. If ProtoData() is used, the specified existing dataset as a prototype: the new dataset will contain; the same number of events as the prototype (unless otherwise specified), and any prototype variables not in; whatVars will be copied into the new dataset for each generated event and also used to set our PDF parameters.; The user can specify a number of events to generate that will override the default. The result is a; copy of the prototype dataset with only variables in whatVars randomized. Variables in whatVars that; are not in the prototype will be added as new columns to the generated dataset. RooDataSet * generate(RooAbsPdf::GenSpec& ) const; Generate data according to a pre-configured specification created by; RooAbsPdf::prepareMultiGen(). If many identical generation requests; are needed, e.g. in toy MC studies, it is more efficient to use the prepareMultiGen()/generate(); combination than calling the standard generate() multiple times as; initialization overhead is only incurred once. RooDataSet * generate(const RooArgSet& whatVars, Double_t nEvents = 0, Bool_t verbose = kFALSE, Bool_t autoBinned = kTRUE, const char* binnedTag = """", Bool_t expectedData = kFALSE, Bool_t extended = kFALSE) const; Generate a new dataset containing the specified variables with; events sampled from our distribution. Generate the specified; number of events or else try to use expectedEvents() if nEvents <= 0.; Any variables of this PDF that are not in whatVars will use their; current values and be treated as fixed parameters. Returns zero; in case of an error. The caller takes ownership of the returned; dataset. RooDataSet * generate(RooAbsGenContext& context, const RooArgSet& whatVars, const RooDataSet* prototype, Double_t nEvents, Bool_t verbose, Bool_t randProtoOrder, Bool_t resampleProto, Bool_t skipInit = kFALSE, Bool_t extended = kFALSE) const; Internal method. RooDataSet * generate(co",MatchSource.WIKI,root/html602/RooAbsPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsPdf.html
https://root.cern/root/html602/RooAbsPdf.html:80661,Energy Efficiency,adapt,adaptive,80661," Plotting control. LineStyle(Int_t style) -- Select line style by ROOT line style code, default is solid; LineColor(Int_t color) -- Select line color by ROOT color code, default is blue; LineWidth(Int_t width) -- Select line with in pixels, default is 3; FillStyle(Int_t style) -- Select fill style, default is not filled. If a filled style is selected, also use VLines(); to add vertical downward lines at end of curve to ensure proper closure; FillColor(Int_t color) -- Select fill color by ROOT color code; Range(const char* name) -- Only draw curve in range defined by given name; Range(double lo, double hi) -- Only draw curve in specified range; VLines() -- Add vertical lines to y=0 at end points of curve; Precision(Double_t eps) -- Control precision of drawn curve w.r.t to scale of plot, default is 1e-3. Higher precision; will result in more and more densely spaced curve points; A negative precision value will disable adaptive point spacing and restrict sampling to; the grid point of points defined by the binning of the plotted observabled (recommended for; expensive functions such as profile likelihoods); Invisble(Bool_t flag) -- Add curve to frame, but do not display. Useful in combination AddTo(). RooPlot* plotOn(RooPlot* frame, RooAbsReal::PlotOpt o) const; Plot oneself on 'frame'. In addition to features detailed in RooAbsReal::plotOn(),; the scale factor for a PDF can be interpreted in three different ways. The interpretation; is controlled by ScaleType. Relative - Scale factor is applied on top of PDF normalization scale factor; NumEvent - Scale factor is interpreted as a number of events. The surface area; under the PDF curve will match that of a histogram containing the specified; number of event; Raw - Scale factor is applied to the raw (projected) probability density.; Not too useful, option provided for completeness. RooPlot* paramOn(RooPlot* frame, const RooCmdArg& arg1 = RooCmdArg::none(), const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 ",MatchSource.WIKI,root/html602/RooAbsPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsPdf.html
https://root.cern/root/html602/RooAbsPdf.html:325,Integrability,interface,interface,325,". RooAbsPdf. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » ROOFIT; » ROOFITCORE; » RooAbsPdf. class RooAbsPdf: public RooAbsReal. RooAbsPdf is the abstract interface for all probability density; functions The class provides hybrid analytical/numerical; normalization for its implementations, error tracing and a MC; generator interface. A minimal implementation of a PDF class derived from RooAbsPdf; should overload the evaluate() function. This functions should; return PDFs value. [Normalization/Integration]. Although the normalization of a PDF is an integral part of a; probability density function, normalization is treated separately; in RooAbsPdf. The reason is that a RooAbsPdf object is more than a; PDF: it can be a building block for a more complex, composite PDF; if any of its variables are functions instead of variables. In; such cases the normalization of the composite may not be simply the; integral over the dependents of the top level PDF as these are; functions with potentially non-trivial Jacobian terms themselves.; Therefore. --> No explicit attempt should be made to normalize; the functions output in evaluate(). In addition, RooAbsPdf objects do not have a static concept of what; variables are parameters and what variables are dependents (which; need to be integrated over for a correct PDF normalization).; Instead the choice of normalization is always specified each time a; normalized values is requested from the PDF via the getVal(); method. RooAbsPdf manages the entire normalization logic of each PDF with; help of a RooRealIntegral object, which coordinates the integration; of a given choice of normalization. By default, RooRealIntegral will; perform a fully numeric integration of all dependents. However,; PDFs can advertise one or more (partial) analytical integrals of; their function, a",MatchSource.WIKI,root/html602/RooAbsPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsPdf.html
https://root.cern/root/html602/RooAbsPdf.html:495,Integrability,interface,interface,495,". RooAbsPdf. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » ROOFIT; » ROOFITCORE; » RooAbsPdf. class RooAbsPdf: public RooAbsReal. RooAbsPdf is the abstract interface for all probability density; functions The class provides hybrid analytical/numerical; normalization for its implementations, error tracing and a MC; generator interface. A minimal implementation of a PDF class derived from RooAbsPdf; should overload the evaluate() function. This functions should; return PDFs value. [Normalization/Integration]. Although the normalization of a PDF is an integral part of a; probability density function, normalization is treated separately; in RooAbsPdf. The reason is that a RooAbsPdf object is more than a; PDF: it can be a building block for a more complex, composite PDF; if any of its variables are functions instead of variables. In; such cases the normalization of the composite may not be simply the; integral over the dependents of the top level PDF as these are; functions with potentially non-trivial Jacobian terms themselves.; Therefore. --> No explicit attempt should be made to normalize; the functions output in evaluate(). In addition, RooAbsPdf objects do not have a static concept of what; variables are parameters and what variables are dependents (which; need to be integrated over for a correct PDF normalization).; Instead the choice of normalization is always specified each time a; normalized values is requested from the PDF via the getVal(); method. RooAbsPdf manages the entire normalization logic of each PDF with; help of a RooRealIntegral object, which coordinates the integration; of a given choice of normalization. By default, RooRealIntegral will; perform a fully numeric integration of all dependents. However,; PDFs can advertise one or more (partial) analytical integrals of; their function, a",MatchSource.WIKI,root/html602/RooAbsPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsPdf.html
https://root.cern/root/html602/RooAbsPdf.html:1097,Integrability,depend,dependents,1097,"ce file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » ROOFIT; » ROOFITCORE; » RooAbsPdf. class RooAbsPdf: public RooAbsReal. RooAbsPdf is the abstract interface for all probability density; functions The class provides hybrid analytical/numerical; normalization for its implementations, error tracing and a MC; generator interface. A minimal implementation of a PDF class derived from RooAbsPdf; should overload the evaluate() function. This functions should; return PDFs value. [Normalization/Integration]. Although the normalization of a PDF is an integral part of a; probability density function, normalization is treated separately; in RooAbsPdf. The reason is that a RooAbsPdf object is more than a; PDF: it can be a building block for a more complex, composite PDF; if any of its variables are functions instead of variables. In; such cases the normalization of the composite may not be simply the; integral over the dependents of the top level PDF as these are; functions with potentially non-trivial Jacobian terms themselves.; Therefore. --> No explicit attempt should be made to normalize; the functions output in evaluate(). In addition, RooAbsPdf objects do not have a static concept of what; variables are parameters and what variables are dependents (which; need to be integrated over for a correct PDF normalization).; Instead the choice of normalization is always specified each time a; normalized values is requested from the PDF via the getVal(); method. RooAbsPdf manages the entire normalization logic of each PDF with; help of a RooRealIntegral object, which coordinates the integration; of a given choice of normalization. By default, RooRealIntegral will; perform a fully numeric integration of all dependents. However,; PDFs can advertise one or more (partial) analytical integrals of; their function, and these will be used by RooRealIntegral, if it; determines that this is safe (i.e. no hidden Jacobian ter",MatchSource.WIKI,root/html602/RooAbsPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsPdf.html
https://root.cern/root/html602/RooAbsPdf.html:1427,Integrability,depend,dependents,1427,"cal/numerical; normalization for its implementations, error tracing and a MC; generator interface. A minimal implementation of a PDF class derived from RooAbsPdf; should overload the evaluate() function. This functions should; return PDFs value. [Normalization/Integration]. Although the normalization of a PDF is an integral part of a; probability density function, normalization is treated separately; in RooAbsPdf. The reason is that a RooAbsPdf object is more than a; PDF: it can be a building block for a more complex, composite PDF; if any of its variables are functions instead of variables. In; such cases the normalization of the composite may not be simply the; integral over the dependents of the top level PDF as these are; functions with potentially non-trivial Jacobian terms themselves.; Therefore. --> No explicit attempt should be made to normalize; the functions output in evaluate(). In addition, RooAbsPdf objects do not have a static concept of what; variables are parameters and what variables are dependents (which; need to be integrated over for a correct PDF normalization).; Instead the choice of normalization is always specified each time a; normalized values is requested from the PDF via the getVal(); method. RooAbsPdf manages the entire normalization logic of each PDF with; help of a RooRealIntegral object, which coordinates the integration; of a given choice of normalization. By default, RooRealIntegral will; perform a fully numeric integration of all dependents. However,; PDFs can advertise one or more (partial) analytical integrals of; their function, and these will be used by RooRealIntegral, if it; determines that this is safe (i.e. no hidden Jacobian terms,; multiplication with other PDFs that have one or more dependents in; commen etc). To implement analytical integrals, two functions must be implemented. First,. Int_t getAnalyticalIntegral(const RooArgSet& integSet, RooArgSet& anaIntSet). advertises the analytical integrals that are supported. 'in",MatchSource.WIKI,root/html602/RooAbsPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsPdf.html
https://root.cern/root/html602/RooAbsPdf.html:1457,Integrability,integrat,integrated,1457,"cal/numerical; normalization for its implementations, error tracing and a MC; generator interface. A minimal implementation of a PDF class derived from RooAbsPdf; should overload the evaluate() function. This functions should; return PDFs value. [Normalization/Integration]. Although the normalization of a PDF is an integral part of a; probability density function, normalization is treated separately; in RooAbsPdf. The reason is that a RooAbsPdf object is more than a; PDF: it can be a building block for a more complex, composite PDF; if any of its variables are functions instead of variables. In; such cases the normalization of the composite may not be simply the; integral over the dependents of the top level PDF as these are; functions with potentially non-trivial Jacobian terms themselves.; Therefore. --> No explicit attempt should be made to normalize; the functions output in evaluate(). In addition, RooAbsPdf objects do not have a static concept of what; variables are parameters and what variables are dependents (which; need to be integrated over for a correct PDF normalization).; Instead the choice of normalization is always specified each time a; normalized values is requested from the PDF via the getVal(); method. RooAbsPdf manages the entire normalization logic of each PDF with; help of a RooRealIntegral object, which coordinates the integration; of a given choice of normalization. By default, RooRealIntegral will; perform a fully numeric integration of all dependents. However,; PDFs can advertise one or more (partial) analytical integrals of; their function, and these will be used by RooRealIntegral, if it; determines that this is safe (i.e. no hidden Jacobian terms,; multiplication with other PDFs that have one or more dependents in; commen etc). To implement analytical integrals, two functions must be implemented. First,. Int_t getAnalyticalIntegral(const RooArgSet& integSet, RooArgSet& anaIntSet). advertises the analytical integrals that are supported. 'in",MatchSource.WIKI,root/html602/RooAbsPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsPdf.html
https://root.cern/root/html602/RooAbsPdf.html:1770,Integrability,integrat,integration,1770," part of a; probability density function, normalization is treated separately; in RooAbsPdf. The reason is that a RooAbsPdf object is more than a; PDF: it can be a building block for a more complex, composite PDF; if any of its variables are functions instead of variables. In; such cases the normalization of the composite may not be simply the; integral over the dependents of the top level PDF as these are; functions with potentially non-trivial Jacobian terms themselves.; Therefore. --> No explicit attempt should be made to normalize; the functions output in evaluate(). In addition, RooAbsPdf objects do not have a static concept of what; variables are parameters and what variables are dependents (which; need to be integrated over for a correct PDF normalization).; Instead the choice of normalization is always specified each time a; normalized values is requested from the PDF via the getVal(); method. RooAbsPdf manages the entire normalization logic of each PDF with; help of a RooRealIntegral object, which coordinates the integration; of a given choice of normalization. By default, RooRealIntegral will; perform a fully numeric integration of all dependents. However,; PDFs can advertise one or more (partial) analytical integrals of; their function, and these will be used by RooRealIntegral, if it; determines that this is safe (i.e. no hidden Jacobian terms,; multiplication with other PDFs that have one or more dependents in; commen etc). To implement analytical integrals, two functions must be implemented. First,. Int_t getAnalyticalIntegral(const RooArgSet& integSet, RooArgSet& anaIntSet). advertises the analytical integrals that are supported. 'integSet'; is the set of dependents for which integration is requested. The; function should copy the subset of dependents it can analytically; integrate to anaIntSet and return a unique identification code for; this integration configuration. If no integration can be; performed, zero should be returned. Second,. Double_t an",MatchSource.WIKI,root/html602/RooAbsPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsPdf.html
https://root.cern/root/html602/RooAbsPdf.html:1877,Integrability,integrat,integration,1877," is more than a; PDF: it can be a building block for a more complex, composite PDF; if any of its variables are functions instead of variables. In; such cases the normalization of the composite may not be simply the; integral over the dependents of the top level PDF as these are; functions with potentially non-trivial Jacobian terms themselves.; Therefore. --> No explicit attempt should be made to normalize; the functions output in evaluate(). In addition, RooAbsPdf objects do not have a static concept of what; variables are parameters and what variables are dependents (which; need to be integrated over for a correct PDF normalization).; Instead the choice of normalization is always specified each time a; normalized values is requested from the PDF via the getVal(); method. RooAbsPdf manages the entire normalization logic of each PDF with; help of a RooRealIntegral object, which coordinates the integration; of a given choice of normalization. By default, RooRealIntegral will; perform a fully numeric integration of all dependents. However,; PDFs can advertise one or more (partial) analytical integrals of; their function, and these will be used by RooRealIntegral, if it; determines that this is safe (i.e. no hidden Jacobian terms,; multiplication with other PDFs that have one or more dependents in; commen etc). To implement analytical integrals, two functions must be implemented. First,. Int_t getAnalyticalIntegral(const RooArgSet& integSet, RooArgSet& anaIntSet). advertises the analytical integrals that are supported. 'integSet'; is the set of dependents for which integration is requested. The; function should copy the subset of dependents it can analytically; integrate to anaIntSet and return a unique identification code for; this integration configuration. If no integration can be; performed, zero should be returned. Second,. Double_t analyticalIntegral(Int_t code). Implements the actual analytical integral(s) advertised by; getAnalyticalIntegral. This functions wil",MatchSource.WIKI,root/html602/RooAbsPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsPdf.html
https://root.cern/root/html602/RooAbsPdf.html:1896,Integrability,depend,dependents,1896," is more than a; PDF: it can be a building block for a more complex, composite PDF; if any of its variables are functions instead of variables. In; such cases the normalization of the composite may not be simply the; integral over the dependents of the top level PDF as these are; functions with potentially non-trivial Jacobian terms themselves.; Therefore. --> No explicit attempt should be made to normalize; the functions output in evaluate(). In addition, RooAbsPdf objects do not have a static concept of what; variables are parameters and what variables are dependents (which; need to be integrated over for a correct PDF normalization).; Instead the choice of normalization is always specified each time a; normalized values is requested from the PDF via the getVal(); method. RooAbsPdf manages the entire normalization logic of each PDF with; help of a RooRealIntegral object, which coordinates the integration; of a given choice of normalization. By default, RooRealIntegral will; perform a fully numeric integration of all dependents. However,; PDFs can advertise one or more (partial) analytical integrals of; their function, and these will be used by RooRealIntegral, if it; determines that this is safe (i.e. no hidden Jacobian terms,; multiplication with other PDFs that have one or more dependents in; commen etc). To implement analytical integrals, two functions must be implemented. First,. Int_t getAnalyticalIntegral(const RooArgSet& integSet, RooArgSet& anaIntSet). advertises the analytical integrals that are supported. 'integSet'; is the set of dependents for which integration is requested. The; function should copy the subset of dependents it can analytically; integrate to anaIntSet and return a unique identification code for; this integration configuration. If no integration can be; performed, zero should be returned. Second,. Double_t analyticalIntegral(Int_t code). Implements the actual analytical integral(s) advertised by; getAnalyticalIntegral. This functions wil",MatchSource.WIKI,root/html602/RooAbsPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsPdf.html
https://root.cern/root/html602/RooAbsPdf.html:2165,Integrability,depend,dependents,2165,"are; functions with potentially non-trivial Jacobian terms themselves.; Therefore. --> No explicit attempt should be made to normalize; the functions output in evaluate(). In addition, RooAbsPdf objects do not have a static concept of what; variables are parameters and what variables are dependents (which; need to be integrated over for a correct PDF normalization).; Instead the choice of normalization is always specified each time a; normalized values is requested from the PDF via the getVal(); method. RooAbsPdf manages the entire normalization logic of each PDF with; help of a RooRealIntegral object, which coordinates the integration; of a given choice of normalization. By default, RooRealIntegral will; perform a fully numeric integration of all dependents. However,; PDFs can advertise one or more (partial) analytical integrals of; their function, and these will be used by RooRealIntegral, if it; determines that this is safe (i.e. no hidden Jacobian terms,; multiplication with other PDFs that have one or more dependents in; commen etc). To implement analytical integrals, two functions must be implemented. First,. Int_t getAnalyticalIntegral(const RooArgSet& integSet, RooArgSet& anaIntSet). advertises the analytical integrals that are supported. 'integSet'; is the set of dependents for which integration is requested. The; function should copy the subset of dependents it can analytically; integrate to anaIntSet and return a unique identification code for; this integration configuration. If no integration can be; performed, zero should be returned. Second,. Double_t analyticalIntegral(Int_t code). Implements the actual analytical integral(s) advertised by; getAnalyticalIntegral. This functions will only be called with; codes returned by getAnalyticalIntegral, except code zero. The integration range for real each dependent to be integrated can; be obtained from the dependents' proxy functions min() and; max(). Never call these proxy functions for any proxy not known t",MatchSource.WIKI,root/html602/RooAbsPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsPdf.html
https://root.cern/root/html602/RooAbsPdf.html:2431,Integrability,depend,dependents,2431,"hich; need to be integrated over for a correct PDF normalization).; Instead the choice of normalization is always specified each time a; normalized values is requested from the PDF via the getVal(); method. RooAbsPdf manages the entire normalization logic of each PDF with; help of a RooRealIntegral object, which coordinates the integration; of a given choice of normalization. By default, RooRealIntegral will; perform a fully numeric integration of all dependents. However,; PDFs can advertise one or more (partial) analytical integrals of; their function, and these will be used by RooRealIntegral, if it; determines that this is safe (i.e. no hidden Jacobian terms,; multiplication with other PDFs that have one or more dependents in; commen etc). To implement analytical integrals, two functions must be implemented. First,. Int_t getAnalyticalIntegral(const RooArgSet& integSet, RooArgSet& anaIntSet). advertises the analytical integrals that are supported. 'integSet'; is the set of dependents for which integration is requested. The; function should copy the subset of dependents it can analytically; integrate to anaIntSet and return a unique identification code for; this integration configuration. If no integration can be; performed, zero should be returned. Second,. Double_t analyticalIntegral(Int_t code). Implements the actual analytical integral(s) advertised by; getAnalyticalIntegral. This functions will only be called with; codes returned by getAnalyticalIntegral, except code zero. The integration range for real each dependent to be integrated can; be obtained from the dependents' proxy functions min() and; max(). Never call these proxy functions for any proxy not known to; be a dependent via the integration code. Doing so may be; ill-defined, e.g. in case the proxy holds a function, and will; trigger an assert. Integrated category dependents should always be; summed over all of their states. [Direct generation of observables]. Any PDF dependent can be generated with t",MatchSource.WIKI,root/html602/RooAbsPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsPdf.html
https://root.cern/root/html602/RooAbsPdf.html:2452,Integrability,integrat,integration,2452,"hich; need to be integrated over for a correct PDF normalization).; Instead the choice of normalization is always specified each time a; normalized values is requested from the PDF via the getVal(); method. RooAbsPdf manages the entire normalization logic of each PDF with; help of a RooRealIntegral object, which coordinates the integration; of a given choice of normalization. By default, RooRealIntegral will; perform a fully numeric integration of all dependents. However,; PDFs can advertise one or more (partial) analytical integrals of; their function, and these will be used by RooRealIntegral, if it; determines that this is safe (i.e. no hidden Jacobian terms,; multiplication with other PDFs that have one or more dependents in; commen etc). To implement analytical integrals, two functions must be implemented. First,. Int_t getAnalyticalIntegral(const RooArgSet& integSet, RooArgSet& anaIntSet). advertises the analytical integrals that are supported. 'integSet'; is the set of dependents for which integration is requested. The; function should copy the subset of dependents it can analytically; integrate to anaIntSet and return a unique identification code for; this integration configuration. If no integration can be; performed, zero should be returned. Second,. Double_t analyticalIntegral(Int_t code). Implements the actual analytical integral(s) advertised by; getAnalyticalIntegral. This functions will only be called with; codes returned by getAnalyticalIntegral, except code zero. The integration range for real each dependent to be integrated can; be obtained from the dependents' proxy functions min() and; max(). Never call these proxy functions for any proxy not known to; be a dependent via the integration code. Doing so may be; ill-defined, e.g. in case the proxy holds a function, and will; trigger an assert. Integrated category dependents should always be; summed over all of their states. [Direct generation of observables]. Any PDF dependent can be generated with t",MatchSource.WIKI,root/html602/RooAbsPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsPdf.html
https://root.cern/root/html602/RooAbsPdf.html:2518,Integrability,depend,dependents,2518," each time a; normalized values is requested from the PDF via the getVal(); method. RooAbsPdf manages the entire normalization logic of each PDF with; help of a RooRealIntegral object, which coordinates the integration; of a given choice of normalization. By default, RooRealIntegral will; perform a fully numeric integration of all dependents. However,; PDFs can advertise one or more (partial) analytical integrals of; their function, and these will be used by RooRealIntegral, if it; determines that this is safe (i.e. no hidden Jacobian terms,; multiplication with other PDFs that have one or more dependents in; commen etc). To implement analytical integrals, two functions must be implemented. First,. Int_t getAnalyticalIntegral(const RooArgSet& integSet, RooArgSet& anaIntSet). advertises the analytical integrals that are supported. 'integSet'; is the set of dependents for which integration is requested. The; function should copy the subset of dependents it can analytically; integrate to anaIntSet and return a unique identification code for; this integration configuration. If no integration can be; performed, zero should be returned. Second,. Double_t analyticalIntegral(Int_t code). Implements the actual analytical integral(s) advertised by; getAnalyticalIntegral. This functions will only be called with; codes returned by getAnalyticalIntegral, except code zero. The integration range for real each dependent to be integrated can; be obtained from the dependents' proxy functions min() and; max(). Never call these proxy functions for any proxy not known to; be a dependent via the integration code. Doing so may be; ill-defined, e.g. in case the proxy holds a function, and will; trigger an assert. Integrated category dependents should always be; summed over all of their states. [Direct generation of observables]. Any PDF dependent can be generated with the accept/reject method,; but for certain PDFs more efficient methods may be implemented. To; implement direct generation ",MatchSource.WIKI,root/html602/RooAbsPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsPdf.html
https://root.cern/root/html602/RooAbsPdf.html:2550,Integrability,integrat,integrate,2550," each time a; normalized values is requested from the PDF via the getVal(); method. RooAbsPdf manages the entire normalization logic of each PDF with; help of a RooRealIntegral object, which coordinates the integration; of a given choice of normalization. By default, RooRealIntegral will; perform a fully numeric integration of all dependents. However,; PDFs can advertise one or more (partial) analytical integrals of; their function, and these will be used by RooRealIntegral, if it; determines that this is safe (i.e. no hidden Jacobian terms,; multiplication with other PDFs that have one or more dependents in; commen etc). To implement analytical integrals, two functions must be implemented. First,. Int_t getAnalyticalIntegral(const RooArgSet& integSet, RooArgSet& anaIntSet). advertises the analytical integrals that are supported. 'integSet'; is the set of dependents for which integration is requested. The; function should copy the subset of dependents it can analytically; integrate to anaIntSet and return a unique identification code for; this integration configuration. If no integration can be; performed, zero should be returned. Second,. Double_t analyticalIntegral(Int_t code). Implements the actual analytical integral(s) advertised by; getAnalyticalIntegral. This functions will only be called with; codes returned by getAnalyticalIntegral, except code zero. The integration range for real each dependent to be integrated can; be obtained from the dependents' proxy functions min() and; max(). Never call these proxy functions for any proxy not known to; be a dependent via the integration code. Doing so may be; ill-defined, e.g. in case the proxy holds a function, and will; trigger an assert. Integrated category dependents should always be; summed over all of their states. [Direct generation of observables]. Any PDF dependent can be generated with the accept/reject method,; but for certain PDFs more efficient methods may be implemented. To; implement direct generation ",MatchSource.WIKI,root/html602/RooAbsPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsPdf.html
https://root.cern/root/html602/RooAbsPdf.html:2623,Integrability,integrat,integration,2623," each time a; normalized values is requested from the PDF via the getVal(); method. RooAbsPdf manages the entire normalization logic of each PDF with; help of a RooRealIntegral object, which coordinates the integration; of a given choice of normalization. By default, RooRealIntegral will; perform a fully numeric integration of all dependents. However,; PDFs can advertise one or more (partial) analytical integrals of; their function, and these will be used by RooRealIntegral, if it; determines that this is safe (i.e. no hidden Jacobian terms,; multiplication with other PDFs that have one or more dependents in; commen etc). To implement analytical integrals, two functions must be implemented. First,. Int_t getAnalyticalIntegral(const RooArgSet& integSet, RooArgSet& anaIntSet). advertises the analytical integrals that are supported. 'integSet'; is the set of dependents for which integration is requested. The; function should copy the subset of dependents it can analytically; integrate to anaIntSet and return a unique identification code for; this integration configuration. If no integration can be; performed, zero should be returned. Second,. Double_t analyticalIntegral(Int_t code). Implements the actual analytical integral(s) advertised by; getAnalyticalIntegral. This functions will only be called with; codes returned by getAnalyticalIntegral, except code zero. The integration range for real each dependent to be integrated can; be obtained from the dependents' proxy functions min() and; max(). Never call these proxy functions for any proxy not known to; be a dependent via the integration code. Doing so may be; ill-defined, e.g. in case the proxy holds a function, and will; trigger an assert. Integrated category dependents should always be; summed over all of their states. [Direct generation of observables]. Any PDF dependent can be generated with the accept/reject method,; but for certain PDFs more efficient methods may be implemented. To; implement direct generation ",MatchSource.WIKI,root/html602/RooAbsPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsPdf.html
https://root.cern/root/html602/RooAbsPdf.html:2656,Integrability,integrat,integration,2656,"alization logic of each PDF with; help of a RooRealIntegral object, which coordinates the integration; of a given choice of normalization. By default, RooRealIntegral will; perform a fully numeric integration of all dependents. However,; PDFs can advertise one or more (partial) analytical integrals of; their function, and these will be used by RooRealIntegral, if it; determines that this is safe (i.e. no hidden Jacobian terms,; multiplication with other PDFs that have one or more dependents in; commen etc). To implement analytical integrals, two functions must be implemented. First,. Int_t getAnalyticalIntegral(const RooArgSet& integSet, RooArgSet& anaIntSet). advertises the analytical integrals that are supported. 'integSet'; is the set of dependents for which integration is requested. The; function should copy the subset of dependents it can analytically; integrate to anaIntSet and return a unique identification code for; this integration configuration. If no integration can be; performed, zero should be returned. Second,. Double_t analyticalIntegral(Int_t code). Implements the actual analytical integral(s) advertised by; getAnalyticalIntegral. This functions will only be called with; codes returned by getAnalyticalIntegral, except code zero. The integration range for real each dependent to be integrated can; be obtained from the dependents' proxy functions min() and; max(). Never call these proxy functions for any proxy not known to; be a dependent via the integration code. Doing so may be; ill-defined, e.g. in case the proxy holds a function, and will; trigger an assert. Integrated category dependents should always be; summed over all of their states. [Direct generation of observables]. Any PDF dependent can be generated with the accept/reject method,; but for certain PDFs more efficient methods may be implemented. To; implement direct generation of one or more observables, two; functions need to be implemented, similar to those for analytical; integrals:. Int_t",MatchSource.WIKI,root/html602/RooAbsPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsPdf.html
https://root.cern/root/html602/RooAbsPdf.html:2949,Integrability,integrat,integration,2949,"ill be used by RooRealIntegral, if it; determines that this is safe (i.e. no hidden Jacobian terms,; multiplication with other PDFs that have one or more dependents in; commen etc). To implement analytical integrals, two functions must be implemented. First,. Int_t getAnalyticalIntegral(const RooArgSet& integSet, RooArgSet& anaIntSet). advertises the analytical integrals that are supported. 'integSet'; is the set of dependents for which integration is requested. The; function should copy the subset of dependents it can analytically; integrate to anaIntSet and return a unique identification code for; this integration configuration. If no integration can be; performed, zero should be returned. Second,. Double_t analyticalIntegral(Int_t code). Implements the actual analytical integral(s) advertised by; getAnalyticalIntegral. This functions will only be called with; codes returned by getAnalyticalIntegral, except code zero. The integration range for real each dependent to be integrated can; be obtained from the dependents' proxy functions min() and; max(). Never call these proxy functions for any proxy not known to; be a dependent via the integration code. Doing so may be; ill-defined, e.g. in case the proxy holds a function, and will; trigger an assert. Integrated category dependents should always be; summed over all of their states. [Direct generation of observables]. Any PDF dependent can be generated with the accept/reject method,; but for certain PDFs more efficient methods may be implemented. To; implement direct generation of one or more observables, two; functions need to be implemented, similar to those for analytical; integrals:. Int_t getGenerator(const RooArgSet& generateVars, RooArgSet& directVars) and; void generateEvent(Int_t code). The first function advertises observables that can be generated,; similar to the way analytical integrals are advertised. The second; function implements the generator for the advertised observables. The generated dependent val",MatchSource.WIKI,root/html602/RooAbsPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsPdf.html
https://root.cern/root/html602/RooAbsPdf.html:2981,Integrability,depend,dependent,2981,"ill be used by RooRealIntegral, if it; determines that this is safe (i.e. no hidden Jacobian terms,; multiplication with other PDFs that have one or more dependents in; commen etc). To implement analytical integrals, two functions must be implemented. First,. Int_t getAnalyticalIntegral(const RooArgSet& integSet, RooArgSet& anaIntSet). advertises the analytical integrals that are supported. 'integSet'; is the set of dependents for which integration is requested. The; function should copy the subset of dependents it can analytically; integrate to anaIntSet and return a unique identification code for; this integration configuration. If no integration can be; performed, zero should be returned. Second,. Double_t analyticalIntegral(Int_t code). Implements the actual analytical integral(s) advertised by; getAnalyticalIntegral. This functions will only be called with; codes returned by getAnalyticalIntegral, except code zero. The integration range for real each dependent to be integrated can; be obtained from the dependents' proxy functions min() and; max(). Never call these proxy functions for any proxy not known to; be a dependent via the integration code. Doing so may be; ill-defined, e.g. in case the proxy holds a function, and will; trigger an assert. Integrated category dependents should always be; summed over all of their states. [Direct generation of observables]. Any PDF dependent can be generated with the accept/reject method,; but for certain PDFs more efficient methods may be implemented. To; implement direct generation of one or more observables, two; functions need to be implemented, similar to those for analytical; integrals:. Int_t getGenerator(const RooArgSet& generateVars, RooArgSet& directVars) and; void generateEvent(Int_t code). The first function advertises observables that can be generated,; similar to the way analytical integrals are advertised. The second; function implements the generator for the advertised observables. The generated dependent val",MatchSource.WIKI,root/html602/RooAbsPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsPdf.html
https://root.cern/root/html602/RooAbsPdf.html:2997,Integrability,integrat,integrated,2997,"ill be used by RooRealIntegral, if it; determines that this is safe (i.e. no hidden Jacobian terms,; multiplication with other PDFs that have one or more dependents in; commen etc). To implement analytical integrals, two functions must be implemented. First,. Int_t getAnalyticalIntegral(const RooArgSet& integSet, RooArgSet& anaIntSet). advertises the analytical integrals that are supported. 'integSet'; is the set of dependents for which integration is requested. The; function should copy the subset of dependents it can analytically; integrate to anaIntSet and return a unique identification code for; this integration configuration. If no integration can be; performed, zero should be returned. Second,. Double_t analyticalIntegral(Int_t code). Implements the actual analytical integral(s) advertised by; getAnalyticalIntegral. This functions will only be called with; codes returned by getAnalyticalIntegral, except code zero. The integration range for real each dependent to be integrated can; be obtained from the dependents' proxy functions min() and; max(). Never call these proxy functions for any proxy not known to; be a dependent via the integration code. Doing so may be; ill-defined, e.g. in case the proxy holds a function, and will; trigger an assert. Integrated category dependents should always be; summed over all of their states. [Direct generation of observables]. Any PDF dependent can be generated with the accept/reject method,; but for certain PDFs more efficient methods may be implemented. To; implement direct generation of one or more observables, two; functions need to be implemented, similar to those for analytical; integrals:. Int_t getGenerator(const RooArgSet& generateVars, RooArgSet& directVars) and; void generateEvent(Int_t code). The first function advertises observables that can be generated,; similar to the way analytical integrals are advertised. The second; function implements the generator for the advertised observables. The generated dependent val",MatchSource.WIKI,root/html602/RooAbsPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsPdf.html
https://root.cern/root/html602/RooAbsPdf.html:3034,Integrability,depend,dependents,3034,"ill be used by RooRealIntegral, if it; determines that this is safe (i.e. no hidden Jacobian terms,; multiplication with other PDFs that have one or more dependents in; commen etc). To implement analytical integrals, two functions must be implemented. First,. Int_t getAnalyticalIntegral(const RooArgSet& integSet, RooArgSet& anaIntSet). advertises the analytical integrals that are supported. 'integSet'; is the set of dependents for which integration is requested. The; function should copy the subset of dependents it can analytically; integrate to anaIntSet and return a unique identification code for; this integration configuration. If no integration can be; performed, zero should be returned. Second,. Double_t analyticalIntegral(Int_t code). Implements the actual analytical integral(s) advertised by; getAnalyticalIntegral. This functions will only be called with; codes returned by getAnalyticalIntegral, except code zero. The integration range for real each dependent to be integrated can; be obtained from the dependents' proxy functions min() and; max(). Never call these proxy functions for any proxy not known to; be a dependent via the integration code. Doing so may be; ill-defined, e.g. in case the proxy holds a function, and will; trigger an assert. Integrated category dependents should always be; summed over all of their states. [Direct generation of observables]. Any PDF dependent can be generated with the accept/reject method,; but for certain PDFs more efficient methods may be implemented. To; implement direct generation of one or more observables, two; functions need to be implemented, similar to those for analytical; integrals:. Int_t getGenerator(const RooArgSet& generateVars, RooArgSet& directVars) and; void generateEvent(Int_t code). The first function advertises observables that can be generated,; similar to the way analytical integrals are advertised. The second; function implements the generator for the advertised observables. The generated dependent val",MatchSource.WIKI,root/html602/RooAbsPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsPdf.html
https://root.cern/root/html602/RooAbsPdf.html:3146,Integrability,depend,dependent,3146,"h other PDFs that have one or more dependents in; commen etc). To implement analytical integrals, two functions must be implemented. First,. Int_t getAnalyticalIntegral(const RooArgSet& integSet, RooArgSet& anaIntSet). advertises the analytical integrals that are supported. 'integSet'; is the set of dependents for which integration is requested. The; function should copy the subset of dependents it can analytically; integrate to anaIntSet and return a unique identification code for; this integration configuration. If no integration can be; performed, zero should be returned. Second,. Double_t analyticalIntegral(Int_t code). Implements the actual analytical integral(s) advertised by; getAnalyticalIntegral. This functions will only be called with; codes returned by getAnalyticalIntegral, except code zero. The integration range for real each dependent to be integrated can; be obtained from the dependents' proxy functions min() and; max(). Never call these proxy functions for any proxy not known to; be a dependent via the integration code. Doing so may be; ill-defined, e.g. in case the proxy holds a function, and will; trigger an assert. Integrated category dependents should always be; summed over all of their states. [Direct generation of observables]. Any PDF dependent can be generated with the accept/reject method,; but for certain PDFs more efficient methods may be implemented. To; implement direct generation of one or more observables, two; functions need to be implemented, similar to those for analytical; integrals:. Int_t getGenerator(const RooArgSet& generateVars, RooArgSet& directVars) and; void generateEvent(Int_t code). The first function advertises observables that can be generated,; similar to the way analytical integrals are advertised. The second; function implements the generator for the advertised observables. The generated dependent values should be store in the proxy; objects. For this the assignment operator can be used (i.e. xProxy; = 3.0 ). Never c",MatchSource.WIKI,root/html602/RooAbsPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsPdf.html
https://root.cern/root/html602/RooAbsPdf.html:3164,Integrability,integrat,integration,3164,"h other PDFs that have one or more dependents in; commen etc). To implement analytical integrals, two functions must be implemented. First,. Int_t getAnalyticalIntegral(const RooArgSet& integSet, RooArgSet& anaIntSet). advertises the analytical integrals that are supported. 'integSet'; is the set of dependents for which integration is requested. The; function should copy the subset of dependents it can analytically; integrate to anaIntSet and return a unique identification code for; this integration configuration. If no integration can be; performed, zero should be returned. Second,. Double_t analyticalIntegral(Int_t code). Implements the actual analytical integral(s) advertised by; getAnalyticalIntegral. This functions will only be called with; codes returned by getAnalyticalIntegral, except code zero. The integration range for real each dependent to be integrated can; be obtained from the dependents' proxy functions min() and; max(). Never call these proxy functions for any proxy not known to; be a dependent via the integration code. Doing so may be; ill-defined, e.g. in case the proxy holds a function, and will; trigger an assert. Integrated category dependents should always be; summed over all of their states. [Direct generation of observables]. Any PDF dependent can be generated with the accept/reject method,; but for certain PDFs more efficient methods may be implemented. To; implement direct generation of one or more observables, two; functions need to be implemented, similar to those for analytical; integrals:. Int_t getGenerator(const RooArgSet& generateVars, RooArgSet& directVars) and; void generateEvent(Int_t code). The first function advertises observables that can be generated,; similar to the way analytical integrals are advertised. The second; function implements the generator for the advertised observables. The generated dependent values should be store in the proxy; objects. For this the assignment operator can be used (i.e. xProxy; = 3.0 ). Never c",MatchSource.WIKI,root/html602/RooAbsPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsPdf.html
https://root.cern/root/html602/RooAbsPdf.html:3302,Integrability,depend,dependents,3302,"et, RooArgSet& anaIntSet). advertises the analytical integrals that are supported. 'integSet'; is the set of dependents for which integration is requested. The; function should copy the subset of dependents it can analytically; integrate to anaIntSet and return a unique identification code for; this integration configuration. If no integration can be; performed, zero should be returned. Second,. Double_t analyticalIntegral(Int_t code). Implements the actual analytical integral(s) advertised by; getAnalyticalIntegral. This functions will only be called with; codes returned by getAnalyticalIntegral, except code zero. The integration range for real each dependent to be integrated can; be obtained from the dependents' proxy functions min() and; max(). Never call these proxy functions for any proxy not known to; be a dependent via the integration code. Doing so may be; ill-defined, e.g. in case the proxy holds a function, and will; trigger an assert. Integrated category dependents should always be; summed over all of their states. [Direct generation of observables]. Any PDF dependent can be generated with the accept/reject method,; but for certain PDFs more efficient methods may be implemented. To; implement direct generation of one or more observables, two; functions need to be implemented, similar to those for analytical; integrals:. Int_t getGenerator(const RooArgSet& generateVars, RooArgSet& directVars) and; void generateEvent(Int_t code). The first function advertises observables that can be generated,; similar to the way analytical integrals are advertised. The second; function implements the generator for the advertised observables. The generated dependent values should be store in the proxy; objects. For this the assignment operator can be used (i.e. xProxy; = 3.0 ). Never call assign to any proxy not known to be a dependent; via the generation code. Doing so may be ill-defined, e.g. in case; the proxy holds a function, and will trigger an assert. Function Member",MatchSource.WIKI,root/html602/RooAbsPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsPdf.html
https://root.cern/root/html602/RooAbsPdf.html:3408,Integrability,depend,dependent,3408,"is requested. The; function should copy the subset of dependents it can analytically; integrate to anaIntSet and return a unique identification code for; this integration configuration. If no integration can be; performed, zero should be returned. Second,. Double_t analyticalIntegral(Int_t code). Implements the actual analytical integral(s) advertised by; getAnalyticalIntegral. This functions will only be called with; codes returned by getAnalyticalIntegral, except code zero. The integration range for real each dependent to be integrated can; be obtained from the dependents' proxy functions min() and; max(). Never call these proxy functions for any proxy not known to; be a dependent via the integration code. Doing so may be; ill-defined, e.g. in case the proxy holds a function, and will; trigger an assert. Integrated category dependents should always be; summed over all of their states. [Direct generation of observables]. Any PDF dependent can be generated with the accept/reject method,; but for certain PDFs more efficient methods may be implemented. To; implement direct generation of one or more observables, two; functions need to be implemented, similar to those for analytical; integrals:. Int_t getGenerator(const RooArgSet& generateVars, RooArgSet& directVars) and; void generateEvent(Int_t code). The first function advertises observables that can be generated,; similar to the way analytical integrals are advertised. The second; function implements the generator for the advertised observables. The generated dependent values should be store in the proxy; objects. For this the assignment operator can be used (i.e. xProxy; = 3.0 ). Never call assign to any proxy not known to be a dependent; via the generation code. Doing so may be ill-defined, e.g. in case; the proxy holds a function, and will trigger an assert. Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.;",MatchSource.WIKI,root/html602/RooAbsPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsPdf.html
https://root.cern/root/html602/RooAbsPdf.html:3999,Integrability,depend,dependent,3999,"ained from the dependents' proxy functions min() and; max(). Never call these proxy functions for any proxy not known to; be a dependent via the integration code. Doing so may be; ill-defined, e.g. in case the proxy holds a function, and will; trigger an assert. Integrated category dependents should always be; summed over all of their states. [Direct generation of observables]. Any PDF dependent can be generated with the accept/reject method,; but for certain PDFs more efficient methods may be implemented. To; implement direct generation of one or more observables, two; functions need to be implemented, similar to those for analytical; integrals:. Int_t getGenerator(const RooArgSet& generateVars, RooArgSet& directVars) and; void generateEvent(Int_t code). The first function advertises observables that can be generated,; similar to the way analytical integrals are advertised. The second; function implements the generator for the advertised observables. The generated dependent values should be store in the proxy; objects. For this the assignment operator can be used (i.e. xProxy; = 3.0 ). Never call assign to any proxy not known to be a dependent; via the generation code. Doing so may be ill-defined, e.g. in case; the proxy holds a function, and will trigger an assert. Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~RooAbsPdf(); voidTObject::AbstractMethod(const char* method) const; Bool_tRooAbsArg::addOwnedComponents(const RooArgSet& comps); voidRooAbsArg::addParameters(RooArgSet& params, const RooArgSet* nset = 0, Bool_t stripDisconnected = kTRUE) const; voidRooAbsArg::addServer(RooAbsArg& server, Bool_t valueProp = kTRUE, Bool_t shapeProp = kFALSE); voidRooAbsArg::addServerList(RooAbsCollection& serverList, Bool_t valueProp = kTRUE, Bool_t shapeProp = kFALSE); const char*RooAbsArg::aggregateCacheUniqueSuffix() const; virtual Double_tRooAbs",MatchSource.WIKI,root/html602/RooAbsPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsPdf.html
https://root.cern/root/html602/RooAbsPdf.html:4172,Integrability,depend,dependent,4172,"integration code. Doing so may be; ill-defined, e.g. in case the proxy holds a function, and will; trigger an assert. Integrated category dependents should always be; summed over all of their states. [Direct generation of observables]. Any PDF dependent can be generated with the accept/reject method,; but for certain PDFs more efficient methods may be implemented. To; implement direct generation of one or more observables, two; functions need to be implemented, similar to those for analytical; integrals:. Int_t getGenerator(const RooArgSet& generateVars, RooArgSet& directVars) and; void generateEvent(Int_t code). The first function advertises observables that can be generated,; similar to the way analytical integrals are advertised. The second; function implements the generator for the advertised observables. The generated dependent values should be store in the proxy; objects. For this the assignment operator can be used (i.e. xProxy; = 3.0 ). Never call assign to any proxy not known to be a dependent; via the generation code. Doing so may be ill-defined, e.g. in case; the proxy holds a function, and will trigger an assert. Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~RooAbsPdf(); voidTObject::AbstractMethod(const char* method) const; Bool_tRooAbsArg::addOwnedComponents(const RooArgSet& comps); voidRooAbsArg::addParameters(RooArgSet& params, const RooArgSet* nset = 0, Bool_t stripDisconnected = kTRUE) const; voidRooAbsArg::addServer(RooAbsArg& server, Bool_t valueProp = kTRUE, Bool_t shapeProp = kFALSE); voidRooAbsArg::addServerList(RooAbsCollection& serverList, Bool_t valueProp = kTRUE, Bool_t shapeProp = kFALSE); const char*RooAbsArg::aggregateCacheUniqueSuffix() const; virtual Double_tRooAbsReal::analyticalIntegral(Int_t code, const char* rangeName = 0) const; virtual Double_tanalyticalIntegralWN(Int_t code, const RooArgSet* normSet, ",MatchSource.WIKI,root/html602/RooAbsPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsPdf.html
https://root.cern/root/html602/RooAbsPdf.html:10862,Integrability,depend,dependentVars,10862,"rg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()) const; RooAbsReal*RooAbsReal::createIntRI(const RooArgSet& iset, const RooArgSet& nset = RooArgSet()); virtual RooAbsReal*createNLL(RooAbsData& data, const RooLinkedList& cmdList); virtual RooAbsReal*createNLL(RooAbsData& data, const RooCmdArg& arg1 = RooCmdArg::none(), const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()); const RooAbsReal*RooAbsReal::createPlotProjection(const RooArgSet& depVars, const RooArgSet& projVars) const; const RooAbsReal*RooAbsReal::createPlotProjection(const RooArgSet& depVars, const RooArgSet& projVars, RooArgSet*& cloneSet) const; const RooAbsReal*RooAbsReal::createPlotProjection(const RooArgSet& dependentVars, const RooArgSet* projectedVars, RooArgSet*& cloneSet, const char* rangeName = 0, const RooArgSet* condObs = 0) const; virtual RooAbsReal*RooAbsReal::createProfile(const RooArgSet& paramsOfInterest); virtual RooAbsPdf*createProjection(const RooArgSet& iset); RooAbsReal*RooAbsReal::createRunningIntegral(const RooArgSet& iset, const RooArgSet& nset = RooArgSet()); RooAbsReal*RooAbsReal::createRunningIntegral(const RooArgSet& iset, const RooCmdArg& arg1, const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()); RooAbsReal*createScanCdf(const RooArgSet& iset, const RooArgSet& nset, Int_t numScanBins, Int_t intOrder); RooAbsReal*RooAbsReal::createScanRI(const RooArgSet& iset, const RooArgSet& nset, Int_t numScanBins, Int_t intOrder); virtual Do",MatchSource.WIKI,root/html602/RooAbsPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsPdf.html
https://root.cern/root/html602/RooAbsPdf.html:12319,Integrability,depend,dependentOverlaps,12319,":createProfile(const RooArgSet& paramsOfInterest); virtual RooAbsPdf*createProjection(const RooArgSet& iset); RooAbsReal*RooAbsReal::createRunningIntegral(const RooArgSet& iset, const RooArgSet& nset = RooArgSet()); RooAbsReal*RooAbsReal::createRunningIntegral(const RooArgSet& iset, const RooCmdArg& arg1, const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()); RooAbsReal*createScanCdf(const RooArgSet& iset, const RooArgSet& nset, Int_t numScanBins, Int_t intOrder); RooAbsReal*RooAbsReal::createScanRI(const RooArgSet& iset, const RooArgSet& nset, Int_t numScanBins, Int_t intOrder); virtual Double_tRooAbsReal::defaultErrorLevel() const; static RooNumGenConfig*defaultGeneratorConfig(); static RooNumIntConfig*RooAbsReal::defaultIntegratorConfig(); virtual Int_tRooAbsArg::defaultPrintContents(Option_t* opt) const; static ostream&RooPrintable::defaultPrintStream(ostream* os = 0); virtual RooPrintable::StyleOptionRooPrintable::defaultPrintStyle(Option_t* opt) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; Bool_tRooAbsArg::dependentOverlaps(const RooAbsData* dset, const RooAbsArg& testArg) const; Bool_tRooAbsArg::dependentOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; Bool_tRooAbsArg::dependsOn(const RooAbsCollection& serverList, const RooAbsArg* ignoreArg = 0, Bool_t valueOnly = kFALSE) const; Bool_tRooAbsArg::dependsOn(const RooAbsArg& server, const RooAbsArg* ignoreArg = 0, Bool_t valueOnly = kFALSE) const; Bool_tRooAbsArg::dependsOnValue(const RooAbsCollection& serverList, const RooAbsArg* ignoreArg = 0) const; Bool_tRooAbsArg::dependsOnValue(const RooAbsArg& server, const RooAbsArg* ignoreArg = 0) const; RooDerivative*RooAbsReal::derivative(RooRealVar& obs, Int_t order = 1, Double_t eps = 0.",MatchSource.WIKI,root/html602/RooAbsPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsPdf.html
https://root.cern/root/html602/RooAbsPdf.html:12411,Integrability,depend,dependentOverlaps,12411,":createProfile(const RooArgSet& paramsOfInterest); virtual RooAbsPdf*createProjection(const RooArgSet& iset); RooAbsReal*RooAbsReal::createRunningIntegral(const RooArgSet& iset, const RooArgSet& nset = RooArgSet()); RooAbsReal*RooAbsReal::createRunningIntegral(const RooArgSet& iset, const RooCmdArg& arg1, const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()); RooAbsReal*createScanCdf(const RooArgSet& iset, const RooArgSet& nset, Int_t numScanBins, Int_t intOrder); RooAbsReal*RooAbsReal::createScanRI(const RooArgSet& iset, const RooArgSet& nset, Int_t numScanBins, Int_t intOrder); virtual Double_tRooAbsReal::defaultErrorLevel() const; static RooNumGenConfig*defaultGeneratorConfig(); static RooNumIntConfig*RooAbsReal::defaultIntegratorConfig(); virtual Int_tRooAbsArg::defaultPrintContents(Option_t* opt) const; static ostream&RooPrintable::defaultPrintStream(ostream* os = 0); virtual RooPrintable::StyleOptionRooPrintable::defaultPrintStyle(Option_t* opt) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; Bool_tRooAbsArg::dependentOverlaps(const RooAbsData* dset, const RooAbsArg& testArg) const; Bool_tRooAbsArg::dependentOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; Bool_tRooAbsArg::dependsOn(const RooAbsCollection& serverList, const RooAbsArg* ignoreArg = 0, Bool_t valueOnly = kFALSE) const; Bool_tRooAbsArg::dependsOn(const RooAbsArg& server, const RooAbsArg* ignoreArg = 0, Bool_t valueOnly = kFALSE) const; Bool_tRooAbsArg::dependsOnValue(const RooAbsCollection& serverList, const RooAbsArg* ignoreArg = 0) const; Bool_tRooAbsArg::dependsOnValue(const RooAbsArg& server, const RooAbsArg* ignoreArg = 0) const; RooDerivative*RooAbsReal::derivative(RooRealVar& obs, Int_t order = 1, Double_t eps = 0.",MatchSource.WIKI,root/html602/RooAbsPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsPdf.html
https://root.cern/root/html602/RooAbsPdf.html:12505,Integrability,depend,dependsOn,12505,":createProfile(const RooArgSet& paramsOfInterest); virtual RooAbsPdf*createProjection(const RooArgSet& iset); RooAbsReal*RooAbsReal::createRunningIntegral(const RooArgSet& iset, const RooArgSet& nset = RooArgSet()); RooAbsReal*RooAbsReal::createRunningIntegral(const RooArgSet& iset, const RooCmdArg& arg1, const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()); RooAbsReal*createScanCdf(const RooArgSet& iset, const RooArgSet& nset, Int_t numScanBins, Int_t intOrder); RooAbsReal*RooAbsReal::createScanRI(const RooArgSet& iset, const RooArgSet& nset, Int_t numScanBins, Int_t intOrder); virtual Double_tRooAbsReal::defaultErrorLevel() const; static RooNumGenConfig*defaultGeneratorConfig(); static RooNumIntConfig*RooAbsReal::defaultIntegratorConfig(); virtual Int_tRooAbsArg::defaultPrintContents(Option_t* opt) const; static ostream&RooPrintable::defaultPrintStream(ostream* os = 0); virtual RooPrintable::StyleOptionRooPrintable::defaultPrintStyle(Option_t* opt) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; Bool_tRooAbsArg::dependentOverlaps(const RooAbsData* dset, const RooAbsArg& testArg) const; Bool_tRooAbsArg::dependentOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; Bool_tRooAbsArg::dependsOn(const RooAbsCollection& serverList, const RooAbsArg* ignoreArg = 0, Bool_t valueOnly = kFALSE) const; Bool_tRooAbsArg::dependsOn(const RooAbsArg& server, const RooAbsArg* ignoreArg = 0, Bool_t valueOnly = kFALSE) const; Bool_tRooAbsArg::dependsOnValue(const RooAbsCollection& serverList, const RooAbsArg* ignoreArg = 0) const; Bool_tRooAbsArg::dependsOnValue(const RooAbsArg& server, const RooAbsArg* ignoreArg = 0) const; RooDerivative*RooAbsReal::derivative(RooRealVar& obs, Int_t order = 1, Double_t eps = 0.",MatchSource.WIKI,root/html602/RooAbsPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsPdf.html
https://root.cern/root/html602/RooAbsPdf.html:12634,Integrability,depend,dependsOn,12634,":createProfile(const RooArgSet& paramsOfInterest); virtual RooAbsPdf*createProjection(const RooArgSet& iset); RooAbsReal*RooAbsReal::createRunningIntegral(const RooArgSet& iset, const RooArgSet& nset = RooArgSet()); RooAbsReal*RooAbsReal::createRunningIntegral(const RooArgSet& iset, const RooCmdArg& arg1, const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()); RooAbsReal*createScanCdf(const RooArgSet& iset, const RooArgSet& nset, Int_t numScanBins, Int_t intOrder); RooAbsReal*RooAbsReal::createScanRI(const RooArgSet& iset, const RooArgSet& nset, Int_t numScanBins, Int_t intOrder); virtual Double_tRooAbsReal::defaultErrorLevel() const; static RooNumGenConfig*defaultGeneratorConfig(); static RooNumIntConfig*RooAbsReal::defaultIntegratorConfig(); virtual Int_tRooAbsArg::defaultPrintContents(Option_t* opt) const; static ostream&RooPrintable::defaultPrintStream(ostream* os = 0); virtual RooPrintable::StyleOptionRooPrintable::defaultPrintStyle(Option_t* opt) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; Bool_tRooAbsArg::dependentOverlaps(const RooAbsData* dset, const RooAbsArg& testArg) const; Bool_tRooAbsArg::dependentOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; Bool_tRooAbsArg::dependsOn(const RooAbsCollection& serverList, const RooAbsArg* ignoreArg = 0, Bool_t valueOnly = kFALSE) const; Bool_tRooAbsArg::dependsOn(const RooAbsArg& server, const RooAbsArg* ignoreArg = 0, Bool_t valueOnly = kFALSE) const; Bool_tRooAbsArg::dependsOnValue(const RooAbsCollection& serverList, const RooAbsArg* ignoreArg = 0) const; Bool_tRooAbsArg::dependsOnValue(const RooAbsArg& server, const RooAbsArg* ignoreArg = 0) const; RooDerivative*RooAbsReal::derivative(RooRealVar& obs, Int_t order = 1, Double_t eps = 0.",MatchSource.WIKI,root/html602/RooAbsPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsPdf.html
https://root.cern/root/html602/RooAbsPdf.html:12752,Integrability,depend,dependsOnValue,12752,":createProfile(const RooArgSet& paramsOfInterest); virtual RooAbsPdf*createProjection(const RooArgSet& iset); RooAbsReal*RooAbsReal::createRunningIntegral(const RooArgSet& iset, const RooArgSet& nset = RooArgSet()); RooAbsReal*RooAbsReal::createRunningIntegral(const RooArgSet& iset, const RooCmdArg& arg1, const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()); RooAbsReal*createScanCdf(const RooArgSet& iset, const RooArgSet& nset, Int_t numScanBins, Int_t intOrder); RooAbsReal*RooAbsReal::createScanRI(const RooArgSet& iset, const RooArgSet& nset, Int_t numScanBins, Int_t intOrder); virtual Double_tRooAbsReal::defaultErrorLevel() const; static RooNumGenConfig*defaultGeneratorConfig(); static RooNumIntConfig*RooAbsReal::defaultIntegratorConfig(); virtual Int_tRooAbsArg::defaultPrintContents(Option_t* opt) const; static ostream&RooPrintable::defaultPrintStream(ostream* os = 0); virtual RooPrintable::StyleOptionRooPrintable::defaultPrintStyle(Option_t* opt) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; Bool_tRooAbsArg::dependentOverlaps(const RooAbsData* dset, const RooAbsArg& testArg) const; Bool_tRooAbsArg::dependentOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; Bool_tRooAbsArg::dependsOn(const RooAbsCollection& serverList, const RooAbsArg* ignoreArg = 0, Bool_t valueOnly = kFALSE) const; Bool_tRooAbsArg::dependsOn(const RooAbsArg& server, const RooAbsArg* ignoreArg = 0, Bool_t valueOnly = kFALSE) const; Bool_tRooAbsArg::dependsOnValue(const RooAbsCollection& serverList, const RooAbsArg* ignoreArg = 0) const; Bool_tRooAbsArg::dependsOnValue(const RooAbsArg& server, const RooAbsArg* ignoreArg = 0) const; RooDerivative*RooAbsReal::derivative(RooRealVar& obs, Int_t order = 1, Double_t eps = 0.",MatchSource.WIKI,root/html602/RooAbsPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsPdf.html
https://root.cern/root/html602/RooAbsPdf.html:12859,Integrability,depend,dependsOnValue,12859,":createProfile(const RooArgSet& paramsOfInterest); virtual RooAbsPdf*createProjection(const RooArgSet& iset); RooAbsReal*RooAbsReal::createRunningIntegral(const RooArgSet& iset, const RooArgSet& nset = RooArgSet()); RooAbsReal*RooAbsReal::createRunningIntegral(const RooArgSet& iset, const RooCmdArg& arg1, const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()); RooAbsReal*createScanCdf(const RooArgSet& iset, const RooArgSet& nset, Int_t numScanBins, Int_t intOrder); RooAbsReal*RooAbsReal::createScanRI(const RooArgSet& iset, const RooArgSet& nset, Int_t numScanBins, Int_t intOrder); virtual Double_tRooAbsReal::defaultErrorLevel() const; static RooNumGenConfig*defaultGeneratorConfig(); static RooNumIntConfig*RooAbsReal::defaultIntegratorConfig(); virtual Int_tRooAbsArg::defaultPrintContents(Option_t* opt) const; static ostream&RooPrintable::defaultPrintStream(ostream* os = 0); virtual RooPrintable::StyleOptionRooPrintable::defaultPrintStyle(Option_t* opt) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; Bool_tRooAbsArg::dependentOverlaps(const RooAbsData* dset, const RooAbsArg& testArg) const; Bool_tRooAbsArg::dependentOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; Bool_tRooAbsArg::dependsOn(const RooAbsCollection& serverList, const RooAbsArg* ignoreArg = 0, Bool_t valueOnly = kFALSE) const; Bool_tRooAbsArg::dependsOn(const RooAbsArg& server, const RooAbsArg* ignoreArg = 0, Bool_t valueOnly = kFALSE) const; Bool_tRooAbsArg::dependsOnValue(const RooAbsCollection& serverList, const RooAbsArg* ignoreArg = 0) const; Bool_tRooAbsArg::dependsOnValue(const RooAbsArg& server, const RooAbsArg* ignoreArg = 0) const; RooDerivative*RooAbsReal::derivative(RooRealVar& obs, Int_t order = 1, Double_t eps = 0.",MatchSource.WIKI,root/html602/RooAbsPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsPdf.html
https://root.cern/root/html602/RooAbsPdf.html:24475,Integrability,message,message,24475,"TObject::IsFolder() const; virtual Bool_tRooAbsArg::isFundamental() const; virtual Bool_tRooAbsReal::isIdentical(const RooAbsArg& other, Bool_t assumeSameType = kFALSE); virtual Bool_tRooAbsArg::isLValue() const; virtual Bool_tRooAbsReal::isOffsetting() const; Bool_tTObject::IsOnHeap() const; Bool_tRooAbsArg::isShapeDirty() const; Bool_tRooAbsArg::isShapeServer(const RooAbsArg& arg) const; Bool_tRooAbsArg::isShapeServer(const char* name) const; virtual Bool_tRooAbsArg::IsSortable() const; Bool_tRooAbsArg::isValueDirty() const; Bool_tRooAbsArg::isValueDirtyAndClear() const; Bool_tRooAbsArg::isValueOrShapeDirtyAndClear() const; Bool_tRooAbsArg::isValueServer(const RooAbsArg& arg) const; Bool_tRooAbsArg::isValueServer(const char* name) const; Bool_tTObject::IsZombie() const; voidRooAbsArg::leafNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t recurseNonDerived = kFALSE) const; Bool_tRooAbsArg::localNoDirtyInhibit() const; voidRooAbsReal::logEvalError(const char* message, const char* serverValueString = 0) const; static voidRooAbsReal::logEvalError(const RooAbsReal* originator, const char* origName, const char* message, const char* serverValueString = 0); virtual voidTNamed::ls(Option_t* option = """") const; virtual Double_tRooAbsReal::maxVal(Int_t code) const; voidTObject::MayNotUse(const char* method) const; RooAbsMoment*RooAbsReal::mean(RooRealVar& obs); RooAbsMoment*RooAbsReal::mean(RooRealVar& obs, const RooArgSet& nset); virtual Int_tRooAbsReal::minTrialSamples(const RooArgSet&) const; RooAbsMoment*RooAbsReal::moment(RooRealVar& obs, Int_t order, Bool_t central, Bool_t takeRoot); RooAbsMoment*RooAbsReal::moment(RooRealVar& obs, const RooArgSet& normObs, Int_t order, Bool_t central, Bool_t takeRoot, Bool_t intNormObs); Bool_tmustBeExtended() const; static voidRooPrintable::nameFieldLength(Int_t newLen); const TNamed*RooAbsArg::namePtr() const; const char*normRange() const; virtual Bool_tTObject::Notify(); Int_tRooAbsArg::numCaches() const; stat",MatchSource.WIKI,root/html602/RooAbsPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsPdf.html
https://root.cern/root/html602/RooAbsPdf.html:24626,Integrability,message,message,24626,"ameType = kFALSE); virtual Bool_tRooAbsArg::isLValue() const; virtual Bool_tRooAbsReal::isOffsetting() const; Bool_tTObject::IsOnHeap() const; Bool_tRooAbsArg::isShapeDirty() const; Bool_tRooAbsArg::isShapeServer(const RooAbsArg& arg) const; Bool_tRooAbsArg::isShapeServer(const char* name) const; virtual Bool_tRooAbsArg::IsSortable() const; Bool_tRooAbsArg::isValueDirty() const; Bool_tRooAbsArg::isValueDirtyAndClear() const; Bool_tRooAbsArg::isValueOrShapeDirtyAndClear() const; Bool_tRooAbsArg::isValueServer(const RooAbsArg& arg) const; Bool_tRooAbsArg::isValueServer(const char* name) const; Bool_tTObject::IsZombie() const; voidRooAbsArg::leafNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t recurseNonDerived = kFALSE) const; Bool_tRooAbsArg::localNoDirtyInhibit() const; voidRooAbsReal::logEvalError(const char* message, const char* serverValueString = 0) const; static voidRooAbsReal::logEvalError(const RooAbsReal* originator, const char* origName, const char* message, const char* serverValueString = 0); virtual voidTNamed::ls(Option_t* option = """") const; virtual Double_tRooAbsReal::maxVal(Int_t code) const; voidTObject::MayNotUse(const char* method) const; RooAbsMoment*RooAbsReal::mean(RooRealVar& obs); RooAbsMoment*RooAbsReal::mean(RooRealVar& obs, const RooArgSet& nset); virtual Int_tRooAbsReal::minTrialSamples(const RooArgSet&) const; RooAbsMoment*RooAbsReal::moment(RooRealVar& obs, Int_t order, Bool_t central, Bool_t takeRoot); RooAbsMoment*RooAbsReal::moment(RooRealVar& obs, const RooArgSet& normObs, Int_t order, Bool_t central, Bool_t takeRoot, Bool_t intNormObs); Bool_tmustBeExtended() const; static voidRooPrintable::nameFieldLength(Int_t newLen); const TNamed*RooAbsArg::namePtr() const; const char*normRange() const; virtual Bool_tTObject::Notify(); Int_tRooAbsArg::numCaches() const; static Int_tRooAbsReal::numEvalErrorItems(); static Int_tRooAbsReal::numEvalErrors(); Bool_tRooAbsArg::observableOverlaps(const RooAbsData* dset, const Roo",MatchSource.WIKI,root/html602/RooAbsPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsPdf.html
https://root.cern/root/html602/RooAbsPdf.html:45029,Integrability,integrat,integration,45029,"boolAttribBoolean attributes; set<string>RooAbsArg::_boolAttribTransient! Transient boolean attributes (not copied in ctor); Bool_tRooAbsReal::_boolValue! Transient cache for bool values from tree branches; UChar_tRooAbsReal::_byteValue! Transient cache for byte values from tree branches; static Bool_tRooAbsReal::_cacheCheckIf true, always validate contents of clean which outcome of evaluate(); deque<RooAbsCache*>RooAbsArg::_cacheListlist of caches; RooRefCountListRooAbsArg::_clientListlist of client objects; RooRefCountListRooAbsArg::_clientListShapesubset of clients that requested shape dirty flag propagation; RooRefCountListRooAbsArg::_clientListValuesubset of clients that requested value dirty flag propagation; TIterator*RooAbsArg::_clientShapeIter! Iterator over _clientListShape; TIterator*RooAbsArg::_clientValueIter! Iterator over _clientListValue; Bool_tRooAbsArg::_deleteWatch! Delete watch flag; RooExpensiveObjectCache*RooAbsArg::_eocachePointer to global cache manager for any expensive components created by this object; Int_t_errorCountNumber of errors remaining to print; static Bool_t_evalError; Bool_tRooAbsArg::_fastAllow fast access mode in getVal() and proxies; Float_tRooAbsReal::_floatValue! Transient cache for floating point values from tree branches; Bool_tRooAbsReal::_forceNumIntForce numerical integration if flag set; static Bool_tRooAbsReal::_globalSelectCompGlobal activation switch for component selection; static Bool_tRooAbsReal::_hideOffsetOffset hiding flag; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; Int_tRooAbsReal::_intValue! Transient cache for integer values from tree branches; Bool_tRooAbsArg::_isConstant! Cached isConstant status; TStringRooAbsReal::_labelPlot label for objects value; RooArgSet*RooAbsReal::_lastNSet!; Bool_tRooAbsArg::_localNoInhibitDirty! Prevent 'AlwaysDirty' mode for this node; static Int_tRooPrintable::_nameLength; TNamed*RooAbsArg::_namePtr! Do not persist.",MatchSource.WIKI,root/html602/RooAbsPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsPdf.html
https://root.cern/root/html602/RooAbsPdf.html:47054,Integrability,integrat,integrator,47054,"t_t_negCountNumber of negative probablities remaining to print; RooAbsReal*_norm! Normalization integral (owned by _normMgr); RooObjCacheManager_normMgrThe cache manager; TString_normRangeNormalization range; static TString_normRangeOverride; RooArgSet*_normSet! Normalization set with for above integral; RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; Int_tRooAbsReal::_plotBinsNumber of plot bins; Double_tRooAbsReal::_plotMaxMaximum of plot range; Double_tRooAbsReal::_plotMinMinimum of plot range; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; RooRefArrayRooAbsArg::_proxyListlist of proxies; Double_t_rawValue; Char_tRooAbsReal::_sbyteValue! Transient cache for signed byte values from tree branches; Bool_t_selectCompComponent selection flag for RooAbsPdf::plotCompOn; Bool_tRooAbsReal::_selectComp! Component selection flag for RooAbsPdf::plotCompOn; RooRefCountListRooAbsArg::_serverListlist of server objects; Bool_tRooAbsArg::_shapeDirtyFlag set if value needs recalculating because input shapes modified; RooNumGenConfig*_specGeneratorConfig! MC generator configuration specific for this object; RooNumIntConfig*RooAbsReal::_specIntegratorConfigNumeric integrator configuration specific for this object; map<string,string>RooAbsArg::_stringAttribString attributes; Int_t_traceCountNumber of traces remaining to print; Bool_tRooAbsReal::_treeVar!do not persist; UInt_tRooAbsReal::_uintValue! Transient cache for unsigned integer values from tree branches; TStringRooAbsReal::_unitUnit for objects value; Double_tRooAbsReal::_valueCache for current value of object; Bool_tRooAbsArg::_valueDirtyFlag set if value needs recalculating because input values modified; static Bool_tRooAbsArg::_verboseDirtyStatic flag controlling verbose messaging for dirty state changes; static Int_t_verboseEval; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title.",MatchSource.WIKI,root/html602/RooAbsPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsPdf.html
https://root.cern/root/html602/RooAbsPdf.html:48298,Integrability,integrat,integrating,48298,"eal::_uintValue! Transient cache for unsigned integer values from tree branches; TStringRooAbsReal::_unitUnit for objects value; Double_tRooAbsReal::_valueCache for current value of object; Bool_tRooAbsArg::_valueDirtyFlag set if value needs recalculating because input values modified; static Bool_tRooAbsArg::_verboseDirtyStatic flag controlling verbose messaging for dirty state changes; static Int_t_verboseEval; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; RooAbsPdf(); Default constructor. RooAbsPdf(const char* name, const char* title = 0); Constructor with name and title only. RooAbsPdf(const char* name, const char* title, Double_t minVal, Double_t maxVal); Constructor with name, title, and plot range. RooAbsPdf(const RooAbsPdf& other, const char* name = 0); Copy constructor. ~RooAbsPdf(); Destructor. Double_t getValV(const RooArgSet* set = 0) const; Return current value, normalizated by integrating over; the observables in 'nset'. If 'nset' is 0, the unnormalized value.; is returned. All elements of 'nset' must be lvalues. Unnormalized values are not cached; Doing so would be complicated as _norm->getVal() could; spoil the cache and interfere with returning the cached; return value. Since unnormalized calls are typically; done in integration calls, there is no performance hit. Double_t analyticalIntegralWN(Int_t code, const RooArgSet* normSet, const char* rangeName = 0) const; Analytical integral with normalization (see RooAbsReal::analyticalIntegralWN() for further information). This function applies the normalization specified by 'normSet' to the integral returned; by RooAbsReal::analyticalIntegral(). The passthrough scenario (code=0) is also changed; to return a normalized answer. Bool_t traceEvalPdf(Double_t value) const; Check that passed value is positive and not 'not-a-number'. If; not, print an error, until the error counter reaches its s",MatchSource.WIKI,root/html602/RooAbsPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsPdf.html
https://root.cern/root/html602/RooAbsPdf.html:48648,Integrability,integrat,integration,48648,"rty state changes; static Int_t_verboseEval; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; RooAbsPdf(); Default constructor. RooAbsPdf(const char* name, const char* title = 0); Constructor with name and title only. RooAbsPdf(const char* name, const char* title, Double_t minVal, Double_t maxVal); Constructor with name, title, and plot range. RooAbsPdf(const RooAbsPdf& other, const char* name = 0); Copy constructor. ~RooAbsPdf(); Destructor. Double_t getValV(const RooArgSet* set = 0) const; Return current value, normalizated by integrating over; the observables in 'nset'. If 'nset' is 0, the unnormalized value.; is returned. All elements of 'nset' must be lvalues. Unnormalized values are not cached; Doing so would be complicated as _norm->getVal() could; spoil the cache and interfere with returning the cached; return value. Since unnormalized calls are typically; done in integration calls, there is no performance hit. Double_t analyticalIntegralWN(Int_t code, const RooArgSet* normSet, const char* rangeName = 0) const; Analytical integral with normalization (see RooAbsReal::analyticalIntegralWN() for further information). This function applies the normalization specified by 'normSet' to the integral returned; by RooAbsReal::analyticalIntegral(). The passthrough scenario (code=0) is also changed; to return a normalized answer. Bool_t traceEvalPdf(Double_t value) const; Check that passed value is positive and not 'not-a-number'. If; not, print an error, until the error counter reaches its set; maximum. Double_t getNorm(const RooArgSet* set = 0) const; Return the integral of this PDF over all observables listed in 'nset'. const RooAbsReal* getNormObj(const RooArgSet* set, const RooArgSet* iset, const TNamed* rangeName = 0) const; Return pointer to RooAbsReal object that implements calculation of integral over observables iset in range; rangeName, optional",MatchSource.WIKI,root/html602/RooAbsPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsPdf.html
https://root.cern/root/html602/RooAbsPdf.html:50429,Integrability,message,messages,50429,"bles listed in 'nset'. const RooAbsReal* getNormObj(const RooArgSet* set, const RooArgSet* iset, const TNamed* rangeName = 0) const; Return pointer to RooAbsReal object that implements calculation of integral over observables iset in range; rangeName, optionally taking the integrand normalized over observables nset. Bool_t syncNormalization(const RooArgSet* dset, Bool_t adjustProxies = kTRUE) const; Verify that the normalization integral cached with this PDF; is valid for given set of normalization observables. If not, the cached normalization integral (if any) is deleted; and a new integral is constructed for use with 'nset'; Elements in 'nset' can be discrete and real, but must be lvalues. For functions that declare to be self-normalized by overloading the; selfNormalized() function, a unit normalization is always constructed. Bool_t traceEvalHook(Double_t value) const; WVE 08/21/01 Probably obsolete now. void resetErrorCounters(Int_t resetValue = 10); Reset error counter to given value, limiting the number; of future error messages for this pdf to 'resetValue'. void setTraceCounter(Int_t value, Bool_t allNodes = kFALSE); Reset trace counter to given value, limiting the; number of future trace messages for this pdf to 'value'. Double_t getLogVal(const RooArgSet* set = 0) const; Return the log of the current value with given normalization; An error message is printed if the argument of the log is negative. Double_t extendedTerm(Double_t observedEvents, const RooArgSet* nset = 0) const; Returned the extended likelihood term (Nexpect - Nobserved*log(NExpected); of this PDF for the given number of observed events. For successfull operation the PDF implementation must indicate; it is extendable by overloading canBeExtended() and must; implemented the expectedEvents() function. RooAbsReal* createNLL(RooAbsData& data, const RooCmdArg& arg1 = RooCmdArg::none(), const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = Ro",MatchSource.WIKI,root/html602/RooAbsPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsPdf.html
https://root.cern/root/html602/RooAbsPdf.html:50602,Integrability,message,messages,50602,"ject that implements calculation of integral over observables iset in range; rangeName, optionally taking the integrand normalized over observables nset. Bool_t syncNormalization(const RooArgSet* dset, Bool_t adjustProxies = kTRUE) const; Verify that the normalization integral cached with this PDF; is valid for given set of normalization observables. If not, the cached normalization integral (if any) is deleted; and a new integral is constructed for use with 'nset'; Elements in 'nset' can be discrete and real, but must be lvalues. For functions that declare to be self-normalized by overloading the; selfNormalized() function, a unit normalization is always constructed. Bool_t traceEvalHook(Double_t value) const; WVE 08/21/01 Probably obsolete now. void resetErrorCounters(Int_t resetValue = 10); Reset error counter to given value, limiting the number; of future error messages for this pdf to 'resetValue'. void setTraceCounter(Int_t value, Bool_t allNodes = kFALSE); Reset trace counter to given value, limiting the; number of future trace messages for this pdf to 'value'. Double_t getLogVal(const RooArgSet* set = 0) const; Return the log of the current value with given normalization; An error message is printed if the argument of the log is negative. Double_t extendedTerm(Double_t observedEvents, const RooArgSet* nset = 0) const; Returned the extended likelihood term (Nexpect - Nobserved*log(NExpected); of this PDF for the given number of observed events. For successfull operation the PDF implementation must indicate; it is extendable by overloading canBeExtended() and must; implemented the expectedEvents() function. RooAbsReal* createNLL(RooAbsData& data, const RooCmdArg& arg1 = RooCmdArg::none(), const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& a",MatchSource.WIKI,root/html602/RooAbsPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsPdf.html
https://root.cern/root/html602/RooAbsPdf.html:50759,Integrability,message,message,50759,"ion(const RooArgSet* dset, Bool_t adjustProxies = kTRUE) const; Verify that the normalization integral cached with this PDF; is valid for given set of normalization observables. If not, the cached normalization integral (if any) is deleted; and a new integral is constructed for use with 'nset'; Elements in 'nset' can be discrete and real, but must be lvalues. For functions that declare to be self-normalized by overloading the; selfNormalized() function, a unit normalization is always constructed. Bool_t traceEvalHook(Double_t value) const; WVE 08/21/01 Probably obsolete now. void resetErrorCounters(Int_t resetValue = 10); Reset error counter to given value, limiting the number; of future error messages for this pdf to 'resetValue'. void setTraceCounter(Int_t value, Bool_t allNodes = kFALSE); Reset trace counter to given value, limiting the; number of future trace messages for this pdf to 'value'. Double_t getLogVal(const RooArgSet* set = 0) const; Return the log of the current value with given normalization; An error message is printed if the argument of the log is negative. Double_t extendedTerm(Double_t observedEvents, const RooArgSet* nset = 0) const; Returned the extended likelihood term (Nexpect - Nobserved*log(NExpected); of this PDF for the given number of observed events. For successfull operation the PDF implementation must indicate; it is extendable by overloading canBeExtended() and must; implemented the expectedEvents() function. RooAbsReal* createNLL(RooAbsData& data, const RooCmdArg& arg1 = RooCmdArg::none(), const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()); Construct representation of -log(L) of PDFwith given dataset. If dataset is unbinned, an unbinned likelihood is constructed. If the dataset; is binne",MatchSource.WIKI,root/html602/RooAbsPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsPdf.html
https://root.cern/root/html602/RooAbsPdf.html:54579,Integrability,message,messages,54579," 30 dataset entries, for which strategy 2 is followed. Optimize(Bool_t flag) -- Activate constant term optimization (on by default); SplitRange(Bool_t flag) -- Use separate fit ranges in a simultaneous fit. Actual range name for each; subsample is assumed to by rangeName_{indexState} where indexState; is the state of the master index category of the simultaneous fit; Constrain(const RooArgSet&pars) -- For p.d.f.s that contain internal parameter constraint terms, only apply constraints to given subset of parameters; ExternalConstraints(const RooArgSet& ) -- Include given external constraints to likelihood; GlobalObservables(const RooArgSet&) -- Define the set of normalization observables to be used for the constraint terms.; If none are specified the constrained parameters are used; GlobalObservablesTag(const char* tagName) -- Define the set of normalization observables to be used for the constraint terms by a string attribute; associated with pdf observables that match the given tagName; Verbose(Bool_t flag) -- Constrols RooFit informational messages in likelihood construction; CloneData(Bool flag) -- Use clone of dataset in NLL (default is true); Offset(Bool_t) -- Offset likelihood by initial value (so that starting value of FCN in minuit is zero). This; can improve numeric stability in simultaneously fits with components with large likelihood values. RooAbsReal* createNLL(RooAbsData& data, const RooLinkedList& cmdList); Construct representation of -log(L) of PDFwith given dataset. If dataset is unbinned, an unbinned likelihood is constructed. If the dataset; is binned, a binned likelihood is constructed. See RooAbsPdf::createNLL(RooAbsData& data, RooCmdArg arg1, RooCmdArg arg2, RooCmdArg arg3, RooCmdArg arg4,; RooCmdArg arg5, RooCmdArg arg6, RooCmdArg arg7, RooCmdArg arg8). for documentation of options. RooFitResult* fitTo(RooAbsData& data, const RooCmdArg& arg1 = RooCmdArg::none(), const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(",MatchSource.WIKI,root/html602/RooAbsPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsPdf.html
https://root.cern/root/html602/RooAbsPdf.html:58939,Integrability,interface,interface,58939,"; subsample is assumed to by rangeName_{indexState} where indexState; is the state of the master index category of the simultaneous fit; Constrained() -- Apply all constrained contained in the p.d.f. in the likelihood; Contrain(const RooArgSet&pars) -- Apply constraints to listed parameters in likelihood using internal constrains in p.d.f; GlobalObservables(const RooArgSet&) -- Define the set of normalization observables to be used for the constraint terms.; If none are specified the constrained parameters are used; ExternalConstraints(const RooArgSet& ) -- Include given external constraints to likelihood; Offset(Bool_t) -- Offset likelihood by initial value (so that starting value of FCN in minuit is zero). This; can improve numeric stability in simultaneously fits with components with large likelihood values. Options to control flow of fit procedure. Minimizer(type,algo) -- Choose minimization package and algorithm to use. Default is MINUIT/MIGRAD through the RooMinimizer; interface, but others can be specified (through RooMinimizer interface). Select OldMinuit to use; MINUIT through the old RooMinuit interface. Type Algorithm; ------ ---------; OldMinuit migrad, simplex, minimize (=migrad+simplex), migradimproved (=migrad+improve); Minuit migrad, simplex, minimize (=migrad+simplex), migradimproved (=migrad+improve); Minuit2 migrad, simplex, minimize, scan; GSLMultiMin conjugatefr, conjugatepr, bfgs, bfgs2, steepestdescent; GSLSimAn -. InitialHesse(Bool_t flag) -- Flag controls if HESSE before MIGRAD as well, off by default; Optimize(Bool_t flag) -- Activate constant term optimization of test statistic during minimization (on by default); Hesse(Bool_t flag) -- Flag controls if HESSE is run after MIGRAD, on by default; Minos(Bool_t flag) -- Flag controls if MINOS is run after HESSE, off by default; Minos(const RooArgSet& set) -- Only run MINOS on given subset of arguments; Save(Bool_t flag) -- Flac controls if RooFitResult object is produced and returned, off by de",MatchSource.WIKI,root/html602/RooAbsPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsPdf.html
https://root.cern/root/html602/RooAbsPdf.html:59000,Integrability,interface,interface,59000,"; subsample is assumed to by rangeName_{indexState} where indexState; is the state of the master index category of the simultaneous fit; Constrained() -- Apply all constrained contained in the p.d.f. in the likelihood; Contrain(const RooArgSet&pars) -- Apply constraints to listed parameters in likelihood using internal constrains in p.d.f; GlobalObservables(const RooArgSet&) -- Define the set of normalization observables to be used for the constraint terms.; If none are specified the constrained parameters are used; ExternalConstraints(const RooArgSet& ) -- Include given external constraints to likelihood; Offset(Bool_t) -- Offset likelihood by initial value (so that starting value of FCN in minuit is zero). This; can improve numeric stability in simultaneously fits with components with large likelihood values. Options to control flow of fit procedure. Minimizer(type,algo) -- Choose minimization package and algorithm to use. Default is MINUIT/MIGRAD through the RooMinimizer; interface, but others can be specified (through RooMinimizer interface). Select OldMinuit to use; MINUIT through the old RooMinuit interface. Type Algorithm; ------ ---------; OldMinuit migrad, simplex, minimize (=migrad+simplex), migradimproved (=migrad+improve); Minuit migrad, simplex, minimize (=migrad+simplex), migradimproved (=migrad+improve); Minuit2 migrad, simplex, minimize, scan; GSLMultiMin conjugatefr, conjugatepr, bfgs, bfgs2, steepestdescent; GSLSimAn -. InitialHesse(Bool_t flag) -- Flag controls if HESSE before MIGRAD as well, off by default; Optimize(Bool_t flag) -- Activate constant term optimization of test statistic during minimization (on by default); Hesse(Bool_t flag) -- Flag controls if HESSE is run after MIGRAD, on by default; Minos(Bool_t flag) -- Flag controls if MINOS is run after HESSE, off by default; Minos(const RooArgSet& set) -- Only run MINOS on given subset of arguments; Save(Bool_t flag) -- Flac controls if RooFitResult object is produced and returned, off by de",MatchSource.WIKI,root/html602/RooAbsPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsPdf.html
https://root.cern/root/html602/RooAbsPdf.html:59070,Integrability,interface,interface,59070," index category of the simultaneous fit; Constrained() -- Apply all constrained contained in the p.d.f. in the likelihood; Contrain(const RooArgSet&pars) -- Apply constraints to listed parameters in likelihood using internal constrains in p.d.f; GlobalObservables(const RooArgSet&) -- Define the set of normalization observables to be used for the constraint terms.; If none are specified the constrained parameters are used; ExternalConstraints(const RooArgSet& ) -- Include given external constraints to likelihood; Offset(Bool_t) -- Offset likelihood by initial value (so that starting value of FCN in minuit is zero). This; can improve numeric stability in simultaneously fits with components with large likelihood values. Options to control flow of fit procedure. Minimizer(type,algo) -- Choose minimization package and algorithm to use. Default is MINUIT/MIGRAD through the RooMinimizer; interface, but others can be specified (through RooMinimizer interface). Select OldMinuit to use; MINUIT through the old RooMinuit interface. Type Algorithm; ------ ---------; OldMinuit migrad, simplex, minimize (=migrad+simplex), migradimproved (=migrad+improve); Minuit migrad, simplex, minimize (=migrad+simplex), migradimproved (=migrad+improve); Minuit2 migrad, simplex, minimize, scan; GSLMultiMin conjugatefr, conjugatepr, bfgs, bfgs2, steepestdescent; GSLSimAn -. InitialHesse(Bool_t flag) -- Flag controls if HESSE before MIGRAD as well, off by default; Optimize(Bool_t flag) -- Activate constant term optimization of test statistic during minimization (on by default); Hesse(Bool_t flag) -- Flag controls if HESSE is run after MIGRAD, on by default; Minos(Bool_t flag) -- Flag controls if MINOS is run after HESSE, off by default; Minos(const RooArgSet& set) -- Only run MINOS on given subset of arguments; Save(Bool_t flag) -- Flac controls if RooFitResult object is produced and returned, off by default; Strategy(Int_t flag) -- Set Minuit strategy (0 through 2, default is 1); FitOptions(const ",MatchSource.WIKI,root/html602/RooAbsPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsPdf.html
https://root.cern/root/html602/RooAbsPdf.html:60944,Integrability,message,messages,60944,"2, default is 1); FitOptions(const char* optStr) -- Steer fit with classic options string (for backward compatibility). Use of this option; excludes use of any of the new style steering options. SumW2Error(Bool_t flag) -- Apply correaction to errors and covariance matrix using sum-of-weights covariance matrix; to obtain correct error for weighted likelihood fits. If this option is activated the; corrected covariance matrix is calculated as Vcorr = V C-1 V, where V is the original; covariance matrix and C is the inverse of the covariance matrix calculated using the; weights squared. Options to control informational output. Verbose(Bool_t flag) -- Flag controls if verbose output is printed (NLL, parameter changes during fit; Timer(Bool_t flag) -- Time CPU and wall clock consumption of fit steps, off by default; PrintLevel(Int_t level) -- Set Minuit print level (-1 through 3, default is 1). At -1 all RooFit informational; messages are suppressed as well; Warnings(Bool_t flag) -- Enable or disable MINUIT warnings (enabled by default); PrintEvalErrors(Int_t numErr) -- Control number of p.d.f evaluation errors printed per likelihood evaluation. A negative; value suppress output completely, a zero value will only print the error count per p.d.f component,; a positive value is will print details of each error up to numErr messages per p.d.f component. RooFitResult* fitTo(RooAbsData& data, const RooLinkedList& cmdList); Fit PDF to given dataset. If dataset is unbinned, an unbinned maximum likelihood is performed. If the dataset; is binned, a binned maximum likelihood is performed. By default the fit is executed through the MINUIT; commands MIGRAD, HESSE and MINOS in succession. See RooAbsPdf::fitTo(RooAbsData& data, RooCmdArg arg1, RooCmdArg arg2, RooCmdArg arg3, RooCmdArg arg4,; RooCmdArg arg5, RooCmdArg arg6, RooCmdArg arg7, RooCmdArg arg8). for documentation of options. RooFitResult* chi2FitTo(RooDataHist& data, const RooLinkedList& cmdList); Internal back-end function to",MatchSource.WIKI,root/html602/RooAbsPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsPdf.html
https://root.cern/root/html602/RooAbsPdf.html:61347,Integrability,message,messages,61347," matrix; to obtain correct error for weighted likelihood fits. If this option is activated the; corrected covariance matrix is calculated as Vcorr = V C-1 V, where V is the original; covariance matrix and C is the inverse of the covariance matrix calculated using the; weights squared. Options to control informational output. Verbose(Bool_t flag) -- Flag controls if verbose output is printed (NLL, parameter changes during fit; Timer(Bool_t flag) -- Time CPU and wall clock consumption of fit steps, off by default; PrintLevel(Int_t level) -- Set Minuit print level (-1 through 3, default is 1). At -1 all RooFit informational; messages are suppressed as well; Warnings(Bool_t flag) -- Enable or disable MINUIT warnings (enabled by default); PrintEvalErrors(Int_t numErr) -- Control number of p.d.f evaluation errors printed per likelihood evaluation. A negative; value suppress output completely, a zero value will only print the error count per p.d.f component,; a positive value is will print details of each error up to numErr messages per p.d.f component. RooFitResult* fitTo(RooAbsData& data, const RooLinkedList& cmdList); Fit PDF to given dataset. If dataset is unbinned, an unbinned maximum likelihood is performed. If the dataset; is binned, a binned maximum likelihood is performed. By default the fit is executed through the MINUIT; commands MIGRAD, HESSE and MINOS in succession. See RooAbsPdf::fitTo(RooAbsData& data, RooCmdArg arg1, RooCmdArg arg2, RooCmdArg arg3, RooCmdArg arg4,; RooCmdArg arg5, RooCmdArg arg6, RooCmdArg arg7, RooCmdArg arg8). for documentation of options. RooFitResult* chi2FitTo(RooDataHist& data, const RooLinkedList& cmdList); Internal back-end function to steer chi2 fits. RooAbsReal* createChi2(RooDataHist& data, const RooCmdArg& arg1 = RooCmdArg::none(), const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCm",MatchSource.WIKI,root/html602/RooAbsPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsPdf.html
https://root.cern/root/html602/RooAbsPdf.html:65056,Integrability,message,messages,65056,"autoGenContext(const RooArgSet& vars, const RooDataSet* prototype = 0, const RooArgSet* auxProto = 0, Bool_t verbose = kFALSE, Bool_t autoBinned = kTRUE, const char* binnedTag = """") const. RooDataSet * generate(const RooArgSet& whatVars, Int_t nEvents, const RooCmdArg& arg1, const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none()); Generate a new dataset containing the specified variables with events sampled from our distribution.; Generate the specified number of events or expectedEvents() if not specified. Any variables of this PDF that are not in whatVars will use their; current values and be treated as fixed parameters. Returns zero; in case of an error. The caller takes ownership of the returned; dataset. The following named arguments are supported. Name(const char* name) -- Name of the output dataset; Verbose(Bool_t flag) -- Print informational messages during event generation; Extended() -- The actual number of events generated will be sampled from a Poisson distribution; with mu=nevt. For use with extended maximum likelihood fits; AutoBinned(Bool_t flag) -- Automatically deploy binned generation for binned distributions (e.g. RooHistPdf, sums and products of RooHistPdfs etc); NB: Datasets that are generated in binned mode are returned as weighted unbinned datasets. GenBinned(const char* tag) -- Use binned generation for all component pdfs that have 'setAttribute(tag)' set; AllBinned() -- As above, but for all components. Note that the notion of components is only meaningful for simultaneous pdf; as binned generation is always executed at the top-level node for a regular; pdf, so for those it only mattes that the top-level node is tagged. ProtoData(const RooDataSet& data, -- Use specified dataset as prototype dataset. If randOrder is set to true; Bool_t randOrder) the order of the events in the dataset will be read in a random order; if the reques",MatchSource.WIKI,root/html602/RooAbsPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsPdf.html
https://root.cern/root/html602/RooAbsPdf.html:67621,Integrability,message,messages,67621,"totype dataset with only variables in whatVars randomized. Variables in whatVars that; are not in the prototype will be added as new columns to the generated dataset. RooDataSet * generate(const RooArgSet& whatVars, const RooCmdArg& arg1 = RooCmdArg::none(), const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none()); Generate a new dataset containing the specified variables with events sampled from our distribution.; Generate the specified number of events or expectedEvents() if not specified. Any variables of this PDF that are not in whatVars will use their; current values and be treated as fixed parameters. Returns zero; in case of an error. The caller takes ownership of the returned; dataset. The following named arguments are supported. Name(const char* name) -- Name of the output dataset; Verbose(Bool_t flag) -- Print informational messages during event generation; NumEvent(int nevt) -- Generate specified number of events. AutoBinned(Bool_t flag) -- Automatically deploy binned generation for binned distributions (e.g. RooHistPdf, sums and products of RooHistPdfs etc); NB: Datasets that are generated in binned mode are returned as weighted unbinned datasets. GenBinned(const char* tag) -- Use binned generation for all component pdfs that have 'setAttribute(tag)' set; AllBinned() -- As above, but for all components. Note that the notion of components is only meaningful for simultaneous pdf; as binned generation is always executed at the top-level node for a regular; pdf, so for those it only mattes that the top-level node is tagged. Binned generation cannot be used when prototype data is supplied; Extended() -- The actual number of events generated will be sampled from a Poisson distribution; with mu=nevt. For use with extended maximum likelihood fits; ProtoData(const RooDataSet& data, -- Use specified dataset as",MatchSource.WIKI,root/html602/RooAbsPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsPdf.html
https://root.cern/root/html602/RooAbsPdf.html:73372,Integrability,depend,depends,73372,"cannot generate any of the directVars (in this case, nothing; should be added to generatedVars). Any non-zero codes will be passed to our generateEvent(); implementation, but otherwise its value is arbitrary. The default implemetation of; this method returns zero. Subclasses will usually implement this method using the; matchArgs() methods to advertise the algorithms they provide. void initGenerator(Int_t code); Interface for one-time initialization to setup the generator for the specified code. void generateEvent(Int_t code); Interface for generation of anan event using the algorithm; corresponding to the specified code. The meaning of each code is; defined by the getGenerator() implementation. The default; implementation does nothing. Bool_t isDirectGenSafe(const RooAbsArg& arg) const; Check if given observable can be safely generated using the; pdfs internal generator mechanism (if that existsP). Observables; on which a PDF depends via more than route are not safe; for use with internal generators because they introduce; correlations not known to the internal generator. RooDataHist * generateBinned(const RooArgSet& whatVars, Double_t nEvents, const RooCmdArg& arg1, const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none()); Generate a new dataset containing the specified variables with events sampled from our distribution.; Generate the specified number of events or expectedEvents() if not specified. Any variables of this PDF that are not in whatVars will use their; current values and be treated as fixed parameters. Returns zero; in case of an error. The caller takes ownership of the returned; dataset. The following named arguments are supported. Name(const char* name) -- Name of the output dataset; Verbose(Bool_t flag) -- Print informational messages during event generation; Extended() -- The actual number of events generated will be sampled from a Poi",MatchSource.WIKI,root/html602/RooAbsPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsPdf.html
https://root.cern/root/html602/RooAbsPdf.html:73394,Integrability,rout,route,73394,"cannot generate any of the directVars (in this case, nothing; should be added to generatedVars). Any non-zero codes will be passed to our generateEvent(); implementation, but otherwise its value is arbitrary. The default implemetation of; this method returns zero. Subclasses will usually implement this method using the; matchArgs() methods to advertise the algorithms they provide. void initGenerator(Int_t code); Interface for one-time initialization to setup the generator for the specified code. void generateEvent(Int_t code); Interface for generation of anan event using the algorithm; corresponding to the specified code. The meaning of each code is; defined by the getGenerator() implementation. The default; implementation does nothing. Bool_t isDirectGenSafe(const RooAbsArg& arg) const; Check if given observable can be safely generated using the; pdfs internal generator mechanism (if that existsP). Observables; on which a PDF depends via more than route are not safe; for use with internal generators because they introduce; correlations not known to the internal generator. RooDataHist * generateBinned(const RooArgSet& whatVars, Double_t nEvents, const RooCmdArg& arg1, const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none()); Generate a new dataset containing the specified variables with events sampled from our distribution.; Generate the specified number of events or expectedEvents() if not specified. Any variables of this PDF that are not in whatVars will use their; current values and be treated as fixed parameters. Returns zero; in case of an error. The caller takes ownership of the returned; dataset. The following named arguments are supported. Name(const char* name) -- Name of the output dataset; Verbose(Bool_t flag) -- Print informational messages during event generation; Extended() -- The actual number of events generated will be sampled from a Poi",MatchSource.WIKI,root/html602/RooAbsPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsPdf.html
https://root.cern/root/html602/RooAbsPdf.html:74320,Integrability,message,messages,74320,". Observables; on which a PDF depends via more than route are not safe; for use with internal generators because they introduce; correlations not known to the internal generator. RooDataHist * generateBinned(const RooArgSet& whatVars, Double_t nEvents, const RooCmdArg& arg1, const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none()); Generate a new dataset containing the specified variables with events sampled from our distribution.; Generate the specified number of events or expectedEvents() if not specified. Any variables of this PDF that are not in whatVars will use their; current values and be treated as fixed parameters. Returns zero; in case of an error. The caller takes ownership of the returned; dataset. The following named arguments are supported. Name(const char* name) -- Name of the output dataset; Verbose(Bool_t flag) -- Print informational messages during event generation; Extended() -- The actual number of events generated will be sampled from a Poisson distribution; with mu=nevt. For use with extended maximum likelihood fits; ExpectedData() -- Return a binned dataset _without_ statistical fluctuations (also aliased as Asimov()). RooDataHist * generateBinned(const RooArgSet& whatVars, const RooCmdArg& arg1 = RooCmdArg::none(), const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none()); Generate a new dataset containing the specified variables with events sampled from our distribution.; Generate the specified number of events or expectedEvents() if not specified. Any variables of this PDF that are not in whatVars will use their; current values and be treated as fixed parameters. Returns zero; in case of an error. The caller takes ownership of the returned; dataset. The following named argum",MatchSource.WIKI,root/html602/RooAbsPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsPdf.html
https://root.cern/root/html602/RooAbsPdf.html:75461,Integrability,message,messages,75461,"xpectedData() -- Return a binned dataset _without_ statistical fluctuations (also aliased as Asimov()). RooDataHist * generateBinned(const RooArgSet& whatVars, const RooCmdArg& arg1 = RooCmdArg::none(), const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none()); Generate a new dataset containing the specified variables with events sampled from our distribution.; Generate the specified number of events or expectedEvents() if not specified. Any variables of this PDF that are not in whatVars will use their; current values and be treated as fixed parameters. Returns zero; in case of an error. The caller takes ownership of the returned; dataset. The following named arguments are supported. Name(const char* name) -- Name of the output dataset; Verbose(Bool_t flag) -- Print informational messages during event generation; NumEvent(int nevt) -- Generate specified number of events; Extended() -- The actual number of events generated will be sampled from a Poisson distribution; with mu=nevt. For use with extended maximum likelihood fits; ExpectedData() -- Return a binned dataset _without_ statistical fluctuations (also aliased as Asimov()). RooDataHist * generateBinned(const RooArgSet& whatVars, Double_t nEvents, Bool_t expectedData = kFALSE, Bool_t extended = kFALSE) const; Generate a new dataset containing the specified variables with; events sampled from our distribution. Generate the specified; number of events or else try to use expectedEvents() if nEvents <= 0. If expectedData is kTRUE (it is kFALSE by default), the returned histogram returns the 'expected'; data sample, i.e. no statistical fluctuations are present. Any variables of this PDF that are not in whatVars will use their; current values and be treated as fixed parameters. Returns zero; in case of an error. The caller takes ownership of the returned; dataset.",MatchSource.WIKI,root/html602/RooAbsPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsPdf.html
https://root.cern/root/html602/RooAbsPdf.html:76605,Integrability,interface,interface,76605,"s generated will be sampled from a Poisson distribution; with mu=nevt. For use with extended maximum likelihood fits; ExpectedData() -- Return a binned dataset _without_ statistical fluctuations (also aliased as Asimov()). RooDataHist * generateBinned(const RooArgSet& whatVars, Double_t nEvents, Bool_t expectedData = kFALSE, Bool_t extended = kFALSE) const; Generate a new dataset containing the specified variables with; events sampled from our distribution. Generate the specified; number of events or else try to use expectedEvents() if nEvents <= 0. If expectedData is kTRUE (it is kFALSE by default), the returned histogram returns the 'expected'; data sample, i.e. no statistical fluctuations are present. Any variables of this PDF that are not in whatVars will use their; current values and be treated as fixed parameters. Returns zero; in case of an error. The caller takes ownership of the returned; dataset. RooDataSet* generateSimGlobal(const RooArgSet& whatVars, Int_t nEvents); Special generator interface for generation of 'global observables' -- for RooStats tools. RooPlot* plotOn(RooPlot* frame, RooLinkedList& cmdList) const; Plot (project) PDF on specified frame. If a PDF is plotted in an empty frame, it; will show a unit normalized curve in the frame variable, taken at the present value; of other observables defined for this PDF. If a PDF is plotted in a frame in which a dataset has already been plotted, it will; show a projected curve integrated over all variables that were present in the shown; dataset except for the one on the x-axis. The normalization of the curve will also; be adjusted to the event count of the plotted dataset. An informational message; will be printed for each projection step that is performed. This function takes the following named arguments. Projection control. Slice(const RooArgSet& set) -- Override default projection behaviour by omittting observables listed; in set from the projection, resulting a 'slice' plot. Slicing is usually; onl",MatchSource.WIKI,root/html602/RooAbsPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsPdf.html
https://root.cern/root/html602/RooAbsPdf.html:77058,Integrability,integrat,integrated,77058," Generate the specified; number of events or else try to use expectedEvents() if nEvents <= 0. If expectedData is kTRUE (it is kFALSE by default), the returned histogram returns the 'expected'; data sample, i.e. no statistical fluctuations are present. Any variables of this PDF that are not in whatVars will use their; current values and be treated as fixed parameters. Returns zero; in case of an error. The caller takes ownership of the returned; dataset. RooDataSet* generateSimGlobal(const RooArgSet& whatVars, Int_t nEvents); Special generator interface for generation of 'global observables' -- for RooStats tools. RooPlot* plotOn(RooPlot* frame, RooLinkedList& cmdList) const; Plot (project) PDF on specified frame. If a PDF is plotted in an empty frame, it; will show a unit normalized curve in the frame variable, taken at the present value; of other observables defined for this PDF. If a PDF is plotted in a frame in which a dataset has already been plotted, it will; show a projected curve integrated over all variables that were present in the shown; dataset except for the one on the x-axis. The normalization of the curve will also; be adjusted to the event count of the plotted dataset. An informational message; will be printed for each projection step that is performed. This function takes the following named arguments. Projection control. Slice(const RooArgSet& set) -- Override default projection behaviour by omittting observables listed; in set from the projection, resulting a 'slice' plot. Slicing is usually; only sensible in discrete observables; Project(const RooArgSet& set) -- Override default projection behaviour by projecting over observables; given in set and complete ignoring the default projection behavior. Advanced use only.; ProjWData(const RooAbsData& d) -- Override default projection _technique_ (integration). For observables present in given dataset; projection of PDF is achieved by constructing an average over all observable values in given set.; Con",MatchSource.WIKI,root/html602/RooAbsPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsPdf.html
https://root.cern/root/html602/RooAbsPdf.html:77276,Integrability,message,message,77276,"esent. Any variables of this PDF that are not in whatVars will use their; current values and be treated as fixed parameters. Returns zero; in case of an error. The caller takes ownership of the returned; dataset. RooDataSet* generateSimGlobal(const RooArgSet& whatVars, Int_t nEvents); Special generator interface for generation of 'global observables' -- for RooStats tools. RooPlot* plotOn(RooPlot* frame, RooLinkedList& cmdList) const; Plot (project) PDF on specified frame. If a PDF is plotted in an empty frame, it; will show a unit normalized curve in the frame variable, taken at the present value; of other observables defined for this PDF. If a PDF is plotted in a frame in which a dataset has already been plotted, it will; show a projected curve integrated over all variables that were present in the shown; dataset except for the one on the x-axis. The normalization of the curve will also; be adjusted to the event count of the plotted dataset. An informational message; will be printed for each projection step that is performed. This function takes the following named arguments. Projection control. Slice(const RooArgSet& set) -- Override default projection behaviour by omittting observables listed; in set from the projection, resulting a 'slice' plot. Slicing is usually; only sensible in discrete observables; Project(const RooArgSet& set) -- Override default projection behaviour by projecting over observables; given in set and complete ignoring the default projection behavior. Advanced use only.; ProjWData(const RooAbsData& d) -- Override default projection _technique_ (integration). For observables present in given dataset; projection of PDF is achieved by constructing an average over all observable values in given set.; Consult RooFit plotting tutorial for further explanation of meaning & use of this technique; ProjWData(const RooArgSet& s, -- As above but only consider subset 's' of observables in dataset 'd' for projection through data averaging; const RooAbsData",MatchSource.WIKI,root/html602/RooAbsPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsPdf.html
https://root.cern/root/html602/RooAbsPdf.html:77897,Integrability,integrat,integration,77897,"ame variable, taken at the present value; of other observables defined for this PDF. If a PDF is plotted in a frame in which a dataset has already been plotted, it will; show a projected curve integrated over all variables that were present in the shown; dataset except for the one on the x-axis. The normalization of the curve will also; be adjusted to the event count of the plotted dataset. An informational message; will be printed for each projection step that is performed. This function takes the following named arguments. Projection control. Slice(const RooArgSet& set) -- Override default projection behaviour by omittting observables listed; in set from the projection, resulting a 'slice' plot. Slicing is usually; only sensible in discrete observables; Project(const RooArgSet& set) -- Override default projection behaviour by projecting over observables; given in set and complete ignoring the default projection behavior. Advanced use only.; ProjWData(const RooAbsData& d) -- Override default projection _technique_ (integration). For observables present in given dataset; projection of PDF is achieved by constructing an average over all observable values in given set.; Consult RooFit plotting tutorial for further explanation of meaning & use of this technique; ProjWData(const RooArgSet& s, -- As above but only consider subset 's' of observables in dataset 'd' for projection through data averaging; const RooAbsData& d); ProjectionRange(const char* rn) -- Override default range of projection integrals to a different range speficied by given range name.; This technique allows you to project a finite width slice in a real-valued observable; NormRange(const char* name) -- Calculate curve normalization w.r.t. only in specified ranges. NB: A Range() by default implies a NormRange(); on the same range, but this option allows to override the default, or specify a normalization ranges; when the full curve is to be drawn. Misc content control. Normalization(Double_t scale, -- A",MatchSource.WIKI,root/html602/RooAbsPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsPdf.html
https://root.cern/root/html602/RooAbsPdf.html:78933,Integrability,depend,depends,78933,"ed by constructing an average over all observable values in given set.; Consult RooFit plotting tutorial for further explanation of meaning & use of this technique; ProjWData(const RooArgSet& s, -- As above but only consider subset 's' of observables in dataset 'd' for projection through data averaging; const RooAbsData& d); ProjectionRange(const char* rn) -- Override default range of projection integrals to a different range speficied by given range name.; This technique allows you to project a finite width slice in a real-valued observable; NormRange(const char* name) -- Calculate curve normalization w.r.t. only in specified ranges. NB: A Range() by default implies a NormRange(); on the same range, but this option allows to override the default, or specify a normalization ranges; when the full curve is to be drawn. Misc content control. Normalization(Double_t scale, -- Adjust normalization by given scale factor. Interpretation of number depends on code: Relative:; ScaleType code) relative adjustment factor, NumEvent: scale to match given number of events.; Name(const chat* name) -- Give curve specified name in frame. Useful if curve is to be referenced later; Asymmetry(const RooCategory& c) -- Show the asymmetry of the PDF in given two-state category [F(+)-F(-)] / [F(+)+F(-)] rather than; the PDF projection. Category must have two states with indices -1 and +1 or three states with; indeces -1,0 and +1.; ShiftToZero(Bool_t flag) -- Shift entire curve such that lowest visible point is at exactly zero. Mostly useful when; plotting -log(L) or chi^2 distributions; AddTo(const char* name, -- Add constructed projection to already existing curve with given name and relative weight factors; double_t wgtSelf, double_t wgtOther). Plotting control. LineStyle(Int_t style) -- Select line style by ROOT line style code, default is solid; LineColor(Int_t color) -- Select line color by ROOT color code, default is blue; LineWidth(Int_t width) -- Select line with in pixels, default i",MatchSource.WIKI,root/html602/RooAbsPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsPdf.html
https://root.cern/root/html602/RooAbsPdf.html:84707,Integrability,integrat,integrated,84707,"000000000000002, Double_t xmax = 0.98999999999999999, Double_t ymax = 0.94999999999999996, const RooCmdArg* formatCmd = 0); Add a text box with the current parameter values and their errors to the frame.; Observables of this PDF appearing in the 'data' dataset will be omitted. Optional label will be inserted as first line of the text box. Use 'sigDigits'; to modify the default number of significant digits printed. The 'xmin,xmax,ymax'; values specify the inital relative position of the text box in the plot frame. Double_t expectedEvents(const RooArgSet* nset) const; Return expected number of events from this p.d.f for use in extended; likelihood calculations. This default implementation returns zero. void verboseEval(Int_t stat); Change global level of verbosity for p.d.f. evaluations. Int_t verboseEval(); Return global level of verbosity for p.d.f. evaluations. RooAbsPdf* createProjection(const RooArgSet& iset); Return a p.d.f that represent a projection of this p.d.f integrated over given observables. RooAbsReal* createCdf(const RooArgSet& iset, const RooArgSet& nset = RooArgSet()); Create a cumulative distribution function of this p.d.f in terms; of the observables listed in iset. If no nset argument is given; the c.d.f normalization is constructed over the integrated; observables, so that its maximum value is precisely 1. It is also; possible to choose a different normalization for; multi-dimensional p.d.f.s: eg. for a pdf f(x,y,z) one can; construct a partial cdf c(x,y) that only when integrated itself; over z results in a maximum value of 1. To construct such a cdf pass; z as argument to the optional nset argument. RooAbsReal* createCdf(const RooArgSet& iset, const RooCmdArg& arg1, const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = R",MatchSource.WIKI,root/html602/RooAbsPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsPdf.html
https://root.cern/root/html602/RooAbsPdf.html:85004,Integrability,integrat,integrated,85004,"ill be inserted as first line of the text box. Use 'sigDigits'; to modify the default number of significant digits printed. The 'xmin,xmax,ymax'; values specify the inital relative position of the text box in the plot frame. Double_t expectedEvents(const RooArgSet* nset) const; Return expected number of events from this p.d.f for use in extended; likelihood calculations. This default implementation returns zero. void verboseEval(Int_t stat); Change global level of verbosity for p.d.f. evaluations. Int_t verboseEval(); Return global level of verbosity for p.d.f. evaluations. RooAbsPdf* createProjection(const RooArgSet& iset); Return a p.d.f that represent a projection of this p.d.f integrated over given observables. RooAbsReal* createCdf(const RooArgSet& iset, const RooArgSet& nset = RooArgSet()); Create a cumulative distribution function of this p.d.f in terms; of the observables listed in iset. If no nset argument is given; the c.d.f normalization is constructed over the integrated; observables, so that its maximum value is precisely 1. It is also; possible to choose a different normalization for; multi-dimensional p.d.f.s: eg. for a pdf f(x,y,z) one can; construct a partial cdf c(x,y) that only when integrated itself; over z results in a maximum value of 1. To construct such a cdf pass; z as argument to the optional nset argument. RooAbsReal* createCdf(const RooArgSet& iset, const RooCmdArg& arg1, const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()); Create an object that represents the integral of the function over one or more observables listed in iset; The actual integration calculation is only performed when the return object is evaluated. The name; of the integral object is automatically constructed from the name of",MatchSource.WIKI,root/html602/RooAbsPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsPdf.html
https://root.cern/root/html602/RooAbsPdf.html:85238,Integrability,integrat,integrated,85238," plot frame. Double_t expectedEvents(const RooArgSet* nset) const; Return expected number of events from this p.d.f for use in extended; likelihood calculations. This default implementation returns zero. void verboseEval(Int_t stat); Change global level of verbosity for p.d.f. evaluations. Int_t verboseEval(); Return global level of verbosity for p.d.f. evaluations. RooAbsPdf* createProjection(const RooArgSet& iset); Return a p.d.f that represent a projection of this p.d.f integrated over given observables. RooAbsReal* createCdf(const RooArgSet& iset, const RooArgSet& nset = RooArgSet()); Create a cumulative distribution function of this p.d.f in terms; of the observables listed in iset. If no nset argument is given; the c.d.f normalization is constructed over the integrated; observables, so that its maximum value is precisely 1. It is also; possible to choose a different normalization for; multi-dimensional p.d.f.s: eg. for a pdf f(x,y,z) one can; construct a partial cdf c(x,y) that only when integrated itself; over z results in a maximum value of 1. To construct such a cdf pass; z as argument to the optional nset argument. RooAbsReal* createCdf(const RooArgSet& iset, const RooCmdArg& arg1, const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()); Create an object that represents the integral of the function over one or more observables listed in iset; The actual integration calculation is only performed when the return object is evaluated. The name; of the integral object is automatically constructed from the name of the input function, the variables; it integrates and the range integrates over. The following named arguments are accepted. SupNormSet(const RooArgSet&) -- Observables over which should be normalized _in_addition",MatchSource.WIKI,root/html602/RooAbsPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsPdf.html
https://root.cern/root/html602/RooAbsPdf.html:85860,Integrability,integrat,integration,85860,"rn a p.d.f that represent a projection of this p.d.f integrated over given observables. RooAbsReal* createCdf(const RooArgSet& iset, const RooArgSet& nset = RooArgSet()); Create a cumulative distribution function of this p.d.f in terms; of the observables listed in iset. If no nset argument is given; the c.d.f normalization is constructed over the integrated; observables, so that its maximum value is precisely 1. It is also; possible to choose a different normalization for; multi-dimensional p.d.f.s: eg. for a pdf f(x,y,z) one can; construct a partial cdf c(x,y) that only when integrated itself; over z results in a maximum value of 1. To construct such a cdf pass; z as argument to the optional nset argument. RooAbsReal* createCdf(const RooArgSet& iset, const RooCmdArg& arg1, const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()); Create an object that represents the integral of the function over one or more observables listed in iset; The actual integration calculation is only performed when the return object is evaluated. The name; of the integral object is automatically constructed from the name of the input function, the variables; it integrates and the range integrates over. The following named arguments are accepted. SupNormSet(const RooArgSet&) -- Observables over which should be normalized _in_addition_ to the; integration observables; ScanNumCdf() -- Apply scanning technique if cdf integral involves numeric integration [ default ]; ScanAllCdf() -- Always apply scanning technique; ScanNoCdf() -- Never apply scanning technique; ScanParameters(Int_t nbins, -- Parameters for scanning technique of making CDF: number; Int_t intOrder) of sampled bins and order of interpolation applied on numeric cdf. RooAbsReal* createScanCd",MatchSource.WIKI,root/html602/RooAbsPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsPdf.html
https://root.cern/root/html602/RooAbsPdf.html:86056,Integrability,integrat,integrates,86056,"bservables, so that its maximum value is precisely 1. It is also; possible to choose a different normalization for; multi-dimensional p.d.f.s: eg. for a pdf f(x,y,z) one can; construct a partial cdf c(x,y) that only when integrated itself; over z results in a maximum value of 1. To construct such a cdf pass; z as argument to the optional nset argument. RooAbsReal* createCdf(const RooArgSet& iset, const RooCmdArg& arg1, const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()); Create an object that represents the integral of the function over one or more observables listed in iset; The actual integration calculation is only performed when the return object is evaluated. The name; of the integral object is automatically constructed from the name of the input function, the variables; it integrates and the range integrates over. The following named arguments are accepted. SupNormSet(const RooArgSet&) -- Observables over which should be normalized _in_addition_ to the; integration observables; ScanNumCdf() -- Apply scanning technique if cdf integral involves numeric integration [ default ]; ScanAllCdf() -- Always apply scanning technique; ScanNoCdf() -- Never apply scanning technique; ScanParameters(Int_t nbins, -- Parameters for scanning technique of making CDF: number; Int_t intOrder) of sampled bins and order of interpolation applied on numeric cdf. RooAbsReal* createScanCdf(const RooArgSet& iset, const RooArgSet& nset, Int_t numScanBins, Int_t intOrder). RooArgSet* getAllConstraints(const RooArgSet& observables, RooArgSet& constrainedParams, Bool_t stripDisconnected = kTRUE) const; This helper function finds and collects all constraints terms of all coponent p.d.f.s; and returns a RooArgSet with all those terms. void clearEvalEr",MatchSource.WIKI,root/html602/RooAbsPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsPdf.html
https://root.cern/root/html602/RooAbsPdf.html:86081,Integrability,integrat,integrates,86081,"bservables, so that its maximum value is precisely 1. It is also; possible to choose a different normalization for; multi-dimensional p.d.f.s: eg. for a pdf f(x,y,z) one can; construct a partial cdf c(x,y) that only when integrated itself; over z results in a maximum value of 1. To construct such a cdf pass; z as argument to the optional nset argument. RooAbsReal* createCdf(const RooArgSet& iset, const RooCmdArg& arg1, const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()); Create an object that represents the integral of the function over one or more observables listed in iset; The actual integration calculation is only performed when the return object is evaluated. The name; of the integral object is automatically constructed from the name of the input function, the variables; it integrates and the range integrates over. The following named arguments are accepted. SupNormSet(const RooArgSet&) -- Observables over which should be normalized _in_addition_ to the; integration observables; ScanNumCdf() -- Apply scanning technique if cdf integral involves numeric integration [ default ]; ScanAllCdf() -- Always apply scanning technique; ScanNoCdf() -- Never apply scanning technique; ScanParameters(Int_t nbins, -- Parameters for scanning technique of making CDF: number; Int_t intOrder) of sampled bins and order of interpolation applied on numeric cdf. RooAbsReal* createScanCdf(const RooArgSet& iset, const RooArgSet& nset, Int_t numScanBins, Int_t intOrder). RooArgSet* getAllConstraints(const RooArgSet& observables, RooArgSet& constrainedParams, Bool_t stripDisconnected = kTRUE) const; This helper function finds and collects all constraints terms of all coponent p.d.f.s; and returns a RooArgSet with all those terms. void clearEvalEr",MatchSource.WIKI,root/html602/RooAbsPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsPdf.html
https://root.cern/root/html602/RooAbsPdf.html:86240,Integrability,integrat,integration,86240,"reateCdf(const RooArgSet& iset, const RooCmdArg& arg1, const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()); Create an object that represents the integral of the function over one or more observables listed in iset; The actual integration calculation is only performed when the return object is evaluated. The name; of the integral object is automatically constructed from the name of the input function, the variables; it integrates and the range integrates over. The following named arguments are accepted. SupNormSet(const RooArgSet&) -- Observables over which should be normalized _in_addition_ to the; integration observables; ScanNumCdf() -- Apply scanning technique if cdf integral involves numeric integration [ default ]; ScanAllCdf() -- Always apply scanning technique; ScanNoCdf() -- Never apply scanning technique; ScanParameters(Int_t nbins, -- Parameters for scanning technique of making CDF: number; Int_t intOrder) of sampled bins and order of interpolation applied on numeric cdf. RooAbsReal* createScanCdf(const RooArgSet& iset, const RooArgSet& nset, Int_t numScanBins, Int_t intOrder). RooArgSet* getAllConstraints(const RooArgSet& observables, RooArgSet& constrainedParams, Bool_t stripDisconnected = kTRUE) const; This helper function finds and collects all constraints terms of all coponent p.d.f.s; and returns a RooArgSet with all those terms. void clearEvalError(); Clear the evaluation error flag. Bool_t evalError(); Return the evaluation error flag. void raiseEvalError(); Raise the evaluation error flag. RooNumGenConfig* defaultGeneratorConfig(); Returns the default numeric MC generator configuration for all RooAbsReals. RooNumGenConfig* specialGeneratorConfig() const; Returns the specialized integrator configuration f",MatchSource.WIKI,root/html602/RooAbsPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsPdf.html
https://root.cern/root/html602/RooAbsPdf.html:86339,Integrability,integrat,integration,86339,"reateCdf(const RooArgSet& iset, const RooCmdArg& arg1, const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()); Create an object that represents the integral of the function over one or more observables listed in iset; The actual integration calculation is only performed when the return object is evaluated. The name; of the integral object is automatically constructed from the name of the input function, the variables; it integrates and the range integrates over. The following named arguments are accepted. SupNormSet(const RooArgSet&) -- Observables over which should be normalized _in_addition_ to the; integration observables; ScanNumCdf() -- Apply scanning technique if cdf integral involves numeric integration [ default ]; ScanAllCdf() -- Always apply scanning technique; ScanNoCdf() -- Never apply scanning technique; ScanParameters(Int_t nbins, -- Parameters for scanning technique of making CDF: number; Int_t intOrder) of sampled bins and order of interpolation applied on numeric cdf. RooAbsReal* createScanCdf(const RooArgSet& iset, const RooArgSet& nset, Int_t numScanBins, Int_t intOrder). RooArgSet* getAllConstraints(const RooArgSet& observables, RooArgSet& constrainedParams, Bool_t stripDisconnected = kTRUE) const; This helper function finds and collects all constraints terms of all coponent p.d.f.s; and returns a RooArgSet with all those terms. void clearEvalError(); Clear the evaluation error flag. Bool_t evalError(); Return the evaluation error flag. void raiseEvalError(); Raise the evaluation error flag. RooNumGenConfig* defaultGeneratorConfig(); Returns the default numeric MC generator configuration for all RooAbsReals. RooNumGenConfig* specialGeneratorConfig() const; Returns the specialized integrator configuration f",MatchSource.WIKI,root/html602/RooAbsPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsPdf.html
https://root.cern/root/html602/RooAbsPdf.html:87360,Integrability,integrat,integrator,87360,"tion [ default ]; ScanAllCdf() -- Always apply scanning technique; ScanNoCdf() -- Never apply scanning technique; ScanParameters(Int_t nbins, -- Parameters for scanning technique of making CDF: number; Int_t intOrder) of sampled bins and order of interpolation applied on numeric cdf. RooAbsReal* createScanCdf(const RooArgSet& iset, const RooArgSet& nset, Int_t numScanBins, Int_t intOrder). RooArgSet* getAllConstraints(const RooArgSet& observables, RooArgSet& constrainedParams, Bool_t stripDisconnected = kTRUE) const; This helper function finds and collects all constraints terms of all coponent p.d.f.s; and returns a RooArgSet with all those terms. void clearEvalError(); Clear the evaluation error flag. Bool_t evalError(); Return the evaluation error flag. void raiseEvalError(); Raise the evaluation error flag. RooNumGenConfig* defaultGeneratorConfig(); Returns the default numeric MC generator configuration for all RooAbsReals. RooNumGenConfig* specialGeneratorConfig() const; Returns the specialized integrator configuration for _this_ RooAbsReal.; If this object has no specialized configuration, a null pointer is returned. RooNumGenConfig* specialGeneratorConfig(Bool_t createOnTheFly); Returns the specialized integrator configuration for _this_ RooAbsReal.; If this object has no specialized configuration, a null pointer is returned,; unless createOnTheFly is kTRUE in which case a clone of the default integrator; configuration is created, installed as specialized configuration, and returned. const RooNumGenConfig* getGeneratorConfig() const; Return the numeric MC generator configuration used for this object. If; a specialized configuration was associated with this object, that configuration; is returned, otherwise the default configuration for all RooAbsReals is returned. void setGeneratorConfig(const RooNumGenConfig& config); Set the given configuration as default numeric MC generator; configuration for this object. void setGeneratorConfig(); Remove the specialized nu",MatchSource.WIKI,root/html602/RooAbsPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsPdf.html
https://root.cern/root/html602/RooAbsPdf.html:87574,Integrability,integrat,integrator,87574," intOrder) of sampled bins and order of interpolation applied on numeric cdf. RooAbsReal* createScanCdf(const RooArgSet& iset, const RooArgSet& nset, Int_t numScanBins, Int_t intOrder). RooArgSet* getAllConstraints(const RooArgSet& observables, RooArgSet& constrainedParams, Bool_t stripDisconnected = kTRUE) const; This helper function finds and collects all constraints terms of all coponent p.d.f.s; and returns a RooArgSet with all those terms. void clearEvalError(); Clear the evaluation error flag. Bool_t evalError(); Return the evaluation error flag. void raiseEvalError(); Raise the evaluation error flag. RooNumGenConfig* defaultGeneratorConfig(); Returns the default numeric MC generator configuration for all RooAbsReals. RooNumGenConfig* specialGeneratorConfig() const; Returns the specialized integrator configuration for _this_ RooAbsReal.; If this object has no specialized configuration, a null pointer is returned. RooNumGenConfig* specialGeneratorConfig(Bool_t createOnTheFly); Returns the specialized integrator configuration for _this_ RooAbsReal.; If this object has no specialized configuration, a null pointer is returned,; unless createOnTheFly is kTRUE in which case a clone of the default integrator; configuration is created, installed as specialized configuration, and returned. const RooNumGenConfig* getGeneratorConfig() const; Return the numeric MC generator configuration used for this object. If; a specialized configuration was associated with this object, that configuration; is returned, otherwise the default configuration for all RooAbsReals is returned. void setGeneratorConfig(const RooNumGenConfig& config); Set the given configuration as default numeric MC generator; configuration for this object. void setGeneratorConfig(); Remove the specialized numeric MC generator configuration associated; with this object. void setNormRange(const char* rangeName). void setNormRangeOverride(const char* rangeName). GenSpec* prepareMultiGen(const RooArgSet& whatVars,",MatchSource.WIKI,root/html602/RooAbsPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsPdf.html
https://root.cern/root/html602/RooAbsPdf.html:87769,Integrability,integrat,integrator,87769,"ooArgSet* getAllConstraints(const RooArgSet& observables, RooArgSet& constrainedParams, Bool_t stripDisconnected = kTRUE) const; This helper function finds and collects all constraints terms of all coponent p.d.f.s; and returns a RooArgSet with all those terms. void clearEvalError(); Clear the evaluation error flag. Bool_t evalError(); Return the evaluation error flag. void raiseEvalError(); Raise the evaluation error flag. RooNumGenConfig* defaultGeneratorConfig(); Returns the default numeric MC generator configuration for all RooAbsReals. RooNumGenConfig* specialGeneratorConfig() const; Returns the specialized integrator configuration for _this_ RooAbsReal.; If this object has no specialized configuration, a null pointer is returned. RooNumGenConfig* specialGeneratorConfig(Bool_t createOnTheFly); Returns the specialized integrator configuration for _this_ RooAbsReal.; If this object has no specialized configuration, a null pointer is returned,; unless createOnTheFly is kTRUE in which case a clone of the default integrator; configuration is created, installed as specialized configuration, and returned. const RooNumGenConfig* getGeneratorConfig() const; Return the numeric MC generator configuration used for this object. If; a specialized configuration was associated with this object, that configuration; is returned, otherwise the default configuration for all RooAbsReals is returned. void setGeneratorConfig(const RooNumGenConfig& config); Set the given configuration as default numeric MC generator; configuration for this object. void setGeneratorConfig(); Remove the specialized numeric MC generator configuration associated; with this object. void setNormRange(const char* rangeName). void setNormRangeOverride(const char* rangeName). GenSpec* prepareMultiGen(const RooArgSet& whatVars, const RooCmdArg& arg1 = RooCmdArg::none(), const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg",MatchSource.WIKI,root/html602/RooAbsPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsPdf.html
https://root.cern/root/html602/RooAbsPdf.html:960,Modifiability,variab,variables,960,". RooAbsPdf. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » ROOFIT; » ROOFITCORE; » RooAbsPdf. class RooAbsPdf: public RooAbsReal. RooAbsPdf is the abstract interface for all probability density; functions The class provides hybrid analytical/numerical; normalization for its implementations, error tracing and a MC; generator interface. A minimal implementation of a PDF class derived from RooAbsPdf; should overload the evaluate() function. This functions should; return PDFs value. [Normalization/Integration]. Although the normalization of a PDF is an integral part of a; probability density function, normalization is treated separately; in RooAbsPdf. The reason is that a RooAbsPdf object is more than a; PDF: it can be a building block for a more complex, composite PDF; if any of its variables are functions instead of variables. In; such cases the normalization of the composite may not be simply the; integral over the dependents of the top level PDF as these are; functions with potentially non-trivial Jacobian terms themselves.; Therefore. --> No explicit attempt should be made to normalize; the functions output in evaluate(). In addition, RooAbsPdf objects do not have a static concept of what; variables are parameters and what variables are dependents (which; need to be integrated over for a correct PDF normalization).; Instead the choice of normalization is always specified each time a; normalized values is requested from the PDF via the getVal(); method. RooAbsPdf manages the entire normalization logic of each PDF with; help of a RooRealIntegral object, which coordinates the integration; of a given choice of normalization. By default, RooRealIntegral will; perform a fully numeric integration of all dependents. However,; PDFs can advertise one or more (partial) analytical integrals of; their function, a",MatchSource.WIKI,root/html602/RooAbsPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsPdf.html
https://root.cern/root/html602/RooAbsPdf.html:995,Modifiability,variab,variables,995,". RooAbsPdf. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » ROOFIT; » ROOFITCORE; » RooAbsPdf. class RooAbsPdf: public RooAbsReal. RooAbsPdf is the abstract interface for all probability density; functions The class provides hybrid analytical/numerical; normalization for its implementations, error tracing and a MC; generator interface. A minimal implementation of a PDF class derived from RooAbsPdf; should overload the evaluate() function. This functions should; return PDFs value. [Normalization/Integration]. Although the normalization of a PDF is an integral part of a; probability density function, normalization is treated separately; in RooAbsPdf. The reason is that a RooAbsPdf object is more than a; PDF: it can be a building block for a more complex, composite PDF; if any of its variables are functions instead of variables. In; such cases the normalization of the composite may not be simply the; integral over the dependents of the top level PDF as these are; functions with potentially non-trivial Jacobian terms themselves.; Therefore. --> No explicit attempt should be made to normalize; the functions output in evaluate(). In addition, RooAbsPdf objects do not have a static concept of what; variables are parameters and what variables are dependents (which; need to be integrated over for a correct PDF normalization).; Instead the choice of normalization is always specified each time a; normalized values is requested from the PDF via the getVal(); method. RooAbsPdf manages the entire normalization logic of each PDF with; help of a RooRealIntegral object, which coordinates the integration; of a given choice of normalization. By default, RooRealIntegral will; perform a fully numeric integration of all dependents. However,; PDFs can advertise one or more (partial) analytical integrals of; their function, a",MatchSource.WIKI,root/html602/RooAbsPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsPdf.html
https://root.cern/root/html602/RooAbsPdf.html:1379,Modifiability,variab,variables,1379,"cal/numerical; normalization for its implementations, error tracing and a MC; generator interface. A minimal implementation of a PDF class derived from RooAbsPdf; should overload the evaluate() function. This functions should; return PDFs value. [Normalization/Integration]. Although the normalization of a PDF is an integral part of a; probability density function, normalization is treated separately; in RooAbsPdf. The reason is that a RooAbsPdf object is more than a; PDF: it can be a building block for a more complex, composite PDF; if any of its variables are functions instead of variables. In; such cases the normalization of the composite may not be simply the; integral over the dependents of the top level PDF as these are; functions with potentially non-trivial Jacobian terms themselves.; Therefore. --> No explicit attempt should be made to normalize; the functions output in evaluate(). In addition, RooAbsPdf objects do not have a static concept of what; variables are parameters and what variables are dependents (which; need to be integrated over for a correct PDF normalization).; Instead the choice of normalization is always specified each time a; normalized values is requested from the PDF via the getVal(); method. RooAbsPdf manages the entire normalization logic of each PDF with; help of a RooRealIntegral object, which coordinates the integration; of a given choice of normalization. By default, RooRealIntegral will; perform a fully numeric integration of all dependents. However,; PDFs can advertise one or more (partial) analytical integrals of; their function, and these will be used by RooRealIntegral, if it; determines that this is safe (i.e. no hidden Jacobian terms,; multiplication with other PDFs that have one or more dependents in; commen etc). To implement analytical integrals, two functions must be implemented. First,. Int_t getAnalyticalIntegral(const RooArgSet& integSet, RooArgSet& anaIntSet). advertises the analytical integrals that are supported. 'in",MatchSource.WIKI,root/html602/RooAbsPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsPdf.html
https://root.cern/root/html602/RooAbsPdf.html:1413,Modifiability,variab,variables,1413,"cal/numerical; normalization for its implementations, error tracing and a MC; generator interface. A minimal implementation of a PDF class derived from RooAbsPdf; should overload the evaluate() function. This functions should; return PDFs value. [Normalization/Integration]. Although the normalization of a PDF is an integral part of a; probability density function, normalization is treated separately; in RooAbsPdf. The reason is that a RooAbsPdf object is more than a; PDF: it can be a building block for a more complex, composite PDF; if any of its variables are functions instead of variables. In; such cases the normalization of the composite may not be simply the; integral over the dependents of the top level PDF as these are; functions with potentially non-trivial Jacobian terms themselves.; Therefore. --> No explicit attempt should be made to normalize; the functions output in evaluate(). In addition, RooAbsPdf objects do not have a static concept of what; variables are parameters and what variables are dependents (which; need to be integrated over for a correct PDF normalization).; Instead the choice of normalization is always specified each time a; normalized values is requested from the PDF via the getVal(); method. RooAbsPdf manages the entire normalization logic of each PDF with; help of a RooRealIntegral object, which coordinates the integration; of a given choice of normalization. By default, RooRealIntegral will; perform a fully numeric integration of all dependents. However,; PDFs can advertise one or more (partial) analytical integrals of; their function, and these will be used by RooRealIntegral, if it; determines that this is safe (i.e. no hidden Jacobian terms,; multiplication with other PDFs that have one or more dependents in; commen etc). To implement analytical integrals, two functions must be implemented. First,. Int_t getAnalyticalIntegral(const RooArgSet& integSet, RooArgSet& anaIntSet). advertises the analytical integrals that are supported. 'in",MatchSource.WIKI,root/html602/RooAbsPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsPdf.html
https://root.cern/root/html602/RooAbsPdf.html:2635,Modifiability,config,configuration,2635," each time a; normalized values is requested from the PDF via the getVal(); method. RooAbsPdf manages the entire normalization logic of each PDF with; help of a RooRealIntegral object, which coordinates the integration; of a given choice of normalization. By default, RooRealIntegral will; perform a fully numeric integration of all dependents. However,; PDFs can advertise one or more (partial) analytical integrals of; their function, and these will be used by RooRealIntegral, if it; determines that this is safe (i.e. no hidden Jacobian terms,; multiplication with other PDFs that have one or more dependents in; commen etc). To implement analytical integrals, two functions must be implemented. First,. Int_t getAnalyticalIntegral(const RooArgSet& integSet, RooArgSet& anaIntSet). advertises the analytical integrals that are supported. 'integSet'; is the set of dependents for which integration is requested. The; function should copy the subset of dependents it can analytically; integrate to anaIntSet and return a unique identification code for; this integration configuration. If no integration can be; performed, zero should be returned. Second,. Double_t analyticalIntegral(Int_t code). Implements the actual analytical integral(s) advertised by; getAnalyticalIntegral. This functions will only be called with; codes returned by getAnalyticalIntegral, except code zero. The integration range for real each dependent to be integrated can; be obtained from the dependents' proxy functions min() and; max(). Never call these proxy functions for any proxy not known to; be a dependent via the integration code. Doing so may be; ill-defined, e.g. in case the proxy holds a function, and will; trigger an assert. Integrated category dependents should always be; summed over all of their states. [Direct generation of observables]. Any PDF dependent can be generated with the accept/reject method,; but for certain PDFs more efficient methods may be implemented. To; implement direct generation ",MatchSource.WIKI,root/html602/RooAbsPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsPdf.html
https://root.cern/root/html602/RooAbsPdf.html:17675,Modifiability,extend,extended,17675," const; RooDataSet*generate(RooAbsPdf::GenSpec&) const; RooDataSet*generate(const RooArgSet& whatVars, const RooDataSet& prototype, Int_t nEvents = 0, Bool_t verbose = kFALSE, Bool_t randProtoOrder = kFALSE, Bool_t resampleProto = kFALSE) const; RooDataSet*generate(const RooArgSet& whatVars, Int_t nEvents, const RooCmdArg& arg1, const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none()); RooDataSet*generate(const RooArgSet& whatVars, const RooCmdArg& arg1 = RooCmdArg::none(), const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none()); RooDataSet*generate(const RooArgSet& whatVars, Double_t nEvents = 0, Bool_t verbose = kFALSE, Bool_t autoBinned = kTRUE, const char* binnedTag = """", Bool_t expectedData = kFALSE, Bool_t extended = kFALSE) const; virtual RooDataHist*generateBinned(const RooArgSet& whatVars, Double_t nEvents, Bool_t expectedData = kFALSE, Bool_t extended = kFALSE) const; virtual RooDataHist*generateBinned(const RooArgSet& whatVars, Double_t nEvents, const RooCmdArg& arg1, const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none()); virtual RooDataHist*generateBinned(const RooArgSet& whatVars, const RooCmdArg& arg1 = RooCmdArg::none(), const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none()); virtual voidgenerateEvent(Int_t code); virtual RooDataSet*generateSimGlobal(const RooArgSet& whatVars, Int_t nEvents); virtual RooArgSet*getAllConstraints(const RooArgSet& observables, RooArgSet& constrainedParams, Bool_t stripDisconnected",MatchSource.WIKI,root/html602/RooAbsPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsPdf.html
https://root.cern/root/html602/RooAbsPdf.html:17818,Modifiability,extend,extended,17818,"ts = 0, Bool_t verbose = kFALSE, Bool_t randProtoOrder = kFALSE, Bool_t resampleProto = kFALSE) const; RooDataSet*generate(const RooArgSet& whatVars, Int_t nEvents, const RooCmdArg& arg1, const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none()); RooDataSet*generate(const RooArgSet& whatVars, const RooCmdArg& arg1 = RooCmdArg::none(), const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none()); RooDataSet*generate(const RooArgSet& whatVars, Double_t nEvents = 0, Bool_t verbose = kFALSE, Bool_t autoBinned = kTRUE, const char* binnedTag = """", Bool_t expectedData = kFALSE, Bool_t extended = kFALSE) const; virtual RooDataHist*generateBinned(const RooArgSet& whatVars, Double_t nEvents, Bool_t expectedData = kFALSE, Bool_t extended = kFALSE) const; virtual RooDataHist*generateBinned(const RooArgSet& whatVars, Double_t nEvents, const RooCmdArg& arg1, const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none()); virtual RooDataHist*generateBinned(const RooArgSet& whatVars, const RooCmdArg& arg1 = RooCmdArg::none(), const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none()); virtual voidgenerateEvent(Int_t code); virtual RooDataSet*generateSimGlobal(const RooArgSet& whatVars, Int_t nEvents); virtual RooArgSet*getAllConstraints(const RooArgSet& observables, RooArgSet& constrainedParams, Bool_t stripDisconnected = kTRUE) const; virtual Int_tRooAbsReal::getAnalyticalIntegral(RooArgSet& allVars, RooArgSet& analVars, const char* rangeName = 0) const; virt",MatchSource.WIKI,root/html602/RooAbsPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsPdf.html
https://root.cern/root/html602/RooAbsPdf.html:32392,Modifiability,config,config,32392,"ENU ; virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); virtual Bool_tselfNormalized() const; TIterator*RooAbsArg::serverIterator() const; RooFIterRooAbsArg::serverMIterator() const; virtual voidRooAbsArg::serverNameChangeHook(const RooAbsArg*, const RooAbsArg*); voidRooAbsArg::setAttribute(const Text_t* name, Bool_t value = kTRUE); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); virtual voidRooAbsArg::setCacheAndTrackHints(RooArgSet&); static voidRooAbsReal::setCacheCheck(Bool_t flag); virtual Bool_tRooAbsReal::setData(RooAbsData&, Bool_t = kTRUE); static voidRooAbsArg::setDirtyInhibit(Bool_t flag); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); static voidRooAbsReal::setEvalErrorLoggingMode(RooAbsReal::ErrorLoggingMode m); virtual voidRooAbsArg::setExpensiveObjectCache(RooExpensiveObjectCache& cache); voidsetGeneratorConfig(); voidsetGeneratorConfig(const RooNumGenConfig& config); static voidRooAbsReal::setHideOffset(Bool_t flag); voidRooAbsReal::setIntegratorConfig(); voidRooAbsReal::setIntegratorConfig(const RooNumIntConfig& config); voidRooAbsArg::setLocalNoDirtyInhibit(Bool_t flag) const; virtual voidRooAbsArg::SetName(const char* name); virtual voidRooAbsArg::SetNameTitle(const char* name, const char* title); voidsetNormRange(const char* rangeName); voidsetNormRangeOverride(const char* rangeName); static voidTObject::SetObjectStat(Bool_t stat); voidRooAbsArg::setOperMode(RooAbsArg::OperMode mode, Bool_t recurseADirty = kTRUE); voidRooAbsReal::setParameterizeIntegral(const RooArgSet& paramVars); voidRooAbsReal::setPlotLabel(const char* label); voidRooAbsArg::setProhibitServerRedirect(Bool_t flag); voidRooAbsArg::setShapeDirty() const; voidRooAbsArg::setStringAttribute(const Text_t* key, const Text_t* value); virtual voidTNamed::SetTitle(const char* title = """")MENU ; voidsetTraceCounter(Int_t value, Bool_t allNodes = kFALSE); voidRooAbsArg::setTransientA",MatchSource.WIKI,root/html602/RooAbsPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsPdf.html
https://root.cern/root/html602/RooAbsPdf.html:32550,Modifiability,config,config,32550,"st; RooFIterRooAbsArg::serverMIterator() const; virtual voidRooAbsArg::serverNameChangeHook(const RooAbsArg*, const RooAbsArg*); voidRooAbsArg::setAttribute(const Text_t* name, Bool_t value = kTRUE); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); virtual voidRooAbsArg::setCacheAndTrackHints(RooArgSet&); static voidRooAbsReal::setCacheCheck(Bool_t flag); virtual Bool_tRooAbsReal::setData(RooAbsData&, Bool_t = kTRUE); static voidRooAbsArg::setDirtyInhibit(Bool_t flag); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); static voidRooAbsReal::setEvalErrorLoggingMode(RooAbsReal::ErrorLoggingMode m); virtual voidRooAbsArg::setExpensiveObjectCache(RooExpensiveObjectCache& cache); voidsetGeneratorConfig(); voidsetGeneratorConfig(const RooNumGenConfig& config); static voidRooAbsReal::setHideOffset(Bool_t flag); voidRooAbsReal::setIntegratorConfig(); voidRooAbsReal::setIntegratorConfig(const RooNumIntConfig& config); voidRooAbsArg::setLocalNoDirtyInhibit(Bool_t flag) const; virtual voidRooAbsArg::SetName(const char* name); virtual voidRooAbsArg::SetNameTitle(const char* name, const char* title); voidsetNormRange(const char* rangeName); voidsetNormRangeOverride(const char* rangeName); static voidTObject::SetObjectStat(Bool_t stat); voidRooAbsArg::setOperMode(RooAbsArg::OperMode mode, Bool_t recurseADirty = kTRUE); voidRooAbsReal::setParameterizeIntegral(const RooArgSet& paramVars); voidRooAbsReal::setPlotLabel(const char* label); voidRooAbsArg::setProhibitServerRedirect(Bool_t flag); voidRooAbsArg::setShapeDirty() const; voidRooAbsArg::setStringAttribute(const Text_t* key, const Text_t* value); virtual voidTNamed::SetTitle(const char* title = """")MENU ; voidsetTraceCounter(Int_t value, Bool_t allNodes = kFALSE); voidRooAbsArg::setTransientAttribute(const Text_t* name, Bool_t value = kTRUE); virtual voidTObject::SetUniqueID(UInt_t uid); voidRooAbsReal::setUnit(const char* unit); voidRooAbsArg::se",MatchSource.WIKI,root/html602/RooAbsPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsPdf.html
https://root.cern/root/html602/RooAbsPdf.html:37039,Modifiability,extend,extended,37039,"dList& cmdList); TStringRooAbsArg::cleanBranchName() const; virtual voidRooAbsReal::copyCache(const RooAbsArg* source, Bool_t valueOnly = kFALSE, Bool_t setValDirty = kTRUE); RooAbsReal*RooAbsReal::createIntObj(const RooArgSet& iset, const RooArgSet* nset, const RooNumIntConfig* cfg, const char* rangeName) const; virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; virtual Double_tRooAbsReal::evaluate() const; virtual voidRooAbsReal::fillTreeBranch(TTree& t); voidRooAbsReal::findInnerMostIntegration(const RooArgSet& allObs, RooArgSet& innerObs, const char* rangeName) const; virtual RooAbsGenContext*genContext(const RooArgSet& vars, const RooDataSet* prototype = 0, const RooArgSet* auxProto = 0, Bool_t verbose = kFALSE) const; RooDataSet*generate(RooAbsGenContext& context, const RooArgSet& whatVars, const RooDataSet* prototype, Double_t nEvents, Bool_t verbose, Bool_t randProtoOrder, Bool_t resampleProto, Bool_t skipInit = kFALSE, Bool_t extended = kFALSE) const; virtual voidRooAbsArg::getObservablesHook(const RooArgSet*, RooArgSet*) const; virtual voidRooAbsArg::getParametersHook(const RooArgSet*, RooArgSet*, Bool_t) const; RooAbsProxy*RooAbsArg::getProxy(Int_t index) const; static voidRooAbsReal::globalSelectComp(Bool_t flag); voidRooAbsArg::graphVizAddConnections(set<pair<RooAbsArg*,RooAbsArg*> >&); Bool_tRooAbsArg::inhibitDirty() const; TStringRooAbsReal::integralNameSuffix(const RooArgSet& iset, const RooArgSet* nset = 0, const char* rangeName = 0, Bool_t omitEmpty = kFALSE) const; Bool_tRooAbsReal::isSelectedComp() const; virtual Bool_tRooAbsReal::isValid() const; virtual Bool_tRooAbsReal::isValidReal(Double_t value, Bool_t printError = kFALSE) const; voidRooAbsReal::makeProjectionSet(const RooAbsArg* plotVar, const RooArgSet* allVars, RooArgSet& projectedVars, Bool_t silent) const; voidTObject::MakeZombie(); Bool_tRooAbsReal::matchArgs(const RooArgSet& allDeps, RooArgSet& numDeps, const RooArgProxy& a) const; Bool_tR",MatchSource.WIKI,root/html602/RooAbsPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsPdf.html
https://root.cern/root/html602/RooAbsPdf.html:46957,Modifiability,config,configuration,46957,"t_t_negCountNumber of negative probablities remaining to print; RooAbsReal*_norm! Normalization integral (owned by _normMgr); RooObjCacheManager_normMgrThe cache manager; TString_normRangeNormalization range; static TString_normRangeOverride; RooArgSet*_normSet! Normalization set with for above integral; RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; Int_tRooAbsReal::_plotBinsNumber of plot bins; Double_tRooAbsReal::_plotMaxMaximum of plot range; Double_tRooAbsReal::_plotMinMinimum of plot range; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; RooRefArrayRooAbsArg::_proxyListlist of proxies; Double_t_rawValue; Char_tRooAbsReal::_sbyteValue! Transient cache for signed byte values from tree branches; Bool_t_selectCompComponent selection flag for RooAbsPdf::plotCompOn; Bool_tRooAbsReal::_selectComp! Component selection flag for RooAbsPdf::plotCompOn; RooRefCountListRooAbsArg::_serverListlist of server objects; Bool_tRooAbsArg::_shapeDirtyFlag set if value needs recalculating because input shapes modified; RooNumGenConfig*_specGeneratorConfig! MC generator configuration specific for this object; RooNumIntConfig*RooAbsReal::_specIntegratorConfigNumeric integrator configuration specific for this object; map<string,string>RooAbsArg::_stringAttribString attributes; Int_t_traceCountNumber of traces remaining to print; Bool_tRooAbsReal::_treeVar!do not persist; UInt_tRooAbsReal::_uintValue! Transient cache for unsigned integer values from tree branches; TStringRooAbsReal::_unitUnit for objects value; Double_tRooAbsReal::_valueCache for current value of object; Bool_tRooAbsArg::_valueDirtyFlag set if value needs recalculating because input values modified; static Bool_tRooAbsArg::_verboseDirtyStatic flag controlling verbose messaging for dirty state changes; static Int_t_verboseEval; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title.",MatchSource.WIKI,root/html602/RooAbsPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsPdf.html
https://root.cern/root/html602/RooAbsPdf.html:47065,Modifiability,config,configuration,47065,"t_t_negCountNumber of negative probablities remaining to print; RooAbsReal*_norm! Normalization integral (owned by _normMgr); RooObjCacheManager_normMgrThe cache manager; TString_normRangeNormalization range; static TString_normRangeOverride; RooArgSet*_normSet! Normalization set with for above integral; RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; Int_tRooAbsReal::_plotBinsNumber of plot bins; Double_tRooAbsReal::_plotMaxMaximum of plot range; Double_tRooAbsReal::_plotMinMinimum of plot range; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; RooRefArrayRooAbsArg::_proxyListlist of proxies; Double_t_rawValue; Char_tRooAbsReal::_sbyteValue! Transient cache for signed byte values from tree branches; Bool_t_selectCompComponent selection flag for RooAbsPdf::plotCompOn; Bool_tRooAbsReal::_selectComp! Component selection flag for RooAbsPdf::plotCompOn; RooRefCountListRooAbsArg::_serverListlist of server objects; Bool_tRooAbsArg::_shapeDirtyFlag set if value needs recalculating because input shapes modified; RooNumGenConfig*_specGeneratorConfig! MC generator configuration specific for this object; RooNumIntConfig*RooAbsReal::_specIntegratorConfigNumeric integrator configuration specific for this object; map<string,string>RooAbsArg::_stringAttribString attributes; Int_t_traceCountNumber of traces remaining to print; Bool_tRooAbsReal::_treeVar!do not persist; UInt_tRooAbsReal::_uintValue! Transient cache for unsigned integer values from tree branches; TStringRooAbsReal::_unitUnit for objects value; Double_tRooAbsReal::_valueCache for current value of object; Bool_tRooAbsArg::_valueDirtyFlag set if value needs recalculating because input values modified; static Bool_tRooAbsArg::_verboseDirtyStatic flag controlling verbose messaging for dirty state changes; static Int_t_verboseEval; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title.",MatchSource.WIKI,root/html602/RooAbsPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsPdf.html
https://root.cern/root/html602/RooAbsPdf.html:50827,Modifiability,extend,extendedTerm,50827,"d normalization integral (if any) is deleted; and a new integral is constructed for use with 'nset'; Elements in 'nset' can be discrete and real, but must be lvalues. For functions that declare to be self-normalized by overloading the; selfNormalized() function, a unit normalization is always constructed. Bool_t traceEvalHook(Double_t value) const; WVE 08/21/01 Probably obsolete now. void resetErrorCounters(Int_t resetValue = 10); Reset error counter to given value, limiting the number; of future error messages for this pdf to 'resetValue'. void setTraceCounter(Int_t value, Bool_t allNodes = kFALSE); Reset trace counter to given value, limiting the; number of future trace messages for this pdf to 'value'. Double_t getLogVal(const RooArgSet* set = 0) const; Return the log of the current value with given normalization; An error message is printed if the argument of the log is negative. Double_t extendedTerm(Double_t observedEvents, const RooArgSet* nset = 0) const; Returned the extended likelihood term (Nexpect - Nobserved*log(NExpected); of this PDF for the given number of observed events. For successfull operation the PDF implementation must indicate; it is extendable by overloading canBeExtended() and must; implemented the expectedEvents() function. RooAbsReal* createNLL(RooAbsData& data, const RooCmdArg& arg1 = RooCmdArg::none(), const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()); Construct representation of -log(L) of PDFwith given dataset. If dataset is unbinned, an unbinned likelihood is constructed. If the dataset; is binned, a binned likelihood is constructed. The following named arguments are supported. ConditionalObservables(const RooArgSet& set) -- Do not normalize PDF over listed observables; Extended(Bool_t fl",MatchSource.WIKI,root/html602/RooAbsPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsPdf.html
https://root.cern/root/html602/RooAbsPdf.html:50912,Modifiability,extend,extended,50912,"d normalization integral (if any) is deleted; and a new integral is constructed for use with 'nset'; Elements in 'nset' can be discrete and real, but must be lvalues. For functions that declare to be self-normalized by overloading the; selfNormalized() function, a unit normalization is always constructed. Bool_t traceEvalHook(Double_t value) const; WVE 08/21/01 Probably obsolete now. void resetErrorCounters(Int_t resetValue = 10); Reset error counter to given value, limiting the number; of future error messages for this pdf to 'resetValue'. void setTraceCounter(Int_t value, Bool_t allNodes = kFALSE); Reset trace counter to given value, limiting the; number of future trace messages for this pdf to 'value'. Double_t getLogVal(const RooArgSet* set = 0) const; Return the log of the current value with given normalization; An error message is printed if the argument of the log is negative. Double_t extendedTerm(Double_t observedEvents, const RooArgSet* nset = 0) const; Returned the extended likelihood term (Nexpect - Nobserved*log(NExpected); of this PDF for the given number of observed events. For successfull operation the PDF implementation must indicate; it is extendable by overloading canBeExtended() and must; implemented the expectedEvents() function. RooAbsReal* createNLL(RooAbsData& data, const RooCmdArg& arg1 = RooCmdArg::none(), const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()); Construct representation of -log(L) of PDFwith given dataset. If dataset is unbinned, an unbinned likelihood is constructed. If the dataset; is binned, a binned likelihood is constructed. The following named arguments are supported. ConditionalObservables(const RooArgSet& set) -- Do not normalize PDF over listed observables; Extended(Bool_t fl",MatchSource.WIKI,root/html602/RooAbsPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsPdf.html
https://root.cern/root/html602/RooAbsPdf.html:51097,Modifiability,extend,extendable,51097,"eclare to be self-normalized by overloading the; selfNormalized() function, a unit normalization is always constructed. Bool_t traceEvalHook(Double_t value) const; WVE 08/21/01 Probably obsolete now. void resetErrorCounters(Int_t resetValue = 10); Reset error counter to given value, limiting the number; of future error messages for this pdf to 'resetValue'. void setTraceCounter(Int_t value, Bool_t allNodes = kFALSE); Reset trace counter to given value, limiting the; number of future trace messages for this pdf to 'value'. Double_t getLogVal(const RooArgSet* set = 0) const; Return the log of the current value with given normalization; An error message is printed if the argument of the log is negative. Double_t extendedTerm(Double_t observedEvents, const RooArgSet* nset = 0) const; Returned the extended likelihood term (Nexpect - Nobserved*log(NExpected); of this PDF for the given number of observed events. For successfull operation the PDF implementation must indicate; it is extendable by overloading canBeExtended() and must; implemented the expectedEvents() function. RooAbsReal* createNLL(RooAbsData& data, const RooCmdArg& arg1 = RooCmdArg::none(), const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()); Construct representation of -log(L) of PDFwith given dataset. If dataset is unbinned, an unbinned likelihood is constructed. If the dataset; is binned, a binned likelihood is constructed. The following named arguments are supported. ConditionalObservables(const RooArgSet& set) -- Do not normalize PDF over listed observables; Extended(Bool_t flag) -- Add extended likelihood term, off by default; Range(const char* name) -- Fit only data inside range with given name; Range(Double_t lo, Double_t hi) -- Fit only data inside given r",MatchSource.WIKI,root/html602/RooAbsPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsPdf.html
https://root.cern/root/html602/RooAbsPdf.html:51933,Modifiability,extend,extended,51933,"(NExpected); of this PDF for the given number of observed events. For successfull operation the PDF implementation must indicate; it is extendable by overloading canBeExtended() and must; implemented the expectedEvents() function. RooAbsReal* createNLL(RooAbsData& data, const RooCmdArg& arg1 = RooCmdArg::none(), const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()); Construct representation of -log(L) of PDFwith given dataset. If dataset is unbinned, an unbinned likelihood is constructed. If the dataset; is binned, a binned likelihood is constructed. The following named arguments are supported. ConditionalObservables(const RooArgSet& set) -- Do not normalize PDF over listed observables; Extended(Bool_t flag) -- Add extended likelihood term, off by default; Range(const char* name) -- Fit only data inside range with given name; Range(Double_t lo, Double_t hi) -- Fit only data inside given range. A range named ""fit"" is created on the fly on all observables.; Multiple comma separated range names can be specified.; SumCoefRange(const char* name) -- Set the range in which to interpret the coefficients of RooAddPdf components; NumCPU(int num, int strat) -- Parallelize NLL calculation on num CPUs. Strategy 0 = RooFit::BulkPartition (Default) --> Divide events in N equal chunks; Strategy 1 = RooFit::Interleave --> Process event i%N in process N. Recommended for binned data with; a substantial number of zero-bins, which will be distributed across processes more equitably in this strategy; Strategy 2 = RooFit::SimComponents --> Process each component likelihood of a RooSimultaneous fully in a single process; and distribute components over processes. This approach can be benificial if normalization calculation time; dominates the total ",MatchSource.WIKI,root/html602/RooAbsPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsPdf.html
https://root.cern/root/html602/RooAbsPdf.html:56206,Modifiability,extend,extended,56206,"mdArg arg3, RooCmdArg arg4,; RooCmdArg arg5, RooCmdArg arg6, RooCmdArg arg7, RooCmdArg arg8). for documentation of options. RooFitResult* fitTo(RooAbsData& data, const RooCmdArg& arg1 = RooCmdArg::none(), const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()); Fit PDF to given dataset. If dataset is unbinned, an unbinned maximum likelihood is performed. If the dataset; is binned, a binned maximum likelihood is performed. By default the fit is executed through the MINUIT; commands MIGRAD, HESSE in succession. The following named arguments are supported. Options to control construction of -log(L). ConditionalObservables(const RooArgSet& set) -- Do not normalize PDF over listed observables; Extended(Bool_t flag) -- Add extended likelihood term, off by default; Range(const char* name) -- Fit only data inside range with given name; Range(Double_t lo, Double_t hi) -- Fit only data inside given range. A range named ""fit"" is created on the fly on all observables.; Multiple comma separated range names can be specified.; SumCoefRange(const char* name) -- Set the range in which to interpret the coefficients of RooAddPdf components; NumCPU(int num, int strat) -- Parallelize NLL calculation on num CPUs. Strategy 0 = RooFit::BulkPartition (Default) --> Divide events in N equal chunks; Strategy 1 = RooFit::Interleave --> Process event i%N in process N. Recommended for binned data with; a substantial number of zero-bins, which will be distributed across processes more equitably in this strategy; Strategy 2 = RooFit::SimComponents --> Process each component likelihood of a RooSimultaneous fully in a single process; and distribute components over processes. This approach can be benificial if normalization calculation time; dominates the total ",MatchSource.WIKI,root/html602/RooAbsPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsPdf.html
https://root.cern/root/html602/RooAbsPdf.html:62608,Modifiability,extend,extended,62608,"elihood is performed. By default the fit is executed through the MINUIT; commands MIGRAD, HESSE and MINOS in succession. See RooAbsPdf::fitTo(RooAbsData& data, RooCmdArg arg1, RooCmdArg arg2, RooCmdArg arg3, RooCmdArg arg4,; RooCmdArg arg5, RooCmdArg arg6, RooCmdArg arg7, RooCmdArg arg8). for documentation of options. RooFitResult* chi2FitTo(RooDataHist& data, const RooLinkedList& cmdList); Internal back-end function to steer chi2 fits. RooAbsReal* createChi2(RooDataHist& data, const RooCmdArg& arg1 = RooCmdArg::none(), const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()); Create a chi-2 from a histogram and this function. The following named arguments are supported. Options to control construction of the chi^2. Extended() -- Use expected number of events of an extended p.d.f as normalization; DataError() -- Choose between Expected error [RooAbsData::Expected] , or Observed error (e.g. Sum-of-weights [RooAbsData:SumW2] or Poisson interval [RooAbsData::Poisson] ); Default is AUTO : Expected error for unweighted data, Sum-of-weights for weighted data; NumCPU() -- Activate parallel processing feature; Range() -- Fit only selected region; SumCoefRange() -- Set the range in which to interpret the coefficients of RooAddPdf components; SplitRange() -- Fit range is split by index catory of simultaneous PDF; ConditionalObservables() -- Define projected observables. RooAbsReal* createChi2(RooDataSet& data, const RooLinkedList& cmdList); Internal back-end function to create a chi^2 from a p.d.f. and a dataset. void printValue(ostream& os) const; Print value of p.d.f, also print normalization integral that was last used, if any. void printMultiline(ostream& os, Int_t contents, Bool_t verbose = kFALSE, TString indent = """") const; Print",MatchSource.WIKI,root/html602/RooAbsPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsPdf.html
https://root.cern/root/html602/RooAbsPdf.html:64575,Modifiability,variab,variables,64575,"tegral that was last used, if any. void printMultiline(ostream& os, Int_t contents, Bool_t verbose = kFALSE, TString indent = """") const; Print multi line detailed information of this RooAbsPdf. RooAbsGenContext* binnedGenContext(const RooArgSet& vars, Bool_t verbose = kFALSE) const; Return a binned generator context. RooAbsGenContext* genContext(const RooArgSet& vars, const RooDataSet* prototype = 0, const RooArgSet* auxProto = 0, Bool_t verbose = kFALSE) const; Interface function to create a generator context from a p.d.f. This default; implementation returns a 'standard' context that works for any p.d.f. RooAbsGenContext* autoGenContext(const RooArgSet& vars, const RooDataSet* prototype = 0, const RooArgSet* auxProto = 0, Bool_t verbose = kFALSE, Bool_t autoBinned = kTRUE, const char* binnedTag = """") const. RooDataSet * generate(const RooArgSet& whatVars, Int_t nEvents, const RooCmdArg& arg1, const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none()); Generate a new dataset containing the specified variables with events sampled from our distribution.; Generate the specified number of events or expectedEvents() if not specified. Any variables of this PDF that are not in whatVars will use their; current values and be treated as fixed parameters. Returns zero; in case of an error. The caller takes ownership of the returned; dataset. The following named arguments are supported. Name(const char* name) -- Name of the output dataset; Verbose(Bool_t flag) -- Print informational messages during event generation; Extended() -- The actual number of events generated will be sampled from a Poisson distribution; with mu=nevt. For use with extended maximum likelihood fits; AutoBinned(Bool_t flag) -- Automatically deploy binned generation for binned distributions (e.g. RooHistPdf, sums and products of RooHistPdfs etc); NB: Datasets that are generated in binned mode are ",MatchSource.WIKI,root/html602/RooAbsPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsPdf.html
https://root.cern/root/html602/RooAbsPdf.html:64711,Modifiability,variab,variables,64711,"RooAbsGenContext* genContext(const RooArgSet& vars, const RooDataSet* prototype = 0, const RooArgSet* auxProto = 0, Bool_t verbose = kFALSE) const; Interface function to create a generator context from a p.d.f. This default; implementation returns a 'standard' context that works for any p.d.f. RooAbsGenContext* autoGenContext(const RooArgSet& vars, const RooDataSet* prototype = 0, const RooArgSet* auxProto = 0, Bool_t verbose = kFALSE, Bool_t autoBinned = kTRUE, const char* binnedTag = """") const. RooDataSet * generate(const RooArgSet& whatVars, Int_t nEvents, const RooCmdArg& arg1, const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none()); Generate a new dataset containing the specified variables with events sampled from our distribution.; Generate the specified number of events or expectedEvents() if not specified. Any variables of this PDF that are not in whatVars will use their; current values and be treated as fixed parameters. Returns zero; in case of an error. The caller takes ownership of the returned; dataset. The following named arguments are supported. Name(const char* name) -- Name of the output dataset; Verbose(Bool_t flag) -- Print informational messages during event generation; Extended() -- The actual number of events generated will be sampled from a Poisson distribution; with mu=nevt. For use with extended maximum likelihood fits; AutoBinned(Bool_t flag) -- Automatically deploy binned generation for binned distributions (e.g. RooHistPdf, sums and products of RooHistPdfs etc); NB: Datasets that are generated in binned mode are returned as weighted unbinned datasets. GenBinned(const char* tag) -- Use binned generation for all component pdfs that have 'setAttribute(tag)' set; AllBinned() -- As above, but for all components. Note that the notion of components is only meaningful for simultaneous pdf; as binned generation is always executed at ",MatchSource.WIKI,root/html602/RooAbsPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsPdf.html
https://root.cern/root/html602/RooAbsPdf.html:65214,Modifiability,extend,extended,65214,"ataSet * generate(const RooArgSet& whatVars, Int_t nEvents, const RooCmdArg& arg1, const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none()); Generate a new dataset containing the specified variables with events sampled from our distribution.; Generate the specified number of events or expectedEvents() if not specified. Any variables of this PDF that are not in whatVars will use their; current values and be treated as fixed parameters. Returns zero; in case of an error. The caller takes ownership of the returned; dataset. The following named arguments are supported. Name(const char* name) -- Name of the output dataset; Verbose(Bool_t flag) -- Print informational messages during event generation; Extended() -- The actual number of events generated will be sampled from a Poisson distribution; with mu=nevt. For use with extended maximum likelihood fits; AutoBinned(Bool_t flag) -- Automatically deploy binned generation for binned distributions (e.g. RooHistPdf, sums and products of RooHistPdfs etc); NB: Datasets that are generated in binned mode are returned as weighted unbinned datasets. GenBinned(const char* tag) -- Use binned generation for all component pdfs that have 'setAttribute(tag)' set; AllBinned() -- As above, but for all components. Note that the notion of components is only meaningful for simultaneous pdf; as binned generation is always executed at the top-level node for a regular; pdf, so for those it only mattes that the top-level node is tagged. ProtoData(const RooDataSet& data, -- Use specified dataset as prototype dataset. If randOrder is set to true; Bool_t randOrder) the order of the events in the dataset will be read in a random order; if the requested number of events to be generated does not match the; number of events in the prototype dataset. If ProtoData() is used, the specified existing dataset as a prototype: the new dataset will ",MatchSource.WIKI,root/html602/RooAbsPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsPdf.html
https://root.cern/root/html602/RooAbsPdf.html:66371,Modifiability,variab,variables,66371," (e.g. RooHistPdf, sums and products of RooHistPdfs etc); NB: Datasets that are generated in binned mode are returned as weighted unbinned datasets. GenBinned(const char* tag) -- Use binned generation for all component pdfs that have 'setAttribute(tag)' set; AllBinned() -- As above, but for all components. Note that the notion of components is only meaningful for simultaneous pdf; as binned generation is always executed at the top-level node for a regular; pdf, so for those it only mattes that the top-level node is tagged. ProtoData(const RooDataSet& data, -- Use specified dataset as prototype dataset. If randOrder is set to true; Bool_t randOrder) the order of the events in the dataset will be read in a random order; if the requested number of events to be generated does not match the; number of events in the prototype dataset. If ProtoData() is used, the specified existing dataset as a prototype: the new dataset will contain; the same number of events as the prototype (unless otherwise specified), and any prototype variables not in; whatVars will be copied into the new dataset for each generated event and also used to set our PDF parameters.; The user can specify a number of events to generate that will override the default. The result is a; copy of the prototype dataset with only variables in whatVars randomized. Variables in whatVars that; are not in the prototype will be added as new columns to the generated dataset. RooDataSet * generate(const RooArgSet& whatVars, const RooCmdArg& arg1 = RooCmdArg::none(), const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none()); Generate a new dataset containing the specified variables with events sampled from our distribution.; Generate the specified number of events or expectedEvents() if not specified. Any variables of this PDF that are not in whatVars will use their; ",MatchSource.WIKI,root/html602/RooAbsPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsPdf.html
https://root.cern/root/html602/RooAbsPdf.html:66642,Modifiability,variab,variables,66642," all components. Note that the notion of components is only meaningful for simultaneous pdf; as binned generation is always executed at the top-level node for a regular; pdf, so for those it only mattes that the top-level node is tagged. ProtoData(const RooDataSet& data, -- Use specified dataset as prototype dataset. If randOrder is set to true; Bool_t randOrder) the order of the events in the dataset will be read in a random order; if the requested number of events to be generated does not match the; number of events in the prototype dataset. If ProtoData() is used, the specified existing dataset as a prototype: the new dataset will contain; the same number of events as the prototype (unless otherwise specified), and any prototype variables not in; whatVars will be copied into the new dataset for each generated event and also used to set our PDF parameters.; The user can specify a number of events to generate that will override the default. The result is a; copy of the prototype dataset with only variables in whatVars randomized. Variables in whatVars that; are not in the prototype will be added as new columns to the generated dataset. RooDataSet * generate(const RooArgSet& whatVars, const RooCmdArg& arg1 = RooCmdArg::none(), const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none()); Generate a new dataset containing the specified variables with events sampled from our distribution.; Generate the specified number of events or expectedEvents() if not specified. Any variables of this PDF that are not in whatVars will use their; current values and be treated as fixed parameters. Returns zero; in case of an error. The caller takes ownership of the returned; dataset. The following named arguments are supported. Name(const char* name) -- Name of the output dataset; Verbose(Bool_t flag) -- Print informational messages ",MatchSource.WIKI,root/html602/RooAbsPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsPdf.html
https://root.cern/root/html602/RooAbsPdf.html:67140,Modifiability,variab,variables,67140,"dOrder) the order of the events in the dataset will be read in a random order; if the requested number of events to be generated does not match the; number of events in the prototype dataset. If ProtoData() is used, the specified existing dataset as a prototype: the new dataset will contain; the same number of events as the prototype (unless otherwise specified), and any prototype variables not in; whatVars will be copied into the new dataset for each generated event and also used to set our PDF parameters.; The user can specify a number of events to generate that will override the default. The result is a; copy of the prototype dataset with only variables in whatVars randomized. Variables in whatVars that; are not in the prototype will be added as new columns to the generated dataset. RooDataSet * generate(const RooArgSet& whatVars, const RooCmdArg& arg1 = RooCmdArg::none(), const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none()); Generate a new dataset containing the specified variables with events sampled from our distribution.; Generate the specified number of events or expectedEvents() if not specified. Any variables of this PDF that are not in whatVars will use their; current values and be treated as fixed parameters. Returns zero; in case of an error. The caller takes ownership of the returned; dataset. The following named arguments are supported. Name(const char* name) -- Name of the output dataset; Verbose(Bool_t flag) -- Print informational messages during event generation; NumEvent(int nevt) -- Generate specified number of events. AutoBinned(Bool_t flag) -- Automatically deploy binned generation for binned distributions (e.g. RooHistPdf, sums and products of RooHistPdfs etc); NB: Datasets that are generated in binned mode are returned as weighted unbinned datasets. GenBinned(const char* tag) -- Use b",MatchSource.WIKI,root/html602/RooAbsPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsPdf.html
https://root.cern/root/html602/RooAbsPdf.html:67276,Modifiability,variab,variables,67276," otherwise specified), and any prototype variables not in; whatVars will be copied into the new dataset for each generated event and also used to set our PDF parameters.; The user can specify a number of events to generate that will override the default. The result is a; copy of the prototype dataset with only variables in whatVars randomized. Variables in whatVars that; are not in the prototype will be added as new columns to the generated dataset. RooDataSet * generate(const RooArgSet& whatVars, const RooCmdArg& arg1 = RooCmdArg::none(), const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none()); Generate a new dataset containing the specified variables with events sampled from our distribution.; Generate the specified number of events or expectedEvents() if not specified. Any variables of this PDF that are not in whatVars will use their; current values and be treated as fixed parameters. Returns zero; in case of an error. The caller takes ownership of the returned; dataset. The following named arguments are supported. Name(const char* name) -- Name of the output dataset; Verbose(Bool_t flag) -- Print informational messages during event generation; NumEvent(int nevt) -- Generate specified number of events. AutoBinned(Bool_t flag) -- Automatically deploy binned generation for binned distributions (e.g. RooHistPdf, sums and products of RooHistPdfs etc); NB: Datasets that are generated in binned mode are returned as weighted unbinned datasets. GenBinned(const char* tag) -- Use binned generation for all component pdfs that have 'setAttribute(tag)' set; AllBinned() -- As above, but for all components. Note that the notion of components is only meaningful for simultaneous pdf; as binned generation is always executed at the top-level node for a regular; pdf, so for those it only mattes that the top-level node is tagge",MatchSource.WIKI,root/html602/RooAbsPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsPdf.html
https://root.cern/root/html602/RooAbsPdf.html:68523,Modifiability,extend,extended,68523,"et; Verbose(Bool_t flag) -- Print informational messages during event generation; NumEvent(int nevt) -- Generate specified number of events. AutoBinned(Bool_t flag) -- Automatically deploy binned generation for binned distributions (e.g. RooHistPdf, sums and products of RooHistPdfs etc); NB: Datasets that are generated in binned mode are returned as weighted unbinned datasets. GenBinned(const char* tag) -- Use binned generation for all component pdfs that have 'setAttribute(tag)' set; AllBinned() -- As above, but for all components. Note that the notion of components is only meaningful for simultaneous pdf; as binned generation is always executed at the top-level node for a regular; pdf, so for those it only mattes that the top-level node is tagged. Binned generation cannot be used when prototype data is supplied; Extended() -- The actual number of events generated will be sampled from a Poisson distribution; with mu=nevt. For use with extended maximum likelihood fits; ProtoData(const RooDataSet& data, -- Use specified dataset as prototype dataset. If randOrder is set to true; Bool_t randOrder, the order of the events in the dataset will be read in a random order; Bool_t resample) if the requested number of events to be generated does not match the; number of events in the prototype dataset. If resample is also set to; true, the prototype dataset will be resampled rather than be strictly; reshuffled. In this mode events of the protodata may be used more than; once. If ProtoData() is used, the specified existing dataset as a prototype: the new dataset will contain; the same number of events as the prototype (unless otherwise specified), and any prototype variables not in; whatVars will be copied into the new dataset for each generated event and also used to set our PDF parameters.; The user can specify a number of events to generate that will override the default. The result is a; copy of the prototype dataset with only variables in whatVars randomized. Variables in ",MatchSource.WIKI,root/html602/RooAbsPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsPdf.html
https://root.cern/root/html602/RooAbsPdf.html:69255,Modifiability,variab,variables,69255,"cuted at the top-level node for a regular; pdf, so for those it only mattes that the top-level node is tagged. Binned generation cannot be used when prototype data is supplied; Extended() -- The actual number of events generated will be sampled from a Poisson distribution; with mu=nevt. For use with extended maximum likelihood fits; ProtoData(const RooDataSet& data, -- Use specified dataset as prototype dataset. If randOrder is set to true; Bool_t randOrder, the order of the events in the dataset will be read in a random order; Bool_t resample) if the requested number of events to be generated does not match the; number of events in the prototype dataset. If resample is also set to; true, the prototype dataset will be resampled rather than be strictly; reshuffled. In this mode events of the protodata may be used more than; once. If ProtoData() is used, the specified existing dataset as a prototype: the new dataset will contain; the same number of events as the prototype (unless otherwise specified), and any prototype variables not in; whatVars will be copied into the new dataset for each generated event and also used to set our PDF parameters.; The user can specify a number of events to generate that will override the default. The result is a; copy of the prototype dataset with only variables in whatVars randomized. Variables in whatVars that; are not in the prototype will be added as new columns to the generated dataset. RooDataSet * generate(RooAbsPdf::GenSpec& ) const; Generate data according to a pre-configured specification created by; RooAbsPdf::prepareMultiGen(). If many identical generation requests; are needed, e.g. in toy MC studies, it is more efficient to use the prepareMultiGen()/generate(); combination than calling the standard generate() multiple times as; initialization overhead is only incurred once. RooDataSet * generate(const RooArgSet& whatVars, Double_t nEvents = 0, Bool_t verbose = kFALSE, Bool_t autoBinned = kTRUE, const char* binnedTag = """", B",MatchSource.WIKI,root/html602/RooAbsPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsPdf.html
https://root.cern/root/html602/RooAbsPdf.html:69526,Modifiability,variab,variables,69526," use with extended maximum likelihood fits; ProtoData(const RooDataSet& data, -- Use specified dataset as prototype dataset. If randOrder is set to true; Bool_t randOrder, the order of the events in the dataset will be read in a random order; Bool_t resample) if the requested number of events to be generated does not match the; number of events in the prototype dataset. If resample is also set to; true, the prototype dataset will be resampled rather than be strictly; reshuffled. In this mode events of the protodata may be used more than; once. If ProtoData() is used, the specified existing dataset as a prototype: the new dataset will contain; the same number of events as the prototype (unless otherwise specified), and any prototype variables not in; whatVars will be copied into the new dataset for each generated event and also used to set our PDF parameters.; The user can specify a number of events to generate that will override the default. The result is a; copy of the prototype dataset with only variables in whatVars randomized. Variables in whatVars that; are not in the prototype will be added as new columns to the generated dataset. RooDataSet * generate(RooAbsPdf::GenSpec& ) const; Generate data according to a pre-configured specification created by; RooAbsPdf::prepareMultiGen(). If many identical generation requests; are needed, e.g. in toy MC studies, it is more efficient to use the prepareMultiGen()/generate(); combination than calling the standard generate() multiple times as; initialization overhead is only incurred once. RooDataSet * generate(const RooArgSet& whatVars, Double_t nEvents = 0, Bool_t verbose = kFALSE, Bool_t autoBinned = kTRUE, const char* binnedTag = """", Bool_t expectedData = kFALSE, Bool_t extended = kFALSE) const; Generate a new dataset containing the specified variables with; events sampled from our distribution. Generate the specified; number of events or else try to use expectedEvents() if nEvents <= 0.; Any variables of this PDF that a",MatchSource.WIKI,root/html602/RooAbsPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsPdf.html
https://root.cern/root/html602/RooAbsPdf.html:69752,Modifiability,config,configured,69752,"random order; Bool_t resample) if the requested number of events to be generated does not match the; number of events in the prototype dataset. If resample is also set to; true, the prototype dataset will be resampled rather than be strictly; reshuffled. In this mode events of the protodata may be used more than; once. If ProtoData() is used, the specified existing dataset as a prototype: the new dataset will contain; the same number of events as the prototype (unless otherwise specified), and any prototype variables not in; whatVars will be copied into the new dataset for each generated event and also used to set our PDF parameters.; The user can specify a number of events to generate that will override the default. The result is a; copy of the prototype dataset with only variables in whatVars randomized. Variables in whatVars that; are not in the prototype will be added as new columns to the generated dataset. RooDataSet * generate(RooAbsPdf::GenSpec& ) const; Generate data according to a pre-configured specification created by; RooAbsPdf::prepareMultiGen(). If many identical generation requests; are needed, e.g. in toy MC studies, it is more efficient to use the prepareMultiGen()/generate(); combination than calling the standard generate() multiple times as; initialization overhead is only incurred once. RooDataSet * generate(const RooArgSet& whatVars, Double_t nEvents = 0, Bool_t verbose = kFALSE, Bool_t autoBinned = kTRUE, const char* binnedTag = """", Bool_t expectedData = kFALSE, Bool_t extended = kFALSE) const; Generate a new dataset containing the specified variables with; events sampled from our distribution. Generate the specified; number of events or else try to use expectedEvents() if nEvents <= 0.; Any variables of this PDF that are not in whatVars will use their; current values and be treated as fixed parameters. Returns zero; in case of an error. The caller takes ownership of the returned; dataset. RooDataSet * generate(RooAbsGenContext& context, const ",MatchSource.WIKI,root/html602/RooAbsPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsPdf.html
https://root.cern/root/html602/RooAbsPdf.html:70259,Modifiability,extend,extended,70259,"cified), and any prototype variables not in; whatVars will be copied into the new dataset for each generated event and also used to set our PDF parameters.; The user can specify a number of events to generate that will override the default. The result is a; copy of the prototype dataset with only variables in whatVars randomized. Variables in whatVars that; are not in the prototype will be added as new columns to the generated dataset. RooDataSet * generate(RooAbsPdf::GenSpec& ) const; Generate data according to a pre-configured specification created by; RooAbsPdf::prepareMultiGen(). If many identical generation requests; are needed, e.g. in toy MC studies, it is more efficient to use the prepareMultiGen()/generate(); combination than calling the standard generate() multiple times as; initialization overhead is only incurred once. RooDataSet * generate(const RooArgSet& whatVars, Double_t nEvents = 0, Bool_t verbose = kFALSE, Bool_t autoBinned = kTRUE, const char* binnedTag = """", Bool_t expectedData = kFALSE, Bool_t extended = kFALSE) const; Generate a new dataset containing the specified variables with; events sampled from our distribution. Generate the specified; number of events or else try to use expectedEvents() if nEvents <= 0.; Any variables of this PDF that are not in whatVars will use their; current values and be treated as fixed parameters. Returns zero; in case of an error. The caller takes ownership of the returned; dataset. RooDataSet * generate(RooAbsGenContext& context, const RooArgSet& whatVars, const RooDataSet* prototype, Double_t nEvents, Bool_t verbose, Bool_t randProtoOrder, Bool_t resampleProto, Bool_t skipInit = kFALSE, Bool_t extended = kFALSE) const; Internal method. RooDataSet * generate(const RooArgSet& whatVars, const RooDataSet& prototype, Int_t nEvents = 0, Bool_t verbose = kFALSE, Bool_t randProtoOrder = kFALSE, Bool_t resampleProto = kFALSE) const; Generate a new dataset with values of the whatVars variables; sampled from our distribut",MatchSource.WIKI,root/html602/RooAbsPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsPdf.html
https://root.cern/root/html602/RooAbsPdf.html:70333,Modifiability,variab,variables,70333,"cified), and any prototype variables not in; whatVars will be copied into the new dataset for each generated event and also used to set our PDF parameters.; The user can specify a number of events to generate that will override the default. The result is a; copy of the prototype dataset with only variables in whatVars randomized. Variables in whatVars that; are not in the prototype will be added as new columns to the generated dataset. RooDataSet * generate(RooAbsPdf::GenSpec& ) const; Generate data according to a pre-configured specification created by; RooAbsPdf::prepareMultiGen(). If many identical generation requests; are needed, e.g. in toy MC studies, it is more efficient to use the prepareMultiGen()/generate(); combination than calling the standard generate() multiple times as; initialization overhead is only incurred once. RooDataSet * generate(const RooArgSet& whatVars, Double_t nEvents = 0, Bool_t verbose = kFALSE, Bool_t autoBinned = kTRUE, const char* binnedTag = """", Bool_t expectedData = kFALSE, Bool_t extended = kFALSE) const; Generate a new dataset containing the specified variables with; events sampled from our distribution. Generate the specified; number of events or else try to use expectedEvents() if nEvents <= 0.; Any variables of this PDF that are not in whatVars will use their; current values and be treated as fixed parameters. Returns zero; in case of an error. The caller takes ownership of the returned; dataset. RooDataSet * generate(RooAbsGenContext& context, const RooArgSet& whatVars, const RooDataSet* prototype, Double_t nEvents, Bool_t verbose, Bool_t randProtoOrder, Bool_t resampleProto, Bool_t skipInit = kFALSE, Bool_t extended = kFALSE) const; Internal method. RooDataSet * generate(const RooArgSet& whatVars, const RooDataSet& prototype, Int_t nEvents = 0, Bool_t verbose = kFALSE, Bool_t randProtoOrder = kFALSE, Bool_t resampleProto = kFALSE) const; Generate a new dataset with values of the whatVars variables; sampled from our distribut",MatchSource.WIKI,root/html602/RooAbsPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsPdf.html
https://root.cern/root/html602/RooAbsPdf.html:70486,Modifiability,variab,variables,70486,"whatVars randomized. Variables in whatVars that; are not in the prototype will be added as new columns to the generated dataset. RooDataSet * generate(RooAbsPdf::GenSpec& ) const; Generate data according to a pre-configured specification created by; RooAbsPdf::prepareMultiGen(). If many identical generation requests; are needed, e.g. in toy MC studies, it is more efficient to use the prepareMultiGen()/generate(); combination than calling the standard generate() multiple times as; initialization overhead is only incurred once. RooDataSet * generate(const RooArgSet& whatVars, Double_t nEvents = 0, Bool_t verbose = kFALSE, Bool_t autoBinned = kTRUE, const char* binnedTag = """", Bool_t expectedData = kFALSE, Bool_t extended = kFALSE) const; Generate a new dataset containing the specified variables with; events sampled from our distribution. Generate the specified; number of events or else try to use expectedEvents() if nEvents <= 0.; Any variables of this PDF that are not in whatVars will use their; current values and be treated as fixed parameters. Returns zero; in case of an error. The caller takes ownership of the returned; dataset. RooDataSet * generate(RooAbsGenContext& context, const RooArgSet& whatVars, const RooDataSet* prototype, Double_t nEvents, Bool_t verbose, Bool_t randProtoOrder, Bool_t resampleProto, Bool_t skipInit = kFALSE, Bool_t extended = kFALSE) const; Internal method. RooDataSet * generate(const RooArgSet& whatVars, const RooDataSet& prototype, Int_t nEvents = 0, Bool_t verbose = kFALSE, Bool_t randProtoOrder = kFALSE, Bool_t resampleProto = kFALSE) const; Generate a new dataset with values of the whatVars variables; sampled from our distribution. Use the specified existing dataset; as a prototype: the new dataset will contain the same number of; events as the prototype (by default), and any prototype variables not in; whatVars will be copied into the new dataset for each generated; event and also used to set our PDF parameters. The user can specify",MatchSource.WIKI,root/html602/RooAbsPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsPdf.html
https://root.cern/root/html602/RooAbsPdf.html:70905,Modifiability,extend,extended,70905,". If many identical generation requests; are needed, e.g. in toy MC studies, it is more efficient to use the prepareMultiGen()/generate(); combination than calling the standard generate() multiple times as; initialization overhead is only incurred once. RooDataSet * generate(const RooArgSet& whatVars, Double_t nEvents = 0, Bool_t verbose = kFALSE, Bool_t autoBinned = kTRUE, const char* binnedTag = """", Bool_t expectedData = kFALSE, Bool_t extended = kFALSE) const; Generate a new dataset containing the specified variables with; events sampled from our distribution. Generate the specified; number of events or else try to use expectedEvents() if nEvents <= 0.; Any variables of this PDF that are not in whatVars will use their; current values and be treated as fixed parameters. Returns zero; in case of an error. The caller takes ownership of the returned; dataset. RooDataSet * generate(RooAbsGenContext& context, const RooArgSet& whatVars, const RooDataSet* prototype, Double_t nEvents, Bool_t verbose, Bool_t randProtoOrder, Bool_t resampleProto, Bool_t skipInit = kFALSE, Bool_t extended = kFALSE) const; Internal method. RooDataSet * generate(const RooArgSet& whatVars, const RooDataSet& prototype, Int_t nEvents = 0, Bool_t verbose = kFALSE, Bool_t randProtoOrder = kFALSE, Bool_t resampleProto = kFALSE) const; Generate a new dataset with values of the whatVars variables; sampled from our distribution. Use the specified existing dataset; as a prototype: the new dataset will contain the same number of; events as the prototype (by default), and any prototype variables not in; whatVars will be copied into the new dataset for each generated; event and also used to set our PDF parameters. The user can specify a; number of events to generate that will override the default. The result is a; copy of the prototype dataset with only variables in whatVars; randomized. Variables in whatVars that are not in the prototype; will be added as new columns to the generated dataset. Returns; zer",MatchSource.WIKI,root/html602/RooAbsPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsPdf.html
https://root.cern/root/html602/RooAbsPdf.html:71191,Modifiability,variab,variables,71191,"ate(const RooArgSet& whatVars, Double_t nEvents = 0, Bool_t verbose = kFALSE, Bool_t autoBinned = kTRUE, const char* binnedTag = """", Bool_t expectedData = kFALSE, Bool_t extended = kFALSE) const; Generate a new dataset containing the specified variables with; events sampled from our distribution. Generate the specified; number of events or else try to use expectedEvents() if nEvents <= 0.; Any variables of this PDF that are not in whatVars will use their; current values and be treated as fixed parameters. Returns zero; in case of an error. The caller takes ownership of the returned; dataset. RooDataSet * generate(RooAbsGenContext& context, const RooArgSet& whatVars, const RooDataSet* prototype, Double_t nEvents, Bool_t verbose, Bool_t randProtoOrder, Bool_t resampleProto, Bool_t skipInit = kFALSE, Bool_t extended = kFALSE) const; Internal method. RooDataSet * generate(const RooArgSet& whatVars, const RooDataSet& prototype, Int_t nEvents = 0, Bool_t verbose = kFALSE, Bool_t randProtoOrder = kFALSE, Bool_t resampleProto = kFALSE) const; Generate a new dataset with values of the whatVars variables; sampled from our distribution. Use the specified existing dataset; as a prototype: the new dataset will contain the same number of; events as the prototype (by default), and any prototype variables not in; whatVars will be copied into the new dataset for each generated; event and also used to set our PDF parameters. The user can specify a; number of events to generate that will override the default. The result is a; copy of the prototype dataset with only variables in whatVars; randomized. Variables in whatVars that are not in the prototype; will be added as new columns to the generated dataset. Returns; zero in case of an error. The caller takes ownership of the; returned dataset. Int_t* randomizeProtoOrder(Int_t nProto, Int_t nGen, Bool_t resample = kFALSE) const; Return lookup table with randomized access order for prototype events,; given nProto prototype data events and ",MatchSource.WIKI,root/html602/RooAbsPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsPdf.html
https://root.cern/root/html602/RooAbsPdf.html:71390,Modifiability,variab,variables,71390,"stribution. Generate the specified; number of events or else try to use expectedEvents() if nEvents <= 0.; Any variables of this PDF that are not in whatVars will use their; current values and be treated as fixed parameters. Returns zero; in case of an error. The caller takes ownership of the returned; dataset. RooDataSet * generate(RooAbsGenContext& context, const RooArgSet& whatVars, const RooDataSet* prototype, Double_t nEvents, Bool_t verbose, Bool_t randProtoOrder, Bool_t resampleProto, Bool_t skipInit = kFALSE, Bool_t extended = kFALSE) const; Internal method. RooDataSet * generate(const RooArgSet& whatVars, const RooDataSet& prototype, Int_t nEvents = 0, Bool_t verbose = kFALSE, Bool_t randProtoOrder = kFALSE, Bool_t resampleProto = kFALSE) const; Generate a new dataset with values of the whatVars variables; sampled from our distribution. Use the specified existing dataset; as a prototype: the new dataset will contain the same number of; events as the prototype (by default), and any prototype variables not in; whatVars will be copied into the new dataset for each generated; event and also used to set our PDF parameters. The user can specify a; number of events to generate that will override the default. The result is a; copy of the prototype dataset with only variables in whatVars; randomized. Variables in whatVars that are not in the prototype; will be added as new columns to the generated dataset. Returns; zero in case of an error. The caller takes ownership of the; returned dataset. Int_t* randomizeProtoOrder(Int_t nProto, Int_t nGen, Bool_t resample = kFALSE) const; Return lookup table with randomized access order for prototype events,; given nProto prototype data events and nGen events that will actually; be accessed. Int_t getGenerator(const RooArgSet& directVars, RooArgSet& generateVars, Bool_t staticInitOK = kTRUE) const; Load generatedVars with the subset of directVars that we can generate events for,; and return a code that specifies the generator al",MatchSource.WIKI,root/html602/RooAbsPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsPdf.html
https://root.cern/root/html602/RooAbsPdf.html:71662,Modifiability,variab,variables,71662,"s ownership of the returned; dataset. RooDataSet * generate(RooAbsGenContext& context, const RooArgSet& whatVars, const RooDataSet* prototype, Double_t nEvents, Bool_t verbose, Bool_t randProtoOrder, Bool_t resampleProto, Bool_t skipInit = kFALSE, Bool_t extended = kFALSE) const; Internal method. RooDataSet * generate(const RooArgSet& whatVars, const RooDataSet& prototype, Int_t nEvents = 0, Bool_t verbose = kFALSE, Bool_t randProtoOrder = kFALSE, Bool_t resampleProto = kFALSE) const; Generate a new dataset with values of the whatVars variables; sampled from our distribution. Use the specified existing dataset; as a prototype: the new dataset will contain the same number of; events as the prototype (by default), and any prototype variables not in; whatVars will be copied into the new dataset for each generated; event and also used to set our PDF parameters. The user can specify a; number of events to generate that will override the default. The result is a; copy of the prototype dataset with only variables in whatVars; randomized. Variables in whatVars that are not in the prototype; will be added as new columns to the generated dataset. Returns; zero in case of an error. The caller takes ownership of the; returned dataset. Int_t* randomizeProtoOrder(Int_t nProto, Int_t nGen, Bool_t resample = kFALSE) const; Return lookup table with randomized access order for prototype events,; given nProto prototype data events and nGen events that will actually; be accessed. Int_t getGenerator(const RooArgSet& directVars, RooArgSet& generateVars, Bool_t staticInitOK = kTRUE) const; Load generatedVars with the subset of directVars that we can generate events for,; and return a code that specifies the generator algorithm we will use. A code of; zero indicates that we cannot generate any of the directVars (in this case, nothing; should be added to generatedVars). Any non-zero codes will be passed to our generateEvent(); implementation, but otherwise its value is arbitrary. The defaul",MatchSource.WIKI,root/html602/RooAbsPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsPdf.html
https://root.cern/root/html602/RooAbsPdf.html:73839,Modifiability,variab,variables,73839,"s will usually implement this method using the; matchArgs() methods to advertise the algorithms they provide. void initGenerator(Int_t code); Interface for one-time initialization to setup the generator for the specified code. void generateEvent(Int_t code); Interface for generation of anan event using the algorithm; corresponding to the specified code. The meaning of each code is; defined by the getGenerator() implementation. The default; implementation does nothing. Bool_t isDirectGenSafe(const RooAbsArg& arg) const; Check if given observable can be safely generated using the; pdfs internal generator mechanism (if that existsP). Observables; on which a PDF depends via more than route are not safe; for use with internal generators because they introduce; correlations not known to the internal generator. RooDataHist * generateBinned(const RooArgSet& whatVars, Double_t nEvents, const RooCmdArg& arg1, const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none()); Generate a new dataset containing the specified variables with events sampled from our distribution.; Generate the specified number of events or expectedEvents() if not specified. Any variables of this PDF that are not in whatVars will use their; current values and be treated as fixed parameters. Returns zero; in case of an error. The caller takes ownership of the returned; dataset. The following named arguments are supported. Name(const char* name) -- Name of the output dataset; Verbose(Bool_t flag) -- Print informational messages during event generation; Extended() -- The actual number of events generated will be sampled from a Poisson distribution; with mu=nevt. For use with extended maximum likelihood fits; ExpectedData() -- Return a binned dataset _without_ statistical fluctuations (also aliased as Asimov()). RooDataHist * generateBinned(const RooArgSet& whatVars, const RooCmdArg& arg1 = RooCmdArg",MatchSource.WIKI,root/html602/RooAbsPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsPdf.html
https://root.cern/root/html602/RooAbsPdf.html:73975,Modifiability,variab,variables,73975,"sponding to the specified code. The meaning of each code is; defined by the getGenerator() implementation. The default; implementation does nothing. Bool_t isDirectGenSafe(const RooAbsArg& arg) const; Check if given observable can be safely generated using the; pdfs internal generator mechanism (if that existsP). Observables; on which a PDF depends via more than route are not safe; for use with internal generators because they introduce; correlations not known to the internal generator. RooDataHist * generateBinned(const RooArgSet& whatVars, Double_t nEvents, const RooCmdArg& arg1, const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none()); Generate a new dataset containing the specified variables with events sampled from our distribution.; Generate the specified number of events or expectedEvents() if not specified. Any variables of this PDF that are not in whatVars will use their; current values and be treated as fixed parameters. Returns zero; in case of an error. The caller takes ownership of the returned; dataset. The following named arguments are supported. Name(const char* name) -- Name of the output dataset; Verbose(Bool_t flag) -- Print informational messages during event generation; Extended() -- The actual number of events generated will be sampled from a Poisson distribution; with mu=nevt. For use with extended maximum likelihood fits; ExpectedData() -- Return a binned dataset _without_ statistical fluctuations (also aliased as Asimov()). RooDataHist * generateBinned(const RooArgSet& whatVars, const RooCmdArg& arg1 = RooCmdArg::none(), const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none()); Generate a new dataset containing the specified variables with events sampled from our distributi",MatchSource.WIKI,root/html602/RooAbsPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsPdf.html
https://root.cern/root/html602/RooAbsPdf.html:74478,Modifiability,extend,extended,74478,"ateBinned(const RooArgSet& whatVars, Double_t nEvents, const RooCmdArg& arg1, const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none()); Generate a new dataset containing the specified variables with events sampled from our distribution.; Generate the specified number of events or expectedEvents() if not specified. Any variables of this PDF that are not in whatVars will use their; current values and be treated as fixed parameters. Returns zero; in case of an error. The caller takes ownership of the returned; dataset. The following named arguments are supported. Name(const char* name) -- Name of the output dataset; Verbose(Bool_t flag) -- Print informational messages during event generation; Extended() -- The actual number of events generated will be sampled from a Poisson distribution; with mu=nevt. For use with extended maximum likelihood fits; ExpectedData() -- Return a binned dataset _without_ statistical fluctuations (also aliased as Asimov()). RooDataHist * generateBinned(const RooArgSet& whatVars, const RooCmdArg& arg1 = RooCmdArg::none(), const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none()); Generate a new dataset containing the specified variables with events sampled from our distribution.; Generate the specified number of events or expectedEvents() if not specified. Any variables of this PDF that are not in whatVars will use their; current values and be treated as fixed parameters. Returns zero; in case of an error. The caller takes ownership of the returned; dataset. The following named arguments are supported. Name(const char* name) -- Name of the output dataset; Verbose(Bool_t flag) -- Print informational messages during event generation; NumEvent(int nevt) -- Generate specified numb",MatchSource.WIKI,root/html602/RooAbsPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsPdf.html
https://root.cern/root/html602/RooAbsPdf.html:74980,Modifiability,variab,variables,74980," the specified variables with events sampled from our distribution.; Generate the specified number of events or expectedEvents() if not specified. Any variables of this PDF that are not in whatVars will use their; current values and be treated as fixed parameters. Returns zero; in case of an error. The caller takes ownership of the returned; dataset. The following named arguments are supported. Name(const char* name) -- Name of the output dataset; Verbose(Bool_t flag) -- Print informational messages during event generation; Extended() -- The actual number of events generated will be sampled from a Poisson distribution; with mu=nevt. For use with extended maximum likelihood fits; ExpectedData() -- Return a binned dataset _without_ statistical fluctuations (also aliased as Asimov()). RooDataHist * generateBinned(const RooArgSet& whatVars, const RooCmdArg& arg1 = RooCmdArg::none(), const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none()); Generate a new dataset containing the specified variables with events sampled from our distribution.; Generate the specified number of events or expectedEvents() if not specified. Any variables of this PDF that are not in whatVars will use their; current values and be treated as fixed parameters. Returns zero; in case of an error. The caller takes ownership of the returned; dataset. The following named arguments are supported. Name(const char* name) -- Name of the output dataset; Verbose(Bool_t flag) -- Print informational messages during event generation; NumEvent(int nevt) -- Generate specified number of events; Extended() -- The actual number of events generated will be sampled from a Poisson distribution; with mu=nevt. For use with extended maximum likelihood fits; ExpectedData() -- Return a binned dataset _without_ statistical fluctuations (also aliased as Asimov()). RooData",MatchSource.WIKI,root/html602/RooAbsPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsPdf.html
https://root.cern/root/html602/RooAbsPdf.html:75116,Modifiability,variab,variables,75116,"taset. The following named arguments are supported. Name(const char* name) -- Name of the output dataset; Verbose(Bool_t flag) -- Print informational messages during event generation; Extended() -- The actual number of events generated will be sampled from a Poisson distribution; with mu=nevt. For use with extended maximum likelihood fits; ExpectedData() -- Return a binned dataset _without_ statistical fluctuations (also aliased as Asimov()). RooDataHist * generateBinned(const RooArgSet& whatVars, const RooCmdArg& arg1 = RooCmdArg::none(), const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none()); Generate a new dataset containing the specified variables with events sampled from our distribution.; Generate the specified number of events or expectedEvents() if not specified. Any variables of this PDF that are not in whatVars will use their; current values and be treated as fixed parameters. Returns zero; in case of an error. The caller takes ownership of the returned; dataset. The following named arguments are supported. Name(const char* name) -- Name of the output dataset; Verbose(Bool_t flag) -- Print informational messages during event generation; NumEvent(int nevt) -- Generate specified number of events; Extended() -- The actual number of events generated will be sampled from a Poisson distribution; with mu=nevt. For use with extended maximum likelihood fits; ExpectedData() -- Return a binned dataset _without_ statistical fluctuations (also aliased as Asimov()). RooDataHist * generateBinned(const RooArgSet& whatVars, Double_t nEvents, Bool_t expectedData = kFALSE, Bool_t extended = kFALSE) const; Generate a new dataset containing the specified variables with; events sampled from our distribution. Generate the specified; number of events or else try to use expectedEvents() if nEvents <= 0. If expectedData is k",MatchSource.WIKI,root/html602/RooAbsPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsPdf.html
https://root.cern/root/html602/RooAbsPdf.html:75678,Modifiability,extend,extended,75678,"RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none()); Generate a new dataset containing the specified variables with events sampled from our distribution.; Generate the specified number of events or expectedEvents() if not specified. Any variables of this PDF that are not in whatVars will use their; current values and be treated as fixed parameters. Returns zero; in case of an error. The caller takes ownership of the returned; dataset. The following named arguments are supported. Name(const char* name) -- Name of the output dataset; Verbose(Bool_t flag) -- Print informational messages during event generation; NumEvent(int nevt) -- Generate specified number of events; Extended() -- The actual number of events generated will be sampled from a Poisson distribution; with mu=nevt. For use with extended maximum likelihood fits; ExpectedData() -- Return a binned dataset _without_ statistical fluctuations (also aliased as Asimov()). RooDataHist * generateBinned(const RooArgSet& whatVars, Double_t nEvents, Bool_t expectedData = kFALSE, Bool_t extended = kFALSE) const; Generate a new dataset containing the specified variables with; events sampled from our distribution. Generate the specified; number of events or else try to use expectedEvents() if nEvents <= 0. If expectedData is kTRUE (it is kFALSE by default), the returned histogram returns the 'expected'; data sample, i.e. no statistical fluctuations are present. Any variables of this PDF that are not in whatVars will use their; current values and be treated as fixed parameters. Returns zero; in case of an error. The caller takes ownership of the returned; dataset. RooDataSet* generateSimGlobal(const RooArgSet& whatVars, Int_t nEvents); Special generator interface for generation of 'global observables' -- for RooStats tools. RooPlot* plotOn(RooPlot* frame, RooLinkedList& cmdList) const; ",MatchSource.WIKI,root/html602/RooAbsPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsPdf.html
https://root.cern/root/html602/RooAbsPdf.html:75928,Modifiability,extend,extended,75928,"erate a new dataset containing the specified variables with events sampled from our distribution.; Generate the specified number of events or expectedEvents() if not specified. Any variables of this PDF that are not in whatVars will use their; current values and be treated as fixed parameters. Returns zero; in case of an error. The caller takes ownership of the returned; dataset. The following named arguments are supported. Name(const char* name) -- Name of the output dataset; Verbose(Bool_t flag) -- Print informational messages during event generation; NumEvent(int nevt) -- Generate specified number of events; Extended() -- The actual number of events generated will be sampled from a Poisson distribution; with mu=nevt. For use with extended maximum likelihood fits; ExpectedData() -- Return a binned dataset _without_ statistical fluctuations (also aliased as Asimov()). RooDataHist * generateBinned(const RooArgSet& whatVars, Double_t nEvents, Bool_t expectedData = kFALSE, Bool_t extended = kFALSE) const; Generate a new dataset containing the specified variables with; events sampled from our distribution. Generate the specified; number of events or else try to use expectedEvents() if nEvents <= 0. If expectedData is kTRUE (it is kFALSE by default), the returned histogram returns the 'expected'; data sample, i.e. no statistical fluctuations are present. Any variables of this PDF that are not in whatVars will use their; current values and be treated as fixed parameters. Returns zero; in case of an error. The caller takes ownership of the returned; dataset. RooDataSet* generateSimGlobal(const RooArgSet& whatVars, Int_t nEvents); Special generator interface for generation of 'global observables' -- for RooStats tools. RooPlot* plotOn(RooPlot* frame, RooLinkedList& cmdList) const; Plot (project) PDF on specified frame. If a PDF is plotted in an empty frame, it; will show a unit normalized curve in the frame variable, taken at the present value; of other observables defined ",MatchSource.WIKI,root/html602/RooAbsPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsPdf.html
https://root.cern/root/html602/RooAbsPdf.html:76002,Modifiability,variab,variables,76002,"erate a new dataset containing the specified variables with events sampled from our distribution.; Generate the specified number of events or expectedEvents() if not specified. Any variables of this PDF that are not in whatVars will use their; current values and be treated as fixed parameters. Returns zero; in case of an error. The caller takes ownership of the returned; dataset. The following named arguments are supported. Name(const char* name) -- Name of the output dataset; Verbose(Bool_t flag) -- Print informational messages during event generation; NumEvent(int nevt) -- Generate specified number of events; Extended() -- The actual number of events generated will be sampled from a Poisson distribution; with mu=nevt. For use with extended maximum likelihood fits; ExpectedData() -- Return a binned dataset _without_ statistical fluctuations (also aliased as Asimov()). RooDataHist * generateBinned(const RooArgSet& whatVars, Double_t nEvents, Bool_t expectedData = kFALSE, Bool_t extended = kFALSE) const; Generate a new dataset containing the specified variables with; events sampled from our distribution. Generate the specified; number of events or else try to use expectedEvents() if nEvents <= 0. If expectedData is kTRUE (it is kFALSE by default), the returned histogram returns the 'expected'; data sample, i.e. no statistical fluctuations are present. Any variables of this PDF that are not in whatVars will use their; current values and be treated as fixed parameters. Returns zero; in case of an error. The caller takes ownership of the returned; dataset. RooDataSet* generateSimGlobal(const RooArgSet& whatVars, Int_t nEvents); Special generator interface for generation of 'global observables' -- for RooStats tools. RooPlot* plotOn(RooPlot* frame, RooLinkedList& cmdList) const; Plot (project) PDF on specified frame. If a PDF is plotted in an empty frame, it; will show a unit normalized curve in the frame variable, taken at the present value; of other observables defined ",MatchSource.WIKI,root/html602/RooAbsPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsPdf.html
https://root.cern/root/html602/RooAbsPdf.html:76312,Modifiability,variab,variables,76312,"e(const char* name) -- Name of the output dataset; Verbose(Bool_t flag) -- Print informational messages during event generation; NumEvent(int nevt) -- Generate specified number of events; Extended() -- The actual number of events generated will be sampled from a Poisson distribution; with mu=nevt. For use with extended maximum likelihood fits; ExpectedData() -- Return a binned dataset _without_ statistical fluctuations (also aliased as Asimov()). RooDataHist * generateBinned(const RooArgSet& whatVars, Double_t nEvents, Bool_t expectedData = kFALSE, Bool_t extended = kFALSE) const; Generate a new dataset containing the specified variables with; events sampled from our distribution. Generate the specified; number of events or else try to use expectedEvents() if nEvents <= 0. If expectedData is kTRUE (it is kFALSE by default), the returned histogram returns the 'expected'; data sample, i.e. no statistical fluctuations are present. Any variables of this PDF that are not in whatVars will use their; current values and be treated as fixed parameters. Returns zero; in case of an error. The caller takes ownership of the returned; dataset. RooDataSet* generateSimGlobal(const RooArgSet& whatVars, Int_t nEvents); Special generator interface for generation of 'global observables' -- for RooStats tools. RooPlot* plotOn(RooPlot* frame, RooLinkedList& cmdList) const; Plot (project) PDF on specified frame. If a PDF is plotted in an empty frame, it; will show a unit normalized curve in the frame variable, taken at the present value; of other observables defined for this PDF. If a PDF is plotted in a frame in which a dataset has already been plotted, it will; show a projected curve integrated over all variables that were present in the shown; dataset except for the one on the x-axis. The normalization of the curve will also; be adjusted to the event count of the plotted dataset. An informational message; will be printed for each projection step that is performed. This function takes t",MatchSource.WIKI,root/html602/RooAbsPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsPdf.html
https://root.cern/root/html602/RooAbsPdf.html:76869,Modifiability,variab,variable,76869,"whatVars, Double_t nEvents, Bool_t expectedData = kFALSE, Bool_t extended = kFALSE) const; Generate a new dataset containing the specified variables with; events sampled from our distribution. Generate the specified; number of events or else try to use expectedEvents() if nEvents <= 0. If expectedData is kTRUE (it is kFALSE by default), the returned histogram returns the 'expected'; data sample, i.e. no statistical fluctuations are present. Any variables of this PDF that are not in whatVars will use their; current values and be treated as fixed parameters. Returns zero; in case of an error. The caller takes ownership of the returned; dataset. RooDataSet* generateSimGlobal(const RooArgSet& whatVars, Int_t nEvents); Special generator interface for generation of 'global observables' -- for RooStats tools. RooPlot* plotOn(RooPlot* frame, RooLinkedList& cmdList) const; Plot (project) PDF on specified frame. If a PDF is plotted in an empty frame, it; will show a unit normalized curve in the frame variable, taken at the present value; of other observables defined for this PDF. If a PDF is plotted in a frame in which a dataset has already been plotted, it will; show a projected curve integrated over all variables that were present in the shown; dataset except for the one on the x-axis. The normalization of the curve will also; be adjusted to the event count of the plotted dataset. An informational message; will be printed for each projection step that is performed. This function takes the following named arguments. Projection control. Slice(const RooArgSet& set) -- Override default projection behaviour by omittting observables listed; in set from the projection, resulting a 'slice' plot. Slicing is usually; only sensible in discrete observables; Project(const RooArgSet& set) -- Override default projection behaviour by projecting over observables; given in set and complete ignoring the default projection behavior. Advanced use only.; ProjWData(const RooAbsData& d) -- Override",MatchSource.WIKI,root/html602/RooAbsPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsPdf.html
https://root.cern/root/html602/RooAbsPdf.html:77078,Modifiability,variab,variables,77078," Generate the specified; number of events or else try to use expectedEvents() if nEvents <= 0. If expectedData is kTRUE (it is kFALSE by default), the returned histogram returns the 'expected'; data sample, i.e. no statistical fluctuations are present. Any variables of this PDF that are not in whatVars will use their; current values and be treated as fixed parameters. Returns zero; in case of an error. The caller takes ownership of the returned; dataset. RooDataSet* generateSimGlobal(const RooArgSet& whatVars, Int_t nEvents); Special generator interface for generation of 'global observables' -- for RooStats tools. RooPlot* plotOn(RooPlot* frame, RooLinkedList& cmdList) const; Plot (project) PDF on specified frame. If a PDF is plotted in an empty frame, it; will show a unit normalized curve in the frame variable, taken at the present value; of other observables defined for this PDF. If a PDF is plotted in a frame in which a dataset has already been plotted, it will; show a projected curve integrated over all variables that were present in the shown; dataset except for the one on the x-axis. The normalization of the curve will also; be adjusted to the event count of the plotted dataset. An informational message; will be printed for each projection step that is performed. This function takes the following named arguments. Projection control. Slice(const RooArgSet& set) -- Override default projection behaviour by omittting observables listed; in set from the projection, resulting a 'slice' plot. Slicing is usually; only sensible in discrete observables; Project(const RooArgSet& set) -- Override default projection behaviour by projecting over observables; given in set and complete ignoring the default projection behavior. Advanced use only.; ProjWData(const RooAbsData& d) -- Override default projection _technique_ (integration). For observables present in given dataset; projection of PDF is achieved by constructing an average over all observable values in given set.; Con",MatchSource.WIKI,root/html602/RooAbsPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsPdf.html
https://root.cern/root/html602/RooAbsPdf.html:80661,Modifiability,adapt,adaptive,80661," Plotting control. LineStyle(Int_t style) -- Select line style by ROOT line style code, default is solid; LineColor(Int_t color) -- Select line color by ROOT color code, default is blue; LineWidth(Int_t width) -- Select line with in pixels, default is 3; FillStyle(Int_t style) -- Select fill style, default is not filled. If a filled style is selected, also use VLines(); to add vertical downward lines at end of curve to ensure proper closure; FillColor(Int_t color) -- Select fill color by ROOT color code; Range(const char* name) -- Only draw curve in range defined by given name; Range(double lo, double hi) -- Only draw curve in specified range; VLines() -- Add vertical lines to y=0 at end points of curve; Precision(Double_t eps) -- Control precision of drawn curve w.r.t to scale of plot, default is 1e-3. Higher precision; will result in more and more densely spaced curve points; A negative precision value will disable adaptive point spacing and restrict sampling to; the grid point of points defined by the binning of the plotted observabled (recommended for; expensive functions such as profile likelihoods); Invisble(Bool_t flag) -- Add curve to frame, but do not display. Useful in combination AddTo(). RooPlot* plotOn(RooPlot* frame, RooAbsReal::PlotOpt o) const; Plot oneself on 'frame'. In addition to features detailed in RooAbsReal::plotOn(),; the scale factor for a PDF can be interpreted in three different ways. The interpretation; is controlled by ScaleType. Relative - Scale factor is applied on top of PDF normalization scale factor; NumEvent - Scale factor is interpreted as a number of events. The surface area; under the PDF curve will match that of a histogram containing the specified; number of event; Raw - Scale factor is applied to the raw (projected) probability density.; Not too useful, option provided for completeness. RooPlot* paramOn(RooPlot* frame, const RooCmdArg& arg1 = RooCmdArg::none(), const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 ",MatchSource.WIKI,root/html602/RooAbsPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsPdf.html
https://root.cern/root/html602/RooAbsPdf.html:84356,Modifiability,extend,extended,84356,"on_t* options = ""NELU"", Double_t xmin = 0.5, Double_t xmax = 0.98999999999999999, Double_t ymax = 0.94999999999999996); OBSOLETE FUNCTION PROVIDED FOR BACKWARD COMPATIBILITY. RooPlot* paramOn(RooPlot* frame, const RooArgSet& params, Bool_t showConstants = kFALSE, const char* label = """", Int_t sigDigits = 2, Option_t* options = ""NELU"", Double_t xmin = 0.65000000000000002, Double_t xmax = 0.98999999999999999, Double_t ymax = 0.94999999999999996, const RooCmdArg* formatCmd = 0); Add a text box with the current parameter values and their errors to the frame.; Observables of this PDF appearing in the 'data' dataset will be omitted. Optional label will be inserted as first line of the text box. Use 'sigDigits'; to modify the default number of significant digits printed. The 'xmin,xmax,ymax'; values specify the inital relative position of the text box in the plot frame. Double_t expectedEvents(const RooArgSet* nset) const; Return expected number of events from this p.d.f for use in extended; likelihood calculations. This default implementation returns zero. void verboseEval(Int_t stat); Change global level of verbosity for p.d.f. evaluations. Int_t verboseEval(); Return global level of verbosity for p.d.f. evaluations. RooAbsPdf* createProjection(const RooArgSet& iset); Return a p.d.f that represent a projection of this p.d.f integrated over given observables. RooAbsReal* createCdf(const RooArgSet& iset, const RooArgSet& nset = RooArgSet()); Create a cumulative distribution function of this p.d.f in terms; of the observables listed in iset. If no nset argument is given; the c.d.f normalization is constructed over the integrated; observables, so that its maximum value is precisely 1. It is also; possible to choose a different normalization for; multi-dimensional p.d.f.s: eg. for a pdf f(x,y,z) one can; construct a partial cdf c(x,y) that only when integrated itself; over z results in a maximum value of 1. To construct such a cdf pass; z as argument to the optional nset argum",MatchSource.WIKI,root/html602/RooAbsPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsPdf.html
https://root.cern/root/html602/RooAbsPdf.html:86042,Modifiability,variab,variables,86042,"bservables, so that its maximum value is precisely 1. It is also; possible to choose a different normalization for; multi-dimensional p.d.f.s: eg. for a pdf f(x,y,z) one can; construct a partial cdf c(x,y) that only when integrated itself; over z results in a maximum value of 1. To construct such a cdf pass; z as argument to the optional nset argument. RooAbsReal* createCdf(const RooArgSet& iset, const RooCmdArg& arg1, const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()); Create an object that represents the integral of the function over one or more observables listed in iset; The actual integration calculation is only performed when the return object is evaluated. The name; of the integral object is automatically constructed from the name of the input function, the variables; it integrates and the range integrates over. The following named arguments are accepted. SupNormSet(const RooArgSet&) -- Observables over which should be normalized _in_addition_ to the; integration observables; ScanNumCdf() -- Apply scanning technique if cdf integral involves numeric integration [ default ]; ScanAllCdf() -- Always apply scanning technique; ScanNoCdf() -- Never apply scanning technique; ScanParameters(Int_t nbins, -- Parameters for scanning technique of making CDF: number; Int_t intOrder) of sampled bins and order of interpolation applied on numeric cdf. RooAbsReal* createScanCdf(const RooArgSet& iset, const RooArgSet& nset, Int_t numScanBins, Int_t intOrder). RooArgSet* getAllConstraints(const RooArgSet& observables, RooArgSet& constrainedParams, Bool_t stripDisconnected = kTRUE) const; This helper function finds and collects all constraints terms of all coponent p.d.f.s; and returns a RooArgSet with all those terms. void clearEvalEr",MatchSource.WIKI,root/html602/RooAbsPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsPdf.html
https://root.cern/root/html602/RooAbsPdf.html:87252,Modifiability,config,configuration,87252,"tion_ to the; integration observables; ScanNumCdf() -- Apply scanning technique if cdf integral involves numeric integration [ default ]; ScanAllCdf() -- Always apply scanning technique; ScanNoCdf() -- Never apply scanning technique; ScanParameters(Int_t nbins, -- Parameters for scanning technique of making CDF: number; Int_t intOrder) of sampled bins and order of interpolation applied on numeric cdf. RooAbsReal* createScanCdf(const RooArgSet& iset, const RooArgSet& nset, Int_t numScanBins, Int_t intOrder). RooArgSet* getAllConstraints(const RooArgSet& observables, RooArgSet& constrainedParams, Bool_t stripDisconnected = kTRUE) const; This helper function finds and collects all constraints terms of all coponent p.d.f.s; and returns a RooArgSet with all those terms. void clearEvalError(); Clear the evaluation error flag. Bool_t evalError(); Return the evaluation error flag. void raiseEvalError(); Raise the evaluation error flag. RooNumGenConfig* defaultGeneratorConfig(); Returns the default numeric MC generator configuration for all RooAbsReals. RooNumGenConfig* specialGeneratorConfig() const; Returns the specialized integrator configuration for _this_ RooAbsReal.; If this object has no specialized configuration, a null pointer is returned. RooNumGenConfig* specialGeneratorConfig(Bool_t createOnTheFly); Returns the specialized integrator configuration for _this_ RooAbsReal.; If this object has no specialized configuration, a null pointer is returned,; unless createOnTheFly is kTRUE in which case a clone of the default integrator; configuration is created, installed as specialized configuration, and returned. const RooNumGenConfig* getGeneratorConfig() const; Return the numeric MC generator configuration used for this object. If; a specialized configuration was associated with this object, that configuration; is returned, otherwise the default configuration for all RooAbsReals is returned. void setGeneratorConfig(const RooNumGenConfig& config); Set the given configurat",MatchSource.WIKI,root/html602/RooAbsPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsPdf.html
https://root.cern/root/html602/RooAbsPdf.html:87371,Modifiability,config,configuration,87371,"tion [ default ]; ScanAllCdf() -- Always apply scanning technique; ScanNoCdf() -- Never apply scanning technique; ScanParameters(Int_t nbins, -- Parameters for scanning technique of making CDF: number; Int_t intOrder) of sampled bins and order of interpolation applied on numeric cdf. RooAbsReal* createScanCdf(const RooArgSet& iset, const RooArgSet& nset, Int_t numScanBins, Int_t intOrder). RooArgSet* getAllConstraints(const RooArgSet& observables, RooArgSet& constrainedParams, Bool_t stripDisconnected = kTRUE) const; This helper function finds and collects all constraints terms of all coponent p.d.f.s; and returns a RooArgSet with all those terms. void clearEvalError(); Clear the evaluation error flag. Bool_t evalError(); Return the evaluation error flag. void raiseEvalError(); Raise the evaluation error flag. RooNumGenConfig* defaultGeneratorConfig(); Returns the default numeric MC generator configuration for all RooAbsReals. RooNumGenConfig* specialGeneratorConfig() const; Returns the specialized integrator configuration for _this_ RooAbsReal.; If this object has no specialized configuration, a null pointer is returned. RooNumGenConfig* specialGeneratorConfig(Bool_t createOnTheFly); Returns the specialized integrator configuration for _this_ RooAbsReal.; If this object has no specialized configuration, a null pointer is returned,; unless createOnTheFly is kTRUE in which case a clone of the default integrator; configuration is created, installed as specialized configuration, and returned. const RooNumGenConfig* getGeneratorConfig() const; Return the numeric MC generator configuration used for this object. If; a specialized configuration was associated with this object, that configuration; is returned, otherwise the default configuration for all RooAbsReals is returned. void setGeneratorConfig(const RooNumGenConfig& config); Set the given configuration as default numeric MC generator; configuration for this object. void setGeneratorConfig(); Remove the specialized nu",MatchSource.WIKI,root/html602/RooAbsPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsPdf.html
https://root.cern/root/html602/RooAbsPdf.html:87443,Modifiability,config,configuration,87443,"ng technique; ScanParameters(Int_t nbins, -- Parameters for scanning technique of making CDF: number; Int_t intOrder) of sampled bins and order of interpolation applied on numeric cdf. RooAbsReal* createScanCdf(const RooArgSet& iset, const RooArgSet& nset, Int_t numScanBins, Int_t intOrder). RooArgSet* getAllConstraints(const RooArgSet& observables, RooArgSet& constrainedParams, Bool_t stripDisconnected = kTRUE) const; This helper function finds and collects all constraints terms of all coponent p.d.f.s; and returns a RooArgSet with all those terms. void clearEvalError(); Clear the evaluation error flag. Bool_t evalError(); Return the evaluation error flag. void raiseEvalError(); Raise the evaluation error flag. RooNumGenConfig* defaultGeneratorConfig(); Returns the default numeric MC generator configuration for all RooAbsReals. RooNumGenConfig* specialGeneratorConfig() const; Returns the specialized integrator configuration for _this_ RooAbsReal.; If this object has no specialized configuration, a null pointer is returned. RooNumGenConfig* specialGeneratorConfig(Bool_t createOnTheFly); Returns the specialized integrator configuration for _this_ RooAbsReal.; If this object has no specialized configuration, a null pointer is returned,; unless createOnTheFly is kTRUE in which case a clone of the default integrator; configuration is created, installed as specialized configuration, and returned. const RooNumGenConfig* getGeneratorConfig() const; Return the numeric MC generator configuration used for this object. If; a specialized configuration was associated with this object, that configuration; is returned, otherwise the default configuration for all RooAbsReals is returned. void setGeneratorConfig(const RooNumGenConfig& config); Set the given configuration as default numeric MC generator; configuration for this object. void setGeneratorConfig(); Remove the specialized numeric MC generator configuration associated; with this object. void setNormRange(const char* rangeN",MatchSource.WIKI,root/html602/RooAbsPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsPdf.html
https://root.cern/root/html602/RooAbsPdf.html:87585,Modifiability,config,configuration,87585," intOrder) of sampled bins and order of interpolation applied on numeric cdf. RooAbsReal* createScanCdf(const RooArgSet& iset, const RooArgSet& nset, Int_t numScanBins, Int_t intOrder). RooArgSet* getAllConstraints(const RooArgSet& observables, RooArgSet& constrainedParams, Bool_t stripDisconnected = kTRUE) const; This helper function finds and collects all constraints terms of all coponent p.d.f.s; and returns a RooArgSet with all those terms. void clearEvalError(); Clear the evaluation error flag. Bool_t evalError(); Return the evaluation error flag. void raiseEvalError(); Raise the evaluation error flag. RooNumGenConfig* defaultGeneratorConfig(); Returns the default numeric MC generator configuration for all RooAbsReals. RooNumGenConfig* specialGeneratorConfig() const; Returns the specialized integrator configuration for _this_ RooAbsReal.; If this object has no specialized configuration, a null pointer is returned. RooNumGenConfig* specialGeneratorConfig(Bool_t createOnTheFly); Returns the specialized integrator configuration for _this_ RooAbsReal.; If this object has no specialized configuration, a null pointer is returned,; unless createOnTheFly is kTRUE in which case a clone of the default integrator; configuration is created, installed as specialized configuration, and returned. const RooNumGenConfig* getGeneratorConfig() const; Return the numeric MC generator configuration used for this object. If; a specialized configuration was associated with this object, that configuration; is returned, otherwise the default configuration for all RooAbsReals is returned. void setGeneratorConfig(const RooNumGenConfig& config); Set the given configuration as default numeric MC generator; configuration for this object. void setGeneratorConfig(); Remove the specialized numeric MC generator configuration associated; with this object. void setNormRange(const char* rangeName). void setNormRangeOverride(const char* rangeName). GenSpec* prepareMultiGen(const RooArgSet& whatVars,",MatchSource.WIKI,root/html602/RooAbsPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsPdf.html
https://root.cern/root/html602/RooAbsPdf.html:87657,Modifiability,config,configuration,87657,"ooArgSet* getAllConstraints(const RooArgSet& observables, RooArgSet& constrainedParams, Bool_t stripDisconnected = kTRUE) const; This helper function finds and collects all constraints terms of all coponent p.d.f.s; and returns a RooArgSet with all those terms. void clearEvalError(); Clear the evaluation error flag. Bool_t evalError(); Return the evaluation error flag. void raiseEvalError(); Raise the evaluation error flag. RooNumGenConfig* defaultGeneratorConfig(); Returns the default numeric MC generator configuration for all RooAbsReals. RooNumGenConfig* specialGeneratorConfig() const; Returns the specialized integrator configuration for _this_ RooAbsReal.; If this object has no specialized configuration, a null pointer is returned. RooNumGenConfig* specialGeneratorConfig(Bool_t createOnTheFly); Returns the specialized integrator configuration for _this_ RooAbsReal.; If this object has no specialized configuration, a null pointer is returned,; unless createOnTheFly is kTRUE in which case a clone of the default integrator; configuration is created, installed as specialized configuration, and returned. const RooNumGenConfig* getGeneratorConfig() const; Return the numeric MC generator configuration used for this object. If; a specialized configuration was associated with this object, that configuration; is returned, otherwise the default configuration for all RooAbsReals is returned. void setGeneratorConfig(const RooNumGenConfig& config); Set the given configuration as default numeric MC generator; configuration for this object. void setGeneratorConfig(); Remove the specialized numeric MC generator configuration associated; with this object. void setNormRange(const char* rangeName). void setNormRangeOverride(const char* rangeName). GenSpec* prepareMultiGen(const RooArgSet& whatVars, const RooCmdArg& arg1 = RooCmdArg::none(), const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg",MatchSource.WIKI,root/html602/RooAbsPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsPdf.html
https://root.cern/root/html602/RooAbsPdf.html:87781,Modifiability,config,configuration,87781,"ooArgSet* getAllConstraints(const RooArgSet& observables, RooArgSet& constrainedParams, Bool_t stripDisconnected = kTRUE) const; This helper function finds and collects all constraints terms of all coponent p.d.f.s; and returns a RooArgSet with all those terms. void clearEvalError(); Clear the evaluation error flag. Bool_t evalError(); Return the evaluation error flag. void raiseEvalError(); Raise the evaluation error flag. RooNumGenConfig* defaultGeneratorConfig(); Returns the default numeric MC generator configuration for all RooAbsReals. RooNumGenConfig* specialGeneratorConfig() const; Returns the specialized integrator configuration for _this_ RooAbsReal.; If this object has no specialized configuration, a null pointer is returned. RooNumGenConfig* specialGeneratorConfig(Bool_t createOnTheFly); Returns the specialized integrator configuration for _this_ RooAbsReal.; If this object has no specialized configuration, a null pointer is returned,; unless createOnTheFly is kTRUE in which case a clone of the default integrator; configuration is created, installed as specialized configuration, and returned. const RooNumGenConfig* getGeneratorConfig() const; Return the numeric MC generator configuration used for this object. If; a specialized configuration was associated with this object, that configuration; is returned, otherwise the default configuration for all RooAbsReals is returned. void setGeneratorConfig(const RooNumGenConfig& config); Set the given configuration as default numeric MC generator; configuration for this object. void setGeneratorConfig(); Remove the specialized numeric MC generator configuration associated; with this object. void setNormRange(const char* rangeName). void setNormRangeOverride(const char* rangeName). GenSpec* prepareMultiGen(const RooArgSet& whatVars, const RooCmdArg& arg1 = RooCmdArg::none(), const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg",MatchSource.WIKI,root/html602/RooAbsPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsPdf.html
https://root.cern/root/html602/RooAbsPdf.html:87832,Modifiability,config,configuration,87832,"ooArgSet* getAllConstraints(const RooArgSet& observables, RooArgSet& constrainedParams, Bool_t stripDisconnected = kTRUE) const; This helper function finds and collects all constraints terms of all coponent p.d.f.s; and returns a RooArgSet with all those terms. void clearEvalError(); Clear the evaluation error flag. Bool_t evalError(); Return the evaluation error flag. void raiseEvalError(); Raise the evaluation error flag. RooNumGenConfig* defaultGeneratorConfig(); Returns the default numeric MC generator configuration for all RooAbsReals. RooNumGenConfig* specialGeneratorConfig() const; Returns the specialized integrator configuration for _this_ RooAbsReal.; If this object has no specialized configuration, a null pointer is returned. RooNumGenConfig* specialGeneratorConfig(Bool_t createOnTheFly); Returns the specialized integrator configuration for _this_ RooAbsReal.; If this object has no specialized configuration, a null pointer is returned,; unless createOnTheFly is kTRUE in which case a clone of the default integrator; configuration is created, installed as specialized configuration, and returned. const RooNumGenConfig* getGeneratorConfig() const; Return the numeric MC generator configuration used for this object. If; a specialized configuration was associated with this object, that configuration; is returned, otherwise the default configuration for all RooAbsReals is returned. void setGeneratorConfig(const RooNumGenConfig& config); Set the given configuration as default numeric MC generator; configuration for this object. void setGeneratorConfig(); Remove the specialized numeric MC generator configuration associated; with this object. void setNormRange(const char* rangeName). void setNormRangeOverride(const char* rangeName). GenSpec* prepareMultiGen(const RooArgSet& whatVars, const RooCmdArg& arg1 = RooCmdArg::none(), const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg",MatchSource.WIKI,root/html602/RooAbsPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsPdf.html
https://root.cern/root/html602/RooAbsPdf.html:87944,Modifiability,config,configuration,87944,"aints terms of all coponent p.d.f.s; and returns a RooArgSet with all those terms. void clearEvalError(); Clear the evaluation error flag. Bool_t evalError(); Return the evaluation error flag. void raiseEvalError(); Raise the evaluation error flag. RooNumGenConfig* defaultGeneratorConfig(); Returns the default numeric MC generator configuration for all RooAbsReals. RooNumGenConfig* specialGeneratorConfig() const; Returns the specialized integrator configuration for _this_ RooAbsReal.; If this object has no specialized configuration, a null pointer is returned. RooNumGenConfig* specialGeneratorConfig(Bool_t createOnTheFly); Returns the specialized integrator configuration for _this_ RooAbsReal.; If this object has no specialized configuration, a null pointer is returned,; unless createOnTheFly is kTRUE in which case a clone of the default integrator; configuration is created, installed as specialized configuration, and returned. const RooNumGenConfig* getGeneratorConfig() const; Return the numeric MC generator configuration used for this object. If; a specialized configuration was associated with this object, that configuration; is returned, otherwise the default configuration for all RooAbsReals is returned. void setGeneratorConfig(const RooNumGenConfig& config); Set the given configuration as default numeric MC generator; configuration for this object. void setGeneratorConfig(); Remove the specialized numeric MC generator configuration associated; with this object. void setNormRange(const char* rangeName). void setNormRangeOverride(const char* rangeName). GenSpec* prepareMultiGen(const RooArgSet& whatVars, const RooCmdArg& arg1 = RooCmdArg::none(), const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none()). RooPlot* plotOn(RooPlot* frame, const RooCmdArg& arg1 = RooCmdArg::none(), const RooCmdArg& arg2 = RooCmdAr",MatchSource.WIKI,root/html602/RooAbsPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsPdf.html
https://root.cern/root/html602/RooAbsPdf.html:87998,Modifiability,config,configuration,87998,"_t evalError(); Return the evaluation error flag. void raiseEvalError(); Raise the evaluation error flag. RooNumGenConfig* defaultGeneratorConfig(); Returns the default numeric MC generator configuration for all RooAbsReals. RooNumGenConfig* specialGeneratorConfig() const; Returns the specialized integrator configuration for _this_ RooAbsReal.; If this object has no specialized configuration, a null pointer is returned. RooNumGenConfig* specialGeneratorConfig(Bool_t createOnTheFly); Returns the specialized integrator configuration for _this_ RooAbsReal.; If this object has no specialized configuration, a null pointer is returned,; unless createOnTheFly is kTRUE in which case a clone of the default integrator; configuration is created, installed as specialized configuration, and returned. const RooNumGenConfig* getGeneratorConfig() const; Return the numeric MC generator configuration used for this object. If; a specialized configuration was associated with this object, that configuration; is returned, otherwise the default configuration for all RooAbsReals is returned. void setGeneratorConfig(const RooNumGenConfig& config); Set the given configuration as default numeric MC generator; configuration for this object. void setGeneratorConfig(); Remove the specialized numeric MC generator configuration associated; with this object. void setNormRange(const char* rangeName). void setNormRangeOverride(const char* rangeName). GenSpec* prepareMultiGen(const RooArgSet& whatVars, const RooCmdArg& arg1 = RooCmdArg::none(), const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none()). RooPlot* plotOn(RooPlot* frame, const RooCmdArg& arg1 = RooCmdArg::none(), const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), con",MatchSource.WIKI,root/html602/RooAbsPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsPdf.html
https://root.cern/root/html602/RooAbsPdf.html:88050,Modifiability,config,configuration,88050,"_t evalError(); Return the evaluation error flag. void raiseEvalError(); Raise the evaluation error flag. RooNumGenConfig* defaultGeneratorConfig(); Returns the default numeric MC generator configuration for all RooAbsReals. RooNumGenConfig* specialGeneratorConfig() const; Returns the specialized integrator configuration for _this_ RooAbsReal.; If this object has no specialized configuration, a null pointer is returned. RooNumGenConfig* specialGeneratorConfig(Bool_t createOnTheFly); Returns the specialized integrator configuration for _this_ RooAbsReal.; If this object has no specialized configuration, a null pointer is returned,; unless createOnTheFly is kTRUE in which case a clone of the default integrator; configuration is created, installed as specialized configuration, and returned. const RooNumGenConfig* getGeneratorConfig() const; Return the numeric MC generator configuration used for this object. If; a specialized configuration was associated with this object, that configuration; is returned, otherwise the default configuration for all RooAbsReals is returned. void setGeneratorConfig(const RooNumGenConfig& config); Set the given configuration as default numeric MC generator; configuration for this object. void setGeneratorConfig(); Remove the specialized numeric MC generator configuration associated; with this object. void setNormRange(const char* rangeName). void setNormRangeOverride(const char* rangeName). GenSpec* prepareMultiGen(const RooArgSet& whatVars, const RooCmdArg& arg1 = RooCmdArg::none(), const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none()). RooPlot* plotOn(RooPlot* frame, const RooCmdArg& arg1 = RooCmdArg::none(), const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), con",MatchSource.WIKI,root/html602/RooAbsPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsPdf.html
https://root.cern/root/html602/RooAbsPdf.html:88100,Modifiability,config,configuration,88100,"_t evalError(); Return the evaluation error flag. void raiseEvalError(); Raise the evaluation error flag. RooNumGenConfig* defaultGeneratorConfig(); Returns the default numeric MC generator configuration for all RooAbsReals. RooNumGenConfig* specialGeneratorConfig() const; Returns the specialized integrator configuration for _this_ RooAbsReal.; If this object has no specialized configuration, a null pointer is returned. RooNumGenConfig* specialGeneratorConfig(Bool_t createOnTheFly); Returns the specialized integrator configuration for _this_ RooAbsReal.; If this object has no specialized configuration, a null pointer is returned,; unless createOnTheFly is kTRUE in which case a clone of the default integrator; configuration is created, installed as specialized configuration, and returned. const RooNumGenConfig* getGeneratorConfig() const; Return the numeric MC generator configuration used for this object. If; a specialized configuration was associated with this object, that configuration; is returned, otherwise the default configuration for all RooAbsReals is returned. void setGeneratorConfig(const RooNumGenConfig& config); Set the given configuration as default numeric MC generator; configuration for this object. void setGeneratorConfig(); Remove the specialized numeric MC generator configuration associated; with this object. void setNormRange(const char* rangeName). void setNormRangeOverride(const char* rangeName). GenSpec* prepareMultiGen(const RooArgSet& whatVars, const RooCmdArg& arg1 = RooCmdArg::none(), const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none()). RooPlot* plotOn(RooPlot* frame, const RooCmdArg& arg1 = RooCmdArg::none(), const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), con",MatchSource.WIKI,root/html602/RooAbsPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsPdf.html
https://root.cern/root/html602/RooAbsPdf.html:88194,Modifiability,config,config,88194,"he default numeric MC generator configuration for all RooAbsReals. RooNumGenConfig* specialGeneratorConfig() const; Returns the specialized integrator configuration for _this_ RooAbsReal.; If this object has no specialized configuration, a null pointer is returned. RooNumGenConfig* specialGeneratorConfig(Bool_t createOnTheFly); Returns the specialized integrator configuration for _this_ RooAbsReal.; If this object has no specialized configuration, a null pointer is returned,; unless createOnTheFly is kTRUE in which case a clone of the default integrator; configuration is created, installed as specialized configuration, and returned. const RooNumGenConfig* getGeneratorConfig() const; Return the numeric MC generator configuration used for this object. If; a specialized configuration was associated with this object, that configuration; is returned, otherwise the default configuration for all RooAbsReals is returned. void setGeneratorConfig(const RooNumGenConfig& config); Set the given configuration as default numeric MC generator; configuration for this object. void setGeneratorConfig(); Remove the specialized numeric MC generator configuration associated; with this object. void setNormRange(const char* rangeName). void setNormRangeOverride(const char* rangeName). GenSpec* prepareMultiGen(const RooArgSet& whatVars, const RooCmdArg& arg1 = RooCmdArg::none(), const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none()). RooPlot* plotOn(RooPlot* frame, const RooCmdArg& arg1 = RooCmdArg::none(), const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none(), const RooCmdArg& arg9 = RooCmdA",MatchSource.WIKI,root/html602/RooAbsPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsPdf.html
https://root.cern/root/html602/RooAbsPdf.html:88217,Modifiability,config,configuration,88217,"he default numeric MC generator configuration for all RooAbsReals. RooNumGenConfig* specialGeneratorConfig() const; Returns the specialized integrator configuration for _this_ RooAbsReal.; If this object has no specialized configuration, a null pointer is returned. RooNumGenConfig* specialGeneratorConfig(Bool_t createOnTheFly); Returns the specialized integrator configuration for _this_ RooAbsReal.; If this object has no specialized configuration, a null pointer is returned,; unless createOnTheFly is kTRUE in which case a clone of the default integrator; configuration is created, installed as specialized configuration, and returned. const RooNumGenConfig* getGeneratorConfig() const; Return the numeric MC generator configuration used for this object. If; a specialized configuration was associated with this object, that configuration; is returned, otherwise the default configuration for all RooAbsReals is returned. void setGeneratorConfig(const RooNumGenConfig& config); Set the given configuration as default numeric MC generator; configuration for this object. void setGeneratorConfig(); Remove the specialized numeric MC generator configuration associated; with this object. void setNormRange(const char* rangeName). void setNormRangeOverride(const char* rangeName). GenSpec* prepareMultiGen(const RooArgSet& whatVars, const RooCmdArg& arg1 = RooCmdArg::none(), const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none()). RooPlot* plotOn(RooPlot* frame, const RooCmdArg& arg1 = RooCmdArg::none(), const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none(), const RooCmdArg& arg9 = RooCmdA",MatchSource.WIKI,root/html602/RooAbsPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsPdf.html
https://root.cern/root/html602/RooAbsPdf.html:88264,Modifiability,config,configuration,88264,"he default numeric MC generator configuration for all RooAbsReals. RooNumGenConfig* specialGeneratorConfig() const; Returns the specialized integrator configuration for _this_ RooAbsReal.; If this object has no specialized configuration, a null pointer is returned. RooNumGenConfig* specialGeneratorConfig(Bool_t createOnTheFly); Returns the specialized integrator configuration for _this_ RooAbsReal.; If this object has no specialized configuration, a null pointer is returned,; unless createOnTheFly is kTRUE in which case a clone of the default integrator; configuration is created, installed as specialized configuration, and returned. const RooNumGenConfig* getGeneratorConfig() const; Return the numeric MC generator configuration used for this object. If; a specialized configuration was associated with this object, that configuration; is returned, otherwise the default configuration for all RooAbsReals is returned. void setGeneratorConfig(const RooNumGenConfig& config); Set the given configuration as default numeric MC generator; configuration for this object. void setGeneratorConfig(); Remove the specialized numeric MC generator configuration associated; with this object. void setNormRange(const char* rangeName). void setNormRangeOverride(const char* rangeName). GenSpec* prepareMultiGen(const RooArgSet& whatVars, const RooCmdArg& arg1 = RooCmdArg::none(), const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none()). RooPlot* plotOn(RooPlot* frame, const RooCmdArg& arg1 = RooCmdArg::none(), const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none(), const RooCmdArg& arg9 = RooCmdA",MatchSource.WIKI,root/html602/RooAbsPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsPdf.html
https://root.cern/root/html602/RooAbsPdf.html:88366,Modifiability,config,configuration,88366,"cialized integrator configuration for _this_ RooAbsReal.; If this object has no specialized configuration, a null pointer is returned. RooNumGenConfig* specialGeneratorConfig(Bool_t createOnTheFly); Returns the specialized integrator configuration for _this_ RooAbsReal.; If this object has no specialized configuration, a null pointer is returned,; unless createOnTheFly is kTRUE in which case a clone of the default integrator; configuration is created, installed as specialized configuration, and returned. const RooNumGenConfig* getGeneratorConfig() const; Return the numeric MC generator configuration used for this object. If; a specialized configuration was associated with this object, that configuration; is returned, otherwise the default configuration for all RooAbsReals is returned. void setGeneratorConfig(const RooNumGenConfig& config); Set the given configuration as default numeric MC generator; configuration for this object. void setGeneratorConfig(); Remove the specialized numeric MC generator configuration associated; with this object. void setNormRange(const char* rangeName). void setNormRangeOverride(const char* rangeName). GenSpec* prepareMultiGen(const RooArgSet& whatVars, const RooCmdArg& arg1 = RooCmdArg::none(), const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none()). RooPlot* plotOn(RooPlot* frame, const RooCmdArg& arg1 = RooCmdArg::none(), const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none(), const RooCmdArg& arg9 = RooCmdArg::none(), const RooCmdArg& arg10 = RooCmdArg::none()) const. RooArgSet* getConstraints(const RooArgSet& , RooArgSet& , Bool_t ) co",MatchSource.WIKI,root/html602/RooAbsPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsPdf.html
https://root.cern/root/html602/RooAbsPdf.html:89666,Modifiability,extend,extendMode,89666," arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none()). RooPlot* plotOn(RooPlot* frame, const RooCmdArg& arg1 = RooCmdArg::none(), const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none(), const RooCmdArg& arg9 = RooCmdArg::none(), const RooCmdArg& arg10 = RooCmdArg::none()) const. RooArgSet* getConstraints(const RooArgSet& , RooArgSet& , Bool_t ) const; Constraint management. Double_t getNorm(const RooArgSet& nset) const; Get p.d.f normalization term needed for observables 'nset'. Bool_t selfNormalized() const; If true, p.d.f is taken as self-normalized and no attempt is made to add a normalization term; This default implementation return false. ExtendMode extendMode() const; Returns ability of p.d.f to provided extended likelihood terms. Possible; answers are CanNotBeExtended, CanBeExtended or MustBeExtended. This; default implementation always return CanNotBeExtended. Bool_t canBeExtended() const; If true p.d.f can provide extended likelihood term. Bool_t mustBeExtended() const; If true p.d.f must extended likelihood term. Double_t expectedEvents(const RooArgSet* nset) const. const char* normRange() const. const RooAbsReal* getNormIntegral(const RooArgSet& nset) const; { return getNormObj(0,&nset,0) ; }. Bool_t redirectServersHook(const RooAbsCollection& , Bool_t , Bool_t , Bool_t ); Hook function intercepting redirectServer calls. Discard current normalization; object if any server is redirected. » Last changed: Tue Jun 30 14:30:20 2015 » Last generated: 2015-06-30 14:30; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html602/RooAbsPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsPdf.html
https://root.cern/root/html602/RooAbsPdf.html:89723,Modifiability,extend,extended,89723," arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none()). RooPlot* plotOn(RooPlot* frame, const RooCmdArg& arg1 = RooCmdArg::none(), const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none(), const RooCmdArg& arg9 = RooCmdArg::none(), const RooCmdArg& arg10 = RooCmdArg::none()) const. RooArgSet* getConstraints(const RooArgSet& , RooArgSet& , Bool_t ) const; Constraint management. Double_t getNorm(const RooArgSet& nset) const; Get p.d.f normalization term needed for observables 'nset'. Bool_t selfNormalized() const; If true, p.d.f is taken as self-normalized and no attempt is made to add a normalization term; This default implementation return false. ExtendMode extendMode() const; Returns ability of p.d.f to provided extended likelihood terms. Possible; answers are CanNotBeExtended, CanBeExtended or MustBeExtended. This; default implementation always return CanNotBeExtended. Bool_t canBeExtended() const; If true p.d.f can provide extended likelihood term. Bool_t mustBeExtended() const; If true p.d.f must extended likelihood term. Double_t expectedEvents(const RooArgSet* nset) const. const char* normRange() const. const RooAbsReal* getNormIntegral(const RooArgSet& nset) const; { return getNormObj(0,&nset,0) ; }. Bool_t redirectServersHook(const RooAbsCollection& , Bool_t , Bool_t , Bool_t ); Hook function intercepting redirectServer calls. Discard current normalization; object if any server is redirected. » Last changed: Tue Jun 30 14:30:20 2015 » Last generated: 2015-06-30 14:30; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html602/RooAbsPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsPdf.html
https://root.cern/root/html602/RooAbsPdf.html:89940,Modifiability,extend,extended,89940," arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none()). RooPlot* plotOn(RooPlot* frame, const RooCmdArg& arg1 = RooCmdArg::none(), const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none(), const RooCmdArg& arg9 = RooCmdArg::none(), const RooCmdArg& arg10 = RooCmdArg::none()) const. RooArgSet* getConstraints(const RooArgSet& , RooArgSet& , Bool_t ) const; Constraint management. Double_t getNorm(const RooArgSet& nset) const; Get p.d.f normalization term needed for observables 'nset'. Bool_t selfNormalized() const; If true, p.d.f is taken as self-normalized and no attempt is made to add a normalization term; This default implementation return false. ExtendMode extendMode() const; Returns ability of p.d.f to provided extended likelihood terms. Possible; answers are CanNotBeExtended, CanBeExtended or MustBeExtended. This; default implementation always return CanNotBeExtended. Bool_t canBeExtended() const; If true p.d.f can provide extended likelihood term. Bool_t mustBeExtended() const; If true p.d.f must extended likelihood term. Double_t expectedEvents(const RooArgSet* nset) const. const char* normRange() const. const RooAbsReal* getNormIntegral(const RooArgSet& nset) const; { return getNormObj(0,&nset,0) ; }. Bool_t redirectServersHook(const RooAbsCollection& , Bool_t , Bool_t , Bool_t ); Hook function intercepting redirectServer calls. Discard current normalization; object if any server is redirected. » Last changed: Tue Jun 30 14:30:20 2015 » Last generated: 2015-06-30 14:30; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html602/RooAbsPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsPdf.html
https://root.cern/root/html602/RooAbsPdf.html:90016,Modifiability,extend,extended,90016," arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none()). RooPlot* plotOn(RooPlot* frame, const RooCmdArg& arg1 = RooCmdArg::none(), const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none(), const RooCmdArg& arg9 = RooCmdArg::none(), const RooCmdArg& arg10 = RooCmdArg::none()) const. RooArgSet* getConstraints(const RooArgSet& , RooArgSet& , Bool_t ) const; Constraint management. Double_t getNorm(const RooArgSet& nset) const; Get p.d.f normalization term needed for observables 'nset'. Bool_t selfNormalized() const; If true, p.d.f is taken as self-normalized and no attempt is made to add a normalization term; This default implementation return false. ExtendMode extendMode() const; Returns ability of p.d.f to provided extended likelihood terms. Possible; answers are CanNotBeExtended, CanBeExtended or MustBeExtended. This; default implementation always return CanNotBeExtended. Bool_t canBeExtended() const; If true p.d.f can provide extended likelihood term. Bool_t mustBeExtended() const; If true p.d.f must extended likelihood term. Double_t expectedEvents(const RooArgSet* nset) const. const char* normRange() const. const RooAbsReal* getNormIntegral(const RooArgSet& nset) const; { return getNormObj(0,&nset,0) ; }. Bool_t redirectServersHook(const RooAbsCollection& , Bool_t , Bool_t , Bool_t ); Hook function intercepting redirectServer calls. Discard current normalization; object if any server is redirected. » Last changed: Tue Jun 30 14:30:20 2015 » Last generated: 2015-06-30 14:30; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html602/RooAbsPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsPdf.html
https://root.cern/root/html602/RooAbsPdf.html:1853,Performance,perform,perform,1853," is more than a; PDF: it can be a building block for a more complex, composite PDF; if any of its variables are functions instead of variables. In; such cases the normalization of the composite may not be simply the; integral over the dependents of the top level PDF as these are; functions with potentially non-trivial Jacobian terms themselves.; Therefore. --> No explicit attempt should be made to normalize; the functions output in evaluate(). In addition, RooAbsPdf objects do not have a static concept of what; variables are parameters and what variables are dependents (which; need to be integrated over for a correct PDF normalization).; Instead the choice of normalization is always specified each time a; normalized values is requested from the PDF via the getVal(); method. RooAbsPdf manages the entire normalization logic of each PDF with; help of a RooRealIntegral object, which coordinates the integration; of a given choice of normalization. By default, RooRealIntegral will; perform a fully numeric integration of all dependents. However,; PDFs can advertise one or more (partial) analytical integrals of; their function, and these will be used by RooRealIntegral, if it; determines that this is safe (i.e. no hidden Jacobian terms,; multiplication with other PDFs that have one or more dependents in; commen etc). To implement analytical integrals, two functions must be implemented. First,. Int_t getAnalyticalIntegral(const RooArgSet& integSet, RooArgSet& anaIntSet). advertises the analytical integrals that are supported. 'integSet'; is the set of dependents for which integration is requested. The; function should copy the subset of dependents it can analytically; integrate to anaIntSet and return a unique identification code for; this integration configuration. If no integration can be; performed, zero should be returned. Second,. Double_t analyticalIntegral(Int_t code). Implements the actual analytical integral(s) advertised by; getAnalyticalIntegral. This functions wil",MatchSource.WIKI,root/html602/RooAbsPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsPdf.html
https://root.cern/root/html602/RooAbsPdf.html:2676,Performance,perform,performed,2676,"alization logic of each PDF with; help of a RooRealIntegral object, which coordinates the integration; of a given choice of normalization. By default, RooRealIntegral will; perform a fully numeric integration of all dependents. However,; PDFs can advertise one or more (partial) analytical integrals of; their function, and these will be used by RooRealIntegral, if it; determines that this is safe (i.e. no hidden Jacobian terms,; multiplication with other PDFs that have one or more dependents in; commen etc). To implement analytical integrals, two functions must be implemented. First,. Int_t getAnalyticalIntegral(const RooArgSet& integSet, RooArgSet& anaIntSet). advertises the analytical integrals that are supported. 'integSet'; is the set of dependents for which integration is requested. The; function should copy the subset of dependents it can analytically; integrate to anaIntSet and return a unique identification code for; this integration configuration. If no integration can be; performed, zero should be returned. Second,. Double_t analyticalIntegral(Int_t code). Implements the actual analytical integral(s) advertised by; getAnalyticalIntegral. This functions will only be called with; codes returned by getAnalyticalIntegral, except code zero. The integration range for real each dependent to be integrated can; be obtained from the dependents' proxy functions min() and; max(). Never call these proxy functions for any proxy not known to; be a dependent via the integration code. Doing so may be; ill-defined, e.g. in case the proxy holds a function, and will; trigger an assert. Integrated category dependents should always be; summed over all of their states. [Direct generation of observables]. Any PDF dependent can be generated with the accept/reject method,; but for certain PDFs more efficient methods may be implemented. To; implement direct generation of one or more observables, two; functions need to be implemented, similar to those for analytical; integrals:. Int_t",MatchSource.WIKI,root/html602/RooAbsPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsPdf.html
https://root.cern/root/html602/RooAbsPdf.html:5956,Performance,cache,cacheUniqueSuffix,5956,"egateCacheUniqueSuffix() const; virtual Double_tRooAbsReal::analyticalIntegral(Int_t code, const char* rangeName = 0) const; virtual Double_tanalyticalIntegralWN(Int_t code, const RooArgSet* normSet, const char* rangeName = 0) const; virtual voidTObject::AppendPad(Option_t* option = """"); TF1*RooAbsReal::asTF(const RooArgList& obs, const RooArgList& pars = RooArgList(), const RooArgSet& nset = RooArgSet()) const; voidRooAbsArg::attachDataSet(const RooAbsData& set); voidRooAbsArg::attachDataStore(const RooAbsDataStore& set); const set<string>&RooAbsArg::attributes() const; virtual list<Double_t>*RooAbsReal::binBoundaries(RooAbsRealLValue&, Double_t, Double_t) const; RooAbsFunc*RooAbsReal::bindVars(const RooArgSet& vars, const RooArgSet* nset = 0, Bool_t clipInvalid = kFALSE) const; voidRooAbsArg::branchNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t recurseNonDerived = kFALSE) const; virtual voidTObject::Browse(TBrowser* b); virtual const char*RooAbsArg::cacheUniqueSuffix() const; Bool_tcanBeExtended() const; virtual RooAbsArg::CacheModeRooAbsArg::canNodeBeCached() const; voidRooAbsArg::changeServer(RooAbsArg& server, Bool_t valueProp, Bool_t shapeProp); Bool_tRooAbsArg::checkDependents(const RooArgSet* nset) const; virtual Bool_tRooAbsArg::checkObservables(const RooArgSet* nset) const; virtual RooFitResult*chi2FitTo(RooDataHist& data, const RooLinkedList& cmdList); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); static voidclearEvalError(); static voidRooAbsReal::clearEvalErrorLog(); voidRooAbsArg::clearShapeDirty() const; voidRooAbsArg::clearValueAndShapeDirty() const; voidRooAbsArg::clearValueDirty() const; TIterator*RooAbsArg::clientIterator() const; virtual TObject*RooAbsArg::clone(const char* newname = 0) const; virtual TObject*RooAbsArg::Clone(const char* newname = 0) const; virtual RooAbsArg*RooAbsArg::cloneTree(const char* newname = 0) const; virtual Int_tRooAbsArg",MatchSource.WIKI,root/html602/RooAbsPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsPdf.html
https://root.cern/root/html602/RooAbsPdf.html:14851,Performance,cache,cacheList,14851,"* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual Double_texpectedEvents(const RooArgSet* nset) const; virtual Double_texpectedEvents(const RooArgSet& nset) const; RooExpensiveObjectCache&RooAbsArg::expensiveObjectCache() const; virtual Double_textendedTerm(Double_t observedEvents, const RooArgSet* nset = 0) const; virtual RooAbsPdf::ExtendModeextendMode() const; virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); RooDataHist*RooAbsReal::fillDataHist(RooDataHist* hist, const RooArgSet* nset, Double_t scaleFactor, Bool_t correctForBinVolume = kFALSE, Bool_t showProgress = kFALSE) const; TH1*RooAbsReal::fillHistogram(TH1* hist, const RooArgList& plotVars, Double_t scaleFactor = 1, const RooArgSet* projectedVars = 0, Bool_t scaling = kTRUE, const RooArgSet* condObs = 0, Bool_t setError = kTRUE) const; Bool_tRooAbsArg::findConstantNodes(const RooArgSet& observables, RooArgSet& cacheList); Bool_tRooAbsArg::findConstantNodes(const RooArgSet& observables, RooArgSet& cacheList, RooLinkedList& processedNodes); RooAbsArg*RooAbsArg::findNewServer(const RooAbsCollection& newSet, Bool_t nameChange) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; Double_tRooAbsReal::findRoot(RooRealVar& x, Double_t xmin, Double_t xmax, Double_t yval); RooAbsArg*RooAbsArg::findServer(const char* name) const; RooAbsArg*RooAbsArg::findServer(const RooAbsArg& arg) const; RooAbsArg*RooAbsArg::findServer(Int_t index) const; virtual RooFitResult*fitTo(RooAbsData& data, const RooLinkedList& cmdList); virtual RooFitResult*fitTo(RooAbsData& data, const RooCmdArg& arg1 = RooCmdArg::none(), const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& a",MatchSource.WIKI,root/html602/RooAbsPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsPdf.html
https://root.cern/root/html602/RooAbsPdf.html:14939,Performance,cache,cacheList,14939,"l Double_texpectedEvents(const RooArgSet* nset) const; virtual Double_texpectedEvents(const RooArgSet& nset) const; RooExpensiveObjectCache&RooAbsArg::expensiveObjectCache() const; virtual Double_textendedTerm(Double_t observedEvents, const RooArgSet* nset = 0) const; virtual RooAbsPdf::ExtendModeextendMode() const; virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); RooDataHist*RooAbsReal::fillDataHist(RooDataHist* hist, const RooArgSet* nset, Double_t scaleFactor, Bool_t correctForBinVolume = kFALSE, Bool_t showProgress = kFALSE) const; TH1*RooAbsReal::fillHistogram(TH1* hist, const RooArgList& plotVars, Double_t scaleFactor = 1, const RooArgSet* projectedVars = 0, Bool_t scaling = kTRUE, const RooArgSet* condObs = 0, Bool_t setError = kTRUE) const; Bool_tRooAbsArg::findConstantNodes(const RooArgSet& observables, RooArgSet& cacheList); Bool_tRooAbsArg::findConstantNodes(const RooArgSet& observables, RooArgSet& cacheList, RooLinkedList& processedNodes); RooAbsArg*RooAbsArg::findNewServer(const RooAbsCollection& newSet, Bool_t nameChange) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; Double_tRooAbsReal::findRoot(RooRealVar& x, Double_t xmin, Double_t xmax, Double_t yval); RooAbsArg*RooAbsArg::findServer(const char* name) const; RooAbsArg*RooAbsArg::findServer(const RooAbsArg& arg) const; RooAbsArg*RooAbsArg::findServer(Int_t index) const; virtual RooFitResult*fitTo(RooAbsData& data, const RooLinkedList& cmdList); virtual RooFitResult*fitTo(RooAbsData& data, const RooCmdArg& arg1 = RooCmdArg::none(), const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()); virtual voidRooAbsR",MatchSource.WIKI,root/html602/RooAbsPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsPdf.html
https://root.cern/root/html602/RooAbsPdf.html:26485,Performance,optimiz,optimizeCacheMode,26485,"et&) const; RooAbsMoment*RooAbsReal::moment(RooRealVar& obs, Int_t order, Bool_t central, Bool_t takeRoot); RooAbsMoment*RooAbsReal::moment(RooRealVar& obs, const RooArgSet& normObs, Int_t order, Bool_t central, Bool_t takeRoot, Bool_t intNormObs); Bool_tmustBeExtended() const; static voidRooPrintable::nameFieldLength(Int_t newLen); const TNamed*RooAbsArg::namePtr() const; const char*normRange() const; virtual Bool_tTObject::Notify(); Int_tRooAbsArg::numCaches() const; static Int_tRooAbsReal::numEvalErrorItems(); static Int_tRooAbsReal::numEvalErrors(); Bool_tRooAbsArg::observableOverlaps(const RooAbsData* dset, const RooAbsArg& testArg) const; Bool_tRooAbsArg::observableOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; virtual Double_tRooAbsReal::offset() const; voidTObject::operator delete(void* ptr); voidTObject::operator delete(void* ptr, void* vp); voidTObject::operator delete[](void* ptr); voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); RooAbsPdf&operator=(const RooAbsPdf&); Bool_tRooAbsReal::operator==(Double_t value) const; virtual Bool_tRooAbsReal::operator==(const RooAbsArg& other); RooAbsArg::OperModeRooAbsArg::operMode() const; virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables); virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables, RooArgSet& optNodes, RooLinkedList& processedNodes); Bool_tRooAbsArg::overlaps(const RooAbsArg& testArg, Bool_t valueOnly = kFALSE) const; const RooArgSet*RooAbsArg::ownedComponents() const; virtual voidTObject::Paint(Option_t* option = """"); virtual RooPlot*paramOn(RooPlot* frame, const RooAbsData* data, const char* label = """", Int_t sigDigits = 2, Option_t* options = ""NELU"", Double_t xmin = 0.",MatchSource.WIKI,root/html602/RooAbsPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsPdf.html
https://root.cern/root/html602/RooAbsPdf.html:26557,Performance,optimiz,optimizeCacheMode,26557,"et&) const; RooAbsMoment*RooAbsReal::moment(RooRealVar& obs, Int_t order, Bool_t central, Bool_t takeRoot); RooAbsMoment*RooAbsReal::moment(RooRealVar& obs, const RooArgSet& normObs, Int_t order, Bool_t central, Bool_t takeRoot, Bool_t intNormObs); Bool_tmustBeExtended() const; static voidRooPrintable::nameFieldLength(Int_t newLen); const TNamed*RooAbsArg::namePtr() const; const char*normRange() const; virtual Bool_tTObject::Notify(); Int_tRooAbsArg::numCaches() const; static Int_tRooAbsReal::numEvalErrorItems(); static Int_tRooAbsReal::numEvalErrors(); Bool_tRooAbsArg::observableOverlaps(const RooAbsData* dset, const RooAbsArg& testArg) const; Bool_tRooAbsArg::observableOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; virtual Double_tRooAbsReal::offset() const; voidTObject::operator delete(void* ptr); voidTObject::operator delete(void* ptr, void* vp); voidTObject::operator delete[](void* ptr); voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); RooAbsPdf&operator=(const RooAbsPdf&); Bool_tRooAbsReal::operator==(Double_t value) const; virtual Bool_tRooAbsReal::operator==(const RooAbsArg& other); RooAbsArg::OperModeRooAbsArg::operMode() const; virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables); virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables, RooArgSet& optNodes, RooLinkedList& processedNodes); Bool_tRooAbsArg::overlaps(const RooAbsArg& testArg, Bool_t valueOnly = kFALSE) const; const RooArgSet*RooAbsArg::ownedComponents() const; virtual voidTObject::Paint(Option_t* option = """"); virtual RooPlot*paramOn(RooPlot* frame, const RooAbsData* data, const char* label = """", Int_t sigDigits = 2, Option_t* options = ""NELU"", Double_t xmin = 0.",MatchSource.WIKI,root/html602/RooAbsPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsPdf.html
https://root.cern/root/html602/RooAbsPdf.html:30887,Performance,cache,cache,30887,"e::printStream(ostream& os, Int_t contents, RooPrintable::StyleOption style, TString indent = """") const; virtual voidRooAbsArg::printTitle(ostream& os) const; virtual voidRooAbsArg::printTree(ostream& os, TString indent = """") const; virtual voidprintValue(ostream& os) const; virtual Int_tTObject::Read(const char* name); virtual Bool_tRooAbsReal::readFromStream(istream& is, Bool_t compact, Bool_t verbose = kFALSE); Bool_tRooAbsArg::recursiveCheckDependents(const RooArgSet* nset) const; Bool_tRooAbsArg::recursiveCheckObservables(const RooArgSet* nset) const; Bool_tRooAbsArg::recursiveRedirectServers(const RooAbsCollection& newServerList, Bool_t mustReplaceAll = kFALSE, Bool_t nameChange = kFALSE, Bool_t recurseInNewSet = kTRUE); virtual voidTObject::RecursiveRemove(TObject* obj); Bool_tRooAbsArg::redirectServers(const RooAbsCollection& newServerList, Bool_t mustReplaceAll = kFALSE, Bool_t nameChange = kFALSE, Bool_t isRecursionStep = kFALSE); voidRooAbsArg::registerCache(RooAbsCache& cache); voidRooAbsArg::removeServer(RooAbsArg& server, Bool_t force = kFALSE); voidRooAbsArg::replaceServer(RooAbsArg& oldServer, RooAbsArg& newServer, Bool_t valueProp, Bool_t shapeProp); voidTObject::ResetBit(UInt_t f); virtual voidresetErrorCounters(Int_t resetValue = 10); RooAbsPdf(); RooAbsPdf(const char* name, const char* title = 0); RooAbsPdf(const char* name, const char* title, Double_t minVal, Double_t maxVal); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); virtual Bool_tselfNormalized() const; TIterator*RooAbsArg::serverIterator() const; RooFIterRooAbsArg::serverMIterator() const; virtual voidRooAbsArg::serverNameChangeHook(const RooAbsArg*, const RooAbsArg*); voidRooAbsArg::setAttribute(const Text_t* name, Bool_t value = kTRUE); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); virtual voidRooAbsArg::setCacheAndTrackHints(RooArgSet&); stati",MatchSource.WIKI,root/html602/RooAbsPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsPdf.html
https://root.cern/root/html602/RooAbsPdf.html:32312,Performance,cache,cache,32312,"ual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); virtual Bool_tselfNormalized() const; TIterator*RooAbsArg::serverIterator() const; RooFIterRooAbsArg::serverMIterator() const; virtual voidRooAbsArg::serverNameChangeHook(const RooAbsArg*, const RooAbsArg*); voidRooAbsArg::setAttribute(const Text_t* name, Bool_t value = kTRUE); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); virtual voidRooAbsArg::setCacheAndTrackHints(RooArgSet&); static voidRooAbsReal::setCacheCheck(Bool_t flag); virtual Bool_tRooAbsReal::setData(RooAbsData&, Bool_t = kTRUE); static voidRooAbsArg::setDirtyInhibit(Bool_t flag); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); static voidRooAbsReal::setEvalErrorLoggingMode(RooAbsReal::ErrorLoggingMode m); virtual voidRooAbsArg::setExpensiveObjectCache(RooExpensiveObjectCache& cache); voidsetGeneratorConfig(); voidsetGeneratorConfig(const RooNumGenConfig& config); static voidRooAbsReal::setHideOffset(Bool_t flag); voidRooAbsReal::setIntegratorConfig(); voidRooAbsReal::setIntegratorConfig(const RooNumIntConfig& config); voidRooAbsArg::setLocalNoDirtyInhibit(Bool_t flag) const; virtual voidRooAbsArg::SetName(const char* name); virtual voidRooAbsArg::SetNameTitle(const char* name, const char* title); voidsetNormRange(const char* rangeName); voidsetNormRangeOverride(const char* rangeName); static voidTObject::SetObjectStat(Bool_t stat); voidRooAbsArg::setOperMode(RooAbsArg::OperMode mode, Bool_t recurseADirty = kTRUE); voidRooAbsReal::setParameterizeIntegral(const RooArgSet& paramVars); voidRooAbsReal::setPlotLabel(const char* label); voidRooAbsArg::setProhibitServerRedirect(Bool_t flag); voidRooAbsArg::setShapeDirty() const; voidRooAbsArg::setStringAttribute(const Text_t* key, const Text_t* value); virtual voidTNamed::SetTitle(const char* title = """")MENU ; voidset",MatchSource.WIKI,root/html602/RooAbsPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsPdf.html
https://root.cern/root/html602/RooAbsPdf.html:34842,Performance,cache,cache,34842,"Object::SetUniqueID(UInt_t uid); voidRooAbsReal::setUnit(const char* unit); voidRooAbsArg::setValueDirty() const; TIterator*RooAbsArg::shapeClientIterator() const; RooFIterRooAbsArg::shapeClientMIterator() const; virtual voidShowMembers(TMemberInspector& insp) const; RooAbsMoment*RooAbsReal::sigma(RooRealVar& obs); RooAbsMoment*RooAbsReal::sigma(RooRealVar& obs, const RooArgSet& nset); virtual Int_tTNamed::Sizeof() const; RooNumGenConfig*specialGeneratorConfig() const; RooNumGenConfig*specialGeneratorConfig(Bool_t createOnTheFly); RooNumIntConfig*RooAbsReal::specialIntegratorConfig() const; RooNumIntConfig*RooAbsReal::specialIntegratorConfig(Bool_t createOnTheFly); virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); const map<string,string>&RooAbsArg::stringAttributes() const; virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; virtual Bool_ttraceEvalHook(Double_t value) const; Bool_ttraceEvalPdf(Double_t value) const; const set<string>&RooAbsArg::transientAttributes() const; voidRooAbsArg::treeNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t doBranch = kTRUE, Bool_t doLeaf = kTRUE, Bool_t valueOnly = kFALSE, Bool_t recurseNonDerived = kFALSE) const; voidRooAbsArg::unRegisterCache(RooAbsCache& cache); virtual voidTObject::UseCurrentStyle(); TIterator*RooAbsArg::valueClientIterator() const; RooFIterRooAbsArg::valueClientMIterator() const; static voidRooAbsArg::verboseDirty(Bool_t flag); static intverboseEval(); static voidverboseEval(Int_t stat); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; voidRooAbsArg::wireAllCaches(); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const; virtual voidRooAbsReal::writeToStream(ostream& os, Bool_t compact) const.",MatchSource.WIKI,root/html602/RooAbsPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsPdf.html
https://root.cern/root/html602/RooAbsPdf.html:38679,Performance,optimiz,optimizeDirtyHook,38679,"t RooDataSet* prototype, Double_t nEvents, Bool_t verbose, Bool_t randProtoOrder, Bool_t resampleProto, Bool_t skipInit = kFALSE, Bool_t extended = kFALSE) const; virtual voidRooAbsArg::getObservablesHook(const RooArgSet*, RooArgSet*) const; virtual voidRooAbsArg::getParametersHook(const RooArgSet*, RooArgSet*, Bool_t) const; RooAbsProxy*RooAbsArg::getProxy(Int_t index) const; static voidRooAbsReal::globalSelectComp(Bool_t flag); voidRooAbsArg::graphVizAddConnections(set<pair<RooAbsArg*,RooAbsArg*> >&); Bool_tRooAbsArg::inhibitDirty() const; TStringRooAbsReal::integralNameSuffix(const RooArgSet& iset, const RooArgSet* nset = 0, const char* rangeName = 0, Bool_t omitEmpty = kFALSE) const; Bool_tRooAbsReal::isSelectedComp() const; virtual Bool_tRooAbsReal::isValid() const; virtual Bool_tRooAbsReal::isValidReal(Double_t value, Bool_t printError = kFALSE) const; voidRooAbsReal::makeProjectionSet(const RooAbsArg* plotVar, const RooArgSet* allVars, RooArgSet& projectedVars, Bool_t silent) const; voidTObject::MakeZombie(); Bool_tRooAbsReal::matchArgs(const RooArgSet& allDeps, RooArgSet& numDeps, const RooArgProxy& a) const; Bool_tRooAbsReal::matchArgs(const RooArgSet& allDeps, RooArgSet& numDeps, const RooArgSet& set) const; Bool_tRooAbsReal::matchArgs(const RooArgSet& allDeps, RooArgSet& numDeps, const RooArgProxy& a, const RooArgProxy& b) const; Bool_tRooAbsReal::matchArgs(const RooArgSet& allDeps, RooArgSet& numDeps, const RooArgProxy& a, const RooArgProxy& b, const RooArgProxy& c) const; Bool_tRooAbsReal::matchArgs(const RooArgSet& allDeps, RooArgSet& numDeps, const RooArgProxy& a, const RooArgProxy& b, const RooArgProxy& c, const RooArgProxy& d) const; Int_tRooAbsArg::numProxies() const; virtual voidRooAbsArg::operModeHook(); virtual voidRooAbsArg::optimizeDirtyHook(const RooArgSet*); virtual RooPlot*paramOn(RooPlot* frame, const RooArgSet& params, Bool_t showConstants = kFALSE, const char* label = """", Int_t sigDigits = 2, Option_t* options = ""NELU"", Double_t xmin = 0.",MatchSource.WIKI,root/html602/RooAbsPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsPdf.html
https://root.cern/root/html602/RooAbsPdf.html:43861,Performance,cache,cache,43861,,MatchSource.WIKI,root/html602/RooAbsPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsPdf.html
https://root.cern/root/html602/RooAbsPdf.html:43944,Performance,cache,cache,43944,,MatchSource.WIKI,root/html602/RooAbsPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsPdf.html
https://root.cern/root/html602/RooAbsPdf.html:44142,Performance,cache,caches,44142,,MatchSource.WIKI,root/html602/RooAbsPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsPdf.html
https://root.cern/root/html602/RooAbsPdf.html:44674,Performance,cache,cache,44674,"string>RooAbsArg::_boolAttribBoolean attributes; set<string>RooAbsArg::_boolAttribTransient! Transient boolean attributes (not copied in ctor); Bool_tRooAbsReal::_boolValue! Transient cache for bool values from tree branches; UChar_tRooAbsReal::_byteValue! Transient cache for byte values from tree branches; static Bool_tRooAbsReal::_cacheCheckIf true, always validate contents of clean which outcome of evaluate(); deque<RooAbsCache*>RooAbsArg::_cacheListlist of caches; RooRefCountListRooAbsArg::_clientListlist of client objects; RooRefCountListRooAbsArg::_clientListShapesubset of clients that requested shape dirty flag propagation; RooRefCountListRooAbsArg::_clientListValuesubset of clients that requested value dirty flag propagation; TIterator*RooAbsArg::_clientShapeIter! Iterator over _clientListShape; TIterator*RooAbsArg::_clientValueIter! Iterator over _clientListValue; Bool_tRooAbsArg::_deleteWatch! Delete watch flag; RooExpensiveObjectCache*RooAbsArg::_eocachePointer to global cache manager for any expensive components created by this object; Int_t_errorCountNumber of errors remaining to print; static Bool_t_evalError; Bool_tRooAbsArg::_fastAllow fast access mode in getVal() and proxies; Float_tRooAbsReal::_floatValue! Transient cache for floating point values from tree branches; Bool_tRooAbsReal::_forceNumIntForce numerical integration if flag set; static Bool_tRooAbsReal::_globalSelectCompGlobal activation switch for component selection; static Bool_tRooAbsReal::_hideOffsetOffset hiding flag; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; Int_tRooAbsReal::_intValue! Transient cache for integer values from tree branches; Bool_tRooAbsArg::_isConstant! Cached isConstant status; TStringRooAbsReal::_labelPlot label for objects value; RooArgSet*RooAbsReal::_lastNSet!; Bool_tRooAbsArg::_localNoInhibitDirty! Prevent 'AlwaysDirty' mode for this node; static Int_tRooPrintable::_nameLength; TNamed*RooAbsArg::_name",MatchSource.WIKI,root/html602/RooAbsPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsPdf.html
https://root.cern/root/html602/RooAbsPdf.html:44931,Performance,cache,cache,44931,"boolAttribBoolean attributes; set<string>RooAbsArg::_boolAttribTransient! Transient boolean attributes (not copied in ctor); Bool_tRooAbsReal::_boolValue! Transient cache for bool values from tree branches; UChar_tRooAbsReal::_byteValue! Transient cache for byte values from tree branches; static Bool_tRooAbsReal::_cacheCheckIf true, always validate contents of clean which outcome of evaluate(); deque<RooAbsCache*>RooAbsArg::_cacheListlist of caches; RooRefCountListRooAbsArg::_clientListlist of client objects; RooRefCountListRooAbsArg::_clientListShapesubset of clients that requested shape dirty flag propagation; RooRefCountListRooAbsArg::_clientListValuesubset of clients that requested value dirty flag propagation; TIterator*RooAbsArg::_clientShapeIter! Iterator over _clientListShape; TIterator*RooAbsArg::_clientValueIter! Iterator over _clientListValue; Bool_tRooAbsArg::_deleteWatch! Delete watch flag; RooExpensiveObjectCache*RooAbsArg::_eocachePointer to global cache manager for any expensive components created by this object; Int_t_errorCountNumber of errors remaining to print; static Bool_t_evalError; Bool_tRooAbsArg::_fastAllow fast access mode in getVal() and proxies; Float_tRooAbsReal::_floatValue! Transient cache for floating point values from tree branches; Bool_tRooAbsReal::_forceNumIntForce numerical integration if flag set; static Bool_tRooAbsReal::_globalSelectCompGlobal activation switch for component selection; static Bool_tRooAbsReal::_hideOffsetOffset hiding flag; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; Int_tRooAbsReal::_intValue! Transient cache for integer values from tree branches; Bool_tRooAbsArg::_isConstant! Cached isConstant status; TStringRooAbsReal::_labelPlot label for objects value; RooArgSet*RooAbsReal::_lastNSet!; Bool_tRooAbsArg::_localNoInhibitDirty! Prevent 'AlwaysDirty' mode for this node; static Int_tRooPrintable::_nameLength; TNamed*RooAbsArg::_namePtr! Do not persist.",MatchSource.WIKI,root/html602/RooAbsPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsPdf.html
https://root.cern/root/html602/RooAbsPdf.html:45344,Performance,cache,cache,45344,"boolAttribBoolean attributes; set<string>RooAbsArg::_boolAttribTransient! Transient boolean attributes (not copied in ctor); Bool_tRooAbsReal::_boolValue! Transient cache for bool values from tree branches; UChar_tRooAbsReal::_byteValue! Transient cache for byte values from tree branches; static Bool_tRooAbsReal::_cacheCheckIf true, always validate contents of clean which outcome of evaluate(); deque<RooAbsCache*>RooAbsArg::_cacheListlist of caches; RooRefCountListRooAbsArg::_clientListlist of client objects; RooRefCountListRooAbsArg::_clientListShapesubset of clients that requested shape dirty flag propagation; RooRefCountListRooAbsArg::_clientListValuesubset of clients that requested value dirty flag propagation; TIterator*RooAbsArg::_clientShapeIter! Iterator over _clientListShape; TIterator*RooAbsArg::_clientValueIter! Iterator over _clientListValue; Bool_tRooAbsArg::_deleteWatch! Delete watch flag; RooExpensiveObjectCache*RooAbsArg::_eocachePointer to global cache manager for any expensive components created by this object; Int_t_errorCountNumber of errors remaining to print; static Bool_t_evalError; Bool_tRooAbsArg::_fastAllow fast access mode in getVal() and proxies; Float_tRooAbsReal::_floatValue! Transient cache for floating point values from tree branches; Bool_tRooAbsReal::_forceNumIntForce numerical integration if flag set; static Bool_tRooAbsReal::_globalSelectCompGlobal activation switch for component selection; static Bool_tRooAbsReal::_hideOffsetOffset hiding flag; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; Int_tRooAbsReal::_intValue! Transient cache for integer values from tree branches; Bool_tRooAbsArg::_isConstant! Cached isConstant status; TStringRooAbsReal::_labelPlot label for objects value; RooArgSet*RooAbsReal::_lastNSet!; Bool_tRooAbsArg::_localNoInhibitDirty! Prevent 'AlwaysDirty' mode for this node; static Int_tRooPrintable::_nameLength; TNamed*RooAbsArg::_namePtr! Do not persist.",MatchSource.WIKI,root/html602/RooAbsPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsPdf.html
https://root.cern/root/html602/RooAbsPdf.html:45920,Performance,cache,cache,45920,,MatchSource.WIKI,root/html602/RooAbsPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsPdf.html
https://root.cern/root/html602/RooAbsPdf.html:46547,Performance,cache,cache,46547,,MatchSource.WIKI,root/html602/RooAbsPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsPdf.html
https://root.cern/root/html602/RooAbsPdf.html:47302,Performance,cache,cache,47302,"t_t_negCountNumber of negative probablities remaining to print; RooAbsReal*_norm! Normalization integral (owned by _normMgr); RooObjCacheManager_normMgrThe cache manager; TString_normRangeNormalization range; static TString_normRangeOverride; RooArgSet*_normSet! Normalization set with for above integral; RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; Int_tRooAbsReal::_plotBinsNumber of plot bins; Double_tRooAbsReal::_plotMaxMaximum of plot range; Double_tRooAbsReal::_plotMinMinimum of plot range; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; RooRefArrayRooAbsArg::_proxyListlist of proxies; Double_t_rawValue; Char_tRooAbsReal::_sbyteValue! Transient cache for signed byte values from tree branches; Bool_t_selectCompComponent selection flag for RooAbsPdf::plotCompOn; Bool_tRooAbsReal::_selectComp! Component selection flag for RooAbsPdf::plotCompOn; RooRefCountListRooAbsArg::_serverListlist of server objects; Bool_tRooAbsArg::_shapeDirtyFlag set if value needs recalculating because input shapes modified; RooNumGenConfig*_specGeneratorConfig! MC generator configuration specific for this object; RooNumIntConfig*RooAbsReal::_specIntegratorConfigNumeric integrator configuration specific for this object; map<string,string>RooAbsArg::_stringAttribString attributes; Int_t_traceCountNumber of traces remaining to print; Bool_tRooAbsReal::_treeVar!do not persist; UInt_tRooAbsReal::_uintValue! Transient cache for unsigned integer values from tree branches; TStringRooAbsReal::_unitUnit for objects value; Double_tRooAbsReal::_valueCache for current value of object; Bool_tRooAbsArg::_valueDirtyFlag set if value needs recalculating because input values modified; static Bool_tRooAbsArg::_verboseDirtyStatic flag controlling verbose messaging for dirty state changes; static Int_t_verboseEval; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title.",MatchSource.WIKI,root/html602/RooAbsPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsPdf.html
https://root.cern/root/html602/RooAbsPdf.html:48465,Performance,cache,cached,48465,"recalculating because input values modified; static Bool_tRooAbsArg::_verboseDirtyStatic flag controlling verbose messaging for dirty state changes; static Int_t_verboseEval; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; RooAbsPdf(); Default constructor. RooAbsPdf(const char* name, const char* title = 0); Constructor with name and title only. RooAbsPdf(const char* name, const char* title, Double_t minVal, Double_t maxVal); Constructor with name, title, and plot range. RooAbsPdf(const RooAbsPdf& other, const char* name = 0); Copy constructor. ~RooAbsPdf(); Destructor. Double_t getValV(const RooArgSet* set = 0) const; Return current value, normalizated by integrating over; the observables in 'nset'. If 'nset' is 0, the unnormalized value.; is returned. All elements of 'nset' must be lvalues. Unnormalized values are not cached; Doing so would be complicated as _norm->getVal() could; spoil the cache and interfere with returning the cached; return value. Since unnormalized calls are typically; done in integration calls, there is no performance hit. Double_t analyticalIntegralWN(Int_t code, const RooArgSet* normSet, const char* rangeName = 0) const; Analytical integral with normalization (see RooAbsReal::analyticalIntegralWN() for further information). This function applies the normalization specified by 'normSet' to the integral returned; by RooAbsReal::analyticalIntegral(). The passthrough scenario (code=0) is also changed; to return a normalized answer. Bool_t traceEvalPdf(Double_t value) const; Check that passed value is positive and not 'not-a-number'. If; not, print an error, until the error counter reaches its set; maximum. Double_t getNorm(const RooArgSet* set = 0) const; Return the integral of this PDF over all observables listed in 'nset'. const RooAbsReal* getNormObj(const RooArgSet* set, const RooArgSet* iset, const TNamed* rangeName = 0) const",MatchSource.WIKI,root/html602/RooAbsPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsPdf.html
https://root.cern/root/html602/RooAbsPdf.html:48539,Performance,cache,cache,48539,"recalculating because input values modified; static Bool_tRooAbsArg::_verboseDirtyStatic flag controlling verbose messaging for dirty state changes; static Int_t_verboseEval; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; RooAbsPdf(); Default constructor. RooAbsPdf(const char* name, const char* title = 0); Constructor with name and title only. RooAbsPdf(const char* name, const char* title, Double_t minVal, Double_t maxVal); Constructor with name, title, and plot range. RooAbsPdf(const RooAbsPdf& other, const char* name = 0); Copy constructor. ~RooAbsPdf(); Destructor. Double_t getValV(const RooArgSet* set = 0) const; Return current value, normalizated by integrating over; the observables in 'nset'. If 'nset' is 0, the unnormalized value.; is returned. All elements of 'nset' must be lvalues. Unnormalized values are not cached; Doing so would be complicated as _norm->getVal() could; spoil the cache and interfere with returning the cached; return value. Since unnormalized calls are typically; done in integration calls, there is no performance hit. Double_t analyticalIntegralWN(Int_t code, const RooArgSet* normSet, const char* rangeName = 0) const; Analytical integral with normalization (see RooAbsReal::analyticalIntegralWN() for further information). This function applies the normalization specified by 'normSet' to the integral returned; by RooAbsReal::analyticalIntegral(). The passthrough scenario (code=0) is also changed; to return a normalized answer. Bool_t traceEvalPdf(Double_t value) const; Check that passed value is positive and not 'not-a-number'. If; not, print an error, until the error counter reaches its set; maximum. Double_t getNorm(const RooArgSet* set = 0) const; Return the integral of this PDF over all observables listed in 'nset'. const RooAbsReal* getNormObj(const RooArgSet* set, const RooArgSet* iset, const TNamed* rangeName = 0) const",MatchSource.WIKI,root/html602/RooAbsPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsPdf.html
https://root.cern/root/html602/RooAbsPdf.html:48578,Performance,cache,cached,48578,"recalculating because input values modified; static Bool_tRooAbsArg::_verboseDirtyStatic flag controlling verbose messaging for dirty state changes; static Int_t_verboseEval; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; RooAbsPdf(); Default constructor. RooAbsPdf(const char* name, const char* title = 0); Constructor with name and title only. RooAbsPdf(const char* name, const char* title, Double_t minVal, Double_t maxVal); Constructor with name, title, and plot range. RooAbsPdf(const RooAbsPdf& other, const char* name = 0); Copy constructor. ~RooAbsPdf(); Destructor. Double_t getValV(const RooArgSet* set = 0) const; Return current value, normalizated by integrating over; the observables in 'nset'. If 'nset' is 0, the unnormalized value.; is returned. All elements of 'nset' must be lvalues. Unnormalized values are not cached; Doing so would be complicated as _norm->getVal() could; spoil the cache and interfere with returning the cached; return value. Since unnormalized calls are typically; done in integration calls, there is no performance hit. Double_t analyticalIntegralWN(Int_t code, const RooArgSet* normSet, const char* rangeName = 0) const; Analytical integral with normalization (see RooAbsReal::analyticalIntegralWN() for further information). This function applies the normalization specified by 'normSet' to the integral returned; by RooAbsReal::analyticalIntegral(). The passthrough scenario (code=0) is also changed; to return a normalized answer. Bool_t traceEvalPdf(Double_t value) const; Check that passed value is positive and not 'not-a-number'. If; not, print an error, until the error counter reaches its set; maximum. Double_t getNorm(const RooArgSet* set = 0) const; Return the integral of this PDF over all observables listed in 'nset'. const RooAbsReal* getNormObj(const RooArgSet* set, const RooArgSet* iset, const TNamed* rangeName = 0) const",MatchSource.WIKI,root/html602/RooAbsPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsPdf.html
https://root.cern/root/html602/RooAbsPdf.html:48679,Performance,perform,performance,48679,"rty state changes; static Int_t_verboseEval; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; RooAbsPdf(); Default constructor. RooAbsPdf(const char* name, const char* title = 0); Constructor with name and title only. RooAbsPdf(const char* name, const char* title, Double_t minVal, Double_t maxVal); Constructor with name, title, and plot range. RooAbsPdf(const RooAbsPdf& other, const char* name = 0); Copy constructor. ~RooAbsPdf(); Destructor. Double_t getValV(const RooArgSet* set = 0) const; Return current value, normalizated by integrating over; the observables in 'nset'. If 'nset' is 0, the unnormalized value.; is returned. All elements of 'nset' must be lvalues. Unnormalized values are not cached; Doing so would be complicated as _norm->getVal() could; spoil the cache and interfere with returning the cached; return value. Since unnormalized calls are typically; done in integration calls, there is no performance hit. Double_t analyticalIntegralWN(Int_t code, const RooArgSet* normSet, const char* rangeName = 0) const; Analytical integral with normalization (see RooAbsReal::analyticalIntegralWN() for further information). This function applies the normalization specified by 'normSet' to the integral returned; by RooAbsReal::analyticalIntegral(). The passthrough scenario (code=0) is also changed; to return a normalized answer. Bool_t traceEvalPdf(Double_t value) const; Check that passed value is positive and not 'not-a-number'. If; not, print an error, until the error counter reaches its set; maximum. Double_t getNorm(const RooArgSet* set = 0) const; Return the integral of this PDF over all observables listed in 'nset'. const RooAbsReal* getNormObj(const RooArgSet* set, const RooArgSet* iset, const TNamed* rangeName = 0) const; Return pointer to RooAbsReal object that implements calculation of integral over observables iset in range; rangeName, optional",MatchSource.WIKI,root/html602/RooAbsPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsPdf.html
https://root.cern/root/html602/RooAbsPdf.html:49829,Performance,cache,cached,49829,"tical integral with normalization (see RooAbsReal::analyticalIntegralWN() for further information). This function applies the normalization specified by 'normSet' to the integral returned; by RooAbsReal::analyticalIntegral(). The passthrough scenario (code=0) is also changed; to return a normalized answer. Bool_t traceEvalPdf(Double_t value) const; Check that passed value is positive and not 'not-a-number'. If; not, print an error, until the error counter reaches its set; maximum. Double_t getNorm(const RooArgSet* set = 0) const; Return the integral of this PDF over all observables listed in 'nset'. const RooAbsReal* getNormObj(const RooArgSet* set, const RooArgSet* iset, const TNamed* rangeName = 0) const; Return pointer to RooAbsReal object that implements calculation of integral over observables iset in range; rangeName, optionally taking the integrand normalized over observables nset. Bool_t syncNormalization(const RooArgSet* dset, Bool_t adjustProxies = kTRUE) const; Verify that the normalization integral cached with this PDF; is valid for given set of normalization observables. If not, the cached normalization integral (if any) is deleted; and a new integral is constructed for use with 'nset'; Elements in 'nset' can be discrete and real, but must be lvalues. For functions that declare to be self-normalized by overloading the; selfNormalized() function, a unit normalization is always constructed. Bool_t traceEvalHook(Double_t value) const; WVE 08/21/01 Probably obsolete now. void resetErrorCounters(Int_t resetValue = 10); Reset error counter to given value, limiting the number; of future error messages for this pdf to 'resetValue'. void setTraceCounter(Int_t value, Bool_t allNodes = kFALSE); Reset trace counter to given value, limiting the; number of future trace messages for this pdf to 'value'. Double_t getLogVal(const RooArgSet* set = 0) const; Return the log of the current value with given normalization; An error message is printed if the argument of the log",MatchSource.WIKI,root/html602/RooAbsPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsPdf.html
https://root.cern/root/html602/RooAbsPdf.html:49916,Performance,cache,cached,49916,"RooAbsReal::analyticalIntegral(). The passthrough scenario (code=0) is also changed; to return a normalized answer. Bool_t traceEvalPdf(Double_t value) const; Check that passed value is positive and not 'not-a-number'. If; not, print an error, until the error counter reaches its set; maximum. Double_t getNorm(const RooArgSet* set = 0) const; Return the integral of this PDF over all observables listed in 'nset'. const RooAbsReal* getNormObj(const RooArgSet* set, const RooArgSet* iset, const TNamed* rangeName = 0) const; Return pointer to RooAbsReal object that implements calculation of integral over observables iset in range; rangeName, optionally taking the integrand normalized over observables nset. Bool_t syncNormalization(const RooArgSet* dset, Bool_t adjustProxies = kTRUE) const; Verify that the normalization integral cached with this PDF; is valid for given set of normalization observables. If not, the cached normalization integral (if any) is deleted; and a new integral is constructed for use with 'nset'; Elements in 'nset' can be discrete and real, but must be lvalues. For functions that declare to be self-normalized by overloading the; selfNormalized() function, a unit normalization is always constructed. Bool_t traceEvalHook(Double_t value) const; WVE 08/21/01 Probably obsolete now. void resetErrorCounters(Int_t resetValue = 10); Reset error counter to given value, limiting the number; of future error messages for this pdf to 'resetValue'. void setTraceCounter(Int_t value, Bool_t allNodes = kFALSE); Reset trace counter to given value, limiting the; number of future trace messages for this pdf to 'value'. Double_t getLogVal(const RooArgSet* set = 0) const; Return the log of the current value with given normalization; An error message is printed if the argument of the log is negative. Double_t extendedTerm(Double_t observedEvents, const RooArgSet* nset = 0) const; Returned the extended likelihood term (Nexpect - Nobserved*log(NExpected); of this PDF for the g",MatchSource.WIKI,root/html602/RooAbsPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsPdf.html
https://root.cern/root/html602/RooAbsPdf.html:53039,Performance,perform,performed,53039,"const char* name) -- Fit only data inside range with given name; Range(Double_t lo, Double_t hi) -- Fit only data inside given range. A range named ""fit"" is created on the fly on all observables.; Multiple comma separated range names can be specified.; SumCoefRange(const char* name) -- Set the range in which to interpret the coefficients of RooAddPdf components; NumCPU(int num, int strat) -- Parallelize NLL calculation on num CPUs. Strategy 0 = RooFit::BulkPartition (Default) --> Divide events in N equal chunks; Strategy 1 = RooFit::Interleave --> Process event i%N in process N. Recommended for binned data with; a substantial number of zero-bins, which will be distributed across processes more equitably in this strategy; Strategy 2 = RooFit::SimComponents --> Process each component likelihood of a RooSimultaneous fully in a single process; and distribute components over processes. This approach can be benificial if normalization calculation time; dominates the total computation time of a component (since the normalization calculation must be performed; in each process in strategies 0 and 1. However beware that if the RooSimultaneous components do not share many; parameters this strategy is inefficient: as most minuit-induced likelihood calculations involve changing; a single parameter, only 1 of the N processes will be active most of the time if RooSimultaneous components; do not share many parameters; Strategy 3 = RooFit::Hybrid --> Follow strategy 0 for all RooSimultaneous components, except those with less than; 30 dataset entries, for which strategy 2 is followed. Optimize(Bool_t flag) -- Activate constant term optimization (on by default); SplitRange(Bool_t flag) -- Use separate fit ranges in a simultaneous fit. Actual range name for each; subsample is assumed to by rangeName_{indexState} where indexState; is the state of the master index category of the simultaneous fit; Constrain(const RooArgSet&pars) -- For p.d.f.s that contain internal parameter constraint ",MatchSource.WIKI,root/html602/RooAbsPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsPdf.html
https://root.cern/root/html602/RooAbsPdf.html:53624,Performance,optimiz,optimization,53624,"istributed across processes more equitably in this strategy; Strategy 2 = RooFit::SimComponents --> Process each component likelihood of a RooSimultaneous fully in a single process; and distribute components over processes. This approach can be benificial if normalization calculation time; dominates the total computation time of a component (since the normalization calculation must be performed; in each process in strategies 0 and 1. However beware that if the RooSimultaneous components do not share many; parameters this strategy is inefficient: as most minuit-induced likelihood calculations involve changing; a single parameter, only 1 of the N processes will be active most of the time if RooSimultaneous components; do not share many parameters; Strategy 3 = RooFit::Hybrid --> Follow strategy 0 for all RooSimultaneous components, except those with less than; 30 dataset entries, for which strategy 2 is followed. Optimize(Bool_t flag) -- Activate constant term optimization (on by default); SplitRange(Bool_t flag) -- Use separate fit ranges in a simultaneous fit. Actual range name for each; subsample is assumed to by rangeName_{indexState} where indexState; is the state of the master index category of the simultaneous fit; Constrain(const RooArgSet&pars) -- For p.d.f.s that contain internal parameter constraint terms, only apply constraints to given subset of parameters; ExternalConstraints(const RooArgSet& ) -- Include given external constraints to likelihood; GlobalObservables(const RooArgSet&) -- Define the set of normalization observables to be used for the constraint terms.; If none are specified the constrained parameters are used; GlobalObservablesTag(const char* tagName) -- Define the set of normalization observables to be used for the constraint terms by a string attribute; associated with pdf observables that match the given tagName; Verbose(Bool_t flag) -- Constrols RooFit informational messages in likelihood construction; CloneData(Bool flag) -- Use clone o",MatchSource.WIKI,root/html602/RooAbsPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsPdf.html
https://root.cern/root/html602/RooAbsPdf.html:55825,Performance,perform,performed,55825," improve numeric stability in simultaneously fits with components with large likelihood values. RooAbsReal* createNLL(RooAbsData& data, const RooLinkedList& cmdList); Construct representation of -log(L) of PDFwith given dataset. If dataset is unbinned, an unbinned likelihood is constructed. If the dataset; is binned, a binned likelihood is constructed. See RooAbsPdf::createNLL(RooAbsData& data, RooCmdArg arg1, RooCmdArg arg2, RooCmdArg arg3, RooCmdArg arg4,; RooCmdArg arg5, RooCmdArg arg6, RooCmdArg arg7, RooCmdArg arg8). for documentation of options. RooFitResult* fitTo(RooAbsData& data, const RooCmdArg& arg1 = RooCmdArg::none(), const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()); Fit PDF to given dataset. If dataset is unbinned, an unbinned maximum likelihood is performed. If the dataset; is binned, a binned maximum likelihood is performed. By default the fit is executed through the MINUIT; commands MIGRAD, HESSE in succession. The following named arguments are supported. Options to control construction of -log(L). ConditionalObservables(const RooArgSet& set) -- Do not normalize PDF over listed observables; Extended(Bool_t flag) -- Add extended likelihood term, off by default; Range(const char* name) -- Fit only data inside range with given name; Range(Double_t lo, Double_t hi) -- Fit only data inside given range. A range named ""fit"" is created on the fly on all observables.; Multiple comma separated range names can be specified.; SumCoefRange(const char* name) -- Set the range in which to interpret the coefficients of RooAddPdf components; NumCPU(int num, int strat) -- Parallelize NLL calculation on num CPUs. Strategy 0 = RooFit::BulkPartition (Default) --> Divide events in N equal chunks; Strategy 1 = RooFit::Interlea",MatchSource.WIKI,root/html602/RooAbsPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsPdf.html
https://root.cern/root/html602/RooAbsPdf.html:55894,Performance,perform,performed,55894,"h large likelihood values. RooAbsReal* createNLL(RooAbsData& data, const RooLinkedList& cmdList); Construct representation of -log(L) of PDFwith given dataset. If dataset is unbinned, an unbinned likelihood is constructed. If the dataset; is binned, a binned likelihood is constructed. See RooAbsPdf::createNLL(RooAbsData& data, RooCmdArg arg1, RooCmdArg arg2, RooCmdArg arg3, RooCmdArg arg4,; RooCmdArg arg5, RooCmdArg arg6, RooCmdArg arg7, RooCmdArg arg8). for documentation of options. RooFitResult* fitTo(RooAbsData& data, const RooCmdArg& arg1 = RooCmdArg::none(), const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()); Fit PDF to given dataset. If dataset is unbinned, an unbinned maximum likelihood is performed. If the dataset; is binned, a binned maximum likelihood is performed. By default the fit is executed through the MINUIT; commands MIGRAD, HESSE in succession. The following named arguments are supported. Options to control construction of -log(L). ConditionalObservables(const RooArgSet& set) -- Do not normalize PDF over listed observables; Extended(Bool_t flag) -- Add extended likelihood term, off by default; Range(const char* name) -- Fit only data inside range with given name; Range(Double_t lo, Double_t hi) -- Fit only data inside given range. A range named ""fit"" is created on the fly on all observables.; Multiple comma separated range names can be specified.; SumCoefRange(const char* name) -- Set the range in which to interpret the coefficients of RooAddPdf components; NumCPU(int num, int strat) -- Parallelize NLL calculation on num CPUs. Strategy 0 = RooFit::BulkPartition (Default) --> Divide events in N equal chunks; Strategy 1 = RooFit::Interleave --> Process event i%N in process N. Recommended for binned data wi",MatchSource.WIKI,root/html602/RooAbsPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsPdf.html
https://root.cern/root/html602/RooAbsPdf.html:57312,Performance,perform,performed,57312,"const char* name) -- Fit only data inside range with given name; Range(Double_t lo, Double_t hi) -- Fit only data inside given range. A range named ""fit"" is created on the fly on all observables.; Multiple comma separated range names can be specified.; SumCoefRange(const char* name) -- Set the range in which to interpret the coefficients of RooAddPdf components; NumCPU(int num, int strat) -- Parallelize NLL calculation on num CPUs. Strategy 0 = RooFit::BulkPartition (Default) --> Divide events in N equal chunks; Strategy 1 = RooFit::Interleave --> Process event i%N in process N. Recommended for binned data with; a substantial number of zero-bins, which will be distributed across processes more equitably in this strategy; Strategy 2 = RooFit::SimComponents --> Process each component likelihood of a RooSimultaneous fully in a single process; and distribute components over processes. This approach can be benificial if normalization calculation time; dominates the total computation time of a component (since the normalization calculation must be performed; in each process in strategies 0 and 1. However beware that if the RooSimultaneous components do not share many; parameters this strategy is inefficient: as most minuit-induced likelihood calculations involve changing; a single parameter, only 1 of the N processes will be active most of the time if RooSimultaneous components; do not share many parameters; Strategy 3 = RooFit::Hybrid --> Follow strategy 0 for all RooSimultaneous components, except those with less than; 30 dataset entries, for which strategy 2 is followed. SplitRange(Bool_t flag) -- Use separate fit ranges in a simultaneous fit. Actual range name for each; subsample is assumed to by rangeName_{indexState} where indexState; is the state of the master index category of the simultaneous fit; Constrained() -- Apply all constrained contained in the p.d.f. in the likelihood; Contrain(const RooArgSet&pars) -- Apply constraints to listed parameters in likelihood",MatchSource.WIKI,root/html602/RooAbsPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsPdf.html
https://root.cern/root/html602/RooAbsPdf.html:59550,Performance,optimiz,optimization,59550,". Options to control flow of fit procedure. Minimizer(type,algo) -- Choose minimization package and algorithm to use. Default is MINUIT/MIGRAD through the RooMinimizer; interface, but others can be specified (through RooMinimizer interface). Select OldMinuit to use; MINUIT through the old RooMinuit interface. Type Algorithm; ------ ---------; OldMinuit migrad, simplex, minimize (=migrad+simplex), migradimproved (=migrad+improve); Minuit migrad, simplex, minimize (=migrad+simplex), migradimproved (=migrad+improve); Minuit2 migrad, simplex, minimize, scan; GSLMultiMin conjugatefr, conjugatepr, bfgs, bfgs2, steepestdescent; GSLSimAn -. InitialHesse(Bool_t flag) -- Flag controls if HESSE before MIGRAD as well, off by default; Optimize(Bool_t flag) -- Activate constant term optimization of test statistic during minimization (on by default); Hesse(Bool_t flag) -- Flag controls if HESSE is run after MIGRAD, on by default; Minos(Bool_t flag) -- Flag controls if MINOS is run after HESSE, off by default; Minos(const RooArgSet& set) -- Only run MINOS on given subset of arguments; Save(Bool_t flag) -- Flac controls if RooFitResult object is produced and returned, off by default; Strategy(Int_t flag) -- Set Minuit strategy (0 through 2, default is 1); FitOptions(const char* optStr) -- Steer fit with classic options string (for backward compatibility). Use of this option; excludes use of any of the new style steering options. SumW2Error(Bool_t flag) -- Apply correaction to errors and covariance matrix using sum-of-weights covariance matrix; to obtain correct error for weighted likelihood fits. If this option is activated the; corrected covariance matrix is calculated as Vcorr = V C-1 V, where V is the original; covariance matrix and C is the inverse of the covariance matrix calculated using the; weights squared. Options to control informational output. Verbose(Bool_t flag) -- Flag controls if verbose output is printed (NLL, parameter changes during fit; Timer(Bool_t flag) -- Time",MatchSource.WIKI,root/html602/RooAbsPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsPdf.html
https://root.cern/root/html602/RooAbsPdf.html:61530,Performance,perform,performed,61530,"ce matrix and C is the inverse of the covariance matrix calculated using the; weights squared. Options to control informational output. Verbose(Bool_t flag) -- Flag controls if verbose output is printed (NLL, parameter changes during fit; Timer(Bool_t flag) -- Time CPU and wall clock consumption of fit steps, off by default; PrintLevel(Int_t level) -- Set Minuit print level (-1 through 3, default is 1). At -1 all RooFit informational; messages are suppressed as well; Warnings(Bool_t flag) -- Enable or disable MINUIT warnings (enabled by default); PrintEvalErrors(Int_t numErr) -- Control number of p.d.f evaluation errors printed per likelihood evaluation. A negative; value suppress output completely, a zero value will only print the error count per p.d.f component,; a positive value is will print details of each error up to numErr messages per p.d.f component. RooFitResult* fitTo(RooAbsData& data, const RooLinkedList& cmdList); Fit PDF to given dataset. If dataset is unbinned, an unbinned maximum likelihood is performed. If the dataset; is binned, a binned maximum likelihood is performed. By default the fit is executed through the MINUIT; commands MIGRAD, HESSE and MINOS in succession. See RooAbsPdf::fitTo(RooAbsData& data, RooCmdArg arg1, RooCmdArg arg2, RooCmdArg arg3, RooCmdArg arg4,; RooCmdArg arg5, RooCmdArg arg6, RooCmdArg arg7, RooCmdArg arg8). for documentation of options. RooFitResult* chi2FitTo(RooDataHist& data, const RooLinkedList& cmdList); Internal back-end function to steer chi2 fits. RooAbsReal* createChi2(RooDataHist& data, const RooCmdArg& arg1 = RooCmdArg::none(), const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()); Create a chi-2 from a histogram and this function. The following named arguments are suppo",MatchSource.WIKI,root/html602/RooAbsPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsPdf.html
https://root.cern/root/html602/RooAbsPdf.html:61599,Performance,perform,performed,61599,"ing the; weights squared. Options to control informational output. Verbose(Bool_t flag) -- Flag controls if verbose output is printed (NLL, parameter changes during fit; Timer(Bool_t flag) -- Time CPU and wall clock consumption of fit steps, off by default; PrintLevel(Int_t level) -- Set Minuit print level (-1 through 3, default is 1). At -1 all RooFit informational; messages are suppressed as well; Warnings(Bool_t flag) -- Enable or disable MINUIT warnings (enabled by default); PrintEvalErrors(Int_t numErr) -- Control number of p.d.f evaluation errors printed per likelihood evaluation. A negative; value suppress output completely, a zero value will only print the error count per p.d.f component,; a positive value is will print details of each error up to numErr messages per p.d.f component. RooFitResult* fitTo(RooAbsData& data, const RooLinkedList& cmdList); Fit PDF to given dataset. If dataset is unbinned, an unbinned maximum likelihood is performed. If the dataset; is binned, a binned maximum likelihood is performed. By default the fit is executed through the MINUIT; commands MIGRAD, HESSE and MINOS in succession. See RooAbsPdf::fitTo(RooAbsData& data, RooCmdArg arg1, RooCmdArg arg2, RooCmdArg arg3, RooCmdArg arg4,; RooCmdArg arg5, RooCmdArg arg6, RooCmdArg arg7, RooCmdArg arg8). for documentation of options. RooFitResult* chi2FitTo(RooDataHist& data, const RooLinkedList& cmdList); Internal back-end function to steer chi2 fits. RooAbsReal* createChi2(RooDataHist& data, const RooCmdArg& arg1 = RooCmdArg::none(), const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()); Create a chi-2 from a histogram and this function. The following named arguments are supported. Options to control construction of the chi^2. Extended() -- Use",MatchSource.WIKI,root/html602/RooAbsPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsPdf.html
https://root.cern/root/html602/RooAbsPdf.html:77334,Performance,perform,performed,77334,"esent. Any variables of this PDF that are not in whatVars will use their; current values and be treated as fixed parameters. Returns zero; in case of an error. The caller takes ownership of the returned; dataset. RooDataSet* generateSimGlobal(const RooArgSet& whatVars, Int_t nEvents); Special generator interface for generation of 'global observables' -- for RooStats tools. RooPlot* plotOn(RooPlot* frame, RooLinkedList& cmdList) const; Plot (project) PDF on specified frame. If a PDF is plotted in an empty frame, it; will show a unit normalized curve in the frame variable, taken at the present value; of other observables defined for this PDF. If a PDF is plotted in a frame in which a dataset has already been plotted, it will; show a projected curve integrated over all variables that were present in the shown; dataset except for the one on the x-axis. The normalization of the curve will also; be adjusted to the event count of the plotted dataset. An informational message; will be printed for each projection step that is performed. This function takes the following named arguments. Projection control. Slice(const RooArgSet& set) -- Override default projection behaviour by omittting observables listed; in set from the projection, resulting a 'slice' plot. Slicing is usually; only sensible in discrete observables; Project(const RooArgSet& set) -- Override default projection behaviour by projecting over observables; given in set and complete ignoring the default projection behavior. Advanced use only.; ProjWData(const RooAbsData& d) -- Override default projection _technique_ (integration). For observables present in given dataset; projection of PDF is achieved by constructing an average over all observable values in given set.; Consult RooFit plotting tutorial for further explanation of meaning & use of this technique; ProjWData(const RooArgSet& s, -- As above but only consider subset 's' of observables in dataset 'd' for projection through data averaging; const RooAbsData",MatchSource.WIKI,root/html602/RooAbsPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsPdf.html
https://root.cern/root/html602/RooAbsPdf.html:85892,Performance,perform,performed,85892,"rn a p.d.f that represent a projection of this p.d.f integrated over given observables. RooAbsReal* createCdf(const RooArgSet& iset, const RooArgSet& nset = RooArgSet()); Create a cumulative distribution function of this p.d.f in terms; of the observables listed in iset. If no nset argument is given; the c.d.f normalization is constructed over the integrated; observables, so that its maximum value is precisely 1. It is also; possible to choose a different normalization for; multi-dimensional p.d.f.s: eg. for a pdf f(x,y,z) one can; construct a partial cdf c(x,y) that only when integrated itself; over z results in a maximum value of 1. To construct such a cdf pass; z as argument to the optional nset argument. RooAbsReal* createCdf(const RooArgSet& iset, const RooCmdArg& arg1, const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()); Create an object that represents the integral of the function over one or more observables listed in iset; The actual integration calculation is only performed when the return object is evaluated. The name; of the integral object is automatically constructed from the name of the input function, the variables; it integrates and the range integrates over. The following named arguments are accepted. SupNormSet(const RooArgSet&) -- Observables over which should be normalized _in_addition_ to the; integration observables; ScanNumCdf() -- Apply scanning technique if cdf integral involves numeric integration [ default ]; ScanAllCdf() -- Always apply scanning technique; ScanNoCdf() -- Never apply scanning technique; ScanParameters(Int_t nbins, -- Parameters for scanning technique of making CDF: number; Int_t intOrder) of sampled bins and order of interpolation applied on numeric cdf. RooAbsReal* createScanCd",MatchSource.WIKI,root/html602/RooAbsPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsPdf.html
https://root.cern/root/html602/RooAbsPdf.html:2074,Safety,safe,safe,2074," variables. In; such cases the normalization of the composite may not be simply the; integral over the dependents of the top level PDF as these are; functions with potentially non-trivial Jacobian terms themselves.; Therefore. --> No explicit attempt should be made to normalize; the functions output in evaluate(). In addition, RooAbsPdf objects do not have a static concept of what; variables are parameters and what variables are dependents (which; need to be integrated over for a correct PDF normalization).; Instead the choice of normalization is always specified each time a; normalized values is requested from the PDF via the getVal(); method. RooAbsPdf manages the entire normalization logic of each PDF with; help of a RooRealIntegral object, which coordinates the integration; of a given choice of normalization. By default, RooRealIntegral will; perform a fully numeric integration of all dependents. However,; PDFs can advertise one or more (partial) analytical integrals of; their function, and these will be used by RooRealIntegral, if it; determines that this is safe (i.e. no hidden Jacobian terms,; multiplication with other PDFs that have one or more dependents in; commen etc). To implement analytical integrals, two functions must be implemented. First,. Int_t getAnalyticalIntegral(const RooArgSet& integSet, RooArgSet& anaIntSet). advertises the analytical integrals that are supported. 'integSet'; is the set of dependents for which integration is requested. The; function should copy the subset of dependents it can analytically; integrate to anaIntSet and return a unique identification code for; this integration configuration. If no integration can be; performed, zero should be returned. Second,. Double_t analyticalIntegral(Int_t code). Implements the actual analytical integral(s) advertised by; getAnalyticalIntegral. This functions will only be called with; codes returned by getAnalyticalIntegral, except code zero. The integration range for real each dependent to b",MatchSource.WIKI,root/html602/RooAbsPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsPdf.html
https://root.cern/root/html602/RooAbsPdf.html:73263,Safety,safe,safely,73263,"rs with the subset of directVars that we can generate events for,; and return a code that specifies the generator algorithm we will use. A code of; zero indicates that we cannot generate any of the directVars (in this case, nothing; should be added to generatedVars). Any non-zero codes will be passed to our generateEvent(); implementation, but otherwise its value is arbitrary. The default implemetation of; this method returns zero. Subclasses will usually implement this method using the; matchArgs() methods to advertise the algorithms they provide. void initGenerator(Int_t code); Interface for one-time initialization to setup the generator for the specified code. void generateEvent(Int_t code); Interface for generation of anan event using the algorithm; corresponding to the specified code. The meaning of each code is; defined by the getGenerator() implementation. The default; implementation does nothing. Bool_t isDirectGenSafe(const RooAbsArg& arg) const; Check if given observable can be safely generated using the; pdfs internal generator mechanism (if that existsP). Observables; on which a PDF depends via more than route are not safe; for use with internal generators because they introduce; correlations not known to the internal generator. RooDataHist * generateBinned(const RooArgSet& whatVars, Double_t nEvents, const RooCmdArg& arg1, const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none()); Generate a new dataset containing the specified variables with events sampled from our distribution.; Generate the specified number of events or expectedEvents() if not specified. Any variables of this PDF that are not in whatVars will use their; current values and be treated as fixed parameters. Returns zero; in case of an error. The caller takes ownership of the returned; dataset. The following named arguments are supported. Name(const char* name) -- Name of the ",MatchSource.WIKI,root/html602/RooAbsPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsPdf.html
https://root.cern/root/html602/RooAbsPdf.html:73408,Safety,safe,safe,73408,"cannot generate any of the directVars (in this case, nothing; should be added to generatedVars). Any non-zero codes will be passed to our generateEvent(); implementation, but otherwise its value is arbitrary. The default implemetation of; this method returns zero. Subclasses will usually implement this method using the; matchArgs() methods to advertise the algorithms they provide. void initGenerator(Int_t code); Interface for one-time initialization to setup the generator for the specified code. void generateEvent(Int_t code); Interface for generation of anan event using the algorithm; corresponding to the specified code. The meaning of each code is; defined by the getGenerator() implementation. The default; implementation does nothing. Bool_t isDirectGenSafe(const RooAbsArg& arg) const; Check if given observable can be safely generated using the; pdfs internal generator mechanism (if that existsP). Observables; on which a PDF depends via more than route are not safe; for use with internal generators because they introduce; correlations not known to the internal generator. RooDataHist * generateBinned(const RooArgSet& whatVars, Double_t nEvents, const RooCmdArg& arg1, const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none()); Generate a new dataset containing the specified variables with events sampled from our distribution.; Generate the specified number of events or expectedEvents() if not specified. Any variables of this PDF that are not in whatVars will use their; current values and be treated as fixed parameters. Returns zero; in case of an error. The caller takes ownership of the returned; dataset. The following named arguments are supported. Name(const char* name) -- Name of the output dataset; Verbose(Bool_t flag) -- Print informational messages during event generation; Extended() -- The actual number of events generated will be sampled from a Poi",MatchSource.WIKI,root/html602/RooAbsPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsPdf.html
https://root.cern/root/html602/RooAbsPdf.html:16249,Security,hash,hash,16249," xmin, Double_t xmax, Double_t yval); RooAbsArg*RooAbsArg::findServer(const char* name) const; RooAbsArg*RooAbsArg::findServer(const RooAbsArg& arg) const; RooAbsArg*RooAbsArg::findServer(Int_t index) const; virtual RooFitResult*fitTo(RooAbsData& data, const RooLinkedList& cmdList); virtual RooFitResult*fitTo(RooAbsData& data, const RooCmdArg& arg1 = RooCmdArg::none(), const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()); virtual voidRooAbsReal::fixAddCoefNormalization(const RooArgSet& addNormSet = RooArgSet(), Bool_t force = kTRUE); virtual voidRooAbsReal::fixAddCoefRange(const char* rangeName = 0, Bool_t force = kTRUE); static UInt_tRooAbsArg::fnv1a32(const char* data); static UInt_tRooAbsArg::fnv1a32(const char* data, ULong_t sz, UInt_t hash = fnv1a32start); static ULong64_tRooAbsArg::fnv1a64(const char* data); static ULong64_tRooAbsArg::fnv1a64(const char* data, ULong_t sz, ULong64_t hash = fnv1a64start); virtual Bool_tRooAbsReal::forceAnalyticalInt(const RooAbsArg&) const; virtual voidRooAbsReal::forceNumInt(Bool_t flag = kTRUE); RooFunctor*RooAbsReal::functor(const RooArgList& obs, const RooArgList& pars = RooArgList(), const RooArgSet& nset = RooArgSet()) const; RooDataSet*generate(RooAbsPdf::GenSpec&) const; RooDataSet*generate(const RooArgSet& whatVars, const RooDataSet& prototype, Int_t nEvents = 0, Bool_t verbose = kFALSE, Bool_t randProtoOrder = kFALSE, Bool_t resampleProto = kFALSE) const; RooDataSet*generate(const RooArgSet& whatVars, Int_t nEvents, const RooCmdArg& arg1, const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none()); RooDataSet*generate(const RooArgSet& whatVars, const RooCmdArg& arg1 ",MatchSource.WIKI,root/html602/RooAbsPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsPdf.html
https://root.cern/root/html602/RooAbsPdf.html:16400,Security,hash,hash,16400,"nst; RooAbsArg*RooAbsArg::findServer(Int_t index) const; virtual RooFitResult*fitTo(RooAbsData& data, const RooLinkedList& cmdList); virtual RooFitResult*fitTo(RooAbsData& data, const RooCmdArg& arg1 = RooCmdArg::none(), const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()); virtual voidRooAbsReal::fixAddCoefNormalization(const RooArgSet& addNormSet = RooArgSet(), Bool_t force = kTRUE); virtual voidRooAbsReal::fixAddCoefRange(const char* rangeName = 0, Bool_t force = kTRUE); static UInt_tRooAbsArg::fnv1a32(const char* data); static UInt_tRooAbsArg::fnv1a32(const char* data, ULong_t sz, UInt_t hash = fnv1a32start); static ULong64_tRooAbsArg::fnv1a64(const char* data); static ULong64_tRooAbsArg::fnv1a64(const char* data, ULong_t sz, ULong64_t hash = fnv1a64start); virtual Bool_tRooAbsReal::forceAnalyticalInt(const RooAbsArg&) const; virtual voidRooAbsReal::forceNumInt(Bool_t flag = kTRUE); RooFunctor*RooAbsReal::functor(const RooArgList& obs, const RooArgList& pars = RooArgList(), const RooArgSet& nset = RooArgSet()) const; RooDataSet*generate(RooAbsPdf::GenSpec&) const; RooDataSet*generate(const RooArgSet& whatVars, const RooDataSet& prototype, Int_t nEvents = 0, Bool_t verbose = kFALSE, Bool_t randProtoOrder = kFALSE, Bool_t resampleProto = kFALSE) const; RooDataSet*generate(const RooArgSet& whatVars, Int_t nEvents, const RooCmdArg& arg1, const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none()); RooDataSet*generate(const RooArgSet& whatVars, const RooCmdArg& arg1 = RooCmdArg::none(), const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), c",MatchSource.WIKI,root/html602/RooAbsPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsPdf.html
https://root.cern/root/html602/RooAbsPdf.html:44038,Security,validat,validate,44038,,MatchSource.WIKI,root/html602/RooAbsPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsPdf.html
https://root.cern/root/html602/RooAbsPdf.html:44852,Security,access,access,44852,"boolAttribBoolean attributes; set<string>RooAbsArg::_boolAttribTransient! Transient boolean attributes (not copied in ctor); Bool_tRooAbsReal::_boolValue! Transient cache for bool values from tree branches; UChar_tRooAbsReal::_byteValue! Transient cache for byte values from tree branches; static Bool_tRooAbsReal::_cacheCheckIf true, always validate contents of clean which outcome of evaluate(); deque<RooAbsCache*>RooAbsArg::_cacheListlist of caches; RooRefCountListRooAbsArg::_clientListlist of client objects; RooRefCountListRooAbsArg::_clientListShapesubset of clients that requested shape dirty flag propagation; RooRefCountListRooAbsArg::_clientListValuesubset of clients that requested value dirty flag propagation; TIterator*RooAbsArg::_clientShapeIter! Iterator over _clientListShape; TIterator*RooAbsArg::_clientValueIter! Iterator over _clientListValue; Bool_tRooAbsArg::_deleteWatch! Delete watch flag; RooExpensiveObjectCache*RooAbsArg::_eocachePointer to global cache manager for any expensive components created by this object; Int_t_errorCountNumber of errors remaining to print; static Bool_t_evalError; Bool_tRooAbsArg::_fastAllow fast access mode in getVal() and proxies; Float_tRooAbsReal::_floatValue! Transient cache for floating point values from tree branches; Bool_tRooAbsReal::_forceNumIntForce numerical integration if flag set; static Bool_tRooAbsReal::_globalSelectCompGlobal activation switch for component selection; static Bool_tRooAbsReal::_hideOffsetOffset hiding flag; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; Int_tRooAbsReal::_intValue! Transient cache for integer values from tree branches; Bool_tRooAbsArg::_isConstant! Cached isConstant status; TStringRooAbsReal::_labelPlot label for objects value; RooArgSet*RooAbsReal::_lastNSet!; Bool_tRooAbsArg::_localNoInhibitDirty! Prevent 'AlwaysDirty' mode for this node; static Int_tRooPrintable::_nameLength; TNamed*RooAbsArg::_namePtr! Do not persist.",MatchSource.WIKI,root/html602/RooAbsPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsPdf.html
https://root.cern/root/html602/RooAbsPdf.html:72015,Security,access,access,72015,"& prototype, Int_t nEvents = 0, Bool_t verbose = kFALSE, Bool_t randProtoOrder = kFALSE, Bool_t resampleProto = kFALSE) const; Generate a new dataset with values of the whatVars variables; sampled from our distribution. Use the specified existing dataset; as a prototype: the new dataset will contain the same number of; events as the prototype (by default), and any prototype variables not in; whatVars will be copied into the new dataset for each generated; event and also used to set our PDF parameters. The user can specify a; number of events to generate that will override the default. The result is a; copy of the prototype dataset with only variables in whatVars; randomized. Variables in whatVars that are not in the prototype; will be added as new columns to the generated dataset. Returns; zero in case of an error. The caller takes ownership of the; returned dataset. Int_t* randomizeProtoOrder(Int_t nProto, Int_t nGen, Bool_t resample = kFALSE) const; Return lookup table with randomized access order for prototype events,; given nProto prototype data events and nGen events that will actually; be accessed. Int_t getGenerator(const RooArgSet& directVars, RooArgSet& generateVars, Bool_t staticInitOK = kTRUE) const; Load generatedVars with the subset of directVars that we can generate events for,; and return a code that specifies the generator algorithm we will use. A code of; zero indicates that we cannot generate any of the directVars (in this case, nothing; should be added to generatedVars). Any non-zero codes will be passed to our generateEvent(); implementation, but otherwise its value is arbitrary. The default implemetation of; this method returns zero. Subclasses will usually implement this method using the; matchArgs() methods to advertise the algorithms they provide. void initGenerator(Int_t code); Interface for one-time initialization to setup the generator for the specified code. void generateEvent(Int_t code); Interface for generation of anan event using the ",MatchSource.WIKI,root/html602/RooAbsPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsPdf.html
https://root.cern/root/html602/RooAbsPdf.html:72125,Security,access,accessed,72125,"& prototype, Int_t nEvents = 0, Bool_t verbose = kFALSE, Bool_t randProtoOrder = kFALSE, Bool_t resampleProto = kFALSE) const; Generate a new dataset with values of the whatVars variables; sampled from our distribution. Use the specified existing dataset; as a prototype: the new dataset will contain the same number of; events as the prototype (by default), and any prototype variables not in; whatVars will be copied into the new dataset for each generated; event and also used to set our PDF parameters. The user can specify a; number of events to generate that will override the default. The result is a; copy of the prototype dataset with only variables in whatVars; randomized. Variables in whatVars that are not in the prototype; will be added as new columns to the generated dataset. Returns; zero in case of an error. The caller takes ownership of the; returned dataset. Int_t* randomizeProtoOrder(Int_t nProto, Int_t nGen, Bool_t resample = kFALSE) const; Return lookup table with randomized access order for prototype events,; given nProto prototype data events and nGen events that will actually; be accessed. Int_t getGenerator(const RooArgSet& directVars, RooArgSet& generateVars, Bool_t staticInitOK = kTRUE) const; Load generatedVars with the subset of directVars that we can generate events for,; and return a code that specifies the generator algorithm we will use. A code of; zero indicates that we cannot generate any of the directVars (in this case, nothing; should be added to generatedVars). Any non-zero codes will be passed to our generateEvent(); implementation, but otherwise its value is arbitrary. The default implemetation of; this method returns zero. Subclasses will usually implement this method using the; matchArgs() methods to advertise the algorithms they provide. void initGenerator(Int_t code); Interface for one-time initialization to setup the generator for the specified code. void generateEvent(Int_t code); Interface for generation of anan event using the ",MatchSource.WIKI,root/html602/RooAbsPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsPdf.html
https://root.cern/root/html602/RooAbsPdf.html:1690,Testability,log,logic,1690," part of a; probability density function, normalization is treated separately; in RooAbsPdf. The reason is that a RooAbsPdf object is more than a; PDF: it can be a building block for a more complex, composite PDF; if any of its variables are functions instead of variables. In; such cases the normalization of the composite may not be simply the; integral over the dependents of the top level PDF as these are; functions with potentially non-trivial Jacobian terms themselves.; Therefore. --> No explicit attempt should be made to normalize; the functions output in evaluate(). In addition, RooAbsPdf objects do not have a static concept of what; variables are parameters and what variables are dependents (which; need to be integrated over for a correct PDF normalization).; Instead the choice of normalization is always specified each time a; normalized values is requested from the PDF via the getVal(); method. RooAbsPdf manages the entire normalization logic of each PDF with; help of a RooRealIntegral object, which coordinates the integration; of a given choice of normalization. By default, RooRealIntegral will; perform a fully numeric integration of all dependents. However,; PDFs can advertise one or more (partial) analytical integrals of; their function, and these will be used by RooRealIntegral, if it; determines that this is safe (i.e. no hidden Jacobian terms,; multiplication with other PDFs that have one or more dependents in; commen etc). To implement analytical integrals, two functions must be implemented. First,. Int_t getAnalyticalIntegral(const RooArgSet& integSet, RooArgSet& anaIntSet). advertises the analytical integrals that are supported. 'integSet'; is the set of dependents for which integration is requested. The; function should copy the subset of dependents it can analytically; integrate to anaIntSet and return a unique identification code for; this integration configuration. If no integration can be; performed, zero should be returned. Second,. Double_t an",MatchSource.WIKI,root/html602/RooAbsPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsPdf.html
https://root.cern/root/html602/RooAbsPdf.html:3274,Testability,assert,assert,3274,"e implemented. First,. Int_t getAnalyticalIntegral(const RooArgSet& integSet, RooArgSet& anaIntSet). advertises the analytical integrals that are supported. 'integSet'; is the set of dependents for which integration is requested. The; function should copy the subset of dependents it can analytically; integrate to anaIntSet and return a unique identification code for; this integration configuration. If no integration can be; performed, zero should be returned. Second,. Double_t analyticalIntegral(Int_t code). Implements the actual analytical integral(s) advertised by; getAnalyticalIntegral. This functions will only be called with; codes returned by getAnalyticalIntegral, except code zero. The integration range for real each dependent to be integrated can; be obtained from the dependents' proxy functions min() and; max(). Never call these proxy functions for any proxy not known to; be a dependent via the integration code. Doing so may be; ill-defined, e.g. in case the proxy holds a function, and will; trigger an assert. Integrated category dependents should always be; summed over all of their states. [Direct generation of observables]. Any PDF dependent can be generated with the accept/reject method,; but for certain PDFs more efficient methods may be implemented. To; implement direct generation of one or more observables, two; functions need to be implemented, similar to those for analytical; integrals:. Int_t getGenerator(const RooArgSet& generateVars, RooArgSet& directVars) and; void generateEvent(Int_t code). The first function advertises observables that can be generated,; similar to the way analytical integrals are advertised. The second; function implements the generator for the advertised observables. The generated dependent values should be store in the proxy; objects. For this the assignment operator can be used (i.e. xProxy; = 3.0 ). Never call assign to any proxy not known to be a dependent; via the generation code. Doing so may be ill-defined, e.g. in case",MatchSource.WIKI,root/html602/RooAbsPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsPdf.html
https://root.cern/root/html602/RooAbsPdf.html:4299,Testability,assert,assert,4299," assert. Integrated category dependents should always be; summed over all of their states. [Direct generation of observables]. Any PDF dependent can be generated with the accept/reject method,; but for certain PDFs more efficient methods may be implemented. To; implement direct generation of one or more observables, two; functions need to be implemented, similar to those for analytical; integrals:. Int_t getGenerator(const RooArgSet& generateVars, RooArgSet& directVars) and; void generateEvent(Int_t code). The first function advertises observables that can be generated,; similar to the way analytical integrals are advertised. The second; function implements the generator for the advertised observables. The generated dependent values should be store in the proxy; objects. For this the assignment operator can be used (i.e. xProxy; = 3.0 ). Never call assign to any proxy not known to be a dependent; via the generation code. Doing so may be ill-defined, e.g. in case; the proxy holds a function, and will trigger an assert. Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~RooAbsPdf(); voidTObject::AbstractMethod(const char* method) const; Bool_tRooAbsArg::addOwnedComponents(const RooArgSet& comps); voidRooAbsArg::addParameters(RooArgSet& params, const RooArgSet* nset = 0, Bool_t stripDisconnected = kTRUE) const; voidRooAbsArg::addServer(RooAbsArg& server, Bool_t valueProp = kTRUE, Bool_t shapeProp = kFALSE); voidRooAbsArg::addServerList(RooAbsCollection& serverList, Bool_t valueProp = kTRUE, Bool_t shapeProp = kFALSE); const char*RooAbsArg::aggregateCacheUniqueSuffix() const; virtual Double_tRooAbsReal::analyticalIntegral(Int_t code, const char* rangeName = 0) const; virtual Double_tanalyticalIntegralWN(Int_t code, const RooArgSet* normSet, const char* rangeName = 0) const; virtual voidTObject::AppendPad(Option_t* option = """"); TF1*RooAbsReal::asTF",MatchSource.WIKI,root/html602/RooAbsPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsPdf.html
https://root.cern/root/html602/RooAbsPdf.html:12378,Testability,test,testArg,12378,":createProfile(const RooArgSet& paramsOfInterest); virtual RooAbsPdf*createProjection(const RooArgSet& iset); RooAbsReal*RooAbsReal::createRunningIntegral(const RooArgSet& iset, const RooArgSet& nset = RooArgSet()); RooAbsReal*RooAbsReal::createRunningIntegral(const RooArgSet& iset, const RooCmdArg& arg1, const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()); RooAbsReal*createScanCdf(const RooArgSet& iset, const RooArgSet& nset, Int_t numScanBins, Int_t intOrder); RooAbsReal*RooAbsReal::createScanRI(const RooArgSet& iset, const RooArgSet& nset, Int_t numScanBins, Int_t intOrder); virtual Double_tRooAbsReal::defaultErrorLevel() const; static RooNumGenConfig*defaultGeneratorConfig(); static RooNumIntConfig*RooAbsReal::defaultIntegratorConfig(); virtual Int_tRooAbsArg::defaultPrintContents(Option_t* opt) const; static ostream&RooPrintable::defaultPrintStream(ostream* os = 0); virtual RooPrintable::StyleOptionRooPrintable::defaultPrintStyle(Option_t* opt) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; Bool_tRooAbsArg::dependentOverlaps(const RooAbsData* dset, const RooAbsArg& testArg) const; Bool_tRooAbsArg::dependentOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; Bool_tRooAbsArg::dependsOn(const RooAbsCollection& serverList, const RooAbsArg* ignoreArg = 0, Bool_t valueOnly = kFALSE) const; Bool_tRooAbsArg::dependsOn(const RooAbsArg& server, const RooAbsArg* ignoreArg = 0, Bool_t valueOnly = kFALSE) const; Bool_tRooAbsArg::dependsOnValue(const RooAbsCollection& serverList, const RooAbsArg* ignoreArg = 0) const; Bool_tRooAbsArg::dependsOnValue(const RooAbsArg& server, const RooAbsArg* ignoreArg = 0) const; RooDerivative*RooAbsReal::derivative(RooRealVar& obs, Int_t order = 1, Double_t eps = 0.",MatchSource.WIKI,root/html602/RooAbsPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsPdf.html
https://root.cern/root/html602/RooAbsPdf.html:12472,Testability,test,testArg,12472,":createProfile(const RooArgSet& paramsOfInterest); virtual RooAbsPdf*createProjection(const RooArgSet& iset); RooAbsReal*RooAbsReal::createRunningIntegral(const RooArgSet& iset, const RooArgSet& nset = RooArgSet()); RooAbsReal*RooAbsReal::createRunningIntegral(const RooArgSet& iset, const RooCmdArg& arg1, const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()); RooAbsReal*createScanCdf(const RooArgSet& iset, const RooArgSet& nset, Int_t numScanBins, Int_t intOrder); RooAbsReal*RooAbsReal::createScanRI(const RooArgSet& iset, const RooArgSet& nset, Int_t numScanBins, Int_t intOrder); virtual Double_tRooAbsReal::defaultErrorLevel() const; static RooNumGenConfig*defaultGeneratorConfig(); static RooNumIntConfig*RooAbsReal::defaultIntegratorConfig(); virtual Int_tRooAbsArg::defaultPrintContents(Option_t* opt) const; static ostream&RooPrintable::defaultPrintStream(ostream* os = 0); virtual RooPrintable::StyleOptionRooPrintable::defaultPrintStyle(Option_t* opt) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; Bool_tRooAbsArg::dependentOverlaps(const RooAbsData* dset, const RooAbsArg& testArg) const; Bool_tRooAbsArg::dependentOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; Bool_tRooAbsArg::dependsOn(const RooAbsCollection& serverList, const RooAbsArg* ignoreArg = 0, Bool_t valueOnly = kFALSE) const; Bool_tRooAbsArg::dependsOn(const RooAbsArg& server, const RooAbsArg* ignoreArg = 0, Bool_t valueOnly = kFALSE) const; Bool_tRooAbsArg::dependsOnValue(const RooAbsCollection& serverList, const RooAbsArg* ignoreArg = 0) const; Bool_tRooAbsArg::dependsOnValue(const RooAbsArg& server, const RooAbsArg* ignoreArg = 0) const; RooDerivative*RooAbsReal::derivative(RooRealVar& obs, Int_t order = 1, Double_t eps = 0.",MatchSource.WIKI,root/html602/RooAbsPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsPdf.html
https://root.cern/root/html602/RooAbsPdf.html:24450,Testability,log,logEvalError,24450,") const; virtual Bool_tTObject::IsFolder() const; virtual Bool_tRooAbsArg::isFundamental() const; virtual Bool_tRooAbsReal::isIdentical(const RooAbsArg& other, Bool_t assumeSameType = kFALSE); virtual Bool_tRooAbsArg::isLValue() const; virtual Bool_tRooAbsReal::isOffsetting() const; Bool_tTObject::IsOnHeap() const; Bool_tRooAbsArg::isShapeDirty() const; Bool_tRooAbsArg::isShapeServer(const RooAbsArg& arg) const; Bool_tRooAbsArg::isShapeServer(const char* name) const; virtual Bool_tRooAbsArg::IsSortable() const; Bool_tRooAbsArg::isValueDirty() const; Bool_tRooAbsArg::isValueDirtyAndClear() const; Bool_tRooAbsArg::isValueOrShapeDirtyAndClear() const; Bool_tRooAbsArg::isValueServer(const RooAbsArg& arg) const; Bool_tRooAbsArg::isValueServer(const char* name) const; Bool_tTObject::IsZombie() const; voidRooAbsArg::leafNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t recurseNonDerived = kFALSE) const; Bool_tRooAbsArg::localNoDirtyInhibit() const; voidRooAbsReal::logEvalError(const char* message, const char* serverValueString = 0) const; static voidRooAbsReal::logEvalError(const RooAbsReal* originator, const char* origName, const char* message, const char* serverValueString = 0); virtual voidTNamed::ls(Option_t* option = """") const; virtual Double_tRooAbsReal::maxVal(Int_t code) const; voidTObject::MayNotUse(const char* method) const; RooAbsMoment*RooAbsReal::mean(RooRealVar& obs); RooAbsMoment*RooAbsReal::mean(RooRealVar& obs, const RooArgSet& nset); virtual Int_tRooAbsReal::minTrialSamples(const RooArgSet&) const; RooAbsMoment*RooAbsReal::moment(RooRealVar& obs, Int_t order, Bool_t central, Bool_t takeRoot); RooAbsMoment*RooAbsReal::moment(RooRealVar& obs, const RooArgSet& normObs, Int_t order, Bool_t central, Bool_t takeRoot, Bool_t intNormObs); Bool_tmustBeExtended() const; static voidRooPrintable::nameFieldLength(Int_t newLen); const TNamed*RooAbsArg::namePtr() const; const char*normRange() const; virtual Bool_tTObject::Notify(); Int_tRooAbsArg::n",MatchSource.WIKI,root/html602/RooAbsPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsPdf.html
https://root.cern/root/html602/RooAbsPdf.html:24549,Testability,log,logEvalError,24549,"irtual Bool_tRooAbsReal::isIdentical(const RooAbsArg& other, Bool_t assumeSameType = kFALSE); virtual Bool_tRooAbsArg::isLValue() const; virtual Bool_tRooAbsReal::isOffsetting() const; Bool_tTObject::IsOnHeap() const; Bool_tRooAbsArg::isShapeDirty() const; Bool_tRooAbsArg::isShapeServer(const RooAbsArg& arg) const; Bool_tRooAbsArg::isShapeServer(const char* name) const; virtual Bool_tRooAbsArg::IsSortable() const; Bool_tRooAbsArg::isValueDirty() const; Bool_tRooAbsArg::isValueDirtyAndClear() const; Bool_tRooAbsArg::isValueOrShapeDirtyAndClear() const; Bool_tRooAbsArg::isValueServer(const RooAbsArg& arg) const; Bool_tRooAbsArg::isValueServer(const char* name) const; Bool_tTObject::IsZombie() const; voidRooAbsArg::leafNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t recurseNonDerived = kFALSE) const; Bool_tRooAbsArg::localNoDirtyInhibit() const; voidRooAbsReal::logEvalError(const char* message, const char* serverValueString = 0) const; static voidRooAbsReal::logEvalError(const RooAbsReal* originator, const char* origName, const char* message, const char* serverValueString = 0); virtual voidTNamed::ls(Option_t* option = """") const; virtual Double_tRooAbsReal::maxVal(Int_t code) const; voidTObject::MayNotUse(const char* method) const; RooAbsMoment*RooAbsReal::mean(RooRealVar& obs); RooAbsMoment*RooAbsReal::mean(RooRealVar& obs, const RooArgSet& nset); virtual Int_tRooAbsReal::minTrialSamples(const RooArgSet&) const; RooAbsMoment*RooAbsReal::moment(RooRealVar& obs, Int_t order, Bool_t central, Bool_t takeRoot); RooAbsMoment*RooAbsReal::moment(RooRealVar& obs, const RooArgSet& normObs, Int_t order, Bool_t central, Bool_t takeRoot, Bool_t intNormObs); Bool_tmustBeExtended() const; static voidRooPrintable::nameFieldLength(Int_t newLen); const TNamed*RooAbsArg::namePtr() const; const char*normRange() const; virtual Bool_tTObject::Notify(); Int_tRooAbsArg::numCaches() const; static Int_tRooAbsReal::numEvalErrorItems(); static Int_tRooAbsReal::numEvalError",MatchSource.WIKI,root/html602/RooAbsPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsPdf.html
https://root.cern/root/html602/RooAbsPdf.html:25638,Testability,test,testArg,25638,"har* serverValueString = 0); virtual voidTNamed::ls(Option_t* option = """") const; virtual Double_tRooAbsReal::maxVal(Int_t code) const; voidTObject::MayNotUse(const char* method) const; RooAbsMoment*RooAbsReal::mean(RooRealVar& obs); RooAbsMoment*RooAbsReal::mean(RooRealVar& obs, const RooArgSet& nset); virtual Int_tRooAbsReal::minTrialSamples(const RooArgSet&) const; RooAbsMoment*RooAbsReal::moment(RooRealVar& obs, Int_t order, Bool_t central, Bool_t takeRoot); RooAbsMoment*RooAbsReal::moment(RooRealVar& obs, const RooArgSet& normObs, Int_t order, Bool_t central, Bool_t takeRoot, Bool_t intNormObs); Bool_tmustBeExtended() const; static voidRooPrintable::nameFieldLength(Int_t newLen); const TNamed*RooAbsArg::namePtr() const; const char*normRange() const; virtual Bool_tTObject::Notify(); Int_tRooAbsArg::numCaches() const; static Int_tRooAbsReal::numEvalErrorItems(); static Int_tRooAbsReal::numEvalErrors(); Bool_tRooAbsArg::observableOverlaps(const RooAbsData* dset, const RooAbsArg& testArg) const; Bool_tRooAbsArg::observableOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; virtual Double_tRooAbsReal::offset() const; voidTObject::operator delete(void* ptr); voidTObject::operator delete(void* ptr, void* vp); voidTObject::operator delete[](void* ptr); voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); RooAbsPdf&operator=(const RooAbsPdf&); Bool_tRooAbsReal::operator==(Double_t value) const; virtual Bool_tRooAbsReal::operator==(const RooAbsArg& other); RooAbsArg::OperModeRooAbsArg::operMode() const; virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables); virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables, RooArgSet& optNodes, RooLinkedList& p",MatchSource.WIKI,root/html602/RooAbsPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsPdf.html
https://root.cern/root/html602/RooAbsPdf.html:25733,Testability,test,testArg,25733,"e_tRooAbsReal::maxVal(Int_t code) const; voidTObject::MayNotUse(const char* method) const; RooAbsMoment*RooAbsReal::mean(RooRealVar& obs); RooAbsMoment*RooAbsReal::mean(RooRealVar& obs, const RooArgSet& nset); virtual Int_tRooAbsReal::minTrialSamples(const RooArgSet&) const; RooAbsMoment*RooAbsReal::moment(RooRealVar& obs, Int_t order, Bool_t central, Bool_t takeRoot); RooAbsMoment*RooAbsReal::moment(RooRealVar& obs, const RooArgSet& normObs, Int_t order, Bool_t central, Bool_t takeRoot, Bool_t intNormObs); Bool_tmustBeExtended() const; static voidRooPrintable::nameFieldLength(Int_t newLen); const TNamed*RooAbsArg::namePtr() const; const char*normRange() const; virtual Bool_tTObject::Notify(); Int_tRooAbsArg::numCaches() const; static Int_tRooAbsReal::numEvalErrorItems(); static Int_tRooAbsReal::numEvalErrors(); Bool_tRooAbsArg::observableOverlaps(const RooAbsData* dset, const RooAbsArg& testArg) const; Bool_tRooAbsArg::observableOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; virtual Double_tRooAbsReal::offset() const; voidTObject::operator delete(void* ptr); voidTObject::operator delete(void* ptr, void* vp); voidTObject::operator delete[](void* ptr); voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); RooAbsPdf&operator=(const RooAbsPdf&); Bool_tRooAbsReal::operator==(Double_t value) const; virtual Bool_tRooAbsReal::operator==(const RooAbsArg& other); RooAbsArg::OperModeRooAbsArg::operMode() const; virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables); virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables, RooArgSet& optNodes, RooLinkedList& processedNodes); Bool_tRooAbsArg::overlaps(const RooAbsArg& testArg, Bool_t valueOnly = kFALSE) ",MatchSource.WIKI,root/html602/RooAbsPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsPdf.html
https://root.cern/root/html602/RooAbsPdf.html:26701,Testability,test,testArg,26701,"et&) const; RooAbsMoment*RooAbsReal::moment(RooRealVar& obs, Int_t order, Bool_t central, Bool_t takeRoot); RooAbsMoment*RooAbsReal::moment(RooRealVar& obs, const RooArgSet& normObs, Int_t order, Bool_t central, Bool_t takeRoot, Bool_t intNormObs); Bool_tmustBeExtended() const; static voidRooPrintable::nameFieldLength(Int_t newLen); const TNamed*RooAbsArg::namePtr() const; const char*normRange() const; virtual Bool_tTObject::Notify(); Int_tRooAbsArg::numCaches() const; static Int_tRooAbsReal::numEvalErrorItems(); static Int_tRooAbsReal::numEvalErrors(); Bool_tRooAbsArg::observableOverlaps(const RooAbsData* dset, const RooAbsArg& testArg) const; Bool_tRooAbsArg::observableOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; virtual Double_tRooAbsReal::offset() const; voidTObject::operator delete(void* ptr); voidTObject::operator delete(void* ptr, void* vp); voidTObject::operator delete[](void* ptr); voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); RooAbsPdf&operator=(const RooAbsPdf&); Bool_tRooAbsReal::operator==(Double_t value) const; virtual Bool_tRooAbsReal::operator==(const RooAbsArg& other); RooAbsArg::OperModeRooAbsArg::operMode() const; virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables); virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables, RooArgSet& optNodes, RooLinkedList& processedNodes); Bool_tRooAbsArg::overlaps(const RooAbsArg& testArg, Bool_t valueOnly = kFALSE) const; const RooArgSet*RooAbsArg::ownedComponents() const; virtual voidTObject::Paint(Option_t* option = """"); virtual RooPlot*paramOn(RooPlot* frame, const RooAbsData* data, const char* label = """", Int_t sigDigits = 2, Option_t* options = ""NELU"", Double_t xmin = 0.",MatchSource.WIKI,root/html602/RooAbsPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsPdf.html
https://root.cern/root/html602/RooAbsPdf.html:50699,Testability,log,log,50699,"ion(const RooArgSet* dset, Bool_t adjustProxies = kTRUE) const; Verify that the normalization integral cached with this PDF; is valid for given set of normalization observables. If not, the cached normalization integral (if any) is deleted; and a new integral is constructed for use with 'nset'; Elements in 'nset' can be discrete and real, but must be lvalues. For functions that declare to be self-normalized by overloading the; selfNormalized() function, a unit normalization is always constructed. Bool_t traceEvalHook(Double_t value) const; WVE 08/21/01 Probably obsolete now. void resetErrorCounters(Int_t resetValue = 10); Reset error counter to given value, limiting the number; of future error messages for this pdf to 'resetValue'. void setTraceCounter(Int_t value, Bool_t allNodes = kFALSE); Reset trace counter to given value, limiting the; number of future trace messages for this pdf to 'value'. Double_t getLogVal(const RooArgSet* set = 0) const; Return the log of the current value with given normalization; An error message is printed if the argument of the log is negative. Double_t extendedTerm(Double_t observedEvents, const RooArgSet* nset = 0) const; Returned the extended likelihood term (Nexpect - Nobserved*log(NExpected); of this PDF for the given number of observed events. For successfull operation the PDF implementation must indicate; it is extendable by overloading canBeExtended() and must; implemented the expectedEvents() function. RooAbsReal* createNLL(RooAbsData& data, const RooCmdArg& arg1 = RooCmdArg::none(), const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()); Construct representation of -log(L) of PDFwith given dataset. If dataset is unbinned, an unbinned likelihood is constructed. If the dataset; is binne",MatchSource.WIKI,root/html602/RooAbsPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsPdf.html
https://root.cern/root/html602/RooAbsPdf.html:50801,Testability,log,log,50801,"ion(const RooArgSet* dset, Bool_t adjustProxies = kTRUE) const; Verify that the normalization integral cached with this PDF; is valid for given set of normalization observables. If not, the cached normalization integral (if any) is deleted; and a new integral is constructed for use with 'nset'; Elements in 'nset' can be discrete and real, but must be lvalues. For functions that declare to be self-normalized by overloading the; selfNormalized() function, a unit normalization is always constructed. Bool_t traceEvalHook(Double_t value) const; WVE 08/21/01 Probably obsolete now. void resetErrorCounters(Int_t resetValue = 10); Reset error counter to given value, limiting the number; of future error messages for this pdf to 'resetValue'. void setTraceCounter(Int_t value, Bool_t allNodes = kFALSE); Reset trace counter to given value, limiting the; number of future trace messages for this pdf to 'value'. Double_t getLogVal(const RooArgSet* set = 0) const; Return the log of the current value with given normalization; An error message is printed if the argument of the log is negative. Double_t extendedTerm(Double_t observedEvents, const RooArgSet* nset = 0) const; Returned the extended likelihood term (Nexpect - Nobserved*log(NExpected); of this PDF for the given number of observed events. For successfull operation the PDF implementation must indicate; it is extendable by overloading canBeExtended() and must; implemented the expectedEvents() function. RooAbsReal* createNLL(RooAbsData& data, const RooCmdArg& arg1 = RooCmdArg::none(), const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()); Construct representation of -log(L) of PDFwith given dataset. If dataset is unbinned, an unbinned likelihood is constructed. If the dataset; is binne",MatchSource.WIKI,root/html602/RooAbsPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsPdf.html
https://root.cern/root/html602/RooAbsPdf.html:50958,Testability,log,log,50958,"d normalization integral (if any) is deleted; and a new integral is constructed for use with 'nset'; Elements in 'nset' can be discrete and real, but must be lvalues. For functions that declare to be self-normalized by overloading the; selfNormalized() function, a unit normalization is always constructed. Bool_t traceEvalHook(Double_t value) const; WVE 08/21/01 Probably obsolete now. void resetErrorCounters(Int_t resetValue = 10); Reset error counter to given value, limiting the number; of future error messages for this pdf to 'resetValue'. void setTraceCounter(Int_t value, Bool_t allNodes = kFALSE); Reset trace counter to given value, limiting the; number of future trace messages for this pdf to 'value'. Double_t getLogVal(const RooArgSet* set = 0) const; Return the log of the current value with given normalization; An error message is printed if the argument of the log is negative. Double_t extendedTerm(Double_t observedEvents, const RooArgSet* nset = 0) const; Returned the extended likelihood term (Nexpect - Nobserved*log(NExpected); of this PDF for the given number of observed events. For successfull operation the PDF implementation must indicate; it is extendable by overloading canBeExtended() and must; implemented the expectedEvents() function. RooAbsReal* createNLL(RooAbsData& data, const RooCmdArg& arg1 = RooCmdArg::none(), const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()); Construct representation of -log(L) of PDFwith given dataset. If dataset is unbinned, an unbinned likelihood is constructed. If the dataset; is binned, a binned likelihood is constructed. The following named arguments are supported. ConditionalObservables(const RooArgSet& set) -- Do not normalize PDF over listed observables; Extended(Bool_t fl",MatchSource.WIKI,root/html602/RooAbsPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsPdf.html
https://root.cern/root/html602/RooAbsPdf.html:51606,Testability,log,log,51606,"f future error messages for this pdf to 'resetValue'. void setTraceCounter(Int_t value, Bool_t allNodes = kFALSE); Reset trace counter to given value, limiting the; number of future trace messages for this pdf to 'value'. Double_t getLogVal(const RooArgSet* set = 0) const; Return the log of the current value with given normalization; An error message is printed if the argument of the log is negative. Double_t extendedTerm(Double_t observedEvents, const RooArgSet* nset = 0) const; Returned the extended likelihood term (Nexpect - Nobserved*log(NExpected); of this PDF for the given number of observed events. For successfull operation the PDF implementation must indicate; it is extendable by overloading canBeExtended() and must; implemented the expectedEvents() function. RooAbsReal* createNLL(RooAbsData& data, const RooCmdArg& arg1 = RooCmdArg::none(), const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()); Construct representation of -log(L) of PDFwith given dataset. If dataset is unbinned, an unbinned likelihood is constructed. If the dataset; is binned, a binned likelihood is constructed. The following named arguments are supported. ConditionalObservables(const RooArgSet& set) -- Do not normalize PDF over listed observables; Extended(Bool_t flag) -- Add extended likelihood term, off by default; Range(const char* name) -- Fit only data inside range with given name; Range(Double_t lo, Double_t hi) -- Fit only data inside given range. A range named ""fit"" is created on the fly on all observables.; Multiple comma separated range names can be specified.; SumCoefRange(const char* name) -- Set the range in which to interpret the coefficients of RooAddPdf components; NumCPU(int num, int strat) -- Parallelize NLL calculation on num CPUs",MatchSource.WIKI,root/html602/RooAbsPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsPdf.html
https://root.cern/root/html602/RooAbsPdf.html:54996,Testability,log,log,54996,"arameter constraint terms, only apply constraints to given subset of parameters; ExternalConstraints(const RooArgSet& ) -- Include given external constraints to likelihood; GlobalObservables(const RooArgSet&) -- Define the set of normalization observables to be used for the constraint terms.; If none are specified the constrained parameters are used; GlobalObservablesTag(const char* tagName) -- Define the set of normalization observables to be used for the constraint terms by a string attribute; associated with pdf observables that match the given tagName; Verbose(Bool_t flag) -- Constrols RooFit informational messages in likelihood construction; CloneData(Bool flag) -- Use clone of dataset in NLL (default is true); Offset(Bool_t) -- Offset likelihood by initial value (so that starting value of FCN in minuit is zero). This; can improve numeric stability in simultaneously fits with components with large likelihood values. RooAbsReal* createNLL(RooAbsData& data, const RooLinkedList& cmdList); Construct representation of -log(L) of PDFwith given dataset. If dataset is unbinned, an unbinned likelihood is constructed. If the dataset; is binned, a binned likelihood is constructed. See RooAbsPdf::createNLL(RooAbsData& data, RooCmdArg arg1, RooCmdArg arg2, RooCmdArg arg3, RooCmdArg arg4,; RooCmdArg arg5, RooCmdArg arg6, RooCmdArg arg7, RooCmdArg arg8). for documentation of options. RooFitResult* fitTo(RooAbsData& data, const RooCmdArg& arg1 = RooCmdArg::none(), const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()); Fit PDF to given dataset. If dataset is unbinned, an unbinned maximum likelihood is performed. If the dataset; is binned, a binned maximum likelihood is performed. By default the fit is executed through the MINUIT; comman",MatchSource.WIKI,root/html602/RooAbsPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsPdf.html
https://root.cern/root/html602/RooAbsPdf.html:56075,Testability,log,log,56075,"nned likelihood is constructed. If the dataset; is binned, a binned likelihood is constructed. See RooAbsPdf::createNLL(RooAbsData& data, RooCmdArg arg1, RooCmdArg arg2, RooCmdArg arg3, RooCmdArg arg4,; RooCmdArg arg5, RooCmdArg arg6, RooCmdArg arg7, RooCmdArg arg8). for documentation of options. RooFitResult* fitTo(RooAbsData& data, const RooCmdArg& arg1 = RooCmdArg::none(), const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()); Fit PDF to given dataset. If dataset is unbinned, an unbinned maximum likelihood is performed. If the dataset; is binned, a binned maximum likelihood is performed. By default the fit is executed through the MINUIT; commands MIGRAD, HESSE in succession. The following named arguments are supported. Options to control construction of -log(L). ConditionalObservables(const RooArgSet& set) -- Do not normalize PDF over listed observables; Extended(Bool_t flag) -- Add extended likelihood term, off by default; Range(const char* name) -- Fit only data inside range with given name; Range(Double_t lo, Double_t hi) -- Fit only data inside given range. A range named ""fit"" is created on the fly on all observables.; Multiple comma separated range names can be specified.; SumCoefRange(const char* name) -- Set the range in which to interpret the coefficients of RooAddPdf components; NumCPU(int num, int strat) -- Parallelize NLL calculation on num CPUs. Strategy 0 = RooFit::BulkPartition (Default) --> Divide events in N equal chunks; Strategy 1 = RooFit::Interleave --> Process event i%N in process N. Recommended for binned data with; a substantial number of zero-bins, which will be distributed across processes more equitably in this strategy; Strategy 2 = RooFit::SimComponents --> Process each component likelihood of",MatchSource.WIKI,root/html602/RooAbsPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsPdf.html
https://root.cern/root/html602/RooAbsPdf.html:59566,Testability,test,test,59566,". Options to control flow of fit procedure. Minimizer(type,algo) -- Choose minimization package and algorithm to use. Default is MINUIT/MIGRAD through the RooMinimizer; interface, but others can be specified (through RooMinimizer interface). Select OldMinuit to use; MINUIT through the old RooMinuit interface. Type Algorithm; ------ ---------; OldMinuit migrad, simplex, minimize (=migrad+simplex), migradimproved (=migrad+improve); Minuit migrad, simplex, minimize (=migrad+simplex), migradimproved (=migrad+improve); Minuit2 migrad, simplex, minimize, scan; GSLMultiMin conjugatefr, conjugatepr, bfgs, bfgs2, steepestdescent; GSLSimAn -. InitialHesse(Bool_t flag) -- Flag controls if HESSE before MIGRAD as well, off by default; Optimize(Bool_t flag) -- Activate constant term optimization of test statistic during minimization (on by default); Hesse(Bool_t flag) -- Flag controls if HESSE is run after MIGRAD, on by default; Minos(Bool_t flag) -- Flag controls if MINOS is run after HESSE, off by default; Minos(const RooArgSet& set) -- Only run MINOS on given subset of arguments; Save(Bool_t flag) -- Flac controls if RooFitResult object is produced and returned, off by default; Strategy(Int_t flag) -- Set Minuit strategy (0 through 2, default is 1); FitOptions(const char* optStr) -- Steer fit with classic options string (for backward compatibility). Use of this option; excludes use of any of the new style steering options. SumW2Error(Bool_t flag) -- Apply correaction to errors and covariance matrix using sum-of-weights covariance matrix; to obtain correct error for weighted likelihood fits. If this option is activated the; corrected covariance matrix is calculated as Vcorr = V C-1 V, where V is the original; covariance matrix and C is the inverse of the covariance matrix calculated using the; weights squared. Options to control informational output. Verbose(Bool_t flag) -- Flag controls if verbose output is printed (NLL, parameter changes during fit; Timer(Bool_t flag) -- Time",MatchSource.WIKI,root/html602/RooAbsPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsPdf.html
https://root.cern/root/html602/RooAbsPdf.html:79537,Testability,log,log,79537,"ges. NB: A Range() by default implies a NormRange(); on the same range, but this option allows to override the default, or specify a normalization ranges; when the full curve is to be drawn. Misc content control. Normalization(Double_t scale, -- Adjust normalization by given scale factor. Interpretation of number depends on code: Relative:; ScaleType code) relative adjustment factor, NumEvent: scale to match given number of events.; Name(const chat* name) -- Give curve specified name in frame. Useful if curve is to be referenced later; Asymmetry(const RooCategory& c) -- Show the asymmetry of the PDF in given two-state category [F(+)-F(-)] / [F(+)+F(-)] rather than; the PDF projection. Category must have two states with indices -1 and +1 or three states with; indeces -1,0 and +1.; ShiftToZero(Bool_t flag) -- Shift entire curve such that lowest visible point is at exactly zero. Mostly useful when; plotting -log(L) or chi^2 distributions; AddTo(const char* name, -- Add constructed projection to already existing curve with given name and relative weight factors; double_t wgtSelf, double_t wgtOther). Plotting control. LineStyle(Int_t style) -- Select line style by ROOT line style code, default is solid; LineColor(Int_t color) -- Select line color by ROOT color code, default is blue; LineWidth(Int_t width) -- Select line with in pixels, default is 3; FillStyle(Int_t style) -- Select fill style, default is not filled. If a filled style is selected, also use VLines(); to add vertical downward lines at end of curve to ensure proper closure; FillColor(Int_t color) -- Select fill color by ROOT color code; Range(const char* name) -- Only draw curve in range defined by given name; Range(double lo, double hi) -- Only draw curve in specified range; VLines() -- Add vertical lines to y=0 at end points of curve; Precision(Double_t eps) -- Control precision of drawn curve w.r.t to scale of plot, default is 1e-3. Higher precision; will result in more and more densely spaced curve point",MatchSource.WIKI,root/html602/RooAbsPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsPdf.html
https://root.cern/root/html602/RooAbsPdf.html:1067,Usability,simpl,simply,1067,"ce file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » ROOFIT; » ROOFITCORE; » RooAbsPdf. class RooAbsPdf: public RooAbsReal. RooAbsPdf is the abstract interface for all probability density; functions The class provides hybrid analytical/numerical; normalization for its implementations, error tracing and a MC; generator interface. A minimal implementation of a PDF class derived from RooAbsPdf; should overload the evaluate() function. This functions should; return PDFs value. [Normalization/Integration]. Although the normalization of a PDF is an integral part of a; probability density function, normalization is treated separately; in RooAbsPdf. The reason is that a RooAbsPdf object is more than a; PDF: it can be a building block for a more complex, composite PDF; if any of its variables are functions instead of variables. In; such cases the normalization of the composite may not be simply the; integral over the dependents of the top level PDF as these are; functions with potentially non-trivial Jacobian terms themselves.; Therefore. --> No explicit attempt should be made to normalize; the functions output in evaluate(). In addition, RooAbsPdf objects do not have a static concept of what; variables are parameters and what variables are dependents (which; need to be integrated over for a correct PDF normalization).; Instead the choice of normalization is always specified each time a; normalized values is requested from the PDF via the getVal(); method. RooAbsPdf manages the entire normalization logic of each PDF with; help of a RooRealIntegral object, which coordinates the integration; of a given choice of normalization. By default, RooRealIntegral will; perform a fully numeric integration of all dependents. However,; PDFs can advertise one or more (partial) analytical integrals of; their function, and these will be used by RooRealIntegral, if it; determines that this is safe (i.e. no hidden Jacobian ter",MatchSource.WIKI,root/html602/RooAbsPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsPdf.html
https://root.cern/root/html602/RooAbsPdf.html:6548,Usability,clear,clearEvalErrorLog,6548,"ouble_t>*RooAbsReal::binBoundaries(RooAbsRealLValue&, Double_t, Double_t) const; RooAbsFunc*RooAbsReal::bindVars(const RooArgSet& vars, const RooArgSet* nset = 0, Bool_t clipInvalid = kFALSE) const; voidRooAbsArg::branchNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t recurseNonDerived = kFALSE) const; virtual voidTObject::Browse(TBrowser* b); virtual const char*RooAbsArg::cacheUniqueSuffix() const; Bool_tcanBeExtended() const; virtual RooAbsArg::CacheModeRooAbsArg::canNodeBeCached() const; voidRooAbsArg::changeServer(RooAbsArg& server, Bool_t valueProp, Bool_t shapeProp); Bool_tRooAbsArg::checkDependents(const RooArgSet* nset) const; virtual Bool_tRooAbsArg::checkObservables(const RooArgSet* nset) const; virtual RooFitResult*chi2FitTo(RooDataHist& data, const RooLinkedList& cmdList); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); static voidclearEvalError(); static voidRooAbsReal::clearEvalErrorLog(); voidRooAbsArg::clearShapeDirty() const; voidRooAbsArg::clearValueAndShapeDirty() const; voidRooAbsArg::clearValueDirty() const; TIterator*RooAbsArg::clientIterator() const; virtual TObject*RooAbsArg::clone(const char* newname = 0) const; virtual TObject*RooAbsArg::Clone(const char* newname = 0) const; virtual RooAbsArg*RooAbsArg::cloneTree(const char* newname = 0) const; virtual Int_tRooAbsArg::Compare(const TObject* other) const; virtual voidRooAbsArg::constOptimizeTestStatistic(RooAbsArg::ConstOpCode opcode, Bool_t doAlsoTrackingOpt = kTRUE); virtual voidTNamed::Copy(TObject& named) const; static UInt_tRooAbsArg::crc32(const char* data); static UInt_tRooAbsArg::crc32(const char* data, ULong_t sz, UInt_t crc = 0); RooAbsReal*createCdf(const RooArgSet& iset, const RooArgSet& nset = RooArgSet()); RooAbsReal*createCdf(const RooArgSet& iset, const RooCmdArg& arg1, const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooC",MatchSource.WIKI,root/html602/RooAbsPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsPdf.html
https://root.cern/root/html602/RooAbsPdf.html:6584,Usability,clear,clearShapeDirty,6584,"RooAbsRealLValue&, Double_t, Double_t) const; RooAbsFunc*RooAbsReal::bindVars(const RooArgSet& vars, const RooArgSet* nset = 0, Bool_t clipInvalid = kFALSE) const; voidRooAbsArg::branchNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t recurseNonDerived = kFALSE) const; virtual voidTObject::Browse(TBrowser* b); virtual const char*RooAbsArg::cacheUniqueSuffix() const; Bool_tcanBeExtended() const; virtual RooAbsArg::CacheModeRooAbsArg::canNodeBeCached() const; voidRooAbsArg::changeServer(RooAbsArg& server, Bool_t valueProp, Bool_t shapeProp); Bool_tRooAbsArg::checkDependents(const RooArgSet* nset) const; virtual Bool_tRooAbsArg::checkObservables(const RooArgSet* nset) const; virtual RooFitResult*chi2FitTo(RooDataHist& data, const RooLinkedList& cmdList); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); static voidclearEvalError(); static voidRooAbsReal::clearEvalErrorLog(); voidRooAbsArg::clearShapeDirty() const; voidRooAbsArg::clearValueAndShapeDirty() const; voidRooAbsArg::clearValueDirty() const; TIterator*RooAbsArg::clientIterator() const; virtual TObject*RooAbsArg::clone(const char* newname = 0) const; virtual TObject*RooAbsArg::Clone(const char* newname = 0) const; virtual RooAbsArg*RooAbsArg::cloneTree(const char* newname = 0) const; virtual Int_tRooAbsArg::Compare(const TObject* other) const; virtual voidRooAbsArg::constOptimizeTestStatistic(RooAbsArg::ConstOpCode opcode, Bool_t doAlsoTrackingOpt = kTRUE); virtual voidTNamed::Copy(TObject& named) const; static UInt_tRooAbsArg::crc32(const char* data); static UInt_tRooAbsArg::crc32(const char* data, ULong_t sz, UInt_t crc = 0); RooAbsReal*createCdf(const RooArgSet& iset, const RooArgSet& nset = RooArgSet()); RooAbsReal*createCdf(const RooArgSet& iset, const RooCmdArg& arg1, const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg",MatchSource.WIKI,root/html602/RooAbsPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsPdf.html
https://root.cern/root/html602/RooAbsPdf.html:6624,Usability,clear,clearValueAndShapeDirty,6624,"; RooAbsFunc*RooAbsReal::bindVars(const RooArgSet& vars, const RooArgSet* nset = 0, Bool_t clipInvalid = kFALSE) const; voidRooAbsArg::branchNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t recurseNonDerived = kFALSE) const; virtual voidTObject::Browse(TBrowser* b); virtual const char*RooAbsArg::cacheUniqueSuffix() const; Bool_tcanBeExtended() const; virtual RooAbsArg::CacheModeRooAbsArg::canNodeBeCached() const; voidRooAbsArg::changeServer(RooAbsArg& server, Bool_t valueProp, Bool_t shapeProp); Bool_tRooAbsArg::checkDependents(const RooArgSet* nset) const; virtual Bool_tRooAbsArg::checkObservables(const RooArgSet* nset) const; virtual RooFitResult*chi2FitTo(RooDataHist& data, const RooLinkedList& cmdList); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); static voidclearEvalError(); static voidRooAbsReal::clearEvalErrorLog(); voidRooAbsArg::clearShapeDirty() const; voidRooAbsArg::clearValueAndShapeDirty() const; voidRooAbsArg::clearValueDirty() const; TIterator*RooAbsArg::clientIterator() const; virtual TObject*RooAbsArg::clone(const char* newname = 0) const; virtual TObject*RooAbsArg::Clone(const char* newname = 0) const; virtual RooAbsArg*RooAbsArg::cloneTree(const char* newname = 0) const; virtual Int_tRooAbsArg::Compare(const TObject* other) const; virtual voidRooAbsArg::constOptimizeTestStatistic(RooAbsArg::ConstOpCode opcode, Bool_t doAlsoTrackingOpt = kTRUE); virtual voidTNamed::Copy(TObject& named) const; static UInt_tRooAbsArg::crc32(const char* data); static UInt_tRooAbsArg::crc32(const char* data, ULong_t sz, UInt_t crc = 0); RooAbsReal*createCdf(const RooArgSet& iset, const RooArgSet& nset = RooArgSet()); RooAbsReal*createCdf(const RooArgSet& iset, const RooCmdArg& arg1, const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6",MatchSource.WIKI,root/html602/RooAbsPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsPdf.html
https://root.cern/root/html602/RooAbsPdf.html:6672,Usability,clear,clearValueDirty,6672,"rgSet& vars, const RooArgSet* nset = 0, Bool_t clipInvalid = kFALSE) const; voidRooAbsArg::branchNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t recurseNonDerived = kFALSE) const; virtual voidTObject::Browse(TBrowser* b); virtual const char*RooAbsArg::cacheUniqueSuffix() const; Bool_tcanBeExtended() const; virtual RooAbsArg::CacheModeRooAbsArg::canNodeBeCached() const; voidRooAbsArg::changeServer(RooAbsArg& server, Bool_t valueProp, Bool_t shapeProp); Bool_tRooAbsArg::checkDependents(const RooArgSet* nset) const; virtual Bool_tRooAbsArg::checkObservables(const RooArgSet* nset) const; virtual RooFitResult*chi2FitTo(RooDataHist& data, const RooLinkedList& cmdList); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); static voidclearEvalError(); static voidRooAbsReal::clearEvalErrorLog(); voidRooAbsArg::clearShapeDirty() const; voidRooAbsArg::clearValueAndShapeDirty() const; voidRooAbsArg::clearValueDirty() const; TIterator*RooAbsArg::clientIterator() const; virtual TObject*RooAbsArg::clone(const char* newname = 0) const; virtual TObject*RooAbsArg::Clone(const char* newname = 0) const; virtual RooAbsArg*RooAbsArg::cloneTree(const char* newname = 0) const; virtual Int_tRooAbsArg::Compare(const TObject* other) const; virtual voidRooAbsArg::constOptimizeTestStatistic(RooAbsArg::ConstOpCode opcode, Bool_t doAlsoTrackingOpt = kTRUE); virtual voidTNamed::Copy(TObject& named) const; static UInt_tRooAbsArg::crc32(const char* data); static UInt_tRooAbsArg::crc32(const char* data, ULong_t sz, UInt_t crc = 0); RooAbsReal*createCdf(const RooArgSet& iset, const RooArgSet& nset = RooArgSet()); RooAbsReal*createCdf(const RooArgSet& iset, const RooCmdArg& arg1, const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 ",MatchSource.WIKI,root/html602/RooAbsPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsPdf.html
https://root.cern/root/html602/RooAbsPdf.html:59133,Usability,simpl,simplex,59133,"ikelihood using internal constrains in p.d.f; GlobalObservables(const RooArgSet&) -- Define the set of normalization observables to be used for the constraint terms.; If none are specified the constrained parameters are used; ExternalConstraints(const RooArgSet& ) -- Include given external constraints to likelihood; Offset(Bool_t) -- Offset likelihood by initial value (so that starting value of FCN in minuit is zero). This; can improve numeric stability in simultaneously fits with components with large likelihood values. Options to control flow of fit procedure. Minimizer(type,algo) -- Choose minimization package and algorithm to use. Default is MINUIT/MIGRAD through the RooMinimizer; interface, but others can be specified (through RooMinimizer interface). Select OldMinuit to use; MINUIT through the old RooMinuit interface. Type Algorithm; ------ ---------; OldMinuit migrad, simplex, minimize (=migrad+simplex), migradimproved (=migrad+improve); Minuit migrad, simplex, minimize (=migrad+simplex), migradimproved (=migrad+improve); Minuit2 migrad, simplex, minimize, scan; GSLMultiMin conjugatefr, conjugatepr, bfgs, bfgs2, steepestdescent; GSLSimAn -. InitialHesse(Bool_t flag) -- Flag controls if HESSE before MIGRAD as well, off by default; Optimize(Bool_t flag) -- Activate constant term optimization of test statistic during minimization (on by default); Hesse(Bool_t flag) -- Flag controls if HESSE is run after MIGRAD, on by default; Minos(Bool_t flag) -- Flag controls if MINOS is run after HESSE, off by default; Minos(const RooArgSet& set) -- Only run MINOS on given subset of arguments; Save(Bool_t flag) -- Flac controls if RooFitResult object is produced and returned, off by default; Strategy(Int_t flag) -- Set Minuit strategy (0 through 2, default is 1); FitOptions(const char* optStr) -- Steer fit with classic options string (for backward compatibility). Use of this option; excludes use of any of the new style steering options. SumW2Error(Bool_t flag) -- Apply correa",MatchSource.WIKI,root/html602/RooAbsPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsPdf.html
https://root.cern/root/html602/RooAbsPdf.html:59160,Usability,simpl,simplex,59160,"ikelihood using internal constrains in p.d.f; GlobalObservables(const RooArgSet&) -- Define the set of normalization observables to be used for the constraint terms.; If none are specified the constrained parameters are used; ExternalConstraints(const RooArgSet& ) -- Include given external constraints to likelihood; Offset(Bool_t) -- Offset likelihood by initial value (so that starting value of FCN in minuit is zero). This; can improve numeric stability in simultaneously fits with components with large likelihood values. Options to control flow of fit procedure. Minimizer(type,algo) -- Choose minimization package and algorithm to use. Default is MINUIT/MIGRAD through the RooMinimizer; interface, but others can be specified (through RooMinimizer interface). Select OldMinuit to use; MINUIT through the old RooMinuit interface. Type Algorithm; ------ ---------; OldMinuit migrad, simplex, minimize (=migrad+simplex), migradimproved (=migrad+improve); Minuit migrad, simplex, minimize (=migrad+simplex), migradimproved (=migrad+improve); Minuit2 migrad, simplex, minimize, scan; GSLMultiMin conjugatefr, conjugatepr, bfgs, bfgs2, steepestdescent; GSLSimAn -. InitialHesse(Bool_t flag) -- Flag controls if HESSE before MIGRAD as well, off by default; Optimize(Bool_t flag) -- Activate constant term optimization of test statistic during minimization (on by default); Hesse(Bool_t flag) -- Flag controls if HESSE is run after MIGRAD, on by default; Minos(Bool_t flag) -- Flag controls if MINOS is run after HESSE, off by default; Minos(const RooArgSet& set) -- Only run MINOS on given subset of arguments; Save(Bool_t flag) -- Flac controls if RooFitResult object is produced and returned, off by default; Strategy(Int_t flag) -- Set Minuit strategy (0 through 2, default is 1); FitOptions(const char* optStr) -- Steer fit with classic options string (for backward compatibility). Use of this option; excludes use of any of the new style steering options. SumW2Error(Bool_t flag) -- Apply correa",MatchSource.WIKI,root/html602/RooAbsPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsPdf.html
https://root.cern/root/html602/RooAbsPdf.html:59219,Usability,simpl,simplex,59219,"ikelihood using internal constrains in p.d.f; GlobalObservables(const RooArgSet&) -- Define the set of normalization observables to be used for the constraint terms.; If none are specified the constrained parameters are used; ExternalConstraints(const RooArgSet& ) -- Include given external constraints to likelihood; Offset(Bool_t) -- Offset likelihood by initial value (so that starting value of FCN in minuit is zero). This; can improve numeric stability in simultaneously fits with components with large likelihood values. Options to control flow of fit procedure. Minimizer(type,algo) -- Choose minimization package and algorithm to use. Default is MINUIT/MIGRAD through the RooMinimizer; interface, but others can be specified (through RooMinimizer interface). Select OldMinuit to use; MINUIT through the old RooMinuit interface. Type Algorithm; ------ ---------; OldMinuit migrad, simplex, minimize (=migrad+simplex), migradimproved (=migrad+improve); Minuit migrad, simplex, minimize (=migrad+simplex), migradimproved (=migrad+improve); Minuit2 migrad, simplex, minimize, scan; GSLMultiMin conjugatefr, conjugatepr, bfgs, bfgs2, steepestdescent; GSLSimAn -. InitialHesse(Bool_t flag) -- Flag controls if HESSE before MIGRAD as well, off by default; Optimize(Bool_t flag) -- Activate constant term optimization of test statistic during minimization (on by default); Hesse(Bool_t flag) -- Flag controls if HESSE is run after MIGRAD, on by default; Minos(Bool_t flag) -- Flag controls if MINOS is run after HESSE, off by default; Minos(const RooArgSet& set) -- Only run MINOS on given subset of arguments; Save(Bool_t flag) -- Flac controls if RooFitResult object is produced and returned, off by default; Strategy(Int_t flag) -- Set Minuit strategy (0 through 2, default is 1); FitOptions(const char* optStr) -- Steer fit with classic options string (for backward compatibility). Use of this option; excludes use of any of the new style steering options. SumW2Error(Bool_t flag) -- Apply correa",MatchSource.WIKI,root/html602/RooAbsPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsPdf.html
https://root.cern/root/html602/RooAbsPdf.html:59246,Usability,simpl,simplex,59246,"ikelihood using internal constrains in p.d.f; GlobalObservables(const RooArgSet&) -- Define the set of normalization observables to be used for the constraint terms.; If none are specified the constrained parameters are used; ExternalConstraints(const RooArgSet& ) -- Include given external constraints to likelihood; Offset(Bool_t) -- Offset likelihood by initial value (so that starting value of FCN in minuit is zero). This; can improve numeric stability in simultaneously fits with components with large likelihood values. Options to control flow of fit procedure. Minimizer(type,algo) -- Choose minimization package and algorithm to use. Default is MINUIT/MIGRAD through the RooMinimizer; interface, but others can be specified (through RooMinimizer interface). Select OldMinuit to use; MINUIT through the old RooMinuit interface. Type Algorithm; ------ ---------; OldMinuit migrad, simplex, minimize (=migrad+simplex), migradimproved (=migrad+improve); Minuit migrad, simplex, minimize (=migrad+simplex), migradimproved (=migrad+improve); Minuit2 migrad, simplex, minimize, scan; GSLMultiMin conjugatefr, conjugatepr, bfgs, bfgs2, steepestdescent; GSLSimAn -. InitialHesse(Bool_t flag) -- Flag controls if HESSE before MIGRAD as well, off by default; Optimize(Bool_t flag) -- Activate constant term optimization of test statistic during minimization (on by default); Hesse(Bool_t flag) -- Flag controls if HESSE is run after MIGRAD, on by default; Minos(Bool_t flag) -- Flag controls if MINOS is run after HESSE, off by default; Minos(const RooArgSet& set) -- Only run MINOS on given subset of arguments; Save(Bool_t flag) -- Flac controls if RooFitResult object is produced and returned, off by default; Strategy(Int_t flag) -- Set Minuit strategy (0 through 2, default is 1); FitOptions(const char* optStr) -- Steer fit with classic options string (for backward compatibility). Use of this option; excludes use of any of the new style steering options. SumW2Error(Bool_t flag) -- Apply correa",MatchSource.WIKI,root/html602/RooAbsPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsPdf.html
https://root.cern/root/html602/RooAbsPdf.html:59306,Usability,simpl,simplex,59306,"ikelihood using internal constrains in p.d.f; GlobalObservables(const RooArgSet&) -- Define the set of normalization observables to be used for the constraint terms.; If none are specified the constrained parameters are used; ExternalConstraints(const RooArgSet& ) -- Include given external constraints to likelihood; Offset(Bool_t) -- Offset likelihood by initial value (so that starting value of FCN in minuit is zero). This; can improve numeric stability in simultaneously fits with components with large likelihood values. Options to control flow of fit procedure. Minimizer(type,algo) -- Choose minimization package and algorithm to use. Default is MINUIT/MIGRAD through the RooMinimizer; interface, but others can be specified (through RooMinimizer interface). Select OldMinuit to use; MINUIT through the old RooMinuit interface. Type Algorithm; ------ ---------; OldMinuit migrad, simplex, minimize (=migrad+simplex), migradimproved (=migrad+improve); Minuit migrad, simplex, minimize (=migrad+simplex), migradimproved (=migrad+improve); Minuit2 migrad, simplex, minimize, scan; GSLMultiMin conjugatefr, conjugatepr, bfgs, bfgs2, steepestdescent; GSLSimAn -. InitialHesse(Bool_t flag) -- Flag controls if HESSE before MIGRAD as well, off by default; Optimize(Bool_t flag) -- Activate constant term optimization of test statistic during minimization (on by default); Hesse(Bool_t flag) -- Flag controls if HESSE is run after MIGRAD, on by default; Minos(Bool_t flag) -- Flag controls if MINOS is run after HESSE, off by default; Minos(const RooArgSet& set) -- Only run MINOS on given subset of arguments; Save(Bool_t flag) -- Flac controls if RooFitResult object is produced and returned, off by default; Strategy(Int_t flag) -- Set Minuit strategy (0 through 2, default is 1); FitOptions(const char* optStr) -- Steer fit with classic options string (for backward compatibility). Use of this option; excludes use of any of the new style steering options. SumW2Error(Bool_t flag) -- Apply correa",MatchSource.WIKI,root/html602/RooAbsPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsPdf.html
https://root.cern/root/html602/RooAbsPdf.html:87007,Usability,clear,clearEvalError,87007,"unction, the variables; it integrates and the range integrates over. The following named arguments are accepted. SupNormSet(const RooArgSet&) -- Observables over which should be normalized _in_addition_ to the; integration observables; ScanNumCdf() -- Apply scanning technique if cdf integral involves numeric integration [ default ]; ScanAllCdf() -- Always apply scanning technique; ScanNoCdf() -- Never apply scanning technique; ScanParameters(Int_t nbins, -- Parameters for scanning technique of making CDF: number; Int_t intOrder) of sampled bins and order of interpolation applied on numeric cdf. RooAbsReal* createScanCdf(const RooArgSet& iset, const RooArgSet& nset, Int_t numScanBins, Int_t intOrder). RooArgSet* getAllConstraints(const RooArgSet& observables, RooArgSet& constrainedParams, Bool_t stripDisconnected = kTRUE) const; This helper function finds and collects all constraints terms of all coponent p.d.f.s; and returns a RooArgSet with all those terms. void clearEvalError(); Clear the evaluation error flag. Bool_t evalError(); Return the evaluation error flag. void raiseEvalError(); Raise the evaluation error flag. RooNumGenConfig* defaultGeneratorConfig(); Returns the default numeric MC generator configuration for all RooAbsReals. RooNumGenConfig* specialGeneratorConfig() const; Returns the specialized integrator configuration for _this_ RooAbsReal.; If this object has no specialized configuration, a null pointer is returned. RooNumGenConfig* specialGeneratorConfig(Bool_t createOnTheFly); Returns the specialized integrator configuration for _this_ RooAbsReal.; If this object has no specialized configuration, a null pointer is returned,; unless createOnTheFly is kTRUE in which case a clone of the default integrator; configuration is created, installed as specialized configuration, and returned. const RooNumGenConfig* getGeneratorConfig() const; Return the numeric MC generator configuration used for this object. If; a specialized configuration was associated wi",MatchSource.WIKI,root/html602/RooAbsPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsPdf.html
https://root.cern/root/html602/RooAbsPdf__GenSpec.html:469,Availability,error,error,469,". RooAbsPdf::GenSpec. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » ROOFIT; » ROOFITCORE; » RooAbsPdf::GenSpec. class RooAbsPdf::GenSpec. RooAbsPdf is the abstract interface for all probability density; functions The class provides hybrid analytical/numerical; normalization for its implementations, error tracing and a MC; generator interface. A minimal implementation of a PDF class derived from RooAbsPdf; should overload the evaluate() function. This functions should; return PDFs value. [Normalization/Integration]. Although the normalization of a PDF is an integral part of a; probability density function, normalization is treated separately; in RooAbsPdf. The reason is that a RooAbsPdf object is more than a; PDF: it can be a building block for a more complex, composite PDF; if any of its variables are functions instead of variables. In; such cases the normalization of the composite may not be simply the; integral over the dependents of the top level PDF as these are; functions with potentially non-trivial Jacobian terms themselves.; Therefore. --> No explicit attempt should be made to normalize; the functions output in evaluate(). In addition, RooAbsPdf objects do not have a static concept of what; variables are parameters and what variables are dependents (which; need to be integrated over for a correct PDF normalization).; Instead the choice of normalization is always specified each time a; normalized values is requested from the PDF via the getVal(); method. RooAbsPdf manages the entire normalization logic of each PDF with; help of a RooRealIntegral object, which coordinates the integration; of a given choice of normalization. By default, RooRealIntegral will; perform a fully numeric integration of all dependents. However,; PDFs can advertise one or more (partial) analytical integrals of; their fun",MatchSource.WIKI,root/html602/RooAbsPdf__GenSpec.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsPdf__GenSpec.html
https://root.cern/root/html602/RooAbsPdf__GenSpec.html:1465,Deployability,integrat,integrated,1465,"cal/numerical; normalization for its implementations, error tracing and a MC; generator interface. A minimal implementation of a PDF class derived from RooAbsPdf; should overload the evaluate() function. This functions should; return PDFs value. [Normalization/Integration]. Although the normalization of a PDF is an integral part of a; probability density function, normalization is treated separately; in RooAbsPdf. The reason is that a RooAbsPdf object is more than a; PDF: it can be a building block for a more complex, composite PDF; if any of its variables are functions instead of variables. In; such cases the normalization of the composite may not be simply the; integral over the dependents of the top level PDF as these are; functions with potentially non-trivial Jacobian terms themselves.; Therefore. --> No explicit attempt should be made to normalize; the functions output in evaluate(). In addition, RooAbsPdf objects do not have a static concept of what; variables are parameters and what variables are dependents (which; need to be integrated over for a correct PDF normalization).; Instead the choice of normalization is always specified each time a; normalized values is requested from the PDF via the getVal(); method. RooAbsPdf manages the entire normalization logic of each PDF with; help of a RooRealIntegral object, which coordinates the integration; of a given choice of normalization. By default, RooRealIntegral will; perform a fully numeric integration of all dependents. However,; PDFs can advertise one or more (partial) analytical integrals of; their function, and these will be used by RooRealIntegral, if it; determines that this is safe (i.e. no hidden Jacobian terms,; multiplication with other PDFs that have one or more dependents in; commen etc). To implement analytical integrals, two functions must be implemented. First,. Int_t getAnalyticalIntegral(const RooArgSet& integSet, RooArgSet& anaIntSet). advertises the analytical integrals that are supported. 'in",MatchSource.WIKI,root/html602/RooAbsPdf__GenSpec.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsPdf__GenSpec.html
https://root.cern/root/html602/RooAbsPdf__GenSpec.html:1778,Deployability,integrat,integration,1778," part of a; probability density function, normalization is treated separately; in RooAbsPdf. The reason is that a RooAbsPdf object is more than a; PDF: it can be a building block for a more complex, composite PDF; if any of its variables are functions instead of variables. In; such cases the normalization of the composite may not be simply the; integral over the dependents of the top level PDF as these are; functions with potentially non-trivial Jacobian terms themselves.; Therefore. --> No explicit attempt should be made to normalize; the functions output in evaluate(). In addition, RooAbsPdf objects do not have a static concept of what; variables are parameters and what variables are dependents (which; need to be integrated over for a correct PDF normalization).; Instead the choice of normalization is always specified each time a; normalized values is requested from the PDF via the getVal(); method. RooAbsPdf manages the entire normalization logic of each PDF with; help of a RooRealIntegral object, which coordinates the integration; of a given choice of normalization. By default, RooRealIntegral will; perform a fully numeric integration of all dependents. However,; PDFs can advertise one or more (partial) analytical integrals of; their function, and these will be used by RooRealIntegral, if it; determines that this is safe (i.e. no hidden Jacobian terms,; multiplication with other PDFs that have one or more dependents in; commen etc). To implement analytical integrals, two functions must be implemented. First,. Int_t getAnalyticalIntegral(const RooArgSet& integSet, RooArgSet& anaIntSet). advertises the analytical integrals that are supported. 'integSet'; is the set of dependents for which integration is requested. The; function should copy the subset of dependents it can analytically; integrate to anaIntSet and return a unique identification code for; this integration configuration. If no integration can be; performed, zero should be returned. Second,. Double_t an",MatchSource.WIKI,root/html602/RooAbsPdf__GenSpec.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsPdf__GenSpec.html
https://root.cern/root/html602/RooAbsPdf__GenSpec.html:1885,Deployability,integrat,integration,1885," is more than a; PDF: it can be a building block for a more complex, composite PDF; if any of its variables are functions instead of variables. In; such cases the normalization of the composite may not be simply the; integral over the dependents of the top level PDF as these are; functions with potentially non-trivial Jacobian terms themselves.; Therefore. --> No explicit attempt should be made to normalize; the functions output in evaluate(). In addition, RooAbsPdf objects do not have a static concept of what; variables are parameters and what variables are dependents (which; need to be integrated over for a correct PDF normalization).; Instead the choice of normalization is always specified each time a; normalized values is requested from the PDF via the getVal(); method. RooAbsPdf manages the entire normalization logic of each PDF with; help of a RooRealIntegral object, which coordinates the integration; of a given choice of normalization. By default, RooRealIntegral will; perform a fully numeric integration of all dependents. However,; PDFs can advertise one or more (partial) analytical integrals of; their function, and these will be used by RooRealIntegral, if it; determines that this is safe (i.e. no hidden Jacobian terms,; multiplication with other PDFs that have one or more dependents in; commen etc). To implement analytical integrals, two functions must be implemented. First,. Int_t getAnalyticalIntegral(const RooArgSet& integSet, RooArgSet& anaIntSet). advertises the analytical integrals that are supported. 'integSet'; is the set of dependents for which integration is requested. The; function should copy the subset of dependents it can analytically; integrate to anaIntSet and return a unique identification code for; this integration configuration. If no integration can be; performed, zero should be returned. Second,. Double_t analyticalIntegral(Int_t code). Implements the actual analytical integral(s) advertised by; getAnalyticalIntegral. This functions wil",MatchSource.WIKI,root/html602/RooAbsPdf__GenSpec.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsPdf__GenSpec.html
https://root.cern/root/html602/RooAbsPdf__GenSpec.html:2460,Deployability,integrat,integration,2460,"hich; need to be integrated over for a correct PDF normalization).; Instead the choice of normalization is always specified each time a; normalized values is requested from the PDF via the getVal(); method. RooAbsPdf manages the entire normalization logic of each PDF with; help of a RooRealIntegral object, which coordinates the integration; of a given choice of normalization. By default, RooRealIntegral will; perform a fully numeric integration of all dependents. However,; PDFs can advertise one or more (partial) analytical integrals of; their function, and these will be used by RooRealIntegral, if it; determines that this is safe (i.e. no hidden Jacobian terms,; multiplication with other PDFs that have one or more dependents in; commen etc). To implement analytical integrals, two functions must be implemented. First,. Int_t getAnalyticalIntegral(const RooArgSet& integSet, RooArgSet& anaIntSet). advertises the analytical integrals that are supported. 'integSet'; is the set of dependents for which integration is requested. The; function should copy the subset of dependents it can analytically; integrate to anaIntSet and return a unique identification code for; this integration configuration. If no integration can be; performed, zero should be returned. Second,. Double_t analyticalIntegral(Int_t code). Implements the actual analytical integral(s) advertised by; getAnalyticalIntegral. This functions will only be called with; codes returned by getAnalyticalIntegral, except code zero. The integration range for real each dependent to be integrated can; be obtained from the dependents' proxy functions min() and; max(). Never call these proxy functions for any proxy not known to; be a dependent via the integration code. Doing so may be; ill-defined, e.g. in case the proxy holds a function, and will; trigger an assert. Integrated category dependents should always be; summed over all of their states. [Direct generation of observables]. Any PDF dependent can be generated with t",MatchSource.WIKI,root/html602/RooAbsPdf__GenSpec.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsPdf__GenSpec.html
https://root.cern/root/html602/RooAbsPdf__GenSpec.html:2558,Deployability,integrat,integrate,2558," each time a; normalized values is requested from the PDF via the getVal(); method. RooAbsPdf manages the entire normalization logic of each PDF with; help of a RooRealIntegral object, which coordinates the integration; of a given choice of normalization. By default, RooRealIntegral will; perform a fully numeric integration of all dependents. However,; PDFs can advertise one or more (partial) analytical integrals of; their function, and these will be used by RooRealIntegral, if it; determines that this is safe (i.e. no hidden Jacobian terms,; multiplication with other PDFs that have one or more dependents in; commen etc). To implement analytical integrals, two functions must be implemented. First,. Int_t getAnalyticalIntegral(const RooArgSet& integSet, RooArgSet& anaIntSet). advertises the analytical integrals that are supported. 'integSet'; is the set of dependents for which integration is requested. The; function should copy the subset of dependents it can analytically; integrate to anaIntSet and return a unique identification code for; this integration configuration. If no integration can be; performed, zero should be returned. Second,. Double_t analyticalIntegral(Int_t code). Implements the actual analytical integral(s) advertised by; getAnalyticalIntegral. This functions will only be called with; codes returned by getAnalyticalIntegral, except code zero. The integration range for real each dependent to be integrated can; be obtained from the dependents' proxy functions min() and; max(). Never call these proxy functions for any proxy not known to; be a dependent via the integration code. Doing so may be; ill-defined, e.g. in case the proxy holds a function, and will; trigger an assert. Integrated category dependents should always be; summed over all of their states. [Direct generation of observables]. Any PDF dependent can be generated with the accept/reject method,; but for certain PDFs more efficient methods may be implemented. To; implement direct generation ",MatchSource.WIKI,root/html602/RooAbsPdf__GenSpec.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsPdf__GenSpec.html
https://root.cern/root/html602/RooAbsPdf__GenSpec.html:2631,Deployability,integrat,integration,2631," each time a; normalized values is requested from the PDF via the getVal(); method. RooAbsPdf manages the entire normalization logic of each PDF with; help of a RooRealIntegral object, which coordinates the integration; of a given choice of normalization. By default, RooRealIntegral will; perform a fully numeric integration of all dependents. However,; PDFs can advertise one or more (partial) analytical integrals of; their function, and these will be used by RooRealIntegral, if it; determines that this is safe (i.e. no hidden Jacobian terms,; multiplication with other PDFs that have one or more dependents in; commen etc). To implement analytical integrals, two functions must be implemented. First,. Int_t getAnalyticalIntegral(const RooArgSet& integSet, RooArgSet& anaIntSet). advertises the analytical integrals that are supported. 'integSet'; is the set of dependents for which integration is requested. The; function should copy the subset of dependents it can analytically; integrate to anaIntSet and return a unique identification code for; this integration configuration. If no integration can be; performed, zero should be returned. Second,. Double_t analyticalIntegral(Int_t code). Implements the actual analytical integral(s) advertised by; getAnalyticalIntegral. This functions will only be called with; codes returned by getAnalyticalIntegral, except code zero. The integration range for real each dependent to be integrated can; be obtained from the dependents' proxy functions min() and; max(). Never call these proxy functions for any proxy not known to; be a dependent via the integration code. Doing so may be; ill-defined, e.g. in case the proxy holds a function, and will; trigger an assert. Integrated category dependents should always be; summed over all of their states. [Direct generation of observables]. Any PDF dependent can be generated with the accept/reject method,; but for certain PDFs more efficient methods may be implemented. To; implement direct generation ",MatchSource.WIKI,root/html602/RooAbsPdf__GenSpec.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsPdf__GenSpec.html
https://root.cern/root/html602/RooAbsPdf__GenSpec.html:2643,Deployability,configurat,configuration,2643," each time a; normalized values is requested from the PDF via the getVal(); method. RooAbsPdf manages the entire normalization logic of each PDF with; help of a RooRealIntegral object, which coordinates the integration; of a given choice of normalization. By default, RooRealIntegral will; perform a fully numeric integration of all dependents. However,; PDFs can advertise one or more (partial) analytical integrals of; their function, and these will be used by RooRealIntegral, if it; determines that this is safe (i.e. no hidden Jacobian terms,; multiplication with other PDFs that have one or more dependents in; commen etc). To implement analytical integrals, two functions must be implemented. First,. Int_t getAnalyticalIntegral(const RooArgSet& integSet, RooArgSet& anaIntSet). advertises the analytical integrals that are supported. 'integSet'; is the set of dependents for which integration is requested. The; function should copy the subset of dependents it can analytically; integrate to anaIntSet and return a unique identification code for; this integration configuration. If no integration can be; performed, zero should be returned. Second,. Double_t analyticalIntegral(Int_t code). Implements the actual analytical integral(s) advertised by; getAnalyticalIntegral. This functions will only be called with; codes returned by getAnalyticalIntegral, except code zero. The integration range for real each dependent to be integrated can; be obtained from the dependents' proxy functions min() and; max(). Never call these proxy functions for any proxy not known to; be a dependent via the integration code. Doing so may be; ill-defined, e.g. in case the proxy holds a function, and will; trigger an assert. Integrated category dependents should always be; summed over all of their states. [Direct generation of observables]. Any PDF dependent can be generated with the accept/reject method,; but for certain PDFs more efficient methods may be implemented. To; implement direct generation ",MatchSource.WIKI,root/html602/RooAbsPdf__GenSpec.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsPdf__GenSpec.html
https://root.cern/root/html602/RooAbsPdf__GenSpec.html:2664,Deployability,integrat,integration,2664,"alization logic of each PDF with; help of a RooRealIntegral object, which coordinates the integration; of a given choice of normalization. By default, RooRealIntegral will; perform a fully numeric integration of all dependents. However,; PDFs can advertise one or more (partial) analytical integrals of; their function, and these will be used by RooRealIntegral, if it; determines that this is safe (i.e. no hidden Jacobian terms,; multiplication with other PDFs that have one or more dependents in; commen etc). To implement analytical integrals, two functions must be implemented. First,. Int_t getAnalyticalIntegral(const RooArgSet& integSet, RooArgSet& anaIntSet). advertises the analytical integrals that are supported. 'integSet'; is the set of dependents for which integration is requested. The; function should copy the subset of dependents it can analytically; integrate to anaIntSet and return a unique identification code for; this integration configuration. If no integration can be; performed, zero should be returned. Second,. Double_t analyticalIntegral(Int_t code). Implements the actual analytical integral(s) advertised by; getAnalyticalIntegral. This functions will only be called with; codes returned by getAnalyticalIntegral, except code zero. The integration range for real each dependent to be integrated can; be obtained from the dependents' proxy functions min() and; max(). Never call these proxy functions for any proxy not known to; be a dependent via the integration code. Doing so may be; ill-defined, e.g. in case the proxy holds a function, and will; trigger an assert. Integrated category dependents should always be; summed over all of their states. [Direct generation of observables]. Any PDF dependent can be generated with the accept/reject method,; but for certain PDFs more efficient methods may be implemented. To; implement direct generation of one or more observables, two; functions need to be implemented, similar to those for analytical; integrals:. Int_t",MatchSource.WIKI,root/html602/RooAbsPdf__GenSpec.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsPdf__GenSpec.html
https://root.cern/root/html602/RooAbsPdf__GenSpec.html:2957,Deployability,integrat,integration,2957,"ill be used by RooRealIntegral, if it; determines that this is safe (i.e. no hidden Jacobian terms,; multiplication with other PDFs that have one or more dependents in; commen etc). To implement analytical integrals, two functions must be implemented. First,. Int_t getAnalyticalIntegral(const RooArgSet& integSet, RooArgSet& anaIntSet). advertises the analytical integrals that are supported. 'integSet'; is the set of dependents for which integration is requested. The; function should copy the subset of dependents it can analytically; integrate to anaIntSet and return a unique identification code for; this integration configuration. If no integration can be; performed, zero should be returned. Second,. Double_t analyticalIntegral(Int_t code). Implements the actual analytical integral(s) advertised by; getAnalyticalIntegral. This functions will only be called with; codes returned by getAnalyticalIntegral, except code zero. The integration range for real each dependent to be integrated can; be obtained from the dependents' proxy functions min() and; max(). Never call these proxy functions for any proxy not known to; be a dependent via the integration code. Doing so may be; ill-defined, e.g. in case the proxy holds a function, and will; trigger an assert. Integrated category dependents should always be; summed over all of their states. [Direct generation of observables]. Any PDF dependent can be generated with the accept/reject method,; but for certain PDFs more efficient methods may be implemented. To; implement direct generation of one or more observables, two; functions need to be implemented, similar to those for analytical; integrals:. Int_t getGenerator(const RooArgSet& generateVars, RooArgSet& directVars) and; void generateEvent(Int_t code). The first function advertises observables that can be generated,; similar to the way analytical integrals are advertised. The second; function implements the generator for the advertised observables. The generated dependent val",MatchSource.WIKI,root/html602/RooAbsPdf__GenSpec.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsPdf__GenSpec.html
https://root.cern/root/html602/RooAbsPdf__GenSpec.html:3005,Deployability,integrat,integrated,3005,"ill be used by RooRealIntegral, if it; determines that this is safe (i.e. no hidden Jacobian terms,; multiplication with other PDFs that have one or more dependents in; commen etc). To implement analytical integrals, two functions must be implemented. First,. Int_t getAnalyticalIntegral(const RooArgSet& integSet, RooArgSet& anaIntSet). advertises the analytical integrals that are supported. 'integSet'; is the set of dependents for which integration is requested. The; function should copy the subset of dependents it can analytically; integrate to anaIntSet and return a unique identification code for; this integration configuration. If no integration can be; performed, zero should be returned. Second,. Double_t analyticalIntegral(Int_t code). Implements the actual analytical integral(s) advertised by; getAnalyticalIntegral. This functions will only be called with; codes returned by getAnalyticalIntegral, except code zero. The integration range for real each dependent to be integrated can; be obtained from the dependents' proxy functions min() and; max(). Never call these proxy functions for any proxy not known to; be a dependent via the integration code. Doing so may be; ill-defined, e.g. in case the proxy holds a function, and will; trigger an assert. Integrated category dependents should always be; summed over all of their states. [Direct generation of observables]. Any PDF dependent can be generated with the accept/reject method,; but for certain PDFs more efficient methods may be implemented. To; implement direct generation of one or more observables, two; functions need to be implemented, similar to those for analytical; integrals:. Int_t getGenerator(const RooArgSet& generateVars, RooArgSet& directVars) and; void generateEvent(Int_t code). The first function advertises observables that can be generated,; similar to the way analytical integrals are advertised. The second; function implements the generator for the advertised observables. The generated dependent val",MatchSource.WIKI,root/html602/RooAbsPdf__GenSpec.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsPdf__GenSpec.html
https://root.cern/root/html602/RooAbsPdf__GenSpec.html:3172,Deployability,integrat,integration,3172,"h other PDFs that have one or more dependents in; commen etc). To implement analytical integrals, two functions must be implemented. First,. Int_t getAnalyticalIntegral(const RooArgSet& integSet, RooArgSet& anaIntSet). advertises the analytical integrals that are supported. 'integSet'; is the set of dependents for which integration is requested. The; function should copy the subset of dependents it can analytically; integrate to anaIntSet and return a unique identification code for; this integration configuration. If no integration can be; performed, zero should be returned. Second,. Double_t analyticalIntegral(Int_t code). Implements the actual analytical integral(s) advertised by; getAnalyticalIntegral. This functions will only be called with; codes returned by getAnalyticalIntegral, except code zero. The integration range for real each dependent to be integrated can; be obtained from the dependents' proxy functions min() and; max(). Never call these proxy functions for any proxy not known to; be a dependent via the integration code. Doing so may be; ill-defined, e.g. in case the proxy holds a function, and will; trigger an assert. Integrated category dependents should always be; summed over all of their states. [Direct generation of observables]. Any PDF dependent can be generated with the accept/reject method,; but for certain PDFs more efficient methods may be implemented. To; implement direct generation of one or more observables, two; functions need to be implemented, similar to those for analytical; integrals:. Int_t getGenerator(const RooArgSet& generateVars, RooArgSet& directVars) and; void generateEvent(Int_t code). The first function advertises observables that can be generated,; similar to the way analytical integrals are advertised. The second; function implements the generator for the advertised observables. The generated dependent values should be store in the proxy; objects. For this the assignment operator can be used (i.e. xProxy; = 3.0 ). Never c",MatchSource.WIKI,root/html602/RooAbsPdf__GenSpec.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsPdf__GenSpec.html
https://root.cern/root/html602/RooAbsPdf__GenSpec.html:3501,Energy Efficiency,efficient,efficient,3501,"is requested. The; function should copy the subset of dependents it can analytically; integrate to anaIntSet and return a unique identification code for; this integration configuration. If no integration can be; performed, zero should be returned. Second,. Double_t analyticalIntegral(Int_t code). Implements the actual analytical integral(s) advertised by; getAnalyticalIntegral. This functions will only be called with; codes returned by getAnalyticalIntegral, except code zero. The integration range for real each dependent to be integrated can; be obtained from the dependents' proxy functions min() and; max(). Never call these proxy functions for any proxy not known to; be a dependent via the integration code. Doing so may be; ill-defined, e.g. in case the proxy holds a function, and will; trigger an assert. Integrated category dependents should always be; summed over all of their states. [Direct generation of observables]. Any PDF dependent can be generated with the accept/reject method,; but for certain PDFs more efficient methods may be implemented. To; implement direct generation of one or more observables, two; functions need to be implemented, similar to those for analytical; integrals:. Int_t getGenerator(const RooArgSet& generateVars, RooArgSet& directVars) and; void generateEvent(Int_t code). The first function advertises observables that can be generated,; similar to the way analytical integrals are advertised. The second; function implements the generator for the advertised observables. The generated dependent values should be store in the proxy; objects. For this the assignment operator can be used (i.e. xProxy; = 3.0 ). Never call assign to any proxy not known to be a dependent; via the generation code. Doing so may be ill-defined, e.g. in case; the proxy holds a function, and will trigger an assert. Function Members (Methods); public:. virtual~GenSpec(); static TClass*Class(); RooAbsPdf::GenSpecGenSpec(); virtual TClass*IsA() const; RooAbsPdf::GenSpec&ope",MatchSource.WIKI,root/html602/RooAbsPdf__GenSpec.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsPdf__GenSpec.html
https://root.cern/root/html602/RooAbsPdf__GenSpec.html:333,Integrability,interface,interface,333,". RooAbsPdf::GenSpec. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » ROOFIT; » ROOFITCORE; » RooAbsPdf::GenSpec. class RooAbsPdf::GenSpec. RooAbsPdf is the abstract interface for all probability density; functions The class provides hybrid analytical/numerical; normalization for its implementations, error tracing and a MC; generator interface. A minimal implementation of a PDF class derived from RooAbsPdf; should overload the evaluate() function. This functions should; return PDFs value. [Normalization/Integration]. Although the normalization of a PDF is an integral part of a; probability density function, normalization is treated separately; in RooAbsPdf. The reason is that a RooAbsPdf object is more than a; PDF: it can be a building block for a more complex, composite PDF; if any of its variables are functions instead of variables. In; such cases the normalization of the composite may not be simply the; integral over the dependents of the top level PDF as these are; functions with potentially non-trivial Jacobian terms themselves.; Therefore. --> No explicit attempt should be made to normalize; the functions output in evaluate(). In addition, RooAbsPdf objects do not have a static concept of what; variables are parameters and what variables are dependents (which; need to be integrated over for a correct PDF normalization).; Instead the choice of normalization is always specified each time a; normalized values is requested from the PDF via the getVal(); method. RooAbsPdf manages the entire normalization logic of each PDF with; help of a RooRealIntegral object, which coordinates the integration; of a given choice of normalization. By default, RooRealIntegral will; perform a fully numeric integration of all dependents. However,; PDFs can advertise one or more (partial) analytical integrals of; their fun",MatchSource.WIKI,root/html602/RooAbsPdf__GenSpec.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsPdf__GenSpec.html
https://root.cern/root/html602/RooAbsPdf__GenSpec.html:503,Integrability,interface,interface,503,". RooAbsPdf::GenSpec. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » ROOFIT; » ROOFITCORE; » RooAbsPdf::GenSpec. class RooAbsPdf::GenSpec. RooAbsPdf is the abstract interface for all probability density; functions The class provides hybrid analytical/numerical; normalization for its implementations, error tracing and a MC; generator interface. A minimal implementation of a PDF class derived from RooAbsPdf; should overload the evaluate() function. This functions should; return PDFs value. [Normalization/Integration]. Although the normalization of a PDF is an integral part of a; probability density function, normalization is treated separately; in RooAbsPdf. The reason is that a RooAbsPdf object is more than a; PDF: it can be a building block for a more complex, composite PDF; if any of its variables are functions instead of variables. In; such cases the normalization of the composite may not be simply the; integral over the dependents of the top level PDF as these are; functions with potentially non-trivial Jacobian terms themselves.; Therefore. --> No explicit attempt should be made to normalize; the functions output in evaluate(). In addition, RooAbsPdf objects do not have a static concept of what; variables are parameters and what variables are dependents (which; need to be integrated over for a correct PDF normalization).; Instead the choice of normalization is always specified each time a; normalized values is requested from the PDF via the getVal(); method. RooAbsPdf manages the entire normalization logic of each PDF with; help of a RooRealIntegral object, which coordinates the integration; of a given choice of normalization. By default, RooRealIntegral will; perform a fully numeric integration of all dependents. However,; PDFs can advertise one or more (partial) analytical integrals of; their fun",MatchSource.WIKI,root/html602/RooAbsPdf__GenSpec.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsPdf__GenSpec.html
https://root.cern/root/html602/RooAbsPdf__GenSpec.html:1105,Integrability,depend,dependents,1105,"rce file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » ROOFIT; » ROOFITCORE; » RooAbsPdf::GenSpec. class RooAbsPdf::GenSpec. RooAbsPdf is the abstract interface for all probability density; functions The class provides hybrid analytical/numerical; normalization for its implementations, error tracing and a MC; generator interface. A minimal implementation of a PDF class derived from RooAbsPdf; should overload the evaluate() function. This functions should; return PDFs value. [Normalization/Integration]. Although the normalization of a PDF is an integral part of a; probability density function, normalization is treated separately; in RooAbsPdf. The reason is that a RooAbsPdf object is more than a; PDF: it can be a building block for a more complex, composite PDF; if any of its variables are functions instead of variables. In; such cases the normalization of the composite may not be simply the; integral over the dependents of the top level PDF as these are; functions with potentially non-trivial Jacobian terms themselves.; Therefore. --> No explicit attempt should be made to normalize; the functions output in evaluate(). In addition, RooAbsPdf objects do not have a static concept of what; variables are parameters and what variables are dependents (which; need to be integrated over for a correct PDF normalization).; Instead the choice of normalization is always specified each time a; normalized values is requested from the PDF via the getVal(); method. RooAbsPdf manages the entire normalization logic of each PDF with; help of a RooRealIntegral object, which coordinates the integration; of a given choice of normalization. By default, RooRealIntegral will; perform a fully numeric integration of all dependents. However,; PDFs can advertise one or more (partial) analytical integrals of; their function, and these will be used by RooRealIntegral, if it; determines that this is safe (i.e. no hidden Jacobian ter",MatchSource.WIKI,root/html602/RooAbsPdf__GenSpec.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsPdf__GenSpec.html
https://root.cern/root/html602/RooAbsPdf__GenSpec.html:1435,Integrability,depend,dependents,1435,"cal/numerical; normalization for its implementations, error tracing and a MC; generator interface. A minimal implementation of a PDF class derived from RooAbsPdf; should overload the evaluate() function. This functions should; return PDFs value. [Normalization/Integration]. Although the normalization of a PDF is an integral part of a; probability density function, normalization is treated separately; in RooAbsPdf. The reason is that a RooAbsPdf object is more than a; PDF: it can be a building block for a more complex, composite PDF; if any of its variables are functions instead of variables. In; such cases the normalization of the composite may not be simply the; integral over the dependents of the top level PDF as these are; functions with potentially non-trivial Jacobian terms themselves.; Therefore. --> No explicit attempt should be made to normalize; the functions output in evaluate(). In addition, RooAbsPdf objects do not have a static concept of what; variables are parameters and what variables are dependents (which; need to be integrated over for a correct PDF normalization).; Instead the choice of normalization is always specified each time a; normalized values is requested from the PDF via the getVal(); method. RooAbsPdf manages the entire normalization logic of each PDF with; help of a RooRealIntegral object, which coordinates the integration; of a given choice of normalization. By default, RooRealIntegral will; perform a fully numeric integration of all dependents. However,; PDFs can advertise one or more (partial) analytical integrals of; their function, and these will be used by RooRealIntegral, if it; determines that this is safe (i.e. no hidden Jacobian terms,; multiplication with other PDFs that have one or more dependents in; commen etc). To implement analytical integrals, two functions must be implemented. First,. Int_t getAnalyticalIntegral(const RooArgSet& integSet, RooArgSet& anaIntSet). advertises the analytical integrals that are supported. 'in",MatchSource.WIKI,root/html602/RooAbsPdf__GenSpec.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsPdf__GenSpec.html
https://root.cern/root/html602/RooAbsPdf__GenSpec.html:1465,Integrability,integrat,integrated,1465,"cal/numerical; normalization for its implementations, error tracing and a MC; generator interface. A minimal implementation of a PDF class derived from RooAbsPdf; should overload the evaluate() function. This functions should; return PDFs value. [Normalization/Integration]. Although the normalization of a PDF is an integral part of a; probability density function, normalization is treated separately; in RooAbsPdf. The reason is that a RooAbsPdf object is more than a; PDF: it can be a building block for a more complex, composite PDF; if any of its variables are functions instead of variables. In; such cases the normalization of the composite may not be simply the; integral over the dependents of the top level PDF as these are; functions with potentially non-trivial Jacobian terms themselves.; Therefore. --> No explicit attempt should be made to normalize; the functions output in evaluate(). In addition, RooAbsPdf objects do not have a static concept of what; variables are parameters and what variables are dependents (which; need to be integrated over for a correct PDF normalization).; Instead the choice of normalization is always specified each time a; normalized values is requested from the PDF via the getVal(); method. RooAbsPdf manages the entire normalization logic of each PDF with; help of a RooRealIntegral object, which coordinates the integration; of a given choice of normalization. By default, RooRealIntegral will; perform a fully numeric integration of all dependents. However,; PDFs can advertise one or more (partial) analytical integrals of; their function, and these will be used by RooRealIntegral, if it; determines that this is safe (i.e. no hidden Jacobian terms,; multiplication with other PDFs that have one or more dependents in; commen etc). To implement analytical integrals, two functions must be implemented. First,. Int_t getAnalyticalIntegral(const RooArgSet& integSet, RooArgSet& anaIntSet). advertises the analytical integrals that are supported. 'in",MatchSource.WIKI,root/html602/RooAbsPdf__GenSpec.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsPdf__GenSpec.html
https://root.cern/root/html602/RooAbsPdf__GenSpec.html:1778,Integrability,integrat,integration,1778," part of a; probability density function, normalization is treated separately; in RooAbsPdf. The reason is that a RooAbsPdf object is more than a; PDF: it can be a building block for a more complex, composite PDF; if any of its variables are functions instead of variables. In; such cases the normalization of the composite may not be simply the; integral over the dependents of the top level PDF as these are; functions with potentially non-trivial Jacobian terms themselves.; Therefore. --> No explicit attempt should be made to normalize; the functions output in evaluate(). In addition, RooAbsPdf objects do not have a static concept of what; variables are parameters and what variables are dependents (which; need to be integrated over for a correct PDF normalization).; Instead the choice of normalization is always specified each time a; normalized values is requested from the PDF via the getVal(); method. RooAbsPdf manages the entire normalization logic of each PDF with; help of a RooRealIntegral object, which coordinates the integration; of a given choice of normalization. By default, RooRealIntegral will; perform a fully numeric integration of all dependents. However,; PDFs can advertise one or more (partial) analytical integrals of; their function, and these will be used by RooRealIntegral, if it; determines that this is safe (i.e. no hidden Jacobian terms,; multiplication with other PDFs that have one or more dependents in; commen etc). To implement analytical integrals, two functions must be implemented. First,. Int_t getAnalyticalIntegral(const RooArgSet& integSet, RooArgSet& anaIntSet). advertises the analytical integrals that are supported. 'integSet'; is the set of dependents for which integration is requested. The; function should copy the subset of dependents it can analytically; integrate to anaIntSet and return a unique identification code for; this integration configuration. If no integration can be; performed, zero should be returned. Second,. Double_t an",MatchSource.WIKI,root/html602/RooAbsPdf__GenSpec.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsPdf__GenSpec.html
https://root.cern/root/html602/RooAbsPdf__GenSpec.html:1885,Integrability,integrat,integration,1885," is more than a; PDF: it can be a building block for a more complex, composite PDF; if any of its variables are functions instead of variables. In; such cases the normalization of the composite may not be simply the; integral over the dependents of the top level PDF as these are; functions with potentially non-trivial Jacobian terms themselves.; Therefore. --> No explicit attempt should be made to normalize; the functions output in evaluate(). In addition, RooAbsPdf objects do not have a static concept of what; variables are parameters and what variables are dependents (which; need to be integrated over for a correct PDF normalization).; Instead the choice of normalization is always specified each time a; normalized values is requested from the PDF via the getVal(); method. RooAbsPdf manages the entire normalization logic of each PDF with; help of a RooRealIntegral object, which coordinates the integration; of a given choice of normalization. By default, RooRealIntegral will; perform a fully numeric integration of all dependents. However,; PDFs can advertise one or more (partial) analytical integrals of; their function, and these will be used by RooRealIntegral, if it; determines that this is safe (i.e. no hidden Jacobian terms,; multiplication with other PDFs that have one or more dependents in; commen etc). To implement analytical integrals, two functions must be implemented. First,. Int_t getAnalyticalIntegral(const RooArgSet& integSet, RooArgSet& anaIntSet). advertises the analytical integrals that are supported. 'integSet'; is the set of dependents for which integration is requested. The; function should copy the subset of dependents it can analytically; integrate to anaIntSet and return a unique identification code for; this integration configuration. If no integration can be; performed, zero should be returned. Second,. Double_t analyticalIntegral(Int_t code). Implements the actual analytical integral(s) advertised by; getAnalyticalIntegral. This functions wil",MatchSource.WIKI,root/html602/RooAbsPdf__GenSpec.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsPdf__GenSpec.html
https://root.cern/root/html602/RooAbsPdf__GenSpec.html:1904,Integrability,depend,dependents,1904," is more than a; PDF: it can be a building block for a more complex, composite PDF; if any of its variables are functions instead of variables. In; such cases the normalization of the composite may not be simply the; integral over the dependents of the top level PDF as these are; functions with potentially non-trivial Jacobian terms themselves.; Therefore. --> No explicit attempt should be made to normalize; the functions output in evaluate(). In addition, RooAbsPdf objects do not have a static concept of what; variables are parameters and what variables are dependents (which; need to be integrated over for a correct PDF normalization).; Instead the choice of normalization is always specified each time a; normalized values is requested from the PDF via the getVal(); method. RooAbsPdf manages the entire normalization logic of each PDF with; help of a RooRealIntegral object, which coordinates the integration; of a given choice of normalization. By default, RooRealIntegral will; perform a fully numeric integration of all dependents. However,; PDFs can advertise one or more (partial) analytical integrals of; their function, and these will be used by RooRealIntegral, if it; determines that this is safe (i.e. no hidden Jacobian terms,; multiplication with other PDFs that have one or more dependents in; commen etc). To implement analytical integrals, two functions must be implemented. First,. Int_t getAnalyticalIntegral(const RooArgSet& integSet, RooArgSet& anaIntSet). advertises the analytical integrals that are supported. 'integSet'; is the set of dependents for which integration is requested. The; function should copy the subset of dependents it can analytically; integrate to anaIntSet and return a unique identification code for; this integration configuration. If no integration can be; performed, zero should be returned. Second,. Double_t analyticalIntegral(Int_t code). Implements the actual analytical integral(s) advertised by; getAnalyticalIntegral. This functions wil",MatchSource.WIKI,root/html602/RooAbsPdf__GenSpec.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsPdf__GenSpec.html
https://root.cern/root/html602/RooAbsPdf__GenSpec.html:2173,Integrability,depend,dependents,2173,"are; functions with potentially non-trivial Jacobian terms themselves.; Therefore. --> No explicit attempt should be made to normalize; the functions output in evaluate(). In addition, RooAbsPdf objects do not have a static concept of what; variables are parameters and what variables are dependents (which; need to be integrated over for a correct PDF normalization).; Instead the choice of normalization is always specified each time a; normalized values is requested from the PDF via the getVal(); method. RooAbsPdf manages the entire normalization logic of each PDF with; help of a RooRealIntegral object, which coordinates the integration; of a given choice of normalization. By default, RooRealIntegral will; perform a fully numeric integration of all dependents. However,; PDFs can advertise one or more (partial) analytical integrals of; their function, and these will be used by RooRealIntegral, if it; determines that this is safe (i.e. no hidden Jacobian terms,; multiplication with other PDFs that have one or more dependents in; commen etc). To implement analytical integrals, two functions must be implemented. First,. Int_t getAnalyticalIntegral(const RooArgSet& integSet, RooArgSet& anaIntSet). advertises the analytical integrals that are supported. 'integSet'; is the set of dependents for which integration is requested. The; function should copy the subset of dependents it can analytically; integrate to anaIntSet and return a unique identification code for; this integration configuration. If no integration can be; performed, zero should be returned. Second,. Double_t analyticalIntegral(Int_t code). Implements the actual analytical integral(s) advertised by; getAnalyticalIntegral. This functions will only be called with; codes returned by getAnalyticalIntegral, except code zero. The integration range for real each dependent to be integrated can; be obtained from the dependents' proxy functions min() and; max(). Never call these proxy functions for any proxy not known t",MatchSource.WIKI,root/html602/RooAbsPdf__GenSpec.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsPdf__GenSpec.html
https://root.cern/root/html602/RooAbsPdf__GenSpec.html:2439,Integrability,depend,dependents,2439,"hich; need to be integrated over for a correct PDF normalization).; Instead the choice of normalization is always specified each time a; normalized values is requested from the PDF via the getVal(); method. RooAbsPdf manages the entire normalization logic of each PDF with; help of a RooRealIntegral object, which coordinates the integration; of a given choice of normalization. By default, RooRealIntegral will; perform a fully numeric integration of all dependents. However,; PDFs can advertise one or more (partial) analytical integrals of; their function, and these will be used by RooRealIntegral, if it; determines that this is safe (i.e. no hidden Jacobian terms,; multiplication with other PDFs that have one or more dependents in; commen etc). To implement analytical integrals, two functions must be implemented. First,. Int_t getAnalyticalIntegral(const RooArgSet& integSet, RooArgSet& anaIntSet). advertises the analytical integrals that are supported. 'integSet'; is the set of dependents for which integration is requested. The; function should copy the subset of dependents it can analytically; integrate to anaIntSet and return a unique identification code for; this integration configuration. If no integration can be; performed, zero should be returned. Second,. Double_t analyticalIntegral(Int_t code). Implements the actual analytical integral(s) advertised by; getAnalyticalIntegral. This functions will only be called with; codes returned by getAnalyticalIntegral, except code zero. The integration range for real each dependent to be integrated can; be obtained from the dependents' proxy functions min() and; max(). Never call these proxy functions for any proxy not known to; be a dependent via the integration code. Doing so may be; ill-defined, e.g. in case the proxy holds a function, and will; trigger an assert. Integrated category dependents should always be; summed over all of their states. [Direct generation of observables]. Any PDF dependent can be generated with t",MatchSource.WIKI,root/html602/RooAbsPdf__GenSpec.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsPdf__GenSpec.html
https://root.cern/root/html602/RooAbsPdf__GenSpec.html:2460,Integrability,integrat,integration,2460,"hich; need to be integrated over for a correct PDF normalization).; Instead the choice of normalization is always specified each time a; normalized values is requested from the PDF via the getVal(); method. RooAbsPdf manages the entire normalization logic of each PDF with; help of a RooRealIntegral object, which coordinates the integration; of a given choice of normalization. By default, RooRealIntegral will; perform a fully numeric integration of all dependents. However,; PDFs can advertise one or more (partial) analytical integrals of; their function, and these will be used by RooRealIntegral, if it; determines that this is safe (i.e. no hidden Jacobian terms,; multiplication with other PDFs that have one or more dependents in; commen etc). To implement analytical integrals, two functions must be implemented. First,. Int_t getAnalyticalIntegral(const RooArgSet& integSet, RooArgSet& anaIntSet). advertises the analytical integrals that are supported. 'integSet'; is the set of dependents for which integration is requested. The; function should copy the subset of dependents it can analytically; integrate to anaIntSet and return a unique identification code for; this integration configuration. If no integration can be; performed, zero should be returned. Second,. Double_t analyticalIntegral(Int_t code). Implements the actual analytical integral(s) advertised by; getAnalyticalIntegral. This functions will only be called with; codes returned by getAnalyticalIntegral, except code zero. The integration range for real each dependent to be integrated can; be obtained from the dependents' proxy functions min() and; max(). Never call these proxy functions for any proxy not known to; be a dependent via the integration code. Doing so may be; ill-defined, e.g. in case the proxy holds a function, and will; trigger an assert. Integrated category dependents should always be; summed over all of their states. [Direct generation of observables]. Any PDF dependent can be generated with t",MatchSource.WIKI,root/html602/RooAbsPdf__GenSpec.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsPdf__GenSpec.html
https://root.cern/root/html602/RooAbsPdf__GenSpec.html:2526,Integrability,depend,dependents,2526," each time a; normalized values is requested from the PDF via the getVal(); method. RooAbsPdf manages the entire normalization logic of each PDF with; help of a RooRealIntegral object, which coordinates the integration; of a given choice of normalization. By default, RooRealIntegral will; perform a fully numeric integration of all dependents. However,; PDFs can advertise one or more (partial) analytical integrals of; their function, and these will be used by RooRealIntegral, if it; determines that this is safe (i.e. no hidden Jacobian terms,; multiplication with other PDFs that have one or more dependents in; commen etc). To implement analytical integrals, two functions must be implemented. First,. Int_t getAnalyticalIntegral(const RooArgSet& integSet, RooArgSet& anaIntSet). advertises the analytical integrals that are supported. 'integSet'; is the set of dependents for which integration is requested. The; function should copy the subset of dependents it can analytically; integrate to anaIntSet and return a unique identification code for; this integration configuration. If no integration can be; performed, zero should be returned. Second,. Double_t analyticalIntegral(Int_t code). Implements the actual analytical integral(s) advertised by; getAnalyticalIntegral. This functions will only be called with; codes returned by getAnalyticalIntegral, except code zero. The integration range for real each dependent to be integrated can; be obtained from the dependents' proxy functions min() and; max(). Never call these proxy functions for any proxy not known to; be a dependent via the integration code. Doing so may be; ill-defined, e.g. in case the proxy holds a function, and will; trigger an assert. Integrated category dependents should always be; summed over all of their states. [Direct generation of observables]. Any PDF dependent can be generated with the accept/reject method,; but for certain PDFs more efficient methods may be implemented. To; implement direct generation ",MatchSource.WIKI,root/html602/RooAbsPdf__GenSpec.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsPdf__GenSpec.html
https://root.cern/root/html602/RooAbsPdf__GenSpec.html:2558,Integrability,integrat,integrate,2558," each time a; normalized values is requested from the PDF via the getVal(); method. RooAbsPdf manages the entire normalization logic of each PDF with; help of a RooRealIntegral object, which coordinates the integration; of a given choice of normalization. By default, RooRealIntegral will; perform a fully numeric integration of all dependents. However,; PDFs can advertise one or more (partial) analytical integrals of; their function, and these will be used by RooRealIntegral, if it; determines that this is safe (i.e. no hidden Jacobian terms,; multiplication with other PDFs that have one or more dependents in; commen etc). To implement analytical integrals, two functions must be implemented. First,. Int_t getAnalyticalIntegral(const RooArgSet& integSet, RooArgSet& anaIntSet). advertises the analytical integrals that are supported. 'integSet'; is the set of dependents for which integration is requested. The; function should copy the subset of dependents it can analytically; integrate to anaIntSet and return a unique identification code for; this integration configuration. If no integration can be; performed, zero should be returned. Second,. Double_t analyticalIntegral(Int_t code). Implements the actual analytical integral(s) advertised by; getAnalyticalIntegral. This functions will only be called with; codes returned by getAnalyticalIntegral, except code zero. The integration range for real each dependent to be integrated can; be obtained from the dependents' proxy functions min() and; max(). Never call these proxy functions for any proxy not known to; be a dependent via the integration code. Doing so may be; ill-defined, e.g. in case the proxy holds a function, and will; trigger an assert. Integrated category dependents should always be; summed over all of their states. [Direct generation of observables]. Any PDF dependent can be generated with the accept/reject method,; but for certain PDFs more efficient methods may be implemented. To; implement direct generation ",MatchSource.WIKI,root/html602/RooAbsPdf__GenSpec.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsPdf__GenSpec.html
https://root.cern/root/html602/RooAbsPdf__GenSpec.html:2631,Integrability,integrat,integration,2631," each time a; normalized values is requested from the PDF via the getVal(); method. RooAbsPdf manages the entire normalization logic of each PDF with; help of a RooRealIntegral object, which coordinates the integration; of a given choice of normalization. By default, RooRealIntegral will; perform a fully numeric integration of all dependents. However,; PDFs can advertise one or more (partial) analytical integrals of; their function, and these will be used by RooRealIntegral, if it; determines that this is safe (i.e. no hidden Jacobian terms,; multiplication with other PDFs that have one or more dependents in; commen etc). To implement analytical integrals, two functions must be implemented. First,. Int_t getAnalyticalIntegral(const RooArgSet& integSet, RooArgSet& anaIntSet). advertises the analytical integrals that are supported. 'integSet'; is the set of dependents for which integration is requested. The; function should copy the subset of dependents it can analytically; integrate to anaIntSet and return a unique identification code for; this integration configuration. If no integration can be; performed, zero should be returned. Second,. Double_t analyticalIntegral(Int_t code). Implements the actual analytical integral(s) advertised by; getAnalyticalIntegral. This functions will only be called with; codes returned by getAnalyticalIntegral, except code zero. The integration range for real each dependent to be integrated can; be obtained from the dependents' proxy functions min() and; max(). Never call these proxy functions for any proxy not known to; be a dependent via the integration code. Doing so may be; ill-defined, e.g. in case the proxy holds a function, and will; trigger an assert. Integrated category dependents should always be; summed over all of their states. [Direct generation of observables]. Any PDF dependent can be generated with the accept/reject method,; but for certain PDFs more efficient methods may be implemented. To; implement direct generation ",MatchSource.WIKI,root/html602/RooAbsPdf__GenSpec.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsPdf__GenSpec.html
https://root.cern/root/html602/RooAbsPdf__GenSpec.html:2664,Integrability,integrat,integration,2664,"alization logic of each PDF with; help of a RooRealIntegral object, which coordinates the integration; of a given choice of normalization. By default, RooRealIntegral will; perform a fully numeric integration of all dependents. However,; PDFs can advertise one or more (partial) analytical integrals of; their function, and these will be used by RooRealIntegral, if it; determines that this is safe (i.e. no hidden Jacobian terms,; multiplication with other PDFs that have one or more dependents in; commen etc). To implement analytical integrals, two functions must be implemented. First,. Int_t getAnalyticalIntegral(const RooArgSet& integSet, RooArgSet& anaIntSet). advertises the analytical integrals that are supported. 'integSet'; is the set of dependents for which integration is requested. The; function should copy the subset of dependents it can analytically; integrate to anaIntSet and return a unique identification code for; this integration configuration. If no integration can be; performed, zero should be returned. Second,. Double_t analyticalIntegral(Int_t code). Implements the actual analytical integral(s) advertised by; getAnalyticalIntegral. This functions will only be called with; codes returned by getAnalyticalIntegral, except code zero. The integration range for real each dependent to be integrated can; be obtained from the dependents' proxy functions min() and; max(). Never call these proxy functions for any proxy not known to; be a dependent via the integration code. Doing so may be; ill-defined, e.g. in case the proxy holds a function, and will; trigger an assert. Integrated category dependents should always be; summed over all of their states. [Direct generation of observables]. Any PDF dependent can be generated with the accept/reject method,; but for certain PDFs more efficient methods may be implemented. To; implement direct generation of one or more observables, two; functions need to be implemented, similar to those for analytical; integrals:. Int_t",MatchSource.WIKI,root/html602/RooAbsPdf__GenSpec.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsPdf__GenSpec.html
https://root.cern/root/html602/RooAbsPdf__GenSpec.html:2957,Integrability,integrat,integration,2957,"ill be used by RooRealIntegral, if it; determines that this is safe (i.e. no hidden Jacobian terms,; multiplication with other PDFs that have one or more dependents in; commen etc). To implement analytical integrals, two functions must be implemented. First,. Int_t getAnalyticalIntegral(const RooArgSet& integSet, RooArgSet& anaIntSet). advertises the analytical integrals that are supported. 'integSet'; is the set of dependents for which integration is requested. The; function should copy the subset of dependents it can analytically; integrate to anaIntSet and return a unique identification code for; this integration configuration. If no integration can be; performed, zero should be returned. Second,. Double_t analyticalIntegral(Int_t code). Implements the actual analytical integral(s) advertised by; getAnalyticalIntegral. This functions will only be called with; codes returned by getAnalyticalIntegral, except code zero. The integration range for real each dependent to be integrated can; be obtained from the dependents' proxy functions min() and; max(). Never call these proxy functions for any proxy not known to; be a dependent via the integration code. Doing so may be; ill-defined, e.g. in case the proxy holds a function, and will; trigger an assert. Integrated category dependents should always be; summed over all of their states. [Direct generation of observables]. Any PDF dependent can be generated with the accept/reject method,; but for certain PDFs more efficient methods may be implemented. To; implement direct generation of one or more observables, two; functions need to be implemented, similar to those for analytical; integrals:. Int_t getGenerator(const RooArgSet& generateVars, RooArgSet& directVars) and; void generateEvent(Int_t code). The first function advertises observables that can be generated,; similar to the way analytical integrals are advertised. The second; function implements the generator for the advertised observables. The generated dependent val",MatchSource.WIKI,root/html602/RooAbsPdf__GenSpec.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsPdf__GenSpec.html
https://root.cern/root/html602/RooAbsPdf__GenSpec.html:2989,Integrability,depend,dependent,2989,"ill be used by RooRealIntegral, if it; determines that this is safe (i.e. no hidden Jacobian terms,; multiplication with other PDFs that have one or more dependents in; commen etc). To implement analytical integrals, two functions must be implemented. First,. Int_t getAnalyticalIntegral(const RooArgSet& integSet, RooArgSet& anaIntSet). advertises the analytical integrals that are supported. 'integSet'; is the set of dependents for which integration is requested. The; function should copy the subset of dependents it can analytically; integrate to anaIntSet and return a unique identification code for; this integration configuration. If no integration can be; performed, zero should be returned. Second,. Double_t analyticalIntegral(Int_t code). Implements the actual analytical integral(s) advertised by; getAnalyticalIntegral. This functions will only be called with; codes returned by getAnalyticalIntegral, except code zero. The integration range for real each dependent to be integrated can; be obtained from the dependents' proxy functions min() and; max(). Never call these proxy functions for any proxy not known to; be a dependent via the integration code. Doing so may be; ill-defined, e.g. in case the proxy holds a function, and will; trigger an assert. Integrated category dependents should always be; summed over all of their states. [Direct generation of observables]. Any PDF dependent can be generated with the accept/reject method,; but for certain PDFs more efficient methods may be implemented. To; implement direct generation of one or more observables, two; functions need to be implemented, similar to those for analytical; integrals:. Int_t getGenerator(const RooArgSet& generateVars, RooArgSet& directVars) and; void generateEvent(Int_t code). The first function advertises observables that can be generated,; similar to the way analytical integrals are advertised. The second; function implements the generator for the advertised observables. The generated dependent val",MatchSource.WIKI,root/html602/RooAbsPdf__GenSpec.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsPdf__GenSpec.html
https://root.cern/root/html602/RooAbsPdf__GenSpec.html:3005,Integrability,integrat,integrated,3005,"ill be used by RooRealIntegral, if it; determines that this is safe (i.e. no hidden Jacobian terms,; multiplication with other PDFs that have one or more dependents in; commen etc). To implement analytical integrals, two functions must be implemented. First,. Int_t getAnalyticalIntegral(const RooArgSet& integSet, RooArgSet& anaIntSet). advertises the analytical integrals that are supported. 'integSet'; is the set of dependents for which integration is requested. The; function should copy the subset of dependents it can analytically; integrate to anaIntSet and return a unique identification code for; this integration configuration. If no integration can be; performed, zero should be returned. Second,. Double_t analyticalIntegral(Int_t code). Implements the actual analytical integral(s) advertised by; getAnalyticalIntegral. This functions will only be called with; codes returned by getAnalyticalIntegral, except code zero. The integration range for real each dependent to be integrated can; be obtained from the dependents' proxy functions min() and; max(). Never call these proxy functions for any proxy not known to; be a dependent via the integration code. Doing so may be; ill-defined, e.g. in case the proxy holds a function, and will; trigger an assert. Integrated category dependents should always be; summed over all of their states. [Direct generation of observables]. Any PDF dependent can be generated with the accept/reject method,; but for certain PDFs more efficient methods may be implemented. To; implement direct generation of one or more observables, two; functions need to be implemented, similar to those for analytical; integrals:. Int_t getGenerator(const RooArgSet& generateVars, RooArgSet& directVars) and; void generateEvent(Int_t code). The first function advertises observables that can be generated,; similar to the way analytical integrals are advertised. The second; function implements the generator for the advertised observables. The generated dependent val",MatchSource.WIKI,root/html602/RooAbsPdf__GenSpec.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsPdf__GenSpec.html
https://root.cern/root/html602/RooAbsPdf__GenSpec.html:3042,Integrability,depend,dependents,3042,"ill be used by RooRealIntegral, if it; determines that this is safe (i.e. no hidden Jacobian terms,; multiplication with other PDFs that have one or more dependents in; commen etc). To implement analytical integrals, two functions must be implemented. First,. Int_t getAnalyticalIntegral(const RooArgSet& integSet, RooArgSet& anaIntSet). advertises the analytical integrals that are supported. 'integSet'; is the set of dependents for which integration is requested. The; function should copy the subset of dependents it can analytically; integrate to anaIntSet and return a unique identification code for; this integration configuration. If no integration can be; performed, zero should be returned. Second,. Double_t analyticalIntegral(Int_t code). Implements the actual analytical integral(s) advertised by; getAnalyticalIntegral. This functions will only be called with; codes returned by getAnalyticalIntegral, except code zero. The integration range for real each dependent to be integrated can; be obtained from the dependents' proxy functions min() and; max(). Never call these proxy functions for any proxy not known to; be a dependent via the integration code. Doing so may be; ill-defined, e.g. in case the proxy holds a function, and will; trigger an assert. Integrated category dependents should always be; summed over all of their states. [Direct generation of observables]. Any PDF dependent can be generated with the accept/reject method,; but for certain PDFs more efficient methods may be implemented. To; implement direct generation of one or more observables, two; functions need to be implemented, similar to those for analytical; integrals:. Int_t getGenerator(const RooArgSet& generateVars, RooArgSet& directVars) and; void generateEvent(Int_t code). The first function advertises observables that can be generated,; similar to the way analytical integrals are advertised. The second; function implements the generator for the advertised observables. The generated dependent val",MatchSource.WIKI,root/html602/RooAbsPdf__GenSpec.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsPdf__GenSpec.html
https://root.cern/root/html602/RooAbsPdf__GenSpec.html:3154,Integrability,depend,dependent,3154,"h other PDFs that have one or more dependents in; commen etc). To implement analytical integrals, two functions must be implemented. First,. Int_t getAnalyticalIntegral(const RooArgSet& integSet, RooArgSet& anaIntSet). advertises the analytical integrals that are supported. 'integSet'; is the set of dependents for which integration is requested. The; function should copy the subset of dependents it can analytically; integrate to anaIntSet and return a unique identification code for; this integration configuration. If no integration can be; performed, zero should be returned. Second,. Double_t analyticalIntegral(Int_t code). Implements the actual analytical integral(s) advertised by; getAnalyticalIntegral. This functions will only be called with; codes returned by getAnalyticalIntegral, except code zero. The integration range for real each dependent to be integrated can; be obtained from the dependents' proxy functions min() and; max(). Never call these proxy functions for any proxy not known to; be a dependent via the integration code. Doing so may be; ill-defined, e.g. in case the proxy holds a function, and will; trigger an assert. Integrated category dependents should always be; summed over all of their states. [Direct generation of observables]. Any PDF dependent can be generated with the accept/reject method,; but for certain PDFs more efficient methods may be implemented. To; implement direct generation of one or more observables, two; functions need to be implemented, similar to those for analytical; integrals:. Int_t getGenerator(const RooArgSet& generateVars, RooArgSet& directVars) and; void generateEvent(Int_t code). The first function advertises observables that can be generated,; similar to the way analytical integrals are advertised. The second; function implements the generator for the advertised observables. The generated dependent values should be store in the proxy; objects. For this the assignment operator can be used (i.e. xProxy; = 3.0 ). Never c",MatchSource.WIKI,root/html602/RooAbsPdf__GenSpec.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsPdf__GenSpec.html
https://root.cern/root/html602/RooAbsPdf__GenSpec.html:3172,Integrability,integrat,integration,3172,"h other PDFs that have one or more dependents in; commen etc). To implement analytical integrals, two functions must be implemented. First,. Int_t getAnalyticalIntegral(const RooArgSet& integSet, RooArgSet& anaIntSet). advertises the analytical integrals that are supported. 'integSet'; is the set of dependents for which integration is requested. The; function should copy the subset of dependents it can analytically; integrate to anaIntSet and return a unique identification code for; this integration configuration. If no integration can be; performed, zero should be returned. Second,. Double_t analyticalIntegral(Int_t code). Implements the actual analytical integral(s) advertised by; getAnalyticalIntegral. This functions will only be called with; codes returned by getAnalyticalIntegral, except code zero. The integration range for real each dependent to be integrated can; be obtained from the dependents' proxy functions min() and; max(). Never call these proxy functions for any proxy not known to; be a dependent via the integration code. Doing so may be; ill-defined, e.g. in case the proxy holds a function, and will; trigger an assert. Integrated category dependents should always be; summed over all of their states. [Direct generation of observables]. Any PDF dependent can be generated with the accept/reject method,; but for certain PDFs more efficient methods may be implemented. To; implement direct generation of one or more observables, two; functions need to be implemented, similar to those for analytical; integrals:. Int_t getGenerator(const RooArgSet& generateVars, RooArgSet& directVars) and; void generateEvent(Int_t code). The first function advertises observables that can be generated,; similar to the way analytical integrals are advertised. The second; function implements the generator for the advertised observables. The generated dependent values should be store in the proxy; objects. For this the assignment operator can be used (i.e. xProxy; = 3.0 ). Never c",MatchSource.WIKI,root/html602/RooAbsPdf__GenSpec.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsPdf__GenSpec.html
https://root.cern/root/html602/RooAbsPdf__GenSpec.html:3310,Integrability,depend,dependents,3310,"et, RooArgSet& anaIntSet). advertises the analytical integrals that are supported. 'integSet'; is the set of dependents for which integration is requested. The; function should copy the subset of dependents it can analytically; integrate to anaIntSet and return a unique identification code for; this integration configuration. If no integration can be; performed, zero should be returned. Second,. Double_t analyticalIntegral(Int_t code). Implements the actual analytical integral(s) advertised by; getAnalyticalIntegral. This functions will only be called with; codes returned by getAnalyticalIntegral, except code zero. The integration range for real each dependent to be integrated can; be obtained from the dependents' proxy functions min() and; max(). Never call these proxy functions for any proxy not known to; be a dependent via the integration code. Doing so may be; ill-defined, e.g. in case the proxy holds a function, and will; trigger an assert. Integrated category dependents should always be; summed over all of their states. [Direct generation of observables]. Any PDF dependent can be generated with the accept/reject method,; but for certain PDFs more efficient methods may be implemented. To; implement direct generation of one or more observables, two; functions need to be implemented, similar to those for analytical; integrals:. Int_t getGenerator(const RooArgSet& generateVars, RooArgSet& directVars) and; void generateEvent(Int_t code). The first function advertises observables that can be generated,; similar to the way analytical integrals are advertised. The second; function implements the generator for the advertised observables. The generated dependent values should be store in the proxy; objects. For this the assignment operator can be used (i.e. xProxy; = 3.0 ). Never call assign to any proxy not known to be a dependent; via the generation code. Doing so may be ill-defined, e.g. in case; the proxy holds a function, and will trigger an assert. Function Member",MatchSource.WIKI,root/html602/RooAbsPdf__GenSpec.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsPdf__GenSpec.html
https://root.cern/root/html602/RooAbsPdf__GenSpec.html:3416,Integrability,depend,dependent,3416,"is requested. The; function should copy the subset of dependents it can analytically; integrate to anaIntSet and return a unique identification code for; this integration configuration. If no integration can be; performed, zero should be returned. Second,. Double_t analyticalIntegral(Int_t code). Implements the actual analytical integral(s) advertised by; getAnalyticalIntegral. This functions will only be called with; codes returned by getAnalyticalIntegral, except code zero. The integration range for real each dependent to be integrated can; be obtained from the dependents' proxy functions min() and; max(). Never call these proxy functions for any proxy not known to; be a dependent via the integration code. Doing so may be; ill-defined, e.g. in case the proxy holds a function, and will; trigger an assert. Integrated category dependents should always be; summed over all of their states. [Direct generation of observables]. Any PDF dependent can be generated with the accept/reject method,; but for certain PDFs more efficient methods may be implemented. To; implement direct generation of one or more observables, two; functions need to be implemented, similar to those for analytical; integrals:. Int_t getGenerator(const RooArgSet& generateVars, RooArgSet& directVars) and; void generateEvent(Int_t code). The first function advertises observables that can be generated,; similar to the way analytical integrals are advertised. The second; function implements the generator for the advertised observables. The generated dependent values should be store in the proxy; objects. For this the assignment operator can be used (i.e. xProxy; = 3.0 ). Never call assign to any proxy not known to be a dependent; via the generation code. Doing so may be ill-defined, e.g. in case; the proxy holds a function, and will trigger an assert. Function Members (Methods); public:. virtual~GenSpec(); static TClass*Class(); RooAbsPdf::GenSpecGenSpec(); virtual TClass*IsA() const; RooAbsPdf::GenSpec&ope",MatchSource.WIKI,root/html602/RooAbsPdf__GenSpec.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsPdf__GenSpec.html
https://root.cern/root/html602/RooAbsPdf__GenSpec.html:4007,Integrability,depend,dependent,4007,"ained from the dependents' proxy functions min() and; max(). Never call these proxy functions for any proxy not known to; be a dependent via the integration code. Doing so may be; ill-defined, e.g. in case the proxy holds a function, and will; trigger an assert. Integrated category dependents should always be; summed over all of their states. [Direct generation of observables]. Any PDF dependent can be generated with the accept/reject method,; but for certain PDFs more efficient methods may be implemented. To; implement direct generation of one or more observables, two; functions need to be implemented, similar to those for analytical; integrals:. Int_t getGenerator(const RooArgSet& generateVars, RooArgSet& directVars) and; void generateEvent(Int_t code). The first function advertises observables that can be generated,; similar to the way analytical integrals are advertised. The second; function implements the generator for the advertised observables. The generated dependent values should be store in the proxy; objects. For this the assignment operator can be used (i.e. xProxy; = 3.0 ). Never call assign to any proxy not known to be a dependent; via the generation code. Doing so may be ill-defined, e.g. in case; the proxy holds a function, and will trigger an assert. Function Members (Methods); public:. virtual~GenSpec(); static TClass*Class(); RooAbsPdf::GenSpecGenSpec(); virtual TClass*IsA() const; RooAbsPdf::GenSpec&operator=(const RooAbsPdf::GenSpec&); virtual voidShowMembers(TMemberInspector& insp) const; virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b). private:. RooAbsPdf::GenSpecGenSpec(const RooAbsPdf::GenSpec& other); RooAbsPdf::GenSpecGenSpec(RooAbsGenContext* context, const RooArgSet& whatVars, RooDataSet* protoData, Int_t nGen, Bool_t extended, Bool_t randProto, Bool_t resampleProto, TString dsetName, Bool_t init = kFALSE). Data Members; private:. TString_dsetName; Bool_t_extended; RooAbsGenContext*_genContext; ",MatchSource.WIKI,root/html602/RooAbsPdf__GenSpec.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsPdf__GenSpec.html
https://root.cern/root/html602/RooAbsPdf__GenSpec.html:4180,Integrability,depend,dependent,4180,"integration code. Doing so may be; ill-defined, e.g. in case the proxy holds a function, and will; trigger an assert. Integrated category dependents should always be; summed over all of their states. [Direct generation of observables]. Any PDF dependent can be generated with the accept/reject method,; but for certain PDFs more efficient methods may be implemented. To; implement direct generation of one or more observables, two; functions need to be implemented, similar to those for analytical; integrals:. Int_t getGenerator(const RooArgSet& generateVars, RooArgSet& directVars) and; void generateEvent(Int_t code). The first function advertises observables that can be generated,; similar to the way analytical integrals are advertised. The second; function implements the generator for the advertised observables. The generated dependent values should be store in the proxy; objects. For this the assignment operator can be used (i.e. xProxy; = 3.0 ). Never call assign to any proxy not known to be a dependent; via the generation code. Doing so may be ill-defined, e.g. in case; the proxy holds a function, and will trigger an assert. Function Members (Methods); public:. virtual~GenSpec(); static TClass*Class(); RooAbsPdf::GenSpecGenSpec(); virtual TClass*IsA() const; RooAbsPdf::GenSpec&operator=(const RooAbsPdf::GenSpec&); virtual voidShowMembers(TMemberInspector& insp) const; virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b). private:. RooAbsPdf::GenSpecGenSpec(const RooAbsPdf::GenSpec& other); RooAbsPdf::GenSpecGenSpec(RooAbsGenContext* context, const RooArgSet& whatVars, RooDataSet* protoData, Int_t nGen, Bool_t extended, Bool_t randProto, Bool_t resampleProto, TString dsetName, Bool_t init = kFALSE). Data Members; private:. TString_dsetName; Bool_t_extended; RooAbsGenContext*_genContext; Bool_t_init; Int_t_nGen; RooDataSet*_protoData; Bool_t_randProto; Bool_t_resampleProto; RooArgSet_whatVars. Class Charts. Inheritance; Inherited M",MatchSource.WIKI,root/html602/RooAbsPdf__GenSpec.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsPdf__GenSpec.html
https://root.cern/root/html602/RooAbsPdf__GenSpec.html:968,Modifiability,variab,variables,968,". RooAbsPdf::GenSpec. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » ROOFIT; » ROOFITCORE; » RooAbsPdf::GenSpec. class RooAbsPdf::GenSpec. RooAbsPdf is the abstract interface for all probability density; functions The class provides hybrid analytical/numerical; normalization for its implementations, error tracing and a MC; generator interface. A minimal implementation of a PDF class derived from RooAbsPdf; should overload the evaluate() function. This functions should; return PDFs value. [Normalization/Integration]. Although the normalization of a PDF is an integral part of a; probability density function, normalization is treated separately; in RooAbsPdf. The reason is that a RooAbsPdf object is more than a; PDF: it can be a building block for a more complex, composite PDF; if any of its variables are functions instead of variables. In; such cases the normalization of the composite may not be simply the; integral over the dependents of the top level PDF as these are; functions with potentially non-trivial Jacobian terms themselves.; Therefore. --> No explicit attempt should be made to normalize; the functions output in evaluate(). In addition, RooAbsPdf objects do not have a static concept of what; variables are parameters and what variables are dependents (which; need to be integrated over for a correct PDF normalization).; Instead the choice of normalization is always specified each time a; normalized values is requested from the PDF via the getVal(); method. RooAbsPdf manages the entire normalization logic of each PDF with; help of a RooRealIntegral object, which coordinates the integration; of a given choice of normalization. By default, RooRealIntegral will; perform a fully numeric integration of all dependents. However,; PDFs can advertise one or more (partial) analytical integrals of; their fun",MatchSource.WIKI,root/html602/RooAbsPdf__GenSpec.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsPdf__GenSpec.html
https://root.cern/root/html602/RooAbsPdf__GenSpec.html:1003,Modifiability,variab,variables,1003,". RooAbsPdf::GenSpec. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » ROOFIT; » ROOFITCORE; » RooAbsPdf::GenSpec. class RooAbsPdf::GenSpec. RooAbsPdf is the abstract interface for all probability density; functions The class provides hybrid analytical/numerical; normalization for its implementations, error tracing and a MC; generator interface. A minimal implementation of a PDF class derived from RooAbsPdf; should overload the evaluate() function. This functions should; return PDFs value. [Normalization/Integration]. Although the normalization of a PDF is an integral part of a; probability density function, normalization is treated separately; in RooAbsPdf. The reason is that a RooAbsPdf object is more than a; PDF: it can be a building block for a more complex, composite PDF; if any of its variables are functions instead of variables. In; such cases the normalization of the composite may not be simply the; integral over the dependents of the top level PDF as these are; functions with potentially non-trivial Jacobian terms themselves.; Therefore. --> No explicit attempt should be made to normalize; the functions output in evaluate(). In addition, RooAbsPdf objects do not have a static concept of what; variables are parameters and what variables are dependents (which; need to be integrated over for a correct PDF normalization).; Instead the choice of normalization is always specified each time a; normalized values is requested from the PDF via the getVal(); method. RooAbsPdf manages the entire normalization logic of each PDF with; help of a RooRealIntegral object, which coordinates the integration; of a given choice of normalization. By default, RooRealIntegral will; perform a fully numeric integration of all dependents. However,; PDFs can advertise one or more (partial) analytical integrals of; their fun",MatchSource.WIKI,root/html602/RooAbsPdf__GenSpec.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsPdf__GenSpec.html
https://root.cern/root/html602/RooAbsPdf__GenSpec.html:1387,Modifiability,variab,variables,1387,"cal/numerical; normalization for its implementations, error tracing and a MC; generator interface. A minimal implementation of a PDF class derived from RooAbsPdf; should overload the evaluate() function. This functions should; return PDFs value. [Normalization/Integration]. Although the normalization of a PDF is an integral part of a; probability density function, normalization is treated separately; in RooAbsPdf. The reason is that a RooAbsPdf object is more than a; PDF: it can be a building block for a more complex, composite PDF; if any of its variables are functions instead of variables. In; such cases the normalization of the composite may not be simply the; integral over the dependents of the top level PDF as these are; functions with potentially non-trivial Jacobian terms themselves.; Therefore. --> No explicit attempt should be made to normalize; the functions output in evaluate(). In addition, RooAbsPdf objects do not have a static concept of what; variables are parameters and what variables are dependents (which; need to be integrated over for a correct PDF normalization).; Instead the choice of normalization is always specified each time a; normalized values is requested from the PDF via the getVal(); method. RooAbsPdf manages the entire normalization logic of each PDF with; help of a RooRealIntegral object, which coordinates the integration; of a given choice of normalization. By default, RooRealIntegral will; perform a fully numeric integration of all dependents. However,; PDFs can advertise one or more (partial) analytical integrals of; their function, and these will be used by RooRealIntegral, if it; determines that this is safe (i.e. no hidden Jacobian terms,; multiplication with other PDFs that have one or more dependents in; commen etc). To implement analytical integrals, two functions must be implemented. First,. Int_t getAnalyticalIntegral(const RooArgSet& integSet, RooArgSet& anaIntSet). advertises the analytical integrals that are supported. 'in",MatchSource.WIKI,root/html602/RooAbsPdf__GenSpec.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsPdf__GenSpec.html
https://root.cern/root/html602/RooAbsPdf__GenSpec.html:1421,Modifiability,variab,variables,1421,"cal/numerical; normalization for its implementations, error tracing and a MC; generator interface. A minimal implementation of a PDF class derived from RooAbsPdf; should overload the evaluate() function. This functions should; return PDFs value. [Normalization/Integration]. Although the normalization of a PDF is an integral part of a; probability density function, normalization is treated separately; in RooAbsPdf. The reason is that a RooAbsPdf object is more than a; PDF: it can be a building block for a more complex, composite PDF; if any of its variables are functions instead of variables. In; such cases the normalization of the composite may not be simply the; integral over the dependents of the top level PDF as these are; functions with potentially non-trivial Jacobian terms themselves.; Therefore. --> No explicit attempt should be made to normalize; the functions output in evaluate(). In addition, RooAbsPdf objects do not have a static concept of what; variables are parameters and what variables are dependents (which; need to be integrated over for a correct PDF normalization).; Instead the choice of normalization is always specified each time a; normalized values is requested from the PDF via the getVal(); method. RooAbsPdf manages the entire normalization logic of each PDF with; help of a RooRealIntegral object, which coordinates the integration; of a given choice of normalization. By default, RooRealIntegral will; perform a fully numeric integration of all dependents. However,; PDFs can advertise one or more (partial) analytical integrals of; their function, and these will be used by RooRealIntegral, if it; determines that this is safe (i.e. no hidden Jacobian terms,; multiplication with other PDFs that have one or more dependents in; commen etc). To implement analytical integrals, two functions must be implemented. First,. Int_t getAnalyticalIntegral(const RooArgSet& integSet, RooArgSet& anaIntSet). advertises the analytical integrals that are supported. 'in",MatchSource.WIKI,root/html602/RooAbsPdf__GenSpec.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsPdf__GenSpec.html
https://root.cern/root/html602/RooAbsPdf__GenSpec.html:2643,Modifiability,config,configuration,2643," each time a; normalized values is requested from the PDF via the getVal(); method. RooAbsPdf manages the entire normalization logic of each PDF with; help of a RooRealIntegral object, which coordinates the integration; of a given choice of normalization. By default, RooRealIntegral will; perform a fully numeric integration of all dependents. However,; PDFs can advertise one or more (partial) analytical integrals of; their function, and these will be used by RooRealIntegral, if it; determines that this is safe (i.e. no hidden Jacobian terms,; multiplication with other PDFs that have one or more dependents in; commen etc). To implement analytical integrals, two functions must be implemented. First,. Int_t getAnalyticalIntegral(const RooArgSet& integSet, RooArgSet& anaIntSet). advertises the analytical integrals that are supported. 'integSet'; is the set of dependents for which integration is requested. The; function should copy the subset of dependents it can analytically; integrate to anaIntSet and return a unique identification code for; this integration configuration. If no integration can be; performed, zero should be returned. Second,. Double_t analyticalIntegral(Int_t code). Implements the actual analytical integral(s) advertised by; getAnalyticalIntegral. This functions will only be called with; codes returned by getAnalyticalIntegral, except code zero. The integration range for real each dependent to be integrated can; be obtained from the dependents' proxy functions min() and; max(). Never call these proxy functions for any proxy not known to; be a dependent via the integration code. Doing so may be; ill-defined, e.g. in case the proxy holds a function, and will; trigger an assert. Integrated category dependents should always be; summed over all of their states. [Direct generation of observables]. Any PDF dependent can be generated with the accept/reject method,; but for certain PDFs more efficient methods may be implemented. To; implement direct generation ",MatchSource.WIKI,root/html602/RooAbsPdf__GenSpec.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsPdf__GenSpec.html
https://root.cern/root/html602/RooAbsPdf__GenSpec.html:4847,Modifiability,extend,extended,4847,"st function advertises observables that can be generated,; similar to the way analytical integrals are advertised. The second; function implements the generator for the advertised observables. The generated dependent values should be store in the proxy; objects. For this the assignment operator can be used (i.e. xProxy; = 3.0 ). Never call assign to any proxy not known to be a dependent; via the generation code. Doing so may be ill-defined, e.g. in case; the proxy holds a function, and will trigger an assert. Function Members (Methods); public:. virtual~GenSpec(); static TClass*Class(); RooAbsPdf::GenSpecGenSpec(); virtual TClass*IsA() const; RooAbsPdf::GenSpec&operator=(const RooAbsPdf::GenSpec&); virtual voidShowMembers(TMemberInspector& insp) const; virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b). private:. RooAbsPdf::GenSpecGenSpec(const RooAbsPdf::GenSpec& other); RooAbsPdf::GenSpecGenSpec(RooAbsGenContext* context, const RooArgSet& whatVars, RooDataSet* protoData, Int_t nGen, Bool_t extended, Bool_t randProto, Bool_t resampleProto, TString dsetName, Bool_t init = kFALSE). Data Members; private:. TString_dsetName; Bool_t_extended; RooAbsGenContext*_genContext; Bool_t_init; Int_t_nGen; RooDataSet*_protoData; Bool_t_randProto; Bool_t_resampleProto; RooArgSet_whatVars. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; ~GenSpec(). GenSpec(RooAbsGenContext* context, const RooArgSet& whatVars, RooDataSet* protoData, Int_t nGen, Bool_t extended, Bool_t randProto, Bool_t resampleProto, TString dsetName, Bool_t init = kFALSE). GenSpec(); { _genContext = 0 ; _protoData = 0 ; _init = kFALSE ; _extended=kFALSE, _nGen=0 ; _randProto = kFALSE ; _resampleProto=kFALSE ; }. GenSpec(RooAbsGenContext* context, const RooArgSet& whatVars, RooDataSet* protoData, Int_t nGen, Bool_t extended, Bool_t randProto, Bool_t resampleProto, TString dsetName, Bool_t init = kFALSE). » Last changed: Tue Jun 30 14:3",MatchSource.WIKI,root/html602/RooAbsPdf__GenSpec.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsPdf__GenSpec.html
https://root.cern/root/html602/RooAbsPdf__GenSpec.html:5342,Modifiability,extend,extended,5342,"ated dependent values should be store in the proxy; objects. For this the assignment operator can be used (i.e. xProxy; = 3.0 ). Never call assign to any proxy not known to be a dependent; via the generation code. Doing so may be ill-defined, e.g. in case; the proxy holds a function, and will trigger an assert. Function Members (Methods); public:. virtual~GenSpec(); static TClass*Class(); RooAbsPdf::GenSpecGenSpec(); virtual TClass*IsA() const; RooAbsPdf::GenSpec&operator=(const RooAbsPdf::GenSpec&); virtual voidShowMembers(TMemberInspector& insp) const; virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b). private:. RooAbsPdf::GenSpecGenSpec(const RooAbsPdf::GenSpec& other); RooAbsPdf::GenSpecGenSpec(RooAbsGenContext* context, const RooArgSet& whatVars, RooDataSet* protoData, Int_t nGen, Bool_t extended, Bool_t randProto, Bool_t resampleProto, TString dsetName, Bool_t init = kFALSE). Data Members; private:. TString_dsetName; Bool_t_extended; RooAbsGenContext*_genContext; Bool_t_init; Int_t_nGen; RooDataSet*_protoData; Bool_t_randProto; Bool_t_resampleProto; RooArgSet_whatVars. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; ~GenSpec(). GenSpec(RooAbsGenContext* context, const RooArgSet& whatVars, RooDataSet* protoData, Int_t nGen, Bool_t extended, Bool_t randProto, Bool_t resampleProto, TString dsetName, Bool_t init = kFALSE). GenSpec(); { _genContext = 0 ; _protoData = 0 ; _init = kFALSE ; _extended=kFALSE, _nGen=0 ; _randProto = kFALSE ; _resampleProto=kFALSE ; }. GenSpec(RooAbsGenContext* context, const RooArgSet& whatVars, RooDataSet* protoData, Int_t nGen, Bool_t extended, Bool_t randProto, Bool_t resampleProto, TString dsetName, Bool_t init = kFALSE). » Last changed: Tue Jun 30 14:30:22 2015 » Last generated: 2015-06-30 14:30; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html602/RooAbsPdf__GenSpec.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsPdf__GenSpec.html
https://root.cern/root/html602/RooAbsPdf__GenSpec.html:5679,Modifiability,extend,extended,5679,"ated dependent values should be store in the proxy; objects. For this the assignment operator can be used (i.e. xProxy; = 3.0 ). Never call assign to any proxy not known to be a dependent; via the generation code. Doing so may be ill-defined, e.g. in case; the proxy holds a function, and will trigger an assert. Function Members (Methods); public:. virtual~GenSpec(); static TClass*Class(); RooAbsPdf::GenSpecGenSpec(); virtual TClass*IsA() const; RooAbsPdf::GenSpec&operator=(const RooAbsPdf::GenSpec&); virtual voidShowMembers(TMemberInspector& insp) const; virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b). private:. RooAbsPdf::GenSpecGenSpec(const RooAbsPdf::GenSpec& other); RooAbsPdf::GenSpecGenSpec(RooAbsGenContext* context, const RooArgSet& whatVars, RooDataSet* protoData, Int_t nGen, Bool_t extended, Bool_t randProto, Bool_t resampleProto, TString dsetName, Bool_t init = kFALSE). Data Members; private:. TString_dsetName; Bool_t_extended; RooAbsGenContext*_genContext; Bool_t_init; Int_t_nGen; RooDataSet*_protoData; Bool_t_randProto; Bool_t_resampleProto; RooArgSet_whatVars. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; ~GenSpec(). GenSpec(RooAbsGenContext* context, const RooArgSet& whatVars, RooDataSet* protoData, Int_t nGen, Bool_t extended, Bool_t randProto, Bool_t resampleProto, TString dsetName, Bool_t init = kFALSE). GenSpec(); { _genContext = 0 ; _protoData = 0 ; _init = kFALSE ; _extended=kFALSE, _nGen=0 ; _randProto = kFALSE ; _resampleProto=kFALSE ; }. GenSpec(RooAbsGenContext* context, const RooArgSet& whatVars, RooDataSet* protoData, Int_t nGen, Bool_t extended, Bool_t randProto, Bool_t resampleProto, TString dsetName, Bool_t init = kFALSE). » Last changed: Tue Jun 30 14:30:22 2015 » Last generated: 2015-06-30 14:30; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html602/RooAbsPdf__GenSpec.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsPdf__GenSpec.html
https://root.cern/root/html602/RooAbsPdf__GenSpec.html:1861,Performance,perform,perform,1861," is more than a; PDF: it can be a building block for a more complex, composite PDF; if any of its variables are functions instead of variables. In; such cases the normalization of the composite may not be simply the; integral over the dependents of the top level PDF as these are; functions with potentially non-trivial Jacobian terms themselves.; Therefore. --> No explicit attempt should be made to normalize; the functions output in evaluate(). In addition, RooAbsPdf objects do not have a static concept of what; variables are parameters and what variables are dependents (which; need to be integrated over for a correct PDF normalization).; Instead the choice of normalization is always specified each time a; normalized values is requested from the PDF via the getVal(); method. RooAbsPdf manages the entire normalization logic of each PDF with; help of a RooRealIntegral object, which coordinates the integration; of a given choice of normalization. By default, RooRealIntegral will; perform a fully numeric integration of all dependents. However,; PDFs can advertise one or more (partial) analytical integrals of; their function, and these will be used by RooRealIntegral, if it; determines that this is safe (i.e. no hidden Jacobian terms,; multiplication with other PDFs that have one or more dependents in; commen etc). To implement analytical integrals, two functions must be implemented. First,. Int_t getAnalyticalIntegral(const RooArgSet& integSet, RooArgSet& anaIntSet). advertises the analytical integrals that are supported. 'integSet'; is the set of dependents for which integration is requested. The; function should copy the subset of dependents it can analytically; integrate to anaIntSet and return a unique identification code for; this integration configuration. If no integration can be; performed, zero should be returned. Second,. Double_t analyticalIntegral(Int_t code). Implements the actual analytical integral(s) advertised by; getAnalyticalIntegral. This functions wil",MatchSource.WIKI,root/html602/RooAbsPdf__GenSpec.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsPdf__GenSpec.html
https://root.cern/root/html602/RooAbsPdf__GenSpec.html:2684,Performance,perform,performed,2684,"alization logic of each PDF with; help of a RooRealIntegral object, which coordinates the integration; of a given choice of normalization. By default, RooRealIntegral will; perform a fully numeric integration of all dependents. However,; PDFs can advertise one or more (partial) analytical integrals of; their function, and these will be used by RooRealIntegral, if it; determines that this is safe (i.e. no hidden Jacobian terms,; multiplication with other PDFs that have one or more dependents in; commen etc). To implement analytical integrals, two functions must be implemented. First,. Int_t getAnalyticalIntegral(const RooArgSet& integSet, RooArgSet& anaIntSet). advertises the analytical integrals that are supported. 'integSet'; is the set of dependents for which integration is requested. The; function should copy the subset of dependents it can analytically; integrate to anaIntSet and return a unique identification code for; this integration configuration. If no integration can be; performed, zero should be returned. Second,. Double_t analyticalIntegral(Int_t code). Implements the actual analytical integral(s) advertised by; getAnalyticalIntegral. This functions will only be called with; codes returned by getAnalyticalIntegral, except code zero. The integration range for real each dependent to be integrated can; be obtained from the dependents' proxy functions min() and; max(). Never call these proxy functions for any proxy not known to; be a dependent via the integration code. Doing so may be; ill-defined, e.g. in case the proxy holds a function, and will; trigger an assert. Integrated category dependents should always be; summed over all of their states. [Direct generation of observables]. Any PDF dependent can be generated with the accept/reject method,; but for certain PDFs more efficient methods may be implemented. To; implement direct generation of one or more observables, two; functions need to be implemented, similar to those for analytical; integrals:. Int_t",MatchSource.WIKI,root/html602/RooAbsPdf__GenSpec.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsPdf__GenSpec.html
https://root.cern/root/html602/RooAbsPdf__GenSpec.html:2082,Safety,safe,safe,2082," variables. In; such cases the normalization of the composite may not be simply the; integral over the dependents of the top level PDF as these are; functions with potentially non-trivial Jacobian terms themselves.; Therefore. --> No explicit attempt should be made to normalize; the functions output in evaluate(). In addition, RooAbsPdf objects do not have a static concept of what; variables are parameters and what variables are dependents (which; need to be integrated over for a correct PDF normalization).; Instead the choice of normalization is always specified each time a; normalized values is requested from the PDF via the getVal(); method. RooAbsPdf manages the entire normalization logic of each PDF with; help of a RooRealIntegral object, which coordinates the integration; of a given choice of normalization. By default, RooRealIntegral will; perform a fully numeric integration of all dependents. However,; PDFs can advertise one or more (partial) analytical integrals of; their function, and these will be used by RooRealIntegral, if it; determines that this is safe (i.e. no hidden Jacobian terms,; multiplication with other PDFs that have one or more dependents in; commen etc). To implement analytical integrals, two functions must be implemented. First,. Int_t getAnalyticalIntegral(const RooArgSet& integSet, RooArgSet& anaIntSet). advertises the analytical integrals that are supported. 'integSet'; is the set of dependents for which integration is requested. The; function should copy the subset of dependents it can analytically; integrate to anaIntSet and return a unique identification code for; this integration configuration. If no integration can be; performed, zero should be returned. Second,. Double_t analyticalIntegral(Int_t code). Implements the actual analytical integral(s) advertised by; getAnalyticalIntegral. This functions will only be called with; codes returned by getAnalyticalIntegral, except code zero. The integration range for real each dependent to b",MatchSource.WIKI,root/html602/RooAbsPdf__GenSpec.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsPdf__GenSpec.html
https://root.cern/root/html602/RooAbsPdf__GenSpec.html:1698,Testability,log,logic,1698," part of a; probability density function, normalization is treated separately; in RooAbsPdf. The reason is that a RooAbsPdf object is more than a; PDF: it can be a building block for a more complex, composite PDF; if any of its variables are functions instead of variables. In; such cases the normalization of the composite may not be simply the; integral over the dependents of the top level PDF as these are; functions with potentially non-trivial Jacobian terms themselves.; Therefore. --> No explicit attempt should be made to normalize; the functions output in evaluate(). In addition, RooAbsPdf objects do not have a static concept of what; variables are parameters and what variables are dependents (which; need to be integrated over for a correct PDF normalization).; Instead the choice of normalization is always specified each time a; normalized values is requested from the PDF via the getVal(); method. RooAbsPdf manages the entire normalization logic of each PDF with; help of a RooRealIntegral object, which coordinates the integration; of a given choice of normalization. By default, RooRealIntegral will; perform a fully numeric integration of all dependents. However,; PDFs can advertise one or more (partial) analytical integrals of; their function, and these will be used by RooRealIntegral, if it; determines that this is safe (i.e. no hidden Jacobian terms,; multiplication with other PDFs that have one or more dependents in; commen etc). To implement analytical integrals, two functions must be implemented. First,. Int_t getAnalyticalIntegral(const RooArgSet& integSet, RooArgSet& anaIntSet). advertises the analytical integrals that are supported. 'integSet'; is the set of dependents for which integration is requested. The; function should copy the subset of dependents it can analytically; integrate to anaIntSet and return a unique identification code for; this integration configuration. If no integration can be; performed, zero should be returned. Second,. Double_t an",MatchSource.WIKI,root/html602/RooAbsPdf__GenSpec.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsPdf__GenSpec.html
https://root.cern/root/html602/RooAbsPdf__GenSpec.html:3282,Testability,assert,assert,3282,"e implemented. First,. Int_t getAnalyticalIntegral(const RooArgSet& integSet, RooArgSet& anaIntSet). advertises the analytical integrals that are supported. 'integSet'; is the set of dependents for which integration is requested. The; function should copy the subset of dependents it can analytically; integrate to anaIntSet and return a unique identification code for; this integration configuration. If no integration can be; performed, zero should be returned. Second,. Double_t analyticalIntegral(Int_t code). Implements the actual analytical integral(s) advertised by; getAnalyticalIntegral. This functions will only be called with; codes returned by getAnalyticalIntegral, except code zero. The integration range for real each dependent to be integrated can; be obtained from the dependents' proxy functions min() and; max(). Never call these proxy functions for any proxy not known to; be a dependent via the integration code. Doing so may be; ill-defined, e.g. in case the proxy holds a function, and will; trigger an assert. Integrated category dependents should always be; summed over all of their states. [Direct generation of observables]. Any PDF dependent can be generated with the accept/reject method,; but for certain PDFs more efficient methods may be implemented. To; implement direct generation of one or more observables, two; functions need to be implemented, similar to those for analytical; integrals:. Int_t getGenerator(const RooArgSet& generateVars, RooArgSet& directVars) and; void generateEvent(Int_t code). The first function advertises observables that can be generated,; similar to the way analytical integrals are advertised. The second; function implements the generator for the advertised observables. The generated dependent values should be store in the proxy; objects. For this the assignment operator can be used (i.e. xProxy; = 3.0 ). Never call assign to any proxy not known to be a dependent; via the generation code. Doing so may be ill-defined, e.g. in case",MatchSource.WIKI,root/html602/RooAbsPdf__GenSpec.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsPdf__GenSpec.html
https://root.cern/root/html602/RooAbsPdf__GenSpec.html:4307,Testability,assert,assert,4307," assert. Integrated category dependents should always be; summed over all of their states. [Direct generation of observables]. Any PDF dependent can be generated with the accept/reject method,; but for certain PDFs more efficient methods may be implemented. To; implement direct generation of one or more observables, two; functions need to be implemented, similar to those for analytical; integrals:. Int_t getGenerator(const RooArgSet& generateVars, RooArgSet& directVars) and; void generateEvent(Int_t code). The first function advertises observables that can be generated,; similar to the way analytical integrals are advertised. The second; function implements the generator for the advertised observables. The generated dependent values should be store in the proxy; objects. For this the assignment operator can be used (i.e. xProxy; = 3.0 ). Never call assign to any proxy not known to be a dependent; via the generation code. Doing so may be ill-defined, e.g. in case; the proxy holds a function, and will trigger an assert. Function Members (Methods); public:. virtual~GenSpec(); static TClass*Class(); RooAbsPdf::GenSpecGenSpec(); virtual TClass*IsA() const; RooAbsPdf::GenSpec&operator=(const RooAbsPdf::GenSpec&); virtual voidShowMembers(TMemberInspector& insp) const; virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b). private:. RooAbsPdf::GenSpecGenSpec(const RooAbsPdf::GenSpec& other); RooAbsPdf::GenSpecGenSpec(RooAbsGenContext* context, const RooArgSet& whatVars, RooDataSet* protoData, Int_t nGen, Bool_t extended, Bool_t randProto, Bool_t resampleProto, TString dsetName, Bool_t init = kFALSE). Data Members; private:. TString_dsetName; Bool_t_extended; RooAbsGenContext*_genContext; Bool_t_init; Int_t_nGen; RooDataSet*_protoData; Bool_t_randProto; Bool_t_resampleProto; RooArgSet_whatVars. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; ~GenSpec(). GenSpec(RooAbsGenContext* context, const Roo",MatchSource.WIKI,root/html602/RooAbsPdf__GenSpec.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsPdf__GenSpec.html
https://root.cern/root/html602/RooAbsPdf__GenSpec.html:1075,Usability,simpl,simply,1075,"rce file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » ROOFIT; » ROOFITCORE; » RooAbsPdf::GenSpec. class RooAbsPdf::GenSpec. RooAbsPdf is the abstract interface for all probability density; functions The class provides hybrid analytical/numerical; normalization for its implementations, error tracing and a MC; generator interface. A minimal implementation of a PDF class derived from RooAbsPdf; should overload the evaluate() function. This functions should; return PDFs value. [Normalization/Integration]. Although the normalization of a PDF is an integral part of a; probability density function, normalization is treated separately; in RooAbsPdf. The reason is that a RooAbsPdf object is more than a; PDF: it can be a building block for a more complex, composite PDF; if any of its variables are functions instead of variables. In; such cases the normalization of the composite may not be simply the; integral over the dependents of the top level PDF as these are; functions with potentially non-trivial Jacobian terms themselves.; Therefore. --> No explicit attempt should be made to normalize; the functions output in evaluate(). In addition, RooAbsPdf objects do not have a static concept of what; variables are parameters and what variables are dependents (which; need to be integrated over for a correct PDF normalization).; Instead the choice of normalization is always specified each time a; normalized values is requested from the PDF via the getVal(); method. RooAbsPdf manages the entire normalization logic of each PDF with; help of a RooRealIntegral object, which coordinates the integration; of a given choice of normalization. By default, RooRealIntegral will; perform a fully numeric integration of all dependents. However,; PDFs can advertise one or more (partial) analytical integrals of; their function, and these will be used by RooRealIntegral, if it; determines that this is safe (i.e. no hidden Jacobian ter",MatchSource.WIKI,root/html602/RooAbsPdf__GenSpec.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsPdf__GenSpec.html
https://root.cern/root/html602/RooAbsProxy.html:666,Availability,avail,available,666,". RooAbsProxy. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » ROOFIT; » ROOFITCORE; » RooAbsProxy. class RooAbsProxy. RooAbsProxy is the abstact interface for proxy classes.; Proxy classes hold pointers to other Roofit objects ; and process serverRedirect changes so that the proxied; pointers are updated accordingly on a clone or copy of; of the owning class; . Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~RooAbsProxy(); static TClass*Class(); virtual TClass*IsA() const; virtual const char*name() const; const RooArgSet*nset() const; RooAbsProxy&operator=(const RooAbsProxy&); virtual voidprint(ostream& os, Bool_t addContents = kFALSE) const; RooAbsProxy(); RooAbsProxy(const RooAbsProxy&); RooAbsProxy(const char* name, const RooAbsProxy& other); virtual voidShowMembers(TMemberInspector& insp) const; virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b). protected:. virtual voidchangeNormSet(const RooArgSet* newNormSet); virtual Bool_tchangePointer(const RooAbsCollection& newServerSet, Bool_t nameChange = kFALSE, Bool_t factoryInitMode = kFALSE). Data Members; protected:. RooArgSet*_nset! Normalization set to be used for evaluation of RooAbsPdf contents. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; RooAbsProxy(); Constructor. RooAbsProxy(const char* name, const RooAbsProxy& other); Copy constructor. void changeNormSet(const RooArgSet* newNormSet); Destructor. void print(ostream& os, Bool_t addContents = kFALSE) const; Print proxy name. RooAbsProxy(); Constructors, assignment etc. virtual ~RooAbsProxy(); Destructor. const char* name() const; Return name of proxy. const RooArgSet* nset() const; Ret",MatchSource.WIKI,root/html602/RooAbsProxy.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsProxy.html
https://root.cern/root/html602/RooAbsProxy.html:466,Deployability,update,updated,466,". RooAbsProxy. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » ROOFIT; » ROOFITCORE; » RooAbsProxy. class RooAbsProxy. RooAbsProxy is the abstact interface for proxy classes.; Proxy classes hold pointers to other Roofit objects ; and process serverRedirect changes so that the proxied; pointers are updated accordingly on a clone or copy of; of the owning class; . Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~RooAbsProxy(); static TClass*Class(); virtual TClass*IsA() const; virtual const char*name() const; const RooArgSet*nset() const; RooAbsProxy&operator=(const RooAbsProxy&); virtual voidprint(ostream& os, Bool_t addContents = kFALSE) const; RooAbsProxy(); RooAbsProxy(const RooAbsProxy&); RooAbsProxy(const char* name, const RooAbsProxy& other); virtual voidShowMembers(TMemberInspector& insp) const; virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b). protected:. virtual voidchangeNormSet(const RooArgSet* newNormSet); virtual Bool_tchangePointer(const RooAbsCollection& newServerSet, Bool_t nameChange = kFALSE, Bool_t factoryInitMode = kFALSE). Data Members; protected:. RooArgSet*_nset! Normalization set to be used for evaluation of RooAbsPdf contents. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; RooAbsProxy(); Constructor. RooAbsProxy(const char* name, const RooAbsProxy& other); Copy constructor. void changeNormSet(const RooArgSet* newNormSet); Destructor. void print(ostream& os, Bool_t addContents = kFALSE) const; Print proxy name. RooAbsProxy(); Constructors, assignment etc. virtual ~RooAbsProxy(); Destructor. const char* name() const; Return name of proxy. const RooArgSet* nset() const; Ret",MatchSource.WIKI,root/html602/RooAbsProxy.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsProxy.html
https://root.cern/root/html602/RooAbsProxy.html:313,Integrability,interface,interface,313,". RooAbsProxy. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » ROOFIT; » ROOFITCORE; » RooAbsProxy. class RooAbsProxy. RooAbsProxy is the abstact interface for proxy classes.; Proxy classes hold pointers to other Roofit objects ; and process serverRedirect changes so that the proxied; pointers are updated accordingly on a clone or copy of; of the owning class; . Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~RooAbsProxy(); static TClass*Class(); virtual TClass*IsA() const; virtual const char*name() const; const RooArgSet*nset() const; RooAbsProxy&operator=(const RooAbsProxy&); virtual voidprint(ostream& os, Bool_t addContents = kFALSE) const; RooAbsProxy(); RooAbsProxy(const RooAbsProxy&); RooAbsProxy(const char* name, const RooAbsProxy& other); virtual voidShowMembers(TMemberInspector& insp) const; virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b). protected:. virtual voidchangeNormSet(const RooArgSet* newNormSet); virtual Bool_tchangePointer(const RooAbsCollection& newServerSet, Bool_t nameChange = kFALSE, Bool_t factoryInitMode = kFALSE). Data Members; protected:. RooArgSet*_nset! Normalization set to be used for evaluation of RooAbsPdf contents. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; RooAbsProxy(); Constructor. RooAbsProxy(const char* name, const RooAbsProxy& other); Copy constructor. void changeNormSet(const RooArgSet* newNormSet); Destructor. void print(ostream& os, Bool_t addContents = kFALSE) const; Print proxy name. RooAbsProxy(); Constructors, assignment etc. virtual ~RooAbsProxy(); Destructor. const char* name() const; Return name of proxy. const RooArgSet* nset() const; Ret",MatchSource.WIKI,root/html602/RooAbsProxy.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsProxy.html
https://root.cern/root/html602/RooAbsReal.html:822,Availability,avail,available,822,". RooAbsReal. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » ROOFIT; » ROOFITCORE; » RooAbsReal. class RooAbsReal: public RooAbsArg. RooAbsReal is the common abstract base class for objects that represent a; real value and implements functionality common to all real-valued objects; such as the ability to plot them, to construct integrals of them, the; ability to advertise (partial) analytical integrals etc..; Implementation of RooAbsReal may be derived, thus no interface; is provided to modify the contents.; ; ; . Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~RooAbsReal(); voidTObject::AbstractMethod(const char* method) const; Bool_tRooAbsArg::addOwnedComponents(const RooArgSet& comps); voidRooAbsArg::addParameters(RooArgSet& params, const RooArgSet* nset = 0, Bool_t stripDisconnected = kTRUE) const; voidRooAbsArg::addServer(RooAbsArg& server, Bool_t valueProp = kTRUE, Bool_t shapeProp = kFALSE); voidRooAbsArg::addServerList(RooAbsCollection& serverList, Bool_t valueProp = kTRUE, Bool_t shapeProp = kFALSE); const char*RooAbsArg::aggregateCacheUniqueSuffix() const; virtual Double_tanalyticalIntegral(Int_t code, const char* rangeName = 0) const; virtual Double_tanalyticalIntegralWN(Int_t code, const RooArgSet* normSet, const char* rangeName = 0) const; virtual voidTObject::AppendPad(Option_t* option = """"); TF1*asTF(const RooArgList& obs, const RooArgList& pars = RooArgList(), const RooArgSet& nset = RooArgSet()) const; voidRooAbsArg::attachDataSet(const RooAbsData& set); voidRooAbsArg::attachDataStore(const RooAbsDataStore& set); const set<string>&RooAbsArg::attributes() const; virtual list<Double_t>*binBoundaries(RooAbsRealLValue&, Double_t, Double_t) const; RooAbsFunc*bindVa",MatchSource.WIKI,root/html602/RooAbsReal.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsReal.html
https://root.cern/root/html602/RooAbsReal.html:9922,Availability,error,error,9922,,MatchSource.WIKI,root/html602/RooAbsReal.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsReal.html
https://root.cern/root/html602/RooAbsReal.html:10006,Availability,error,error,10006,,MatchSource.WIKI,root/html602/RooAbsReal.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsReal.html
https://root.cern/root/html602/RooAbsReal.html:37271,Availability,error,error,37271,"name, const char* title, Double_t minVal, Double_t maxVal, const char* unit = """"); Constructor with plot range and unit label. RooAbsReal(const RooAbsReal& other, const char* name = 0); coverity[UNINIT_CTOR]; Copy constructor. ~RooAbsReal(); Destructor. Bool_t operator==(Double_t value) const; Equality operator comparing to a Double_t. Bool_t operator==(const RooAbsArg& other); Equality operator when comparing to another RooAbsArg.; Only functional when the other arg is a RooAbsReal. Bool_t isIdentical(const RooAbsArg& other, Bool_t assumeSameType = kFALSE). TString getTitle(Bool_t appendUnit = kFALSE) const; Return this variable's title string. If appendUnit is true and; this variable has units, also append a string "" (<unit>)"". Double_t getValV(const RooArgSet* set = 0) const; Return value of object. If the cache is clean, return the; cached value, otherwise recalculate on the fly and refill; the cache. Int_t numEvalErrorItems(). Double_t traceEval(const RooArgSet* set) const; Calculate current value of object, with error tracing wrapper. Int_t getAnalyticalIntegralWN(RooArgSet& allVars, RooArgSet& analVars, const RooArgSet* normSet, const char* rangeName = 0) const; Variant of getAnalyticalIntegral that is also passed the normalization set; that should be applied to the integrand of which the integral is request.; For certain operator p.d.f it is useful to overload this function rather; than analyticalIntegralWN() as the additional normalization information; may be useful in determining a more efficient decomposition of the; requested integral. Int_t getAnalyticalIntegral(RooArgSet& allVars, RooArgSet& analVars, const char* rangeName = 0) const; Interface function getAnalyticalIntergral advertises the; analytical integrals that are supported. 'integSet'; is the set of dependents for which integration is requested. The; function should copy the subset of dependents it can analytically; integrate to anaIntSet and return a unique identification code for; this integra",MatchSource.WIKI,root/html602/RooAbsReal.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsReal.html
https://root.cern/root/html602/RooAbsReal.html:44312,Availability,error,error,44312,"Utility function for plotOn() that creates a projection of a function or p.d.f; to be plotted on a RooPlot. const RooAbsReal* createPlotProjection(const RooArgSet& depVars, const RooArgSet& projVars) const; Utility function for plotOn() that creates a projection of a function or p.d.f; to be plotted on a RooPlot. const RooAbsReal * createPlotProjection(const RooArgSet& dependentVars, const RooArgSet* projectedVars, RooArgSet*& cloneSet, const char* rangeName = 0, const RooArgSet* condObs = 0) const; Utility function for plotOn() that creates a projection of a function or p.d.f; to be plotted on a RooPlot. Create a new object G that represents the normalized projection:. Integral [ F[x,y,p] , { y } ]; G[x,p] = ---------------------------------; Integral [ F[x,y,p] , { x,y } ]. where F[x,y,p] is the function we represent, ""x"" are the; specified dependentVars, ""y"" are the specified projectedVars, and; ""p"" are our remaining variables (""parameters""). Return a; pointer to the newly created object, or else zero in case of an; error. The caller is responsible for deleting the contents of; cloneSet (which includes the returned projection object). TH1 * fillHistogram(TH1* hist, const RooArgList& plotVars, Double_t scaleFactor = 1, const RooArgSet* projectedVars = 0, Bool_t scaling = kTRUE, const RooArgSet* condObs = 0, Bool_t setError = kTRUE) const; Fill the ROOT histogram 'hist' with values sampled from this; function at the bin centers. Our value is calculated by first; integrating out any variables in projectedVars and then scaling; the result by scaleFactor. Returns a pointer to the input; histogram, or zero in case of an error. The input histogram can; be any TH1 subclass, and therefore of arbitrary; dimension. Variables are matched with the (x,y,...) dimensions of; the input histogram according to the order in which they appear; in the input plotVars list. If scaleForDensity is true the; histogram is filled with a the functions density rather than; the functions value ",MatchSource.WIKI,root/html602/RooAbsReal.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsReal.html
https://root.cern/root/html602/RooAbsReal.html:44922,Availability,error,error,44922,"eate a new object G that represents the normalized projection:. Integral [ F[x,y,p] , { y } ]; G[x,p] = ---------------------------------; Integral [ F[x,y,p] , { x,y } ]. where F[x,y,p] is the function we represent, ""x"" are the; specified dependentVars, ""y"" are the specified projectedVars, and; ""p"" are our remaining variables (""parameters""). Return a; pointer to the newly created object, or else zero in case of an; error. The caller is responsible for deleting the contents of; cloneSet (which includes the returned projection object). TH1 * fillHistogram(TH1* hist, const RooArgList& plotVars, Double_t scaleFactor = 1, const RooArgSet* projectedVars = 0, Bool_t scaling = kTRUE, const RooArgSet* condObs = 0, Bool_t setError = kTRUE) const; Fill the ROOT histogram 'hist' with values sampled from this; function at the bin centers. Our value is calculated by first; integrating out any variables in projectedVars and then scaling; the result by scaleFactor. Returns a pointer to the input; histogram, or zero in case of an error. The input histogram can; be any TH1 subclass, and therefore of arbitrary; dimension. Variables are matched with the (x,y,...) dimensions of; the input histogram according to the order in which they appear; in the input plotVars list. If scaleForDensity is true the; histogram is filled with a the functions density rather than; the functions value (i.e. the value at the bin center is multiplied; with bin volume). RooDataHist* fillDataHist(RooDataHist* hist, const RooArgSet* nset, Double_t scaleFactor, Bool_t correctForBinVolume = kFALSE, Bool_t showProgress = kFALSE) const; Fill a RooDataHist with values sampled from this function at the; bin centers. If extendedMode is true, the p.d.f. values is multiplied; by the number of expected events in each bin. An optional scaling by a given scaleFactor can be performed.; Returns a pointer to the input RooDataHist, or zero; in case of an error. If correctForBinSize is true the RooDataHist; is filled with the ",MatchSource.WIKI,root/html602/RooAbsReal.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsReal.html
https://root.cern/root/html602/RooAbsReal.html:45820,Availability,error,error,45820,"iables in projectedVars and then scaling; the result by scaleFactor. Returns a pointer to the input; histogram, or zero in case of an error. The input histogram can; be any TH1 subclass, and therefore of arbitrary; dimension. Variables are matched with the (x,y,...) dimensions of; the input histogram according to the order in which they appear; in the input plotVars list. If scaleForDensity is true the; histogram is filled with a the functions density rather than; the functions value (i.e. the value at the bin center is multiplied; with bin volume). RooDataHist* fillDataHist(RooDataHist* hist, const RooArgSet* nset, Double_t scaleFactor, Bool_t correctForBinVolume = kFALSE, Bool_t showProgress = kFALSE) const; Fill a RooDataHist with values sampled from this function at the; bin centers. If extendedMode is true, the p.d.f. values is multiplied; by the number of expected events in each bin. An optional scaling by a given scaleFactor can be performed.; Returns a pointer to the input RooDataHist, or zero; in case of an error. If correctForBinSize is true the RooDataHist; is filled with the functions density (function value times the; bin volume) rather than function value. If showProgress is true; a process indicator is printed on stdout in steps of one percent,; which is mostly useful for the sampling of expensive functions; such as likelihoods. TH1* createHistogram(const char* varNameList, Int_t xbins = 0, Int_t ybins = 0, Int_t zbins = 0) const; Create and fill a ROOT histogram TH1,TH2 or TH3 with the values of this function for the variables with given names; The number of bins can be controlled using the [xyz]bins parameters. For a greater degree of control; use the createHistogram() method below with named arguments. The caller takes ownership of the returned histogram. TH1 * createHistogram(const char* name, const RooAbsRealLValue& xvar, const RooCmdArg& arg1 = RooCmdArg::none(), const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none()",MatchSource.WIKI,root/html602/RooAbsReal.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsReal.html
https://root.cern/root/html602/RooAbsReal.html:51678,Availability,error,errors,51678,"ignoring the default projection behavior. Advanced use only. ProjWData(const RooAbsData& d) -- Override default projection _technique_ (integration). For observables present in given dataset; projection of PDF is achieved by constructing an average over all observable values in given set.; Consult RooFit plotting tutorial for further explanation of meaning & use of this technique. ProjWData(const RooArgSet& s, -- As above but only consider subset 's' of observables in dataset 'd' for projection through data averaging; const RooAbsData& d). ProjectionRange(const char* rn) -- Override default range of projection integrals to a different range speficied by given range name.; This technique allows you to project a finite width slice in a real-valued observable. NumCPU(Int_t ncpu) -- Number of CPUs to use simultaneously to calculate data-weighted projections (only in combination with ProjWData). Misc content control. PrintEvalErrors(Int_t numErr) -- Control number of p.d.f evaluation errors printed per curve. A negative; value suppress output completely, a zero value will only print the error count per p.d.f component,; a positive value is will print details of each error up to numErr messages per p.d.f component. EvalErrorValue(Double_t value) -- Set curve points at which (pdf) evaluation error occur to specified value. By default the; function value is plotted. Normalization(Double_t scale, -- Adjust normalization by given scale factor. Interpretation of number depends on code: Relative:; ScaleType code) relative adjustment factor, NumEvent: scale to match given number of events. Name(const chat* name) -- Give curve specified name in frame. Useful if curve is to be referenced later. Asymmetry(const RooCategory& c) -- Show the asymmetry of the PDF in given two-state category [F(+)-F(-)] / [F(+)+F(-)] rather than; the PDF projection. Category must have two states with indices -1 and +1 or three states with; indeces -1,0 and +1. ShiftToZero(Bool_t flag) -- Shift entire cu",MatchSource.WIKI,root/html602/RooAbsReal.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsReal.html
https://root.cern/root/html602/RooAbsReal.html:51783,Availability,error,error,51783,"ta(const RooAbsData& d) -- Override default projection _technique_ (integration). For observables present in given dataset; projection of PDF is achieved by constructing an average over all observable values in given set.; Consult RooFit plotting tutorial for further explanation of meaning & use of this technique. ProjWData(const RooArgSet& s, -- As above but only consider subset 's' of observables in dataset 'd' for projection through data averaging; const RooAbsData& d). ProjectionRange(const char* rn) -- Override default range of projection integrals to a different range speficied by given range name.; This technique allows you to project a finite width slice in a real-valued observable. NumCPU(Int_t ncpu) -- Number of CPUs to use simultaneously to calculate data-weighted projections (only in combination with ProjWData). Misc content control. PrintEvalErrors(Int_t numErr) -- Control number of p.d.f evaluation errors printed per curve. A negative; value suppress output completely, a zero value will only print the error count per p.d.f component,; a positive value is will print details of each error up to numErr messages per p.d.f component. EvalErrorValue(Double_t value) -- Set curve points at which (pdf) evaluation error occur to specified value. By default the; function value is plotted. Normalization(Double_t scale, -- Adjust normalization by given scale factor. Interpretation of number depends on code: Relative:; ScaleType code) relative adjustment factor, NumEvent: scale to match given number of events. Name(const chat* name) -- Give curve specified name in frame. Useful if curve is to be referenced later. Asymmetry(const RooCategory& c) -- Show the asymmetry of the PDF in given two-state category [F(+)-F(-)] / [F(+)+F(-)] rather than; the PDF projection. Category must have two states with indices -1 and +1 or three states with; indeces -1,0 and +1. ShiftToZero(Bool_t flag) -- Shift entire curve such that lowest visible point is at exactly zero. Mostly useful",MatchSource.WIKI,root/html602/RooAbsReal.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsReal.html
https://root.cern/root/html602/RooAbsReal.html:51864,Availability,error,error,51864,"present in given dataset; projection of PDF is achieved by constructing an average over all observable values in given set.; Consult RooFit plotting tutorial for further explanation of meaning & use of this technique. ProjWData(const RooArgSet& s, -- As above but only consider subset 's' of observables in dataset 'd' for projection through data averaging; const RooAbsData& d). ProjectionRange(const char* rn) -- Override default range of projection integrals to a different range speficied by given range name.; This technique allows you to project a finite width slice in a real-valued observable. NumCPU(Int_t ncpu) -- Number of CPUs to use simultaneously to calculate data-weighted projections (only in combination with ProjWData). Misc content control. PrintEvalErrors(Int_t numErr) -- Control number of p.d.f evaluation errors printed per curve. A negative; value suppress output completely, a zero value will only print the error count per p.d.f component,; a positive value is will print details of each error up to numErr messages per p.d.f component. EvalErrorValue(Double_t value) -- Set curve points at which (pdf) evaluation error occur to specified value. By default the; function value is plotted. Normalization(Double_t scale, -- Adjust normalization by given scale factor. Interpretation of number depends on code: Relative:; ScaleType code) relative adjustment factor, NumEvent: scale to match given number of events. Name(const chat* name) -- Give curve specified name in frame. Useful if curve is to be referenced later. Asymmetry(const RooCategory& c) -- Show the asymmetry of the PDF in given two-state category [F(+)-F(-)] / [F(+)+F(-)] rather than; the PDF projection. Category must have two states with indices -1 and +1 or three states with; indeces -1,0 and +1. ShiftToZero(Bool_t flag) -- Shift entire curve such that lowest visible point is at exactly zero. Mostly useful when; plotting -log(L) or chi^2 distributions. AddTo(const char* name, -- Add constructed projecti",MatchSource.WIKI,root/html602/RooAbsReal.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsReal.html
https://root.cern/root/html602/RooAbsReal.html:51990,Availability,error,error,51990,"en set.; Consult RooFit plotting tutorial for further explanation of meaning & use of this technique. ProjWData(const RooArgSet& s, -- As above but only consider subset 's' of observables in dataset 'd' for projection through data averaging; const RooAbsData& d). ProjectionRange(const char* rn) -- Override default range of projection integrals to a different range speficied by given range name.; This technique allows you to project a finite width slice in a real-valued observable. NumCPU(Int_t ncpu) -- Number of CPUs to use simultaneously to calculate data-weighted projections (only in combination with ProjWData). Misc content control. PrintEvalErrors(Int_t numErr) -- Control number of p.d.f evaluation errors printed per curve. A negative; value suppress output completely, a zero value will only print the error count per p.d.f component,; a positive value is will print details of each error up to numErr messages per p.d.f component. EvalErrorValue(Double_t value) -- Set curve points at which (pdf) evaluation error occur to specified value. By default the; function value is plotted. Normalization(Double_t scale, -- Adjust normalization by given scale factor. Interpretation of number depends on code: Relative:; ScaleType code) relative adjustment factor, NumEvent: scale to match given number of events. Name(const chat* name) -- Give curve specified name in frame. Useful if curve is to be referenced later. Asymmetry(const RooCategory& c) -- Show the asymmetry of the PDF in given two-state category [F(+)-F(-)] / [F(+)+F(-)] rather than; the PDF projection. Category must have two states with indices -1 and +1 or three states with; indeces -1,0 and +1. ShiftToZero(Bool_t flag) -- Shift entire curve such that lowest visible point is at exactly zero. Mostly useful when; plotting -log(L) or chi^2 distributions. AddTo(const char* name, -- Add constructed projection to already existing curve with given name and relative weight factors; double_t wgtSelf, double_t wgtOther). Plot",MatchSource.WIKI,root/html602/RooAbsReal.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsReal.html
https://root.cern/root/html602/RooAbsReal.html:53435,Availability,down,downward,53435,"given two-state category [F(+)-F(-)] / [F(+)+F(-)] rather than; the PDF projection. Category must have two states with indices -1 and +1 or three states with; indeces -1,0 and +1. ShiftToZero(Bool_t flag) -- Shift entire curve such that lowest visible point is at exactly zero. Mostly useful when; plotting -log(L) or chi^2 distributions. AddTo(const char* name, -- Add constructed projection to already existing curve with given name and relative weight factors; double_t wgtSelf, double_t wgtOther). Plotting control. DrawOption(const char* opt) -- Select ROOT draw option for resulting TGraph object. LineStyle(Int_t style) -- Select line style by ROOT line style code, default is solid. LineColor(Int_t color) -- Select line color by ROOT color code, default is blue. LineWidth(Int_t width) -- Select line with in pixels, default is 3. FillStyle(Int_t style) -- Select fill style, default is not filled. If a filled style is selected, also use VLines(); to add vertical downward lines at end of curve to ensure proper closure; FillColor(Int_t color) -- Select fill color by ROOT color code. Range(const char* name) -- Only draw curve in range defined by given name. Range(double lo, double hi) -- Only draw curve in specified range. VLines() -- Add vertical lines to y=0 at end points of curve. Precision(Double_t eps) -- Control precision of drawn curve w.r.t to scale of plot, default is 1e-3. Higher precision; will result in more and more densely spaced curve points. Invisible(Bool_t flag) -- Add curve to frame, but do not display. Useful in combination AddTo(). VisualizeError(const RooFitResult& fitres, Double_t Z=1, Bool_t linearMethod=kTRUE); -- Visualize the uncertainty on the parameters, as given in fitres, at 'Z' sigma'. VisualizeError(const RooFitResult& fitres, const RooArgSet& param, Double_t Z=1, Bool_t linearMethod=kTRUE) ;; -- Visualize the uncertainty on the subset of parameters 'param', as given in fitres, at 'Z' sigma'. Details on error band visualization. By default ",MatchSource.WIKI,root/html602/RooAbsReal.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsReal.html
https://root.cern/root/html602/RooAbsReal.html:54425,Availability,error,error,54425,"cal downward lines at end of curve to ensure proper closure; FillColor(Int_t color) -- Select fill color by ROOT color code. Range(const char* name) -- Only draw curve in range defined by given name. Range(double lo, double hi) -- Only draw curve in specified range. VLines() -- Add vertical lines to y=0 at end points of curve. Precision(Double_t eps) -- Control precision of drawn curve w.r.t to scale of plot, default is 1e-3. Higher precision; will result in more and more densely spaced curve points. Invisible(Bool_t flag) -- Add curve to frame, but do not display. Useful in combination AddTo(). VisualizeError(const RooFitResult& fitres, Double_t Z=1, Bool_t linearMethod=kTRUE); -- Visualize the uncertainty on the parameters, as given in fitres, at 'Z' sigma'. VisualizeError(const RooFitResult& fitres, const RooArgSet& param, Double_t Z=1, Bool_t linearMethod=kTRUE) ;; -- Visualize the uncertainty on the subset of parameters 'param', as given in fitres, at 'Z' sigma'. Details on error band visualization. By default (linMethod=kTRUE) a linearized error is shown which is calculated as follows; T; error(x) = Z* F_a(x) * Corr(a,a') F_a'(x). where F_a(x) = [ f(x,a+da) - f(x,a-da) ] / 2, with f(x) the plotted curve and 'da' taken from the fit result; Corr(a,a') = the correlation matrix from the fit result; Z = requested significance 'Z sigma band'. The linear method is fast (required 2*N evaluations of the curve, where N is the number of parameters), but may; not be accurate in the presence of strong correlations (~>0.9) and at Z>2 due to linear and Gaussian approximations made. Alternatively (linMethod=kFALSE), a more robust error is calculated using a sampling method. In this method a number of curves; is calculated with variations of the parameter values, as drawn from a multi-variate Gaussian p.d.f. that is constructed; from the fit results covariance matrix. The error(x) is determined by calculating a central interval that capture N% of the variations; for each valye ",MatchSource.WIKI,root/html602/RooAbsReal.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsReal.html
https://root.cern/root/html602/RooAbsReal.html:54493,Availability,error,error,54493," Select fill color by ROOT color code. Range(const char* name) -- Only draw curve in range defined by given name. Range(double lo, double hi) -- Only draw curve in specified range. VLines() -- Add vertical lines to y=0 at end points of curve. Precision(Double_t eps) -- Control precision of drawn curve w.r.t to scale of plot, default is 1e-3. Higher precision; will result in more and more densely spaced curve points. Invisible(Bool_t flag) -- Add curve to frame, but do not display. Useful in combination AddTo(). VisualizeError(const RooFitResult& fitres, Double_t Z=1, Bool_t linearMethod=kTRUE); -- Visualize the uncertainty on the parameters, as given in fitres, at 'Z' sigma'. VisualizeError(const RooFitResult& fitres, const RooArgSet& param, Double_t Z=1, Bool_t linearMethod=kTRUE) ;; -- Visualize the uncertainty on the subset of parameters 'param', as given in fitres, at 'Z' sigma'. Details on error band visualization. By default (linMethod=kTRUE) a linearized error is shown which is calculated as follows; T; error(x) = Z* F_a(x) * Corr(a,a') F_a'(x). where F_a(x) = [ f(x,a+da) - f(x,a-da) ] / 2, with f(x) the plotted curve and 'da' taken from the fit result; Corr(a,a') = the correlation matrix from the fit result; Z = requested significance 'Z sigma band'. The linear method is fast (required 2*N evaluations of the curve, where N is the number of parameters), but may; not be accurate in the presence of strong correlations (~>0.9) and at Z>2 due to linear and Gaussian approximations made. Alternatively (linMethod=kFALSE), a more robust error is calculated using a sampling method. In this method a number of curves; is calculated with variations of the parameter values, as drawn from a multi-variate Gaussian p.d.f. that is constructed; from the fit results covariance matrix. The error(x) is determined by calculating a central interval that capture N% of the variations; for each valye of x, where N% is controlled by Z (i.e. Z=1 gives N=68%). The number of sampling curve",MatchSource.WIKI,root/html602/RooAbsReal.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsReal.html
https://root.cern/root/html602/RooAbsReal.html:54543,Availability,error,error,54543," Select fill color by ROOT color code. Range(const char* name) -- Only draw curve in range defined by given name. Range(double lo, double hi) -- Only draw curve in specified range. VLines() -- Add vertical lines to y=0 at end points of curve. Precision(Double_t eps) -- Control precision of drawn curve w.r.t to scale of plot, default is 1e-3. Higher precision; will result in more and more densely spaced curve points. Invisible(Bool_t flag) -- Add curve to frame, but do not display. Useful in combination AddTo(). VisualizeError(const RooFitResult& fitres, Double_t Z=1, Bool_t linearMethod=kTRUE); -- Visualize the uncertainty on the parameters, as given in fitres, at 'Z' sigma'. VisualizeError(const RooFitResult& fitres, const RooArgSet& param, Double_t Z=1, Bool_t linearMethod=kTRUE) ;; -- Visualize the uncertainty on the subset of parameters 'param', as given in fitres, at 'Z' sigma'. Details on error band visualization. By default (linMethod=kTRUE) a linearized error is shown which is calculated as follows; T; error(x) = Z* F_a(x) * Corr(a,a') F_a'(x). where F_a(x) = [ f(x,a+da) - f(x,a-da) ] / 2, with f(x) the plotted curve and 'da' taken from the fit result; Corr(a,a') = the correlation matrix from the fit result; Z = requested significance 'Z sigma band'. The linear method is fast (required 2*N evaluations of the curve, where N is the number of parameters), but may; not be accurate in the presence of strong correlations (~>0.9) and at Z>2 due to linear and Gaussian approximations made. Alternatively (linMethod=kFALSE), a more robust error is calculated using a sampling method. In this method a number of curves; is calculated with variations of the parameter values, as drawn from a multi-variate Gaussian p.d.f. that is constructed; from the fit results covariance matrix. The error(x) is determined by calculating a central interval that capture N% of the variations; for each valye of x, where N% is controlled by Z (i.e. Z=1 gives N=68%). The number of sampling curve",MatchSource.WIKI,root/html602/RooAbsReal.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsReal.html
https://root.cern/root/html602/RooAbsReal.html:55072,Availability,robust,robust,55072," Double_t Z=1, Bool_t linearMethod=kTRUE); -- Visualize the uncertainty on the parameters, as given in fitres, at 'Z' sigma'. VisualizeError(const RooFitResult& fitres, const RooArgSet& param, Double_t Z=1, Bool_t linearMethod=kTRUE) ;; -- Visualize the uncertainty on the subset of parameters 'param', as given in fitres, at 'Z' sigma'. Details on error band visualization. By default (linMethod=kTRUE) a linearized error is shown which is calculated as follows; T; error(x) = Z* F_a(x) * Corr(a,a') F_a'(x). where F_a(x) = [ f(x,a+da) - f(x,a-da) ] / 2, with f(x) the plotted curve and 'da' taken from the fit result; Corr(a,a') = the correlation matrix from the fit result; Z = requested significance 'Z sigma band'. The linear method is fast (required 2*N evaluations of the curve, where N is the number of parameters), but may; not be accurate in the presence of strong correlations (~>0.9) and at Z>2 due to linear and Gaussian approximations made. Alternatively (linMethod=kFALSE), a more robust error is calculated using a sampling method. In this method a number of curves; is calculated with variations of the parameter values, as drawn from a multi-variate Gaussian p.d.f. that is constructed; from the fit results covariance matrix. The error(x) is determined by calculating a central interval that capture N% of the variations; for each valye of x, where N% is controlled by Z (i.e. Z=1 gives N=68%). The number of sampling curves is chosen to be such; that at least 30 curves are expected to be outside the N% interval, and is minimally 100 (e.g. Z=1->Ncurve=100, Z=2->Ncurve=659, Z=3->Ncurve=11111); Intervals from the sampling method can be asymmetric, and may perform better in the presence of strong correlations, but may take (much); longer to calculate. RooPlot* plotOn(RooPlot* frame, RooLinkedList& cmdList) const; Internal back-end function of plotOn() with named arguments. RooPlot* plotOn(RooPlot* frame, RooAbsReal::PlotOpt o) const; Plotting engine function for internal use",MatchSource.WIKI,root/html602/RooAbsReal.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsReal.html
https://root.cern/root/html602/RooAbsReal.html:55079,Availability,error,error,55079," Double_t Z=1, Bool_t linearMethod=kTRUE); -- Visualize the uncertainty on the parameters, as given in fitres, at 'Z' sigma'. VisualizeError(const RooFitResult& fitres, const RooArgSet& param, Double_t Z=1, Bool_t linearMethod=kTRUE) ;; -- Visualize the uncertainty on the subset of parameters 'param', as given in fitres, at 'Z' sigma'. Details on error band visualization. By default (linMethod=kTRUE) a linearized error is shown which is calculated as follows; T; error(x) = Z* F_a(x) * Corr(a,a') F_a'(x). where F_a(x) = [ f(x,a+da) - f(x,a-da) ] / 2, with f(x) the plotted curve and 'da' taken from the fit result; Corr(a,a') = the correlation matrix from the fit result; Z = requested significance 'Z sigma band'. The linear method is fast (required 2*N evaluations of the curve, where N is the number of parameters), but may; not be accurate in the presence of strong correlations (~>0.9) and at Z>2 due to linear and Gaussian approximations made. Alternatively (linMethod=kFALSE), a more robust error is calculated using a sampling method. In this method a number of curves; is calculated with variations of the parameter values, as drawn from a multi-variate Gaussian p.d.f. that is constructed; from the fit results covariance matrix. The error(x) is determined by calculating a central interval that capture N% of the variations; for each valye of x, where N% is controlled by Z (i.e. Z=1 gives N=68%). The number of sampling curves is chosen to be such; that at least 30 curves are expected to be outside the N% interval, and is minimally 100 (e.g. Z=1->Ncurve=100, Z=2->Ncurve=659, Z=3->Ncurve=11111); Intervals from the sampling method can be asymmetric, and may perform better in the presence of strong correlations, but may take (much); longer to calculate. RooPlot* plotOn(RooPlot* frame, RooLinkedList& cmdList) const; Internal back-end function of plotOn() with named arguments. RooPlot* plotOn(RooPlot* frame, RooAbsReal::PlotOpt o) const; Plotting engine function for internal use",MatchSource.WIKI,root/html602/RooAbsReal.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsReal.html
https://root.cern/root/html602/RooAbsReal.html:55325,Availability,error,error,55325,"res, at 'Z' sigma'. Details on error band visualization. By default (linMethod=kTRUE) a linearized error is shown which is calculated as follows; T; error(x) = Z* F_a(x) * Corr(a,a') F_a'(x). where F_a(x) = [ f(x,a+da) - f(x,a-da) ] / 2, with f(x) the plotted curve and 'da' taken from the fit result; Corr(a,a') = the correlation matrix from the fit result; Z = requested significance 'Z sigma band'. The linear method is fast (required 2*N evaluations of the curve, where N is the number of parameters), but may; not be accurate in the presence of strong correlations (~>0.9) and at Z>2 due to linear and Gaussian approximations made. Alternatively (linMethod=kFALSE), a more robust error is calculated using a sampling method. In this method a number of curves; is calculated with variations of the parameter values, as drawn from a multi-variate Gaussian p.d.f. that is constructed; from the fit results covariance matrix. The error(x) is determined by calculating a central interval that capture N% of the variations; for each valye of x, where N% is controlled by Z (i.e. Z=1 gives N=68%). The number of sampling curves is chosen to be such; that at least 30 curves are expected to be outside the N% interval, and is minimally 100 (e.g. Z=1->Ncurve=100, Z=2->Ncurve=659, Z=3->Ncurve=11111); Intervals from the sampling method can be asymmetric, and may perform better in the presence of strong correlations, but may take (much); longer to calculate. RooPlot* plotOn(RooPlot* frame, RooLinkedList& cmdList) const; Internal back-end function of plotOn() with named arguments. RooPlot* plotOn(RooPlot* frame, RooAbsReal::PlotOpt o) const; Plotting engine function for internal use. Plot ourselves on given frame. If frame contains a histogram, all dimensions of the plotted; function that occur in the previously plotted dataset are projected via partial integration,; otherwise no projections are performed. Optionally, certain projections can be performed; by summing over the values present in a",MatchSource.WIKI,root/html602/RooAbsReal.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsReal.html
https://root.cern/root/html602/RooAbsReal.html:56528,Availability,error,errors,56528,"sen to be such; that at least 30 curves are expected to be outside the N% interval, and is minimally 100 (e.g. Z=1->Ncurve=100, Z=2->Ncurve=659, Z=3->Ncurve=11111); Intervals from the sampling method can be asymmetric, and may perform better in the presence of strong correlations, but may take (much); longer to calculate. RooPlot* plotOn(RooPlot* frame, RooLinkedList& cmdList) const; Internal back-end function of plotOn() with named arguments. RooPlot* plotOn(RooPlot* frame, RooAbsReal::PlotOpt o) const; Plotting engine function for internal use. Plot ourselves on given frame. If frame contains a histogram, all dimensions of the plotted; function that occur in the previously plotted dataset are projected via partial integration,; otherwise no projections are performed. Optionally, certain projections can be performed; by summing over the values present in a provided dataset ('projData'), to correctly; project out data dependents that are not properly described by the PDF (e.g. per-event errors). The functions value can be multiplied with an optional scale factor. The interpretation; of the scale factor is unique for generic real functions, for PDFs there are various interpretations; possible, which can be selection with 'stype' (see RooAbsPdf::plotOn() for details). The default projection behaviour can be overriden by supplying an optional set of dependents; to project. For most cases, plotSliceOn() and plotProjOn() provide a more intuitive interface; to modify the default projection behavour. RooPlot* plotSliceOn(RooPlot* frame, const RooArgSet& sliceSet, Option_t* drawOptions = ""L"", Double_t scaleFactor = 1., RooAbsReal::ScaleType stype = Relative, const RooAbsData* projData = 0) const; OBSOLETE -- RETAINED FOR BACKWARD COMPATIBILITY. Use the plotOn(frame,Slice(...)) instead. RooPlot* plotAsymOn(RooPlot* frame, const RooAbsCategoryLValue& asymCat, RooAbsReal::PlotOpt o) const; Plotting engine for asymmetries. Implements the functionality if plotOn(frame,Asymmetry(.",MatchSource.WIKI,root/html602/RooAbsReal.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsReal.html
https://root.cern/root/html602/RooAbsReal.html:58107,Availability,error,error,58107,"bsReal::ScaleType stype = Relative, const RooAbsData* projData = 0) const; OBSOLETE -- RETAINED FOR BACKWARD COMPATIBILITY. Use the plotOn(frame,Slice(...)) instead. RooPlot* plotAsymOn(RooPlot* frame, const RooAbsCategoryLValue& asymCat, RooAbsReal::PlotOpt o) const; Plotting engine for asymmetries. Implements the functionality if plotOn(frame,Asymmetry(...))). Plot asymmetry of ourselves, defined as. asym = f(asymCat=-1) - f(asymCat=+1) / ( f(asymCat=-1) + f(asymCat=+1) ). on frame. If frame contains a histogram, all dimensions of the plotted; asymmetry function that occur in the previously plotted dataset are projected via partial integration.; Otherwise no projections are performed,. The asymmetry function can be multiplied with an optional scale factor. The default projection; behaviour can be overriden by supplying an optional set of dependents to project. Double_t getPropagatedError(const RooFitResult& fr); Calculate error on self by propagated errors on parameters with correlations as given by fit result; The linearly propagated error is calculated as follows; T; error(x) = F_a(x) * Corr(a,a') F_a'(x). where F_a(x) = [ f(x,a+da) - f(x,a-da) ] / 2, with f(x) this function and 'da' taken from the fit result; Corr(a,a') = the correlation matrix from the fit result. RooPlot* plotOnWithErrorBand(RooPlot* frame, const RooFitResult& fr, Double_t Z, const RooArgSet* params, const RooLinkedList& argList, Bool_t method1) const; Plot function or p.d.f. on frame with support for visualization of the uncertainty encoded in the given fit result fr.; If params is non-zero, only the subset of the parameters in fr that occur in params is considered for the error evaluation; Argument argList can contain any RooCmdArg named argument that can be applied to a regular plotOn() operation. By default (linMethod=kTRUE) a linearized error is shown which is calculated as follows; T; error(x) = Z* F_a(x) * Corr(a,a') F_a'(x). where F_a(x) = [ f(x,a+da) - f(x,a-da) ] / 2, with f(x) the p",MatchSource.WIKI,root/html602/RooAbsReal.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsReal.html
https://root.cern/root/html602/RooAbsReal.html:58135,Availability,error,errors,58135,"bsReal::ScaleType stype = Relative, const RooAbsData* projData = 0) const; OBSOLETE -- RETAINED FOR BACKWARD COMPATIBILITY. Use the plotOn(frame,Slice(...)) instead. RooPlot* plotAsymOn(RooPlot* frame, const RooAbsCategoryLValue& asymCat, RooAbsReal::PlotOpt o) const; Plotting engine for asymmetries. Implements the functionality if plotOn(frame,Asymmetry(...))). Plot asymmetry of ourselves, defined as. asym = f(asymCat=-1) - f(asymCat=+1) / ( f(asymCat=-1) + f(asymCat=+1) ). on frame. If frame contains a histogram, all dimensions of the plotted; asymmetry function that occur in the previously plotted dataset are projected via partial integration.; Otherwise no projections are performed,. The asymmetry function can be multiplied with an optional scale factor. The default projection; behaviour can be overriden by supplying an optional set of dependents to project. Double_t getPropagatedError(const RooFitResult& fr); Calculate error on self by propagated errors on parameters with correlations as given by fit result; The linearly propagated error is calculated as follows; T; error(x) = F_a(x) * Corr(a,a') F_a'(x). where F_a(x) = [ f(x,a+da) - f(x,a-da) ] / 2, with f(x) this function and 'da' taken from the fit result; Corr(a,a') = the correlation matrix from the fit result. RooPlot* plotOnWithErrorBand(RooPlot* frame, const RooFitResult& fr, Double_t Z, const RooArgSet* params, const RooLinkedList& argList, Bool_t method1) const; Plot function or p.d.f. on frame with support for visualization of the uncertainty encoded in the given fit result fr.; If params is non-zero, only the subset of the parameters in fr that occur in params is considered for the error evaluation; Argument argList can contain any RooCmdArg named argument that can be applied to a regular plotOn() operation. By default (linMethod=kTRUE) a linearized error is shown which is calculated as follows; T; error(x) = Z* F_a(x) * Corr(a,a') F_a'(x). where F_a(x) = [ f(x,a+da) - f(x,a-da) ] / 2, with f(x) the p",MatchSource.WIKI,root/html602/RooAbsReal.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsReal.html
https://root.cern/root/html602/RooAbsReal.html:58222,Availability,error,error,58222,"bsReal::ScaleType stype = Relative, const RooAbsData* projData = 0) const; OBSOLETE -- RETAINED FOR BACKWARD COMPATIBILITY. Use the plotOn(frame,Slice(...)) instead. RooPlot* plotAsymOn(RooPlot* frame, const RooAbsCategoryLValue& asymCat, RooAbsReal::PlotOpt o) const; Plotting engine for asymmetries. Implements the functionality if plotOn(frame,Asymmetry(...))). Plot asymmetry of ourselves, defined as. asym = f(asymCat=-1) - f(asymCat=+1) / ( f(asymCat=-1) + f(asymCat=+1) ). on frame. If frame contains a histogram, all dimensions of the plotted; asymmetry function that occur in the previously plotted dataset are projected via partial integration.; Otherwise no projections are performed,. The asymmetry function can be multiplied with an optional scale factor. The default projection; behaviour can be overriden by supplying an optional set of dependents to project. Double_t getPropagatedError(const RooFitResult& fr); Calculate error on self by propagated errors on parameters with correlations as given by fit result; The linearly propagated error is calculated as follows; T; error(x) = F_a(x) * Corr(a,a') F_a'(x). where F_a(x) = [ f(x,a+da) - f(x,a-da) ] / 2, with f(x) this function and 'da' taken from the fit result; Corr(a,a') = the correlation matrix from the fit result. RooPlot* plotOnWithErrorBand(RooPlot* frame, const RooFitResult& fr, Double_t Z, const RooArgSet* params, const RooLinkedList& argList, Bool_t method1) const; Plot function or p.d.f. on frame with support for visualization of the uncertainty encoded in the given fit result fr.; If params is non-zero, only the subset of the parameters in fr that occur in params is considered for the error evaluation; Argument argList can contain any RooCmdArg named argument that can be applied to a regular plotOn() operation. By default (linMethod=kTRUE) a linearized error is shown which is calculated as follows; T; error(x) = Z* F_a(x) * Corr(a,a') F_a'(x). where F_a(x) = [ f(x,a+da) - f(x,a-da) ] / 2, with f(x) the p",MatchSource.WIKI,root/html602/RooAbsReal.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsReal.html
https://root.cern/root/html602/RooAbsReal.html:58257,Availability,error,error,58257,"bsReal::ScaleType stype = Relative, const RooAbsData* projData = 0) const; OBSOLETE -- RETAINED FOR BACKWARD COMPATIBILITY. Use the plotOn(frame,Slice(...)) instead. RooPlot* plotAsymOn(RooPlot* frame, const RooAbsCategoryLValue& asymCat, RooAbsReal::PlotOpt o) const; Plotting engine for asymmetries. Implements the functionality if plotOn(frame,Asymmetry(...))). Plot asymmetry of ourselves, defined as. asym = f(asymCat=-1) - f(asymCat=+1) / ( f(asymCat=-1) + f(asymCat=+1) ). on frame. If frame contains a histogram, all dimensions of the plotted; asymmetry function that occur in the previously plotted dataset are projected via partial integration.; Otherwise no projections are performed,. The asymmetry function can be multiplied with an optional scale factor. The default projection; behaviour can be overriden by supplying an optional set of dependents to project. Double_t getPropagatedError(const RooFitResult& fr); Calculate error on self by propagated errors on parameters with correlations as given by fit result; The linearly propagated error is calculated as follows; T; error(x) = F_a(x) * Corr(a,a') F_a'(x). where F_a(x) = [ f(x,a+da) - f(x,a-da) ] / 2, with f(x) this function and 'da' taken from the fit result; Corr(a,a') = the correlation matrix from the fit result. RooPlot* plotOnWithErrorBand(RooPlot* frame, const RooFitResult& fr, Double_t Z, const RooArgSet* params, const RooLinkedList& argList, Bool_t method1) const; Plot function or p.d.f. on frame with support for visualization of the uncertainty encoded in the given fit result fr.; If params is non-zero, only the subset of the parameters in fr that occur in params is considered for the error evaluation; Argument argList can contain any RooCmdArg named argument that can be applied to a regular plotOn() operation. By default (linMethod=kTRUE) a linearized error is shown which is calculated as follows; T; error(x) = Z* F_a(x) * Corr(a,a') F_a'(x). where F_a(x) = [ f(x,a+da) - f(x,a-da) ] / 2, with f(x) the p",MatchSource.WIKI,root/html602/RooAbsReal.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsReal.html
https://root.cern/root/html602/RooAbsReal.html:58845,Availability,error,error,58845,"erformed,. The asymmetry function can be multiplied with an optional scale factor. The default projection; behaviour can be overriden by supplying an optional set of dependents to project. Double_t getPropagatedError(const RooFitResult& fr); Calculate error on self by propagated errors on parameters with correlations as given by fit result; The linearly propagated error is calculated as follows; T; error(x) = F_a(x) * Corr(a,a') F_a'(x). where F_a(x) = [ f(x,a+da) - f(x,a-da) ] / 2, with f(x) this function and 'da' taken from the fit result; Corr(a,a') = the correlation matrix from the fit result. RooPlot* plotOnWithErrorBand(RooPlot* frame, const RooFitResult& fr, Double_t Z, const RooArgSet* params, const RooLinkedList& argList, Bool_t method1) const; Plot function or p.d.f. on frame with support for visualization of the uncertainty encoded in the given fit result fr.; If params is non-zero, only the subset of the parameters in fr that occur in params is considered for the error evaluation; Argument argList can contain any RooCmdArg named argument that can be applied to a regular plotOn() operation. By default (linMethod=kTRUE) a linearized error is shown which is calculated as follows; T; error(x) = Z* F_a(x) * Corr(a,a') F_a'(x). where F_a(x) = [ f(x,a+da) - f(x,a-da) ] / 2, with f(x) the plotted curve and 'da' taken from the fit result; Corr(a,a') = the correlation matrix from the fit result; Z = requested signifance 'Z sigma band'. The linear method is fast (required 2*N evaluations of the curve, where N is the number of parameters), but may; not be accurate in the presence of strong correlations (~>0.9) and at Z>2 due to linear and Gaussian approximations made. Alternatively, a more robust error is calculated using a sampling method. In this method a number of curves; is calculated with variations of the parameter values, as drawn from a multi-variate Gaussian p.d.f. that is constructed; from the fit results covariance matrix. The error(x) is determined by ca",MatchSource.WIKI,root/html602/RooAbsReal.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsReal.html
https://root.cern/root/html602/RooAbsReal.html:59016,Availability,error,error,59016,"ct. Double_t getPropagatedError(const RooFitResult& fr); Calculate error on self by propagated errors on parameters with correlations as given by fit result; The linearly propagated error is calculated as follows; T; error(x) = F_a(x) * Corr(a,a') F_a'(x). where F_a(x) = [ f(x,a+da) - f(x,a-da) ] / 2, with f(x) this function and 'da' taken from the fit result; Corr(a,a') = the correlation matrix from the fit result. RooPlot* plotOnWithErrorBand(RooPlot* frame, const RooFitResult& fr, Double_t Z, const RooArgSet* params, const RooLinkedList& argList, Bool_t method1) const; Plot function or p.d.f. on frame with support for visualization of the uncertainty encoded in the given fit result fr.; If params is non-zero, only the subset of the parameters in fr that occur in params is considered for the error evaluation; Argument argList can contain any RooCmdArg named argument that can be applied to a regular plotOn() operation. By default (linMethod=kTRUE) a linearized error is shown which is calculated as follows; T; error(x) = Z* F_a(x) * Corr(a,a') F_a'(x). where F_a(x) = [ f(x,a+da) - f(x,a-da) ] / 2, with f(x) the plotted curve and 'da' taken from the fit result; Corr(a,a') = the correlation matrix from the fit result; Z = requested signifance 'Z sigma band'. The linear method is fast (required 2*N evaluations of the curve, where N is the number of parameters), but may; not be accurate in the presence of strong correlations (~>0.9) and at Z>2 due to linear and Gaussian approximations made. Alternatively, a more robust error is calculated using a sampling method. In this method a number of curves; is calculated with variations of the parameter values, as drawn from a multi-variate Gaussian p.d.f. that is constructed; from the fit results covariance matrix. The error(x) is determined by calculating a central interval that capture N% of the variations; for each valye of x, where N% is controlled by Z (i.e. Z=1 gives N=68%). The number of sampling curves is chosen to be suc",MatchSource.WIKI,root/html602/RooAbsReal.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsReal.html
https://root.cern/root/html602/RooAbsReal.html:59066,Availability,error,error,59066,"ct. Double_t getPropagatedError(const RooFitResult& fr); Calculate error on self by propagated errors on parameters with correlations as given by fit result; The linearly propagated error is calculated as follows; T; error(x) = F_a(x) * Corr(a,a') F_a'(x). where F_a(x) = [ f(x,a+da) - f(x,a-da) ] / 2, with f(x) this function and 'da' taken from the fit result; Corr(a,a') = the correlation matrix from the fit result. RooPlot* plotOnWithErrorBand(RooPlot* frame, const RooFitResult& fr, Double_t Z, const RooArgSet* params, const RooLinkedList& argList, Bool_t method1) const; Plot function or p.d.f. on frame with support for visualization of the uncertainty encoded in the given fit result fr.; If params is non-zero, only the subset of the parameters in fr that occur in params is considered for the error evaluation; Argument argList can contain any RooCmdArg named argument that can be applied to a regular plotOn() operation. By default (linMethod=kTRUE) a linearized error is shown which is calculated as follows; T; error(x) = Z* F_a(x) * Corr(a,a') F_a'(x). where F_a(x) = [ f(x,a+da) - f(x,a-da) ] / 2, with f(x) the plotted curve and 'da' taken from the fit result; Corr(a,a') = the correlation matrix from the fit result; Z = requested signifance 'Z sigma band'. The linear method is fast (required 2*N evaluations of the curve, where N is the number of parameters), but may; not be accurate in the presence of strong correlations (~>0.9) and at Z>2 due to linear and Gaussian approximations made. Alternatively, a more robust error is calculated using a sampling method. In this method a number of curves; is calculated with variations of the parameter values, as drawn from a multi-variate Gaussian p.d.f. that is constructed; from the fit results covariance matrix. The error(x) is determined by calculating a central interval that capture N% of the variations; for each valye of x, where N% is controlled by Z (i.e. Z=1 gives N=68%). The number of sampling curves is chosen to be suc",MatchSource.WIKI,root/html602/RooAbsReal.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsReal.html
https://root.cern/root/html602/RooAbsReal.html:59574,Availability,robust,robust,59574,"rgList, Bool_t method1) const; Plot function or p.d.f. on frame with support for visualization of the uncertainty encoded in the given fit result fr.; If params is non-zero, only the subset of the parameters in fr that occur in params is considered for the error evaluation; Argument argList can contain any RooCmdArg named argument that can be applied to a regular plotOn() operation. By default (linMethod=kTRUE) a linearized error is shown which is calculated as follows; T; error(x) = Z* F_a(x) * Corr(a,a') F_a'(x). where F_a(x) = [ f(x,a+da) - f(x,a-da) ] / 2, with f(x) the plotted curve and 'da' taken from the fit result; Corr(a,a') = the correlation matrix from the fit result; Z = requested signifance 'Z sigma band'. The linear method is fast (required 2*N evaluations of the curve, where N is the number of parameters), but may; not be accurate in the presence of strong correlations (~>0.9) and at Z>2 due to linear and Gaussian approximations made. Alternatively, a more robust error is calculated using a sampling method. In this method a number of curves; is calculated with variations of the parameter values, as drawn from a multi-variate Gaussian p.d.f. that is constructed; from the fit results covariance matrix. The error(x) is determined by calculating a central interval that capture N% of the variations; for each valye of x, where N% is controlled by Z (i.e. Z=1 gives N=68%). The number of sampling curves is chosen to be such; that at least 30 curves are expected to be outside the N% interval, and is minimally 100 (e.g. Z=1->Ncurve=100, Z=2->Ncurve=659, Z=3->Ncurve=11111); Intervals from the sampling method can be asymmetric, and may perform better in the presence of strong correlations. Bool_t plotSanityChecks(RooPlot* frame) const; Utility function for plotOn(), perform general sanity check on frame to ensure safe plotting operations. void makeProjectionSet(const RooAbsArg* plotVar, const RooArgSet* allVars, RooArgSet& projectedVars, Bool_t silent) const; Uti",MatchSource.WIKI,root/html602/RooAbsReal.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsReal.html
https://root.cern/root/html602/RooAbsReal.html:59581,Availability,error,error,59581,"rgList, Bool_t method1) const; Plot function or p.d.f. on frame with support for visualization of the uncertainty encoded in the given fit result fr.; If params is non-zero, only the subset of the parameters in fr that occur in params is considered for the error evaluation; Argument argList can contain any RooCmdArg named argument that can be applied to a regular plotOn() operation. By default (linMethod=kTRUE) a linearized error is shown which is calculated as follows; T; error(x) = Z* F_a(x) * Corr(a,a') F_a'(x). where F_a(x) = [ f(x,a+da) - f(x,a-da) ] / 2, with f(x) the plotted curve and 'da' taken from the fit result; Corr(a,a') = the correlation matrix from the fit result; Z = requested signifance 'Z sigma band'. The linear method is fast (required 2*N evaluations of the curve, where N is the number of parameters), but may; not be accurate in the presence of strong correlations (~>0.9) and at Z>2 due to linear and Gaussian approximations made. Alternatively, a more robust error is calculated using a sampling method. In this method a number of curves; is calculated with variations of the parameter values, as drawn from a multi-variate Gaussian p.d.f. that is constructed; from the fit results covariance matrix. The error(x) is determined by calculating a central interval that capture N% of the variations; for each valye of x, where N% is controlled by Z (i.e. Z=1 gives N=68%). The number of sampling curves is chosen to be such; that at least 30 curves are expected to be outside the N% interval, and is minimally 100 (e.g. Z=1->Ncurve=100, Z=2->Ncurve=659, Z=3->Ncurve=11111); Intervals from the sampling method can be asymmetric, and may perform better in the presence of strong correlations. Bool_t plotSanityChecks(RooPlot* frame) const; Utility function for plotOn(), perform general sanity check on frame to ensure safe plotting operations. void makeProjectionSet(const RooAbsArg* plotVar, const RooArgSet* allVars, RooArgSet& projectedVars, Bool_t silent) const; Uti",MatchSource.WIKI,root/html602/RooAbsReal.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsReal.html
https://root.cern/root/html602/RooAbsReal.html:59827,Availability,error,error,59827,"RooCmdArg named argument that can be applied to a regular plotOn() operation. By default (linMethod=kTRUE) a linearized error is shown which is calculated as follows; T; error(x) = Z* F_a(x) * Corr(a,a') F_a'(x). where F_a(x) = [ f(x,a+da) - f(x,a-da) ] / 2, with f(x) the plotted curve and 'da' taken from the fit result; Corr(a,a') = the correlation matrix from the fit result; Z = requested signifance 'Z sigma band'. The linear method is fast (required 2*N evaluations of the curve, where N is the number of parameters), but may; not be accurate in the presence of strong correlations (~>0.9) and at Z>2 due to linear and Gaussian approximations made. Alternatively, a more robust error is calculated using a sampling method. In this method a number of curves; is calculated with variations of the parameter values, as drawn from a multi-variate Gaussian p.d.f. that is constructed; from the fit results covariance matrix. The error(x) is determined by calculating a central interval that capture N% of the variations; for each valye of x, where N% is controlled by Z (i.e. Z=1 gives N=68%). The number of sampling curves is chosen to be such; that at least 30 curves are expected to be outside the N% interval, and is minimally 100 (e.g. Z=1->Ncurve=100, Z=2->Ncurve=659, Z=3->Ncurve=11111); Intervals from the sampling method can be asymmetric, and may perform better in the presence of strong correlations. Bool_t plotSanityChecks(RooPlot* frame) const; Utility function for plotOn(), perform general sanity check on frame to ensure safe plotting operations. void makeProjectionSet(const RooAbsArg* plotVar, const RooArgSet* allVars, RooArgSet& projectedVars, Bool_t silent) const; Utility function for plotOn() that constructs the set of; observables to project when plotting ourselves as function of; 'plotVar'. 'allVars' is the list of variables that must be; projected, but may contain variables that we do not depend on. If; 'silent' is cleared, warnings about inconsistent input parameter",MatchSource.WIKI,root/html602/RooAbsReal.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsReal.html
https://root.cern/root/html602/RooAbsReal.html:67480,Availability,error,error,67480,"e depends on the choice of normalization such as; RooAddPdf. void selectNormalizationRange(const char* rangeName = 0, Bool_t force = kFALSE); Interface function to force use of a given normalization range; to interpret function value. Needed for functions or p.d.f.s; whose shape depends on the choice of normalization such as; RooAddPdf. void setCacheCheck(Bool_t flag); Activate cache validation mode. Int_t getMaxVal(const RooArgSet& vars) const; Advertise capability to determine maximum value of function for given set of; observables. If no direct generator method is provided, this information; will assist the accept/reject generator to operate more efficiently as; it can skip the initial trial sampling phase to empirically find the function; maximum. Double_t maxVal(Int_t code) const; Return maximum value for set of observables identified by code assigned; in getMaxVal. void logEvalError(const RooAbsReal* originator, const char* origName, const char* message, const char* serverValueString = 0); Interface to insert remote error logging messages received by RooRealMPFE into current error loggin stream. void logEvalError(const char* message, const char* serverValueString = 0) const; Log evaluation error message. Evaluation errors may be routed through a different; protocol than generic RooFit warning message (which go straight through RooMsgService); because evaluation errors can occur in very large numbers in the use of likelihood; evaluations. In logEvalError mode, controlled by global method enableEvalErrorLogging(); messages reported through this function are not printed but all stored in a list,; along with server values at the time of reporting. Error messages logged in this; way can be printed in a structured way, eliminating duplicates and with the ability; to truncate the list by printEvalErrors. This is the standard mode of error logging; during MINUIT operations. If enableEvalErrorLogging() is false, all errors; reported through this method are passed for im",MatchSource.WIKI,root/html602/RooAbsReal.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsReal.html
https://root.cern/root/html602/RooAbsReal.html:67540,Availability,error,error,67540,"e depends on the choice of normalization such as; RooAddPdf. void selectNormalizationRange(const char* rangeName = 0, Bool_t force = kFALSE); Interface function to force use of a given normalization range; to interpret function value. Needed for functions or p.d.f.s; whose shape depends on the choice of normalization such as; RooAddPdf. void setCacheCheck(Bool_t flag); Activate cache validation mode. Int_t getMaxVal(const RooArgSet& vars) const; Advertise capability to determine maximum value of function for given set of; observables. If no direct generator method is provided, this information; will assist the accept/reject generator to operate more efficiently as; it can skip the initial trial sampling phase to empirically find the function; maximum. Double_t maxVal(Int_t code) const; Return maximum value for set of observables identified by code assigned; in getMaxVal. void logEvalError(const RooAbsReal* originator, const char* origName, const char* message, const char* serverValueString = 0); Interface to insert remote error logging messages received by RooRealMPFE into current error loggin stream. void logEvalError(const char* message, const char* serverValueString = 0) const; Log evaluation error message. Evaluation errors may be routed through a different; protocol than generic RooFit warning message (which go straight through RooMsgService); because evaluation errors can occur in very large numbers in the use of likelihood; evaluations. In logEvalError mode, controlled by global method enableEvalErrorLogging(); messages reported through this function are not printed but all stored in a list,; along with server values at the time of reporting. Error messages logged in this; way can be printed in a structured way, eliminating duplicates and with the ability; to truncate the list by printEvalErrors. This is the standard mode of error logging; during MINUIT operations. If enableEvalErrorLogging() is false, all errors; reported through this method are passed for im",MatchSource.WIKI,root/html602/RooAbsReal.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsReal.html
https://root.cern/root/html602/RooAbsReal.html:67657,Availability,error,error,67657," of a given normalization range; to interpret function value. Needed for functions or p.d.f.s; whose shape depends on the choice of normalization such as; RooAddPdf. void setCacheCheck(Bool_t flag); Activate cache validation mode. Int_t getMaxVal(const RooArgSet& vars) const; Advertise capability to determine maximum value of function for given set of; observables. If no direct generator method is provided, this information; will assist the accept/reject generator to operate more efficiently as; it can skip the initial trial sampling phase to empirically find the function; maximum. Double_t maxVal(Int_t code) const; Return maximum value for set of observables identified by code assigned; in getMaxVal. void logEvalError(const RooAbsReal* originator, const char* origName, const char* message, const char* serverValueString = 0); Interface to insert remote error logging messages received by RooRealMPFE into current error loggin stream. void logEvalError(const char* message, const char* serverValueString = 0) const; Log evaluation error message. Evaluation errors may be routed through a different; protocol than generic RooFit warning message (which go straight through RooMsgService); because evaluation errors can occur in very large numbers in the use of likelihood; evaluations. In logEvalError mode, controlled by global method enableEvalErrorLogging(); messages reported through this function are not printed but all stored in a list,; along with server values at the time of reporting. Error messages logged in this; way can be printed in a structured way, eliminating duplicates and with the ability; to truncate the list by printEvalErrors. This is the standard mode of error logging; during MINUIT operations. If enableEvalErrorLogging() is false, all errors; reported through this method are passed for immediate printing through RooMsgService.; A string with server names and values is constructed automatically for error logging; purposes, unless a custom string with similar ",MatchSource.WIKI,root/html602/RooAbsReal.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsReal.html
https://root.cern/root/html602/RooAbsReal.html:67683,Availability,error,errors,67683,"acheCheck(Bool_t flag); Activate cache validation mode. Int_t getMaxVal(const RooArgSet& vars) const; Advertise capability to determine maximum value of function for given set of; observables. If no direct generator method is provided, this information; will assist the accept/reject generator to operate more efficiently as; it can skip the initial trial sampling phase to empirically find the function; maximum. Double_t maxVal(Int_t code) const; Return maximum value for set of observables identified by code assigned; in getMaxVal. void logEvalError(const RooAbsReal* originator, const char* origName, const char* message, const char* serverValueString = 0); Interface to insert remote error logging messages received by RooRealMPFE into current error loggin stream. void logEvalError(const char* message, const char* serverValueString = 0) const; Log evaluation error message. Evaluation errors may be routed through a different; protocol than generic RooFit warning message (which go straight through RooMsgService); because evaluation errors can occur in very large numbers in the use of likelihood; evaluations. In logEvalError mode, controlled by global method enableEvalErrorLogging(); messages reported through this function are not printed but all stored in a list,; along with server values at the time of reporting. Error messages logged in this; way can be printed in a structured way, eliminating duplicates and with the ability; to truncate the list by printEvalErrors. This is the standard mode of error logging; during MINUIT operations. If enableEvalErrorLogging() is false, all errors; reported through this method are passed for immediate printing through RooMsgService.; A string with server names and values is constructed automatically for error logging; purposes, unless a custom string with similar information is passed as argument. void clearEvalErrorLog(); Clear the stack of evaluation error messages. void printEvalErrors(ostream& os = std::cout, Int_t maxPerNode = 10",MatchSource.WIKI,root/html602/RooAbsReal.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsReal.html
https://root.cern/root/html602/RooAbsReal.html:67832,Availability,error,errors,67832,"acheCheck(Bool_t flag); Activate cache validation mode. Int_t getMaxVal(const RooArgSet& vars) const; Advertise capability to determine maximum value of function for given set of; observables. If no direct generator method is provided, this information; will assist the accept/reject generator to operate more efficiently as; it can skip the initial trial sampling phase to empirically find the function; maximum. Double_t maxVal(Int_t code) const; Return maximum value for set of observables identified by code assigned; in getMaxVal. void logEvalError(const RooAbsReal* originator, const char* origName, const char* message, const char* serverValueString = 0); Interface to insert remote error logging messages received by RooRealMPFE into current error loggin stream. void logEvalError(const char* message, const char* serverValueString = 0) const; Log evaluation error message. Evaluation errors may be routed through a different; protocol than generic RooFit warning message (which go straight through RooMsgService); because evaluation errors can occur in very large numbers in the use of likelihood; evaluations. In logEvalError mode, controlled by global method enableEvalErrorLogging(); messages reported through this function are not printed but all stored in a list,; along with server values at the time of reporting. Error messages logged in this; way can be printed in a structured way, eliminating duplicates and with the ability; to truncate the list by printEvalErrors. This is the standard mode of error logging; during MINUIT operations. If enableEvalErrorLogging() is false, all errors; reported through this method are passed for immediate printing through RooMsgService.; A string with server names and values is constructed automatically for error logging; purposes, unless a custom string with similar information is passed as argument. void clearEvalErrorLog(); Clear the stack of evaluation error messages. void printEvalErrors(ostream& os = std::cout, Int_t maxPerNode = 10",MatchSource.WIKI,root/html602/RooAbsReal.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsReal.html
https://root.cern/root/html602/RooAbsReal.html:68306,Availability,error,error,68306," in getMaxVal. void logEvalError(const RooAbsReal* originator, const char* origName, const char* message, const char* serverValueString = 0); Interface to insert remote error logging messages received by RooRealMPFE into current error loggin stream. void logEvalError(const char* message, const char* serverValueString = 0) const; Log evaluation error message. Evaluation errors may be routed through a different; protocol than generic RooFit warning message (which go straight through RooMsgService); because evaluation errors can occur in very large numbers in the use of likelihood; evaluations. In logEvalError mode, controlled by global method enableEvalErrorLogging(); messages reported through this function are not printed but all stored in a list,; along with server values at the time of reporting. Error messages logged in this; way can be printed in a structured way, eliminating duplicates and with the ability; to truncate the list by printEvalErrors. This is the standard mode of error logging; during MINUIT operations. If enableEvalErrorLogging() is false, all errors; reported through this method are passed for immediate printing through RooMsgService.; A string with server names and values is constructed automatically for error logging; purposes, unless a custom string with similar information is passed as argument. void clearEvalErrorLog(); Clear the stack of evaluation error messages. void printEvalErrors(ostream& os = std::cout, Int_t maxPerNode = 10000000); Print all outstanding logged evaluation error on the given ostream. If maxPerNode; is zero, only the number of errors for each source (object with unique name) is listed.; If maxPerNode is greater than zero, up to maxPerNode detailed error messages are shown; per source of errors. A truncation message is shown if there were more errors logged; than shown. Int_t numEvalErrors(); Return the number of logged evaluation errors since the last clearing. void fixAddCoefNormalization(const RooArgSet& addNormSet = R",MatchSource.WIKI,root/html602/RooAbsReal.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsReal.html
https://root.cern/root/html602/RooAbsReal.html:68389,Availability,error,errors,68389,"e, const char* serverValueString = 0); Interface to insert remote error logging messages received by RooRealMPFE into current error loggin stream. void logEvalError(const char* message, const char* serverValueString = 0) const; Log evaluation error message. Evaluation errors may be routed through a different; protocol than generic RooFit warning message (which go straight through RooMsgService); because evaluation errors can occur in very large numbers in the use of likelihood; evaluations. In logEvalError mode, controlled by global method enableEvalErrorLogging(); messages reported through this function are not printed but all stored in a list,; along with server values at the time of reporting. Error messages logged in this; way can be printed in a structured way, eliminating duplicates and with the ability; to truncate the list by printEvalErrors. This is the standard mode of error logging; during MINUIT operations. If enableEvalErrorLogging() is false, all errors; reported through this method are passed for immediate printing through RooMsgService.; A string with server names and values is constructed automatically for error logging; purposes, unless a custom string with similar information is passed as argument. void clearEvalErrorLog(); Clear the stack of evaluation error messages. void printEvalErrors(ostream& os = std::cout, Int_t maxPerNode = 10000000); Print all outstanding logged evaluation error on the given ostream. If maxPerNode; is zero, only the number of errors for each source (object with unique name) is listed.; If maxPerNode is greater than zero, up to maxPerNode detailed error messages are shown; per source of errors. A truncation message is shown if there were more errors logged; than shown. Int_t numEvalErrors(); Return the number of logged evaluation errors since the last clearing. void fixAddCoefNormalization(const RooArgSet& addNormSet = RooArgSet(), Bool_t force = kTRUE); Fix the interpretation of the coefficient of any RooAddPdf component",MatchSource.WIKI,root/html602/RooAbsReal.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsReal.html
https://root.cern/root/html602/RooAbsReal.html:68555,Availability,error,error,68555,"logEvalError(const char* message, const char* serverValueString = 0) const; Log evaluation error message. Evaluation errors may be routed through a different; protocol than generic RooFit warning message (which go straight through RooMsgService); because evaluation errors can occur in very large numbers in the use of likelihood; evaluations. In logEvalError mode, controlled by global method enableEvalErrorLogging(); messages reported through this function are not printed but all stored in a list,; along with server values at the time of reporting. Error messages logged in this; way can be printed in a structured way, eliminating duplicates and with the ability; to truncate the list by printEvalErrors. This is the standard mode of error logging; during MINUIT operations. If enableEvalErrorLogging() is false, all errors; reported through this method are passed for immediate printing through RooMsgService.; A string with server names and values is constructed automatically for error logging; purposes, unless a custom string with similar information is passed as argument. void clearEvalErrorLog(); Clear the stack of evaluation error messages. void printEvalErrors(ostream& os = std::cout, Int_t maxPerNode = 10000000); Print all outstanding logged evaluation error on the given ostream. If maxPerNode; is zero, only the number of errors for each source (object with unique name) is listed.; If maxPerNode is greater than zero, up to maxPerNode detailed error messages are shown; per source of errors. A truncation message is shown if there were more errors logged; than shown. Int_t numEvalErrors(); Return the number of logged evaluation errors since the last clearing. void fixAddCoefNormalization(const RooArgSet& addNormSet = RooArgSet(), Bool_t force = kTRUE); Fix the interpretation of the coefficient of any RooAddPdf component in; the expression tree headed by this object to the given set of observables. If the force flag is false, the normalization choice is only fixed for t",MatchSource.WIKI,root/html602/RooAbsReal.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsReal.html
https://root.cern/root/html602/RooAbsReal.html:68707,Availability,error,error,68707,"ors may be routed through a different; protocol than generic RooFit warning message (which go straight through RooMsgService); because evaluation errors can occur in very large numbers in the use of likelihood; evaluations. In logEvalError mode, controlled by global method enableEvalErrorLogging(); messages reported through this function are not printed but all stored in a list,; along with server values at the time of reporting. Error messages logged in this; way can be printed in a structured way, eliminating duplicates and with the ability; to truncate the list by printEvalErrors. This is the standard mode of error logging; during MINUIT operations. If enableEvalErrorLogging() is false, all errors; reported through this method are passed for immediate printing through RooMsgService.; A string with server names and values is constructed automatically for error logging; purposes, unless a custom string with similar information is passed as argument. void clearEvalErrorLog(); Clear the stack of evaluation error messages. void printEvalErrors(ostream& os = std::cout, Int_t maxPerNode = 10000000); Print all outstanding logged evaluation error on the given ostream. If maxPerNode; is zero, only the number of errors for each source (object with unique name) is listed.; If maxPerNode is greater than zero, up to maxPerNode detailed error messages are shown; per source of errors. A truncation message is shown if there were more errors logged; than shown. Int_t numEvalErrors(); Return the number of logged evaluation errors since the last clearing. void fixAddCoefNormalization(const RooArgSet& addNormSet = RooArgSet(), Bool_t force = kTRUE); Fix the interpretation of the coefficient of any RooAddPdf component in; the expression tree headed by this object to the given set of observables. If the force flag is false, the normalization choice is only fixed for those; RooAddPdf components that have the default 'automatic' interpretation of; coefficients (i.e. the interpretation is",MatchSource.WIKI,root/html602/RooAbsReal.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsReal.html
https://root.cern/root/html602/RooAbsReal.html:68839,Availability,error,error,68839,"gh RooMsgService); because evaluation errors can occur in very large numbers in the use of likelihood; evaluations. In logEvalError mode, controlled by global method enableEvalErrorLogging(); messages reported through this function are not printed but all stored in a list,; along with server values at the time of reporting. Error messages logged in this; way can be printed in a structured way, eliminating duplicates and with the ability; to truncate the list by printEvalErrors. This is the standard mode of error logging; during MINUIT operations. If enableEvalErrorLogging() is false, all errors; reported through this method are passed for immediate printing through RooMsgService.; A string with server names and values is constructed automatically for error logging; purposes, unless a custom string with similar information is passed as argument. void clearEvalErrorLog(); Clear the stack of evaluation error messages. void printEvalErrors(ostream& os = std::cout, Int_t maxPerNode = 10000000); Print all outstanding logged evaluation error on the given ostream. If maxPerNode; is zero, only the number of errors for each source (object with unique name) is listed.; If maxPerNode is greater than zero, up to maxPerNode detailed error messages are shown; per source of errors. A truncation message is shown if there were more errors logged; than shown. Int_t numEvalErrors(); Return the number of logged evaluation errors since the last clearing. void fixAddCoefNormalization(const RooArgSet& addNormSet = RooArgSet(), Bool_t force = kTRUE); Fix the interpretation of the coefficient of any RooAddPdf component in; the expression tree headed by this object to the given set of observables. If the force flag is false, the normalization choice is only fixed for those; RooAddPdf components that have the default 'automatic' interpretation of; coefficients (i.e. the interpretation is defined by the observables passed; to getVal()). If force is true, also RooAddPdf that already have a fixed",MatchSource.WIKI,root/html602/RooAbsReal.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsReal.html
https://root.cern/root/html602/RooAbsReal.html:68910,Availability,error,errors,68910,"valError mode, controlled by global method enableEvalErrorLogging(); messages reported through this function are not printed but all stored in a list,; along with server values at the time of reporting. Error messages logged in this; way can be printed in a structured way, eliminating duplicates and with the ability; to truncate the list by printEvalErrors. This is the standard mode of error logging; during MINUIT operations. If enableEvalErrorLogging() is false, all errors; reported through this method are passed for immediate printing through RooMsgService.; A string with server names and values is constructed automatically for error logging; purposes, unless a custom string with similar information is passed as argument. void clearEvalErrorLog(); Clear the stack of evaluation error messages. void printEvalErrors(ostream& os = std::cout, Int_t maxPerNode = 10000000); Print all outstanding logged evaluation error on the given ostream. If maxPerNode; is zero, only the number of errors for each source (object with unique name) is listed.; If maxPerNode is greater than zero, up to maxPerNode detailed error messages are shown; per source of errors. A truncation message is shown if there were more errors logged; than shown. Int_t numEvalErrors(); Return the number of logged evaluation errors since the last clearing. void fixAddCoefNormalization(const RooArgSet& addNormSet = RooArgSet(), Bool_t force = kTRUE); Fix the interpretation of the coefficient of any RooAddPdf component in; the expression tree headed by this object to the given set of observables. If the force flag is false, the normalization choice is only fixed for those; RooAddPdf components that have the default 'automatic' interpretation of; coefficients (i.e. the interpretation is defined by the observables passed; to getVal()). If force is true, also RooAddPdf that already have a fixed; interpretation are changed to a new fixed interpretation. void fixAddCoefRange(const char* rangeName = 0, Bool_t force = k",MatchSource.WIKI,root/html602/RooAbsReal.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsReal.html
https://root.cern/root/html602/RooAbsReal.html:69033,Availability,error,error,69033,"n are not printed but all stored in a list,; along with server values at the time of reporting. Error messages logged in this; way can be printed in a structured way, eliminating duplicates and with the ability; to truncate the list by printEvalErrors. This is the standard mode of error logging; during MINUIT operations. If enableEvalErrorLogging() is false, all errors; reported through this method are passed for immediate printing through RooMsgService.; A string with server names and values is constructed automatically for error logging; purposes, unless a custom string with similar information is passed as argument. void clearEvalErrorLog(); Clear the stack of evaluation error messages. void printEvalErrors(ostream& os = std::cout, Int_t maxPerNode = 10000000); Print all outstanding logged evaluation error on the given ostream. If maxPerNode; is zero, only the number of errors for each source (object with unique name) is listed.; If maxPerNode is greater than zero, up to maxPerNode detailed error messages are shown; per source of errors. A truncation message is shown if there were more errors logged; than shown. Int_t numEvalErrors(); Return the number of logged evaluation errors since the last clearing. void fixAddCoefNormalization(const RooArgSet& addNormSet = RooArgSet(), Bool_t force = kTRUE); Fix the interpretation of the coefficient of any RooAddPdf component in; the expression tree headed by this object to the given set of observables. If the force flag is false, the normalization choice is only fixed for those; RooAddPdf components that have the default 'automatic' interpretation of; coefficients (i.e. the interpretation is defined by the observables passed; to getVal()). If force is true, also RooAddPdf that already have a fixed; interpretation are changed to a new fixed interpretation. void fixAddCoefRange(const char* rangeName = 0, Bool_t force = kTRUE); Fix the interpretation of the coefficient of any RooAddPdf component in; the expression tree headed ",MatchSource.WIKI,root/html602/RooAbsReal.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsReal.html
https://root.cern/root/html602/RooAbsReal.html:69073,Availability,error,errors,69073,"n are not printed but all stored in a list,; along with server values at the time of reporting. Error messages logged in this; way can be printed in a structured way, eliminating duplicates and with the ability; to truncate the list by printEvalErrors. This is the standard mode of error logging; during MINUIT operations. If enableEvalErrorLogging() is false, all errors; reported through this method are passed for immediate printing through RooMsgService.; A string with server names and values is constructed automatically for error logging; purposes, unless a custom string with similar information is passed as argument. void clearEvalErrorLog(); Clear the stack of evaluation error messages. void printEvalErrors(ostream& os = std::cout, Int_t maxPerNode = 10000000); Print all outstanding logged evaluation error on the given ostream. If maxPerNode; is zero, only the number of errors for each source (object with unique name) is listed.; If maxPerNode is greater than zero, up to maxPerNode detailed error messages are shown; per source of errors. A truncation message is shown if there were more errors logged; than shown. Int_t numEvalErrors(); Return the number of logged evaluation errors since the last clearing. void fixAddCoefNormalization(const RooArgSet& addNormSet = RooArgSet(), Bool_t force = kTRUE); Fix the interpretation of the coefficient of any RooAddPdf component in; the expression tree headed by this object to the given set of observables. If the force flag is false, the normalization choice is only fixed for those; RooAddPdf components that have the default 'automatic' interpretation of; coefficients (i.e. the interpretation is defined by the observables passed; to getVal()). If force is true, also RooAddPdf that already have a fixed; interpretation are changed to a new fixed interpretation. void fixAddCoefRange(const char* rangeName = 0, Bool_t force = kTRUE); Fix the interpretation of the coefficient of any RooAddPdf component in; the expression tree headed ",MatchSource.WIKI,root/html602/RooAbsReal.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsReal.html
https://root.cern/root/html602/RooAbsReal.html:69130,Availability,error,errors,69130,". Error messages logged in this; way can be printed in a structured way, eliminating duplicates and with the ability; to truncate the list by printEvalErrors. This is the standard mode of error logging; during MINUIT operations. If enableEvalErrorLogging() is false, all errors; reported through this method are passed for immediate printing through RooMsgService.; A string with server names and values is constructed automatically for error logging; purposes, unless a custom string with similar information is passed as argument. void clearEvalErrorLog(); Clear the stack of evaluation error messages. void printEvalErrors(ostream& os = std::cout, Int_t maxPerNode = 10000000); Print all outstanding logged evaluation error on the given ostream. If maxPerNode; is zero, only the number of errors for each source (object with unique name) is listed.; If maxPerNode is greater than zero, up to maxPerNode detailed error messages are shown; per source of errors. A truncation message is shown if there were more errors logged; than shown. Int_t numEvalErrors(); Return the number of logged evaluation errors since the last clearing. void fixAddCoefNormalization(const RooArgSet& addNormSet = RooArgSet(), Bool_t force = kTRUE); Fix the interpretation of the coefficient of any RooAddPdf component in; the expression tree headed by this object to the given set of observables. If the force flag is false, the normalization choice is only fixed for those; RooAddPdf components that have the default 'automatic' interpretation of; coefficients (i.e. the interpretation is defined by the observables passed; to getVal()). If force is true, also RooAddPdf that already have a fixed; interpretation are changed to a new fixed interpretation. void fixAddCoefRange(const char* rangeName = 0, Bool_t force = kTRUE); Fix the interpretation of the coefficient of any RooAddPdf component in; the expression tree headed by this object to the given set of observables. If the force flag is false, the normalization",MatchSource.WIKI,root/html602/RooAbsReal.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsReal.html
https://root.cern/root/html602/RooAbsReal.html:69219,Availability,error,errors,69219,"duplicates and with the ability; to truncate the list by printEvalErrors. This is the standard mode of error logging; during MINUIT operations. If enableEvalErrorLogging() is false, all errors; reported through this method are passed for immediate printing through RooMsgService.; A string with server names and values is constructed automatically for error logging; purposes, unless a custom string with similar information is passed as argument. void clearEvalErrorLog(); Clear the stack of evaluation error messages. void printEvalErrors(ostream& os = std::cout, Int_t maxPerNode = 10000000); Print all outstanding logged evaluation error on the given ostream. If maxPerNode; is zero, only the number of errors for each source (object with unique name) is listed.; If maxPerNode is greater than zero, up to maxPerNode detailed error messages are shown; per source of errors. A truncation message is shown if there were more errors logged; than shown. Int_t numEvalErrors(); Return the number of logged evaluation errors since the last clearing. void fixAddCoefNormalization(const RooArgSet& addNormSet = RooArgSet(), Bool_t force = kTRUE); Fix the interpretation of the coefficient of any RooAddPdf component in; the expression tree headed by this object to the given set of observables. If the force flag is false, the normalization choice is only fixed for those; RooAddPdf components that have the default 'automatic' interpretation of; coefficients (i.e. the interpretation is defined by the observables passed; to getVal()). If force is true, also RooAddPdf that already have a fixed; interpretation are changed to a new fixed interpretation. void fixAddCoefRange(const char* rangeName = 0, Bool_t force = kTRUE); Fix the interpretation of the coefficient of any RooAddPdf component in; the expression tree headed by this object to the given set of observables. If the force flag is false, the normalization range choice is only fixed for those; RooAddPdf components that currently use the de",MatchSource.WIKI,root/html602/RooAbsReal.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsReal.html
https://root.cern/root/html602/RooAbsReal.html:78294,Availability,error,errors,78294,"s run after HESSE, on by default; Minos(const RooArgSet& set) -- Only run MINOS on given subset of arguments; Save(Bool_t flag) -- Flac controls if RooFitResult object is produced and returned, off by default; Strategy(Int_t flag) -- Set Minuit strategy (0 through 2, default is 1); FitOptions(const char* optStr) -- Steer fit with classic options string (for backward compatibility). Use of this option; excludes use of any of the new style steering options. Options to control informational output. Verbose(Bool_t flag) -- Flag controls if verbose output is printed (NLL, parameter changes during fit; Timer(Bool_t flag) -- Time CPU and wall clock consumption of fit steps, off by default; PrintLevel(Int_t level) -- Set Minuit print level (-1 through 3, default is 1). At -1 all RooFit informational; messages are suppressed as well; Warnings(Bool_t flag) -- Enable or disable MINUIT warnings (enabled by default); PrintEvalErrors(Int_t numErr) -- Control number of p.d.f evaluation errors printed per likelihood evaluation. A negative; value suppress output completely, a zero value will only print the error count per p.d.f component,; a positive value is will print details of each error up to numErr messages per p.d.f component. RooFitResult* chi2FitTo(RooDataHist& data, const RooLinkedList& cmdList); Internal back-end function to steer chi2 fits. RooAbsReal* createChi2(RooDataHist& data, const RooCmdArg& arg1 = RooCmdArg::none(), const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()); Create a chi-2 from a histogram and this function. The following named arguments are supported. Options to control construction of the chi^2. DataError(RooAbsData::ErrorType) -- Choose between Poisson errors and Sum-of-weights errors; NumCPU(Int_t) -- Act",MatchSource.WIKI,root/html602/RooAbsReal.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsReal.html
https://root.cern/root/html602/RooAbsReal.html:78415,Availability,error,error,78415,"NOS on given subset of arguments; Save(Bool_t flag) -- Flac controls if RooFitResult object is produced and returned, off by default; Strategy(Int_t flag) -- Set Minuit strategy (0 through 2, default is 1); FitOptions(const char* optStr) -- Steer fit with classic options string (for backward compatibility). Use of this option; excludes use of any of the new style steering options. Options to control informational output. Verbose(Bool_t flag) -- Flag controls if verbose output is printed (NLL, parameter changes during fit; Timer(Bool_t flag) -- Time CPU and wall clock consumption of fit steps, off by default; PrintLevel(Int_t level) -- Set Minuit print level (-1 through 3, default is 1). At -1 all RooFit informational; messages are suppressed as well; Warnings(Bool_t flag) -- Enable or disable MINUIT warnings (enabled by default); PrintEvalErrors(Int_t numErr) -- Control number of p.d.f evaluation errors printed per likelihood evaluation. A negative; value suppress output completely, a zero value will only print the error count per p.d.f component,; a positive value is will print details of each error up to numErr messages per p.d.f component. RooFitResult* chi2FitTo(RooDataHist& data, const RooLinkedList& cmdList); Internal back-end function to steer chi2 fits. RooAbsReal* createChi2(RooDataHist& data, const RooCmdArg& arg1 = RooCmdArg::none(), const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()); Create a chi-2 from a histogram and this function. The following named arguments are supported. Options to control construction of the chi^2. DataError(RooAbsData::ErrorType) -- Choose between Poisson errors and Sum-of-weights errors; NumCPU(Int_t) -- Activate parallel processing feature on N processes; Range() -- Calculate Chi2 ",MatchSource.WIKI,root/html602/RooAbsReal.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsReal.html
https://root.cern/root/html602/RooAbsReal.html:78496,Availability,error,error,78496,"duced and returned, off by default; Strategy(Int_t flag) -- Set Minuit strategy (0 through 2, default is 1); FitOptions(const char* optStr) -- Steer fit with classic options string (for backward compatibility). Use of this option; excludes use of any of the new style steering options. Options to control informational output. Verbose(Bool_t flag) -- Flag controls if verbose output is printed (NLL, parameter changes during fit; Timer(Bool_t flag) -- Time CPU and wall clock consumption of fit steps, off by default; PrintLevel(Int_t level) -- Set Minuit print level (-1 through 3, default is 1). At -1 all RooFit informational; messages are suppressed as well; Warnings(Bool_t flag) -- Enable or disable MINUIT warnings (enabled by default); PrintEvalErrors(Int_t numErr) -- Control number of p.d.f evaluation errors printed per likelihood evaluation. A negative; value suppress output completely, a zero value will only print the error count per p.d.f component,; a positive value is will print details of each error up to numErr messages per p.d.f component. RooFitResult* chi2FitTo(RooDataHist& data, const RooLinkedList& cmdList); Internal back-end function to steer chi2 fits. RooAbsReal* createChi2(RooDataHist& data, const RooCmdArg& arg1 = RooCmdArg::none(), const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()); Create a chi-2 from a histogram and this function. The following named arguments are supported. Options to control construction of the chi^2. DataError(RooAbsData::ErrorType) -- Choose between Poisson errors and Sum-of-weights errors; NumCPU(Int_t) -- Activate parallel processing feature on N processes; Range() -- Calculate Chi2 only in selected region. RooAbsReal* createChi2(RooDataHist& data, const RooLinkedList& cmdList); I",MatchSource.WIKI,root/html602/RooAbsReal.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsReal.html
https://root.cern/root/html602/RooAbsReal.html:79254,Availability,error,errors,79254,"printed per likelihood evaluation. A negative; value suppress output completely, a zero value will only print the error count per p.d.f component,; a positive value is will print details of each error up to numErr messages per p.d.f component. RooFitResult* chi2FitTo(RooDataHist& data, const RooLinkedList& cmdList); Internal back-end function to steer chi2 fits. RooAbsReal* createChi2(RooDataHist& data, const RooCmdArg& arg1 = RooCmdArg::none(), const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()); Create a chi-2 from a histogram and this function. The following named arguments are supported. Options to control construction of the chi^2. DataError(RooAbsData::ErrorType) -- Choose between Poisson errors and Sum-of-weights errors; NumCPU(Int_t) -- Activate parallel processing feature on N processes; Range() -- Calculate Chi2 only in selected region. RooAbsReal* createChi2(RooDataHist& data, const RooLinkedList& cmdList); Internal back-end function to create a chi2. RooFitResult* chi2FitTo(RooDataSet& xydata, const RooCmdArg& arg1 = RooCmdArg::none(), const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()); Create a chi-2 from a series of x and y value stored in a dataset.; The y values can either be the event weights, or can be another column designated; by the YVar() argument. The y value must have errors defined for the chi-2 to; be well defined. The following named arguments are supported. Options to control construction of the chi^2. YVar(RooRealVar& yvar) -- Designate given colum",MatchSource.WIKI,root/html602/RooAbsReal.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsReal.html
https://root.cern/root/html602/RooAbsReal.html:79280,Availability,error,errors,79280,"printed per likelihood evaluation. A negative; value suppress output completely, a zero value will only print the error count per p.d.f component,; a positive value is will print details of each error up to numErr messages per p.d.f component. RooFitResult* chi2FitTo(RooDataHist& data, const RooLinkedList& cmdList); Internal back-end function to steer chi2 fits. RooAbsReal* createChi2(RooDataHist& data, const RooCmdArg& arg1 = RooCmdArg::none(), const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()); Create a chi-2 from a histogram and this function. The following named arguments are supported. Options to control construction of the chi^2. DataError(RooAbsData::ErrorType) -- Choose between Poisson errors and Sum-of-weights errors; NumCPU(Int_t) -- Activate parallel processing feature on N processes; Range() -- Calculate Chi2 only in selected region. RooAbsReal* createChi2(RooDataHist& data, const RooLinkedList& cmdList); Internal back-end function to create a chi2. RooFitResult* chi2FitTo(RooDataSet& xydata, const RooCmdArg& arg1 = RooCmdArg::none(), const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()); Create a chi-2 from a series of x and y value stored in a dataset.; The y values can either be the event weights, or can be another column designated; by the YVar() argument. The y value must have errors defined for the chi-2 to; be well defined. The following named arguments are supported. Options to control construction of the chi^2. YVar(RooRealVar& yvar) -- Designate given colum",MatchSource.WIKI,root/html602/RooAbsReal.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsReal.html
https://root.cern/root/html602/RooAbsReal.html:80113,Availability,error,errors,80113,"guments are supported. Options to control construction of the chi^2. DataError(RooAbsData::ErrorType) -- Choose between Poisson errors and Sum-of-weights errors; NumCPU(Int_t) -- Activate parallel processing feature on N processes; Range() -- Calculate Chi2 only in selected region. RooAbsReal* createChi2(RooDataHist& data, const RooLinkedList& cmdList); Internal back-end function to create a chi2. RooFitResult* chi2FitTo(RooDataSet& xydata, const RooCmdArg& arg1 = RooCmdArg::none(), const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()); Create a chi-2 from a series of x and y value stored in a dataset.; The y values can either be the event weights, or can be another column designated; by the YVar() argument. The y value must have errors defined for the chi-2 to; be well defined. The following named arguments are supported. Options to control construction of the chi^2. YVar(RooRealVar& yvar) -- Designate given column in dataset as Y value; Integrate(Bool_t flag) -- Integrate function over range specified by X errors; rather than take value at bin center. Options to control flow of fit procedure. InitialHesse(Bool_t flag) -- Flag controls if HESSE before MIGRAD as well, off by default; Hesse(Bool_t flag) -- Flag controls if HESSE is run after MIGRAD, on by default; Minos(Bool_t flag) -- Flag controls if MINOS is run after HESSE, on by default; Minos(const RooArgSet& set) -- Only run MINOS on given subset of arguments; Save(Bool_t flag) -- Flac controls if RooFitResult object is produced and returned, off by default; Strategy(Int_t flag) -- Set Minuit strategy (0 through 2, default is 1); FitOptions(const char* optStr) -- Steer fit with classic options string (for backward compatibility). Use of this option; excludes use of an",MatchSource.WIKI,root/html602/RooAbsReal.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsReal.html
https://root.cern/root/html602/RooAbsReal.html:80397,Availability,error,errors,80397,"processes; Range() -- Calculate Chi2 only in selected region. RooAbsReal* createChi2(RooDataHist& data, const RooLinkedList& cmdList); Internal back-end function to create a chi2. RooFitResult* chi2FitTo(RooDataSet& xydata, const RooCmdArg& arg1 = RooCmdArg::none(), const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()); Create a chi-2 from a series of x and y value stored in a dataset.; The y values can either be the event weights, or can be another column designated; by the YVar() argument. The y value must have errors defined for the chi-2 to; be well defined. The following named arguments are supported. Options to control construction of the chi^2. YVar(RooRealVar& yvar) -- Designate given column in dataset as Y value; Integrate(Bool_t flag) -- Integrate function over range specified by X errors; rather than take value at bin center. Options to control flow of fit procedure. InitialHesse(Bool_t flag) -- Flag controls if HESSE before MIGRAD as well, off by default; Hesse(Bool_t flag) -- Flag controls if HESSE is run after MIGRAD, on by default; Minos(Bool_t flag) -- Flag controls if MINOS is run after HESSE, on by default; Minos(const RooArgSet& set) -- Only run MINOS on given subset of arguments; Save(Bool_t flag) -- Flac controls if RooFitResult object is produced and returned, off by default; Strategy(Int_t flag) -- Set Minuit strategy (0 through 2, default is 1); FitOptions(const char* optStr) -- Steer fit with classic options string (for backward compatibility). Use of this option; excludes use of any of the new style steering options. Options to control informational output. Verbose(Bool_t flag) -- Flag controls if verbose output is printed (NLL, parameter changes during fit; Timer(Bool_t flag) -- Time CPU and wall c",MatchSource.WIKI,root/html602/RooAbsReal.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsReal.html
https://root.cern/root/html602/RooAbsReal.html:81689,Availability,error,errors,81689,"s run after HESSE, on by default; Minos(const RooArgSet& set) -- Only run MINOS on given subset of arguments; Save(Bool_t flag) -- Flac controls if RooFitResult object is produced and returned, off by default; Strategy(Int_t flag) -- Set Minuit strategy (0 through 2, default is 1); FitOptions(const char* optStr) -- Steer fit with classic options string (for backward compatibility). Use of this option; excludes use of any of the new style steering options. Options to control informational output. Verbose(Bool_t flag) -- Flag controls if verbose output is printed (NLL, parameter changes during fit; Timer(Bool_t flag) -- Time CPU and wall clock consumption of fit steps, off by default; PrintLevel(Int_t level) -- Set Minuit print level (-1 through 3, default is 1). At -1 all RooFit informational; messages are suppressed as well; Warnings(Bool_t flag) -- Enable or disable MINUIT warnings (enabled by default); PrintEvalErrors(Int_t numErr) -- Control number of p.d.f evaluation errors printed per likelihood evaluation. A negative; value suppress output completely, a zero value will only print the error count per p.d.f component,; a positive value is will print details of each error up to numErr messages per p.d.f component. RooFitResult* chi2FitTo(RooDataSet& xydata, const RooLinkedList& cmdList); Internal back-end function to steer chi2 fits. RooAbsReal* createChi2(RooDataSet& data, const RooCmdArg& arg1 = RooCmdArg::none(), const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()); Create a chi-2 from a series of x and y value stored in a dataset.; The y values can either be the event weights (default), or can be another column designated; by the YVar() argument. The y value must have errors defined for the chi-2 to; be well defined",MatchSource.WIKI,root/html602/RooAbsReal.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsReal.html
https://root.cern/root/html602/RooAbsReal.html:81810,Availability,error,error,81810,"NOS on given subset of arguments; Save(Bool_t flag) -- Flac controls if RooFitResult object is produced and returned, off by default; Strategy(Int_t flag) -- Set Minuit strategy (0 through 2, default is 1); FitOptions(const char* optStr) -- Steer fit with classic options string (for backward compatibility). Use of this option; excludes use of any of the new style steering options. Options to control informational output. Verbose(Bool_t flag) -- Flag controls if verbose output is printed (NLL, parameter changes during fit; Timer(Bool_t flag) -- Time CPU and wall clock consumption of fit steps, off by default; PrintLevel(Int_t level) -- Set Minuit print level (-1 through 3, default is 1). At -1 all RooFit informational; messages are suppressed as well; Warnings(Bool_t flag) -- Enable or disable MINUIT warnings (enabled by default); PrintEvalErrors(Int_t numErr) -- Control number of p.d.f evaluation errors printed per likelihood evaluation. A negative; value suppress output completely, a zero value will only print the error count per p.d.f component,; a positive value is will print details of each error up to numErr messages per p.d.f component. RooFitResult* chi2FitTo(RooDataSet& xydata, const RooLinkedList& cmdList); Internal back-end function to steer chi2 fits. RooAbsReal* createChi2(RooDataSet& data, const RooCmdArg& arg1 = RooCmdArg::none(), const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()); Create a chi-2 from a series of x and y value stored in a dataset.; The y values can either be the event weights (default), or can be another column designated; by the YVar() argument. The y value must have errors defined for the chi-2 to; be well defined. The following named arguments are supported. Options to control constructi",MatchSource.WIKI,root/html602/RooAbsReal.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsReal.html
https://root.cern/root/html602/RooAbsReal.html:81891,Availability,error,error,81891,"duced and returned, off by default; Strategy(Int_t flag) -- Set Minuit strategy (0 through 2, default is 1); FitOptions(const char* optStr) -- Steer fit with classic options string (for backward compatibility). Use of this option; excludes use of any of the new style steering options. Options to control informational output. Verbose(Bool_t flag) -- Flag controls if verbose output is printed (NLL, parameter changes during fit; Timer(Bool_t flag) -- Time CPU and wall clock consumption of fit steps, off by default; PrintLevel(Int_t level) -- Set Minuit print level (-1 through 3, default is 1). At -1 all RooFit informational; messages are suppressed as well; Warnings(Bool_t flag) -- Enable or disable MINUIT warnings (enabled by default); PrintEvalErrors(Int_t numErr) -- Control number of p.d.f evaluation errors printed per likelihood evaluation. A negative; value suppress output completely, a zero value will only print the error count per p.d.f component,; a positive value is will print details of each error up to numErr messages per p.d.f component. RooFitResult* chi2FitTo(RooDataSet& xydata, const RooLinkedList& cmdList); Internal back-end function to steer chi2 fits. RooAbsReal* createChi2(RooDataSet& data, const RooCmdArg& arg1 = RooCmdArg::none(), const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()); Create a chi-2 from a series of x and y value stored in a dataset.; The y values can either be the event weights (default), or can be another column designated; by the YVar() argument. The y value must have errors defined for the chi-2 to; be well defined. The following named arguments are supported. Options to control construction of the chi^2. YVar(RooRealVar& yvar) -- Designate given column in dataset as Y value; Integrate(",MatchSource.WIKI,root/html602/RooAbsReal.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsReal.html
https://root.cern/root/html602/RooAbsReal.html:82655,Availability,error,errors,82655," of p.d.f evaluation errors printed per likelihood evaluation. A negative; value suppress output completely, a zero value will only print the error count per p.d.f component,; a positive value is will print details of each error up to numErr messages per p.d.f component. RooFitResult* chi2FitTo(RooDataSet& xydata, const RooLinkedList& cmdList); Internal back-end function to steer chi2 fits. RooAbsReal* createChi2(RooDataSet& data, const RooCmdArg& arg1 = RooCmdArg::none(), const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()); Create a chi-2 from a series of x and y value stored in a dataset.; The y values can either be the event weights (default), or can be another column designated; by the YVar() argument. The y value must have errors defined for the chi-2 to; be well defined. The following named arguments are supported. Options to control construction of the chi^2. YVar(RooRealVar& yvar) -- Designate given column in dataset as Y value; Integrate(Bool_t flag) -- Integrate function over range specified by X errors; rather than take value at bin center. RooAbsReal* createChi2(RooDataSet& data, const RooLinkedList& cmdList); Internal back-end function to create a chi^2 from a function and a dataset. RooFitResult* chi2FitDriver(RooAbsReal& fcn, RooLinkedList& cmdList); Internal driver function for chi2 fits. void setEvalErrorLoggingMode(RooAbsReal::ErrorLoggingMode m); Set evaluation error logging mode. Options are. PrintErrors - Print each error through RooMsgService() as it occurs; CollectErrors - Accumulate errors, but do not print them. A subsequent call; to printEvalErrors() will print a summary; CountErrors - Accumulate error count, but do not print them. void setParameterizeIntegral(const RooArgSet& paramVars). Double_",MatchSource.WIKI,root/html602/RooAbsReal.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsReal.html
https://root.cern/root/html602/RooAbsReal.html:82939,Availability,error,errors,82939,"h error up to numErr messages per p.d.f component. RooFitResult* chi2FitTo(RooDataSet& xydata, const RooLinkedList& cmdList); Internal back-end function to steer chi2 fits. RooAbsReal* createChi2(RooDataSet& data, const RooCmdArg& arg1 = RooCmdArg::none(), const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()); Create a chi-2 from a series of x and y value stored in a dataset.; The y values can either be the event weights (default), or can be another column designated; by the YVar() argument. The y value must have errors defined for the chi-2 to; be well defined. The following named arguments are supported. Options to control construction of the chi^2. YVar(RooRealVar& yvar) -- Designate given column in dataset as Y value; Integrate(Bool_t flag) -- Integrate function over range specified by X errors; rather than take value at bin center. RooAbsReal* createChi2(RooDataSet& data, const RooLinkedList& cmdList); Internal back-end function to create a chi^2 from a function and a dataset. RooFitResult* chi2FitDriver(RooAbsReal& fcn, RooLinkedList& cmdList); Internal driver function for chi2 fits. void setEvalErrorLoggingMode(RooAbsReal::ErrorLoggingMode m); Set evaluation error logging mode. Options are. PrintErrors - Print each error through RooMsgService() as it occurs; CollectErrors - Accumulate errors, but do not print them. A subsequent call; to printEvalErrors() will print a summary; CountErrors - Accumulate error count, but do not print them. void setParameterizeIntegral(const RooArgSet& paramVars). Double_t getVal(const RooArgSet* set = 0) const; Return value and unit accessors. Double_t getVal(const RooArgSet& set) const; { return _fast ? _value : getValV(&set) ; }. const Text_t * getUnit() const; Return string with unit d",MatchSource.WIKI,root/html602/RooAbsReal.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsReal.html
https://root.cern/root/html602/RooAbsReal.html:83320,Availability,error,error,83320,"& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()); Create a chi-2 from a series of x and y value stored in a dataset.; The y values can either be the event weights (default), or can be another column designated; by the YVar() argument. The y value must have errors defined for the chi-2 to; be well defined. The following named arguments are supported. Options to control construction of the chi^2. YVar(RooRealVar& yvar) -- Designate given column in dataset as Y value; Integrate(Bool_t flag) -- Integrate function over range specified by X errors; rather than take value at bin center. RooAbsReal* createChi2(RooDataSet& data, const RooLinkedList& cmdList); Internal back-end function to create a chi^2 from a function and a dataset. RooFitResult* chi2FitDriver(RooAbsReal& fcn, RooLinkedList& cmdList); Internal driver function for chi2 fits. void setEvalErrorLoggingMode(RooAbsReal::ErrorLoggingMode m); Set evaluation error logging mode. Options are. PrintErrors - Print each error through RooMsgService() as it occurs; CollectErrors - Accumulate errors, but do not print them. A subsequent call; to printEvalErrors() will print a summary; CountErrors - Accumulate error count, but do not print them. void setParameterizeIntegral(const RooArgSet& paramVars). Double_t getVal(const RooArgSet* set = 0) const; Return value and unit accessors. Double_t getVal(const RooArgSet& set) const; { return _fast ? _value : getValV(&set) ; }. const Text_t * getUnit() const; Return string with unit description. void setUnit(const char* unit); Set unit description to given string. Bool_t forceAnalyticalInt(const RooAbsArg& ) const; Interface to force RooRealIntegral to offer given observable for internal integration; even if this is deemed unsafe. This default implementation returns always flase. void forceNumInt(Bool_t flag = kTRUE); If flag is true, all advertised analytical integrals will be",MatchSource.WIKI,root/html602/RooAbsReal.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsReal.html
https://root.cern/root/html602/RooAbsReal.html:83378,Availability,error,error,83378,"dArg& arg8 = RooCmdArg::none()); Create a chi-2 from a series of x and y value stored in a dataset.; The y values can either be the event weights (default), or can be another column designated; by the YVar() argument. The y value must have errors defined for the chi-2 to; be well defined. The following named arguments are supported. Options to control construction of the chi^2. YVar(RooRealVar& yvar) -- Designate given column in dataset as Y value; Integrate(Bool_t flag) -- Integrate function over range specified by X errors; rather than take value at bin center. RooAbsReal* createChi2(RooDataSet& data, const RooLinkedList& cmdList); Internal back-end function to create a chi^2 from a function and a dataset. RooFitResult* chi2FitDriver(RooAbsReal& fcn, RooLinkedList& cmdList); Internal driver function for chi2 fits. void setEvalErrorLoggingMode(RooAbsReal::ErrorLoggingMode m); Set evaluation error logging mode. Options are. PrintErrors - Print each error through RooMsgService() as it occurs; CollectErrors - Accumulate errors, but do not print them. A subsequent call; to printEvalErrors() will print a summary; CountErrors - Accumulate error count, but do not print them. void setParameterizeIntegral(const RooArgSet& paramVars). Double_t getVal(const RooArgSet* set = 0) const; Return value and unit accessors. Double_t getVal(const RooArgSet& set) const; { return _fast ? _value : getValV(&set) ; }. const Text_t * getUnit() const; Return string with unit description. void setUnit(const char* unit); Set unit description to given string. Bool_t forceAnalyticalInt(const RooAbsArg& ) const; Interface to force RooRealIntegral to offer given observable for internal integration; even if this is deemed unsafe. This default implementation returns always flase. void forceNumInt(Bool_t flag = kTRUE); If flag is true, all advertised analytical integrals will be ignored; and all integrals are calculated numerically. Bool_t getForceNumInt() const; { return _forceNumInt ; }. RooAbsReal*",MatchSource.WIKI,root/html602/RooAbsReal.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsReal.html
https://root.cern/root/html602/RooAbsReal.html:83449,Availability,error,errors,83449,"dArg& arg8 = RooCmdArg::none()); Create a chi-2 from a series of x and y value stored in a dataset.; The y values can either be the event weights (default), or can be another column designated; by the YVar() argument. The y value must have errors defined for the chi-2 to; be well defined. The following named arguments are supported. Options to control construction of the chi^2. YVar(RooRealVar& yvar) -- Designate given column in dataset as Y value; Integrate(Bool_t flag) -- Integrate function over range specified by X errors; rather than take value at bin center. RooAbsReal* createChi2(RooDataSet& data, const RooLinkedList& cmdList); Internal back-end function to create a chi^2 from a function and a dataset. RooFitResult* chi2FitDriver(RooAbsReal& fcn, RooLinkedList& cmdList); Internal driver function for chi2 fits. void setEvalErrorLoggingMode(RooAbsReal::ErrorLoggingMode m); Set evaluation error logging mode. Options are. PrintErrors - Print each error through RooMsgService() as it occurs; CollectErrors - Accumulate errors, but do not print them. A subsequent call; to printEvalErrors() will print a summary; CountErrors - Accumulate error count, but do not print them. void setParameterizeIntegral(const RooArgSet& paramVars). Double_t getVal(const RooArgSet* set = 0) const; Return value and unit accessors. Double_t getVal(const RooArgSet& set) const; { return _fast ? _value : getValV(&set) ; }. const Text_t * getUnit() const; Return string with unit description. void setUnit(const char* unit); Set unit description to given string. Bool_t forceAnalyticalInt(const RooAbsArg& ) const; Interface to force RooRealIntegral to offer given observable for internal integration; even if this is deemed unsafe. This default implementation returns always flase. void forceNumInt(Bool_t flag = kTRUE); If flag is true, all advertised analytical integrals will be ignored; and all integrals are calculated numerically. Bool_t getForceNumInt() const; { return _forceNumInt ; }. RooAbsReal*",MatchSource.WIKI,root/html602/RooAbsReal.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsReal.html
https://root.cern/root/html602/RooAbsReal.html:83567,Availability,error,error,83567,"be the event weights (default), or can be another column designated; by the YVar() argument. The y value must have errors defined for the chi-2 to; be well defined. The following named arguments are supported. Options to control construction of the chi^2. YVar(RooRealVar& yvar) -- Designate given column in dataset as Y value; Integrate(Bool_t flag) -- Integrate function over range specified by X errors; rather than take value at bin center. RooAbsReal* createChi2(RooDataSet& data, const RooLinkedList& cmdList); Internal back-end function to create a chi^2 from a function and a dataset. RooFitResult* chi2FitDriver(RooAbsReal& fcn, RooLinkedList& cmdList); Internal driver function for chi2 fits. void setEvalErrorLoggingMode(RooAbsReal::ErrorLoggingMode m); Set evaluation error logging mode. Options are. PrintErrors - Print each error through RooMsgService() as it occurs; CollectErrors - Accumulate errors, but do not print them. A subsequent call; to printEvalErrors() will print a summary; CountErrors - Accumulate error count, but do not print them. void setParameterizeIntegral(const RooArgSet& paramVars). Double_t getVal(const RooArgSet* set = 0) const; Return value and unit accessors. Double_t getVal(const RooArgSet& set) const; { return _fast ? _value : getValV(&set) ; }. const Text_t * getUnit() const; Return string with unit description. void setUnit(const char* unit); Set unit description to given string. Bool_t forceAnalyticalInt(const RooAbsArg& ) const; Interface to force RooRealIntegral to offer given observable for internal integration; even if this is deemed unsafe. This default implementation returns always flase. void forceNumInt(Bool_t flag = kTRUE); If flag is true, all advertised analytical integrals will be ignored; and all integrals are calculated numerically. Bool_t getForceNumInt() const; { return _forceNumInt ; }. RooAbsReal* createIntegral(const RooArgSet& iset, const RooCmdArg& arg1, const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg",MatchSource.WIKI,root/html602/RooAbsReal.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsReal.html
https://root.cern/root/html602/RooAbsReal.html:85300,Availability,error,error,85300," integrals will be ignored; and all integrals are calculated numerically. Bool_t getForceNumInt() const; { return _forceNumInt ; }. RooAbsReal* createIntegral(const RooArgSet& iset, const RooCmdArg& arg1, const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()) const; Create integral over observables in iset in range named rangeName. return createIntegral(iset,0,0,rangeName). RooAbsReal* createIntegral(const RooArgSet& iset, const RooArgSet& nset, const char* rangeName = 0) const; Create integral over observables in iset in range named rangeName with integrand normalized over observables in nset. return createIntegral(iset,&nset,0,rangeName). Int_t minTrialSamples(const RooArgSet& ) const; { return 0 ; }. Double_t defaultErrorLevel() const; Return default level for MINUIT error analysis. ErrorLoggingMode evalErrorLoggingMode(). EvalErrorIter evalErrorIter(). Bool_t isBinnedDistribution(const RooArgSet& ) const; { return kFALSE ; }. std::list<Double_t>* binBoundaries(RooAbsRealLValue& , Double_t , Double_t ) const; { return 0 ; }. std::list<Double_t>* plotSamplingHint(RooAbsRealLValue& , Double_t , Double_t ) const; Interface for returning an optional hint for initial sampling points when constructing a curve; projected on observable. RooAbsMoment* mean(RooRealVar& obs); { return moment(obs,1,kFALSE,kFALSE) ; }. RooAbsMoment* mean(RooRealVar& obs, const RooArgSet& nset); { return moment(obs,nset,1,kFALSE,kFALSE,kTRUE) ; }. RooAbsMoment* sigma(RooRealVar& obs); { return moment(obs,2,kTRUE,kTRUE) ; }. RooAbsMoment* sigma(RooRealVar& obs, const RooArgSet& nset); { return moment(obs,nset,2,kTRUE,kTRUE,kTRUE) ; }. Bool_t setData(RooAbsData& , Bool_t = kTRUE); { return kTRUE ; }. void enableOffsetting(Bool_t ); {}. Bool_t isOffsettin",MatchSource.WIKI,root/html602/RooAbsReal.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsReal.html
https://root.cern/root/html602/RooAbsReal.html:33690,Deployability,integrat,integration,33690,"onymous)TObject::kWriteDelete; static TObject::(anonymous)TObject::kZombie. protected:. set<string>RooAbsArg::_boolAttribBoolean attributes; set<string>RooAbsArg::_boolAttribTransient! Transient boolean attributes (not copied in ctor); Bool_t_boolValue! Transient cache for bool values from tree branches; UChar_t_byteValue! Transient cache for byte values from tree branches; static Bool_t_cacheCheckIf true, always validate contents of clean which outcome of evaluate(); deque<RooAbsCache*>RooAbsArg::_cacheListlist of caches; RooRefCountListRooAbsArg::_clientListlist of client objects; RooRefCountListRooAbsArg::_clientListShapesubset of clients that requested shape dirty flag propagation; RooRefCountListRooAbsArg::_clientListValuesubset of clients that requested value dirty flag propagation; TIterator*RooAbsArg::_clientShapeIter! Iterator over _clientListShape; TIterator*RooAbsArg::_clientValueIter! Iterator over _clientListValue; Bool_tRooAbsArg::_deleteWatch! Delete watch flag; RooExpensiveObjectCache*RooAbsArg::_eocachePointer to global cache manager for any expensive components created by this object; Bool_tRooAbsArg::_fastAllow fast access mode in getVal() and proxies; Float_t_floatValue! Transient cache for floating point values from tree branches; Bool_t_forceNumIntForce numerical integration if flag set; static Bool_t_globalSelectCompGlobal activation switch for component selection; static Bool_t_hideOffsetOffset hiding flag; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; Int_t_intValue! Transient cache for integer values from tree branches; Bool_tRooAbsArg::_isConstant! Cached isConstant status; TString_labelPlot label for objects value; RooArgSet*_lastNSet!; Bool_tRooAbsArg::_localNoInhibitDirty! Prevent 'AlwaysDirty' mode for this node; static Int_tRooPrintable::_nameLength; TNamed*RooAbsArg::_namePtr! Do not persist. Pointer to global instance of string that matches object named; RooAbsArg::OperModeRoo",MatchSource.WIKI,root/html602/RooAbsReal.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsReal.html
https://root.cern/root/html602/RooAbsReal.html:35096,Deployability,integrat,integrator,35096,"lues from tree branches; Bool_tRooAbsArg::_isConstant! Cached isConstant status; TString_labelPlot label for objects value; RooArgSet*_lastNSet!; Bool_tRooAbsArg::_localNoInhibitDirty! Prevent 'AlwaysDirty' mode for this node; static Int_tRooPrintable::_nameLength; TNamed*RooAbsArg::_namePtr! Do not persist. Pointer to global instance of string that matches object named; RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; Int_t_plotBinsNumber of plot bins; Double_t_plotMaxMaximum of plot range; Double_t_plotMinMinimum of plot range; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; RooRefArrayRooAbsArg::_proxyListlist of proxies; Char_t_sbyteValue! Transient cache for signed byte values from tree branches; Bool_t_selectComp! Component selection flag for RooAbsPdf::plotCompOn; RooRefCountListRooAbsArg::_serverListlist of server objects; Bool_tRooAbsArg::_shapeDirtyFlag set if value needs recalculating because input shapes modified; RooNumIntConfig*_specIntegratorConfigNumeric integrator configuration specific for this object; map<string,string>RooAbsArg::_stringAttribString attributes; Bool_t_treeVar!do not persist; UInt_t_uintValue! Transient cache for unsigned integer values from tree branches; TString_unitUnit for objects value; Double_t_valueCache for current value of object; Bool_tRooAbsArg::_valueDirtyFlag set if value needs recalculating because input values modified; static Bool_tRooAbsArg::_verboseDirtyStatic flag controlling verbose messaging for dirty state changes; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title. private:. static Int_t_evalErrorCount; static map<const RooAbsArg*,pair<string,list<RooAbsReal::EvalError> > >_evalErrorList; static RooAbsReal::ErrorLoggingMode_evalErrorMode. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; void setHideOffset(Bool_t flag); { _hide",MatchSource.WIKI,root/html602/RooAbsReal.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsReal.html
https://root.cern/root/html602/RooAbsReal.html:35107,Deployability,configurat,configuration,35107,"lues from tree branches; Bool_tRooAbsArg::_isConstant! Cached isConstant status; TString_labelPlot label for objects value; RooArgSet*_lastNSet!; Bool_tRooAbsArg::_localNoInhibitDirty! Prevent 'AlwaysDirty' mode for this node; static Int_tRooPrintable::_nameLength; TNamed*RooAbsArg::_namePtr! Do not persist. Pointer to global instance of string that matches object named; RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; Int_t_plotBinsNumber of plot bins; Double_t_plotMaxMaximum of plot range; Double_t_plotMinMinimum of plot range; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; RooRefArrayRooAbsArg::_proxyListlist of proxies; Char_t_sbyteValue! Transient cache for signed byte values from tree branches; Bool_t_selectComp! Component selection flag for RooAbsPdf::plotCompOn; RooRefCountListRooAbsArg::_serverListlist of server objects; Bool_tRooAbsArg::_shapeDirtyFlag set if value needs recalculating because input shapes modified; RooNumIntConfig*_specIntegratorConfigNumeric integrator configuration specific for this object; map<string,string>RooAbsArg::_stringAttribString attributes; Bool_t_treeVar!do not persist; UInt_t_uintValue! Transient cache for unsigned integer values from tree branches; TString_unitUnit for objects value; Double_t_valueCache for current value of object; Bool_tRooAbsArg::_valueDirtyFlag set if value needs recalculating because input values modified; static Bool_tRooAbsArg::_verboseDirtyStatic flag controlling verbose messaging for dirty state changes; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title. private:. static Int_t_evalErrorCount; static map<const RooAbsArg*,pair<string,list<RooAbsReal::EvalError> > >_evalErrorList; static RooAbsReal::ErrorLoggingMode_evalErrorMode. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; void setHideOffset(Bool_t flag); { _hide",MatchSource.WIKI,root/html602/RooAbsReal.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsReal.html
https://root.cern/root/html602/RooAbsReal.html:38060,Deployability,integrat,integration,38060,"t. If the cache is clean, return the; cached value, otherwise recalculate on the fly and refill; the cache. Int_t numEvalErrorItems(). Double_t traceEval(const RooArgSet* set) const; Calculate current value of object, with error tracing wrapper. Int_t getAnalyticalIntegralWN(RooArgSet& allVars, RooArgSet& analVars, const RooArgSet* normSet, const char* rangeName = 0) const; Variant of getAnalyticalIntegral that is also passed the normalization set; that should be applied to the integrand of which the integral is request.; For certain operator p.d.f it is useful to overload this function rather; than analyticalIntegralWN() as the additional normalization information; may be useful in determining a more efficient decomposition of the; requested integral. Int_t getAnalyticalIntegral(RooArgSet& allVars, RooArgSet& analVars, const char* rangeName = 0) const; Interface function getAnalyticalIntergral advertises the; analytical integrals that are supported. 'integSet'; is the set of dependents for which integration is requested. The; function should copy the subset of dependents it can analytically; integrate to anaIntSet and return a unique identification code for; this integration configuration. If no integration can be; performed, zero should be returned. Double_t analyticalIntegralWN(Int_t code, const RooArgSet* normSet, const char* rangeName = 0) const; Implements the actual analytical integral(s) advertised by; getAnalyticalIntegral. This functions will only be called with; codes returned by getAnalyticalIntegral, except code zero. Double_t analyticalIntegral(Int_t code, const char* rangeName = 0) const; Implements the actual analytical integral(s) advertised by; getAnalyticalIntegral. This functions will only be called with; codes returned by getAnalyticalIntegral, except code zero. const char * getPlotLabel() const; Get the label associated with the variable. void setPlotLabel(const char* label); Set the label associated with this variable. Bool_t readFromStream(ist",MatchSource.WIKI,root/html602/RooAbsReal.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsReal.html
https://root.cern/root/html602/RooAbsReal.html:38158,Deployability,integrat,integrate,38158,"rorItems(). Double_t traceEval(const RooArgSet* set) const; Calculate current value of object, with error tracing wrapper. Int_t getAnalyticalIntegralWN(RooArgSet& allVars, RooArgSet& analVars, const RooArgSet* normSet, const char* rangeName = 0) const; Variant of getAnalyticalIntegral that is also passed the normalization set; that should be applied to the integrand of which the integral is request.; For certain operator p.d.f it is useful to overload this function rather; than analyticalIntegralWN() as the additional normalization information; may be useful in determining a more efficient decomposition of the; requested integral. Int_t getAnalyticalIntegral(RooArgSet& allVars, RooArgSet& analVars, const char* rangeName = 0) const; Interface function getAnalyticalIntergral advertises the; analytical integrals that are supported. 'integSet'; is the set of dependents for which integration is requested. The; function should copy the subset of dependents it can analytically; integrate to anaIntSet and return a unique identification code for; this integration configuration. If no integration can be; performed, zero should be returned. Double_t analyticalIntegralWN(Int_t code, const RooArgSet* normSet, const char* rangeName = 0) const; Implements the actual analytical integral(s) advertised by; getAnalyticalIntegral. This functions will only be called with; codes returned by getAnalyticalIntegral, except code zero. Double_t analyticalIntegral(Int_t code, const char* rangeName = 0) const; Implements the actual analytical integral(s) advertised by; getAnalyticalIntegral. This functions will only be called with; codes returned by getAnalyticalIntegral, except code zero. const char * getPlotLabel() const; Get the label associated with the variable. void setPlotLabel(const char* label); Set the label associated with this variable. Bool_t readFromStream(istream& is, Bool_t compact, Bool_t verbose = kFALSE); Read object contents from stream (dummy for now). void writeToStream(o",MatchSource.WIKI,root/html602/RooAbsReal.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsReal.html
https://root.cern/root/html602/RooAbsReal.html:38231,Deployability,integrat,integration,38231,"rorItems(). Double_t traceEval(const RooArgSet* set) const; Calculate current value of object, with error tracing wrapper. Int_t getAnalyticalIntegralWN(RooArgSet& allVars, RooArgSet& analVars, const RooArgSet* normSet, const char* rangeName = 0) const; Variant of getAnalyticalIntegral that is also passed the normalization set; that should be applied to the integrand of which the integral is request.; For certain operator p.d.f it is useful to overload this function rather; than analyticalIntegralWN() as the additional normalization information; may be useful in determining a more efficient decomposition of the; requested integral. Int_t getAnalyticalIntegral(RooArgSet& allVars, RooArgSet& analVars, const char* rangeName = 0) const; Interface function getAnalyticalIntergral advertises the; analytical integrals that are supported. 'integSet'; is the set of dependents for which integration is requested. The; function should copy the subset of dependents it can analytically; integrate to anaIntSet and return a unique identification code for; this integration configuration. If no integration can be; performed, zero should be returned. Double_t analyticalIntegralWN(Int_t code, const RooArgSet* normSet, const char* rangeName = 0) const; Implements the actual analytical integral(s) advertised by; getAnalyticalIntegral. This functions will only be called with; codes returned by getAnalyticalIntegral, except code zero. Double_t analyticalIntegral(Int_t code, const char* rangeName = 0) const; Implements the actual analytical integral(s) advertised by; getAnalyticalIntegral. This functions will only be called with; codes returned by getAnalyticalIntegral, except code zero. const char * getPlotLabel() const; Get the label associated with the variable. void setPlotLabel(const char* label); Set the label associated with this variable. Bool_t readFromStream(istream& is, Bool_t compact, Bool_t verbose = kFALSE); Read object contents from stream (dummy for now). void writeToStream(o",MatchSource.WIKI,root/html602/RooAbsReal.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsReal.html
https://root.cern/root/html602/RooAbsReal.html:38243,Deployability,configurat,configuration,38243,"rorItems(). Double_t traceEval(const RooArgSet* set) const; Calculate current value of object, with error tracing wrapper. Int_t getAnalyticalIntegralWN(RooArgSet& allVars, RooArgSet& analVars, const RooArgSet* normSet, const char* rangeName = 0) const; Variant of getAnalyticalIntegral that is also passed the normalization set; that should be applied to the integrand of which the integral is request.; For certain operator p.d.f it is useful to overload this function rather; than analyticalIntegralWN() as the additional normalization information; may be useful in determining a more efficient decomposition of the; requested integral. Int_t getAnalyticalIntegral(RooArgSet& allVars, RooArgSet& analVars, const char* rangeName = 0) const; Interface function getAnalyticalIntergral advertises the; analytical integrals that are supported. 'integSet'; is the set of dependents for which integration is requested. The; function should copy the subset of dependents it can analytically; integrate to anaIntSet and return a unique identification code for; this integration configuration. If no integration can be; performed, zero should be returned. Double_t analyticalIntegralWN(Int_t code, const RooArgSet* normSet, const char* rangeName = 0) const; Implements the actual analytical integral(s) advertised by; getAnalyticalIntegral. This functions will only be called with; codes returned by getAnalyticalIntegral, except code zero. Double_t analyticalIntegral(Int_t code, const char* rangeName = 0) const; Implements the actual analytical integral(s) advertised by; getAnalyticalIntegral. This functions will only be called with; codes returned by getAnalyticalIntegral, except code zero. const char * getPlotLabel() const; Get the label associated with the variable. void setPlotLabel(const char* label); Set the label associated with this variable. Bool_t readFromStream(istream& is, Bool_t compact, Bool_t verbose = kFALSE); Read object contents from stream (dummy for now). void writeToStream(o",MatchSource.WIKI,root/html602/RooAbsReal.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsReal.html
https://root.cern/root/html602/RooAbsReal.html:38264,Deployability,integrat,integration,38264,"pper. Int_t getAnalyticalIntegralWN(RooArgSet& allVars, RooArgSet& analVars, const RooArgSet* normSet, const char* rangeName = 0) const; Variant of getAnalyticalIntegral that is also passed the normalization set; that should be applied to the integrand of which the integral is request.; For certain operator p.d.f it is useful to overload this function rather; than analyticalIntegralWN() as the additional normalization information; may be useful in determining a more efficient decomposition of the; requested integral. Int_t getAnalyticalIntegral(RooArgSet& allVars, RooArgSet& analVars, const char* rangeName = 0) const; Interface function getAnalyticalIntergral advertises the; analytical integrals that are supported. 'integSet'; is the set of dependents for which integration is requested. The; function should copy the subset of dependents it can analytically; integrate to anaIntSet and return a unique identification code for; this integration configuration. If no integration can be; performed, zero should be returned. Double_t analyticalIntegralWN(Int_t code, const RooArgSet* normSet, const char* rangeName = 0) const; Implements the actual analytical integral(s) advertised by; getAnalyticalIntegral. This functions will only be called with; codes returned by getAnalyticalIntegral, except code zero. Double_t analyticalIntegral(Int_t code, const char* rangeName = 0) const; Implements the actual analytical integral(s) advertised by; getAnalyticalIntegral. This functions will only be called with; codes returned by getAnalyticalIntegral, except code zero. const char * getPlotLabel() const; Get the label associated with the variable. void setPlotLabel(const char* label); Set the label associated with this variable. Bool_t readFromStream(istream& is, Bool_t compact, Bool_t verbose = kFALSE); Read object contents from stream (dummy for now). void writeToStream(ostream& os, Bool_t compact) const; Write object contents to stream (dummy for now). void printValue(ostream& os) cons",MatchSource.WIKI,root/html602/RooAbsReal.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsReal.html
https://root.cern/root/html602/RooAbsReal.html:40457,Deployability,integrat,integration,40457,"or now). void printValue(ostream& os) const; Print object value. void printMultiline(ostream& os, Int_t contents, Bool_t verbose = kFALSE, TString indent = """") const; Structure printing. Bool_t isValid() const; Check if current value is valid. Bool_t isValidReal(Double_t value, Bool_t printError = kFALSE) const; Interface function to check if given value is a valid value for this object.; This default implementation considers all values valid. RooAbsReal* createProfile(const RooArgSet& paramsOfInterest); Create a RooProfileLL object that eliminates all nuisance parameters in the; present function. The nuisance parameters are defined as all parameters; of the function except the stated paramsOfInterest. RooAbsReal* createIntegral(const RooArgSet& iset, const RooCmdArg& arg1, const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()) const; Create an object that represents the integral of the function over one or more observables listed in iset; The actual integration calculation is only performed when the return object is evaluated. The name; of the integral object is automatically constructed from the name of the input function, the variables; it integrates and the range integrates over. The following named arguments are accepted. NormSet(const RooArgSet&) -- Specify normalization set, mostly useful when working with PDFS; NumIntConfig(const RooNumIntConfig&) -- Use given configuration for any numeric integration, if necessary; Range(const char* name) -- Integrate only over given range. Multiple ranges may be specified; by passing multiple Range() arguments. RooAbsReal* createIntegral(const RooArgSet& iset, const RooArgSet* nset = 0, const RooNumIntConfig* cfg = 0, const char* rangeName = 0) const; Create an object that represen",MatchSource.WIKI,root/html602/RooAbsReal.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsReal.html
https://root.cern/root/html602/RooAbsReal.html:40653,Deployability,integrat,integrates,40653,"value for this object.; This default implementation considers all values valid. RooAbsReal* createProfile(const RooArgSet& paramsOfInterest); Create a RooProfileLL object that eliminates all nuisance parameters in the; present function. The nuisance parameters are defined as all parameters; of the function except the stated paramsOfInterest. RooAbsReal* createIntegral(const RooArgSet& iset, const RooCmdArg& arg1, const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()) const; Create an object that represents the integral of the function over one or more observables listed in iset; The actual integration calculation is only performed when the return object is evaluated. The name; of the integral object is automatically constructed from the name of the input function, the variables; it integrates and the range integrates over. The following named arguments are accepted. NormSet(const RooArgSet&) -- Specify normalization set, mostly useful when working with PDFS; NumIntConfig(const RooNumIntConfig&) -- Use given configuration for any numeric integration, if necessary; Range(const char* name) -- Integrate only over given range. Multiple ranges may be specified; by passing multiple Range() arguments. RooAbsReal* createIntegral(const RooArgSet& iset, const RooArgSet* nset = 0, const RooNumIntConfig* cfg = 0, const char* rangeName = 0) const; Create an object that represents the integral of the function over one or more observables listed in iset; The actual integration calculation is only performed when the return object is evaluated. The name; of the integral object is automatically constructed from the name of the input function, the variables; it integrates and the range integrates over. If nset is specified the integrand is reque",MatchSource.WIKI,root/html602/RooAbsReal.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsReal.html
https://root.cern/root/html602/RooAbsReal.html:40678,Deployability,integrat,integrates,40678,"value for this object.; This default implementation considers all values valid. RooAbsReal* createProfile(const RooArgSet& paramsOfInterest); Create a RooProfileLL object that eliminates all nuisance parameters in the; present function. The nuisance parameters are defined as all parameters; of the function except the stated paramsOfInterest. RooAbsReal* createIntegral(const RooArgSet& iset, const RooCmdArg& arg1, const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()) const; Create an object that represents the integral of the function over one or more observables listed in iset; The actual integration calculation is only performed when the return object is evaluated. The name; of the integral object is automatically constructed from the name of the input function, the variables; it integrates and the range integrates over. The following named arguments are accepted. NormSet(const RooArgSet&) -- Specify normalization set, mostly useful when working with PDFS; NumIntConfig(const RooNumIntConfig&) -- Use given configuration for any numeric integration, if necessary; Range(const char* name) -- Integrate only over given range. Multiple ranges may be specified; by passing multiple Range() arguments. RooAbsReal* createIntegral(const RooArgSet& iset, const RooArgSet* nset = 0, const RooNumIntConfig* cfg = 0, const char* rangeName = 0) const; Create an object that represents the integral of the function over one or more observables listed in iset; The actual integration calculation is only performed when the return object is evaluated. The name; of the integral object is automatically constructed from the name of the input function, the variables; it integrates and the range integrates over. If nset is specified the integrand is reque",MatchSource.WIKI,root/html602/RooAbsReal.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsReal.html
https://root.cern/root/html602/RooAbsReal.html:40883,Deployability,configurat,configuration,40883,"meters are defined as all parameters; of the function except the stated paramsOfInterest. RooAbsReal* createIntegral(const RooArgSet& iset, const RooCmdArg& arg1, const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()) const; Create an object that represents the integral of the function over one or more observables listed in iset; The actual integration calculation is only performed when the return object is evaluated. The name; of the integral object is automatically constructed from the name of the input function, the variables; it integrates and the range integrates over. The following named arguments are accepted. NormSet(const RooArgSet&) -- Specify normalization set, mostly useful when working with PDFS; NumIntConfig(const RooNumIntConfig&) -- Use given configuration for any numeric integration, if necessary; Range(const char* name) -- Integrate only over given range. Multiple ranges may be specified; by passing multiple Range() arguments. RooAbsReal* createIntegral(const RooArgSet& iset, const RooArgSet* nset = 0, const RooNumIntConfig* cfg = 0, const char* rangeName = 0) const; Create an object that represents the integral of the function over one or more observables listed in iset; The actual integration calculation is only performed when the return object is evaluated. The name; of the integral object is automatically constructed from the name of the input function, the variables; it integrates and the range integrates over. If nset is specified the integrand is request; to be normalized over nset (only meaningful when the integrand is a pdf). If rangename is specified; the integral is performed over the named range, otherwise it is performed over the domain of each; integrated observable. If cfg is specified it will",MatchSource.WIKI,root/html602/RooAbsReal.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsReal.html
https://root.cern/root/html602/RooAbsReal.html:40913,Deployability,integrat,integration,40913,"meters are defined as all parameters; of the function except the stated paramsOfInterest. RooAbsReal* createIntegral(const RooArgSet& iset, const RooCmdArg& arg1, const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()) const; Create an object that represents the integral of the function over one or more observables listed in iset; The actual integration calculation is only performed when the return object is evaluated. The name; of the integral object is automatically constructed from the name of the input function, the variables; it integrates and the range integrates over. The following named arguments are accepted. NormSet(const RooArgSet&) -- Specify normalization set, mostly useful when working with PDFS; NumIntConfig(const RooNumIntConfig&) -- Use given configuration for any numeric integration, if necessary; Range(const char* name) -- Integrate only over given range. Multiple ranges may be specified; by passing multiple Range() arguments. RooAbsReal* createIntegral(const RooArgSet& iset, const RooArgSet* nset = 0, const RooNumIntConfig* cfg = 0, const char* rangeName = 0) const; Create an object that represents the integral of the function over one or more observables listed in iset; The actual integration calculation is only performed when the return object is evaluated. The name; of the integral object is automatically constructed from the name of the input function, the variables; it integrates and the range integrates over. If nset is specified the integrand is request; to be normalized over nset (only meaningful when the integrand is a pdf). If rangename is specified; the integral is performed over the named range, otherwise it is performed over the domain of each; integrated observable. If cfg is specified it will",MatchSource.WIKI,root/html602/RooAbsReal.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsReal.html
https://root.cern/root/html602/RooAbsReal.html:41334,Deployability,integrat,integration,41334,"(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()) const; Create an object that represents the integral of the function over one or more observables listed in iset; The actual integration calculation is only performed when the return object is evaluated. The name; of the integral object is automatically constructed from the name of the input function, the variables; it integrates and the range integrates over. The following named arguments are accepted. NormSet(const RooArgSet&) -- Specify normalization set, mostly useful when working with PDFS; NumIntConfig(const RooNumIntConfig&) -- Use given configuration for any numeric integration, if necessary; Range(const char* name) -- Integrate only over given range. Multiple ranges may be specified; by passing multiple Range() arguments. RooAbsReal* createIntegral(const RooArgSet& iset, const RooArgSet* nset = 0, const RooNumIntConfig* cfg = 0, const char* rangeName = 0) const; Create an object that represents the integral of the function over one or more observables listed in iset; The actual integration calculation is only performed when the return object is evaluated. The name; of the integral object is automatically constructed from the name of the input function, the variables; it integrates and the range integrates over. If nset is specified the integrand is request; to be normalized over nset (only meaningful when the integrand is a pdf). If rangename is specified; the integral is performed over the named range, otherwise it is performed over the domain of each; integrated observable. If cfg is specified it will be used to configure any numeric integration; aspect of the integral. It will not force the integral to be performed numerically, which is; decided automatically by RooRealIntegral. RooAbsReal* createIntObj(const RooArgSet& iset, const RooArgSet* nset, const RooNumIntConfig* cfg, const char* rangeName) const; Utility function for createIntegral that creates the actual i",MatchSource.WIKI,root/html602/RooAbsReal.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsReal.html
https://root.cern/root/html602/RooAbsReal.html:41530,Deployability,integrat,integrates,41530,"rformed when the return object is evaluated. The name; of the integral object is automatically constructed from the name of the input function, the variables; it integrates and the range integrates over. The following named arguments are accepted. NormSet(const RooArgSet&) -- Specify normalization set, mostly useful when working with PDFS; NumIntConfig(const RooNumIntConfig&) -- Use given configuration for any numeric integration, if necessary; Range(const char* name) -- Integrate only over given range. Multiple ranges may be specified; by passing multiple Range() arguments. RooAbsReal* createIntegral(const RooArgSet& iset, const RooArgSet* nset = 0, const RooNumIntConfig* cfg = 0, const char* rangeName = 0) const; Create an object that represents the integral of the function over one or more observables listed in iset; The actual integration calculation is only performed when the return object is evaluated. The name; of the integral object is automatically constructed from the name of the input function, the variables; it integrates and the range integrates over. If nset is specified the integrand is request; to be normalized over nset (only meaningful when the integrand is a pdf). If rangename is specified; the integral is performed over the named range, otherwise it is performed over the domain of each; integrated observable. If cfg is specified it will be used to configure any numeric integration; aspect of the integral. It will not force the integral to be performed numerically, which is; decided automatically by RooRealIntegral. RooAbsReal* createIntObj(const RooArgSet& iset, const RooArgSet* nset, const RooNumIntConfig* cfg, const char* rangeName) const; Utility function for createIntegral that creates the actual integreal object. void findInnerMostIntegration(const RooArgSet& allObs, RooArgSet& innerObs, const char* rangeName) const; Utility function for createIntObj() that aids in the construct of recursive integrals; over functions with multiple observables",MatchSource.WIKI,root/html602/RooAbsReal.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsReal.html
https://root.cern/root/html602/RooAbsReal.html:41555,Deployability,integrat,integrates,41555,"rformed when the return object is evaluated. The name; of the integral object is automatically constructed from the name of the input function, the variables; it integrates and the range integrates over. The following named arguments are accepted. NormSet(const RooArgSet&) -- Specify normalization set, mostly useful when working with PDFS; NumIntConfig(const RooNumIntConfig&) -- Use given configuration for any numeric integration, if necessary; Range(const char* name) -- Integrate only over given range. Multiple ranges may be specified; by passing multiple Range() arguments. RooAbsReal* createIntegral(const RooArgSet& iset, const RooArgSet* nset = 0, const RooNumIntConfig* cfg = 0, const char* rangeName = 0) const; Create an object that represents the integral of the function over one or more observables listed in iset; The actual integration calculation is only performed when the return object is evaluated. The name; of the integral object is automatically constructed from the name of the input function, the variables; it integrates and the range integrates over. If nset is specified the integrand is request; to be normalized over nset (only meaningful when the integrand is a pdf). If rangename is specified; the integral is performed over the named range, otherwise it is performed over the domain of each; integrated observable. If cfg is specified it will be used to configure any numeric integration; aspect of the integral. It will not force the integral to be performed numerically, which is; decided automatically by RooRealIntegral. RooAbsReal* createIntObj(const RooArgSet& iset, const RooArgSet* nset, const RooNumIntConfig* cfg, const char* rangeName) const; Utility function for createIntegral that creates the actual integreal object. void findInnerMostIntegration(const RooArgSet& allObs, RooArgSet& innerObs, const char* rangeName) const; Utility function for createIntObj() that aids in the construct of recursive integrals; over functions with multiple observables",MatchSource.WIKI,root/html602/RooAbsReal.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsReal.html
https://root.cern/root/html602/RooAbsReal.html:41819,Deployability,integrat,integrated,41819,"- Specify normalization set, mostly useful when working with PDFS; NumIntConfig(const RooNumIntConfig&) -- Use given configuration for any numeric integration, if necessary; Range(const char* name) -- Integrate only over given range. Multiple ranges may be specified; by passing multiple Range() arguments. RooAbsReal* createIntegral(const RooArgSet& iset, const RooArgSet* nset = 0, const RooNumIntConfig* cfg = 0, const char* rangeName = 0) const; Create an object that represents the integral of the function over one or more observables listed in iset; The actual integration calculation is only performed when the return object is evaluated. The name; of the integral object is automatically constructed from the name of the input function, the variables; it integrates and the range integrates over. If nset is specified the integrand is request; to be normalized over nset (only meaningful when the integrand is a pdf). If rangename is specified; the integral is performed over the named range, otherwise it is performed over the domain of each; integrated observable. If cfg is specified it will be used to configure any numeric integration; aspect of the integral. It will not force the integral to be performed numerically, which is; decided automatically by RooRealIntegral. RooAbsReal* createIntObj(const RooArgSet& iset, const RooArgSet* nset, const RooNumIntConfig* cfg, const char* rangeName) const; Utility function for createIntegral that creates the actual integreal object. void findInnerMostIntegration(const RooArgSet& allObs, RooArgSet& innerObs, const char* rangeName) const; Utility function for createIntObj() that aids in the construct of recursive integrals; over functions with multiple observables with parameterized ranges. This function; finds in a given set allObs over which integration is requested the largeset subset; of observables that can be integrated simultaneously. This subset consists of; observables with fixed ranges and observables with parameterized ran",MatchSource.WIKI,root/html602/RooAbsReal.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsReal.html
https://root.cern/root/html602/RooAbsReal.html:41903,Deployability,integrat,integration,41903,"ration for any numeric integration, if necessary; Range(const char* name) -- Integrate only over given range. Multiple ranges may be specified; by passing multiple Range() arguments. RooAbsReal* createIntegral(const RooArgSet& iset, const RooArgSet* nset = 0, const RooNumIntConfig* cfg = 0, const char* rangeName = 0) const; Create an object that represents the integral of the function over one or more observables listed in iset; The actual integration calculation is only performed when the return object is evaluated. The name; of the integral object is automatically constructed from the name of the input function, the variables; it integrates and the range integrates over. If nset is specified the integrand is request; to be normalized over nset (only meaningful when the integrand is a pdf). If rangename is specified; the integral is performed over the named range, otherwise it is performed over the domain of each; integrated observable. If cfg is specified it will be used to configure any numeric integration; aspect of the integral. It will not force the integral to be performed numerically, which is; decided automatically by RooRealIntegral. RooAbsReal* createIntObj(const RooArgSet& iset, const RooArgSet* nset, const RooNumIntConfig* cfg, const char* rangeName) const; Utility function for createIntegral that creates the actual integreal object. void findInnerMostIntegration(const RooArgSet& allObs, RooArgSet& innerObs, const char* rangeName) const; Utility function for createIntObj() that aids in the construct of recursive integrals; over functions with multiple observables with parameterized ranges. This function; finds in a given set allObs over which integration is requested the largeset subset; of observables that can be integrated simultaneously. This subset consists of; observables with fixed ranges and observables with parameterized ranges whose; parameterization does not depend on any observable that is also integrated. TString integralNameSuffix(const Roo",MatchSource.WIKI,root/html602/RooAbsReal.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsReal.html
https://root.cern/root/html602/RooAbsReal.html:42574,Deployability,integrat,integration,42574," integrand is request; to be normalized over nset (only meaningful when the integrand is a pdf). If rangename is specified; the integral is performed over the named range, otherwise it is performed over the domain of each; integrated observable. If cfg is specified it will be used to configure any numeric integration; aspect of the integral. It will not force the integral to be performed numerically, which is; decided automatically by RooRealIntegral. RooAbsReal* createIntObj(const RooArgSet& iset, const RooArgSet* nset, const RooNumIntConfig* cfg, const char* rangeName) const; Utility function for createIntegral that creates the actual integreal object. void findInnerMostIntegration(const RooArgSet& allObs, RooArgSet& innerObs, const char* rangeName) const; Utility function for createIntObj() that aids in the construct of recursive integrals; over functions with multiple observables with parameterized ranges. This function; finds in a given set allObs over which integration is requested the largeset subset; of observables that can be integrated simultaneously. This subset consists of; observables with fixed ranges and observables with parameterized ranges whose; parameterization does not depend on any observable that is also integrated. TString integralNameSuffix(const RooArgSet& iset, const RooArgSet* nset = 0, const char* rangeName = 0, Bool_t omitEmpty = kFALSE) const; Construct string with unique suffix name to give to integral object that encodes; integrated observables, normalization observables and the integration range name. const RooAbsReal* createPlotProjection(const RooArgSet& depVars, const RooArgSet& projVars, RooArgSet*& cloneSet) const; Utility function for plotOn() that creates a projection of a function or p.d.f; to be plotted on a RooPlot. const RooAbsReal* createPlotProjection(const RooArgSet& depVars, const RooArgSet& projVars) const; Utility function for plotOn() that creates a projection of a function or p.d.f; to be plotted on a RooPlot. cons",MatchSource.WIKI,root/html602/RooAbsReal.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsReal.html
https://root.cern/root/html602/RooAbsReal.html:42647,Deployability,integrat,integrated,42647," integrand is request; to be normalized over nset (only meaningful when the integrand is a pdf). If rangename is specified; the integral is performed over the named range, otherwise it is performed over the domain of each; integrated observable. If cfg is specified it will be used to configure any numeric integration; aspect of the integral. It will not force the integral to be performed numerically, which is; decided automatically by RooRealIntegral. RooAbsReal* createIntObj(const RooArgSet& iset, const RooArgSet* nset, const RooNumIntConfig* cfg, const char* rangeName) const; Utility function for createIntegral that creates the actual integreal object. void findInnerMostIntegration(const RooArgSet& allObs, RooArgSet& innerObs, const char* rangeName) const; Utility function for createIntObj() that aids in the construct of recursive integrals; over functions with multiple observables with parameterized ranges. This function; finds in a given set allObs over which integration is requested the largeset subset; of observables that can be integrated simultaneously. This subset consists of; observables with fixed ranges and observables with parameterized ranges whose; parameterization does not depend on any observable that is also integrated. TString integralNameSuffix(const RooArgSet& iset, const RooArgSet* nset = 0, const char* rangeName = 0, Bool_t omitEmpty = kFALSE) const; Construct string with unique suffix name to give to integral object that encodes; integrated observables, normalization observables and the integration range name. const RooAbsReal* createPlotProjection(const RooArgSet& depVars, const RooArgSet& projVars, RooArgSet*& cloneSet) const; Utility function for plotOn() that creates a projection of a function or p.d.f; to be plotted on a RooPlot. const RooAbsReal* createPlotProjection(const RooArgSet& depVars, const RooArgSet& projVars) const; Utility function for plotOn() that creates a projection of a function or p.d.f; to be plotted on a RooPlot. cons",MatchSource.WIKI,root/html602/RooAbsReal.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsReal.html
https://root.cern/root/html602/RooAbsReal.html:42842,Deployability,integrat,integrated,42842,"nge, otherwise it is performed over the domain of each; integrated observable. If cfg is specified it will be used to configure any numeric integration; aspect of the integral. It will not force the integral to be performed numerically, which is; decided automatically by RooRealIntegral. RooAbsReal* createIntObj(const RooArgSet& iset, const RooArgSet* nset, const RooNumIntConfig* cfg, const char* rangeName) const; Utility function for createIntegral that creates the actual integreal object. void findInnerMostIntegration(const RooArgSet& allObs, RooArgSet& innerObs, const char* rangeName) const; Utility function for createIntObj() that aids in the construct of recursive integrals; over functions with multiple observables with parameterized ranges. This function; finds in a given set allObs over which integration is requested the largeset subset; of observables that can be integrated simultaneously. This subset consists of; observables with fixed ranges and observables with parameterized ranges whose; parameterization does not depend on any observable that is also integrated. TString integralNameSuffix(const RooArgSet& iset, const RooArgSet* nset = 0, const char* rangeName = 0, Bool_t omitEmpty = kFALSE) const; Construct string with unique suffix name to give to integral object that encodes; integrated observables, normalization observables and the integration range name. const RooAbsReal* createPlotProjection(const RooArgSet& depVars, const RooArgSet& projVars, RooArgSet*& cloneSet) const; Utility function for plotOn() that creates a projection of a function or p.d.f; to be plotted on a RooPlot. const RooAbsReal* createPlotProjection(const RooArgSet& depVars, const RooArgSet& projVars) const; Utility function for plotOn() that creates a projection of a function or p.d.f; to be plotted on a RooPlot. const RooAbsReal * createPlotProjection(const RooArgSet& dependentVars, const RooArgSet* projectedVars, RooArgSet*& cloneSet, const char* rangeName = 0, const RooArgSet* c",MatchSource.WIKI,root/html602/RooAbsReal.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsReal.html
https://root.cern/root/html602/RooAbsReal.html:43074,Deployability,integrat,integrated,43074,"h is; decided automatically by RooRealIntegral. RooAbsReal* createIntObj(const RooArgSet& iset, const RooArgSet* nset, const RooNumIntConfig* cfg, const char* rangeName) const; Utility function for createIntegral that creates the actual integreal object. void findInnerMostIntegration(const RooArgSet& allObs, RooArgSet& innerObs, const char* rangeName) const; Utility function for createIntObj() that aids in the construct of recursive integrals; over functions with multiple observables with parameterized ranges. This function; finds in a given set allObs over which integration is requested the largeset subset; of observables that can be integrated simultaneously. This subset consists of; observables with fixed ranges and observables with parameterized ranges whose; parameterization does not depend on any observable that is also integrated. TString integralNameSuffix(const RooArgSet& iset, const RooArgSet* nset = 0, const char* rangeName = 0, Bool_t omitEmpty = kFALSE) const; Construct string with unique suffix name to give to integral object that encodes; integrated observables, normalization observables and the integration range name. const RooAbsReal* createPlotProjection(const RooArgSet& depVars, const RooArgSet& projVars, RooArgSet*& cloneSet) const; Utility function for plotOn() that creates a projection of a function or p.d.f; to be plotted on a RooPlot. const RooAbsReal* createPlotProjection(const RooArgSet& depVars, const RooArgSet& projVars) const; Utility function for plotOn() that creates a projection of a function or p.d.f; to be plotted on a RooPlot. const RooAbsReal * createPlotProjection(const RooArgSet& dependentVars, const RooArgSet* projectedVars, RooArgSet*& cloneSet, const char* rangeName = 0, const RooArgSet* condObs = 0) const; Utility function for plotOn() that creates a projection of a function or p.d.f; to be plotted on a RooPlot. Create a new object G that represents the normalized projection:. Integral [ F[x,y,p] , { y } ]; G[x,p] = --------",MatchSource.WIKI,root/html602/RooAbsReal.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsReal.html
https://root.cern/root/html602/RooAbsReal.html:43132,Deployability,integrat,integration,43132,"h is; decided automatically by RooRealIntegral. RooAbsReal* createIntObj(const RooArgSet& iset, const RooArgSet* nset, const RooNumIntConfig* cfg, const char* rangeName) const; Utility function for createIntegral that creates the actual integreal object. void findInnerMostIntegration(const RooArgSet& allObs, RooArgSet& innerObs, const char* rangeName) const; Utility function for createIntObj() that aids in the construct of recursive integrals; over functions with multiple observables with parameterized ranges. This function; finds in a given set allObs over which integration is requested the largeset subset; of observables that can be integrated simultaneously. This subset consists of; observables with fixed ranges and observables with parameterized ranges whose; parameterization does not depend on any observable that is also integrated. TString integralNameSuffix(const RooArgSet& iset, const RooArgSet* nset = 0, const char* rangeName = 0, Bool_t omitEmpty = kFALSE) const; Construct string with unique suffix name to give to integral object that encodes; integrated observables, normalization observables and the integration range name. const RooAbsReal* createPlotProjection(const RooArgSet& depVars, const RooArgSet& projVars, RooArgSet*& cloneSet) const; Utility function for plotOn() that creates a projection of a function or p.d.f; to be plotted on a RooPlot. const RooAbsReal* createPlotProjection(const RooArgSet& depVars, const RooArgSet& projVars) const; Utility function for plotOn() that creates a projection of a function or p.d.f; to be plotted on a RooPlot. const RooAbsReal * createPlotProjection(const RooArgSet& dependentVars, const RooArgSet* projectedVars, RooArgSet*& cloneSet, const char* rangeName = 0, const RooArgSet* condObs = 0) const; Utility function for plotOn() that creates a projection of a function or p.d.f; to be plotted on a RooPlot. Create a new object G that represents the normalized projection:. Integral [ F[x,y,p] , { y } ]; G[x,p] = --------",MatchSource.WIKI,root/html602/RooAbsReal.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsReal.html
https://root.cern/root/html602/RooAbsReal.html:44765,Deployability,integrat,integrating,44765,"ction for plotOn() that creates a projection of a function or p.d.f; to be plotted on a RooPlot. Create a new object G that represents the normalized projection:. Integral [ F[x,y,p] , { y } ]; G[x,p] = ---------------------------------; Integral [ F[x,y,p] , { x,y } ]. where F[x,y,p] is the function we represent, ""x"" are the; specified dependentVars, ""y"" are the specified projectedVars, and; ""p"" are our remaining variables (""parameters""). Return a; pointer to the newly created object, or else zero in case of an; error. The caller is responsible for deleting the contents of; cloneSet (which includes the returned projection object). TH1 * fillHistogram(TH1* hist, const RooArgList& plotVars, Double_t scaleFactor = 1, const RooArgSet* projectedVars = 0, Bool_t scaling = kTRUE, const RooArgSet* condObs = 0, Bool_t setError = kTRUE) const; Fill the ROOT histogram 'hist' with values sampled from this; function at the bin centers. Our value is calculated by first; integrating out any variables in projectedVars and then scaling; the result by scaleFactor. Returns a pointer to the input; histogram, or zero in case of an error. The input histogram can; be any TH1 subclass, and therefore of arbitrary; dimension. Variables are matched with the (x,y,...) dimensions of; the input histogram according to the order in which they appear; in the input plotVars list. If scaleForDensity is true the; histogram is filled with a the functions density rather than; the functions value (i.e. the value at the bin center is multiplied; with bin volume). RooDataHist* fillDataHist(RooDataHist* hist, const RooArgSet* nset, Double_t scaleFactor, Bool_t correctForBinVolume = kFALSE, Bool_t showProgress = kFALSE) const; Fill a RooDataHist with values sampled from this function at the; bin centers. If extendedMode is true, the p.d.f. values is multiplied; by the number of expected events in each bin. An optional scaling by a given scaleFactor can be performed.; Returns a pointer to the input RooDataHi",MatchSource.WIKI,root/html602/RooAbsReal.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsReal.html
https://root.cern/root/html602/RooAbsReal.html:49597,Deployability,integrat,integrated,49597,"nst; Helper function for plotting of composite p.d.fs. Given; a set of selected components that should be plotted,; find all nodes that (in)directly depend on these selected; nodes. Mark all directly and indirecty selected nodes; as 'selected' using the selectComp() method. RooPlot* plotOn(RooPlot* frame, const RooCmdArg& arg1 = RooCmdArg(), const RooCmdArg& arg2 = RooCmdArg(), const RooCmdArg& arg3 = RooCmdArg(), const RooCmdArg& arg4 = RooCmdArg(), const RooCmdArg& arg5 = RooCmdArg(), const RooCmdArg& arg6 = RooCmdArg(), const RooCmdArg& arg7 = RooCmdArg(), const RooCmdArg& arg8 = RooCmdArg(), const RooCmdArg& arg9 = RooCmdArg(), const RooCmdArg& arg10 = RooCmdArg()) const; Plot (project) PDF on specified frame. If a PDF is plotted in an empty frame, it; will show a unit normalized curve in the frame variable, taken at the present value; of other observables defined for this PDF. If a PDF is plotted in a frame in which a dataset has already been plotted, it will; show a projected curve integrated over all variables that were present in the shown; dataset except for the one on the x-axis. The normalization of the curve will also; be adjusted to the event count of the plotted dataset. An informational message; will be printed for each projection step that is performed. This function takes the following named arguments. Projection control. Slice(const RooArgSet& set) -- Override default projection behaviour by omittting observables listed; in set from the projection, resulting a 'slice' plot. Slicing is usually; only sensible in discrete observables. The slice is position at the 'current'; value of the observable objects. Slice(RooCategory& cat, -- Override default projection behaviour by omittting specified category; const char* label) observable from the projection, resulting in a 'slice' plot. The slice is positioned; at the given label value. Multiple Slice() commands can be given to specify slices; in multiple observables. Project(const RooArgSet& set) -- Overri",MatchSource.WIKI,root/html602/RooAbsReal.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsReal.html
https://root.cern/root/html602/RooAbsReal.html:50820,Deployability,integrat,integration,50820," dataset. An informational message; will be printed for each projection step that is performed. This function takes the following named arguments. Projection control. Slice(const RooArgSet& set) -- Override default projection behaviour by omittting observables listed; in set from the projection, resulting a 'slice' plot. Slicing is usually; only sensible in discrete observables. The slice is position at the 'current'; value of the observable objects. Slice(RooCategory& cat, -- Override default projection behaviour by omittting specified category; const char* label) observable from the projection, resulting in a 'slice' plot. The slice is positioned; at the given label value. Multiple Slice() commands can be given to specify slices; in multiple observables. Project(const RooArgSet& set) -- Override default projection behaviour by projecting over observables; given in set and complete ignoring the default projection behavior. Advanced use only. ProjWData(const RooAbsData& d) -- Override default projection _technique_ (integration). For observables present in given dataset; projection of PDF is achieved by constructing an average over all observable values in given set.; Consult RooFit plotting tutorial for further explanation of meaning & use of this technique. ProjWData(const RooArgSet& s, -- As above but only consider subset 's' of observables in dataset 'd' for projection through data averaging; const RooAbsData& d). ProjectionRange(const char* rn) -- Override default range of projection integrals to a different range speficied by given range name.; This technique allows you to project a finite width slice in a real-valued observable. NumCPU(Int_t ncpu) -- Number of CPUs to use simultaneously to calculate data-weighted projections (only in combination with ProjWData). Misc content control. PrintEvalErrors(Int_t numErr) -- Control number of p.d.f evaluation errors printed per curve. A negative; value suppress output completely, a zero value will only print the error ",MatchSource.WIKI,root/html602/RooAbsReal.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsReal.html
https://root.cern/root/html602/RooAbsReal.html:56252,Deployability,integrat,integration,56252,"alues, as drawn from a multi-variate Gaussian p.d.f. that is constructed; from the fit results covariance matrix. The error(x) is determined by calculating a central interval that capture N% of the variations; for each valye of x, where N% is controlled by Z (i.e. Z=1 gives N=68%). The number of sampling curves is chosen to be such; that at least 30 curves are expected to be outside the N% interval, and is minimally 100 (e.g. Z=1->Ncurve=100, Z=2->Ncurve=659, Z=3->Ncurve=11111); Intervals from the sampling method can be asymmetric, and may perform better in the presence of strong correlations, but may take (much); longer to calculate. RooPlot* plotOn(RooPlot* frame, RooLinkedList& cmdList) const; Internal back-end function of plotOn() with named arguments. RooPlot* plotOn(RooPlot* frame, RooAbsReal::PlotOpt o) const; Plotting engine function for internal use. Plot ourselves on given frame. If frame contains a histogram, all dimensions of the plotted; function that occur in the previously plotted dataset are projected via partial integration,; otherwise no projections are performed. Optionally, certain projections can be performed; by summing over the values present in a provided dataset ('projData'), to correctly; project out data dependents that are not properly described by the PDF (e.g. per-event errors). The functions value can be multiplied with an optional scale factor. The interpretation; of the scale factor is unique for generic real functions, for PDFs there are various interpretations; possible, which can be selection with 'stype' (see RooAbsPdf::plotOn() for details). The default projection behaviour can be overriden by supplying an optional set of dependents; to project. For most cases, plotSliceOn() and plotProjOn() provide a more intuitive interface; to modify the default projection behavour. RooPlot* plotSliceOn(RooPlot* frame, const RooArgSet& sliceSet, Option_t* drawOptions = ""L"", Double_t scaleFactor = 1., RooAbsReal::ScaleType stype = Relative, co",MatchSource.WIKI,root/html602/RooAbsReal.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsReal.html
https://root.cern/root/html602/RooAbsReal.html:57811,Deployability,integrat,integration,57811,"ich can be selection with 'stype' (see RooAbsPdf::plotOn() for details). The default projection behaviour can be overriden by supplying an optional set of dependents; to project. For most cases, plotSliceOn() and plotProjOn() provide a more intuitive interface; to modify the default projection behavour. RooPlot* plotSliceOn(RooPlot* frame, const RooArgSet& sliceSet, Option_t* drawOptions = ""L"", Double_t scaleFactor = 1., RooAbsReal::ScaleType stype = Relative, const RooAbsData* projData = 0) const; OBSOLETE -- RETAINED FOR BACKWARD COMPATIBILITY. Use the plotOn(frame,Slice(...)) instead. RooPlot* plotAsymOn(RooPlot* frame, const RooAbsCategoryLValue& asymCat, RooAbsReal::PlotOpt o) const; Plotting engine for asymmetries. Implements the functionality if plotOn(frame,Asymmetry(...))). Plot asymmetry of ourselves, defined as. asym = f(asymCat=-1) - f(asymCat=+1) / ( f(asymCat=-1) + f(asymCat=+1) ). on frame. If frame contains a histogram, all dimensions of the plotted; asymmetry function that occur in the previously plotted dataset are projected via partial integration.; Otherwise no projections are performed,. The asymmetry function can be multiplied with an optional scale factor. The default projection; behaviour can be overriden by supplying an optional set of dependents to project. Double_t getPropagatedError(const RooFitResult& fr); Calculate error on self by propagated errors on parameters with correlations as given by fit result; The linearly propagated error is calculated as follows; T; error(x) = F_a(x) * Corr(a,a') F_a'(x). where F_a(x) = [ f(x,a+da) - f(x,a-da) ] / 2, with f(x) this function and 'da' taken from the fit result; Corr(a,a') = the correlation matrix from the fit result. RooPlot* plotOnWithErrorBand(RooPlot* frame, const RooFitResult& fr, Double_t Z, const RooArgSet* params, const RooLinkedList& argList, Bool_t method1) const; Plot function or p.d.f. on frame with support for visualization of the uncertainty encoded in the given fit result fr.; If",MatchSource.WIKI,root/html602/RooAbsReal.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsReal.html
https://root.cern/root/html602/RooAbsReal.html:64772,Deployability,integrat,integration,64772,"o analDeps. Bool_t matchArgs(const RooArgSet& allDeps, RooArgSet& numDeps, const RooArgProxy& a, const RooArgProxy& b, const RooArgProxy& c, const RooArgProxy& d) const; Utility function for use in getAnalyticalIntegral(). If the; contents of proxies a,b,c,d occur in set 'allDeps' then the arguments; held in a,b,c,d are copied from allDeps to analDeps. Bool_t matchArgs(const RooArgSet& allDeps, RooArgSet& numDeps, const RooArgSet& set) const; Utility function for use in getAnalyticalIntegral(). If the; contents of 'refset' occur in set 'allDeps' then the arguments; held in 'refset' are copied from allDeps to analDeps. Bool_t matchArgsByName(const RooArgSet& allArgs, RooArgSet& matchedArgs, const TList& nameList) const; Check if allArgs contains matching elements for each name in nameList. If it does,; add the corresponding args from allArgs to matchedArgs and return kTRUE. Otherwise; return kFALSE and do not change matchedArgs. RooNumIntConfig* defaultIntegratorConfig(); Returns the default numeric integration configuration for all RooAbsReals. RooNumIntConfig* specialIntegratorConfig() const; Returns the specialized integrator configuration for _this_ RooAbsReal.; If this object has no specialized configuration, a null pointer is returned. RooNumIntConfig* specialIntegratorConfig(Bool_t createOnTheFly); Returns the specialized integrator configuration for _this_ RooAbsReal.; If this object has no specialized configuration, a null pointer is returned,; unless createOnTheFly is kTRUE in which case a clone of the default integrator; configuration is created, installed as specialized configuration, and returned. const RooNumIntConfig* getIntegratorConfig() const; Return the numeric integration configuration used for this object. If; a specialized configuration was associated with this object, that configuration; is returned, otherwise the default configuration for all RooAbsReals is returned. RooNumIntConfig* getIntegratorConfig(); Return the numeric integration configu",MatchSource.WIKI,root/html602/RooAbsReal.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsReal.html
https://root.cern/root/html602/RooAbsReal.html:64784,Deployability,configurat,configuration,64784,"o analDeps. Bool_t matchArgs(const RooArgSet& allDeps, RooArgSet& numDeps, const RooArgProxy& a, const RooArgProxy& b, const RooArgProxy& c, const RooArgProxy& d) const; Utility function for use in getAnalyticalIntegral(). If the; contents of proxies a,b,c,d occur in set 'allDeps' then the arguments; held in a,b,c,d are copied from allDeps to analDeps. Bool_t matchArgs(const RooArgSet& allDeps, RooArgSet& numDeps, const RooArgSet& set) const; Utility function for use in getAnalyticalIntegral(). If the; contents of 'refset' occur in set 'allDeps' then the arguments; held in 'refset' are copied from allDeps to analDeps. Bool_t matchArgsByName(const RooArgSet& allArgs, RooArgSet& matchedArgs, const TList& nameList) const; Check if allArgs contains matching elements for each name in nameList. If it does,; add the corresponding args from allArgs to matchedArgs and return kTRUE. Otherwise; return kFALSE and do not change matchedArgs. RooNumIntConfig* defaultIntegratorConfig(); Returns the default numeric integration configuration for all RooAbsReals. RooNumIntConfig* specialIntegratorConfig() const; Returns the specialized integrator configuration for _this_ RooAbsReal.; If this object has no specialized configuration, a null pointer is returned. RooNumIntConfig* specialIntegratorConfig(Bool_t createOnTheFly); Returns the specialized integrator configuration for _this_ RooAbsReal.; If this object has no specialized configuration, a null pointer is returned,; unless createOnTheFly is kTRUE in which case a clone of the default integrator; configuration is created, installed as specialized configuration, and returned. const RooNumIntConfig* getIntegratorConfig() const; Return the numeric integration configuration used for this object. If; a specialized configuration was associated with this object, that configuration; is returned, otherwise the default configuration for all RooAbsReals is returned. RooNumIntConfig* getIntegratorConfig(); Return the numeric integration configu",MatchSource.WIKI,root/html602/RooAbsReal.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsReal.html
https://root.cern/root/html602/RooAbsReal.html:64893,Deployability,integrat,integrator,64893,"nst RooArgProxy& c, const RooArgProxy& d) const; Utility function for use in getAnalyticalIntegral(). If the; contents of proxies a,b,c,d occur in set 'allDeps' then the arguments; held in a,b,c,d are copied from allDeps to analDeps. Bool_t matchArgs(const RooArgSet& allDeps, RooArgSet& numDeps, const RooArgSet& set) const; Utility function for use in getAnalyticalIntegral(). If the; contents of 'refset' occur in set 'allDeps' then the arguments; held in 'refset' are copied from allDeps to analDeps. Bool_t matchArgsByName(const RooArgSet& allArgs, RooArgSet& matchedArgs, const TList& nameList) const; Check if allArgs contains matching elements for each name in nameList. If it does,; add the corresponding args from allArgs to matchedArgs and return kTRUE. Otherwise; return kFALSE and do not change matchedArgs. RooNumIntConfig* defaultIntegratorConfig(); Returns the default numeric integration configuration for all RooAbsReals. RooNumIntConfig* specialIntegratorConfig() const; Returns the specialized integrator configuration for _this_ RooAbsReal.; If this object has no specialized configuration, a null pointer is returned. RooNumIntConfig* specialIntegratorConfig(Bool_t createOnTheFly); Returns the specialized integrator configuration for _this_ RooAbsReal.; If this object has no specialized configuration, a null pointer is returned,; unless createOnTheFly is kTRUE in which case a clone of the default integrator; configuration is created, installed as specialized configuration, and returned. const RooNumIntConfig* getIntegratorConfig() const; Return the numeric integration configuration used for this object. If; a specialized configuration was associated with this object, that configuration; is returned, otherwise the default configuration for all RooAbsReals is returned. RooNumIntConfig* getIntegratorConfig(); Return the numeric integration configuration used for this object. If; a specialized configuration was associated with this object, that configuration; is ret",MatchSource.WIKI,root/html602/RooAbsReal.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsReal.html
https://root.cern/root/html602/RooAbsReal.html:64904,Deployability,configurat,configuration,64904,"nst RooArgProxy& c, const RooArgProxy& d) const; Utility function for use in getAnalyticalIntegral(). If the; contents of proxies a,b,c,d occur in set 'allDeps' then the arguments; held in a,b,c,d are copied from allDeps to analDeps. Bool_t matchArgs(const RooArgSet& allDeps, RooArgSet& numDeps, const RooArgSet& set) const; Utility function for use in getAnalyticalIntegral(). If the; contents of 'refset' occur in set 'allDeps' then the arguments; held in 'refset' are copied from allDeps to analDeps. Bool_t matchArgsByName(const RooArgSet& allArgs, RooArgSet& matchedArgs, const TList& nameList) const; Check if allArgs contains matching elements for each name in nameList. If it does,; add the corresponding args from allArgs to matchedArgs and return kTRUE. Otherwise; return kFALSE and do not change matchedArgs. RooNumIntConfig* defaultIntegratorConfig(); Returns the default numeric integration configuration for all RooAbsReals. RooNumIntConfig* specialIntegratorConfig() const; Returns the specialized integrator configuration for _this_ RooAbsReal.; If this object has no specialized configuration, a null pointer is returned. RooNumIntConfig* specialIntegratorConfig(Bool_t createOnTheFly); Returns the specialized integrator configuration for _this_ RooAbsReal.; If this object has no specialized configuration, a null pointer is returned,; unless createOnTheFly is kTRUE in which case a clone of the default integrator; configuration is created, installed as specialized configuration, and returned. const RooNumIntConfig* getIntegratorConfig() const; Return the numeric integration configuration used for this object. If; a specialized configuration was associated with this object, that configuration; is returned, otherwise the default configuration for all RooAbsReals is returned. RooNumIntConfig* getIntegratorConfig(); Return the numeric integration configuration used for this object. If; a specialized configuration was associated with this object, that configuration; is ret",MatchSource.WIKI,root/html602/RooAbsReal.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsReal.html
https://root.cern/root/html602/RooAbsReal.html:64976,Deployability,configurat,configuration,64976,". If the; contents of proxies a,b,c,d occur in set 'allDeps' then the arguments; held in a,b,c,d are copied from allDeps to analDeps. Bool_t matchArgs(const RooArgSet& allDeps, RooArgSet& numDeps, const RooArgSet& set) const; Utility function for use in getAnalyticalIntegral(). If the; contents of 'refset' occur in set 'allDeps' then the arguments; held in 'refset' are copied from allDeps to analDeps. Bool_t matchArgsByName(const RooArgSet& allArgs, RooArgSet& matchedArgs, const TList& nameList) const; Check if allArgs contains matching elements for each name in nameList. If it does,; add the corresponding args from allArgs to matchedArgs and return kTRUE. Otherwise; return kFALSE and do not change matchedArgs. RooNumIntConfig* defaultIntegratorConfig(); Returns the default numeric integration configuration for all RooAbsReals. RooNumIntConfig* specialIntegratorConfig() const; Returns the specialized integrator configuration for _this_ RooAbsReal.; If this object has no specialized configuration, a null pointer is returned. RooNumIntConfig* specialIntegratorConfig(Bool_t createOnTheFly); Returns the specialized integrator configuration for _this_ RooAbsReal.; If this object has no specialized configuration, a null pointer is returned,; unless createOnTheFly is kTRUE in which case a clone of the default integrator; configuration is created, installed as specialized configuration, and returned. const RooNumIntConfig* getIntegratorConfig() const; Return the numeric integration configuration used for this object. If; a specialized configuration was associated with this object, that configuration; is returned, otherwise the default configuration for all RooAbsReals is returned. RooNumIntConfig* getIntegratorConfig(); Return the numeric integration configuration used for this object. If; a specialized configuration was associated with this object, that configuration; is returned, otherwise the default configuration for all RooAbsReals is returned. void setIntegratorConfig",MatchSource.WIKI,root/html602/RooAbsReal.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsReal.html
https://root.cern/root/html602/RooAbsReal.html:65108,Deployability,integrat,integrator,65108," from allDeps to analDeps. Bool_t matchArgs(const RooArgSet& allDeps, RooArgSet& numDeps, const RooArgSet& set) const; Utility function for use in getAnalyticalIntegral(). If the; contents of 'refset' occur in set 'allDeps' then the arguments; held in 'refset' are copied from allDeps to analDeps. Bool_t matchArgsByName(const RooArgSet& allArgs, RooArgSet& matchedArgs, const TList& nameList) const; Check if allArgs contains matching elements for each name in nameList. If it does,; add the corresponding args from allArgs to matchedArgs and return kTRUE. Otherwise; return kFALSE and do not change matchedArgs. RooNumIntConfig* defaultIntegratorConfig(); Returns the default numeric integration configuration for all RooAbsReals. RooNumIntConfig* specialIntegratorConfig() const; Returns the specialized integrator configuration for _this_ RooAbsReal.; If this object has no specialized configuration, a null pointer is returned. RooNumIntConfig* specialIntegratorConfig(Bool_t createOnTheFly); Returns the specialized integrator configuration for _this_ RooAbsReal.; If this object has no specialized configuration, a null pointer is returned,; unless createOnTheFly is kTRUE in which case a clone of the default integrator; configuration is created, installed as specialized configuration, and returned. const RooNumIntConfig* getIntegratorConfig() const; Return the numeric integration configuration used for this object. If; a specialized configuration was associated with this object, that configuration; is returned, otherwise the default configuration for all RooAbsReals is returned. RooNumIntConfig* getIntegratorConfig(); Return the numeric integration configuration used for this object. If; a specialized configuration was associated with this object, that configuration; is returned, otherwise the default configuration for all RooAbsReals is returned. void setIntegratorConfig(const RooNumIntConfig& config); Set the given integrator configuration as default numeric integration; conf",MatchSource.WIKI,root/html602/RooAbsReal.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsReal.html
https://root.cern/root/html602/RooAbsReal.html:65119,Deployability,configurat,configuration,65119," from allDeps to analDeps. Bool_t matchArgs(const RooArgSet& allDeps, RooArgSet& numDeps, const RooArgSet& set) const; Utility function for use in getAnalyticalIntegral(). If the; contents of 'refset' occur in set 'allDeps' then the arguments; held in 'refset' are copied from allDeps to analDeps. Bool_t matchArgsByName(const RooArgSet& allArgs, RooArgSet& matchedArgs, const TList& nameList) const; Check if allArgs contains matching elements for each name in nameList. If it does,; add the corresponding args from allArgs to matchedArgs and return kTRUE. Otherwise; return kFALSE and do not change matchedArgs. RooNumIntConfig* defaultIntegratorConfig(); Returns the default numeric integration configuration for all RooAbsReals. RooNumIntConfig* specialIntegratorConfig() const; Returns the specialized integrator configuration for _this_ RooAbsReal.; If this object has no specialized configuration, a null pointer is returned. RooNumIntConfig* specialIntegratorConfig(Bool_t createOnTheFly); Returns the specialized integrator configuration for _this_ RooAbsReal.; If this object has no specialized configuration, a null pointer is returned,; unless createOnTheFly is kTRUE in which case a clone of the default integrator; configuration is created, installed as specialized configuration, and returned. const RooNumIntConfig* getIntegratorConfig() const; Return the numeric integration configuration used for this object. If; a specialized configuration was associated with this object, that configuration; is returned, otherwise the default configuration for all RooAbsReals is returned. RooNumIntConfig* getIntegratorConfig(); Return the numeric integration configuration used for this object. If; a specialized configuration was associated with this object, that configuration; is returned, otherwise the default configuration for all RooAbsReals is returned. void setIntegratorConfig(const RooNumIntConfig& config); Set the given integrator configuration as default numeric integration; conf",MatchSource.WIKI,root/html602/RooAbsReal.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsReal.html
https://root.cern/root/html602/RooAbsReal.html:65191,Deployability,configurat,configuration,65191," of 'refset' occur in set 'allDeps' then the arguments; held in 'refset' are copied from allDeps to analDeps. Bool_t matchArgsByName(const RooArgSet& allArgs, RooArgSet& matchedArgs, const TList& nameList) const; Check if allArgs contains matching elements for each name in nameList. If it does,; add the corresponding args from allArgs to matchedArgs and return kTRUE. Otherwise; return kFALSE and do not change matchedArgs. RooNumIntConfig* defaultIntegratorConfig(); Returns the default numeric integration configuration for all RooAbsReals. RooNumIntConfig* specialIntegratorConfig() const; Returns the specialized integrator configuration for _this_ RooAbsReal.; If this object has no specialized configuration, a null pointer is returned. RooNumIntConfig* specialIntegratorConfig(Bool_t createOnTheFly); Returns the specialized integrator configuration for _this_ RooAbsReal.; If this object has no specialized configuration, a null pointer is returned,; unless createOnTheFly is kTRUE in which case a clone of the default integrator; configuration is created, installed as specialized configuration, and returned. const RooNumIntConfig* getIntegratorConfig() const; Return the numeric integration configuration used for this object. If; a specialized configuration was associated with this object, that configuration; is returned, otherwise the default configuration for all RooAbsReals is returned. RooNumIntConfig* getIntegratorConfig(); Return the numeric integration configuration used for this object. If; a specialized configuration was associated with this object, that configuration; is returned, otherwise the default configuration for all RooAbsReals is returned. void setIntegratorConfig(const RooNumIntConfig& config); Set the given integrator configuration as default numeric integration; configuration for this object. void setIntegratorConfig(); Remove the specialized numeric integration configuration associated; with this object. void selectNormalization(const RooArgSet* depS",MatchSource.WIKI,root/html602/RooAbsReal.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsReal.html
https://root.cern/root/html602/RooAbsReal.html:65303,Deployability,integrat,integrator,65303," of 'refset' occur in set 'allDeps' then the arguments; held in 'refset' are copied from allDeps to analDeps. Bool_t matchArgsByName(const RooArgSet& allArgs, RooArgSet& matchedArgs, const TList& nameList) const; Check if allArgs contains matching elements for each name in nameList. If it does,; add the corresponding args from allArgs to matchedArgs and return kTRUE. Otherwise; return kFALSE and do not change matchedArgs. RooNumIntConfig* defaultIntegratorConfig(); Returns the default numeric integration configuration for all RooAbsReals. RooNumIntConfig* specialIntegratorConfig() const; Returns the specialized integrator configuration for _this_ RooAbsReal.; If this object has no specialized configuration, a null pointer is returned. RooNumIntConfig* specialIntegratorConfig(Bool_t createOnTheFly); Returns the specialized integrator configuration for _this_ RooAbsReal.; If this object has no specialized configuration, a null pointer is returned,; unless createOnTheFly is kTRUE in which case a clone of the default integrator; configuration is created, installed as specialized configuration, and returned. const RooNumIntConfig* getIntegratorConfig() const; Return the numeric integration configuration used for this object. If; a specialized configuration was associated with this object, that configuration; is returned, otherwise the default configuration for all RooAbsReals is returned. RooNumIntConfig* getIntegratorConfig(); Return the numeric integration configuration used for this object. If; a specialized configuration was associated with this object, that configuration; is returned, otherwise the default configuration for all RooAbsReals is returned. void setIntegratorConfig(const RooNumIntConfig& config); Set the given integrator configuration as default numeric integration; configuration for this object. void setIntegratorConfig(); Remove the specialized numeric integration configuration associated; with this object. void selectNormalization(const RooArgSet* depS",MatchSource.WIKI,root/html602/RooAbsReal.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsReal.html
https://root.cern/root/html602/RooAbsReal.html:65315,Deployability,configurat,configuration,65315," of 'refset' occur in set 'allDeps' then the arguments; held in 'refset' are copied from allDeps to analDeps. Bool_t matchArgsByName(const RooArgSet& allArgs, RooArgSet& matchedArgs, const TList& nameList) const; Check if allArgs contains matching elements for each name in nameList. If it does,; add the corresponding args from allArgs to matchedArgs and return kTRUE. Otherwise; return kFALSE and do not change matchedArgs. RooNumIntConfig* defaultIntegratorConfig(); Returns the default numeric integration configuration for all RooAbsReals. RooNumIntConfig* specialIntegratorConfig() const; Returns the specialized integrator configuration for _this_ RooAbsReal.; If this object has no specialized configuration, a null pointer is returned. RooNumIntConfig* specialIntegratorConfig(Bool_t createOnTheFly); Returns the specialized integrator configuration for _this_ RooAbsReal.; If this object has no specialized configuration, a null pointer is returned,; unless createOnTheFly is kTRUE in which case a clone of the default integrator; configuration is created, installed as specialized configuration, and returned. const RooNumIntConfig* getIntegratorConfig() const; Return the numeric integration configuration used for this object. If; a specialized configuration was associated with this object, that configuration; is returned, otherwise the default configuration for all RooAbsReals is returned. RooNumIntConfig* getIntegratorConfig(); Return the numeric integration configuration used for this object. If; a specialized configuration was associated with this object, that configuration; is returned, otherwise the default configuration for all RooAbsReals is returned. void setIntegratorConfig(const RooNumIntConfig& config); Set the given integrator configuration as default numeric integration; configuration for this object. void setIntegratorConfig(); Remove the specialized numeric integration configuration associated; with this object. void selectNormalization(const RooArgSet* depS",MatchSource.WIKI,root/html602/RooAbsReal.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsReal.html
https://root.cern/root/html602/RooAbsReal.html:65341,Deployability,install,installed,65341," of 'refset' occur in set 'allDeps' then the arguments; held in 'refset' are copied from allDeps to analDeps. Bool_t matchArgsByName(const RooArgSet& allArgs, RooArgSet& matchedArgs, const TList& nameList) const; Check if allArgs contains matching elements for each name in nameList. If it does,; add the corresponding args from allArgs to matchedArgs and return kTRUE. Otherwise; return kFALSE and do not change matchedArgs. RooNumIntConfig* defaultIntegratorConfig(); Returns the default numeric integration configuration for all RooAbsReals. RooNumIntConfig* specialIntegratorConfig() const; Returns the specialized integrator configuration for _this_ RooAbsReal.; If this object has no specialized configuration, a null pointer is returned. RooNumIntConfig* specialIntegratorConfig(Bool_t createOnTheFly); Returns the specialized integrator configuration for _this_ RooAbsReal.; If this object has no specialized configuration, a null pointer is returned,; unless createOnTheFly is kTRUE in which case a clone of the default integrator; configuration is created, installed as specialized configuration, and returned. const RooNumIntConfig* getIntegratorConfig() const; Return the numeric integration configuration used for this object. If; a specialized configuration was associated with this object, that configuration; is returned, otherwise the default configuration for all RooAbsReals is returned. RooNumIntConfig* getIntegratorConfig(); Return the numeric integration configuration used for this object. If; a specialized configuration was associated with this object, that configuration; is returned, otherwise the default configuration for all RooAbsReals is returned. void setIntegratorConfig(const RooNumIntConfig& config); Set the given integrator configuration as default numeric integration; configuration for this object. void setIntegratorConfig(); Remove the specialized numeric integration configuration associated; with this object. void selectNormalization(const RooArgSet* depS",MatchSource.WIKI,root/html602/RooAbsReal.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsReal.html
https://root.cern/root/html602/RooAbsReal.html:65366,Deployability,configurat,configuration,65366," of 'refset' occur in set 'allDeps' then the arguments; held in 'refset' are copied from allDeps to analDeps. Bool_t matchArgsByName(const RooArgSet& allArgs, RooArgSet& matchedArgs, const TList& nameList) const; Check if allArgs contains matching elements for each name in nameList. If it does,; add the corresponding args from allArgs to matchedArgs and return kTRUE. Otherwise; return kFALSE and do not change matchedArgs. RooNumIntConfig* defaultIntegratorConfig(); Returns the default numeric integration configuration for all RooAbsReals. RooNumIntConfig* specialIntegratorConfig() const; Returns the specialized integrator configuration for _this_ RooAbsReal.; If this object has no specialized configuration, a null pointer is returned. RooNumIntConfig* specialIntegratorConfig(Bool_t createOnTheFly); Returns the specialized integrator configuration for _this_ RooAbsReal.; If this object has no specialized configuration, a null pointer is returned,; unless createOnTheFly is kTRUE in which case a clone of the default integrator; configuration is created, installed as specialized configuration, and returned. const RooNumIntConfig* getIntegratorConfig() const; Return the numeric integration configuration used for this object. If; a specialized configuration was associated with this object, that configuration; is returned, otherwise the default configuration for all RooAbsReals is returned. RooNumIntConfig* getIntegratorConfig(); Return the numeric integration configuration used for this object. If; a specialized configuration was associated with this object, that configuration; is returned, otherwise the default configuration for all RooAbsReals is returned. void setIntegratorConfig(const RooNumIntConfig& config); Set the given integrator configuration as default numeric integration; configuration for this object. void setIntegratorConfig(); Remove the specialized numeric integration configuration associated; with this object. void selectNormalization(const RooArgSet* depS",MatchSource.WIKI,root/html602/RooAbsReal.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsReal.html
https://root.cern/root/html602/RooAbsReal.html:65466,Deployability,integrat,integration,65466,"gs, const TList& nameList) const; Check if allArgs contains matching elements for each name in nameList. If it does,; add the corresponding args from allArgs to matchedArgs and return kTRUE. Otherwise; return kFALSE and do not change matchedArgs. RooNumIntConfig* defaultIntegratorConfig(); Returns the default numeric integration configuration for all RooAbsReals. RooNumIntConfig* specialIntegratorConfig() const; Returns the specialized integrator configuration for _this_ RooAbsReal.; If this object has no specialized configuration, a null pointer is returned. RooNumIntConfig* specialIntegratorConfig(Bool_t createOnTheFly); Returns the specialized integrator configuration for _this_ RooAbsReal.; If this object has no specialized configuration, a null pointer is returned,; unless createOnTheFly is kTRUE in which case a clone of the default integrator; configuration is created, installed as specialized configuration, and returned. const RooNumIntConfig* getIntegratorConfig() const; Return the numeric integration configuration used for this object. If; a specialized configuration was associated with this object, that configuration; is returned, otherwise the default configuration for all RooAbsReals is returned. RooNumIntConfig* getIntegratorConfig(); Return the numeric integration configuration used for this object. If; a specialized configuration was associated with this object, that configuration; is returned, otherwise the default configuration for all RooAbsReals is returned. void setIntegratorConfig(const RooNumIntConfig& config); Set the given integrator configuration as default numeric integration; configuration for this object. void setIntegratorConfig(); Remove the specialized numeric integration configuration associated; with this object. void selectNormalization(const RooArgSet* depSet = 0, Bool_t force = kFALSE); Interface function to force use of a given set of observables; to interpret function value. Needed for functions or p.d.f.s; whose shape depends on",MatchSource.WIKI,root/html602/RooAbsReal.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsReal.html
https://root.cern/root/html602/RooAbsReal.html:65478,Deployability,configurat,configuration,65478,"gs, const TList& nameList) const; Check if allArgs contains matching elements for each name in nameList. If it does,; add the corresponding args from allArgs to matchedArgs and return kTRUE. Otherwise; return kFALSE and do not change matchedArgs. RooNumIntConfig* defaultIntegratorConfig(); Returns the default numeric integration configuration for all RooAbsReals. RooNumIntConfig* specialIntegratorConfig() const; Returns the specialized integrator configuration for _this_ RooAbsReal.; If this object has no specialized configuration, a null pointer is returned. RooNumIntConfig* specialIntegratorConfig(Bool_t createOnTheFly); Returns the specialized integrator configuration for _this_ RooAbsReal.; If this object has no specialized configuration, a null pointer is returned,; unless createOnTheFly is kTRUE in which case a clone of the default integrator; configuration is created, installed as specialized configuration, and returned. const RooNumIntConfig* getIntegratorConfig() const; Return the numeric integration configuration used for this object. If; a specialized configuration was associated with this object, that configuration; is returned, otherwise the default configuration for all RooAbsReals is returned. RooNumIntConfig* getIntegratorConfig(); Return the numeric integration configuration used for this object. If; a specialized configuration was associated with this object, that configuration; is returned, otherwise the default configuration for all RooAbsReals is returned. void setIntegratorConfig(const RooNumIntConfig& config); Set the given integrator configuration as default numeric integration; configuration for this object. void setIntegratorConfig(); Remove the specialized numeric integration configuration associated; with this object. void selectNormalization(const RooArgSet* depSet = 0, Bool_t force = kFALSE); Interface function to force use of a given set of observables; to interpret function value. Needed for functions or p.d.f.s; whose shape depends on",MatchSource.WIKI,root/html602/RooAbsReal.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsReal.html
https://root.cern/root/html602/RooAbsReal.html:65532,Deployability,configurat,configuration,65532,"s from allArgs to matchedArgs and return kTRUE. Otherwise; return kFALSE and do not change matchedArgs. RooNumIntConfig* defaultIntegratorConfig(); Returns the default numeric integration configuration for all RooAbsReals. RooNumIntConfig* specialIntegratorConfig() const; Returns the specialized integrator configuration for _this_ RooAbsReal.; If this object has no specialized configuration, a null pointer is returned. RooNumIntConfig* specialIntegratorConfig(Bool_t createOnTheFly); Returns the specialized integrator configuration for _this_ RooAbsReal.; If this object has no specialized configuration, a null pointer is returned,; unless createOnTheFly is kTRUE in which case a clone of the default integrator; configuration is created, installed as specialized configuration, and returned. const RooNumIntConfig* getIntegratorConfig() const; Return the numeric integration configuration used for this object. If; a specialized configuration was associated with this object, that configuration; is returned, otherwise the default configuration for all RooAbsReals is returned. RooNumIntConfig* getIntegratorConfig(); Return the numeric integration configuration used for this object. If; a specialized configuration was associated with this object, that configuration; is returned, otherwise the default configuration for all RooAbsReals is returned. void setIntegratorConfig(const RooNumIntConfig& config); Set the given integrator configuration as default numeric integration; configuration for this object. void setIntegratorConfig(); Remove the specialized numeric integration configuration associated; with this object. void selectNormalization(const RooArgSet* depSet = 0, Bool_t force = kFALSE); Interface function to force use of a given set of observables; to interpret function value. Needed for functions or p.d.f.s; whose shape depends on the choice of normalization such as; RooAddPdf. void selectNormalizationRange(const char* rangeName = 0, Bool_t force = kFALSE); Interface fun",MatchSource.WIKI,root/html602/RooAbsReal.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsReal.html
https://root.cern/root/html602/RooAbsReal.html:65584,Deployability,configurat,configuration,65584,"s from allArgs to matchedArgs and return kTRUE. Otherwise; return kFALSE and do not change matchedArgs. RooNumIntConfig* defaultIntegratorConfig(); Returns the default numeric integration configuration for all RooAbsReals. RooNumIntConfig* specialIntegratorConfig() const; Returns the specialized integrator configuration for _this_ RooAbsReal.; If this object has no specialized configuration, a null pointer is returned. RooNumIntConfig* specialIntegratorConfig(Bool_t createOnTheFly); Returns the specialized integrator configuration for _this_ RooAbsReal.; If this object has no specialized configuration, a null pointer is returned,; unless createOnTheFly is kTRUE in which case a clone of the default integrator; configuration is created, installed as specialized configuration, and returned. const RooNumIntConfig* getIntegratorConfig() const; Return the numeric integration configuration used for this object. If; a specialized configuration was associated with this object, that configuration; is returned, otherwise the default configuration for all RooAbsReals is returned. RooNumIntConfig* getIntegratorConfig(); Return the numeric integration configuration used for this object. If; a specialized configuration was associated with this object, that configuration; is returned, otherwise the default configuration for all RooAbsReals is returned. void setIntegratorConfig(const RooNumIntConfig& config); Set the given integrator configuration as default numeric integration; configuration for this object. void setIntegratorConfig(); Remove the specialized numeric integration configuration associated; with this object. void selectNormalization(const RooArgSet* depSet = 0, Bool_t force = kFALSE); Interface function to force use of a given set of observables; to interpret function value. Needed for functions or p.d.f.s; whose shape depends on the choice of normalization such as; RooAddPdf. void selectNormalizationRange(const char* rangeName = 0, Bool_t force = kFALSE); Interface fun",MatchSource.WIKI,root/html602/RooAbsReal.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsReal.html
https://root.cern/root/html602/RooAbsReal.html:65634,Deployability,configurat,configuration,65634,"s from allArgs to matchedArgs and return kTRUE. Otherwise; return kFALSE and do not change matchedArgs. RooNumIntConfig* defaultIntegratorConfig(); Returns the default numeric integration configuration for all RooAbsReals. RooNumIntConfig* specialIntegratorConfig() const; Returns the specialized integrator configuration for _this_ RooAbsReal.; If this object has no specialized configuration, a null pointer is returned. RooNumIntConfig* specialIntegratorConfig(Bool_t createOnTheFly); Returns the specialized integrator configuration for _this_ RooAbsReal.; If this object has no specialized configuration, a null pointer is returned,; unless createOnTheFly is kTRUE in which case a clone of the default integrator; configuration is created, installed as specialized configuration, and returned. const RooNumIntConfig* getIntegratorConfig() const; Return the numeric integration configuration used for this object. If; a specialized configuration was associated with this object, that configuration; is returned, otherwise the default configuration for all RooAbsReals is returned. RooNumIntConfig* getIntegratorConfig(); Return the numeric integration configuration used for this object. If; a specialized configuration was associated with this object, that configuration; is returned, otherwise the default configuration for all RooAbsReals is returned. void setIntegratorConfig(const RooNumIntConfig& config); Set the given integrator configuration as default numeric integration; configuration for this object. void setIntegratorConfig(); Remove the specialized numeric integration configuration associated; with this object. void selectNormalization(const RooArgSet* depSet = 0, Bool_t force = kFALSE); Interface function to force use of a given set of observables; to interpret function value. Needed for functions or p.d.f.s; whose shape depends on the choice of normalization such as; RooAddPdf. void selectNormalizationRange(const char* rangeName = 0, Bool_t force = kFALSE); Interface fun",MatchSource.WIKI,root/html602/RooAbsReal.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsReal.html
https://root.cern/root/html602/RooAbsReal.html:65740,Deployability,integrat,integration,65740,"rConfig(); Returns the default numeric integration configuration for all RooAbsReals. RooNumIntConfig* specialIntegratorConfig() const; Returns the specialized integrator configuration for _this_ RooAbsReal.; If this object has no specialized configuration, a null pointer is returned. RooNumIntConfig* specialIntegratorConfig(Bool_t createOnTheFly); Returns the specialized integrator configuration for _this_ RooAbsReal.; If this object has no specialized configuration, a null pointer is returned,; unless createOnTheFly is kTRUE in which case a clone of the default integrator; configuration is created, installed as specialized configuration, and returned. const RooNumIntConfig* getIntegratorConfig() const; Return the numeric integration configuration used for this object. If; a specialized configuration was associated with this object, that configuration; is returned, otherwise the default configuration for all RooAbsReals is returned. RooNumIntConfig* getIntegratorConfig(); Return the numeric integration configuration used for this object. If; a specialized configuration was associated with this object, that configuration; is returned, otherwise the default configuration for all RooAbsReals is returned. void setIntegratorConfig(const RooNumIntConfig& config); Set the given integrator configuration as default numeric integration; configuration for this object. void setIntegratorConfig(); Remove the specialized numeric integration configuration associated; with this object. void selectNormalization(const RooArgSet* depSet = 0, Bool_t force = kFALSE); Interface function to force use of a given set of observables; to interpret function value. Needed for functions or p.d.f.s; whose shape depends on the choice of normalization such as; RooAddPdf. void selectNormalizationRange(const char* rangeName = 0, Bool_t force = kFALSE); Interface function to force use of a given normalization range; to interpret function value. Needed for functions or p.d.f.s; whose shape depends on t",MatchSource.WIKI,root/html602/RooAbsReal.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsReal.html
https://root.cern/root/html602/RooAbsReal.html:65752,Deployability,configurat,configuration,65752,"rConfig(); Returns the default numeric integration configuration for all RooAbsReals. RooNumIntConfig* specialIntegratorConfig() const; Returns the specialized integrator configuration for _this_ RooAbsReal.; If this object has no specialized configuration, a null pointer is returned. RooNumIntConfig* specialIntegratorConfig(Bool_t createOnTheFly); Returns the specialized integrator configuration for _this_ RooAbsReal.; If this object has no specialized configuration, a null pointer is returned,; unless createOnTheFly is kTRUE in which case a clone of the default integrator; configuration is created, installed as specialized configuration, and returned. const RooNumIntConfig* getIntegratorConfig() const; Return the numeric integration configuration used for this object. If; a specialized configuration was associated with this object, that configuration; is returned, otherwise the default configuration for all RooAbsReals is returned. RooNumIntConfig* getIntegratorConfig(); Return the numeric integration configuration used for this object. If; a specialized configuration was associated with this object, that configuration; is returned, otherwise the default configuration for all RooAbsReals is returned. void setIntegratorConfig(const RooNumIntConfig& config); Set the given integrator configuration as default numeric integration; configuration for this object. void setIntegratorConfig(); Remove the specialized numeric integration configuration associated; with this object. void selectNormalization(const RooArgSet* depSet = 0, Bool_t force = kFALSE); Interface function to force use of a given set of observables; to interpret function value. Needed for functions or p.d.f.s; whose shape depends on the choice of normalization such as; RooAddPdf. void selectNormalizationRange(const char* rangeName = 0, Bool_t force = kFALSE); Interface function to force use of a given normalization range; to interpret function value. Needed for functions or p.d.f.s; whose shape depends on t",MatchSource.WIKI,root/html602/RooAbsReal.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsReal.html
https://root.cern/root/html602/RooAbsReal.html:65806,Deployability,configurat,configuration,65806,"eturns the specialized integrator configuration for _this_ RooAbsReal.; If this object has no specialized configuration, a null pointer is returned. RooNumIntConfig* specialIntegratorConfig(Bool_t createOnTheFly); Returns the specialized integrator configuration for _this_ RooAbsReal.; If this object has no specialized configuration, a null pointer is returned,; unless createOnTheFly is kTRUE in which case a clone of the default integrator; configuration is created, installed as specialized configuration, and returned. const RooNumIntConfig* getIntegratorConfig() const; Return the numeric integration configuration used for this object. If; a specialized configuration was associated with this object, that configuration; is returned, otherwise the default configuration for all RooAbsReals is returned. RooNumIntConfig* getIntegratorConfig(); Return the numeric integration configuration used for this object. If; a specialized configuration was associated with this object, that configuration; is returned, otherwise the default configuration for all RooAbsReals is returned. void setIntegratorConfig(const RooNumIntConfig& config); Set the given integrator configuration as default numeric integration; configuration for this object. void setIntegratorConfig(); Remove the specialized numeric integration configuration associated; with this object. void selectNormalization(const RooArgSet* depSet = 0, Bool_t force = kFALSE); Interface function to force use of a given set of observables; to interpret function value. Needed for functions or p.d.f.s; whose shape depends on the choice of normalization such as; RooAddPdf. void selectNormalizationRange(const char* rangeName = 0, Bool_t force = kFALSE); Interface function to force use of a given normalization range; to interpret function value. Needed for functions or p.d.f.s; whose shape depends on the choice of normalization such as; RooAddPdf. void setCacheCheck(Bool_t flag); Activate cache validation mode. Int_t getMaxVal(const Roo",MatchSource.WIKI,root/html602/RooAbsReal.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsReal.html
https://root.cern/root/html602/RooAbsReal.html:65858,Deployability,configurat,configuration,65858,"eturns the specialized integrator configuration for _this_ RooAbsReal.; If this object has no specialized configuration, a null pointer is returned. RooNumIntConfig* specialIntegratorConfig(Bool_t createOnTheFly); Returns the specialized integrator configuration for _this_ RooAbsReal.; If this object has no specialized configuration, a null pointer is returned,; unless createOnTheFly is kTRUE in which case a clone of the default integrator; configuration is created, installed as specialized configuration, and returned. const RooNumIntConfig* getIntegratorConfig() const; Return the numeric integration configuration used for this object. If; a specialized configuration was associated with this object, that configuration; is returned, otherwise the default configuration for all RooAbsReals is returned. RooNumIntConfig* getIntegratorConfig(); Return the numeric integration configuration used for this object. If; a specialized configuration was associated with this object, that configuration; is returned, otherwise the default configuration for all RooAbsReals is returned. void setIntegratorConfig(const RooNumIntConfig& config); Set the given integrator configuration as default numeric integration; configuration for this object. void setIntegratorConfig(); Remove the specialized numeric integration configuration associated; with this object. void selectNormalization(const RooArgSet* depSet = 0, Bool_t force = kFALSE); Interface function to force use of a given set of observables; to interpret function value. Needed for functions or p.d.f.s; whose shape depends on the choice of normalization such as; RooAddPdf. void selectNormalizationRange(const char* rangeName = 0, Bool_t force = kFALSE); Interface function to force use of a given normalization range; to interpret function value. Needed for functions or p.d.f.s; whose shape depends on the choice of normalization such as; RooAddPdf. void setCacheCheck(Bool_t flag); Activate cache validation mode. Int_t getMaxVal(const Roo",MatchSource.WIKI,root/html602/RooAbsReal.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsReal.html
https://root.cern/root/html602/RooAbsReal.html:65908,Deployability,configurat,configuration,65908,"eturns the specialized integrator configuration for _this_ RooAbsReal.; If this object has no specialized configuration, a null pointer is returned. RooNumIntConfig* specialIntegratorConfig(Bool_t createOnTheFly); Returns the specialized integrator configuration for _this_ RooAbsReal.; If this object has no specialized configuration, a null pointer is returned,; unless createOnTheFly is kTRUE in which case a clone of the default integrator; configuration is created, installed as specialized configuration, and returned. const RooNumIntConfig* getIntegratorConfig() const; Return the numeric integration configuration used for this object. If; a specialized configuration was associated with this object, that configuration; is returned, otherwise the default configuration for all RooAbsReals is returned. RooNumIntConfig* getIntegratorConfig(); Return the numeric integration configuration used for this object. If; a specialized configuration was associated with this object, that configuration; is returned, otherwise the default configuration for all RooAbsReals is returned. void setIntegratorConfig(const RooNumIntConfig& config); Set the given integrator configuration as default numeric integration; configuration for this object. void setIntegratorConfig(); Remove the specialized numeric integration configuration associated; with this object. void selectNormalization(const RooArgSet* depSet = 0, Bool_t force = kFALSE); Interface function to force use of a given set of observables; to interpret function value. Needed for functions or p.d.f.s; whose shape depends on the choice of normalization such as; RooAddPdf. void selectNormalizationRange(const char* rangeName = 0, Bool_t force = kFALSE); Interface function to force use of a given normalization range; to interpret function value. Needed for functions or p.d.f.s; whose shape depends on the choice of normalization such as; RooAddPdf. void setCacheCheck(Bool_t flag); Activate cache validation mode. Int_t getMaxVal(const Roo",MatchSource.WIKI,root/html602/RooAbsReal.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsReal.html
https://root.cern/root/html602/RooAbsReal.html:66026,Deployability,integrat,integrator,66026,"g* specialIntegratorConfig(Bool_t createOnTheFly); Returns the specialized integrator configuration for _this_ RooAbsReal.; If this object has no specialized configuration, a null pointer is returned,; unless createOnTheFly is kTRUE in which case a clone of the default integrator; configuration is created, installed as specialized configuration, and returned. const RooNumIntConfig* getIntegratorConfig() const; Return the numeric integration configuration used for this object. If; a specialized configuration was associated with this object, that configuration; is returned, otherwise the default configuration for all RooAbsReals is returned. RooNumIntConfig* getIntegratorConfig(); Return the numeric integration configuration used for this object. If; a specialized configuration was associated with this object, that configuration; is returned, otherwise the default configuration for all RooAbsReals is returned. void setIntegratorConfig(const RooNumIntConfig& config); Set the given integrator configuration as default numeric integration; configuration for this object. void setIntegratorConfig(); Remove the specialized numeric integration configuration associated; with this object. void selectNormalization(const RooArgSet* depSet = 0, Bool_t force = kFALSE); Interface function to force use of a given set of observables; to interpret function value. Needed for functions or p.d.f.s; whose shape depends on the choice of normalization such as; RooAddPdf. void selectNormalizationRange(const char* rangeName = 0, Bool_t force = kFALSE); Interface function to force use of a given normalization range; to interpret function value. Needed for functions or p.d.f.s; whose shape depends on the choice of normalization such as; RooAddPdf. void setCacheCheck(Bool_t flag); Activate cache validation mode. Int_t getMaxVal(const RooArgSet& vars) const; Advertise capability to determine maximum value of function for given set of; observables. If no direct generator method is provided, this inf",MatchSource.WIKI,root/html602/RooAbsReal.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsReal.html
https://root.cern/root/html602/RooAbsReal.html:66037,Deployability,configurat,configuration,66037,"g* specialIntegratorConfig(Bool_t createOnTheFly); Returns the specialized integrator configuration for _this_ RooAbsReal.; If this object has no specialized configuration, a null pointer is returned,; unless createOnTheFly is kTRUE in which case a clone of the default integrator; configuration is created, installed as specialized configuration, and returned. const RooNumIntConfig* getIntegratorConfig() const; Return the numeric integration configuration used for this object. If; a specialized configuration was associated with this object, that configuration; is returned, otherwise the default configuration for all RooAbsReals is returned. RooNumIntConfig* getIntegratorConfig(); Return the numeric integration configuration used for this object. If; a specialized configuration was associated with this object, that configuration; is returned, otherwise the default configuration for all RooAbsReals is returned. void setIntegratorConfig(const RooNumIntConfig& config); Set the given integrator configuration as default numeric integration; configuration for this object. void setIntegratorConfig(); Remove the specialized numeric integration configuration associated; with this object. void selectNormalization(const RooArgSet* depSet = 0, Bool_t force = kFALSE); Interface function to force use of a given set of observables; to interpret function value. Needed for functions or p.d.f.s; whose shape depends on the choice of normalization such as; RooAddPdf. void selectNormalizationRange(const char* rangeName = 0, Bool_t force = kFALSE); Interface function to force use of a given normalization range; to interpret function value. Needed for functions or p.d.f.s; whose shape depends on the choice of normalization such as; RooAddPdf. void setCacheCheck(Bool_t flag); Activate cache validation mode. Int_t getMaxVal(const RooArgSet& vars) const; Advertise capability to determine maximum value of function for given set of; observables. If no direct generator method is provided, this inf",MatchSource.WIKI,root/html602/RooAbsReal.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsReal.html
https://root.cern/root/html602/RooAbsReal.html:66070,Deployability,integrat,integration,66070,"g* specialIntegratorConfig(Bool_t createOnTheFly); Returns the specialized integrator configuration for _this_ RooAbsReal.; If this object has no specialized configuration, a null pointer is returned,; unless createOnTheFly is kTRUE in which case a clone of the default integrator; configuration is created, installed as specialized configuration, and returned. const RooNumIntConfig* getIntegratorConfig() const; Return the numeric integration configuration used for this object. If; a specialized configuration was associated with this object, that configuration; is returned, otherwise the default configuration for all RooAbsReals is returned. RooNumIntConfig* getIntegratorConfig(); Return the numeric integration configuration used for this object. If; a specialized configuration was associated with this object, that configuration; is returned, otherwise the default configuration for all RooAbsReals is returned. void setIntegratorConfig(const RooNumIntConfig& config); Set the given integrator configuration as default numeric integration; configuration for this object. void setIntegratorConfig(); Remove the specialized numeric integration configuration associated; with this object. void selectNormalization(const RooArgSet* depSet = 0, Bool_t force = kFALSE); Interface function to force use of a given set of observables; to interpret function value. Needed for functions or p.d.f.s; whose shape depends on the choice of normalization such as; RooAddPdf. void selectNormalizationRange(const char* rangeName = 0, Bool_t force = kFALSE); Interface function to force use of a given normalization range; to interpret function value. Needed for functions or p.d.f.s; whose shape depends on the choice of normalization such as; RooAddPdf. void setCacheCheck(Bool_t flag); Activate cache validation mode. Int_t getMaxVal(const RooArgSet& vars) const; Advertise capability to determine maximum value of function for given set of; observables. If no direct generator method is provided, this inf",MatchSource.WIKI,root/html602/RooAbsReal.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsReal.html
https://root.cern/root/html602/RooAbsReal.html:66083,Deployability,configurat,configuration,66083,"g* specialIntegratorConfig(Bool_t createOnTheFly); Returns the specialized integrator configuration for _this_ RooAbsReal.; If this object has no specialized configuration, a null pointer is returned,; unless createOnTheFly is kTRUE in which case a clone of the default integrator; configuration is created, installed as specialized configuration, and returned. const RooNumIntConfig* getIntegratorConfig() const; Return the numeric integration configuration used for this object. If; a specialized configuration was associated with this object, that configuration; is returned, otherwise the default configuration for all RooAbsReals is returned. RooNumIntConfig* getIntegratorConfig(); Return the numeric integration configuration used for this object. If; a specialized configuration was associated with this object, that configuration; is returned, otherwise the default configuration for all RooAbsReals is returned. void setIntegratorConfig(const RooNumIntConfig& config); Set the given integrator configuration as default numeric integration; configuration for this object. void setIntegratorConfig(); Remove the specialized numeric integration configuration associated; with this object. void selectNormalization(const RooArgSet* depSet = 0, Bool_t force = kFALSE); Interface function to force use of a given set of observables; to interpret function value. Needed for functions or p.d.f.s; whose shape depends on the choice of normalization such as; RooAddPdf. void selectNormalizationRange(const char* rangeName = 0, Bool_t force = kFALSE); Interface function to force use of a given normalization range; to interpret function value. Needed for functions or p.d.f.s; whose shape depends on the choice of normalization such as; RooAddPdf. void setCacheCheck(Bool_t flag); Activate cache validation mode. Int_t getMaxVal(const RooArgSet& vars) const; Advertise capability to determine maximum value of function for given set of; observables. If no direct generator method is provided, this inf",MatchSource.WIKI,root/html602/RooAbsReal.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsReal.html
https://root.cern/root/html602/RooAbsReal.html:66173,Deployability,integrat,integration,66173,"t has no specialized configuration, a null pointer is returned,; unless createOnTheFly is kTRUE in which case a clone of the default integrator; configuration is created, installed as specialized configuration, and returned. const RooNumIntConfig* getIntegratorConfig() const; Return the numeric integration configuration used for this object. If; a specialized configuration was associated with this object, that configuration; is returned, otherwise the default configuration for all RooAbsReals is returned. RooNumIntConfig* getIntegratorConfig(); Return the numeric integration configuration used for this object. If; a specialized configuration was associated with this object, that configuration; is returned, otherwise the default configuration for all RooAbsReals is returned. void setIntegratorConfig(const RooNumIntConfig& config); Set the given integrator configuration as default numeric integration; configuration for this object. void setIntegratorConfig(); Remove the specialized numeric integration configuration associated; with this object. void selectNormalization(const RooArgSet* depSet = 0, Bool_t force = kFALSE); Interface function to force use of a given set of observables; to interpret function value. Needed for functions or p.d.f.s; whose shape depends on the choice of normalization such as; RooAddPdf. void selectNormalizationRange(const char* rangeName = 0, Bool_t force = kFALSE); Interface function to force use of a given normalization range; to interpret function value. Needed for functions or p.d.f.s; whose shape depends on the choice of normalization such as; RooAddPdf. void setCacheCheck(Bool_t flag); Activate cache validation mode. Int_t getMaxVal(const RooArgSet& vars) const; Advertise capability to determine maximum value of function for given set of; observables. If no direct generator method is provided, this information; will assist the accept/reject generator to operate more efficiently as; it can skip the initial trial sampling phase to empiric",MatchSource.WIKI,root/html602/RooAbsReal.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsReal.html
https://root.cern/root/html602/RooAbsReal.html:66185,Deployability,configurat,configuration,66185,"t has no specialized configuration, a null pointer is returned,; unless createOnTheFly is kTRUE in which case a clone of the default integrator; configuration is created, installed as specialized configuration, and returned. const RooNumIntConfig* getIntegratorConfig() const; Return the numeric integration configuration used for this object. If; a specialized configuration was associated with this object, that configuration; is returned, otherwise the default configuration for all RooAbsReals is returned. RooNumIntConfig* getIntegratorConfig(); Return the numeric integration configuration used for this object. If; a specialized configuration was associated with this object, that configuration; is returned, otherwise the default configuration for all RooAbsReals is returned. void setIntegratorConfig(const RooNumIntConfig& config); Set the given integrator configuration as default numeric integration; configuration for this object. void setIntegratorConfig(); Remove the specialized numeric integration configuration associated; with this object. void selectNormalization(const RooArgSet* depSet = 0, Bool_t force = kFALSE); Interface function to force use of a given set of observables; to interpret function value. Needed for functions or p.d.f.s; whose shape depends on the choice of normalization such as; RooAddPdf. void selectNormalizationRange(const char* rangeName = 0, Bool_t force = kFALSE); Interface function to force use of a given normalization range; to interpret function value. Needed for functions or p.d.f.s; whose shape depends on the choice of normalization such as; RooAddPdf. void setCacheCheck(Bool_t flag); Activate cache validation mode. Int_t getMaxVal(const RooArgSet& vars) const; Advertise capability to determine maximum value of function for given set of; observables. If no direct generator method is provided, this information; will assist the accept/reject generator to operate more efficiently as; it can skip the initial trial sampling phase to empiric",MatchSource.WIKI,root/html602/RooAbsReal.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsReal.html
https://root.cern/root/html602/RooAbsReal.html:71656,Deployability,integrat,integration,71656,"ent 'obs' and should be copied in their preferred; order into argument 'orderdObs', This default implementation indicates no preference; and copies the original order of 'obs' into 'orderedObs'. RooAbsReal* createRunningIntegral(const RooArgSet& iset, const RooArgSet& nset = RooArgSet()); Create a running integral over this function, i.e. given a f(x), create an object; representing 'int[x_lo,x] f(x_prime) dx_prime'. RooAbsReal* createRunningIntegral(const RooArgSet& iset, const RooCmdArg& arg1, const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()); Create an object that represents the running integral of the function over one or more observables listed in iset, i.e. int[x_lo,x] f(x_prime) dx_prime. The actual integration calculation is only performed when the return object is evaluated. The name; of the integral object is automatically constructed from the name of the input function, the variables; it integrates and the range integrates over. The default strategy to calculate the running integrals is. - If the integrand (this object) supports analytical integration, construct an integral object; that calculate the running integrals value by calculating the analytical integral each; time the running integral object is evaluated. - If the integrand (this object) requires numeric integration to construct the running integral; create an object of class RooNumRunningInt which first samples the entire function and integrates; the sampled function numerically. This method has superior performance as there is no need to; perform a full (numeric) integration for each evaluation of the running integral object, but; only when one of its parameters has changed. The choice of strategy can be changed with the ScanAll() argument, which f",MatchSource.WIKI,root/html602/RooAbsReal.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsReal.html
https://root.cern/root/html602/RooAbsReal.html:71852,Deployability,integrat,integrates,71852," preference; and copies the original order of 'obs' into 'orderedObs'. RooAbsReal* createRunningIntegral(const RooArgSet& iset, const RooArgSet& nset = RooArgSet()); Create a running integral over this function, i.e. given a f(x), create an object; representing 'int[x_lo,x] f(x_prime) dx_prime'. RooAbsReal* createRunningIntegral(const RooArgSet& iset, const RooCmdArg& arg1, const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()); Create an object that represents the running integral of the function over one or more observables listed in iset, i.e. int[x_lo,x] f(x_prime) dx_prime. The actual integration calculation is only performed when the return object is evaluated. The name; of the integral object is automatically constructed from the name of the input function, the variables; it integrates and the range integrates over. The default strategy to calculate the running integrals is. - If the integrand (this object) supports analytical integration, construct an integral object; that calculate the running integrals value by calculating the analytical integral each; time the running integral object is evaluated. - If the integrand (this object) requires numeric integration to construct the running integral; create an object of class RooNumRunningInt which first samples the entire function and integrates; the sampled function numerically. This method has superior performance as there is no need to; perform a full (numeric) integration for each evaluation of the running integral object, but; only when one of its parameters has changed. The choice of strategy can be changed with the ScanAll() argument, which forces the use of the; scanning technique implemented in RooNumRunningInt for all use cases, and with the ScanNone(); argument",MatchSource.WIKI,root/html602/RooAbsReal.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsReal.html
https://root.cern/root/html602/RooAbsReal.html:71877,Deployability,integrat,integrates,71877," preference; and copies the original order of 'obs' into 'orderedObs'. RooAbsReal* createRunningIntegral(const RooArgSet& iset, const RooArgSet& nset = RooArgSet()); Create a running integral over this function, i.e. given a f(x), create an object; representing 'int[x_lo,x] f(x_prime) dx_prime'. RooAbsReal* createRunningIntegral(const RooArgSet& iset, const RooCmdArg& arg1, const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()); Create an object that represents the running integral of the function over one or more observables listed in iset, i.e. int[x_lo,x] f(x_prime) dx_prime. The actual integration calculation is only performed when the return object is evaluated. The name; of the integral object is automatically constructed from the name of the input function, the variables; it integrates and the range integrates over. The default strategy to calculate the running integrals is. - If the integrand (this object) supports analytical integration, construct an integral object; that calculate the running integrals value by calculating the analytical integral each; time the running integral object is evaluated. - If the integrand (this object) requires numeric integration to construct the running integral; create an object of class RooNumRunningInt which first samples the entire function and integrates; the sampled function numerically. This method has superior performance as there is no need to; perform a full (numeric) integration for each evaluation of the running integral object, but; only when one of its parameters has changed. The choice of strategy can be changed with the ScanAll() argument, which forces the use of the; scanning technique implemented in RooNumRunningInt for all use cases, and with the ScanNone(); argument",MatchSource.WIKI,root/html602/RooAbsReal.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsReal.html
https://root.cern/root/html602/RooAbsReal.html:72007,Deployability,integrat,integration,72007,"enting 'int[x_lo,x] f(x_prime) dx_prime'. RooAbsReal* createRunningIntegral(const RooArgSet& iset, const RooCmdArg& arg1, const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()); Create an object that represents the running integral of the function over one or more observables listed in iset, i.e. int[x_lo,x] f(x_prime) dx_prime. The actual integration calculation is only performed when the return object is evaluated. The name; of the integral object is automatically constructed from the name of the input function, the variables; it integrates and the range integrates over. The default strategy to calculate the running integrals is. - If the integrand (this object) supports analytical integration, construct an integral object; that calculate the running integrals value by calculating the analytical integral each; time the running integral object is evaluated. - If the integrand (this object) requires numeric integration to construct the running integral; create an object of class RooNumRunningInt which first samples the entire function and integrates; the sampled function numerically. This method has superior performance as there is no need to; perform a full (numeric) integration for each evaluation of the running integral object, but; only when one of its parameters has changed. The choice of strategy can be changed with the ScanAll() argument, which forces the use of the; scanning technique implemented in RooNumRunningInt for all use cases, and with the ScanNone(); argument which forces the 'integrate each evaluation' technique for all use cases. The sampling; granularity for the scanning technique can be controlled with the ScanParameters technique; which allows to specify the number of samples to be taken, and to which or",MatchSource.WIKI,root/html602/RooAbsReal.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsReal.html
https://root.cern/root/html602/RooAbsReal.html:72235,Deployability,integrat,integration,72235," RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()); Create an object that represents the running integral of the function over one or more observables listed in iset, i.e. int[x_lo,x] f(x_prime) dx_prime. The actual integration calculation is only performed when the return object is evaluated. The name; of the integral object is automatically constructed from the name of the input function, the variables; it integrates and the range integrates over. The default strategy to calculate the running integrals is. - If the integrand (this object) supports analytical integration, construct an integral object; that calculate the running integrals value by calculating the analytical integral each; time the running integral object is evaluated. - If the integrand (this object) requires numeric integration to construct the running integral; create an object of class RooNumRunningInt which first samples the entire function and integrates; the sampled function numerically. This method has superior performance as there is no need to; perform a full (numeric) integration for each evaluation of the running integral object, but; only when one of its parameters has changed. The choice of strategy can be changed with the ScanAll() argument, which forces the use of the; scanning technique implemented in RooNumRunningInt for all use cases, and with the ScanNone(); argument which forces the 'integrate each evaluation' technique for all use cases. The sampling; granularity for the scanning technique can be controlled with the ScanParameters technique; which allows to specify the number of samples to be taken, and to which order the resulting; running integral should be interpolated. The default values are 1000 samples and 2nd order; interpolation. The following named arguments are accepted. SupNormSet(const RooArgSet&) -- Observables over which shoul",MatchSource.WIKI,root/html602/RooAbsReal.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsReal.html
https://root.cern/root/html602/RooAbsReal.html:72369,Deployability,integrat,integrates,72369," RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()); Create an object that represents the running integral of the function over one or more observables listed in iset, i.e. int[x_lo,x] f(x_prime) dx_prime. The actual integration calculation is only performed when the return object is evaluated. The name; of the integral object is automatically constructed from the name of the input function, the variables; it integrates and the range integrates over. The default strategy to calculate the running integrals is. - If the integrand (this object) supports analytical integration, construct an integral object; that calculate the running integrals value by calculating the analytical integral each; time the running integral object is evaluated. - If the integrand (this object) requires numeric integration to construct the running integral; create an object of class RooNumRunningInt which first samples the entire function and integrates; the sampled function numerically. This method has superior performance as there is no need to; perform a full (numeric) integration for each evaluation of the running integral object, but; only when one of its parameters has changed. The choice of strategy can be changed with the ScanAll() argument, which forces the use of the; scanning technique implemented in RooNumRunningInt for all use cases, and with the ScanNone(); argument which forces the 'integrate each evaluation' technique for all use cases. The sampling; granularity for the scanning technique can be controlled with the ScanParameters technique; which allows to specify the number of samples to be taken, and to which order the resulting; running integral should be interpolated. The default values are 1000 samples and 2nd order; interpolation. The following named arguments are accepted. SupNormSet(const RooArgSet&) -- Observables over which shoul",MatchSource.WIKI,root/html602/RooAbsReal.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsReal.html
https://root.cern/root/html602/RooAbsReal.html:72501,Deployability,integrat,integration,72501,"represents the running integral of the function over one or more observables listed in iset, i.e. int[x_lo,x] f(x_prime) dx_prime. The actual integration calculation is only performed when the return object is evaluated. The name; of the integral object is automatically constructed from the name of the input function, the variables; it integrates and the range integrates over. The default strategy to calculate the running integrals is. - If the integrand (this object) supports analytical integration, construct an integral object; that calculate the running integrals value by calculating the analytical integral each; time the running integral object is evaluated. - If the integrand (this object) requires numeric integration to construct the running integral; create an object of class RooNumRunningInt which first samples the entire function and integrates; the sampled function numerically. This method has superior performance as there is no need to; perform a full (numeric) integration for each evaluation of the running integral object, but; only when one of its parameters has changed. The choice of strategy can be changed with the ScanAll() argument, which forces the use of the; scanning technique implemented in RooNumRunningInt for all use cases, and with the ScanNone(); argument which forces the 'integrate each evaluation' technique for all use cases. The sampling; granularity for the scanning technique can be controlled with the ScanParameters technique; which allows to specify the number of samples to be taken, and to which order the resulting; running integral should be interpolated. The default values are 1000 samples and 2nd order; interpolation. The following named arguments are accepted. SupNormSet(const RooArgSet&) -- Observables over which should be normalized _in_addition_ to the; integration observables; ScanParameters(Int_t nbins, -- Parameters for scanning technique of making CDF: number; Int_t intOrder) of sampled bins and order of interpolation appli",MatchSource.WIKI,root/html602/RooAbsReal.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsReal.html
https://root.cern/root/html602/RooAbsReal.html:72833,Deployability,integrat,integrate,72833," integral object is automatically constructed from the name of the input function, the variables; it integrates and the range integrates over. The default strategy to calculate the running integrals is. - If the integrand (this object) supports analytical integration, construct an integral object; that calculate the running integrals value by calculating the analytical integral each; time the running integral object is evaluated. - If the integrand (this object) requires numeric integration to construct the running integral; create an object of class RooNumRunningInt which first samples the entire function and integrates; the sampled function numerically. This method has superior performance as there is no need to; perform a full (numeric) integration for each evaluation of the running integral object, but; only when one of its parameters has changed. The choice of strategy can be changed with the ScanAll() argument, which forces the use of the; scanning technique implemented in RooNumRunningInt for all use cases, and with the ScanNone(); argument which forces the 'integrate each evaluation' technique for all use cases. The sampling; granularity for the scanning technique can be controlled with the ScanParameters technique; which allows to specify the number of samples to be taken, and to which order the resulting; running integral should be interpolated. The default values are 1000 samples and 2nd order; interpolation. The following named arguments are accepted. SupNormSet(const RooArgSet&) -- Observables over which should be normalized _in_addition_ to the; integration observables; ScanParameters(Int_t nbins, -- Parameters for scanning technique of making CDF: number; Int_t intOrder) of sampled bins and order of interpolation applied on numeric cdf; ScanNum() -- Apply scanning technique if cdf integral involves numeric integration; ScanAll() -- Always apply scanning technique; ScanNone() -- Never apply scanning technique. RooAbsReal* createScanRI(const RooArgSet& ",MatchSource.WIKI,root/html602/RooAbsReal.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsReal.html
https://root.cern/root/html602/RooAbsReal.html:73337,Deployability,integrat,integration,73337,"o; perform a full (numeric) integration for each evaluation of the running integral object, but; only when one of its parameters has changed. The choice of strategy can be changed with the ScanAll() argument, which forces the use of the; scanning technique implemented in RooNumRunningInt for all use cases, and with the ScanNone(); argument which forces the 'integrate each evaluation' technique for all use cases. The sampling; granularity for the scanning technique can be controlled with the ScanParameters technique; which allows to specify the number of samples to be taken, and to which order the resulting; running integral should be interpolated. The default values are 1000 samples and 2nd order; interpolation. The following named arguments are accepted. SupNormSet(const RooArgSet&) -- Observables over which should be normalized _in_addition_ to the; integration observables; ScanParameters(Int_t nbins, -- Parameters for scanning technique of making CDF: number; Int_t intOrder) of sampled bins and order of interpolation applied on numeric cdf; ScanNum() -- Apply scanning technique if cdf integral involves numeric integration; ScanAll() -- Always apply scanning technique; ScanNone() -- Never apply scanning technique. RooAbsReal* createScanRI(const RooArgSet& iset, const RooArgSet& nset, Int_t numScanBins, Int_t intOrder); Utility function for createRunningIntegral that construct an object; implementing the numeric scanning technique for calculating the running integral. RooAbsReal* createIntRI(const RooArgSet& iset, const RooArgSet& nset = RooArgSet()); Utility function for createRunningIntegral that construct an; object implementing the standard (analytical) integration; technique for calculating the running integral. RooFunctor* functor(const RooArgList& obs, const RooArgList& pars = RooArgList(), const RooArgSet& nset = RooArgSet()) const; Return a RooFunctor object bound to this RooAbsReal with given definition of observables; and parameters. TF1* asTF(const RooA",MatchSource.WIKI,root/html602/RooAbsReal.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsReal.html
https://root.cern/root/html602/RooAbsReal.html:73604,Deployability,integrat,integration,73604,"o; perform a full (numeric) integration for each evaluation of the running integral object, but; only when one of its parameters has changed. The choice of strategy can be changed with the ScanAll() argument, which forces the use of the; scanning technique implemented in RooNumRunningInt for all use cases, and with the ScanNone(); argument which forces the 'integrate each evaluation' technique for all use cases. The sampling; granularity for the scanning technique can be controlled with the ScanParameters technique; which allows to specify the number of samples to be taken, and to which order the resulting; running integral should be interpolated. The default values are 1000 samples and 2nd order; interpolation. The following named arguments are accepted. SupNormSet(const RooArgSet&) -- Observables over which should be normalized _in_addition_ to the; integration observables; ScanParameters(Int_t nbins, -- Parameters for scanning technique of making CDF: number; Int_t intOrder) of sampled bins and order of interpolation applied on numeric cdf; ScanNum() -- Apply scanning technique if cdf integral involves numeric integration; ScanAll() -- Always apply scanning technique; ScanNone() -- Never apply scanning technique. RooAbsReal* createScanRI(const RooArgSet& iset, const RooArgSet& nset, Int_t numScanBins, Int_t intOrder); Utility function for createRunningIntegral that construct an object; implementing the numeric scanning technique for calculating the running integral. RooAbsReal* createIntRI(const RooArgSet& iset, const RooArgSet& nset = RooArgSet()); Utility function for createRunningIntegral that construct an; object implementing the standard (analytical) integration; technique for calculating the running integral. RooFunctor* functor(const RooArgList& obs, const RooArgList& pars = RooArgList(), const RooArgSet& nset = RooArgSet()) const; Return a RooFunctor object bound to this RooAbsReal with given definition of observables; and parameters. TF1* asTF(const RooA",MatchSource.WIKI,root/html602/RooAbsReal.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsReal.html
https://root.cern/root/html602/RooAbsReal.html:74160,Deployability,integrat,integration,74160,"ng integral should be interpolated. The default values are 1000 samples and 2nd order; interpolation. The following named arguments are accepted. SupNormSet(const RooArgSet&) -- Observables over which should be normalized _in_addition_ to the; integration observables; ScanParameters(Int_t nbins, -- Parameters for scanning technique of making CDF: number; Int_t intOrder) of sampled bins and order of interpolation applied on numeric cdf; ScanNum() -- Apply scanning technique if cdf integral involves numeric integration; ScanAll() -- Always apply scanning technique; ScanNone() -- Never apply scanning technique. RooAbsReal* createScanRI(const RooArgSet& iset, const RooArgSet& nset, Int_t numScanBins, Int_t intOrder); Utility function for createRunningIntegral that construct an object; implementing the numeric scanning technique for calculating the running integral. RooAbsReal* createIntRI(const RooArgSet& iset, const RooArgSet& nset = RooArgSet()); Utility function for createRunningIntegral that construct an; object implementing the standard (analytical) integration; technique for calculating the running integral. RooFunctor* functor(const RooArgList& obs, const RooArgList& pars = RooArgList(), const RooArgSet& nset = RooArgSet()) const; Return a RooFunctor object bound to this RooAbsReal with given definition of observables; and parameters. TF1* asTF(const RooArgList& obs, const RooArgList& pars = RooArgList(), const RooArgSet& nset = RooArgSet()) const; Return a ROOT TF1,2,3 object bound to this RooAbsReal with given definition of observables; and parameters. RooDerivative* derivative(RooRealVar& obs, Int_t order = 1, Double_t eps = 0.001); Return function representing first, second or third order derivative of this function. RooDerivative* derivative(RooRealVar& obs, const RooArgSet& normSet, Int_t order, Double_t eps = 0.001); Return function representing first, second or third order derivative of this function. RooAbsMoment* moment(RooRealVar& obs, Int_t order, Boo",MatchSource.WIKI,root/html602/RooAbsReal.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsReal.html
https://root.cern/root/html602/RooAbsReal.html:75590,Deployability,integrat,integrated,75590,"ect bound to this RooAbsReal with given definition of observables; and parameters. RooDerivative* derivative(RooRealVar& obs, Int_t order = 1, Double_t eps = 0.001); Return function representing first, second or third order derivative of this function. RooDerivative* derivative(RooRealVar& obs, const RooArgSet& normSet, Int_t order, Double_t eps = 0.001); Return function representing first, second or third order derivative of this function. RooAbsMoment* moment(RooRealVar& obs, Int_t order, Bool_t central, Bool_t takeRoot); Return function representing moment of function of given order. If central is; true, the central moment is given <(x-<x>)^2>. RooAbsMoment* moment(RooRealVar& obs, const RooArgSet& normObs, Int_t order, Bool_t central, Bool_t takeRoot, Bool_t intNormObs); Return function representing moment of p.d.f (normalized w.r.t given observables) of given order. If central is; true, the central moment is given <(x-<x>)^2>. If intNormObs is true, the moment of the function integrated over; all normalization observables is returned. Double_t findRoot(RooRealVar& x, Double_t xmin, Double_t xmax, Double_t yval). Return value of x (in range xmin,xmax) at which function equals yval.; (Calculation is performed with Brent root finding algorithm). RooGenFunction* iGenFunction(RooRealVar& x, const RooArgSet& nset = RooArgSet()). RooMultiGenFunction* iGenFunction(const RooArgSet& observables, const RooArgSet& nset = RooArgSet()). RooFitResult* chi2FitTo(RooDataHist& data, const RooCmdArg& arg1 = RooCmdArg::none(), const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()); Perform a chi^2 fit to given histogram By default the fit is executed through the MINUIT; commands MIGRAD, HESSE in succession. The following named arguments ar",MatchSource.WIKI,root/html602/RooAbsReal.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsReal.html
https://root.cern/root/html602/RooAbsReal.html:84098,Deployability,integrat,integration,84098," Internal back-end function to create a chi^2 from a function and a dataset. RooFitResult* chi2FitDriver(RooAbsReal& fcn, RooLinkedList& cmdList); Internal driver function for chi2 fits. void setEvalErrorLoggingMode(RooAbsReal::ErrorLoggingMode m); Set evaluation error logging mode. Options are. PrintErrors - Print each error through RooMsgService() as it occurs; CollectErrors - Accumulate errors, but do not print them. A subsequent call; to printEvalErrors() will print a summary; CountErrors - Accumulate error count, but do not print them. void setParameterizeIntegral(const RooArgSet& paramVars). Double_t getVal(const RooArgSet* set = 0) const; Return value and unit accessors. Double_t getVal(const RooArgSet& set) const; { return _fast ? _value : getValV(&set) ; }. const Text_t * getUnit() const; Return string with unit description. void setUnit(const char* unit); Set unit description to given string. Bool_t forceAnalyticalInt(const RooAbsArg& ) const; Interface to force RooRealIntegral to offer given observable for internal integration; even if this is deemed unsafe. This default implementation returns always flase. void forceNumInt(Bool_t flag = kTRUE); If flag is true, all advertised analytical integrals will be ignored; and all integrals are calculated numerically. Bool_t getForceNumInt() const; { return _forceNumInt ; }. RooAbsReal* createIntegral(const RooArgSet& iset, const RooCmdArg& arg1, const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()) const; Create integral over observables in iset in range named rangeName. return createIntegral(iset,0,0,rangeName). RooAbsReal* createIntegral(const RooArgSet& iset, const RooArgSet& nset, const char* rangeName = 0) const; Create integral over observables in iset in range nam",MatchSource.WIKI,root/html602/RooAbsReal.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsReal.html
https://root.cern/root/html602/RooAbsReal.html:37759,Energy Efficiency,efficient,efficient,37759,"arg is a RooAbsReal. Bool_t isIdentical(const RooAbsArg& other, Bool_t assumeSameType = kFALSE). TString getTitle(Bool_t appendUnit = kFALSE) const; Return this variable's title string. If appendUnit is true and; this variable has units, also append a string "" (<unit>)"". Double_t getValV(const RooArgSet* set = 0) const; Return value of object. If the cache is clean, return the; cached value, otherwise recalculate on the fly and refill; the cache. Int_t numEvalErrorItems(). Double_t traceEval(const RooArgSet* set) const; Calculate current value of object, with error tracing wrapper. Int_t getAnalyticalIntegralWN(RooArgSet& allVars, RooArgSet& analVars, const RooArgSet* normSet, const char* rangeName = 0) const; Variant of getAnalyticalIntegral that is also passed the normalization set; that should be applied to the integrand of which the integral is request.; For certain operator p.d.f it is useful to overload this function rather; than analyticalIntegralWN() as the additional normalization information; may be useful in determining a more efficient decomposition of the; requested integral. Int_t getAnalyticalIntegral(RooArgSet& allVars, RooArgSet& analVars, const char* rangeName = 0) const; Interface function getAnalyticalIntergral advertises the; analytical integrals that are supported. 'integSet'; is the set of dependents for which integration is requested. The; function should copy the subset of dependents it can analytically; integrate to anaIntSet and return a unique identification code for; this integration configuration. If no integration can be; performed, zero should be returned. Double_t analyticalIntegralWN(Int_t code, const RooArgSet* normSet, const char* rangeName = 0) const; Implements the actual analytical integral(s) advertised by; getAnalyticalIntegral. This functions will only be called with; codes returned by getAnalyticalIntegral, except code zero. Double_t analyticalIntegral(Int_t code, const char* rangeName = 0) const; Implements the actual analy",MatchSource.WIKI,root/html602/RooAbsReal.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsReal.html
https://root.cern/root/html602/RooAbsReal.html:61260,Energy Efficiency,adapt,adaptor,61260,"asymmetric, and may perform better in the presence of strong correlations. Bool_t plotSanityChecks(RooPlot* frame) const; Utility function for plotOn(), perform general sanity check on frame to ensure safe plotting operations. void makeProjectionSet(const RooAbsArg* plotVar, const RooArgSet* allVars, RooArgSet& projectedVars, Bool_t silent) const; Utility function for plotOn() that constructs the set of; observables to project when plotting ourselves as function of; 'plotVar'. 'allVars' is the list of variables that must be; projected, but may contain variables that we do not depend on. If; 'silent' is cleared, warnings about inconsistent input parameters; will be printed. Bool_t isSelectedComp() const; If true, the current pdf is a selected component (for use in plotting). void globalSelectComp(Bool_t flag); Global switch controlling the activation of the selectComp() functionality. RooAbsFunc * bindVars(const RooArgSet& vars, const RooArgSet* nset = 0, Bool_t clipInvalid = kFALSE) const; Create an interface adaptor f(vars) that binds us to the specified variables; (in arbitrary order). For example, calling bindVars({x1,x3}) on an object; F(x1,x2,x3,x4) returns an object f(x1,x3) that is evaluated using the; current values of x2 and x4. The caller takes ownership of the returned adaptor. void copyCache(const RooAbsArg* source, Bool_t valueOnly = kFALSE, Bool_t setValDirty = kTRUE); Copy the cached value of another RooAbsArg to our cache.; Warning: This function copies the cached values of source,; it is the callers responsibility to make sure the cache is clean. void attachToVStore(RooVectorDataStore& vstore). void attachToTree(TTree& t, Int_t bufSize = 32000); Attach object to a branch of given TTree. By default it will; register the internal value cache RooAbsReal::_value as branch; buffer for a Double_t tree branch with the same name as this; object. If no Double_t branch is found with the name of this; object, this method looks for a Float_t Int_t, UChar_t and ",MatchSource.WIKI,root/html602/RooAbsReal.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsReal.html
https://root.cern/root/html602/RooAbsReal.html:61536,Energy Efficiency,adapt,adaptor,61536,"ooArgSet* allVars, RooArgSet& projectedVars, Bool_t silent) const; Utility function for plotOn() that constructs the set of; observables to project when plotting ourselves as function of; 'plotVar'. 'allVars' is the list of variables that must be; projected, but may contain variables that we do not depend on. If; 'silent' is cleared, warnings about inconsistent input parameters; will be printed. Bool_t isSelectedComp() const; If true, the current pdf is a selected component (for use in plotting). void globalSelectComp(Bool_t flag); Global switch controlling the activation of the selectComp() functionality. RooAbsFunc * bindVars(const RooArgSet& vars, const RooArgSet* nset = 0, Bool_t clipInvalid = kFALSE) const; Create an interface adaptor f(vars) that binds us to the specified variables; (in arbitrary order). For example, calling bindVars({x1,x3}) on an object; F(x1,x2,x3,x4) returns an object f(x1,x3) that is evaluated using the; current values of x2 and x4. The caller takes ownership of the returned adaptor. void copyCache(const RooAbsArg* source, Bool_t valueOnly = kFALSE, Bool_t setValDirty = kTRUE); Copy the cached value of another RooAbsArg to our cache.; Warning: This function copies the cached values of source,; it is the callers responsibility to make sure the cache is clean. void attachToVStore(RooVectorDataStore& vstore). void attachToTree(TTree& t, Int_t bufSize = 32000); Attach object to a branch of given TTree. By default it will; register the internal value cache RooAbsReal::_value as branch; buffer for a Double_t tree branch with the same name as this; object. If no Double_t branch is found with the name of this; object, this method looks for a Float_t Int_t, UChar_t and UInt_t; branch in that order. If any of these are found the buffer for; that branch is set to a correctly typed conversion buffer in this; RooRealVar. A flag is set that will cause copyCache to copy the; object value from the appropriate conversion buffer instead of; the _value buff",MatchSource.WIKI,root/html602/RooAbsReal.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsReal.html
https://root.cern/root/html602/RooAbsReal.html:67100,Energy Efficiency,efficient,efficiently,67100,"tion for this object. void setIntegratorConfig(); Remove the specialized numeric integration configuration associated; with this object. void selectNormalization(const RooArgSet* depSet = 0, Bool_t force = kFALSE); Interface function to force use of a given set of observables; to interpret function value. Needed for functions or p.d.f.s; whose shape depends on the choice of normalization such as; RooAddPdf. void selectNormalizationRange(const char* rangeName = 0, Bool_t force = kFALSE); Interface function to force use of a given normalization range; to interpret function value. Needed for functions or p.d.f.s; whose shape depends on the choice of normalization such as; RooAddPdf. void setCacheCheck(Bool_t flag); Activate cache validation mode. Int_t getMaxVal(const RooArgSet& vars) const; Advertise capability to determine maximum value of function for given set of; observables. If no direct generator method is provided, this information; will assist the accept/reject generator to operate more efficiently as; it can skip the initial trial sampling phase to empirically find the function; maximum. Double_t maxVal(Int_t code) const; Return maximum value for set of observables identified by code assigned; in getMaxVal. void logEvalError(const RooAbsReal* originator, const char* origName, const char* message, const char* serverValueString = 0); Interface to insert remote error logging messages received by RooRealMPFE into current error loggin stream. void logEvalError(const char* message, const char* serverValueString = 0) const; Log evaluation error message. Evaluation errors may be routed through a different; protocol than generic RooFit warning message (which go straight through RooMsgService); because evaluation errors can occur in very large numbers in the use of likelihood; evaluations. In logEvalError mode, controlled by global method enableEvalErrorLogging(); messages reported through this function are not printed but all stored in a list,; along with server values",MatchSource.WIKI,root/html602/RooAbsReal.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsReal.html
https://root.cern/root/html602/RooAbsReal.html:77958,Energy Efficiency,consumption,consumption,77958,"L calculation on num CPUs; Optimize(Bool_t flag) -- Activate constant term optimization (on by default). Options to control flow of fit procedure. InitialHesse(Bool_t flag) -- Flag controls if HESSE before MIGRAD as well, off by default; Hesse(Bool_t flag) -- Flag controls if HESSE is run after MIGRAD, on by default; Minos(Bool_t flag) -- Flag controls if MINOS is run after HESSE, on by default; Minos(const RooArgSet& set) -- Only run MINOS on given subset of arguments; Save(Bool_t flag) -- Flac controls if RooFitResult object is produced and returned, off by default; Strategy(Int_t flag) -- Set Minuit strategy (0 through 2, default is 1); FitOptions(const char* optStr) -- Steer fit with classic options string (for backward compatibility). Use of this option; excludes use of any of the new style steering options. Options to control informational output. Verbose(Bool_t flag) -- Flag controls if verbose output is printed (NLL, parameter changes during fit; Timer(Bool_t flag) -- Time CPU and wall clock consumption of fit steps, off by default; PrintLevel(Int_t level) -- Set Minuit print level (-1 through 3, default is 1). At -1 all RooFit informational; messages are suppressed as well; Warnings(Bool_t flag) -- Enable or disable MINUIT warnings (enabled by default); PrintEvalErrors(Int_t numErr) -- Control number of p.d.f evaluation errors printed per likelihood evaluation. A negative; value suppress output completely, a zero value will only print the error count per p.d.f component,; a positive value is will print details of each error up to numErr messages per p.d.f component. RooFitResult* chi2FitTo(RooDataHist& data, const RooLinkedList& cmdList); Internal back-end function to steer chi2 fits. RooAbsReal* createChi2(RooDataHist& data, const RooCmdArg& arg1 = RooCmdArg::none(), const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6",MatchSource.WIKI,root/html602/RooAbsReal.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsReal.html
https://root.cern/root/html602/RooAbsReal.html:81353,Energy Efficiency,consumption,consumption,81353,"ol_t flag) -- Integrate function over range specified by X errors; rather than take value at bin center. Options to control flow of fit procedure. InitialHesse(Bool_t flag) -- Flag controls if HESSE before MIGRAD as well, off by default; Hesse(Bool_t flag) -- Flag controls if HESSE is run after MIGRAD, on by default; Minos(Bool_t flag) -- Flag controls if MINOS is run after HESSE, on by default; Minos(const RooArgSet& set) -- Only run MINOS on given subset of arguments; Save(Bool_t flag) -- Flac controls if RooFitResult object is produced and returned, off by default; Strategy(Int_t flag) -- Set Minuit strategy (0 through 2, default is 1); FitOptions(const char* optStr) -- Steer fit with classic options string (for backward compatibility). Use of this option; excludes use of any of the new style steering options. Options to control informational output. Verbose(Bool_t flag) -- Flag controls if verbose output is printed (NLL, parameter changes during fit; Timer(Bool_t flag) -- Time CPU and wall clock consumption of fit steps, off by default; PrintLevel(Int_t level) -- Set Minuit print level (-1 through 3, default is 1). At -1 all RooFit informational; messages are suppressed as well; Warnings(Bool_t flag) -- Enable or disable MINUIT warnings (enabled by default); PrintEvalErrors(Int_t numErr) -- Control number of p.d.f evaluation errors printed per likelihood evaluation. A negative; value suppress output completely, a zero value will only print the error count per p.d.f component,; a positive value is will print details of each error up to numErr messages per p.d.f component. RooFitResult* chi2FitTo(RooDataSet& xydata, const RooLinkedList& cmdList); Internal back-end function to steer chi2 fits. RooAbsReal* createChi2(RooDataSet& data, const RooCmdArg& arg1 = RooCmdArg::none(), const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6",MatchSource.WIKI,root/html602/RooAbsReal.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsReal.html
https://root.cern/root/html602/RooAbsReal.html:634,Integrability,interface,interface,634,". RooAbsReal. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » ROOFIT; » ROOFITCORE; » RooAbsReal. class RooAbsReal: public RooAbsArg. RooAbsReal is the common abstract base class for objects that represent a; real value and implements functionality common to all real-valued objects; such as the ability to plot them, to construct integrals of them, the; ability to advertise (partial) analytical integrals etc..; Implementation of RooAbsReal may be derived, thus no interface; is provided to modify the contents.; ; ; . Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~RooAbsReal(); voidTObject::AbstractMethod(const char* method) const; Bool_tRooAbsArg::addOwnedComponents(const RooArgSet& comps); voidRooAbsArg::addParameters(RooArgSet& params, const RooArgSet* nset = 0, Bool_t stripDisconnected = kTRUE) const; voidRooAbsArg::addServer(RooAbsArg& server, Bool_t valueProp = kTRUE, Bool_t shapeProp = kFALSE); voidRooAbsArg::addServerList(RooAbsCollection& serverList, Bool_t valueProp = kTRUE, Bool_t shapeProp = kFALSE); const char*RooAbsArg::aggregateCacheUniqueSuffix() const; virtual Double_tanalyticalIntegral(Int_t code, const char* rangeName = 0) const; virtual Double_tanalyticalIntegralWN(Int_t code, const RooArgSet* normSet, const char* rangeName = 0) const; virtual voidTObject::AppendPad(Option_t* option = """"); TF1*asTF(const RooArgList& obs, const RooArgList& pars = RooArgList(), const RooArgSet& nset = RooArgSet()) const; voidRooAbsArg::attachDataSet(const RooAbsData& set); voidRooAbsArg::attachDataStore(const RooAbsDataStore& set); const set<string>&RooAbsArg::attributes() const; virtual list<Double_t>*binBoundaries(RooAbsRealLValue&, Double_t, Double_t) const; RooAbsFunc*bindVa",MatchSource.WIKI,root/html602/RooAbsReal.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsReal.html
https://root.cern/root/html602/RooAbsReal.html:7383,Integrability,depend,dependentVars,7383,"nst RooArgSet& iset, const RooArgSet& nset, const RooNumIntConfig& cfg, const char* rangeName = 0) const; virtual RooAbsReal*createIntegral(const RooArgSet& iset, const RooArgSet* nset = 0, const RooNumIntConfig* cfg = 0, const char* rangeName = 0) const; RooAbsReal*createIntegral(const RooArgSet& iset, const RooCmdArg& arg1, const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()) const; RooAbsReal*createIntRI(const RooArgSet& iset, const RooArgSet& nset = RooArgSet()); const RooAbsReal*createPlotProjection(const RooArgSet& depVars, const RooArgSet& projVars) const; const RooAbsReal*createPlotProjection(const RooArgSet& depVars, const RooArgSet& projVars, RooArgSet*& cloneSet) const; const RooAbsReal*createPlotProjection(const RooArgSet& dependentVars, const RooArgSet* projectedVars, RooArgSet*& cloneSet, const char* rangeName = 0, const RooArgSet* condObs = 0) const; virtual RooAbsReal*createProfile(const RooArgSet& paramsOfInterest); RooAbsReal*createRunningIntegral(const RooArgSet& iset, const RooArgSet& nset = RooArgSet()); RooAbsReal*createRunningIntegral(const RooArgSet& iset, const RooCmdArg& arg1, const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()); RooAbsReal*createScanRI(const RooArgSet& iset, const RooArgSet& nset, Int_t numScanBins, Int_t intOrder); virtual Double_tdefaultErrorLevel() const; static RooNumIntConfig*defaultIntegratorConfig(); virtual Int_tRooAbsArg::defaultPrintContents(Option_t* opt) const; static ostream&RooPrintable::defaultPrintStream(ostream* os = 0)",MatchSource.WIKI,root/html602/RooAbsReal.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsReal.html
https://root.cern/root/html602/RooAbsReal.html:8553,Integrability,depend,dependentOverlaps,8553,"onst RooArgSet& depVars, const RooArgSet& projVars, RooArgSet*& cloneSet) const; const RooAbsReal*createPlotProjection(const RooArgSet& dependentVars, const RooArgSet* projectedVars, RooArgSet*& cloneSet, const char* rangeName = 0, const RooArgSet* condObs = 0) const; virtual RooAbsReal*createProfile(const RooArgSet& paramsOfInterest); RooAbsReal*createRunningIntegral(const RooArgSet& iset, const RooArgSet& nset = RooArgSet()); RooAbsReal*createRunningIntegral(const RooArgSet& iset, const RooCmdArg& arg1, const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()); RooAbsReal*createScanRI(const RooArgSet& iset, const RooArgSet& nset, Int_t numScanBins, Int_t intOrder); virtual Double_tdefaultErrorLevel() const; static RooNumIntConfig*defaultIntegratorConfig(); virtual Int_tRooAbsArg::defaultPrintContents(Option_t* opt) const; static ostream&RooPrintable::defaultPrintStream(ostream* os = 0); virtual RooPrintable::StyleOptionRooPrintable::defaultPrintStyle(Option_t* opt) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; Bool_tRooAbsArg::dependentOverlaps(const RooAbsData* dset, const RooAbsArg& testArg) const; Bool_tRooAbsArg::dependentOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; Bool_tRooAbsArg::dependsOn(const RooAbsCollection& serverList, const RooAbsArg* ignoreArg = 0, Bool_t valueOnly = kFALSE) const; Bool_tRooAbsArg::dependsOn(const RooAbsArg& server, const RooAbsArg* ignoreArg = 0, Bool_t valueOnly = kFALSE) const; Bool_tRooAbsArg::dependsOnValue(const RooAbsCollection& serverList, const RooAbsArg* ignoreArg = 0) const; Bool_tRooAbsArg::dependsOnValue(const RooAbsArg& server, const RooAbsArg* ignoreArg = 0) const; RooDerivative*derivative(RooRealVar& obs, Int_t order = 1, Double_t eps = 0.",MatchSource.WIKI,root/html602/RooAbsReal.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/RooAbsReal.html
