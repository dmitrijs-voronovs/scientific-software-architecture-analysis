id,quality_attribute,keyword,matched_word,match_idx,sentence,source,filename,author,repo,version,wiki,url
https://root.cern/doc/v632/RWebDisplayArgs_8cxx_source.html:12805,Deployability,configurat,configuration,12805," created QWebEngineView can be found with the command:; 350///; 351/// auto view = qparent->findChild<QWebEngineView*>(""RootWebView"");; 352 ; 353std::string RWebDisplayArgs::GetQt5EmbedQualifier(const void *qparent, const std::string &urlopt, unsigned qtversion); 354{; 355 std::string where = (qtversion >= 0x60000) ? ""qt6"" : ""qt5"";; 356 if (qparent) {; 357 where.append("":"");; 358 where.append(std::to_string((uintptr_t) qparent));; 359 }; 360 if (!urlopt.empty()) {; 361 where.append(""?"");; 362 where.append(urlopt);; 363 }; 364 return where;; 365}; RConfig.hxx; RLogger.hxx; RWebDisplayArgs.hxx; RWebWindow.hxx; widthOption_t Option_t widthDefinition TGWin32VirtualXProxy.cxx:56; heightOption_t Option_t TPoint TPoint const char GetTextMagnitude GetFillStyle GetLineColor GetLineWidth GetMarkerStyle GetTextAlign GetTextColor GetTextSize void char Point_t Rectangle_t heightDefinition TGWin32VirtualXProxy.cxx:164; TROOT.h; gROOT#define gROOTDefinition TROOT.h:406; ROOT::Experimental::RLogChannelA log configuration for a channel, e.g.Definition RLogger.hxx:101; ROOT::RWebDisplayArgsHolds different arguments for starting browser with RWebDisplayHandle::Display() method.Definition RWebDisplayArgs.hxx:33; ROOT::RWebDisplayArgs::GetBrowserNamestd::string GetBrowserName() constReturns configured browser name.Definition RWebDisplayArgs.cxx:248; ROOT::RWebDisplayArgs::~RWebDisplayArgsvirtual ~RWebDisplayArgs()Destructor.; ROOT::RWebDisplayArgs::GetBrowserKindEBrowserKind GetBrowserKind() constreturns configured browser kind, see EBrowserKind for supported valuesDefinition RWebDisplayArgs.hxx:98; ROOT::RWebDisplayArgs::SetUrlOptRWebDisplayArgs & SetUrlOpt(const std::string &opt)set window url optionsDefinition RWebDisplayArgs.hxx:148; ROOT::RWebDisplayArgs::SetPosAsStrbool SetPosAsStr(const std::string &str)Set position of web browser window as string like ""100,100"".Definition RWebDisplayArgs.cxx:120; ROOT::RWebDisplayArgs::fExecstd::string fExec! string to run browser, used with kCus",MatchSource.WIKI,doc/v632/RWebDisplayArgs_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/RWebDisplayArgs_8cxx_source.html
https://root.cern/doc/v632/RWebDisplayArgs_8cxx_source.html:1471,Modifiability,config,configured,1471," * For the licensing terms see $ROOTSYS/LICENSE. *; 10 * For the list of contributors see $ROOTSYS/README/CREDITS. *; 11 *************************************************************************/; 12 ; 13#include <ROOT/RWebDisplayArgs.hxx>; 14 ; 15#include <ROOT/RConfig.hxx>; 16#include <ROOT/RLogger.hxx>; 17#include <ROOT/RWebWindow.hxx>; 18 ; 19#include ""TROOT.h""; 20#include <string>; 21 ; 22using namespace ROOT;; 23 ; 24ROOT::Experimental::RLogChannel &ROOT::WebGUILog(); 25{; 26 static ROOT::Experimental::RLogChannel sLog(""ROOT.WebGUI"");; 27 return sLog;; 28}; 29 ; 30 ; 31/** \class ROOT::RWebDisplayArgs; 32\ingroup webdisplay; 33 ; 34Holds different arguments for starting browser with RWebDisplayHandle::Display() method; 35 ; 36*/; 37 ; 38///////////////////////////////////////////////////////////////////////////////////////////; 39/// Default constructor.; 40/// Browser kind configured from gROOT->GetWebDisplay(); 41 ; 42RWebDisplayArgs::RWebDisplayArgs(); 43{; 44 SetBrowserKind("""");; 45}; 46 ; 47///////////////////////////////////////////////////////////////////////////////////////////; 48/// Constructor.; 49/// Browser kind specified as std::string.; 50/// See \ref SetBrowserKind method for description of allowed parameters; 51 ; 52RWebDisplayArgs::RWebDisplayArgs(const std::string &browser); 53{; 54 SetBrowserKind(browser);; 55}; 56 ; 57///////////////////////////////////////////////////////////////////////////////////////////; 58/// Constructor.; 59/// Browser kind specified as `const char *`.; 60/// See \ref SetBrowserKind method for description of allowed parameters; 61 ; 62RWebDisplayArgs::RWebDisplayArgs(const char *browser); 63{; 64 SetBrowserKind(browser);; 65}; 66 ; 67///////////////////////////////////////////////////////////////////////////////////////////; 68/// Constructor.; 69/// Let specify window width and height; 70 ; 71RWebDisplayArgs::RWebDisplayArgs(int width, int height, int x, int y, const std::string &browser); 72{; 73 SetSize(width, he",MatchSource.WIKI,doc/v632/RWebDisplayArgs_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/RWebDisplayArgs_8cxx_source.html
https://root.cern/doc/v632/RWebDisplayArgs_8cxx_source.html:8403,Modifiability,config,configured,8403,"209 kind = gROOT->GetWebDisplay().Data();; 210 ; 211 if (kind == ""local""); 212 SetBrowserKind(kLocal);; 213 else if (kind == ""native""); 214 SetBrowserKind(kNative);; 215 else if (kind.empty() || (kind == ""on"")); 216 SetBrowserKind(kOn);; 217 else if ((kind == ""dflt"") || (kind == ""default"") || (kind == ""browser"")); 218 SetBrowserKind(kDefault);; 219 else if (kind == ""firefox""); 220 SetBrowserKind(kFirefox);; 221 else if ((kind == ""chrome"") || (kind == ""chromium"")); 222 SetBrowserKind(kChrome);; 223#ifdef _MSC_VER; 224 else if ((kind == ""edge"") || (kind == ""msedge"")); 225 SetBrowserKind(kEdge);; 226#endif; 227 else if ((kind == ""cef"") || (kind == ""cef3"")); 228 SetBrowserKind(kCEF);; 229 else if ((kind == ""qt"") || (kind == ""qt5"")); 230 SetBrowserKind(kQt5);; 231 else if (kind == ""qt6""); 232 SetBrowserKind(kQt6);; 233 else if ((kind == ""embed"") || (kind == ""embedded"")); 234 SetBrowserKind(kEmbedded);; 235 else if (kind == ""server""); 236 SetBrowserKind(kServer);; 237 else if (kind == ""off""); 238 SetBrowserKind(kOff);; 239 else if (!SetSizeAsStr(kind)); 240 SetCustomExec(kind);; 241 ; 242 return *this;; 243}; 244 ; 245/////////////////////////////////////////////////////////////////////; 246/// Returns configured browser name; 247 ; 248std::string RWebDisplayArgs::GetBrowserName() const; 249{; 250 switch (GetBrowserKind()) {; 251 case kChrome: return ""chrome"";; 252 case kEdge: return ""edge"";; 253 case kFirefox: return ""firefox"";; 254 case kNative: return ""native"";; 255 case kCEF: return ""cef"";; 256 case kQt5: return ""qt5"";; 257 case kQt6: return ""qt6"";; 258 case kLocal: return ""local"";; 259 case kDefault: return ""default"";; 260 case kServer: return ""server"";; 261 case kEmbedded: return ""embed"";; 262 case kOff: return ""off"";; 263 case kOn: return ""on"";; 264 case kCustom:; 265 auto pos = fExec.find("" "");; 266 return (pos == std::string::npos) ? fExec : fExec.substr(0,pos);; 267 }; 268 ; 269 return """";; 270}; 271 ; 272//////////////////////////////////////////////////////////",MatchSource.WIKI,doc/v632/RWebDisplayArgs_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/RWebDisplayArgs_8cxx_source.html
https://root.cern/doc/v632/RWebDisplayArgs_8cxx_source.html:12805,Modifiability,config,configuration,12805," created QWebEngineView can be found with the command:; 350///; 351/// auto view = qparent->findChild<QWebEngineView*>(""RootWebView"");; 352 ; 353std::string RWebDisplayArgs::GetQt5EmbedQualifier(const void *qparent, const std::string &urlopt, unsigned qtversion); 354{; 355 std::string where = (qtversion >= 0x60000) ? ""qt6"" : ""qt5"";; 356 if (qparent) {; 357 where.append("":"");; 358 where.append(std::to_string((uintptr_t) qparent));; 359 }; 360 if (!urlopt.empty()) {; 361 where.append(""?"");; 362 where.append(urlopt);; 363 }; 364 return where;; 365}; RConfig.hxx; RLogger.hxx; RWebDisplayArgs.hxx; RWebWindow.hxx; widthOption_t Option_t widthDefinition TGWin32VirtualXProxy.cxx:56; heightOption_t Option_t TPoint TPoint const char GetTextMagnitude GetFillStyle GetLineColor GetLineWidth GetMarkerStyle GetTextAlign GetTextColor GetTextSize void char Point_t Rectangle_t heightDefinition TGWin32VirtualXProxy.cxx:164; TROOT.h; gROOT#define gROOTDefinition TROOT.h:406; ROOT::Experimental::RLogChannelA log configuration for a channel, e.g.Definition RLogger.hxx:101; ROOT::RWebDisplayArgsHolds different arguments for starting browser with RWebDisplayHandle::Display() method.Definition RWebDisplayArgs.hxx:33; ROOT::RWebDisplayArgs::GetBrowserNamestd::string GetBrowserName() constReturns configured browser name.Definition RWebDisplayArgs.cxx:248; ROOT::RWebDisplayArgs::~RWebDisplayArgsvirtual ~RWebDisplayArgs()Destructor.; ROOT::RWebDisplayArgs::GetBrowserKindEBrowserKind GetBrowserKind() constreturns configured browser kind, see EBrowserKind for supported valuesDefinition RWebDisplayArgs.hxx:98; ROOT::RWebDisplayArgs::SetUrlOptRWebDisplayArgs & SetUrlOpt(const std::string &opt)set window url optionsDefinition RWebDisplayArgs.hxx:148; ROOT::RWebDisplayArgs::SetPosAsStrbool SetPosAsStr(const std::string &str)Set position of web browser window as string like ""100,100"".Definition RWebDisplayArgs.cxx:120; ROOT::RWebDisplayArgs::fExecstd::string fExec! string to run browser, used with kCus",MatchSource.WIKI,doc/v632/RWebDisplayArgs_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/RWebDisplayArgs_8cxx_source.html
https://root.cern/doc/v632/RWebDisplayArgs_8cxx_source.html:13089,Modifiability,config,configured,13089,"on); 354{; 355 std::string where = (qtversion >= 0x60000) ? ""qt6"" : ""qt5"";; 356 if (qparent) {; 357 where.append("":"");; 358 where.append(std::to_string((uintptr_t) qparent));; 359 }; 360 if (!urlopt.empty()) {; 361 where.append(""?"");; 362 where.append(urlopt);; 363 }; 364 return where;; 365}; RConfig.hxx; RLogger.hxx; RWebDisplayArgs.hxx; RWebWindow.hxx; widthOption_t Option_t widthDefinition TGWin32VirtualXProxy.cxx:56; heightOption_t Option_t TPoint TPoint const char GetTextMagnitude GetFillStyle GetLineColor GetLineWidth GetMarkerStyle GetTextAlign GetTextColor GetTextSize void char Point_t Rectangle_t heightDefinition TGWin32VirtualXProxy.cxx:164; TROOT.h; gROOT#define gROOTDefinition TROOT.h:406; ROOT::Experimental::RLogChannelA log configuration for a channel, e.g.Definition RLogger.hxx:101; ROOT::RWebDisplayArgsHolds different arguments for starting browser with RWebDisplayHandle::Display() method.Definition RWebDisplayArgs.hxx:33; ROOT::RWebDisplayArgs::GetBrowserNamestd::string GetBrowserName() constReturns configured browser name.Definition RWebDisplayArgs.cxx:248; ROOT::RWebDisplayArgs::~RWebDisplayArgsvirtual ~RWebDisplayArgs()Destructor.; ROOT::RWebDisplayArgs::GetBrowserKindEBrowserKind GetBrowserKind() constreturns configured browser kind, see EBrowserKind for supported valuesDefinition RWebDisplayArgs.hxx:98; ROOT::RWebDisplayArgs::SetUrlOptRWebDisplayArgs & SetUrlOpt(const std::string &opt)set window url optionsDefinition RWebDisplayArgs.hxx:148; ROOT::RWebDisplayArgs::SetPosAsStrbool SetPosAsStr(const std::string &str)Set position of web browser window as string like ""100,100"".Definition RWebDisplayArgs.cxx:120; ROOT::RWebDisplayArgs::fExecstd::string fExec! string to run browser, used with kCustom typeDefinition RWebDisplayArgs.hxx:71; ROOT::RWebDisplayArgs::SetSizeRWebDisplayArgs & SetSize(int w, int h)set preferable web window width and heightDefinition RWebDisplayArgs.hxx:173; ROOT::RWebDisplayArgs::fUrlOptstd::string fUrlOpt! extra URL options,",MatchSource.WIKI,doc/v632/RWebDisplayArgs_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/RWebDisplayArgs_8cxx_source.html
https://root.cern/doc/v632/RWebDisplayArgs_8cxx_source.html:13307,Modifiability,config,configured,13307,"rlopt);; 363 }; 364 return where;; 365}; RConfig.hxx; RLogger.hxx; RWebDisplayArgs.hxx; RWebWindow.hxx; widthOption_t Option_t widthDefinition TGWin32VirtualXProxy.cxx:56; heightOption_t Option_t TPoint TPoint const char GetTextMagnitude GetFillStyle GetLineColor GetLineWidth GetMarkerStyle GetTextAlign GetTextColor GetTextSize void char Point_t Rectangle_t heightDefinition TGWin32VirtualXProxy.cxx:164; TROOT.h; gROOT#define gROOTDefinition TROOT.h:406; ROOT::Experimental::RLogChannelA log configuration for a channel, e.g.Definition RLogger.hxx:101; ROOT::RWebDisplayArgsHolds different arguments for starting browser with RWebDisplayHandle::Display() method.Definition RWebDisplayArgs.hxx:33; ROOT::RWebDisplayArgs::GetBrowserNamestd::string GetBrowserName() constReturns configured browser name.Definition RWebDisplayArgs.cxx:248; ROOT::RWebDisplayArgs::~RWebDisplayArgsvirtual ~RWebDisplayArgs()Destructor.; ROOT::RWebDisplayArgs::GetBrowserKindEBrowserKind GetBrowserKind() constreturns configured browser kind, see EBrowserKind for supported valuesDefinition RWebDisplayArgs.hxx:98; ROOT::RWebDisplayArgs::SetUrlOptRWebDisplayArgs & SetUrlOpt(const std::string &opt)set window url optionsDefinition RWebDisplayArgs.hxx:148; ROOT::RWebDisplayArgs::SetPosAsStrbool SetPosAsStr(const std::string &str)Set position of web browser window as string like ""100,100"".Definition RWebDisplayArgs.cxx:120; ROOT::RWebDisplayArgs::fExecstd::string fExec! string to run browser, used with kCustom typeDefinition RWebDisplayArgs.hxx:71; ROOT::RWebDisplayArgs::SetSizeRWebDisplayArgs & SetSize(int w, int h)set preferable web window width and heightDefinition RWebDisplayArgs.hxx:173; ROOT::RWebDisplayArgs::fUrlOptstd::string fUrlOpt! extra URL options, which are append to window URLDefinition RWebDisplayArgs.hxx:70; ROOT::RWebDisplayArgs::GetUrlconst std::string & GetUrl() constreturns window urlDefinition RWebDisplayArgs.hxx:129; ROOT::RWebDisplayArgs::SetCustomExecvoid SetCustomExec(const std::stri",MatchSource.WIKI,doc/v632/RWebDisplayArgs_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/RWebDisplayArgs_8cxx_source.html
https://root.cern/doc/v632/RWebDisplayArgs_8cxx_source.html:12801,Testability,log,log,12801," created QWebEngineView can be found with the command:; 350///; 351/// auto view = qparent->findChild<QWebEngineView*>(""RootWebView"");; 352 ; 353std::string RWebDisplayArgs::GetQt5EmbedQualifier(const void *qparent, const std::string &urlopt, unsigned qtversion); 354{; 355 std::string where = (qtversion >= 0x60000) ? ""qt6"" : ""qt5"";; 356 if (qparent) {; 357 where.append("":"");; 358 where.append(std::to_string((uintptr_t) qparent));; 359 }; 360 if (!urlopt.empty()) {; 361 where.append(""?"");; 362 where.append(urlopt);; 363 }; 364 return where;; 365}; RConfig.hxx; RLogger.hxx; RWebDisplayArgs.hxx; RWebWindow.hxx; widthOption_t Option_t widthDefinition TGWin32VirtualXProxy.cxx:56; heightOption_t Option_t TPoint TPoint const char GetTextMagnitude GetFillStyle GetLineColor GetLineWidth GetMarkerStyle GetTextAlign GetTextColor GetTextSize void char Point_t Rectangle_t heightDefinition TGWin32VirtualXProxy.cxx:164; TROOT.h; gROOT#define gROOTDefinition TROOT.h:406; ROOT::Experimental::RLogChannelA log configuration for a channel, e.g.Definition RLogger.hxx:101; ROOT::RWebDisplayArgsHolds different arguments for starting browser with RWebDisplayHandle::Display() method.Definition RWebDisplayArgs.hxx:33; ROOT::RWebDisplayArgs::GetBrowserNamestd::string GetBrowserName() constReturns configured browser name.Definition RWebDisplayArgs.cxx:248; ROOT::RWebDisplayArgs::~RWebDisplayArgsvirtual ~RWebDisplayArgs()Destructor.; ROOT::RWebDisplayArgs::GetBrowserKindEBrowserKind GetBrowserKind() constreturns configured browser kind, see EBrowserKind for supported valuesDefinition RWebDisplayArgs.hxx:98; ROOT::RWebDisplayArgs::SetUrlOptRWebDisplayArgs & SetUrlOpt(const std::string &opt)set window url optionsDefinition RWebDisplayArgs.hxx:148; ROOT::RWebDisplayArgs::SetPosAsStrbool SetPosAsStr(const std::string &str)Set position of web browser window as string like ""100,100"".Definition RWebDisplayArgs.cxx:120; ROOT::RWebDisplayArgs::fExecstd::string fExec! string to run browser, used with kCus",MatchSource.WIKI,doc/v632/RWebDisplayArgs_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/RWebDisplayArgs_8cxx_source.html
https://root.cern/doc/v632/RWebDisplayArgs_8cxx_source.html:5763,Usability,clear,clear,5763,"rowser; 147/// firefox - use Mozilla Firefox web browser; 148/// edge - use Microsoft Edge web browser (Windows only); 149/// native - either chrome/edge or firefox, only these browsers support batch (headless) mode; 150/// default - default system web-browser, no batch mode; 151/// cef - Chromium Embeded Framework, local display, local communication; 152/// qt5 - Qt5 QWebEngine, local display, local communication; 153/// qt6 - Qt6 QWebEngineCore, local display, local communication; 154/// local - either cef or qt5 or qt6; 155/// off - disable web display; 156/// on - first try ""local"", then ""native"", then ""default"" (default option); 157/// `<prog>` - any program name which will be started to open widget URL, like ""/usr/bin/opera""; 158 ; 159RWebDisplayArgs &RWebDisplayArgs::SetBrowserKind(const std::string &_kind); 160{; 161 std::string kind = _kind;; 162 ; 163 auto pos = kind.find(""?"");; 164 if (pos == 0) {; 165 SetUrlOpt(kind.substr(1));; 166 kind.clear();; 167 } else if (pos != std::string::npos) {; 168 SetUrlOpt(kind.substr(pos+1));; 169 kind.resize(pos);; 170 }; 171 ; 172 pos = kind.find(""size:"");; 173 if (pos != std::string::npos) {; 174 auto epos = kind.find_first_of("" ;"", pos+5);; 175 if (epos == std::string::npos) epos = kind.length();; 176 SetSizeAsStr(kind.substr(pos+5, epos-pos-5));; 177 kind.erase(pos, epos-pos);; 178 }; 179 ; 180 pos = kind.find(""pos:"");; 181 if (pos != std::string::npos) {; 182 auto epos = kind.find_first_of("" ;"", pos+4);; 183 if (epos == std::string::npos) epos = kind.length();; 184 SetPosAsStr(kind.substr(pos+4, epos-pos-4));; 185 kind.erase(pos, epos-pos);; 186 }; 187 ; 188 pos = kind.rfind(""headless"");; 189 if ((pos != std::string::npos) && (pos == kind.length() - 8)) {; 190 SetHeadless(true);; 191 kind.resize(pos);; 192 if ((pos > 0) && (kind[pos-1] == ';')) kind.resize(pos-1);; 193 }; 194 ; 195 // very special handling of qt5/qt6 which can specify pointer as a string; 196 if ((kind.find(""qt5:"") == 0) || (kind.find(""qt6:"") == 0)) ",MatchSource.WIKI,doc/v632/RWebDisplayArgs_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/RWebDisplayArgs_8cxx_source.html
https://root.cern/doc/v632/RWebWindowsManager_8hxx_source.html:3744,Availability,avail,available,3744,"nsigned ShowWindow(RWebWindow &win, const RWebDisplayArgs &args);; 67 ; 68 int WaitFor(RWebWindow &win, WebWindowWaitFunc_t check, bool timed = false, double tm = -1);; 69 ; 70 std::string GetUrl(RWebWindow &win, bool remote = false, std::string *produced_key = nullptr);; 71 ; 72 bool CreateServer(bool with_http = false);; 73 ; 74 bool InformListener(const std::string &msg);; 75 ; 76 static std::string GenerateKey(int keylen = 32);; 77 ; 78public:; 79 RWebWindowsManager();; 80 ; 81 ~RWebWindowsManager();; 82 ; 83 /// Returns THttpServer instance; 84 THttpServer *GetServer() const { return fServer.get(); }; 85 ; 86 /// Returns http address of the server, empty string when not available; 87 std::string GetServerAddr() const { return fAddr; }; 88 ; 89 /// Assign show callback which can catch window showing, used by RBrowser; 90 void SetShowCallback(WebWindowShowCallback_t func) { fShowCallback = func; }; 91 ; 92 static std::shared_ptr<RWebWindowsManager> &Instance();; 93 ; 94 std::shared_ptr<RWebWindow> CreateWindow();; 95 ; 96 void Terminate();; 97 ; 98 static bool IsMainThrd();; 99 static void AssignMainThrd();; 100 ; 101 static void SetLoopbackMode(bool on = true);; 102 static bool IsLoopbackMode();; 103 ; 104 static void SetUseSessionKey(bool on = true);; 105 static void SetUseConnectionKey(bool on = true);; 106};; 107 ; 108} // namespace ROOT; 109 ; 110#endif; RWebWindow.hxx; onOption_t Option_t TPoint TPoint const char GetTextMagnitude GetFillStyle GetLineColor GetLineWidth GetMarkerStyle GetTextAlign GetTextColor GetTextSize void onDefinition TGWin32VirtualXProxy.cxx:106; winOption_t Option_t TPoint TPoint const char GetTextMagnitude GetFillStyle GetLineColor GetLineWidth GetMarkerStyle GetTextAlign GetTextColor GetTextSize void char Point_t Rectangle_t WindowAttributes_t Float_t Float_t Float_t Int_t Int_t UInt_t UInt_t Rectangle_t Int_t Int_t Window_t winDefinition TGWin32VirtualXProxy.cxx:186; THttpEngine.h; ROOT::RWebDisplayArgsHolds different arguments for ",MatchSource.WIKI,doc/v632/RWebWindowsManager_8hxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/RWebWindowsManager_8hxx_source.html
https://root.cern/doc/v632/RWebWindowsManager_8hxx_source.html:9820,Availability,avail,available,9820,"wsManager.hxx:84; ROOT::RWebWindowsManager::fSessionKeystd::string fSessionKey! secret session key used on client to code connections keysDefinition RWebWindowsManager.hxx:43; ROOT::RWebWindowsManager::fUseHttpThrdbool fUseHttpThrd! use special thread for THttpServerDefinition RWebWindowsManager.hxx:47; ROOT::RWebWindowsManager::AssignMainThrdstatic void AssignMainThrd()Re-assigns main thread id Normally main thread id recognized at the moment when library is loaded It ...Definition RWebWindowsManager.cxx:116; ROOT::RWebWindowsManager::SetUseSessionKeystatic void SetUseSessionKey(bool on=true)Enable or disable usage of session key (default on) If enabled, secrete session key used to calculate...Definition RWebWindowsManager.cxx:156; ROOT::RWebWindowsManager::IsUseHttpThreadbool IsUseHttpThread() constReturns true if http server use special thread for requests processing (default off)Definition RWebWindowsManager.hxx:55; ROOT::RWebWindowsManager::GetServerAddrstd::string GetServerAddr() constReturns http address of the server, empty string when not available.Definition RWebWindowsManager.hxx:87; ROOT::RWebWindowsManager::fUseSenderThreadsbool fUseSenderThreads! use extra threads for sending data from RWebWindow to clientsDefinition RWebWindowsManager.hxx:48; ROOT::RWebWindowsManager::fServerstd::unique_ptr< THttpServer > fServer! central communication with the all used displaysDefinition RWebWindowsManager.hxx:41; ROOT::RWebWindowsManager::SetLoopbackModestatic void SetLoopbackMode(bool on=true)Set loopback mode for THttpServer used for web widgets By default is on.Definition RWebWindowsManager.cxx:128; ROOT::RWebWindowsManager::IsMainThrdstatic bool IsMainThrd()Returns true when called from main process Main process recognized at the moment when library is load...Definition RWebWindowsManager.cxx:104; ROOT::RWebWindowsManager::Instancestatic std::shared_ptr< RWebWindowsManager > & Instance()Returns default window manager Used to display all standard ROOT elements li",MatchSource.WIKI,doc/v632/RWebWindowsManager_8hxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/RWebWindowsManager_8hxx_source.html
https://root.cern/doc/v632/RWebWindowsManager_8hxx_source.html:10949,Integrability,message,message,10949,"nderThreadsbool fUseSenderThreads! use extra threads for sending data from RWebWindow to clientsDefinition RWebWindowsManager.hxx:48; ROOT::RWebWindowsManager::fServerstd::unique_ptr< THttpServer > fServer! central communication with the all used displaysDefinition RWebWindowsManager.hxx:41; ROOT::RWebWindowsManager::SetLoopbackModestatic void SetLoopbackMode(bool on=true)Set loopback mode for THttpServer used for web widgets By default is on.Definition RWebWindowsManager.cxx:128; ROOT::RWebWindowsManager::IsMainThrdstatic bool IsMainThrd()Returns true when called from main process Main process recognized at the moment when library is load...Definition RWebWindowsManager.cxx:104; ROOT::RWebWindowsManager::Instancestatic std::shared_ptr< RWebWindowsManager > & Instance()Returns default window manager Used to display all standard ROOT elements like TCanvas or TFitPanel.Definition RWebWindowsManager.cxx:78; ROOT::RWebWindowsManager::InformListenerbool InformListener(const std::string &msg)If ROOT_LISTENER_SOCKET variable is configured, message will be sent to that unix socket.Definition RWebWindowsManager.cxx:227; ROOT::RWebWindowsManager::fLaunchTmoutfloat fLaunchTmout! timeout in seconds to start browser process, default 30sDefinition RWebWindowsManager.hxx:49; ROOT::RWebWindowsManager::GetUrlstd::string GetUrl(RWebWindow &win, bool remote=false, std::string *produced_key=nullptr)Provide URL address to access specified window from inside or from remote.Definition RWebWindowsManager.cxx:600; ROOT::RWebWindowsManager::Unregistervoid Unregister(RWebWindow &win)Release all references to specified window Called from RWebWindow destructor.Definition RWebWindowsManager.cxx:591; ROOT::RWebWindowsManager::IsLoopbackModestatic bool IsLoopbackMode()Returns true if loopback mode used by THttpServer for web widgets.Definition RWebWindowsManager.cxx:146; ROOT::RWebWindowsManager::CreateWindowstd::shared_ptr< RWebWindow > CreateWindow()Creates new window To show window, RWebWindow:",MatchSource.WIKI,doc/v632/RWebWindowsManager_8hxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/RWebWindowsManager_8hxx_source.html
https://root.cern/doc/v632/RWebWindowsManager_8hxx_source.html:6117,Modifiability,config,configure,6117,"rguments for starting browser with RWebDisplayHandle::Display() method.Definition RWebDisplayArgs.hxx:33; ROOT::RWebWindowRepresents web window, which can be shown in web browser or any other supported environment.Definition RWebWindow.hxx:52; ROOT::RWebWindowsManagerCentral instance to create and show web-based windows like Canvas or FitPanel.Definition RWebWindowsManager.hxx:36; ROOT::RWebWindowsManager::GenerateKeystatic std::string GenerateKey(int keylen=32)Static method to generate cryptographic key Parameter keylen defines length of cryptographic key in b...Definition RWebWindowsManager.cxx:178; ROOT::RWebWindowsManager::fUseSessionKeybool fUseSessionKey! is session key has to be used for data signingDefinition RWebWindowsManager.hxx:44; ROOT::RWebWindowsManager::fAssgnExecstd::unique_ptr< TExec > fAssgnExec! special exec to assign thread id via ProcessEventsDefinition RWebWindowsManager.hxx:51; ROOT::RWebWindowsManager::CreateServerbool CreateServer(bool with_http=false)Creates http server, if required - with real http engine (civetweb) One could configure concrete HTTP...Definition RWebWindowsManager.cxx:351; ROOT::RWebWindowsManager::GetLaunchTmoutfloat GetLaunchTmout() constReturns timeout for launching new browser process.Definition RWebWindowsManager.hxx:61; ROOT::RWebWindowsManager::SetUseConnectionKeystatic void SetUseConnectionKey(bool on=true)Enable or disable usage of connection key (default on) If enabled, each connection (and reconnection)...Definition RWebWindowsManager.cxx:167; ROOT::RWebWindowsManager::fExternalProcessEventsbool fExternalProcessEvents! indicate that there are external process events engineDefinition RWebWindowsManager.hxx:50; ROOT::RWebWindowsManager::fMutexstd::recursive_mutex fMutex! main mutex, used for window creationsDefinition RWebWindowsManager.hxx:45; ROOT::RWebWindowsManager::RWebWindowsManagerRWebWindowsManager()window manager constructor Required here for correct usage of unique_ptr<THttpServer>Definition RWebWindowsM",MatchSource.WIKI,doc/v632/RWebWindowsManager_8hxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/RWebWindowsManager_8hxx_source.html
https://root.cern/doc/v632/RWebWindowsManager_8hxx_source.html:10925,Modifiability,variab,variable,10925,"nderThreadsbool fUseSenderThreads! use extra threads for sending data from RWebWindow to clientsDefinition RWebWindowsManager.hxx:48; ROOT::RWebWindowsManager::fServerstd::unique_ptr< THttpServer > fServer! central communication with the all used displaysDefinition RWebWindowsManager.hxx:41; ROOT::RWebWindowsManager::SetLoopbackModestatic void SetLoopbackMode(bool on=true)Set loopback mode for THttpServer used for web widgets By default is on.Definition RWebWindowsManager.cxx:128; ROOT::RWebWindowsManager::IsMainThrdstatic bool IsMainThrd()Returns true when called from main process Main process recognized at the moment when library is load...Definition RWebWindowsManager.cxx:104; ROOT::RWebWindowsManager::Instancestatic std::shared_ptr< RWebWindowsManager > & Instance()Returns default window manager Used to display all standard ROOT elements like TCanvas or TFitPanel.Definition RWebWindowsManager.cxx:78; ROOT::RWebWindowsManager::InformListenerbool InformListener(const std::string &msg)If ROOT_LISTENER_SOCKET variable is configured, message will be sent to that unix socket.Definition RWebWindowsManager.cxx:227; ROOT::RWebWindowsManager::fLaunchTmoutfloat fLaunchTmout! timeout in seconds to start browser process, default 30sDefinition RWebWindowsManager.hxx:49; ROOT::RWebWindowsManager::GetUrlstd::string GetUrl(RWebWindow &win, bool remote=false, std::string *produced_key=nullptr)Provide URL address to access specified window from inside or from remote.Definition RWebWindowsManager.cxx:600; ROOT::RWebWindowsManager::Unregistervoid Unregister(RWebWindow &win)Release all references to specified window Called from RWebWindow destructor.Definition RWebWindowsManager.cxx:591; ROOT::RWebWindowsManager::IsLoopbackModestatic bool IsLoopbackMode()Returns true if loopback mode used by THttpServer for web widgets.Definition RWebWindowsManager.cxx:146; ROOT::RWebWindowsManager::CreateWindowstd::shared_ptr< RWebWindow > CreateWindow()Creates new window To show window, RWebWindow:",MatchSource.WIKI,doc/v632/RWebWindowsManager_8hxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/RWebWindowsManager_8hxx_source.html
https://root.cern/doc/v632/RWebWindowsManager_8hxx_source.html:10937,Modifiability,config,configured,10937,"nderThreadsbool fUseSenderThreads! use extra threads for sending data from RWebWindow to clientsDefinition RWebWindowsManager.hxx:48; ROOT::RWebWindowsManager::fServerstd::unique_ptr< THttpServer > fServer! central communication with the all used displaysDefinition RWebWindowsManager.hxx:41; ROOT::RWebWindowsManager::SetLoopbackModestatic void SetLoopbackMode(bool on=true)Set loopback mode for THttpServer used for web widgets By default is on.Definition RWebWindowsManager.cxx:128; ROOT::RWebWindowsManager::IsMainThrdstatic bool IsMainThrd()Returns true when called from main process Main process recognized at the moment when library is load...Definition RWebWindowsManager.cxx:104; ROOT::RWebWindowsManager::Instancestatic std::shared_ptr< RWebWindowsManager > & Instance()Returns default window manager Used to display all standard ROOT elements like TCanvas or TFitPanel.Definition RWebWindowsManager.cxx:78; ROOT::RWebWindowsManager::InformListenerbool InformListener(const std::string &msg)If ROOT_LISTENER_SOCKET variable is configured, message will be sent to that unix socket.Definition RWebWindowsManager.cxx:227; ROOT::RWebWindowsManager::fLaunchTmoutfloat fLaunchTmout! timeout in seconds to start browser process, default 30sDefinition RWebWindowsManager.hxx:49; ROOT::RWebWindowsManager::GetUrlstd::string GetUrl(RWebWindow &win, bool remote=false, std::string *produced_key=nullptr)Provide URL address to access specified window from inside or from remote.Definition RWebWindowsManager.cxx:600; ROOT::RWebWindowsManager::Unregistervoid Unregister(RWebWindow &win)Release all references to specified window Called from RWebWindow destructor.Definition RWebWindowsManager.cxx:591; ROOT::RWebWindowsManager::IsLoopbackModestatic bool IsLoopbackMode()Returns true if loopback mode used by THttpServer for web widgets.Definition RWebWindowsManager.cxx:146; ROOT::RWebWindowsManager::CreateWindowstd::shared_ptr< RWebWindow > CreateWindow()Creates new window To show window, RWebWindow:",MatchSource.WIKI,doc/v632/RWebWindowsManager_8hxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/RWebWindowsManager_8hxx_source.html
https://root.cern/doc/v632/RWebWindowsManager_8hxx_source.html:9220,Performance,load,loaded,9220,"e if extra threads to send data via websockets will be used (default off)Definition RWebWindowsManager.hxx:58; ROOT::RWebWindowsManager::SetShowCallbackvoid SetShowCallback(WebWindowShowCallback_t func)Assign show callback which can catch window showing, used by RBrowser.Definition RWebWindowsManager.hxx:90; ROOT::RWebWindowsManager::~RWebWindowsManager~RWebWindowsManager()window manager destructor Required here for correct usage of unique_ptr<THttpServer>Definition RWebWindowsManager.cxx:215; ROOT::RWebWindowsManager::GetServerTHttpServer * GetServer() constReturns THttpServer instance.Definition RWebWindowsManager.hxx:84; ROOT::RWebWindowsManager::fSessionKeystd::string fSessionKey! secret session key used on client to code connections keysDefinition RWebWindowsManager.hxx:43; ROOT::RWebWindowsManager::fUseHttpThrdbool fUseHttpThrd! use special thread for THttpServerDefinition RWebWindowsManager.hxx:47; ROOT::RWebWindowsManager::AssignMainThrdstatic void AssignMainThrd()Re-assigns main thread id Normally main thread id recognized at the moment when library is loaded It ...Definition RWebWindowsManager.cxx:116; ROOT::RWebWindowsManager::SetUseSessionKeystatic void SetUseSessionKey(bool on=true)Enable or disable usage of session key (default on) If enabled, secrete session key used to calculate...Definition RWebWindowsManager.cxx:156; ROOT::RWebWindowsManager::IsUseHttpThreadbool IsUseHttpThread() constReturns true if http server use special thread for requests processing (default off)Definition RWebWindowsManager.hxx:55; ROOT::RWebWindowsManager::GetServerAddrstd::string GetServerAddr() constReturns http address of the server, empty string when not available.Definition RWebWindowsManager.hxx:87; ROOT::RWebWindowsManager::fUseSenderThreadsbool fUseSenderThreads! use extra threads for sending data from RWebWindow to clientsDefinition RWebWindowsManager.hxx:48; ROOT::RWebWindowsManager::fServerstd::unique_ptr< THttpServer > fServer! central communication with the all ",MatchSource.WIKI,doc/v632/RWebWindowsManager_8hxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/RWebWindowsManager_8hxx_source.html
https://root.cern/doc/v632/RWebWindowsManager_8hxx_source.html:10543,Performance,load,load,10543,"finition RWebWindowsManager.cxx:156; ROOT::RWebWindowsManager::IsUseHttpThreadbool IsUseHttpThread() constReturns true if http server use special thread for requests processing (default off)Definition RWebWindowsManager.hxx:55; ROOT::RWebWindowsManager::GetServerAddrstd::string GetServerAddr() constReturns http address of the server, empty string when not available.Definition RWebWindowsManager.hxx:87; ROOT::RWebWindowsManager::fUseSenderThreadsbool fUseSenderThreads! use extra threads for sending data from RWebWindow to clientsDefinition RWebWindowsManager.hxx:48; ROOT::RWebWindowsManager::fServerstd::unique_ptr< THttpServer > fServer! central communication with the all used displaysDefinition RWebWindowsManager.hxx:41; ROOT::RWebWindowsManager::SetLoopbackModestatic void SetLoopbackMode(bool on=true)Set loopback mode for THttpServer used for web widgets By default is on.Definition RWebWindowsManager.cxx:128; ROOT::RWebWindowsManager::IsMainThrdstatic bool IsMainThrd()Returns true when called from main process Main process recognized at the moment when library is load...Definition RWebWindowsManager.cxx:104; ROOT::RWebWindowsManager::Instancestatic std::shared_ptr< RWebWindowsManager > & Instance()Returns default window manager Used to display all standard ROOT elements like TCanvas or TFitPanel.Definition RWebWindowsManager.cxx:78; ROOT::RWebWindowsManager::InformListenerbool InformListener(const std::string &msg)If ROOT_LISTENER_SOCKET variable is configured, message will be sent to that unix socket.Definition RWebWindowsManager.cxx:227; ROOT::RWebWindowsManager::fLaunchTmoutfloat fLaunchTmout! timeout in seconds to start browser process, default 30sDefinition RWebWindowsManager.hxx:49; ROOT::RWebWindowsManager::GetUrlstd::string GetUrl(RWebWindow &win, bool remote=false, std::string *produced_key=nullptr)Provide URL address to access specified window from inside or from remote.Definition RWebWindowsManager.cxx:600; ROOT::RWebWindowsManager::Unregistervoid Unregis",MatchSource.WIKI,doc/v632/RWebWindowsManager_8hxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/RWebWindowsManager_8hxx_source.html
https://root.cern/doc/v632/RWebWindowsManager_8hxx_source.html:2138,Safety,timeout,timeout,2138,"}; ///<! counter for identifiers; 47 bool fUseHttpThrd{false}; ///<! use special thread for THttpServer; 48 bool fUseSenderThreads{false}; ///<! use extra threads for sending data from RWebWindow to clients; 49 float fLaunchTmout{30.}; ///<! timeout in seconds to start browser process, default 30s; 50 bool fExternalProcessEvents{false}; ///<! indicate that there are external process events engine; 51 std::unique_ptr<TExec> fAssgnExec; ///<! special exec to assign thread id via ProcessEvents; 52 WebWindowShowCallback_t fShowCallback; ///<! function called for each RWebWindow::Show call; 53 ; 54 /// Returns true if http server use special thread for requests processing (default off); 55 bool IsUseHttpThread() const { return fUseHttpThrd; }; 56 ; 57 /// Returns true if extra threads to send data via websockets will be used (default off); 58 bool IsUseSenderThreads() const { return fUseSenderThreads; }; 59 ; 60 /// Returns timeout for launching new browser process; 61 float GetLaunchTmout() const { return fLaunchTmout; }; 62 ; 63 void Unregister(RWebWindow &win);; 64 ; 65 /// Show window in specified location, see Show() method for more details; 66 unsigned ShowWindow(RWebWindow &win, const RWebDisplayArgs &args);; 67 ; 68 int WaitFor(RWebWindow &win, WebWindowWaitFunc_t check, bool timed = false, double tm = -1);; 69 ; 70 std::string GetUrl(RWebWindow &win, bool remote = false, std::string *produced_key = nullptr);; 71 ; 72 bool CreateServer(bool with_http = false);; 73 ; 74 bool InformListener(const std::string &msg);; 75 ; 76 static std::string GenerateKey(int keylen = 32);; 77 ; 78public:; 79 RWebWindowsManager();; 80 ; 81 ~RWebWindowsManager();; 82 ; 83 /// Returns THttpServer instance; 84 THttpServer *GetServer() const { return fServer.get(); }; 85 ; 86 /// Returns http address of the server, empty string when not available; 87 std::string GetServerAddr() const { return fAddr; }; 88 ; 89 /// Assign show callback which can catch window showing, used by RBrowser; 90 ",MatchSource.WIKI,doc/v632/RWebWindowsManager_8hxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/RWebWindowsManager_8hxx_source.html
https://root.cern/doc/v632/RWebWindowsManager_8hxx_source.html:2829,Safety,timeout,timeout,2829,"}; ///<! counter for identifiers; 47 bool fUseHttpThrd{false}; ///<! use special thread for THttpServer; 48 bool fUseSenderThreads{false}; ///<! use extra threads for sending data from RWebWindow to clients; 49 float fLaunchTmout{30.}; ///<! timeout in seconds to start browser process, default 30s; 50 bool fExternalProcessEvents{false}; ///<! indicate that there are external process events engine; 51 std::unique_ptr<TExec> fAssgnExec; ///<! special exec to assign thread id via ProcessEvents; 52 WebWindowShowCallback_t fShowCallback; ///<! function called for each RWebWindow::Show call; 53 ; 54 /// Returns true if http server use special thread for requests processing (default off); 55 bool IsUseHttpThread() const { return fUseHttpThrd; }; 56 ; 57 /// Returns true if extra threads to send data via websockets will be used (default off); 58 bool IsUseSenderThreads() const { return fUseSenderThreads; }; 59 ; 60 /// Returns timeout for launching new browser process; 61 float GetLaunchTmout() const { return fLaunchTmout; }; 62 ; 63 void Unregister(RWebWindow &win);; 64 ; 65 /// Show window in specified location, see Show() method for more details; 66 unsigned ShowWindow(RWebWindow &win, const RWebDisplayArgs &args);; 67 ; 68 int WaitFor(RWebWindow &win, WebWindowWaitFunc_t check, bool timed = false, double tm = -1);; 69 ; 70 std::string GetUrl(RWebWindow &win, bool remote = false, std::string *produced_key = nullptr);; 71 ; 72 bool CreateServer(bool with_http = false);; 73 ; 74 bool InformListener(const std::string &msg);; 75 ; 76 static std::string GenerateKey(int keylen = 32);; 77 ; 78public:; 79 RWebWindowsManager();; 80 ; 81 ~RWebWindowsManager();; 82 ; 83 /// Returns THttpServer instance; 84 THttpServer *GetServer() const { return fServer.get(); }; 85 ; 86 /// Returns http address of the server, empty string when not available; 87 std::string GetServerAddr() const { return fAddr; }; 88 ; 89 /// Assign show callback which can catch window showing, used by RBrowser; 90 ",MatchSource.WIKI,doc/v632/RWebWindowsManager_8hxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/RWebWindowsManager_8hxx_source.html
https://root.cern/doc/v632/RWebWindowsManager_8hxx_source.html:6258,Safety,timeout,timeout,6258,"er supported environment.Definition RWebWindow.hxx:52; ROOT::RWebWindowsManagerCentral instance to create and show web-based windows like Canvas or FitPanel.Definition RWebWindowsManager.hxx:36; ROOT::RWebWindowsManager::GenerateKeystatic std::string GenerateKey(int keylen=32)Static method to generate cryptographic key Parameter keylen defines length of cryptographic key in b...Definition RWebWindowsManager.cxx:178; ROOT::RWebWindowsManager::fUseSessionKeybool fUseSessionKey! is session key has to be used for data signingDefinition RWebWindowsManager.hxx:44; ROOT::RWebWindowsManager::fAssgnExecstd::unique_ptr< TExec > fAssgnExec! special exec to assign thread id via ProcessEventsDefinition RWebWindowsManager.hxx:51; ROOT::RWebWindowsManager::CreateServerbool CreateServer(bool with_http=false)Creates http server, if required - with real http engine (civetweb) One could configure concrete HTTP...Definition RWebWindowsManager.cxx:351; ROOT::RWebWindowsManager::GetLaunchTmoutfloat GetLaunchTmout() constReturns timeout for launching new browser process.Definition RWebWindowsManager.hxx:61; ROOT::RWebWindowsManager::SetUseConnectionKeystatic void SetUseConnectionKey(bool on=true)Enable or disable usage of connection key (default on) If enabled, each connection (and reconnection)...Definition RWebWindowsManager.cxx:167; ROOT::RWebWindowsManager::fExternalProcessEventsbool fExternalProcessEvents! indicate that there are external process events engineDefinition RWebWindowsManager.hxx:50; ROOT::RWebWindowsManager::fMutexstd::recursive_mutex fMutex! main mutex, used for window creationsDefinition RWebWindowsManager.hxx:45; ROOT::RWebWindowsManager::RWebWindowsManagerRWebWindowsManager()window manager constructor Required here for correct usage of unique_ptr<THttpServer>Definition RWebWindowsManager.cxx:201; ROOT::RWebWindowsManager::WaitForint WaitFor(RWebWindow &win, WebWindowWaitFunc_t check, bool timed=false, double tm=-1)Waits until provided check function or lambdas return",MatchSource.WIKI,doc/v632/RWebWindowsManager_8hxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/RWebWindowsManager_8hxx_source.html
https://root.cern/doc/v632/RWebWindowsManager_8hxx_source.html:11087,Safety,timeout,timeout,11087,"> fServer! central communication with the all used displaysDefinition RWebWindowsManager.hxx:41; ROOT::RWebWindowsManager::SetLoopbackModestatic void SetLoopbackMode(bool on=true)Set loopback mode for THttpServer used for web widgets By default is on.Definition RWebWindowsManager.cxx:128; ROOT::RWebWindowsManager::IsMainThrdstatic bool IsMainThrd()Returns true when called from main process Main process recognized at the moment when library is load...Definition RWebWindowsManager.cxx:104; ROOT::RWebWindowsManager::Instancestatic std::shared_ptr< RWebWindowsManager > & Instance()Returns default window manager Used to display all standard ROOT elements like TCanvas or TFitPanel.Definition RWebWindowsManager.cxx:78; ROOT::RWebWindowsManager::InformListenerbool InformListener(const std::string &msg)If ROOT_LISTENER_SOCKET variable is configured, message will be sent to that unix socket.Definition RWebWindowsManager.cxx:227; ROOT::RWebWindowsManager::fLaunchTmoutfloat fLaunchTmout! timeout in seconds to start browser process, default 30sDefinition RWebWindowsManager.hxx:49; ROOT::RWebWindowsManager::GetUrlstd::string GetUrl(RWebWindow &win, bool remote=false, std::string *produced_key=nullptr)Provide URL address to access specified window from inside or from remote.Definition RWebWindowsManager.cxx:600; ROOT::RWebWindowsManager::Unregistervoid Unregister(RWebWindow &win)Release all references to specified window Called from RWebWindow destructor.Definition RWebWindowsManager.cxx:591; ROOT::RWebWindowsManager::IsLoopbackModestatic bool IsLoopbackMode()Returns true if loopback mode used by THttpServer for web widgets.Definition RWebWindowsManager.cxx:146; ROOT::RWebWindowsManager::CreateWindowstd::shared_ptr< RWebWindow > CreateWindow()Creates new window To show window, RWebWindow::Show() have to be called.Definition RWebWindowsManager.cxx:536; TExecTExec is a utility class that can be used to execute a C++ command when some event happens in a pad.Definition TExec.h:26; THtt",MatchSource.WIKI,doc/v632/RWebWindowsManager_8hxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/RWebWindowsManager_8hxx_source.html
https://root.cern/doc/v632/RWebWindowsManager_8hxx_source.html:11325,Security,access,access,11325,")Set loopback mode for THttpServer used for web widgets By default is on.Definition RWebWindowsManager.cxx:128; ROOT::RWebWindowsManager::IsMainThrdstatic bool IsMainThrd()Returns true when called from main process Main process recognized at the moment when library is load...Definition RWebWindowsManager.cxx:104; ROOT::RWebWindowsManager::Instancestatic std::shared_ptr< RWebWindowsManager > & Instance()Returns default window manager Used to display all standard ROOT elements like TCanvas or TFitPanel.Definition RWebWindowsManager.cxx:78; ROOT::RWebWindowsManager::InformListenerbool InformListener(const std::string &msg)If ROOT_LISTENER_SOCKET variable is configured, message will be sent to that unix socket.Definition RWebWindowsManager.cxx:227; ROOT::RWebWindowsManager::fLaunchTmoutfloat fLaunchTmout! timeout in seconds to start browser process, default 30sDefinition RWebWindowsManager.hxx:49; ROOT::RWebWindowsManager::GetUrlstd::string GetUrl(RWebWindow &win, bool remote=false, std::string *produced_key=nullptr)Provide URL address to access specified window from inside or from remote.Definition RWebWindowsManager.cxx:600; ROOT::RWebWindowsManager::Unregistervoid Unregister(RWebWindow &win)Release all references to specified window Called from RWebWindow destructor.Definition RWebWindowsManager.cxx:591; ROOT::RWebWindowsManager::IsLoopbackModestatic bool IsLoopbackMode()Returns true if loopback mode used by THttpServer for web widgets.Definition RWebWindowsManager.cxx:146; ROOT::RWebWindowsManager::CreateWindowstd::shared_ptr< RWebWindow > CreateWindow()Creates new window To show window, RWebWindow::Show() have to be called.Definition RWebWindowsManager.cxx:536; TExecTExec is a utility class that can be used to execute a C++ command when some event happens in a pad.Definition TExec.h:26; THttpServerOnline http server for arbitrary ROOT application.Definition THttpServer.h:31; THttpWSHandlerClass for user-side handling of websocket with THttpServer.Definition THttpWSH",MatchSource.WIKI,doc/v632/RWebWindowsManager_8hxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/RWebWindowsManager_8hxx_source.html
https://root.cern/doc/v632/RWebWindow_8hxx_source.html:8646,Integrability,protocol,protocol,8646,"ect event; 160 std::thread::id fCallbacksThrdId; ///<! thread id where callbacks should be invoked; 161 bool fCallbacksThrdIdSet{false}; ///<! flag indicating that thread id is assigned; 162 bool fHasWindowThrd{false}; ///<! indicate if special window thread was started; 163 std::thread fWindowThrd; ///<! special thread for that window; 164 std::queue<QueueEntry> fInputQueue; ///<! input queue for all callbacks; 165 std::mutex fInputQueueMutex; ///<! mutex to protect input queue; 166 unsigned fWidth{0}, fHeight{0}; ///<! initial window width and height when displayed, zeros are ignored; 167 int fX{-1}, fY{-1}; ///<! initial window position, -1 ignored; 168 float fOperationTmout{50.}; ///<! timeout in seconds to perform synchronous operation, default 50s; 169 std::string fClientVersion; ///<! configured client version, used as prefix in scripts URL; 170 std::string fProtocolFileName; ///<! local file where communication protocol will be written; 171 int fProtocolCnt{-1}; ///<! counter for protocol recording; 172 unsigned fProtocolConnId{0}; ///<! connection id, which is used for writing protocol; 173 std::string fProtocolPrefix; ///<! prefix for created files names; 174 std::string fProtocol; ///<! protocol; 175 std::string fUserArgs; ///<! arbitrary JSON code, which is accessible via conn.getUserArgs() method; 176 std::shared_ptr<void> fClearOnClose; ///<! entry which is cleared when last connection is closed; 177 ; 178 std::shared_ptr<RWebWindowWSHandler> CreateWSHandler(std::shared_ptr<RWebWindowsManager> mgr, unsigned id, double tmout);; 179 ; 180 bool ProcessWS(THttpCallArg &arg);; 181 ; 182 void CompleteWSSend(unsigned wsid);; 183 ; 184 ConnectionsList_t GetWindowConnections(unsigned connid = 0, bool only_active = false) const;; 185 ; 186 /// Find connection with specified websocket id; 187 std::shared_ptr<WebConn> FindConnection(unsigned wsid);; 188 ; 189 std::shared_ptr<WebConn> RemoveConnection(unsigned wsid);; 190 ; 191 bool _CanTrustIn(std::shared_ptr<WebC",MatchSource.WIKI,doc/v632/RWebWindow_8hxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/RWebWindow_8hxx_source.html
https://root.cern/doc/v632/RWebWindow_8hxx_source.html:8716,Integrability,protocol,protocol,8716,"ect event; 160 std::thread::id fCallbacksThrdId; ///<! thread id where callbacks should be invoked; 161 bool fCallbacksThrdIdSet{false}; ///<! flag indicating that thread id is assigned; 162 bool fHasWindowThrd{false}; ///<! indicate if special window thread was started; 163 std::thread fWindowThrd; ///<! special thread for that window; 164 std::queue<QueueEntry> fInputQueue; ///<! input queue for all callbacks; 165 std::mutex fInputQueueMutex; ///<! mutex to protect input queue; 166 unsigned fWidth{0}, fHeight{0}; ///<! initial window width and height when displayed, zeros are ignored; 167 int fX{-1}, fY{-1}; ///<! initial window position, -1 ignored; 168 float fOperationTmout{50.}; ///<! timeout in seconds to perform synchronous operation, default 50s; 169 std::string fClientVersion; ///<! configured client version, used as prefix in scripts URL; 170 std::string fProtocolFileName; ///<! local file where communication protocol will be written; 171 int fProtocolCnt{-1}; ///<! counter for protocol recording; 172 unsigned fProtocolConnId{0}; ///<! connection id, which is used for writing protocol; 173 std::string fProtocolPrefix; ///<! prefix for created files names; 174 std::string fProtocol; ///<! protocol; 175 std::string fUserArgs; ///<! arbitrary JSON code, which is accessible via conn.getUserArgs() method; 176 std::shared_ptr<void> fClearOnClose; ///<! entry which is cleared when last connection is closed; 177 ; 178 std::shared_ptr<RWebWindowWSHandler> CreateWSHandler(std::shared_ptr<RWebWindowsManager> mgr, unsigned id, double tmout);; 179 ; 180 bool ProcessWS(THttpCallArg &arg);; 181 ; 182 void CompleteWSSend(unsigned wsid);; 183 ; 184 ConnectionsList_t GetWindowConnections(unsigned connid = 0, bool only_active = false) const;; 185 ; 186 /// Find connection with specified websocket id; 187 std::shared_ptr<WebConn> FindConnection(unsigned wsid);; 188 ; 189 std::shared_ptr<WebConn> RemoveConnection(unsigned wsid);; 190 ; 191 bool _CanTrustIn(std::shared_ptr<WebC",MatchSource.WIKI,doc/v632/RWebWindow_8hxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/RWebWindow_8hxx_source.html
https://root.cern/doc/v632/RWebWindow_8hxx_source.html:8816,Integrability,protocol,protocol,8816,"ect event; 160 std::thread::id fCallbacksThrdId; ///<! thread id where callbacks should be invoked; 161 bool fCallbacksThrdIdSet{false}; ///<! flag indicating that thread id is assigned; 162 bool fHasWindowThrd{false}; ///<! indicate if special window thread was started; 163 std::thread fWindowThrd; ///<! special thread for that window; 164 std::queue<QueueEntry> fInputQueue; ///<! input queue for all callbacks; 165 std::mutex fInputQueueMutex; ///<! mutex to protect input queue; 166 unsigned fWidth{0}, fHeight{0}; ///<! initial window width and height when displayed, zeros are ignored; 167 int fX{-1}, fY{-1}; ///<! initial window position, -1 ignored; 168 float fOperationTmout{50.}; ///<! timeout in seconds to perform synchronous operation, default 50s; 169 std::string fClientVersion; ///<! configured client version, used as prefix in scripts URL; 170 std::string fProtocolFileName; ///<! local file where communication protocol will be written; 171 int fProtocolCnt{-1}; ///<! counter for protocol recording; 172 unsigned fProtocolConnId{0}; ///<! connection id, which is used for writing protocol; 173 std::string fProtocolPrefix; ///<! prefix for created files names; 174 std::string fProtocol; ///<! protocol; 175 std::string fUserArgs; ///<! arbitrary JSON code, which is accessible via conn.getUserArgs() method; 176 std::shared_ptr<void> fClearOnClose; ///<! entry which is cleared when last connection is closed; 177 ; 178 std::shared_ptr<RWebWindowWSHandler> CreateWSHandler(std::shared_ptr<RWebWindowsManager> mgr, unsigned id, double tmout);; 179 ; 180 bool ProcessWS(THttpCallArg &arg);; 181 ; 182 void CompleteWSSend(unsigned wsid);; 183 ; 184 ConnectionsList_t GetWindowConnections(unsigned connid = 0, bool only_active = false) const;; 185 ; 186 /// Find connection with specified websocket id; 187 std::shared_ptr<WebConn> FindConnection(unsigned wsid);; 188 ; 189 std::shared_ptr<WebConn> RemoveConnection(unsigned wsid);; 190 ; 191 bool _CanTrustIn(std::shared_ptr<WebC",MatchSource.WIKI,doc/v632/RWebWindow_8hxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/RWebWindow_8hxx_source.html
https://root.cern/doc/v632/RWebWindow_8hxx_source.html:8930,Integrability,protocol,protocol,8930,"ect event; 160 std::thread::id fCallbacksThrdId; ///<! thread id where callbacks should be invoked; 161 bool fCallbacksThrdIdSet{false}; ///<! flag indicating that thread id is assigned; 162 bool fHasWindowThrd{false}; ///<! indicate if special window thread was started; 163 std::thread fWindowThrd; ///<! special thread for that window; 164 std::queue<QueueEntry> fInputQueue; ///<! input queue for all callbacks; 165 std::mutex fInputQueueMutex; ///<! mutex to protect input queue; 166 unsigned fWidth{0}, fHeight{0}; ///<! initial window width and height when displayed, zeros are ignored; 167 int fX{-1}, fY{-1}; ///<! initial window position, -1 ignored; 168 float fOperationTmout{50.}; ///<! timeout in seconds to perform synchronous operation, default 50s; 169 std::string fClientVersion; ///<! configured client version, used as prefix in scripts URL; 170 std::string fProtocolFileName; ///<! local file where communication protocol will be written; 171 int fProtocolCnt{-1}; ///<! counter for protocol recording; 172 unsigned fProtocolConnId{0}; ///<! connection id, which is used for writing protocol; 173 std::string fProtocolPrefix; ///<! prefix for created files names; 174 std::string fProtocol; ///<! protocol; 175 std::string fUserArgs; ///<! arbitrary JSON code, which is accessible via conn.getUserArgs() method; 176 std::shared_ptr<void> fClearOnClose; ///<! entry which is cleared when last connection is closed; 177 ; 178 std::shared_ptr<RWebWindowWSHandler> CreateWSHandler(std::shared_ptr<RWebWindowsManager> mgr, unsigned id, double tmout);; 179 ; 180 bool ProcessWS(THttpCallArg &arg);; 181 ; 182 void CompleteWSSend(unsigned wsid);; 183 ; 184 ConnectionsList_t GetWindowConnections(unsigned connid = 0, bool only_active = false) const;; 185 ; 186 /// Find connection with specified websocket id; 187 std::shared_ptr<WebConn> FindConnection(unsigned wsid);; 188 ; 189 std::shared_ptr<WebConn> RemoveConnection(unsigned wsid);; 190 ; 191 bool _CanTrustIn(std::shared_ptr<WebC",MatchSource.WIKI,doc/v632/RWebWindow_8hxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/RWebWindow_8hxx_source.html
https://root.cern/doc/v632/RWebWindow_8hxx_source.html:17218,Integrability,protocol,protocol,17218,"t num = 0) const;; 341 ; 342 std::vector<unsigned> GetConnections(unsigned excludeid = 0) const;; 343 ; 344 bool HasConnection(unsigned connid = 0, bool only_active = true) const;; 345 ; 346 void CloseConnections();; 347 ; 348 void CloseConnection(unsigned connid);; 349 ; 350 /// Returns timeout for synchronous WebWindow operations; 351 float GetOperationTmout() const { return fOperationTmout; }; 352 ; 353 /// Set timeout for synchronous WebWindow operations; 354 void SetOperationTmout(float tm = 50.) { fOperationTmout = tm; }; 355 ; 356 std::string GetUrl(bool remote = true);; 357 ; 358 THttpServer *GetServer();; 359 ; 360 void Sync();; 361 ; 362 void Run(double tm = 0.);; 363 ; 364 unsigned Show(const RWebDisplayArgs &args = """");; 365 ; 366 unsigned GetDisplayConnection() const;; 367 ; 368 /// Returns true when window was shown at least once; 369 bool IsShown() const { return GetDisplayConnection() != 0; }; 370 ; 371 bool CanSend(unsigned connid, bool direct = true) const;; 372 ; 373 int GetSendQueueLength(unsigned connid) const;; 374 ; 375 void Send(unsigned connid, const std::string &data);; 376 ; 377 void SendBinary(unsigned connid, const void *data, std::size_t len);; 378 ; 379 void SendBinary(unsigned connid, std::string &&data);; 380 ; 381 void RecordData(const std::string &fname = ""protocol.json"", const std::string &fprefix = """");; 382 ; 383 std::string GetAddr() const;; 384 ; 385 std::string GetRelativeAddr(const std::shared_ptr<RWebWindow> &win) const;; 386 ; 387 std::string GetRelativeAddr(const RWebWindow &win) const;; 388 ; 389 void SetCallBacks(WebWindowConnectCallback_t conn, WebWindowDataCallback_t data, WebWindowConnectCallback_t disconn = nullptr);; 390 ; 391 void SetConnectCallBack(WebWindowConnectCallback_t func);; 392 ; 393 void SetDataCallBack(WebWindowDataCallback_t func);; 394 ; 395 void SetDisconnectCallBack(WebWindowConnectCallback_t func);; 396 ; 397 void SetClearOnClose(const std::shared_ptr<void> &handle = nullptr);; 398 ; 399 void Assi",MatchSource.WIKI,doc/v632/RWebWindow_8hxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/RWebWindow_8hxx_source.html
https://root.cern/doc/v632/RWebWindow_8hxx_source.html:21055,Integrability,wrap,wrapper,21055,"tyle GetTextAlign GetTextColor GetTextSize void char Point_t Rectangle_t WindowAttributes_t Float_t Float_t Float_t Int_t Int_t UInt_t UInt_t Rectangle_t Int_t Int_t Window_t winDefinition TGWin32VirtualXProxy.cxx:186; widthOption_t Option_t widthDefinition TGWin32VirtualXProxy.cxx:56; heightOption_t Option_t TPoint TPoint const char GetTextMagnitude GetFillStyle GetLineColor GetLineWidth GetMarkerStyle GetTextAlign GetTextColor GetTextSize void char Point_t Rectangle_t heightDefinition TGWin32VirtualXProxy.cxx:164; namechar name[80]Definition TGX11.cxx:110; ROOT::RFileDialogWeb-based FileDialog.Definition RFileDialog.hxx:41; ROOT::RWebDisplayArgsHolds different arguments for starting browser with RWebDisplayHandle::Display() method.Definition RWebDisplayArgs.hxx:33; ROOT::RWebDisplayHandleHandle of created web-based display Depending from type of web display, holds handle of started brows...Definition RWebDisplayHandle.hxx:25; ROOT::RWebWindowWSHandlerjust wrapper to deliver websockets call-backs to the RWebWindow classDefinition RWebWindowWSHandler.hxx:30; ROOT::RWebWindowRepresents web window, which can be shown in web browser or any other supported environment.Definition RWebWindow.hxx:52; ROOT::RWebWindow::CheckDataToSendbool CheckDataToSend(std::shared_ptr< WebConn > &conn)Checks if one should send data for specified connection Returns true when send operation was performe...Definition RWebWindow.cxx:1158; ROOT::RWebWindow::fDefaultPagestd::string fDefaultPage! HTML page (or file name) returned when window URL is openedDefinition RWebWindow.hxx:139; ROOT::RWebWindow::WaitForint WaitFor(WebWindowWaitFunc_t check)Waits until provided check function or lambdas returns non-zero value Check function has following si...Definition RWebWindow.cxx:1789; ROOT::RWebWindow::GetIdunsigned GetId() constReturns ID for the window - unique inside window manager.Definition RWebWindow.hxx:248; ROOT::RWebWindow::GetMasterConnectionsstd::vector< MasterConn > GetMasterConnections(un",MatchSource.WIKI,doc/v632/RWebWindow_8hxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/RWebWindow_8hxx_source.html
https://root.cern/doc/v632/RWebWindow_8hxx_source.html:23853,Integrability,protocol,protocolDefinition,23853,"er time For instance, batch browser will be ...Definition RWebWindow.cxx:658; ROOT::RWebWindow::fIdunsigned fId! unique identifierDefinition RWebWindow.hxx:141; ROOT::RWebWindow::fHasWindowThrdbool fHasWindowThrd! indicate if special window thread was startedDefinition RWebWindow.hxx:162; ROOT::RWebWindow::fMasterConnsstd::vector< MasterConn > fMasterConns! master connectionsDefinition RWebWindow.hxx:138; ROOT::RWebWindow::SetClearOnClosevoid SetClearOnClose(const std::shared_ptr< void > &handle=nullptr)Set handle which is cleared when last active connection is closed Typically can be used to destroy we...Definition RWebWindow.cxx:1764; ROOT::RWebWindow::StartThreadvoid StartThread()Start special thread which will be used by the window to handle all callbacks One has to be sure,...Definition RWebWindow.cxx:1680; ROOT::RWebWindow::fConnCntunsigned fConnCnt! counter of new connections to assign idsDefinition RWebWindow.hxx:148; ROOT::RWebWindow::fProtocolConnIdunsigned fProtocolConnId! connection id, which is used for writing protocolDefinition RWebWindow.hxx:172; ROOT::RWebWindow::GetWindowConnectionsConnectionsList_t GetWindowConnections(unsigned connid=0, bool only_active=false) constreturns connection list (or all active connections)Definition RWebWindow.cxx:1458; ROOT::RWebWindow::fSendMTbool fSendMT! true is special threads should be used for sending dataDefinition RWebWindow.hxx:145; ROOT::RWebWindow::fCallbacksThrdIdstd::thread::id fCallbacksThrdId! thread id where callbacks should be invokedDefinition RWebWindow.hxx:160; ROOT::RWebWindow::RemoveKeyvoid RemoveKey(const std::string &key)Removes all connections with the key.Definition RWebWindow.cxx:583; ROOT::RWebWindow::fInputQueuestd::queue< QueueEntry > fInputQueue! input queue for all callbacksDefinition RWebWindow.hxx:164; ROOT::RWebWindow::_CanTrustInbool _CanTrustIn(std::shared_ptr< WebConn > &conn, const std::string &key, const std::string &ntry, bool remote, bool test_first_time)Check if provided hash, ",MatchSource.WIKI,doc/v632/RWebWindow_8hxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/RWebWindow_8hxx_source.html
https://root.cern/doc/v632/RWebWindow_8hxx_source.html:33179,Integrability,message,message,33179,"h should be provided for connecting windowDefinition RWebWindow.hxx:153; ROOT::RWebWindow::GetHeightunsigned GetHeight() constreturns configured window height (0 - default)Definition RWebWindow.hxx:282; ROOT::RWebWindow::ShowWindowstatic unsigned ShowWindow(std::shared_ptr< RWebWindow > window, const RWebDisplayArgs &args="""")Static method to show web window Has to be used instead of RWebWindow::Show() when window potentially...Definition RWebWindow.cxx:1915; ROOT::RWebWindow::fWSHandlerstd::shared_ptr< RWebWindowWSHandler > fWSHandler! specialize websocket handler for all incoming connectionsDefinition RWebWindow.hxx:147; ROOT::RWebWindow::StopThreadvoid StopThread()Stop special thread.Definition RWebWindow.cxx:1702; ROOT::RWebWindow::SubmitDatavoid SubmitData(unsigned connid, bool txt, std::string &&data, int chid=1)Internal method to send data.Definition RWebWindow.cxx:1529; ROOT::RWebWindow::HMACstatic std::string HMAC(const std::string &key, const std::string &sessionKey, const char *msg, int msglen)Calculate HMAC checksum for provided key and message Key combained from connection key and session ke...Definition RWebWindow.cxx:1992; ROOT::RWebWindow::~RWebWindow~RWebWindow()RWebWindow destructor Closes all connections and remove window from manager.Definition RWebWindow.cxx:85; ROOT::RWebWindow::EmbedFileDialogstatic bool EmbedFileDialog(const std::shared_ptr< RWebWindow > &window, unsigned connid, const std::string &args)Create dialog instance to use as embedded dialog inside provided widget Loads libROOTBrowserv7 and tr...Definition RWebWindow.cxx:1977; ROOT::RWebWindow::CloseConnectionvoid CloseConnection(unsigned connid)Close specified connection.Definition RWebWindow.cxx:1447; ROOT::RWebWindow::fPendingConnConnectionsList_t fPendingConn! list of pending connection with pre-assigned keysDefinition RWebWindow.hxx:149; ROOT::RWebWindow::GetConnectionIdunsigned GetConnectionId(int num=0) constReturns connection id for specified connection sequence number Only ac",MatchSource.WIKI,doc/v632/RWebWindow_8hxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/RWebWindow_8hxx_source.html
https://root.cern/doc/v632/RWebWindow_8hxx_source.html:36317,Integrability,protocol,protocolDefinition,36317,"ptr<RWebWindowWSHandler>Definition RWebWindow.cxx:76; ROOT::RWebWindow::SetNativeOnlyConnvoid SetNativeOnlyConn(bool on=true)configures that only native (own-created) connections are allowedDefinition RWebWindow.hxx:308; ROOT::RWebWindow::fProtocolPrefixstd::string fProtocolPrefix! prefix for created files namesDefinition RWebWindow.hxx:173; ROOT::RWebWindow::GetSendQueueLengthint GetSendQueueLength(unsigned connid) constReturns send queue length for specified connection.Definition RWebWindow.cxx:1509; ROOT::RWebWindow::RemoveConnectionstd::shared_ptr< WebConn > RemoveConnection(unsigned wsid)Remove connection with given websocket id.Definition RWebWindow.cxx:279; ROOT::RWebWindow::CreateWSHandlerstd::shared_ptr< RWebWindowWSHandler > CreateWSHandler(std::shared_ptr< RWebWindowsManager > mgr, unsigned id, double tmout)Assigns manager reference, window id and creates websocket handler, used for communication with the c...Definition RWebWindow.cxx:152; ROOT::RWebWindow::fProtocolstd::string fProtocol! protocolDefinition RWebWindow.hxx:174; ROOT::RWebWindow::CanSendbool CanSend(unsigned connid, bool direct=true) constReturns true if sending via specified connection can be performed.Definition RWebWindow.cxx:1484; ROOT::RWebWindow::GetUserArgsstd::string GetUserArgs() constReturns configured user arguments for web window See SetUserArgs method for more details.Definition RWebWindow.cxx:1320; ROOT::RWebWindow::RecordDatavoid RecordData(const std::string &fname=""protocol.json"", const std::string &fprefix="""")Configures recording of communication data in protocol file Provided filename will be used to store J...Definition RWebWindow.cxx:1355; ROOT::RWebWindow::fUseProcessEventsbool fUseProcessEvents! all window functionality will run through process eventsDefinition RWebWindow.hxx:143; ROOT::RWebWindow::GetDisplayConnectionunsigned GetDisplayConnection() constReturns first connection id where window is displayed It could be that connection(s) not yet fully es...Definition RW",MatchSource.WIKI,doc/v632/RWebWindow_8hxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/RWebWindow_8hxx_source.html
https://root.cern/doc/v632/RWebWindow_8hxx_source.html:36783,Integrability,protocol,protocol,36783,"ength for specified connection.Definition RWebWindow.cxx:1509; ROOT::RWebWindow::RemoveConnectionstd::shared_ptr< WebConn > RemoveConnection(unsigned wsid)Remove connection with given websocket id.Definition RWebWindow.cxx:279; ROOT::RWebWindow::CreateWSHandlerstd::shared_ptr< RWebWindowWSHandler > CreateWSHandler(std::shared_ptr< RWebWindowsManager > mgr, unsigned id, double tmout)Assigns manager reference, window id and creates websocket handler, used for communication with the c...Definition RWebWindow.cxx:152; ROOT::RWebWindow::fProtocolstd::string fProtocol! protocolDefinition RWebWindow.hxx:174; ROOT::RWebWindow::CanSendbool CanSend(unsigned connid, bool direct=true) constReturns true if sending via specified connection can be performed.Definition RWebWindow.cxx:1484; ROOT::RWebWindow::GetUserArgsstd::string GetUserArgs() constReturns configured user arguments for web window See SetUserArgs method for more details.Definition RWebWindow.cxx:1320; ROOT::RWebWindow::RecordDatavoid RecordData(const std::string &fname=""protocol.json"", const std::string &fprefix="""")Configures recording of communication data in protocol file Provided filename will be used to store J...Definition RWebWindow.cxx:1355; ROOT::RWebWindow::fUseProcessEventsbool fUseProcessEvents! all window functionality will run through process eventsDefinition RWebWindow.hxx:143; ROOT::RWebWindow::GetDisplayConnectionunsigned GetDisplayConnection() constReturns first connection id where window is displayed It could be that connection(s) not yet fully es...Definition RWebWindow.cxx:244; ROOT::RWebWindow::fMaxQueueLengthunsigned fMaxQueueLength! maximal number of queue entriesDefinition RWebWindow.hxx:156; ROOT::RWebWindow::fXint fXDefinition RWebWindow.hxx:167; ROOT::RWebWindow::GetConnLimitunsigned GetConnLimit() constreturns configured connections limit (0 - default)Definition RWebWindow.cxx:703; ROOT::RWebWindow::GetRelativeAddrstd::string GetRelativeAddr(const std::shared_ptr< RWebWindow > &win) constR",MatchSource.WIKI,doc/v632/RWebWindow_8hxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/RWebWindow_8hxx_source.html
https://root.cern/doc/v632/RWebWindow_8hxx_source.html:36875,Integrability,protocol,protocol,36875,"WebConn > RemoveConnection(unsigned wsid)Remove connection with given websocket id.Definition RWebWindow.cxx:279; ROOT::RWebWindow::CreateWSHandlerstd::shared_ptr< RWebWindowWSHandler > CreateWSHandler(std::shared_ptr< RWebWindowsManager > mgr, unsigned id, double tmout)Assigns manager reference, window id and creates websocket handler, used for communication with the c...Definition RWebWindow.cxx:152; ROOT::RWebWindow::fProtocolstd::string fProtocol! protocolDefinition RWebWindow.hxx:174; ROOT::RWebWindow::CanSendbool CanSend(unsigned connid, bool direct=true) constReturns true if sending via specified connection can be performed.Definition RWebWindow.cxx:1484; ROOT::RWebWindow::GetUserArgsstd::string GetUserArgs() constReturns configured user arguments for web window See SetUserArgs method for more details.Definition RWebWindow.cxx:1320; ROOT::RWebWindow::RecordDatavoid RecordData(const std::string &fname=""protocol.json"", const std::string &fprefix="""")Configures recording of communication data in protocol file Provided filename will be used to store J...Definition RWebWindow.cxx:1355; ROOT::RWebWindow::fUseProcessEventsbool fUseProcessEvents! all window functionality will run through process eventsDefinition RWebWindow.hxx:143; ROOT::RWebWindow::GetDisplayConnectionunsigned GetDisplayConnection() constReturns first connection id where window is displayed It could be that connection(s) not yet fully es...Definition RWebWindow.cxx:244; ROOT::RWebWindow::fMaxQueueLengthunsigned fMaxQueueLength! maximal number of queue entriesDefinition RWebWindow.hxx:156; ROOT::RWebWindow::fXint fXDefinition RWebWindow.hxx:167; ROOT::RWebWindow::GetConnLimitunsigned GetConnLimit() constreturns configured connections limit (0 - default)Definition RWebWindow.cxx:703; ROOT::RWebWindow::GetRelativeAddrstd::string GetRelativeAddr(const std::shared_ptr< RWebWindow > &win) constReturns relative URL address for the specified window Address can be required if one needs to access ...Definition ",MatchSource.WIKI,doc/v632/RWebWindow_8hxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/RWebWindow_8hxx_source.html
https://root.cern/doc/v632/RWebWindow_8hxx_source.html:38913,Integrability,protocol,protocol,38913,"ROOT::RWebWindow::SetStartDialogFuncstatic void SetStartDialogFunc(std::function< bool(const std::shared_ptr< RWebWindow > &, unsigned, const std::string &)>)Configure func which has to be used for starting dialog.Definition RWebWindow.cxx:1953; ROOT::RWebWindow::fPanelNamestd::string fPanelName! panel name which should be shown in the windowDefinition RWebWindow.hxx:140; ROOT::RWebWindow::Runvoid Run(double tm=0.)Run window functionality for specified time If no action can be performed - just sleep specified time...Definition RWebWindow.cxx:1827; ROOT::RWebWindow::fHeightunsigned fHeight! initial window width and height when displayed, zeros are ignoredDefinition RWebWindow.hxx:166; ROOT::RWebWindow::GetAddrstd::string GetAddr() constReturns window address which is used in URL.Definition RWebWindow.cxx:1250; ROOT::RWebWindow::fMgrstd::shared_ptr< RWebWindowsManager > fMgr! display managerDefinition RWebWindow.hxx:136; ROOT::RWebWindow::fProtocolFileNamestd::string fProtocolFileName! local file where communication protocol will be writtenDefinition RWebWindow.hxx:170; ROOT::RWebWindow::GetYint GetY() constreturns configured window Y position (-1 - default)Definition RWebWindow.hxx:290; ROOT::RWebWindow::fNativeOnlyConnbool fNativeOnlyConn! only native connection are allowed, created by Show() methodDefinition RWebWindow.hxx:154; ROOT::RWebWindow::GetManagerstd::shared_ptr< RWebWindowsManager > GetManager() constReturns window manager.Definition RWebWindow.hxx:251; ROOT::RWebWindow::fConnConnectionsList_t fConn! list of all accepted connectionsDefinition RWebWindow.hxx:150; ROOT::RWebWindow::fConnCallbackWebWindowConnectCallback_t fConnCallback! callback for connect eventDefinition RWebWindow.hxx:157; ROOT::RWebWindow::CheckPendingConnectionsvoid CheckPendingConnections()Check if started process(es) establish connection.Definition RWebWindow.cxx:624; ROOT::RWebWindow::fClearOnClosestd::shared_ptr< void > fClearOnClose! entry which is cleared when last connection is c",MatchSource.WIKI,doc/v632/RWebWindow_8hxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/RWebWindow_8hxx_source.html
https://root.cern/doc/v632/RWebWindow_8hxx_source.html:42842,Integrability,protocol,protocol,42842,"g and check if next operation has to be start...Definition RWebWindow.cxx:1088; ROOT::RWebWindow::IsUseCurrentDirbool IsUseCurrentDir() constreturns true if window can access local files via currentdir/ path of http serverDefinition RWebWindow.hxx:328; ROOT::RWebWindow::fUseServerThreadsbool fUseServerThreads! indicates that server thread is using, no special window threadDefinition RWebWindow.hxx:142; ROOT::RWebWindow::FindHeadlessConnectionunsigned FindHeadlessConnection()Returns connection id of window running in headless mode This can be special connection which may run...Definition RWebWindow.cxx:221; ROOT::RWebWindow::WaitForTimedint WaitForTimed(WebWindowWaitFunc_t check)Waits until provided check function or lambdas returns non-zero value Check function has following si...Definition RWebWindow.cxx:1803; ROOT::RWebWindow::fProcessMTbool fProcessMT! if window event processing performed in dedicated threadDefinition RWebWindow.hxx:144; ROOT::RWebWindow::fProtocolCntint fProtocolCnt! counter for protocol recordingDefinition RWebWindow.hxx:171; ROOT::RWebWindow::SetClientVersionvoid SetClientVersion(const std::string &vers)Set client version, used as prefix in scripts URL When changed, web browser will reload all related J...Definition RWebWindow.cxx:1289; ROOT::RWebWindow::RemoveMasterConnectionvoid RemoveMasterConnection(unsigned connid=0)Remove master connection - if any.Definition RWebWindow.cxx:343; ROOT::RWebWindow::RemoveEmbedWindowvoid RemoveEmbedWindow(unsigned connid, int channel)Remove RWebWindow associated with the channelfEmbed.Definition RWebWindow.cxx:1867; ROOT::RWebWindow::SetCallBacksvoid SetCallBacks(WebWindowConnectCallback_t conn, WebWindowDataCallback_t data, WebWindowConnectCallback_t disconn=nullptr)Set call-backs function for connect, data and disconnect events.Definition RWebWindow.cxx:1772; ROOT::RWebWindow::SetRequireAuthKeyvoid SetRequireAuthKey(bool on)Configure if authentication key in connection string is required.Definition RWebWin",MatchSource.WIKI,doc/v632/RWebWindow_8hxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/RWebWindow_8hxx_source.html
https://root.cern/doc/v632/RWebWindow_8hxx_source.html:44945,Integrability,message,message,44945," unique key for the window.Definition RWebWindow.cxx:611; ROOT::RWebWindow::SetUseCurrentDirvoid SetUseCurrentDir(bool on=true)Configure if window can access local files via currentdir/ path of http server.Definition RWebWindow.hxx:324; ROOT::RWebWindow::fDisconnCallbackWebWindowConnectCallback_t fDisconnCallback! callback for disconnect eventDefinition RWebWindow.hxx:159; ROOT::RWebWindow::GetMaxQueueLengthunsigned GetMaxQueueLength() constReturn maximal queue length of data which can be held by window.Definition RWebWindow.hxx:304; ROOT::RWebWindow::EQueueEntryKindEQueueEntryKindDefinition RWebWindow.hxx:124; ROOT::RWebWindow::kind_Disconnect@ kind_DisconnectDefinition RWebWindow.hxx:124; ROOT::RWebWindow::kind_Connect@ kind_ConnectDefinition RWebWindow.hxx:124; ROOT::RWebWindow::kind_None@ kind_NoneDefinition RWebWindow.hxx:124; ROOT::RWebWindow::kind_Data@ kind_DataDefinition RWebWindow.hxx:124; ROOT::RWebWindow::IsFileDialogMessagestatic bool IsFileDialogMessage(const std::string &msg)Check if this could be the message send by client to start new file dialog If returns true,...Definition RWebWindow.cxx:1963; ROOT::RWebWindowsManagerCentral instance to create and show web-based windows like Canvas or FitPanel.Definition RWebWindowsManager.hxx:36; THttpCallArgContains arguments for single HTTP call.Definition THttpCallArg.h:27; THttpServerOnline http server for arbitrary ROOT application.Definition THttpServer.h:31; bool; int; yDouble_t y[n]Definition legend1.C:17; xDouble_t x[n]Definition legend1.C:17; ROOTtbb::task_arena is an alias of tbb::interface7::task_arena, which doesn't allow to forward declare tb...Definition EExecutionPolicy.hxx:4; ROOT::WebWindowDataCallback_tstd::function< void(unsigned, const std::string &)> WebWindowDataCallback_tfunction signature for call-backs from the window clients first argument is connection id,...Definition RWebWindow.hxx:39; ROOT::WebWindowConnectCallback_tstd::function< void(unsigned)> WebWindowConnectCallback_tfunction s",MatchSource.WIKI,doc/v632/RWebWindow_8hxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/RWebWindow_8hxx_source.html
https://root.cern/doc/v632/RWebWindow_8hxx_source.html:8516,Modifiability,config,configured,8516,"ect event; 160 std::thread::id fCallbacksThrdId; ///<! thread id where callbacks should be invoked; 161 bool fCallbacksThrdIdSet{false}; ///<! flag indicating that thread id is assigned; 162 bool fHasWindowThrd{false}; ///<! indicate if special window thread was started; 163 std::thread fWindowThrd; ///<! special thread for that window; 164 std::queue<QueueEntry> fInputQueue; ///<! input queue for all callbacks; 165 std::mutex fInputQueueMutex; ///<! mutex to protect input queue; 166 unsigned fWidth{0}, fHeight{0}; ///<! initial window width and height when displayed, zeros are ignored; 167 int fX{-1}, fY{-1}; ///<! initial window position, -1 ignored; 168 float fOperationTmout{50.}; ///<! timeout in seconds to perform synchronous operation, default 50s; 169 std::string fClientVersion; ///<! configured client version, used as prefix in scripts URL; 170 std::string fProtocolFileName; ///<! local file where communication protocol will be written; 171 int fProtocolCnt{-1}; ///<! counter for protocol recording; 172 unsigned fProtocolConnId{0}; ///<! connection id, which is used for writing protocol; 173 std::string fProtocolPrefix; ///<! prefix for created files names; 174 std::string fProtocol; ///<! protocol; 175 std::string fUserArgs; ///<! arbitrary JSON code, which is accessible via conn.getUserArgs() method; 176 std::shared_ptr<void> fClearOnClose; ///<! entry which is cleared when last connection is closed; 177 ; 178 std::shared_ptr<RWebWindowWSHandler> CreateWSHandler(std::shared_ptr<RWebWindowsManager> mgr, unsigned id, double tmout);; 179 ; 180 bool ProcessWS(THttpCallArg &arg);; 181 ; 182 void CompleteWSSend(unsigned wsid);; 183 ; 184 ConnectionsList_t GetWindowConnections(unsigned connid = 0, bool only_active = false) const;; 185 ; 186 /// Find connection with specified websocket id; 187 std::shared_ptr<WebConn> FindConnection(unsigned wsid);; 188 ; 189 std::shared_ptr<WebConn> RemoveConnection(unsigned wsid);; 190 ; 191 bool _CanTrustIn(std::shared_ptr<WebC",MatchSource.WIKI,doc/v632/RWebWindow_8hxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/RWebWindow_8hxx_source.html
https://root.cern/doc/v632/RWebWindow_8hxx_source.html:12932,Modifiability,config,configured,12932,,MatchSource.WIKI,doc/v632/RWebWindow_8hxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/RWebWindow_8hxx_source.html
https://root.cern/doc/v632/RWebWindow_8hxx_source.html:13168,Modifiability,config,configured,13168,,MatchSource.WIKI,doc/v632/RWebWindow_8hxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/RWebWindow_8hxx_source.html
https://root.cern/doc/v632/RWebWindow_8hxx_source.html:13361,Modifiability,config,configured,13361,,MatchSource.WIKI,doc/v632/RWebWindow_8hxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/RWebWindow_8hxx_source.html
https://root.cern/doc/v632/RWebWindow_8hxx_source.html:13544,Modifiability,config,configured,13544,,MatchSource.WIKI,doc/v632/RWebWindow_8hxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/RWebWindow_8hxx_source.html
https://root.cern/doc/v632/RWebWindow_8hxx_source.html:13870,Modifiability,config,configures,13870,"///////////////////////////////////////; 276 /// returns configured window width (0 - default); 277 /// actual window width can be different; 278 unsigned GetWidth() const { return fWidth; }; 279 ; 280 /////////////////////////////////////////////////////////////////////////; 281 /// returns configured window height (0 - default); 282 unsigned GetHeight() const { return fHeight; }; 283 ; 284 /////////////////////////////////////////////////////////////////////////; 285 /// returns configured window X position (-1 - default); 286 int GetX() const { return fX; }; 287 ; 288 /////////////////////////////////////////////////////////////////////////; 289 /// returns configured window Y position (-1 - default); 290 int GetY() const { return fY; }; 291 ; 292 void SetConnLimit(unsigned lmt = 0);; 293 ; 294 unsigned GetConnLimit() const;; 295 ; 296 void SetConnToken(const std::string &token = """");; 297 ; 298 /////////////////////////////////////////////////////////////////////////; 299 /// configures maximal queue length of data which can be held by window; 300 void SetMaxQueueLength(unsigned len = 10) { fMaxQueueLength = len; }; 301 ; 302 /////////////////////////////////////////////////////////////////////////; 303 /// Return maximal queue length of data which can be held by window; 304 unsigned GetMaxQueueLength() const { return fMaxQueueLength; }; 305 ; 306 /////////////////////////////////////////////////////////////////////////; 307 /// configures that only native (own-created) connections are allowed; 308 void SetNativeOnlyConn(bool on = true) { fNativeOnlyConn = on; }; 309 ; 310 /////////////////////////////////////////////////////////////////////////; 311 /// returns true if only native (own-created) connections are allowed; 312 bool IsNativeOnlyConn() const { return fNativeOnlyConn; }; 313 ; 314 /////////////////////////////////////////////////////////////////////////; 315 /// Configure if authentication key in connection string is required; 316 void SetRequireAuthKe",MatchSource.WIKI,doc/v632/RWebWindow_8hxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/RWebWindow_8hxx_source.html
https://root.cern/doc/v632/RWebWindow_8hxx_source.html:14332,Modifiability,config,configures,14332,"//////; 285 /// returns configured window X position (-1 - default); 286 int GetX() const { return fX; }; 287 ; 288 /////////////////////////////////////////////////////////////////////////; 289 /// returns configured window Y position (-1 - default); 290 int GetY() const { return fY; }; 291 ; 292 void SetConnLimit(unsigned lmt = 0);; 293 ; 294 unsigned GetConnLimit() const;; 295 ; 296 void SetConnToken(const std::string &token = """");; 297 ; 298 /////////////////////////////////////////////////////////////////////////; 299 /// configures maximal queue length of data which can be held by window; 300 void SetMaxQueueLength(unsigned len = 10) { fMaxQueueLength = len; }; 301 ; 302 /////////////////////////////////////////////////////////////////////////; 303 /// Return maximal queue length of data which can be held by window; 304 unsigned GetMaxQueueLength() const { return fMaxQueueLength; }; 305 ; 306 /////////////////////////////////////////////////////////////////////////; 307 /// configures that only native (own-created) connections are allowed; 308 void SetNativeOnlyConn(bool on = true) { fNativeOnlyConn = on; }; 309 ; 310 /////////////////////////////////////////////////////////////////////////; 311 /// returns true if only native (own-created) connections are allowed; 312 bool IsNativeOnlyConn() const { return fNativeOnlyConn; }; 313 ; 314 /////////////////////////////////////////////////////////////////////////; 315 /// Configure if authentication key in connection string is required; 316 void SetRequireAuthKey(bool on) { fRequireAuthKey = on; }; 317 ; 318 /////////////////////////////////////////////////////////////////////////; 319 /// returns true if authentication string is required; 320 bool IsRequireAuthKey() const { return fRequireAuthKey; }; 321 ; 322 /////////////////////////////////////////////////////////////////////////; 323 /// Configure if window can access local files via currentdir/ path of http server; 324 void SetUseCurrentDir(bool on = true) { ",MatchSource.WIKI,doc/v632/RWebWindow_8hxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/RWebWindow_8hxx_source.html
https://root.cern/doc/v632/RWebWindow_8hxx_source.html:29739,Modifiability,config,configured,29739,"ess_mode, const std::string &key, std::unique_ptr< RWebDisplayHandle > &handle)Add display handle and associated key Key is large random string generated when starting new window W...Definition RWebWindow.cxx:482; ROOT::RWebWindow::ConnectionsList_tstd::vector< std::shared_ptr< WebConn > > ConnectionsList_tDefinition RWebWindow.hxx:134; ROOT::RWebWindow::AssignThreadIdvoid AssignThreadId()Assign thread id which has to be used for callbacks WARNING!!! only for expert use Automatically done...Definition RWebWindow.cxx:1645; ROOT::RWebWindow::IsNativeOnlyConnbool IsNativeOnlyConn() constreturns true if only native (own-created) connections are allowedDefinition RWebWindow.hxx:312; ROOT::RWebWindow::SendBinaryvoid SendBinary(unsigned connid, const void *data, std::size_t len)Send binary data to specified connection.Definition RWebWindow.cxx:1630; ROOT::RWebWindow::fYint fY! initial window position, -1 ignoredDefinition RWebWindow.hxx:167; ROOT::RWebWindow::GetXint GetX() constreturns configured window X position (-1 - default)Definition RWebWindow.hxx:286; ROOT::RWebWindow::Createstatic std::shared_ptr< RWebWindow > Create()Create new RWebWindow Using default RWebWindowsManager.Definition RWebWindow.cxx:1883; ROOT::RWebWindow::fWidthunsigned fWidthDefinition RWebWindow.hxx:166; ROOT::RWebWindow::fClientVersionstd::string fClientVersion! configured client version, used as prefix in scripts URLDefinition RWebWindow.hxx:169; ROOT::RWebWindow::ProcessBatchHolderbool ProcessBatchHolder(std::shared_ptr< THttpCallArg > &arg)Process special http request, used to hold headless browser running Such requests should not be repli...Definition RWebWindow.cxx:374; ROOT::RWebWindow::SetOperationTmoutvoid SetOperationTmout(float tm=50.)Set timeout for synchronous WebWindow operations.Definition RWebWindow.hxx:354; ROOT::RWebWindow::AddEmbedWindowunsigned AddEmbedWindow(std::shared_ptr< RWebWindow > window, unsigned connid, int channel)Add embed window.Definition RWebWindow.cxx:1846; ROO",MatchSource.WIKI,doc/v632/RWebWindow_8hxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/RWebWindow_8hxx_source.html
https://root.cern/doc/v632/RWebWindow_8hxx_source.html:30099,Modifiability,config,configured,30099,"signThreadIdvoid AssignThreadId()Assign thread id which has to be used for callbacks WARNING!!! only for expert use Automatically done...Definition RWebWindow.cxx:1645; ROOT::RWebWindow::IsNativeOnlyConnbool IsNativeOnlyConn() constreturns true if only native (own-created) connections are allowedDefinition RWebWindow.hxx:312; ROOT::RWebWindow::SendBinaryvoid SendBinary(unsigned connid, const void *data, std::size_t len)Send binary data to specified connection.Definition RWebWindow.cxx:1630; ROOT::RWebWindow::fYint fY! initial window position, -1 ignoredDefinition RWebWindow.hxx:167; ROOT::RWebWindow::GetXint GetX() constreturns configured window X position (-1 - default)Definition RWebWindow.hxx:286; ROOT::RWebWindow::Createstatic std::shared_ptr< RWebWindow > Create()Create new RWebWindow Using default RWebWindowsManager.Definition RWebWindow.cxx:1883; ROOT::RWebWindow::fWidthunsigned fWidthDefinition RWebWindow.hxx:166; ROOT::RWebWindow::fClientVersionstd::string fClientVersion! configured client version, used as prefix in scripts URLDefinition RWebWindow.hxx:169; ROOT::RWebWindow::ProcessBatchHolderbool ProcessBatchHolder(std::shared_ptr< THttpCallArg > &arg)Process special http request, used to hold headless browser running Such requests should not be repli...Definition RWebWindow.cxx:374; ROOT::RWebWindow::SetOperationTmoutvoid SetOperationTmout(float tm=50.)Set timeout for synchronous WebWindow operations.Definition RWebWindow.hxx:354; ROOT::RWebWindow::AddEmbedWindowunsigned AddEmbedWindow(std::shared_ptr< RWebWindow > window, unsigned connid, int channel)Add embed window.Definition RWebWindow.cxx:1846; ROOT::RWebWindow::SetDisconnectCallBackvoid SetDisconnectCallBack(WebWindowConnectCallback_t func)Set call-back function for disconnecting.Definition RWebWindow.cxx:1753; ROOT::RWebWindow::GetConnectionsstd::vector< unsigned > GetConnections(unsigned excludeid=0) constreturns vector with all existing connections ids One also can exclude specified connection fro",MatchSource.WIKI,doc/v632/RWebWindow_8hxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/RWebWindow_8hxx_source.html
https://root.cern/doc/v632/RWebWindow_8hxx_source.html:32249,Modifiability,config,configured,32249,"unction for data, received from the clients via websocket.Definition RWebWindow.cxx:1733; ROOT::RWebWindow::fOperationTmoutfloat fOperationTmout! timeout in seconds to perform synchronous operation, default 50sDefinition RWebWindow.hxx:168; ROOT::RWebWindow::fRequireAuthKeybool fRequireAuthKey! defines if authentication key always required when connect to the widgetDefinition RWebWindow.hxx:146; ROOT::RWebWindow::gStartDialogFuncstatic std::function< bool(const std::shared_ptr< RWebWindow > &, unsigned, const std::string &)> gStartDialogFuncDefinition RWebWindow.hxx:235; ROOT::RWebWindow::SetUserArgsvoid SetUserArgs(const std::string &args)Set arbitrary JSON data, which is accessible via conn.getUserArgs() method in JavaScript This JSON co...Definition RWebWindow.cxx:1310; ROOT::RWebWindow::fConnTokenstd::string fConnToken! value of ""token"" URL parameter which should be provided for connecting windowDefinition RWebWindow.hxx:153; ROOT::RWebWindow::GetHeightunsigned GetHeight() constreturns configured window height (0 - default)Definition RWebWindow.hxx:282; ROOT::RWebWindow::ShowWindowstatic unsigned ShowWindow(std::shared_ptr< RWebWindow > window, const RWebDisplayArgs &args="""")Static method to show web window Has to be used instead of RWebWindow::Show() when window potentially...Definition RWebWindow.cxx:1915; ROOT::RWebWindow::fWSHandlerstd::shared_ptr< RWebWindowWSHandler > fWSHandler! specialize websocket handler for all incoming connectionsDefinition RWebWindow.hxx:147; ROOT::RWebWindow::StopThreadvoid StopThread()Stop special thread.Definition RWebWindow.cxx:1702; ROOT::RWebWindow::SubmitDatavoid SubmitData(unsigned connid, bool txt, std::string &&data, int chid=1)Internal method to send data.Definition RWebWindow.cxx:1529; ROOT::RWebWindow::HMACstatic std::string HMAC(const std::string &key, const std::string &sessionKey, const char *msg, int msglen)Calculate HMAC checksum for provided key and message Key combained from connection key and session ke...Defini",MatchSource.WIKI,doc/v632/RWebWindow_8hxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/RWebWindow_8hxx_source.html
https://root.cern/doc/v632/RWebWindow_8hxx_source.html:34252,Modifiability,config,configured,34252,"ession ke...Definition RWebWindow.cxx:1992; ROOT::RWebWindow::~RWebWindow~RWebWindow()RWebWindow destructor Closes all connections and remove window from manager.Definition RWebWindow.cxx:85; ROOT::RWebWindow::EmbedFileDialogstatic bool EmbedFileDialog(const std::shared_ptr< RWebWindow > &window, unsigned connid, const std::string &args)Create dialog instance to use as embedded dialog inside provided widget Loads libROOTBrowserv7 and tr...Definition RWebWindow.cxx:1977; ROOT::RWebWindow::CloseConnectionvoid CloseConnection(unsigned connid)Close specified connection.Definition RWebWindow.cxx:1447; ROOT::RWebWindow::fPendingConnConnectionsList_t fPendingConn! list of pending connection with pre-assigned keysDefinition RWebWindow.hxx:149; ROOT::RWebWindow::GetConnectionIdunsigned GetConnectionId(int num=0) constReturns connection id for specified connection sequence number Only active connections are returned -...Definition RWebWindow.cxx:1370; ROOT::RWebWindow::GetConnTokenstd::string GetConnToken() constReturns configured connection token.Definition RWebWindow.cxx:725; ROOT::RWebWindow::GetOperationTmoutfloat GetOperationTmout() constReturns timeout for synchronous WebWindow operations.Definition RWebWindow.hxx:351; ROOT::RWebWindow::SetConnLimitvoid SetConnLimit(unsigned lmt=0)Configure maximal number of allowed connections - 0 is unlimited Will not affect already existing con...Definition RWebWindow.cxx:693; ROOT::RWebWindow::SetPanelNamevoid SetPanelName(const std::string &name)Configure window to show some of existing JSROOT panels It uses ""file:rootui5sys/panel/panel....Definition RWebWindow.cxx:132; ROOT::RWebWindow::SetPositionvoid SetPosition(unsigned x, unsigned y)Set window position. Will be applied if supported by used web display (like CEF or Chromium)Definition RWebWindow.hxx:269; ROOT::RWebWindow::IsRequireAuthKeybool IsRequireAuthKey() constreturns true if authentication string is requiredDefinition RWebWindow.hxx:320; ROOT::RWebWindow::RWebWindowRWebW",MatchSource.WIKI,doc/v632/RWebWindow_8hxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/RWebWindow_8hxx_source.html
https://root.cern/doc/v632/RWebWindow_8hxx_source.html:35427,Modifiability,config,configures,35427,"efinition RWebWindow.hxx:351; ROOT::RWebWindow::SetConnLimitvoid SetConnLimit(unsigned lmt=0)Configure maximal number of allowed connections - 0 is unlimited Will not affect already existing con...Definition RWebWindow.cxx:693; ROOT::RWebWindow::SetPanelNamevoid SetPanelName(const std::string &name)Configure window to show some of existing JSROOT panels It uses ""file:rootui5sys/panel/panel....Definition RWebWindow.cxx:132; ROOT::RWebWindow::SetPositionvoid SetPosition(unsigned x, unsigned y)Set window position. Will be applied if supported by used web display (like CEF or Chromium)Definition RWebWindow.hxx:269; ROOT::RWebWindow::IsRequireAuthKeybool IsRequireAuthKey() constreturns true if authentication string is requiredDefinition RWebWindow.hxx:320; ROOT::RWebWindow::RWebWindowRWebWindow()RWebWindow constructor Should be defined here because of std::unique_ptr<RWebWindowWSHandler>Definition RWebWindow.cxx:76; ROOT::RWebWindow::SetNativeOnlyConnvoid SetNativeOnlyConn(bool on=true)configures that only native (own-created) connections are allowedDefinition RWebWindow.hxx:308; ROOT::RWebWindow::fProtocolPrefixstd::string fProtocolPrefix! prefix for created files namesDefinition RWebWindow.hxx:173; ROOT::RWebWindow::GetSendQueueLengthint GetSendQueueLength(unsigned connid) constReturns send queue length for specified connection.Definition RWebWindow.cxx:1509; ROOT::RWebWindow::RemoveConnectionstd::shared_ptr< WebConn > RemoveConnection(unsigned wsid)Remove connection with given websocket id.Definition RWebWindow.cxx:279; ROOT::RWebWindow::CreateWSHandlerstd::shared_ptr< RWebWindowWSHandler > CreateWSHandler(std::shared_ptr< RWebWindowsManager > mgr, unsigned id, double tmout)Assigns manager reference, window id and creates websocket handler, used for communication with the c...Definition RWebWindow.cxx:152; ROOT::RWebWindow::fProtocolstd::string fProtocol! protocolDefinition RWebWindow.hxx:174; ROOT::RWebWindow::CanSendbool CanSend(unsigned connid, bool direct=true) co",MatchSource.WIKI,doc/v632/RWebWindow_8hxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/RWebWindow_8hxx_source.html
https://root.cern/doc/v632/RWebWindow_8hxx_source.html:36600,Modifiability,config,configured,36600,"ed files namesDefinition RWebWindow.hxx:173; ROOT::RWebWindow::GetSendQueueLengthint GetSendQueueLength(unsigned connid) constReturns send queue length for specified connection.Definition RWebWindow.cxx:1509; ROOT::RWebWindow::RemoveConnectionstd::shared_ptr< WebConn > RemoveConnection(unsigned wsid)Remove connection with given websocket id.Definition RWebWindow.cxx:279; ROOT::RWebWindow::CreateWSHandlerstd::shared_ptr< RWebWindowWSHandler > CreateWSHandler(std::shared_ptr< RWebWindowsManager > mgr, unsigned id, double tmout)Assigns manager reference, window id and creates websocket handler, used for communication with the c...Definition RWebWindow.cxx:152; ROOT::RWebWindow::fProtocolstd::string fProtocol! protocolDefinition RWebWindow.hxx:174; ROOT::RWebWindow::CanSendbool CanSend(unsigned connid, bool direct=true) constReturns true if sending via specified connection can be performed.Definition RWebWindow.cxx:1484; ROOT::RWebWindow::GetUserArgsstd::string GetUserArgs() constReturns configured user arguments for web window See SetUserArgs method for more details.Definition RWebWindow.cxx:1320; ROOT::RWebWindow::RecordDatavoid RecordData(const std::string &fname=""protocol.json"", const std::string &fprefix="""")Configures recording of communication data in protocol file Provided filename will be used to store J...Definition RWebWindow.cxx:1355; ROOT::RWebWindow::fUseProcessEventsbool fUseProcessEvents! all window functionality will run through process eventsDefinition RWebWindow.hxx:143; ROOT::RWebWindow::GetDisplayConnectionunsigned GetDisplayConnection() constReturns first connection id where window is displayed It could be that connection(s) not yet fully es...Definition RWebWindow.cxx:244; ROOT::RWebWindow::fMaxQueueLengthunsigned fMaxQueueLength! maximal number of queue entriesDefinition RWebWindow.hxx:156; ROOT::RWebWindow::fXint fXDefinition RWebWindow.hxx:167; ROOT::RWebWindow::GetConnLimitunsigned GetConnLimit() constreturns configured connections limit (0 - de",MatchSource.WIKI,doc/v632/RWebWindow_8hxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/RWebWindow_8hxx_source.html
https://root.cern/doc/v632/RWebWindow_8hxx_source.html:37566,Modifiability,config,configured,37566,"sstd::string GetUserArgs() constReturns configured user arguments for web window See SetUserArgs method for more details.Definition RWebWindow.cxx:1320; ROOT::RWebWindow::RecordDatavoid RecordData(const std::string &fname=""protocol.json"", const std::string &fprefix="""")Configures recording of communication data in protocol file Provided filename will be used to store J...Definition RWebWindow.cxx:1355; ROOT::RWebWindow::fUseProcessEventsbool fUseProcessEvents! all window functionality will run through process eventsDefinition RWebWindow.hxx:143; ROOT::RWebWindow::GetDisplayConnectionunsigned GetDisplayConnection() constReturns first connection id where window is displayed It could be that connection(s) not yet fully es...Definition RWebWindow.cxx:244; ROOT::RWebWindow::fMaxQueueLengthunsigned fMaxQueueLength! maximal number of queue entriesDefinition RWebWindow.hxx:156; ROOT::RWebWindow::fXint fXDefinition RWebWindow.hxx:167; ROOT::RWebWindow::GetConnLimitunsigned GetConnLimit() constreturns configured connections limit (0 - default)Definition RWebWindow.cxx:703; ROOT::RWebWindow::GetRelativeAddrstd::string GetRelativeAddr(const std::shared_ptr< RWebWindow > &win) constReturns relative URL address for the specified window Address can be required if one needs to access ...Definition RWebWindow.cxx:1260; ROOT::RWebWindow::SetStartDialogFuncstatic void SetStartDialogFunc(std::function< bool(const std::shared_ptr< RWebWindow > &, unsigned, const std::string &)>)Configure func which has to be used for starting dialog.Definition RWebWindow.cxx:1953; ROOT::RWebWindow::fPanelNamestd::string fPanelName! panel name which should be shown in the windowDefinition RWebWindow.hxx:140; ROOT::RWebWindow::Runvoid Run(double tm=0.)Run window functionality for specified time If no action can be performed - just sleep specified time...Definition RWebWindow.cxx:1827; ROOT::RWebWindow::fHeightunsigned fHeight! initial window width and height when displayed, zeros are ignoredDefinition RWeb",MatchSource.WIKI,doc/v632/RWebWindow_8hxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/RWebWindow_8hxx_source.html
https://root.cern/doc/v632/RWebWindow_8hxx_source.html:39014,Modifiability,config,configured,39014,"const std::string &)>)Configure func which has to be used for starting dialog.Definition RWebWindow.cxx:1953; ROOT::RWebWindow::fPanelNamestd::string fPanelName! panel name which should be shown in the windowDefinition RWebWindow.hxx:140; ROOT::RWebWindow::Runvoid Run(double tm=0.)Run window functionality for specified time If no action can be performed - just sleep specified time...Definition RWebWindow.cxx:1827; ROOT::RWebWindow::fHeightunsigned fHeight! initial window width and height when displayed, zeros are ignoredDefinition RWebWindow.hxx:166; ROOT::RWebWindow::GetAddrstd::string GetAddr() constReturns window address which is used in URL.Definition RWebWindow.cxx:1250; ROOT::RWebWindow::fMgrstd::shared_ptr< RWebWindowsManager > fMgr! display managerDefinition RWebWindow.hxx:136; ROOT::RWebWindow::fProtocolFileNamestd::string fProtocolFileName! local file where communication protocol will be writtenDefinition RWebWindow.hxx:170; ROOT::RWebWindow::GetYint GetY() constreturns configured window Y position (-1 - default)Definition RWebWindow.hxx:290; ROOT::RWebWindow::fNativeOnlyConnbool fNativeOnlyConn! only native connection are allowed, created by Show() methodDefinition RWebWindow.hxx:154; ROOT::RWebWindow::GetManagerstd::shared_ptr< RWebWindowsManager > GetManager() constReturns window manager.Definition RWebWindow.hxx:251; ROOT::RWebWindow::fConnConnectionsList_t fConn! list of all accepted connectionsDefinition RWebWindow.hxx:150; ROOT::RWebWindow::fConnCallbackWebWindowConnectCallback_t fConnCallback! callback for connect eventDefinition RWebWindow.hxx:157; ROOT::RWebWindow::CheckPendingConnectionsvoid CheckPendingConnections()Check if started process(es) establish connection.Definition RWebWindow.cxx:624; ROOT::RWebWindow::fClearOnClosestd::shared_ptr< void > fClearOnClose! entry which is cleared when last connection is closedDefinition RWebWindow.hxx:176; ROOT::RWebWindow::fInputQueueMutexstd::mutex fInputQueueMutex! mutex to protect input queueDefinitio",MatchSource.WIKI,doc/v632/RWebWindow_8hxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/RWebWindow_8hxx_source.html
https://root.cern/doc/v632/RWebWindow_8hxx_source.html:40506,Modifiability,config,configures,40506,"lbackWebWindowConnectCallback_t fConnCallback! callback for connect eventDefinition RWebWindow.hxx:157; ROOT::RWebWindow::CheckPendingConnectionsvoid CheckPendingConnections()Check if started process(es) establish connection.Definition RWebWindow.cxx:624; ROOT::RWebWindow::fClearOnClosestd::shared_ptr< void > fClearOnClose! entry which is cleared when last connection is closedDefinition RWebWindow.hxx:176; ROOT::RWebWindow::fInputQueueMutexstd::mutex fInputQueueMutex! mutex to protect input queueDefinition RWebWindow.hxx:165; ROOT::RWebWindow::_MakeSendHeaderstd::string _MakeSendHeader(std::shared_ptr< WebConn > &conn, bool txt, const std::string &data, int chid)Internal method to prepare text part of send data Should be called under locked connection mutex.Definition RWebWindow.cxx:1107; ROOT::RWebWindow::timestamp_tstd::chrono::time_point< std::chrono::system_clock > timestamp_tDefinition RWebWindow.hxx:60; ROOT::RWebWindow::SetMaxQueueLengthvoid SetMaxQueueLength(unsigned len=10)configures maximal queue length of data which can be held by windowDefinition RWebWindow.hxx:300; ROOT::RWebWindow::ProcessWSbool ProcessWS(THttpCallArg &arg)Processing of websockets call-backs, invoked from RWebWindowWSHandler Method invoked from http server...Definition RWebWindow.cxx:736; ROOT::RWebWindow::HasConnectionbool HasConnection(unsigned connid=0, bool only_active=true) constreturns true if specified connection id existsDefinition RWebWindow.cxx:1413; ROOT::RWebWindow::GetWidthunsigned GetWidth() constreturns configured window width (0 - default) actual window width can be differentDefinition RWebWindow.hxx:278; ROOT::RWebWindow::fWindowThrdstd::thread fWindowThrd! special thread for that windowDefinition RWebWindow.hxx:163; ROOT::RWebWindow::ProvideQueueEntryvoid ProvideQueueEntry(unsigned connid, EQueueEntryKind kind, std::string &&arg)Provide data to user callback User callback must be executed in the window thread.Definition RWebWindow.cxx:421; ROOT::RWebWindow::HasKeybool ",MatchSource.WIKI,doc/v632/RWebWindow_8hxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/RWebWindow_8hxx_source.html
https://root.cern/doc/v632/RWebWindow_8hxx_source.html:41033,Modifiability,config,configured,41033,":RWebWindow::_MakeSendHeaderstd::string _MakeSendHeader(std::shared_ptr< WebConn > &conn, bool txt, const std::string &data, int chid)Internal method to prepare text part of send data Should be called under locked connection mutex.Definition RWebWindow.cxx:1107; ROOT::RWebWindow::timestamp_tstd::chrono::time_point< std::chrono::system_clock > timestamp_tDefinition RWebWindow.hxx:60; ROOT::RWebWindow::SetMaxQueueLengthvoid SetMaxQueueLength(unsigned len=10)configures maximal queue length of data which can be held by windowDefinition RWebWindow.hxx:300; ROOT::RWebWindow::ProcessWSbool ProcessWS(THttpCallArg &arg)Processing of websockets call-backs, invoked from RWebWindowWSHandler Method invoked from http server...Definition RWebWindow.cxx:736; ROOT::RWebWindow::HasConnectionbool HasConnection(unsigned connid=0, bool only_active=true) constreturns true if specified connection id existsDefinition RWebWindow.cxx:1413; ROOT::RWebWindow::GetWidthunsigned GetWidth() constreturns configured window width (0 - default) actual window width can be differentDefinition RWebWindow.hxx:278; ROOT::RWebWindow::fWindowThrdstd::thread fWindowThrd! special thread for that windowDefinition RWebWindow.hxx:163; ROOT::RWebWindow::ProvideQueueEntryvoid ProvideQueueEntry(unsigned connid, EQueueEntryKind kind, std::string &&arg)Provide data to user callback User callback must be executed in the window thread.Definition RWebWindow.cxx:421; ROOT::RWebWindow::HasKeybool HasKey(const std::string &key, bool also_newkey=false) constReturns true if provided key value already exists (in processes map or in existing connections) In sp...Definition RWebWindow.cxx:558; ROOT::RWebWindow::CompleteWSSendvoid CompleteWSSend(unsigned wsid)Complete websocket send operation Clear ""doing send"" flag and check if next operation has to be start...Definition RWebWindow.cxx:1088; ROOT::RWebWindow::IsUseCurrentDirbool IsUseCurrentDir() constreturns true if window can access local files via currentdir/ path of http serv",MatchSource.WIKI,doc/v632/RWebWindow_8hxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/RWebWindow_8hxx_source.html
https://root.cern/doc/v632/RWebWindow_8hxx_source.html:957,Performance,queue,queue,957,"hxx>; 17 ; 18#include <memory>; 19#include <vector>; 20#include <string>; 21#include <queue>; 22#include <map>; 23#include <functional>; 24#include <mutex>; 25#include <thread>; 26#include <chrono>; 27 ; 28class THttpCallArg;; 29class THttpServer;; 30 ; 31namespace ROOT {; 32 ; 33/// function signature for connect/disconnect call-backs; 34/// argument is connection id; 35using WebWindowConnectCallback_t = std::function<void(unsigned)>;; 36 ; 37/// function signature for call-backs from the window clients; 38/// first argument is connection id, second is received data; 39using WebWindowDataCallback_t = std::function<void(unsigned, const std::string &)>;; 40 ; 41/// function signature for waiting call-backs; 42/// Such callback used when calling thread need to waits for some special data,; 43/// but wants to run application event loop; 44/// As argument, spent time in second will be provided; 45/// Waiting will be performed until function returns non-zero value; 46using WebWindowWaitFunc_t = std::function<int(double)>;; 47 ; 48class RFileDialog;; 49class RWebWindowsManager;; 50class RWebWindowWSHandler;; 51 ; 52cla",MatchSource.WIKI,doc/v632/RWebWindow_8hxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/RWebWindow_8hxx_source.html
https://root.cern/doc/v632/RWebWindow_8hxx_source.html:1797,Performance,perform,performed,1797,"hxx>; 17 ; 18#include <memory>; 19#include <vector>; 20#include <string>; 21#include <queue>; 22#include <map>; 23#include <functional>; 24#include <mutex>; 25#include <thread>; 26#include <chrono>; 27 ; 28class THttpCallArg;; 29class THttpServer;; 30 ; 31namespace ROOT {; 32 ; 33/// function signature for connect/disconnect call-backs; 34/// argument is connection id; 35using WebWindowConnectCallback_t = std::function<void(unsigned)>;; 36 ; 37/// function signature for call-backs from the window clients; 38/// first argument is connection id, second is received data; 39using WebWindowDataCallback_t = std::function<void(unsigned, const std::string &)>;; 40 ; 41/// function signature for waiting call-backs; 42/// Such callback used when calling thread need to waits for some special data,; 43/// but wants to run application event loop; 44/// As argument, spent time in second will be provided; 45/// Waiting will be performed until function returns non-zero value; 46using WebWindowWaitFunc_t = std::function<int(double)>;; 47 ; 48class RFileDialog;; 49class RWebWindowsManager;; 50class RWebWindowWSHandler;; 51 ; 52cla",MatchSource.WIKI,doc/v632/RWebWindow_8hxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/RWebWindow_8hxx_source.html
https://root.cern/doc/v632/RWebWindow_8hxx_source.html:3692,Performance,perform,performed,3692,"stamp_t fSendStamp; ///<! last server operation, always used from window thread; 78 bool fActive{false}; ///<! flag indicates if connection is active; 79 unsigned fWSId{0}; ///<! websocket id; 80 int fReady{0}; ///<! 0 - not ready, 1..9 - interim, 10 - done; 81 mutable std::mutex fMutex; ///<! mutex must be used to protect all following data; 82 timestamp_t fRecvStamp; ///<! last receive operation, protected with connection mutex; 83 int fRecvCount{0}; ///<! number of received packets, should return back with next sending; 84 int fSendCredits{0}; ///<! how many send operation can be performed without confirmation from other side; 85 int fClientCredits{0}; ///<! number of credits received from client; 86 bool fDoingSend{false}; ///<! true when performing send operation; 87 unsigned long fRecvSeq{0}; ///<! sequence id of last received packet; 88 unsigned long fSendSeq{1}; ///<! sequence id of last send packet; 89 std::queue<QueueItem> fQueue; ///<! output queue; 90 std::map<int,std::shared_ptr<RWebWindow>> fEmbed; ///<! map of embed window for that connection, key value is channel id; 91 WebConn() = default;; 92 WebConn(unsigned connid) : fConnId(connid) {}; 93 WebConn(unsigned connid, unsigned wsid) : fConnId(connid), fActive(true), fWSId(wsid) {}; 94 WebConn(unsigned connid, bool headless_mode, const std::string &key); 95 : fConnId(connid), fHeadlessMode(headless_mode), fKey(key); 96 {; 97 ResetStamps();; 98 }; 99 ~WebConn();; 100 ; 101 void ResetStamps() { fSendStamp = fRecvStamp = std::chrono::system_clock::now(); }; 102 ; 103 void ResetData(); 104 {; 105 fActive = false;; 106 fWSId = 0;; 107 fReady = 0;; 108 fDoingSend = false;; 109 fSendCredits = 0;; 110 fClientCredits = 0;; 111 fRecvSeq = 0;; 112 fSendSeq = 1;; 113 while (!fQueue.empty()); 114 fQueue.pop();; 115 }; 116 };; 117 ; 118 struct MasterConn {; 119 unsigned connid{0};; 120 int channel{-1};; 121 MasterConn(unsigned _connid, int _channel) : connid(_connid), channel(_channel) {}; 122 };; 123 ; 124 enum EQ",MatchSource.WIKI,doc/v632/RWebWindow_8hxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/RWebWindow_8hxx_source.html
https://root.cern/doc/v632/RWebWindow_8hxx_source.html:3855,Performance,perform,performing,3855,"stamp_t fSendStamp; ///<! last server operation, always used from window thread; 78 bool fActive{false}; ///<! flag indicates if connection is active; 79 unsigned fWSId{0}; ///<! websocket id; 80 int fReady{0}; ///<! 0 - not ready, 1..9 - interim, 10 - done; 81 mutable std::mutex fMutex; ///<! mutex must be used to protect all following data; 82 timestamp_t fRecvStamp; ///<! last receive operation, protected with connection mutex; 83 int fRecvCount{0}; ///<! number of received packets, should return back with next sending; 84 int fSendCredits{0}; ///<! how many send operation can be performed without confirmation from other side; 85 int fClientCredits{0}; ///<! number of credits received from client; 86 bool fDoingSend{false}; ///<! true when performing send operation; 87 unsigned long fRecvSeq{0}; ///<! sequence id of last received packet; 88 unsigned long fSendSeq{1}; ///<! sequence id of last send packet; 89 std::queue<QueueItem> fQueue; ///<! output queue; 90 std::map<int,std::shared_ptr<RWebWindow>> fEmbed; ///<! map of embed window for that connection, key value is channel id; 91 WebConn() = default;; 92 WebConn(unsigned connid) : fConnId(connid) {}; 93 WebConn(unsigned connid, unsigned wsid) : fConnId(connid), fActive(true), fWSId(wsid) {}; 94 WebConn(unsigned connid, bool headless_mode, const std::string &key); 95 : fConnId(connid), fHeadlessMode(headless_mode), fKey(key); 96 {; 97 ResetStamps();; 98 }; 99 ~WebConn();; 100 ; 101 void ResetStamps() { fSendStamp = fRecvStamp = std::chrono::system_clock::now(); }; 102 ; 103 void ResetData(); 104 {; 105 fActive = false;; 106 fWSId = 0;; 107 fReady = 0;; 108 fDoingSend = false;; 109 fSendCredits = 0;; 110 fClientCredits = 0;; 111 fRecvSeq = 0;; 112 fSendSeq = 1;; 113 while (!fQueue.empty()); 114 fQueue.pop();; 115 }; 116 };; 117 ; 118 struct MasterConn {; 119 unsigned connid{0};; 120 int channel{-1};; 121 MasterConn(unsigned _connid, int _channel) : connid(_connid), channel(_channel) {}; 122 };; 123 ; 124 enum EQ",MatchSource.WIKI,doc/v632/RWebWindow_8hxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/RWebWindow_8hxx_source.html
https://root.cern/doc/v632/RWebWindow_8hxx_source.html:4032,Performance,queue,queue,4032,"stamp_t fSendStamp; ///<! last server operation, always used from window thread; 78 bool fActive{false}; ///<! flag indicates if connection is active; 79 unsigned fWSId{0}; ///<! websocket id; 80 int fReady{0}; ///<! 0 - not ready, 1..9 - interim, 10 - done; 81 mutable std::mutex fMutex; ///<! mutex must be used to protect all following data; 82 timestamp_t fRecvStamp; ///<! last receive operation, protected with connection mutex; 83 int fRecvCount{0}; ///<! number of received packets, should return back with next sending; 84 int fSendCredits{0}; ///<! how many send operation can be performed without confirmation from other side; 85 int fClientCredits{0}; ///<! number of credits received from client; 86 bool fDoingSend{false}; ///<! true when performing send operation; 87 unsigned long fRecvSeq{0}; ///<! sequence id of last received packet; 88 unsigned long fSendSeq{1}; ///<! sequence id of last send packet; 89 std::queue<QueueItem> fQueue; ///<! output queue; 90 std::map<int,std::shared_ptr<RWebWindow>> fEmbed; ///<! map of embed window for that connection, key value is channel id; 91 WebConn() = default;; 92 WebConn(unsigned connid) : fConnId(connid) {}; 93 WebConn(unsigned connid, unsigned wsid) : fConnId(connid), fActive(true), fWSId(wsid) {}; 94 WebConn(unsigned connid, bool headless_mode, const std::string &key); 95 : fConnId(connid), fHeadlessMode(headless_mode), fKey(key); 96 {; 97 ResetStamps();; 98 }; 99 ~WebConn();; 100 ; 101 void ResetStamps() { fSendStamp = fRecvStamp = std::chrono::system_clock::now(); }; 102 ; 103 void ResetData(); 104 {; 105 fActive = false;; 106 fWSId = 0;; 107 fReady = 0;; 108 fDoingSend = false;; 109 fSendCredits = 0;; 110 fClientCredits = 0;; 111 fRecvSeq = 0;; 112 fSendSeq = 1;; 113 while (!fQueue.empty()); 114 fQueue.pop();; 115 }; 116 };; 117 ; 118 struct MasterConn {; 119 unsigned connid{0};; 120 int channel{-1};; 121 MasterConn(unsigned _connid, int _channel) : connid(_connid), channel(_channel) {}; 122 };; 123 ; 124 enum EQ",MatchSource.WIKI,doc/v632/RWebWindow_8hxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/RWebWindow_8hxx_source.html
https://root.cern/doc/v632/RWebWindow_8hxx_source.html:4070,Performance,queue,queue,4070,"stamp_t fSendStamp; ///<! last server operation, always used from window thread; 78 bool fActive{false}; ///<! flag indicates if connection is active; 79 unsigned fWSId{0}; ///<! websocket id; 80 int fReady{0}; ///<! 0 - not ready, 1..9 - interim, 10 - done; 81 mutable std::mutex fMutex; ///<! mutex must be used to protect all following data; 82 timestamp_t fRecvStamp; ///<! last receive operation, protected with connection mutex; 83 int fRecvCount{0}; ///<! number of received packets, should return back with next sending; 84 int fSendCredits{0}; ///<! how many send operation can be performed without confirmation from other side; 85 int fClientCredits{0}; ///<! number of credits received from client; 86 bool fDoingSend{false}; ///<! true when performing send operation; 87 unsigned long fRecvSeq{0}; ///<! sequence id of last received packet; 88 unsigned long fSendSeq{1}; ///<! sequence id of last send packet; 89 std::queue<QueueItem> fQueue; ///<! output queue; 90 std::map<int,std::shared_ptr<RWebWindow>> fEmbed; ///<! map of embed window for that connection, key value is channel id; 91 WebConn() = default;; 92 WebConn(unsigned connid) : fConnId(connid) {}; 93 WebConn(unsigned connid, unsigned wsid) : fConnId(connid), fActive(true), fWSId(wsid) {}; 94 WebConn(unsigned connid, bool headless_mode, const std::string &key); 95 : fConnId(connid), fHeadlessMode(headless_mode), fKey(key); 96 {; 97 ResetStamps();; 98 }; 99 ~WebConn();; 100 ; 101 void ResetStamps() { fSendStamp = fRecvStamp = std::chrono::system_clock::now(); }; 102 ; 103 void ResetData(); 104 {; 105 fActive = false;; 106 fWSId = 0;; 107 fReady = 0;; 108 fDoingSend = false;; 109 fSendCredits = 0;; 110 fClientCredits = 0;; 111 fRecvSeq = 0;; 112 fSendSeq = 1;; 113 while (!fQueue.empty()); 114 fQueue.pop();; 115 }; 116 };; 117 ; 118 struct MasterConn {; 119 unsigned connid{0};; 120 int channel{-1};; 121 MasterConn(unsigned _connid, int _channel) : connid(_connid), channel(_channel) {}; 122 };; 123 ; 124 enum EQ",MatchSource.WIKI,doc/v632/RWebWindow_8hxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/RWebWindow_8hxx_source.html
https://root.cern/doc/v632/RWebWindow_8hxx_source.html:6326,Performance,perform,performed,6326," ///<! data for given connection; 130 QueueEntry() = default;; 131 QueueEntry(unsigned connid, EQueueEntryKind kind, std::string &&data) : fConnId(connid), fKind(kind), fData(data) {}; 132 };; 133 ; 134 using ConnectionsList_t = std::vector<std::shared_ptr<WebConn>>;; 135 ; 136 std::shared_ptr<RWebWindowsManager> fMgr; ///<! display manager; 137 std::shared_ptr<RWebWindow> fMaster; ///<! master window where this window is embedded; 138 std::vector<MasterConn> fMasterConns; ///<! master connections; 139 std::string fDefaultPage; ///<! HTML page (or file name) returned when window URL is opened; 140 std::string fPanelName; ///<! panel name which should be shown in the window; 141 unsigned fId{0}; ///<! unique identifier; 142 bool fUseServerThreads{false}; ///<! indicates that server thread is using, no special window thread; 143 bool fUseProcessEvents{false}; ///<! all window functionality will run through process events; 144 bool fProcessMT{false}; ///<! if window event processing performed in dedicated thread; 145 bool fSendMT{false}; ///<! true is special threads should be used for sending data; 146 bool fRequireAuthKey{true}; ///<! defines if authentication key always required when connect to the widget; 147 std::shared_ptr<RWebWindowWSHandler> fWSHandler; ///<! specialize websocket handler for all incoming connections; 148 unsigned fConnCnt{0}; ///<! counter of new connections to assign ids; 149 ConnectionsList_t fPendingConn; ///<! list of pending connection with pre-assigned keys; 150 ConnectionsList_t fConn; ///<! list of all accepted connections; 151 mutable std::mutex fConnMutex; ///<! mutex used to protect connection list; 152 unsigned fConnLimit{1}; ///<! number of allowed active connections; 153 std::string fConnToken; ///<! value of ""token"" URL parameter which should be provided for connecting window; 154 bool fNativeOnlyConn{false}; ///<! only native connection are allowed, created by Show() method; 155 bool fUseCurrentDir{false}; ///<! if window can ac",MatchSource.WIKI,doc/v632/RWebWindow_8hxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/RWebWindow_8hxx_source.html
https://root.cern/doc/v632/RWebWindow_8hxx_source.html:7443,Performance,queue,queue,7443,"l threads should be used for sending data; 146 bool fRequireAuthKey{true}; ///<! defines if authentication key always required when connect to the widget; 147 std::shared_ptr<RWebWindowWSHandler> fWSHandler; ///<! specialize websocket handler for all incoming connections; 148 unsigned fConnCnt{0}; ///<! counter of new connections to assign ids; 149 ConnectionsList_t fPendingConn; ///<! list of pending connection with pre-assigned keys; 150 ConnectionsList_t fConn; ///<! list of all accepted connections; 151 mutable std::mutex fConnMutex; ///<! mutex used to protect connection list; 152 unsigned fConnLimit{1}; ///<! number of allowed active connections; 153 std::string fConnToken; ///<! value of ""token"" URL parameter which should be provided for connecting window; 154 bool fNativeOnlyConn{false}; ///<! only native connection are allowed, created by Show() method; 155 bool fUseCurrentDir{false}; ///<! if window can access local files via currentdir/ path of http server; 156 unsigned fMaxQueueLength{10}; ///<! maximal number of queue entries; 157 WebWindowConnectCallback_t fConnCallback; ///<! callback for connect event; 158 WebWindowDataCallback_t fDataCallback; ///<! main callback when data over channel 1 is arrived; 159 WebWindowConnectCallback_t fDisconnCallback; ///<! callback for disconnect event; 160 std::thread::id fCallbacksThrdId; ///<! thread id where callbacks should be invoked; 161 bool fCallbacksThrdIdSet{false}; ///<! flag indicating that thread id is assigned; 162 bool fHasWindowThrd{false}; ///<! indicate if special window thread was started; 163 std::thread fWindowThrd; ///<! special thread for that window; 164 std::queue<QueueEntry> fInputQueue; ///<! input queue for all callbacks; 165 std::mutex fInputQueueMutex; ///<! mutex to protect input queue; 166 unsigned fWidth{0}, fHeight{0}; ///<! initial window width and height when displayed, zeros are ignored; 167 int fX{-1}, fY{-1}; ///<! initial window position, -1 ignored; 168 float fOperationTmout{50.",MatchSource.WIKI,doc/v632/RWebWindow_8hxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/RWebWindow_8hxx_source.html
https://root.cern/doc/v632/RWebWindow_8hxx_source.html:8061,Performance,queue,queue,8061,"l threads should be used for sending data; 146 bool fRequireAuthKey{true}; ///<! defines if authentication key always required when connect to the widget; 147 std::shared_ptr<RWebWindowWSHandler> fWSHandler; ///<! specialize websocket handler for all incoming connections; 148 unsigned fConnCnt{0}; ///<! counter of new connections to assign ids; 149 ConnectionsList_t fPendingConn; ///<! list of pending connection with pre-assigned keys; 150 ConnectionsList_t fConn; ///<! list of all accepted connections; 151 mutable std::mutex fConnMutex; ///<! mutex used to protect connection list; 152 unsigned fConnLimit{1}; ///<! number of allowed active connections; 153 std::string fConnToken; ///<! value of ""token"" URL parameter which should be provided for connecting window; 154 bool fNativeOnlyConn{false}; ///<! only native connection are allowed, created by Show() method; 155 bool fUseCurrentDir{false}; ///<! if window can access local files via currentdir/ path of http server; 156 unsigned fMaxQueueLength{10}; ///<! maximal number of queue entries; 157 WebWindowConnectCallback_t fConnCallback; ///<! callback for connect event; 158 WebWindowDataCallback_t fDataCallback; ///<! main callback when data over channel 1 is arrived; 159 WebWindowConnectCallback_t fDisconnCallback; ///<! callback for disconnect event; 160 std::thread::id fCallbacksThrdId; ///<! thread id where callbacks should be invoked; 161 bool fCallbacksThrdIdSet{false}; ///<! flag indicating that thread id is assigned; 162 bool fHasWindowThrd{false}; ///<! indicate if special window thread was started; 163 std::thread fWindowThrd; ///<! special thread for that window; 164 std::queue<QueueEntry> fInputQueue; ///<! input queue for all callbacks; 165 std::mutex fInputQueueMutex; ///<! mutex to protect input queue; 166 unsigned fWidth{0}, fHeight{0}; ///<! initial window width and height when displayed, zeros are ignored; 167 int fX{-1}, fY{-1}; ///<! initial window position, -1 ignored; 168 float fOperationTmout{50.",MatchSource.WIKI,doc/v632/RWebWindow_8hxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/RWebWindow_8hxx_source.html
https://root.cern/doc/v632/RWebWindow_8hxx_source.html:8104,Performance,queue,queue,8104,"l threads should be used for sending data; 146 bool fRequireAuthKey{true}; ///<! defines if authentication key always required when connect to the widget; 147 std::shared_ptr<RWebWindowWSHandler> fWSHandler; ///<! specialize websocket handler for all incoming connections; 148 unsigned fConnCnt{0}; ///<! counter of new connections to assign ids; 149 ConnectionsList_t fPendingConn; ///<! list of pending connection with pre-assigned keys; 150 ConnectionsList_t fConn; ///<! list of all accepted connections; 151 mutable std::mutex fConnMutex; ///<! mutex used to protect connection list; 152 unsigned fConnLimit{1}; ///<! number of allowed active connections; 153 std::string fConnToken; ///<! value of ""token"" URL parameter which should be provided for connecting window; 154 bool fNativeOnlyConn{false}; ///<! only native connection are allowed, created by Show() method; 155 bool fUseCurrentDir{false}; ///<! if window can access local files via currentdir/ path of http server; 156 unsigned fMaxQueueLength{10}; ///<! maximal number of queue entries; 157 WebWindowConnectCallback_t fConnCallback; ///<! callback for connect event; 158 WebWindowDataCallback_t fDataCallback; ///<! main callback when data over channel 1 is arrived; 159 WebWindowConnectCallback_t fDisconnCallback; ///<! callback for disconnect event; 160 std::thread::id fCallbacksThrdId; ///<! thread id where callbacks should be invoked; 161 bool fCallbacksThrdIdSet{false}; ///<! flag indicating that thread id is assigned; 162 bool fHasWindowThrd{false}; ///<! indicate if special window thread was started; 163 std::thread fWindowThrd; ///<! special thread for that window; 164 std::queue<QueueEntry> fInputQueue; ///<! input queue for all callbacks; 165 std::mutex fInputQueueMutex; ///<! mutex to protect input queue; 166 unsigned fWidth{0}, fHeight{0}; ///<! initial window width and height when displayed, zeros are ignored; 167 int fX{-1}, fY{-1}; ///<! initial window position, -1 ignored; 168 float fOperationTmout{50.",MatchSource.WIKI,doc/v632/RWebWindow_8hxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/RWebWindow_8hxx_source.html
https://root.cern/doc/v632/RWebWindow_8hxx_source.html:8191,Performance,queue,queue,8191,"l threads should be used for sending data; 146 bool fRequireAuthKey{true}; ///<! defines if authentication key always required when connect to the widget; 147 std::shared_ptr<RWebWindowWSHandler> fWSHandler; ///<! specialize websocket handler for all incoming connections; 148 unsigned fConnCnt{0}; ///<! counter of new connections to assign ids; 149 ConnectionsList_t fPendingConn; ///<! list of pending connection with pre-assigned keys; 150 ConnectionsList_t fConn; ///<! list of all accepted connections; 151 mutable std::mutex fConnMutex; ///<! mutex used to protect connection list; 152 unsigned fConnLimit{1}; ///<! number of allowed active connections; 153 std::string fConnToken; ///<! value of ""token"" URL parameter which should be provided for connecting window; 154 bool fNativeOnlyConn{false}; ///<! only native connection are allowed, created by Show() method; 155 bool fUseCurrentDir{false}; ///<! if window can access local files via currentdir/ path of http server; 156 unsigned fMaxQueueLength{10}; ///<! maximal number of queue entries; 157 WebWindowConnectCallback_t fConnCallback; ///<! callback for connect event; 158 WebWindowDataCallback_t fDataCallback; ///<! main callback when data over channel 1 is arrived; 159 WebWindowConnectCallback_t fDisconnCallback; ///<! callback for disconnect event; 160 std::thread::id fCallbacksThrdId; ///<! thread id where callbacks should be invoked; 161 bool fCallbacksThrdIdSet{false}; ///<! flag indicating that thread id is assigned; 162 bool fHasWindowThrd{false}; ///<! indicate if special window thread was started; 163 std::thread fWindowThrd; ///<! special thread for that window; 164 std::queue<QueueEntry> fInputQueue; ///<! input queue for all callbacks; 165 std::mutex fInputQueueMutex; ///<! mutex to protect input queue; 166 unsigned fWidth{0}, fHeight{0}; ///<! initial window width and height when displayed, zeros are ignored; 167 int fX{-1}, fY{-1}; ///<! initial window position, -1 ignored; 168 float fOperationTmout{50.",MatchSource.WIKI,doc/v632/RWebWindow_8hxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/RWebWindow_8hxx_source.html
https://root.cern/doc/v632/RWebWindow_8hxx_source.html:8434,Performance,perform,perform,8434,"ect event; 160 std::thread::id fCallbacksThrdId; ///<! thread id where callbacks should be invoked; 161 bool fCallbacksThrdIdSet{false}; ///<! flag indicating that thread id is assigned; 162 bool fHasWindowThrd{false}; ///<! indicate if special window thread was started; 163 std::thread fWindowThrd; ///<! special thread for that window; 164 std::queue<QueueEntry> fInputQueue; ///<! input queue for all callbacks; 165 std::mutex fInputQueueMutex; ///<! mutex to protect input queue; 166 unsigned fWidth{0}, fHeight{0}; ///<! initial window width and height when displayed, zeros are ignored; 167 int fX{-1}, fY{-1}; ///<! initial window position, -1 ignored; 168 float fOperationTmout{50.}; ///<! timeout in seconds to perform synchronous operation, default 50s; 169 std::string fClientVersion; ///<! configured client version, used as prefix in scripts URL; 170 std::string fProtocolFileName; ///<! local file where communication protocol will be written; 171 int fProtocolCnt{-1}; ///<! counter for protocol recording; 172 unsigned fProtocolConnId{0}; ///<! connection id, which is used for writing protocol; 173 std::string fProtocolPrefix; ///<! prefix for created files names; 174 std::string fProtocol; ///<! protocol; 175 std::string fUserArgs; ///<! arbitrary JSON code, which is accessible via conn.getUserArgs() method; 176 std::shared_ptr<void> fClearOnClose; ///<! entry which is cleared when last connection is closed; 177 ; 178 std::shared_ptr<RWebWindowWSHandler> CreateWSHandler(std::shared_ptr<RWebWindowsManager> mgr, unsigned id, double tmout);; 179 ; 180 bool ProcessWS(THttpCallArg &arg);; 181 ; 182 void CompleteWSSend(unsigned wsid);; 183 ; 184 ConnectionsList_t GetWindowConnections(unsigned connid = 0, bool only_active = false) const;; 185 ; 186 /// Find connection with specified websocket id; 187 std::shared_ptr<WebConn> FindConnection(unsigned wsid);; 188 ; 189 std::shared_ptr<WebConn> RemoveConnection(unsigned wsid);; 190 ; 191 bool _CanTrustIn(std::shared_ptr<WebC",MatchSource.WIKI,doc/v632/RWebWindow_8hxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/RWebWindow_8hxx_source.html
https://root.cern/doc/v632/RWebWindow_8hxx_source.html:13889,Performance,queue,queue,13889,"//////////////////////; 276 /// returns configured window width (0 - default); 277 /// actual window width can be different; 278 unsigned GetWidth() const { return fWidth; }; 279 ; 280 /////////////////////////////////////////////////////////////////////////; 281 /// returns configured window height (0 - default); 282 unsigned GetHeight() const { return fHeight; }; 283 ; 284 /////////////////////////////////////////////////////////////////////////; 285 /// returns configured window X position (-1 - default); 286 int GetX() const { return fX; }; 287 ; 288 /////////////////////////////////////////////////////////////////////////; 289 /// returns configured window Y position (-1 - default); 290 int GetY() const { return fY; }; 291 ; 292 void SetConnLimit(unsigned lmt = 0);; 293 ; 294 unsigned GetConnLimit() const;; 295 ; 296 void SetConnToken(const std::string &token = """");; 297 ; 298 /////////////////////////////////////////////////////////////////////////; 299 /// configures maximal queue length of data which can be held by window; 300 void SetMaxQueueLength(unsigned len = 10) { fMaxQueueLength = len; }; 301 ; 302 /////////////////////////////////////////////////////////////////////////; 303 /// Return maximal queue length of data which can be held by window; 304 unsigned GetMaxQueueLength() const { return fMaxQueueLength; }; 305 ; 306 /////////////////////////////////////////////////////////////////////////; 307 /// configures that only native (own-created) connections are allowed; 308 void SetNativeOnlyConn(bool on = true) { fNativeOnlyConn = on; }; 309 ; 310 /////////////////////////////////////////////////////////////////////////; 311 /// returns true if only native (own-created) connections are allowed; 312 bool IsNativeOnlyConn() const { return fNativeOnlyConn; }; 313 ; 314 /////////////////////////////////////////////////////////////////////////; 315 /// Configure if authentication key in connection string is required; 316 void SetRequireAuthKey(bool on) { fRe",MatchSource.WIKI,doc/v632/RWebWindow_8hxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/RWebWindow_8hxx_source.html
https://root.cern/doc/v632/RWebWindow_8hxx_source.html:14121,Performance,queue,queue,14121,"//////////////////////////; 281 /// returns configured window height (0 - default); 282 unsigned GetHeight() const { return fHeight; }; 283 ; 284 /////////////////////////////////////////////////////////////////////////; 285 /// returns configured window X position (-1 - default); 286 int GetX() const { return fX; }; 287 ; 288 /////////////////////////////////////////////////////////////////////////; 289 /// returns configured window Y position (-1 - default); 290 int GetY() const { return fY; }; 291 ; 292 void SetConnLimit(unsigned lmt = 0);; 293 ; 294 unsigned GetConnLimit() const;; 295 ; 296 void SetConnToken(const std::string &token = """");; 297 ; 298 /////////////////////////////////////////////////////////////////////////; 299 /// configures maximal queue length of data which can be held by window; 300 void SetMaxQueueLength(unsigned len = 10) { fMaxQueueLength = len; }; 301 ; 302 /////////////////////////////////////////////////////////////////////////; 303 /// Return maximal queue length of data which can be held by window; 304 unsigned GetMaxQueueLength() const { return fMaxQueueLength; }; 305 ; 306 /////////////////////////////////////////////////////////////////////////; 307 /// configures that only native (own-created) connections are allowed; 308 void SetNativeOnlyConn(bool on = true) { fNativeOnlyConn = on; }; 309 ; 310 /////////////////////////////////////////////////////////////////////////; 311 /// returns true if only native (own-created) connections are allowed; 312 bool IsNativeOnlyConn() const { return fNativeOnlyConn; }; 313 ; 314 /////////////////////////////////////////////////////////////////////////; 315 /// Configure if authentication key in connection string is required; 316 void SetRequireAuthKey(bool on) { fRequireAuthKey = on; }; 317 ; 318 /////////////////////////////////////////////////////////////////////////; 319 /// returns true if authentication string is required; 320 bool IsRequireAuthKey() const { return fRequireAuthKey; }; 321",MatchSource.WIKI,doc/v632/RWebWindow_8hxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/RWebWindow_8hxx_source.html
https://root.cern/doc/v632/RWebWindow_8hxx_source.html:21476,Performance,perform,performe,21476,"ption_t TPoint TPoint const char GetTextMagnitude GetFillStyle GetLineColor GetLineWidth GetMarkerStyle GetTextAlign GetTextColor GetTextSize void char Point_t Rectangle_t heightDefinition TGWin32VirtualXProxy.cxx:164; namechar name[80]Definition TGX11.cxx:110; ROOT::RFileDialogWeb-based FileDialog.Definition RFileDialog.hxx:41; ROOT::RWebDisplayArgsHolds different arguments for starting browser with RWebDisplayHandle::Display() method.Definition RWebDisplayArgs.hxx:33; ROOT::RWebDisplayHandleHandle of created web-based display Depending from type of web display, holds handle of started brows...Definition RWebDisplayHandle.hxx:25; ROOT::RWebWindowWSHandlerjust wrapper to deliver websockets call-backs to the RWebWindow classDefinition RWebWindowWSHandler.hxx:30; ROOT::RWebWindowRepresents web window, which can be shown in web browser or any other supported environment.Definition RWebWindow.hxx:52; ROOT::RWebWindow::CheckDataToSendbool CheckDataToSend(std::shared_ptr< WebConn > &conn)Checks if one should send data for specified connection Returns true when send operation was performe...Definition RWebWindow.cxx:1158; ROOT::RWebWindow::fDefaultPagestd::string fDefaultPage! HTML page (or file name) returned when window URL is openedDefinition RWebWindow.hxx:139; ROOT::RWebWindow::WaitForint WaitFor(WebWindowWaitFunc_t check)Waits until provided check function or lambdas returns non-zero value Check function has following si...Definition RWebWindow.cxx:1789; ROOT::RWebWindow::GetIdunsigned GetId() constReturns ID for the window - unique inside window manager.Definition RWebWindow.hxx:248; ROOT::RWebWindow::GetMasterConnectionsstd::vector< MasterConn > GetMasterConnections(unsigned connid=0) constGet list of master connections.Definition RWebWindow.cxx:325; ROOT::RWebWindow::AddMasterConnectionvoid AddMasterConnection(std::shared_ptr< RWebWindow > window, unsigned connid, int channel)Add new master connection If there are many connections - only same master is allowed.Defi",MatchSource.WIKI,doc/v632/RWebWindow_8hxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/RWebWindow_8hxx_source.html
https://root.cern/doc/v632/RWebWindow_8hxx_source.html:24534,Performance,queue,queue,24534,"ndow to handle all callbacks One has to be sure,...Definition RWebWindow.cxx:1680; ROOT::RWebWindow::fConnCntunsigned fConnCnt! counter of new connections to assign idsDefinition RWebWindow.hxx:148; ROOT::RWebWindow::fProtocolConnIdunsigned fProtocolConnId! connection id, which is used for writing protocolDefinition RWebWindow.hxx:172; ROOT::RWebWindow::GetWindowConnectionsConnectionsList_t GetWindowConnections(unsigned connid=0, bool only_active=false) constreturns connection list (or all active connections)Definition RWebWindow.cxx:1458; ROOT::RWebWindow::fSendMTbool fSendMT! true is special threads should be used for sending dataDefinition RWebWindow.hxx:145; ROOT::RWebWindow::fCallbacksThrdIdstd::thread::id fCallbacksThrdId! thread id where callbacks should be invokedDefinition RWebWindow.hxx:160; ROOT::RWebWindow::RemoveKeyvoid RemoveKey(const std::string &key)Removes all connections with the key.Definition RWebWindow.cxx:583; ROOT::RWebWindow::fInputQueuestd::queue< QueueEntry > fInputQueue! input queue for all callbacksDefinition RWebWindow.hxx:164; ROOT::RWebWindow::_CanTrustInbool _CanTrustIn(std::shared_ptr< WebConn > &conn, const std::string &key, const std::string &ntry, bool remote, bool test_first_time)Check if provided hash, ntry parameters from the connection request could be accepted.Definition RWebWindow.cxx:513; ROOT::RWebWindow::SetConnTokenvoid SetConnToken(const std::string &token="""")Configures connection token (default none) When specified, in URL of webpage such token should be pro...Definition RWebWindow.cxx:715; ROOT::RWebWindow::MakeHeadlessunsigned MakeHeadless(bool create_new=false)Start headless browser for specified window Normally only single instance is used,...Definition RWebWindow.cxx:202; ROOT::RWebWindow::GetUrlstd::string GetUrl(bool remote=true)Return URL string to connect web window URL typically includes extra parameters required for connecti...Definition RWebWindow.cxx:173; ROOT::RWebWindow::CloseConnectionsvoid CloseConnecti",MatchSource.WIKI,doc/v632/RWebWindow_8hxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/RWebWindow_8hxx_source.html
https://root.cern/doc/v632/RWebWindow_8hxx_source.html:24573,Performance,queue,queue,24573,"ndow to handle all callbacks One has to be sure,...Definition RWebWindow.cxx:1680; ROOT::RWebWindow::fConnCntunsigned fConnCnt! counter of new connections to assign idsDefinition RWebWindow.hxx:148; ROOT::RWebWindow::fProtocolConnIdunsigned fProtocolConnId! connection id, which is used for writing protocolDefinition RWebWindow.hxx:172; ROOT::RWebWindow::GetWindowConnectionsConnectionsList_t GetWindowConnections(unsigned connid=0, bool only_active=false) constreturns connection list (or all active connections)Definition RWebWindow.cxx:1458; ROOT::RWebWindow::fSendMTbool fSendMT! true is special threads should be used for sending dataDefinition RWebWindow.hxx:145; ROOT::RWebWindow::fCallbacksThrdIdstd::thread::id fCallbacksThrdId! thread id where callbacks should be invokedDefinition RWebWindow.hxx:160; ROOT::RWebWindow::RemoveKeyvoid RemoveKey(const std::string &key)Removes all connections with the key.Definition RWebWindow.cxx:583; ROOT::RWebWindow::fInputQueuestd::queue< QueueEntry > fInputQueue! input queue for all callbacksDefinition RWebWindow.hxx:164; ROOT::RWebWindow::_CanTrustInbool _CanTrustIn(std::shared_ptr< WebConn > &conn, const std::string &key, const std::string &ntry, bool remote, bool test_first_time)Check if provided hash, ntry parameters from the connection request could be accepted.Definition RWebWindow.cxx:513; ROOT::RWebWindow::SetConnTokenvoid SetConnToken(const std::string &token="""")Configures connection token (default none) When specified, in URL of webpage such token should be pro...Definition RWebWindow.cxx:715; ROOT::RWebWindow::MakeHeadlessunsigned MakeHeadless(bool create_new=false)Start headless browser for specified window Normally only single instance is used,...Definition RWebWindow.cxx:202; ROOT::RWebWindow::GetUrlstd::string GetUrl(bool remote=true)Return URL string to connect web window URL typically includes extra parameters required for connecti...Definition RWebWindow.cxx:173; ROOT::RWebWindow::CloseConnectionsvoid CloseConnecti",MatchSource.WIKI,doc/v632/RWebWindow_8hxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/RWebWindow_8hxx_source.html
https://root.cern/doc/v632/RWebWindow_8hxx_source.html:31412,Performance,perform,perform,31412,"ebWindow.cxx:374; ROOT::RWebWindow::SetOperationTmoutvoid SetOperationTmout(float tm=50.)Set timeout for synchronous WebWindow operations.Definition RWebWindow.hxx:354; ROOT::RWebWindow::AddEmbedWindowunsigned AddEmbedWindow(std::shared_ptr< RWebWindow > window, unsigned connid, int channel)Add embed window.Definition RWebWindow.cxx:1846; ROOT::RWebWindow::SetDisconnectCallBackvoid SetDisconnectCallBack(WebWindowConnectCallback_t func)Set call-back function for disconnecting.Definition RWebWindow.cxx:1753; ROOT::RWebWindow::GetConnectionsstd::vector< unsigned > GetConnections(unsigned excludeid=0) constreturns vector with all existing connections ids One also can exclude specified connection from retur...Definition RWebWindow.cxx:1387; ROOT::RWebWindow::SetDataCallBackvoid SetDataCallBack(WebWindowDataCallback_t func)Set call-back function for data, received from the clients via websocket.Definition RWebWindow.cxx:1733; ROOT::RWebWindow::fOperationTmoutfloat fOperationTmout! timeout in seconds to perform synchronous operation, default 50sDefinition RWebWindow.hxx:168; ROOT::RWebWindow::fRequireAuthKeybool fRequireAuthKey! defines if authentication key always required when connect to the widgetDefinition RWebWindow.hxx:146; ROOT::RWebWindow::gStartDialogFuncstatic std::function< bool(const std::shared_ptr< RWebWindow > &, unsigned, const std::string &)> gStartDialogFuncDefinition RWebWindow.hxx:235; ROOT::RWebWindow::SetUserArgsvoid SetUserArgs(const std::string &args)Set arbitrary JSON data, which is accessible via conn.getUserArgs() method in JavaScript This JSON co...Definition RWebWindow.cxx:1310; ROOT::RWebWindow::fConnTokenstd::string fConnToken! value of ""token"" URL parameter which should be provided for connecting windowDefinition RWebWindow.hxx:153; ROOT::RWebWindow::GetHeightunsigned GetHeight() constreturns configured window height (0 - default)Definition RWebWindow.hxx:282; ROOT::RWebWindow::ShowWindowstatic unsigned ShowWindow(std::shared_ptr< RWebWindow",MatchSource.WIKI,doc/v632/RWebWindow_8hxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/RWebWindow_8hxx_source.html
https://root.cern/doc/v632/RWebWindow_8hxx_source.html:35740,Performance,queue,queue,35740,"const std::string &name)Configure window to show some of existing JSROOT panels It uses ""file:rootui5sys/panel/panel....Definition RWebWindow.cxx:132; ROOT::RWebWindow::SetPositionvoid SetPosition(unsigned x, unsigned y)Set window position. Will be applied if supported by used web display (like CEF or Chromium)Definition RWebWindow.hxx:269; ROOT::RWebWindow::IsRequireAuthKeybool IsRequireAuthKey() constreturns true if authentication string is requiredDefinition RWebWindow.hxx:320; ROOT::RWebWindow::RWebWindowRWebWindow()RWebWindow constructor Should be defined here because of std::unique_ptr<RWebWindowWSHandler>Definition RWebWindow.cxx:76; ROOT::RWebWindow::SetNativeOnlyConnvoid SetNativeOnlyConn(bool on=true)configures that only native (own-created) connections are allowedDefinition RWebWindow.hxx:308; ROOT::RWebWindow::fProtocolPrefixstd::string fProtocolPrefix! prefix for created files namesDefinition RWebWindow.hxx:173; ROOT::RWebWindow::GetSendQueueLengthint GetSendQueueLength(unsigned connid) constReturns send queue length for specified connection.Definition RWebWindow.cxx:1509; ROOT::RWebWindow::RemoveConnectionstd::shared_ptr< WebConn > RemoveConnection(unsigned wsid)Remove connection with given websocket id.Definition RWebWindow.cxx:279; ROOT::RWebWindow::CreateWSHandlerstd::shared_ptr< RWebWindowWSHandler > CreateWSHandler(std::shared_ptr< RWebWindowsManager > mgr, unsigned id, double tmout)Assigns manager reference, window id and creates websocket handler, used for communication with the c...Definition RWebWindow.cxx:152; ROOT::RWebWindow::fProtocolstd::string fProtocol! protocolDefinition RWebWindow.hxx:174; ROOT::RWebWindow::CanSendbool CanSend(unsigned connid, bool direct=true) constReturns true if sending via specified connection can be performed.Definition RWebWindow.cxx:1484; ROOT::RWebWindow::GetUserArgsstd::string GetUserArgs() constReturns configured user arguments for web window See SetUserArgs method for more details.Definition RWebWindow.cxx:1",MatchSource.WIKI,doc/v632/RWebWindow_8hxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/RWebWindow_8hxx_source.html
https://root.cern/doc/v632/RWebWindow_8hxx_source.html:36490,Performance,perform,performed,36490,"rue)configures that only native (own-created) connections are allowedDefinition RWebWindow.hxx:308; ROOT::RWebWindow::fProtocolPrefixstd::string fProtocolPrefix! prefix for created files namesDefinition RWebWindow.hxx:173; ROOT::RWebWindow::GetSendQueueLengthint GetSendQueueLength(unsigned connid) constReturns send queue length for specified connection.Definition RWebWindow.cxx:1509; ROOT::RWebWindow::RemoveConnectionstd::shared_ptr< WebConn > RemoveConnection(unsigned wsid)Remove connection with given websocket id.Definition RWebWindow.cxx:279; ROOT::RWebWindow::CreateWSHandlerstd::shared_ptr< RWebWindowWSHandler > CreateWSHandler(std::shared_ptr< RWebWindowsManager > mgr, unsigned id, double tmout)Assigns manager reference, window id and creates websocket handler, used for communication with the c...Definition RWebWindow.cxx:152; ROOT::RWebWindow::fProtocolstd::string fProtocol! protocolDefinition RWebWindow.hxx:174; ROOT::RWebWindow::CanSendbool CanSend(unsigned connid, bool direct=true) constReturns true if sending via specified connection can be performed.Definition RWebWindow.cxx:1484; ROOT::RWebWindow::GetUserArgsstd::string GetUserArgs() constReturns configured user arguments for web window See SetUserArgs method for more details.Definition RWebWindow.cxx:1320; ROOT::RWebWindow::RecordDatavoid RecordData(const std::string &fname=""protocol.json"", const std::string &fprefix="""")Configures recording of communication data in protocol file Provided filename will be used to store J...Definition RWebWindow.cxx:1355; ROOT::RWebWindow::fUseProcessEventsbool fUseProcessEvents! all window functionality will run through process eventsDefinition RWebWindow.hxx:143; ROOT::RWebWindow::GetDisplayConnectionunsigned GetDisplayConnection() constReturns first connection id where window is displayed It could be that connection(s) not yet fully es...Definition RWebWindow.cxx:244; ROOT::RWebWindow::fMaxQueueLengthunsigned fMaxQueueLength! maximal number of queue entriesDefinition RW",MatchSource.WIKI,doc/v632/RWebWindow_8hxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/RWebWindow_8hxx_source.html
https://root.cern/doc/v632/RWebWindow_8hxx_source.html:37398,Performance,queue,queue,37398,"::CanSendbool CanSend(unsigned connid, bool direct=true) constReturns true if sending via specified connection can be performed.Definition RWebWindow.cxx:1484; ROOT::RWebWindow::GetUserArgsstd::string GetUserArgs() constReturns configured user arguments for web window See SetUserArgs method for more details.Definition RWebWindow.cxx:1320; ROOT::RWebWindow::RecordDatavoid RecordData(const std::string &fname=""protocol.json"", const std::string &fprefix="""")Configures recording of communication data in protocol file Provided filename will be used to store J...Definition RWebWindow.cxx:1355; ROOT::RWebWindow::fUseProcessEventsbool fUseProcessEvents! all window functionality will run through process eventsDefinition RWebWindow.hxx:143; ROOT::RWebWindow::GetDisplayConnectionunsigned GetDisplayConnection() constReturns first connection id where window is displayed It could be that connection(s) not yet fully es...Definition RWebWindow.cxx:244; ROOT::RWebWindow::fMaxQueueLengthunsigned fMaxQueueLength! maximal number of queue entriesDefinition RWebWindow.hxx:156; ROOT::RWebWindow::fXint fXDefinition RWebWindow.hxx:167; ROOT::RWebWindow::GetConnLimitunsigned GetConnLimit() constreturns configured connections limit (0 - default)Definition RWebWindow.cxx:703; ROOT::RWebWindow::GetRelativeAddrstd::string GetRelativeAddr(const std::shared_ptr< RWebWindow > &win) constReturns relative URL address for the specified window Address can be required if one needs to access ...Definition RWebWindow.cxx:1260; ROOT::RWebWindow::SetStartDialogFuncstatic void SetStartDialogFunc(std::function< bool(const std::shared_ptr< RWebWindow > &, unsigned, const std::string &)>)Configure func which has to be used for starting dialog.Definition RWebWindow.cxx:1953; ROOT::RWebWindow::fPanelNamestd::string fPanelName! panel name which should be shown in the windowDefinition RWebWindow.hxx:140; ROOT::RWebWindow::Runvoid Run(double tm=0.)Run window functionality for specified time If no action can be performe",MatchSource.WIKI,doc/v632/RWebWindow_8hxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/RWebWindow_8hxx_source.html
https://root.cern/doc/v632/RWebWindow_8hxx_source.html:38365,Performance,perform,performed,38365,"gthunsigned fMaxQueueLength! maximal number of queue entriesDefinition RWebWindow.hxx:156; ROOT::RWebWindow::fXint fXDefinition RWebWindow.hxx:167; ROOT::RWebWindow::GetConnLimitunsigned GetConnLimit() constreturns configured connections limit (0 - default)Definition RWebWindow.cxx:703; ROOT::RWebWindow::GetRelativeAddrstd::string GetRelativeAddr(const std::shared_ptr< RWebWindow > &win) constReturns relative URL address for the specified window Address can be required if one needs to access ...Definition RWebWindow.cxx:1260; ROOT::RWebWindow::SetStartDialogFuncstatic void SetStartDialogFunc(std::function< bool(const std::shared_ptr< RWebWindow > &, unsigned, const std::string &)>)Configure func which has to be used for starting dialog.Definition RWebWindow.cxx:1953; ROOT::RWebWindow::fPanelNamestd::string fPanelName! panel name which should be shown in the windowDefinition RWebWindow.hxx:140; ROOT::RWebWindow::Runvoid Run(double tm=0.)Run window functionality for specified time If no action can be performed - just sleep specified time...Definition RWebWindow.cxx:1827; ROOT::RWebWindow::fHeightunsigned fHeight! initial window width and height when displayed, zeros are ignoredDefinition RWebWindow.hxx:166; ROOT::RWebWindow::GetAddrstd::string GetAddr() constReturns window address which is used in URL.Definition RWebWindow.cxx:1250; ROOT::RWebWindow::fMgrstd::shared_ptr< RWebWindowsManager > fMgr! display managerDefinition RWebWindow.hxx:136; ROOT::RWebWindow::fProtocolFileNamestd::string fProtocolFileName! local file where communication protocol will be writtenDefinition RWebWindow.hxx:170; ROOT::RWebWindow::GetYint GetY() constreturns configured window Y position (-1 - default)Definition RWebWindow.hxx:290; ROOT::RWebWindow::fNativeOnlyConnbool fNativeOnlyConn! only native connection are allowed, created by Show() methodDefinition RWebWindow.hxx:154; ROOT::RWebWindow::GetManagerstd::shared_ptr< RWebWindowsManager > GetManager() constReturns window manager.Definition ",MatchSource.WIKI,doc/v632/RWebWindow_8hxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/RWebWindow_8hxx_source.html
https://root.cern/doc/v632/RWebWindow_8hxx_source.html:40005,Performance,queue,queueDefinition,40005,"T::RWebWindow::GetYint GetY() constreturns configured window Y position (-1 - default)Definition RWebWindow.hxx:290; ROOT::RWebWindow::fNativeOnlyConnbool fNativeOnlyConn! only native connection are allowed, created by Show() methodDefinition RWebWindow.hxx:154; ROOT::RWebWindow::GetManagerstd::shared_ptr< RWebWindowsManager > GetManager() constReturns window manager.Definition RWebWindow.hxx:251; ROOT::RWebWindow::fConnConnectionsList_t fConn! list of all accepted connectionsDefinition RWebWindow.hxx:150; ROOT::RWebWindow::fConnCallbackWebWindowConnectCallback_t fConnCallback! callback for connect eventDefinition RWebWindow.hxx:157; ROOT::RWebWindow::CheckPendingConnectionsvoid CheckPendingConnections()Check if started process(es) establish connection.Definition RWebWindow.cxx:624; ROOT::RWebWindow::fClearOnClosestd::shared_ptr< void > fClearOnClose! entry which is cleared when last connection is closedDefinition RWebWindow.hxx:176; ROOT::RWebWindow::fInputQueueMutexstd::mutex fInputQueueMutex! mutex to protect input queueDefinition RWebWindow.hxx:165; ROOT::RWebWindow::_MakeSendHeaderstd::string _MakeSendHeader(std::shared_ptr< WebConn > &conn, bool txt, const std::string &data, int chid)Internal method to prepare text part of send data Should be called under locked connection mutex.Definition RWebWindow.cxx:1107; ROOT::RWebWindow::timestamp_tstd::chrono::time_point< std::chrono::system_clock > timestamp_tDefinition RWebWindow.hxx:60; ROOT::RWebWindow::SetMaxQueueLengthvoid SetMaxQueueLength(unsigned len=10)configures maximal queue length of data which can be held by windowDefinition RWebWindow.hxx:300; ROOT::RWebWindow::ProcessWSbool ProcessWS(THttpCallArg &arg)Processing of websockets call-backs, invoked from RWebWindowWSHandler Method invoked from http server...Definition RWebWindow.cxx:736; ROOT::RWebWindow::HasConnectionbool HasConnection(unsigned connid=0, bool only_active=true) constreturns true if specified connection id existsDefinition RWebWindow.cxx:141",MatchSource.WIKI,doc/v632/RWebWindow_8hxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/RWebWindow_8hxx_source.html
https://root.cern/doc/v632/RWebWindow_8hxx_source.html:40525,Performance,queue,queue,40525,"lbackWebWindowConnectCallback_t fConnCallback! callback for connect eventDefinition RWebWindow.hxx:157; ROOT::RWebWindow::CheckPendingConnectionsvoid CheckPendingConnections()Check if started process(es) establish connection.Definition RWebWindow.cxx:624; ROOT::RWebWindow::fClearOnClosestd::shared_ptr< void > fClearOnClose! entry which is cleared when last connection is closedDefinition RWebWindow.hxx:176; ROOT::RWebWindow::fInputQueueMutexstd::mutex fInputQueueMutex! mutex to protect input queueDefinition RWebWindow.hxx:165; ROOT::RWebWindow::_MakeSendHeaderstd::string _MakeSendHeader(std::shared_ptr< WebConn > &conn, bool txt, const std::string &data, int chid)Internal method to prepare text part of send data Should be called under locked connection mutex.Definition RWebWindow.cxx:1107; ROOT::RWebWindow::timestamp_tstd::chrono::time_point< std::chrono::system_clock > timestamp_tDefinition RWebWindow.hxx:60; ROOT::RWebWindow::SetMaxQueueLengthvoid SetMaxQueueLength(unsigned len=10)configures maximal queue length of data which can be held by windowDefinition RWebWindow.hxx:300; ROOT::RWebWindow::ProcessWSbool ProcessWS(THttpCallArg &arg)Processing of websockets call-backs, invoked from RWebWindowWSHandler Method invoked from http server...Definition RWebWindow.cxx:736; ROOT::RWebWindow::HasConnectionbool HasConnection(unsigned connid=0, bool only_active=true) constreturns true if specified connection id existsDefinition RWebWindow.cxx:1413; ROOT::RWebWindow::GetWidthunsigned GetWidth() constreturns configured window width (0 - default) actual window width can be differentDefinition RWebWindow.hxx:278; ROOT::RWebWindow::fWindowThrdstd::thread fWindowThrd! special thread for that windowDefinition RWebWindow.hxx:163; ROOT::RWebWindow::ProvideQueueEntryvoid ProvideQueueEntry(unsigned connid, EQueueEntryKind kind, std::string &&arg)Provide data to user callback User callback must be executed in the window thread.Definition RWebWindow.cxx:421; ROOT::RWebWindow::HasKeybool ",MatchSource.WIKI,doc/v632/RWebWindow_8hxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/RWebWindow_8hxx_source.html
https://root.cern/doc/v632/RWebWindow_8hxx_source.html:42722,Performance,perform,performed,42722,"OOT::RWebWindow::CompleteWSSendvoid CompleteWSSend(unsigned wsid)Complete websocket send operation Clear ""doing send"" flag and check if next operation has to be start...Definition RWebWindow.cxx:1088; ROOT::RWebWindow::IsUseCurrentDirbool IsUseCurrentDir() constreturns true if window can access local files via currentdir/ path of http serverDefinition RWebWindow.hxx:328; ROOT::RWebWindow::fUseServerThreadsbool fUseServerThreads! indicates that server thread is using, no special window threadDefinition RWebWindow.hxx:142; ROOT::RWebWindow::FindHeadlessConnectionunsigned FindHeadlessConnection()Returns connection id of window running in headless mode This can be special connection which may run...Definition RWebWindow.cxx:221; ROOT::RWebWindow::WaitForTimedint WaitForTimed(WebWindowWaitFunc_t check)Waits until provided check function or lambdas returns non-zero value Check function has following si...Definition RWebWindow.cxx:1803; ROOT::RWebWindow::fProcessMTbool fProcessMT! if window event processing performed in dedicated threadDefinition RWebWindow.hxx:144; ROOT::RWebWindow::fProtocolCntint fProtocolCnt! counter for protocol recordingDefinition RWebWindow.hxx:171; ROOT::RWebWindow::SetClientVersionvoid SetClientVersion(const std::string &vers)Set client version, used as prefix in scripts URL When changed, web browser will reload all related J...Definition RWebWindow.cxx:1289; ROOT::RWebWindow::RemoveMasterConnectionvoid RemoveMasterConnection(unsigned connid=0)Remove master connection - if any.Definition RWebWindow.cxx:343; ROOT::RWebWindow::RemoveEmbedWindowvoid RemoveEmbedWindow(unsigned connid, int channel)Remove RWebWindow associated with the channelfEmbed.Definition RWebWindow.cxx:1867; ROOT::RWebWindow::SetCallBacksvoid SetCallBacks(WebWindowConnectCallback_t conn, WebWindowDataCallback_t data, WebWindowConnectCallback_t disconn=nullptr)Set call-backs function for connect, data and disconnect events.Definition RWebWindow.cxx:1772; ROOT::RWebWindow::SetRequire",MatchSource.WIKI,doc/v632/RWebWindow_8hxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/RWebWindow_8hxx_source.html
https://root.cern/doc/v632/RWebWindow_8hxx_source.html:44373,Performance,queue,queue,44373," RWebWindow associated with the channelfEmbed.Definition RWebWindow.cxx:1867; ROOT::RWebWindow::SetCallBacksvoid SetCallBacks(WebWindowConnectCallback_t conn, WebWindowDataCallback_t data, WebWindowConnectCallback_t disconn=nullptr)Set call-backs function for connect, data and disconnect events.Definition RWebWindow.cxx:1772; ROOT::RWebWindow::SetRequireAuthKeyvoid SetRequireAuthKey(bool on)Configure if authentication key in connection string is required.Definition RWebWindow.hxx:316; ROOT::RWebWindow::GenerateKeystd::string GenerateKey() constGenerate new unique key for the window.Definition RWebWindow.cxx:611; ROOT::RWebWindow::SetUseCurrentDirvoid SetUseCurrentDir(bool on=true)Configure if window can access local files via currentdir/ path of http server.Definition RWebWindow.hxx:324; ROOT::RWebWindow::fDisconnCallbackWebWindowConnectCallback_t fDisconnCallback! callback for disconnect eventDefinition RWebWindow.hxx:159; ROOT::RWebWindow::GetMaxQueueLengthunsigned GetMaxQueueLength() constReturn maximal queue length of data which can be held by window.Definition RWebWindow.hxx:304; ROOT::RWebWindow::EQueueEntryKindEQueueEntryKindDefinition RWebWindow.hxx:124; ROOT::RWebWindow::kind_Disconnect@ kind_DisconnectDefinition RWebWindow.hxx:124; ROOT::RWebWindow::kind_Connect@ kind_ConnectDefinition RWebWindow.hxx:124; ROOT::RWebWindow::kind_None@ kind_NoneDefinition RWebWindow.hxx:124; ROOT::RWebWindow::kind_Data@ kind_DataDefinition RWebWindow.hxx:124; ROOT::RWebWindow::IsFileDialogMessagestatic bool IsFileDialogMessage(const std::string &msg)Check if this could be the message send by client to start new file dialog If returns true,...Definition RWebWindow.cxx:1963; ROOT::RWebWindowsManagerCentral instance to create and show web-based windows like Canvas or FitPanel.Definition RWebWindowsManager.hxx:36; THttpCallArgContains arguments for single HTTP call.Definition THttpCallArg.h:27; THttpServerOnline http server for arbitrary ROOT application.Definition THttpServer.h",MatchSource.WIKI,doc/v632/RWebWindow_8hxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/RWebWindow_8hxx_source.html
https://root.cern/doc/v632/RWebWindow_8hxx_source.html:49756,Performance,perform,performing,49756,"bConn::fEmbedstd::map< int, std::shared_ptr< RWebWindow > > fEmbed! map of embed window for that connection, key value is channel idDefinition RWebWindow.hxx:90; ROOT::RWebWindow::WebConn::fKeystd::string fKey! key value supplied to the window (when exists)Definition RWebWindow.hxx:72; ROOT::RWebWindow::WebConn::WebConnWebConn(unsigned connid, bool headless_mode, const std::string &key)Definition RWebWindow.hxx:94; ROOT::RWebWindow::WebConn::fSendSequnsigned long fSendSeq! sequence id of last send packetDefinition RWebWindow.hxx:88; ROOT::RWebWindow::WebConn::fKeyUsedint fKeyUsed! key value used to verify connectionDefinition RWebWindow.hxx:73; ROOT::RWebWindow::WebConn::~WebConn~WebConn()Destructor for WebConn Notify special HTTP request which blocks headless browser from exit.Definition RWebWindow.cxx:42; ROOT::RWebWindow::WebConn::fMutexstd::mutex fMutex! mutex must be used to protect all following dataDefinition RWebWindow.hxx:81; ROOT::RWebWindow::WebConn::fDoingSendbool fDoingSend! true when performing send operationDefinition RWebWindow.hxx:86; ROOT::RWebWindow::WebConn::fSendCreditsint fSendCredits! how many send operation can be performed without confirmation from other sideDefinition RWebWindow.hxx:84; ROOT::RWebWindow::WebConn::WebConnWebConn(unsigned connid, unsigned wsid)Definition RWebWindow.hxx:93; ROOT::RWebWindow::WebConn::fNewKeystd::string fNewKey! new key if connection request reloadDefinition RWebWindow.hxx:74; ROOT::RWebWindow::WebConn::fWSIdunsigned fWSId! websocket idDefinition RWebWindow.hxx:79; ROOT::RWebWindow::WebConn::fSendStamptimestamp_t fSendStamp! last server operation, always used from window threadDefinition RWebWindow.hxx:77; ROOT::RWebWindow::WebConn::fRecvStamptimestamp_t fRecvStamp! last receive operation, protected with connection mutexDefinition RWebWindow.hxx:82; ROOT::RWebWindow::WebConn::fRecvCountint fRecvCount! number of received packets, should return back with next sendingDefinition RWebWindow.hxx:83; ROOT::RWebWindow::",MatchSource.WIKI,doc/v632/RWebWindow_8hxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/RWebWindow_8hxx_source.html
https://root.cern/doc/v632/RWebWindow_8hxx_source.html:49899,Performance,perform,performed,49899," RWebWindow.hxx:90; ROOT::RWebWindow::WebConn::fKeystd::string fKey! key value supplied to the window (when exists)Definition RWebWindow.hxx:72; ROOT::RWebWindow::WebConn::WebConnWebConn(unsigned connid, bool headless_mode, const std::string &key)Definition RWebWindow.hxx:94; ROOT::RWebWindow::WebConn::fSendSequnsigned long fSendSeq! sequence id of last send packetDefinition RWebWindow.hxx:88; ROOT::RWebWindow::WebConn::fKeyUsedint fKeyUsed! key value used to verify connectionDefinition RWebWindow.hxx:73; ROOT::RWebWindow::WebConn::~WebConn~WebConn()Destructor for WebConn Notify special HTTP request which blocks headless browser from exit.Definition RWebWindow.cxx:42; ROOT::RWebWindow::WebConn::fMutexstd::mutex fMutex! mutex must be used to protect all following dataDefinition RWebWindow.hxx:81; ROOT::RWebWindow::WebConn::fDoingSendbool fDoingSend! true when performing send operationDefinition RWebWindow.hxx:86; ROOT::RWebWindow::WebConn::fSendCreditsint fSendCredits! how many send operation can be performed without confirmation from other sideDefinition RWebWindow.hxx:84; ROOT::RWebWindow::WebConn::WebConnWebConn(unsigned connid, unsigned wsid)Definition RWebWindow.hxx:93; ROOT::RWebWindow::WebConn::fNewKeystd::string fNewKey! new key if connection request reloadDefinition RWebWindow.hxx:74; ROOT::RWebWindow::WebConn::fWSIdunsigned fWSId! websocket idDefinition RWebWindow.hxx:79; ROOT::RWebWindow::WebConn::fSendStamptimestamp_t fSendStamp! last server operation, always used from window threadDefinition RWebWindow.hxx:77; ROOT::RWebWindow::WebConn::fRecvStamptimestamp_t fRecvStamp! last receive operation, protected with connection mutexDefinition RWebWindow.hxx:82; ROOT::RWebWindow::WebConn::fRecvCountint fRecvCount! number of received packets, should return back with next sendingDefinition RWebWindow.hxx:83; ROOT::RWebWindow::WebConn::ResetStampsvoid ResetStamps()Definition RWebWindow.hxx:101; ROOT::RWebWindow::WebConn::fQueuestd::queue< QueueItem > fQueue! output ",MatchSource.WIKI,doc/v632/RWebWindow_8hxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/RWebWindow_8hxx_source.html
https://root.cern/doc/v632/RWebWindow_8hxx_source.html:50851,Performance,queue,queue,50851,"ast send packetDefinition RWebWindow.hxx:88; ROOT::RWebWindow::WebConn::fKeyUsedint fKeyUsed! key value used to verify connectionDefinition RWebWindow.hxx:73; ROOT::RWebWindow::WebConn::~WebConn~WebConn()Destructor for WebConn Notify special HTTP request which blocks headless browser from exit.Definition RWebWindow.cxx:42; ROOT::RWebWindow::WebConn::fMutexstd::mutex fMutex! mutex must be used to protect all following dataDefinition RWebWindow.hxx:81; ROOT::RWebWindow::WebConn::fDoingSendbool fDoingSend! true when performing send operationDefinition RWebWindow.hxx:86; ROOT::RWebWindow::WebConn::fSendCreditsint fSendCredits! how many send operation can be performed without confirmation from other sideDefinition RWebWindow.hxx:84; ROOT::RWebWindow::WebConn::WebConnWebConn(unsigned connid, unsigned wsid)Definition RWebWindow.hxx:93; ROOT::RWebWindow::WebConn::fNewKeystd::string fNewKey! new key if connection request reloadDefinition RWebWindow.hxx:74; ROOT::RWebWindow::WebConn::fWSIdunsigned fWSId! websocket idDefinition RWebWindow.hxx:79; ROOT::RWebWindow::WebConn::fSendStamptimestamp_t fSendStamp! last server operation, always used from window threadDefinition RWebWindow.hxx:77; ROOT::RWebWindow::WebConn::fRecvStamptimestamp_t fRecvStamp! last receive operation, protected with connection mutexDefinition RWebWindow.hxx:82; ROOT::RWebWindow::WebConn::fRecvCountint fRecvCount! number of received packets, should return back with next sendingDefinition RWebWindow.hxx:83; ROOT::RWebWindow::WebConn::ResetStampsvoid ResetStamps()Definition RWebWindow.hxx:101; ROOT::RWebWindow::WebConn::fQueuestd::queue< QueueItem > fQueue! output queueDefinition RWebWindow.hxx:89; ROOT::RWebWindow::WebConn::fDisplayHandlestd::unique_ptr< RWebDisplayHandle > fDisplayHandle! handle assigned with started web display (when exists)Definition RWebWindow.hxx:75. guiwebdisplayincROOTRWebWindow.hxx. ROOT v6-32 - Reference Guide Generated on Fri Nov 1 2024 15:08:10 (GVA Time) using Doxygen 1.9.8 ; . ",MatchSource.WIKI,doc/v632/RWebWindow_8hxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/RWebWindow_8hxx_source.html
https://root.cern/doc/v632/RWebWindow_8hxx_source.html:50885,Performance,queue,queueDefinition,50885,"ast send packetDefinition RWebWindow.hxx:88; ROOT::RWebWindow::WebConn::fKeyUsedint fKeyUsed! key value used to verify connectionDefinition RWebWindow.hxx:73; ROOT::RWebWindow::WebConn::~WebConn~WebConn()Destructor for WebConn Notify special HTTP request which blocks headless browser from exit.Definition RWebWindow.cxx:42; ROOT::RWebWindow::WebConn::fMutexstd::mutex fMutex! mutex must be used to protect all following dataDefinition RWebWindow.hxx:81; ROOT::RWebWindow::WebConn::fDoingSendbool fDoingSend! true when performing send operationDefinition RWebWindow.hxx:86; ROOT::RWebWindow::WebConn::fSendCreditsint fSendCredits! how many send operation can be performed without confirmation from other sideDefinition RWebWindow.hxx:84; ROOT::RWebWindow::WebConn::WebConnWebConn(unsigned connid, unsigned wsid)Definition RWebWindow.hxx:93; ROOT::RWebWindow::WebConn::fNewKeystd::string fNewKey! new key if connection request reloadDefinition RWebWindow.hxx:74; ROOT::RWebWindow::WebConn::fWSIdunsigned fWSId! websocket idDefinition RWebWindow.hxx:79; ROOT::RWebWindow::WebConn::fSendStamptimestamp_t fSendStamp! last server operation, always used from window threadDefinition RWebWindow.hxx:77; ROOT::RWebWindow::WebConn::fRecvStamptimestamp_t fRecvStamp! last receive operation, protected with connection mutexDefinition RWebWindow.hxx:82; ROOT::RWebWindow::WebConn::fRecvCountint fRecvCount! number of received packets, should return back with next sendingDefinition RWebWindow.hxx:83; ROOT::RWebWindow::WebConn::ResetStampsvoid ResetStamps()Definition RWebWindow.hxx:101; ROOT::RWebWindow::WebConn::fQueuestd::queue< QueueItem > fQueue! output queueDefinition RWebWindow.hxx:89; ROOT::RWebWindow::WebConn::fDisplayHandlestd::unique_ptr< RWebDisplayHandle > fDisplayHandle! handle assigned with started web display (when exists)Definition RWebWindow.hxx:75. guiwebdisplayincROOTRWebWindow.hxx. ROOT v6-32 - Reference Guide Generated on Fri Nov 1 2024 15:08:10 (GVA Time) using Doxygen 1.9.8 ; . ",MatchSource.WIKI,doc/v632/RWebWindow_8hxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/RWebWindow_8hxx_source.html
https://root.cern/doc/v632/RWebWindow_8hxx_source.html:8412,Safety,timeout,timeout,8412,"ect event; 160 std::thread::id fCallbacksThrdId; ///<! thread id where callbacks should be invoked; 161 bool fCallbacksThrdIdSet{false}; ///<! flag indicating that thread id is assigned; 162 bool fHasWindowThrd{false}; ///<! indicate if special window thread was started; 163 std::thread fWindowThrd; ///<! special thread for that window; 164 std::queue<QueueEntry> fInputQueue; ///<! input queue for all callbacks; 165 std::mutex fInputQueueMutex; ///<! mutex to protect input queue; 166 unsigned fWidth{0}, fHeight{0}; ///<! initial window width and height when displayed, zeros are ignored; 167 int fX{-1}, fY{-1}; ///<! initial window position, -1 ignored; 168 float fOperationTmout{50.}; ///<! timeout in seconds to perform synchronous operation, default 50s; 169 std::string fClientVersion; ///<! configured client version, used as prefix in scripts URL; 170 std::string fProtocolFileName; ///<! local file where communication protocol will be written; 171 int fProtocolCnt{-1}; ///<! counter for protocol recording; 172 unsigned fProtocolConnId{0}; ///<! connection id, which is used for writing protocol; 173 std::string fProtocolPrefix; ///<! prefix for created files names; 174 std::string fProtocol; ///<! protocol; 175 std::string fUserArgs; ///<! arbitrary JSON code, which is accessible via conn.getUserArgs() method; 176 std::shared_ptr<void> fClearOnClose; ///<! entry which is cleared when last connection is closed; 177 ; 178 std::shared_ptr<RWebWindowWSHandler> CreateWSHandler(std::shared_ptr<RWebWindowsManager> mgr, unsigned id, double tmout);; 179 ; 180 bool ProcessWS(THttpCallArg &arg);; 181 ; 182 void CompleteWSSend(unsigned wsid);; 183 ; 184 ConnectionsList_t GetWindowConnections(unsigned connid = 0, bool only_active = false) const;; 185 ; 186 /// Find connection with specified websocket id; 187 std::shared_ptr<WebConn> FindConnection(unsigned wsid);; 188 ; 189 std::shared_ptr<WebConn> RemoveConnection(unsigned wsid);; 190 ; 191 bool _CanTrustIn(std::shared_ptr<WebC",MatchSource.WIKI,doc/v632/RWebWindow_8hxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/RWebWindow_8hxx_source.html
https://root.cern/doc/v632/RWebWindow_8hxx_source.html:16195,Safety,timeout,timeout,16195,"tNativeOnlyConn(bool on = true) { fNativeOnlyConn = on; }; 309 ; 310 /////////////////////////////////////////////////////////////////////////; 311 /// returns true if only native (own-created) connections are allowed; 312 bool IsNativeOnlyConn() const { return fNativeOnlyConn; }; 313 ; 314 /////////////////////////////////////////////////////////////////////////; 315 /// Configure if authentication key in connection string is required; 316 void SetRequireAuthKey(bool on) { fRequireAuthKey = on; }; 317 ; 318 /////////////////////////////////////////////////////////////////////////; 319 /// returns true if authentication string is required; 320 bool IsRequireAuthKey() const { return fRequireAuthKey; }; 321 ; 322 /////////////////////////////////////////////////////////////////////////; 323 /// Configure if window can access local files via currentdir/ path of http server; 324 void SetUseCurrentDir(bool on = true) { fUseCurrentDir = on; }; 325 ; 326 /////////////////////////////////////////////////////////////////////////; 327 /// returns true if window can access local files via currentdir/ path of http server; 328 bool IsUseCurrentDir() const { return fUseCurrentDir; }; 329 ; 330 void SetClientVersion(const std::string &vers);; 331 ; 332 std::string GetClientVersion() const;; 333 ; 334 void SetUserArgs(const std::string &args);; 335 ; 336 std::string GetUserArgs() const;; 337 ; 338 int NumConnections(bool with_pending = false) const;; 339 ; 340 unsigned GetConnectionId(int num = 0) const;; 341 ; 342 std::vector<unsigned> GetConnections(unsigned excludeid = 0) const;; 343 ; 344 bool HasConnection(unsigned connid = 0, bool only_active = true) const;; 345 ; 346 void CloseConnections();; 347 ; 348 void CloseConnection(unsigned connid);; 349 ; 350 /// Returns timeout for synchronous WebWindow operations; 351 float GetOperationTmout() const { return fOperationTmout; }; 352 ; 353 /// Set timeout for synchronous WebWindow operations; 354 void SetOperationTmout(float tm = 50.",MatchSource.WIKI,doc/v632/RWebWindow_8hxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/RWebWindow_8hxx_source.html
https://root.cern/doc/v632/RWebWindow_8hxx_source.html:16324,Safety,timeout,timeout,16324,"tNativeOnlyConn(bool on = true) { fNativeOnlyConn = on; }; 309 ; 310 /////////////////////////////////////////////////////////////////////////; 311 /// returns true if only native (own-created) connections are allowed; 312 bool IsNativeOnlyConn() const { return fNativeOnlyConn; }; 313 ; 314 /////////////////////////////////////////////////////////////////////////; 315 /// Configure if authentication key in connection string is required; 316 void SetRequireAuthKey(bool on) { fRequireAuthKey = on; }; 317 ; 318 /////////////////////////////////////////////////////////////////////////; 319 /// returns true if authentication string is required; 320 bool IsRequireAuthKey() const { return fRequireAuthKey; }; 321 ; 322 /////////////////////////////////////////////////////////////////////////; 323 /// Configure if window can access local files via currentdir/ path of http server; 324 void SetUseCurrentDir(bool on = true) { fUseCurrentDir = on; }; 325 ; 326 /////////////////////////////////////////////////////////////////////////; 327 /// returns true if window can access local files via currentdir/ path of http server; 328 bool IsUseCurrentDir() const { return fUseCurrentDir; }; 329 ; 330 void SetClientVersion(const std::string &vers);; 331 ; 332 std::string GetClientVersion() const;; 333 ; 334 void SetUserArgs(const std::string &args);; 335 ; 336 std::string GetUserArgs() const;; 337 ; 338 int NumConnections(bool with_pending = false) const;; 339 ; 340 unsigned GetConnectionId(int num = 0) const;; 341 ; 342 std::vector<unsigned> GetConnections(unsigned excludeid = 0) const;; 343 ; 344 bool HasConnection(unsigned connid = 0, bool only_active = true) const;; 345 ; 346 void CloseConnections();; 347 ; 348 void CloseConnection(unsigned connid);; 349 ; 350 /// Returns timeout for synchronous WebWindow operations; 351 float GetOperationTmout() const { return fOperationTmout; }; 352 ; 353 /// Set timeout for synchronous WebWindow operations; 354 void SetOperationTmout(float tm = 50.",MatchSource.WIKI,doc/v632/RWebWindow_8hxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/RWebWindow_8hxx_source.html
https://root.cern/doc/v632/RWebWindow_8hxx_source.html:30493,Safety,timeout,timeout,30493,"::size_t len)Send binary data to specified connection.Definition RWebWindow.cxx:1630; ROOT::RWebWindow::fYint fY! initial window position, -1 ignoredDefinition RWebWindow.hxx:167; ROOT::RWebWindow::GetXint GetX() constreturns configured window X position (-1 - default)Definition RWebWindow.hxx:286; ROOT::RWebWindow::Createstatic std::shared_ptr< RWebWindow > Create()Create new RWebWindow Using default RWebWindowsManager.Definition RWebWindow.cxx:1883; ROOT::RWebWindow::fWidthunsigned fWidthDefinition RWebWindow.hxx:166; ROOT::RWebWindow::fClientVersionstd::string fClientVersion! configured client version, used as prefix in scripts URLDefinition RWebWindow.hxx:169; ROOT::RWebWindow::ProcessBatchHolderbool ProcessBatchHolder(std::shared_ptr< THttpCallArg > &arg)Process special http request, used to hold headless browser running Such requests should not be repli...Definition RWebWindow.cxx:374; ROOT::RWebWindow::SetOperationTmoutvoid SetOperationTmout(float tm=50.)Set timeout for synchronous WebWindow operations.Definition RWebWindow.hxx:354; ROOT::RWebWindow::AddEmbedWindowunsigned AddEmbedWindow(std::shared_ptr< RWebWindow > window, unsigned connid, int channel)Add embed window.Definition RWebWindow.cxx:1846; ROOT::RWebWindow::SetDisconnectCallBackvoid SetDisconnectCallBack(WebWindowConnectCallback_t func)Set call-back function for disconnecting.Definition RWebWindow.cxx:1753; ROOT::RWebWindow::GetConnectionsstd::vector< unsigned > GetConnections(unsigned excludeid=0) constreturns vector with all existing connections ids One also can exclude specified connection from retur...Definition RWebWindow.cxx:1387; ROOT::RWebWindow::SetDataCallBackvoid SetDataCallBack(WebWindowDataCallback_t func)Set call-back function for data, received from the clients via websocket.Definition RWebWindow.cxx:1733; ROOT::RWebWindow::fOperationTmoutfloat fOperationTmout! timeout in seconds to perform synchronous operation, default 50sDefinition RWebWindow.hxx:168; ROOT::RWebWindow::fRequireAu",MatchSource.WIKI,doc/v632/RWebWindow_8hxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/RWebWindow_8hxx_source.html
https://root.cern/doc/v632/RWebWindow_8hxx_source.html:31390,Safety,timeout,timeout,31390,"ebWindow.cxx:374; ROOT::RWebWindow::SetOperationTmoutvoid SetOperationTmout(float tm=50.)Set timeout for synchronous WebWindow operations.Definition RWebWindow.hxx:354; ROOT::RWebWindow::AddEmbedWindowunsigned AddEmbedWindow(std::shared_ptr< RWebWindow > window, unsigned connid, int channel)Add embed window.Definition RWebWindow.cxx:1846; ROOT::RWebWindow::SetDisconnectCallBackvoid SetDisconnectCallBack(WebWindowConnectCallback_t func)Set call-back function for disconnecting.Definition RWebWindow.cxx:1753; ROOT::RWebWindow::GetConnectionsstd::vector< unsigned > GetConnections(unsigned excludeid=0) constreturns vector with all existing connections ids One also can exclude specified connection from retur...Definition RWebWindow.cxx:1387; ROOT::RWebWindow::SetDataCallBackvoid SetDataCallBack(WebWindowDataCallback_t func)Set call-back function for data, received from the clients via websocket.Definition RWebWindow.cxx:1733; ROOT::RWebWindow::fOperationTmoutfloat fOperationTmout! timeout in seconds to perform synchronous operation, default 50sDefinition RWebWindow.hxx:168; ROOT::RWebWindow::fRequireAuthKeybool fRequireAuthKey! defines if authentication key always required when connect to the widgetDefinition RWebWindow.hxx:146; ROOT::RWebWindow::gStartDialogFuncstatic std::function< bool(const std::shared_ptr< RWebWindow > &, unsigned, const std::string &)> gStartDialogFuncDefinition RWebWindow.hxx:235; ROOT::RWebWindow::SetUserArgsvoid SetUserArgs(const std::string &args)Set arbitrary JSON data, which is accessible via conn.getUserArgs() method in JavaScript This JSON co...Definition RWebWindow.cxx:1310; ROOT::RWebWindow::fConnTokenstd::string fConnToken! value of ""token"" URL parameter which should be provided for connecting windowDefinition RWebWindow.hxx:153; ROOT::RWebWindow::GetHeightunsigned GetHeight() constreturns configured window height (0 - default)Definition RWebWindow.hxx:282; ROOT::RWebWindow::ShowWindowstatic unsigned ShowWindow(std::shared_ptr< RWebWindow",MatchSource.WIKI,doc/v632/RWebWindow_8hxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/RWebWindow_8hxx_source.html
https://root.cern/doc/v632/RWebWindow_8hxx_source.html:34385,Safety,timeout,timeout,34385,"e window from manager.Definition RWebWindow.cxx:85; ROOT::RWebWindow::EmbedFileDialogstatic bool EmbedFileDialog(const std::shared_ptr< RWebWindow > &window, unsigned connid, const std::string &args)Create dialog instance to use as embedded dialog inside provided widget Loads libROOTBrowserv7 and tr...Definition RWebWindow.cxx:1977; ROOT::RWebWindow::CloseConnectionvoid CloseConnection(unsigned connid)Close specified connection.Definition RWebWindow.cxx:1447; ROOT::RWebWindow::fPendingConnConnectionsList_t fPendingConn! list of pending connection with pre-assigned keysDefinition RWebWindow.hxx:149; ROOT::RWebWindow::GetConnectionIdunsigned GetConnectionId(int num=0) constReturns connection id for specified connection sequence number Only active connections are returned -...Definition RWebWindow.cxx:1370; ROOT::RWebWindow::GetConnTokenstd::string GetConnToken() constReturns configured connection token.Definition RWebWindow.cxx:725; ROOT::RWebWindow::GetOperationTmoutfloat GetOperationTmout() constReturns timeout for synchronous WebWindow operations.Definition RWebWindow.hxx:351; ROOT::RWebWindow::SetConnLimitvoid SetConnLimit(unsigned lmt=0)Configure maximal number of allowed connections - 0 is unlimited Will not affect already existing con...Definition RWebWindow.cxx:693; ROOT::RWebWindow::SetPanelNamevoid SetPanelName(const std::string &name)Configure window to show some of existing JSROOT panels It uses ""file:rootui5sys/panel/panel....Definition RWebWindow.cxx:132; ROOT::RWebWindow::SetPositionvoid SetPosition(unsigned x, unsigned y)Set window position. Will be applied if supported by used web display (like CEF or Chromium)Definition RWebWindow.hxx:269; ROOT::RWebWindow::IsRequireAuthKeybool IsRequireAuthKey() constreturns true if authentication string is requiredDefinition RWebWindow.hxx:320; ROOT::RWebWindow::RWebWindowRWebWindow()RWebWindow constructor Should be defined here because of std::unique_ptr<RWebWindowWSHandler>Definition RWebWindow.cxx:76; ROOT::RWeb",MatchSource.WIKI,doc/v632/RWebWindow_8hxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/RWebWindow_8hxx_source.html
https://root.cern/doc/v632/RWebWindow_8hxx_source.html:6494,Security,authenticat,authentication,6494,"Data(data) {}; 132 };; 133 ; 134 using ConnectionsList_t = std::vector<std::shared_ptr<WebConn>>;; 135 ; 136 std::shared_ptr<RWebWindowsManager> fMgr; ///<! display manager; 137 std::shared_ptr<RWebWindow> fMaster; ///<! master window where this window is embedded; 138 std::vector<MasterConn> fMasterConns; ///<! master connections; 139 std::string fDefaultPage; ///<! HTML page (or file name) returned when window URL is opened; 140 std::string fPanelName; ///<! panel name which should be shown in the window; 141 unsigned fId{0}; ///<! unique identifier; 142 bool fUseServerThreads{false}; ///<! indicates that server thread is using, no special window thread; 143 bool fUseProcessEvents{false}; ///<! all window functionality will run through process events; 144 bool fProcessMT{false}; ///<! if window event processing performed in dedicated thread; 145 bool fSendMT{false}; ///<! true is special threads should be used for sending data; 146 bool fRequireAuthKey{true}; ///<! defines if authentication key always required when connect to the widget; 147 std::shared_ptr<RWebWindowWSHandler> fWSHandler; ///<! specialize websocket handler for all incoming connections; 148 unsigned fConnCnt{0}; ///<! counter of new connections to assign ids; 149 ConnectionsList_t fPendingConn; ///<! list of pending connection with pre-assigned keys; 150 ConnectionsList_t fConn; ///<! list of all accepted connections; 151 mutable std::mutex fConnMutex; ///<! mutex used to protect connection list; 152 unsigned fConnLimit{1}; ///<! number of allowed active connections; 153 std::string fConnToken; ///<! value of ""token"" URL parameter which should be provided for connecting window; 154 bool fNativeOnlyConn{false}; ///<! only native connection are allowed, created by Show() method; 155 bool fUseCurrentDir{false}; ///<! if window can access local files via currentdir/ path of http server; 156 unsigned fMaxQueueLength{10}; ///<! maximal number of queue entries; 157 WebWindowConnectCallback_t fConnCallback",MatchSource.WIKI,doc/v632/RWebWindow_8hxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/RWebWindow_8hxx_source.html
https://root.cern/doc/v632/RWebWindow_8hxx_source.html:7329,Security,access,access,7329,"med in dedicated thread; 145 bool fSendMT{false}; ///<! true is special threads should be used for sending data; 146 bool fRequireAuthKey{true}; ///<! defines if authentication key always required when connect to the widget; 147 std::shared_ptr<RWebWindowWSHandler> fWSHandler; ///<! specialize websocket handler for all incoming connections; 148 unsigned fConnCnt{0}; ///<! counter of new connections to assign ids; 149 ConnectionsList_t fPendingConn; ///<! list of pending connection with pre-assigned keys; 150 ConnectionsList_t fConn; ///<! list of all accepted connections; 151 mutable std::mutex fConnMutex; ///<! mutex used to protect connection list; 152 unsigned fConnLimit{1}; ///<! number of allowed active connections; 153 std::string fConnToken; ///<! value of ""token"" URL parameter which should be provided for connecting window; 154 bool fNativeOnlyConn{false}; ///<! only native connection are allowed, created by Show() method; 155 bool fUseCurrentDir{false}; ///<! if window can access local files via currentdir/ path of http server; 156 unsigned fMaxQueueLength{10}; ///<! maximal number of queue entries; 157 WebWindowConnectCallback_t fConnCallback; ///<! callback for connect event; 158 WebWindowDataCallback_t fDataCallback; ///<! main callback when data over channel 1 is arrived; 159 WebWindowConnectCallback_t fDisconnCallback; ///<! callback for disconnect event; 160 std::thread::id fCallbacksThrdId; ///<! thread id where callbacks should be invoked; 161 bool fCallbacksThrdIdSet{false}; ///<! flag indicating that thread id is assigned; 162 bool fHasWindowThrd{false}; ///<! indicate if special window thread was started; 163 std::thread fWindowThrd; ///<! special thread for that window; 164 std::queue<QueueEntry> fInputQueue; ///<! input queue for all callbacks; 165 std::mutex fInputQueueMutex; ///<! mutex to protect input queue; 166 unsigned fWidth{0}, fHeight{0}; ///<! initial window width and height when displayed, zeros are ignored; 167 int fX{-1}, fY{-1}; //",MatchSource.WIKI,doc/v632/RWebWindow_8hxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/RWebWindow_8hxx_source.html
https://root.cern/doc/v632/RWebWindow_8hxx_source.html:9003,Security,access,accessible,9003,"ect event; 160 std::thread::id fCallbacksThrdId; ///<! thread id where callbacks should be invoked; 161 bool fCallbacksThrdIdSet{false}; ///<! flag indicating that thread id is assigned; 162 bool fHasWindowThrd{false}; ///<! indicate if special window thread was started; 163 std::thread fWindowThrd; ///<! special thread for that window; 164 std::queue<QueueEntry> fInputQueue; ///<! input queue for all callbacks; 165 std::mutex fInputQueueMutex; ///<! mutex to protect input queue; 166 unsigned fWidth{0}, fHeight{0}; ///<! initial window width and height when displayed, zeros are ignored; 167 int fX{-1}, fY{-1}; ///<! initial window position, -1 ignored; 168 float fOperationTmout{50.}; ///<! timeout in seconds to perform synchronous operation, default 50s; 169 std::string fClientVersion; ///<! configured client version, used as prefix in scripts URL; 170 std::string fProtocolFileName; ///<! local file where communication protocol will be written; 171 int fProtocolCnt{-1}; ///<! counter for protocol recording; 172 unsigned fProtocolConnId{0}; ///<! connection id, which is used for writing protocol; 173 std::string fProtocolPrefix; ///<! prefix for created files names; 174 std::string fProtocol; ///<! protocol; 175 std::string fUserArgs; ///<! arbitrary JSON code, which is accessible via conn.getUserArgs() method; 176 std::shared_ptr<void> fClearOnClose; ///<! entry which is cleared when last connection is closed; 177 ; 178 std::shared_ptr<RWebWindowWSHandler> CreateWSHandler(std::shared_ptr<RWebWindowsManager> mgr, unsigned id, double tmout);; 179 ; 180 bool ProcessWS(THttpCallArg &arg);; 181 ; 182 void CompleteWSSend(unsigned wsid);; 183 ; 184 ConnectionsList_t GetWindowConnections(unsigned connid = 0, bool only_active = false) const;; 185 ; 186 /// Find connection with specified websocket id; 187 std::shared_ptr<WebConn> FindConnection(unsigned wsid);; 188 ; 189 std::shared_ptr<WebConn> RemoveConnection(unsigned wsid);; 190 ; 191 bool _CanTrustIn(std::shared_ptr<WebC",MatchSource.WIKI,doc/v632/RWebWindow_8hxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/RWebWindow_8hxx_source.html
https://root.cern/doc/v632/RWebWindow_8hxx_source.html:14798,Security,authenticat,authentication,14798,///////////////////////////////////////////////////////; 299 /// configures maximal queue length of data which can be held by window; 300 void SetMaxQueueLength(unsigned len = 10) { fMaxQueueLength = len; }; 301 ; 302 /////////////////////////////////////////////////////////////////////////; 303 /// Return maximal queue length of data which can be held by window; 304 unsigned GetMaxQueueLength() const { return fMaxQueueLength; }; 305 ; 306 /////////////////////////////////////////////////////////////////////////; 307 /// configures that only native (own-created) connections are allowed; 308 void SetNativeOnlyConn(bool on = true) { fNativeOnlyConn = on; }; 309 ; 310 /////////////////////////////////////////////////////////////////////////; 311 /// returns true if only native (own-created) connections are allowed; 312 bool IsNativeOnlyConn() const { return fNativeOnlyConn; }; 313 ; 314 /////////////////////////////////////////////////////////////////////////; 315 /// Configure if authentication key in connection string is required; 316 void SetRequireAuthKey(bool on) { fRequireAuthKey = on; }; 317 ; 318 /////////////////////////////////////////////////////////////////////////; 319 /// returns true if authentication string is required; 320 bool IsRequireAuthKey() const { return fRequireAuthKey; }; 321 ; 322 /////////////////////////////////////////////////////////////////////////; 323 /// Configure if window can access local files via currentdir/ path of http server; 324 void SetUseCurrentDir(bool on = true) { fUseCurrentDir = on; }; 325 ; 326 /////////////////////////////////////////////////////////////////////////; 327 /// returns true if window can access local files via currentdir/ path of http server; 328 bool IsUseCurrentDir() const { return fUseCurrentDir; }; 329 ; 330 void SetClientVersion(const std::string &vers);; 331 ; 332 std::string GetClientVersion() const;; 333 ; 334 void SetUserArgs(const std::string &args);; 335 ; 336 std::string GetUserArgs() const;; 3,MatchSource.WIKI,doc/v632/RWebWindow_8hxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/RWebWindow_8hxx_source.html
https://root.cern/doc/v632/RWebWindow_8hxx_source.html:15023,Security,authenticat,authentication,15023,//////////////////////////////////////////////////////////////////; 303 /// Return maximal queue length of data which can be held by window; 304 unsigned GetMaxQueueLength() const { return fMaxQueueLength; }; 305 ; 306 /////////////////////////////////////////////////////////////////////////; 307 /// configures that only native (own-created) connections are allowed; 308 void SetNativeOnlyConn(bool on = true) { fNativeOnlyConn = on; }; 309 ; 310 /////////////////////////////////////////////////////////////////////////; 311 /// returns true if only native (own-created) connections are allowed; 312 bool IsNativeOnlyConn() const { return fNativeOnlyConn; }; 313 ; 314 /////////////////////////////////////////////////////////////////////////; 315 /// Configure if authentication key in connection string is required; 316 void SetRequireAuthKey(bool on) { fRequireAuthKey = on; }; 317 ; 318 /////////////////////////////////////////////////////////////////////////; 319 /// returns true if authentication string is required; 320 bool IsRequireAuthKey() const { return fRequireAuthKey; }; 321 ; 322 /////////////////////////////////////////////////////////////////////////; 323 /// Configure if window can access local files via currentdir/ path of http server; 324 void SetUseCurrentDir(bool on = true) { fUseCurrentDir = on; }; 325 ; 326 /////////////////////////////////////////////////////////////////////////; 327 /// returns true if window can access local files via currentdir/ path of http server; 328 bool IsUseCurrentDir() const { return fUseCurrentDir; }; 329 ; 330 void SetClientVersion(const std::string &vers);; 331 ; 332 std::string GetClientVersion() const;; 333 ; 334 void SetUserArgs(const std::string &args);; 335 ; 336 std::string GetUserArgs() const;; 337 ; 338 int NumConnections(bool with_pending = false) const;; 339 ; 340 unsigned GetConnectionId(int num = 0) const;; 341 ; 342 std::vector<unsigned> GetConnections(unsigned excludeid = 0) const;; 343 ; 344 bool HasConnectio,MatchSource.WIKI,doc/v632/RWebWindow_8hxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/RWebWindow_8hxx_source.html
https://root.cern/doc/v632/RWebWindow_8hxx_source.html:15238,Security,access,access,15238,"5 ; 306 /////////////////////////////////////////////////////////////////////////; 307 /// configures that only native (own-created) connections are allowed; 308 void SetNativeOnlyConn(bool on = true) { fNativeOnlyConn = on; }; 309 ; 310 /////////////////////////////////////////////////////////////////////////; 311 /// returns true if only native (own-created) connections are allowed; 312 bool IsNativeOnlyConn() const { return fNativeOnlyConn; }; 313 ; 314 /////////////////////////////////////////////////////////////////////////; 315 /// Configure if authentication key in connection string is required; 316 void SetRequireAuthKey(bool on) { fRequireAuthKey = on; }; 317 ; 318 /////////////////////////////////////////////////////////////////////////; 319 /// returns true if authentication string is required; 320 bool IsRequireAuthKey() const { return fRequireAuthKey; }; 321 ; 322 /////////////////////////////////////////////////////////////////////////; 323 /// Configure if window can access local files via currentdir/ path of http server; 324 void SetUseCurrentDir(bool on = true) { fUseCurrentDir = on; }; 325 ; 326 /////////////////////////////////////////////////////////////////////////; 327 /// returns true if window can access local files via currentdir/ path of http server; 328 bool IsUseCurrentDir() const { return fUseCurrentDir; }; 329 ; 330 void SetClientVersion(const std::string &vers);; 331 ; 332 std::string GetClientVersion() const;; 333 ; 334 void SetUserArgs(const std::string &args);; 335 ; 336 std::string GetUserArgs() const;; 337 ; 338 int NumConnections(bool with_pending = false) const;; 339 ; 340 unsigned GetConnectionId(int num = 0) const;; 341 ; 342 std::vector<unsigned> GetConnections(unsigned excludeid = 0) const;; 343 ; 344 bool HasConnection(unsigned connid = 0, bool only_active = true) const;; 345 ; 346 void CloseConnections();; 347 ; 348 void CloseConnection(unsigned connid);; 349 ; 350 /// Returns timeout for synchronous WebWindow operations; 3",MatchSource.WIKI,doc/v632/RWebWindow_8hxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/RWebWindow_8hxx_source.html
https://root.cern/doc/v632/RWebWindow_8hxx_source.html:15482,Security,access,access,15482,"tNativeOnlyConn(bool on = true) { fNativeOnlyConn = on; }; 309 ; 310 /////////////////////////////////////////////////////////////////////////; 311 /// returns true if only native (own-created) connections are allowed; 312 bool IsNativeOnlyConn() const { return fNativeOnlyConn; }; 313 ; 314 /////////////////////////////////////////////////////////////////////////; 315 /// Configure if authentication key in connection string is required; 316 void SetRequireAuthKey(bool on) { fRequireAuthKey = on; }; 317 ; 318 /////////////////////////////////////////////////////////////////////////; 319 /// returns true if authentication string is required; 320 bool IsRequireAuthKey() const { return fRequireAuthKey; }; 321 ; 322 /////////////////////////////////////////////////////////////////////////; 323 /// Configure if window can access local files via currentdir/ path of http server; 324 void SetUseCurrentDir(bool on = true) { fUseCurrentDir = on; }; 325 ; 326 /////////////////////////////////////////////////////////////////////////; 327 /// returns true if window can access local files via currentdir/ path of http server; 328 bool IsUseCurrentDir() const { return fUseCurrentDir; }; 329 ; 330 void SetClientVersion(const std::string &vers);; 331 ; 332 std::string GetClientVersion() const;; 333 ; 334 void SetUserArgs(const std::string &args);; 335 ; 336 std::string GetUserArgs() const;; 337 ; 338 int NumConnections(bool with_pending = false) const;; 339 ; 340 unsigned GetConnectionId(int num = 0) const;; 341 ; 342 std::vector<unsigned> GetConnections(unsigned excludeid = 0) const;; 343 ; 344 bool HasConnection(unsigned connid = 0, bool only_active = true) const;; 345 ; 346 void CloseConnections();; 347 ; 348 void CloseConnection(unsigned connid);; 349 ; 350 /// Returns timeout for synchronous WebWindow operations; 351 float GetOperationTmout() const { return fOperationTmout; }; 352 ; 353 /// Set timeout for synchronous WebWindow operations; 354 void SetOperationTmout(float tm = 50.",MatchSource.WIKI,doc/v632/RWebWindow_8hxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/RWebWindow_8hxx_source.html
https://root.cern/doc/v632/RWebWindow_8hxx_source.html:24808,Security,hash,hash,24808,":148; ROOT::RWebWindow::fProtocolConnIdunsigned fProtocolConnId! connection id, which is used for writing protocolDefinition RWebWindow.hxx:172; ROOT::RWebWindow::GetWindowConnectionsConnectionsList_t GetWindowConnections(unsigned connid=0, bool only_active=false) constreturns connection list (or all active connections)Definition RWebWindow.cxx:1458; ROOT::RWebWindow::fSendMTbool fSendMT! true is special threads should be used for sending dataDefinition RWebWindow.hxx:145; ROOT::RWebWindow::fCallbacksThrdIdstd::thread::id fCallbacksThrdId! thread id where callbacks should be invokedDefinition RWebWindow.hxx:160; ROOT::RWebWindow::RemoveKeyvoid RemoveKey(const std::string &key)Removes all connections with the key.Definition RWebWindow.cxx:583; ROOT::RWebWindow::fInputQueuestd::queue< QueueEntry > fInputQueue! input queue for all callbacksDefinition RWebWindow.hxx:164; ROOT::RWebWindow::_CanTrustInbool _CanTrustIn(std::shared_ptr< WebConn > &conn, const std::string &key, const std::string &ntry, bool remote, bool test_first_time)Check if provided hash, ntry parameters from the connection request could be accepted.Definition RWebWindow.cxx:513; ROOT::RWebWindow::SetConnTokenvoid SetConnToken(const std::string &token="""")Configures connection token (default none) When specified, in URL of webpage such token should be pro...Definition RWebWindow.cxx:715; ROOT::RWebWindow::MakeHeadlessunsigned MakeHeadless(bool create_new=false)Start headless browser for specified window Normally only single instance is used,...Definition RWebWindow.cxx:202; ROOT::RWebWindow::GetUrlstd::string GetUrl(bool remote=true)Return URL string to connect web window URL typically includes extra parameters required for connecti...Definition RWebWindow.cxx:173; ROOT::RWebWindow::CloseConnectionsvoid CloseConnections()Closes all connection to clients Normally leads to closing of all correspondent browser windows Some ...Definition RWebWindow.cxx:1438; ROOT::RWebWindow::fMasterstd::shared_ptr< RWebWindo",MatchSource.WIKI,doc/v632/RWebWindow_8hxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/RWebWindow_8hxx_source.html
https://root.cern/doc/v632/RWebWindow_8hxx_source.html:26216,Security,access,accessible,26216,"_new=false)Start headless browser for specified window Normally only single instance is used,...Definition RWebWindow.cxx:202; ROOT::RWebWindow::GetUrlstd::string GetUrl(bool remote=true)Return URL string to connect web window URL typically includes extra parameters required for connecti...Definition RWebWindow.cxx:173; ROOT::RWebWindow::CloseConnectionsvoid CloseConnections()Closes all connection to clients Normally leads to closing of all correspondent browser windows Some ...Definition RWebWindow.cxx:1438; ROOT::RWebWindow::fMasterstd::shared_ptr< RWebWindow > fMaster! master window where this window is embeddedDefinition RWebWindow.hxx:137; ROOT::RWebWindow::NumConnectionsint NumConnections(bool with_pending=false) constReturns current number of active clients connections.Definition RWebWindow.cxx:1330; ROOT::RWebWindow::fCallbacksThrdIdSetbool fCallbacksThrdIdSet! flag indicating that thread id is assignedDefinition RWebWindow.hxx:161; ROOT::RWebWindow::fUserArgsstd::string fUserArgs! arbitrary JSON code, which is accessible via conn.getUserArgs() methodDefinition RWebWindow.hxx:175; ROOT::RWebWindow::SetDefaultPagevoid SetDefaultPage(const std::string &page)Set content of default window HTML page This page returns when URL address of the window will be requ...Definition RWebWindow.hxx:257; ROOT::RWebWindow::fConnLimitunsigned fConnLimit! number of allowed active connectionsDefinition RWebWindow.hxx:152; ROOT::RWebWindow::InvokeCallbacksvoid InvokeCallbacks(bool force=false)Invoke callbacks with existing data Must be called from appropriate thread.Definition RWebWindow.cxx:438; ROOT::RWebWindow::FindConnectionstd::shared_ptr< WebConn > FindConnection(unsigned wsid)Find connection with specified websocket id.Definition RWebWindow.cxx:264; ROOT::RWebWindow::GetClientVersionstd::string GetClientVersion() constReturns current client version.Definition RWebWindow.cxx:1298; ROOT::RWebWindow::SetConnectCallBackvoid SetConnectCallBack(WebWindowConnectCallback_t func)Set",MatchSource.WIKI,doc/v632/RWebWindow_8hxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/RWebWindow_8hxx_source.html
https://root.cern/doc/v632/RWebWindow_8hxx_source.html:28175,Security,access,access,28175,"func)Set call-back function for new connection.Definition RWebWindow.cxx:1743; ROOT::RWebWindow::IsShownbool IsShown() constReturns true when window was shown at least once.Definition RWebWindow.hxx:369; ROOT::RWebWindow::Syncvoid Sync()Special method to process all internal activity when window runs in separate thread.Definition RWebWindow.cxx:1236; ROOT::RWebWindow::UseServerThreadsvoid UseServerThreads()Let use THttpServer threads to process requests WARNING!!! only for expert use Should be only used wh...Definition RWebWindow.cxx:1667; ROOT::RWebWindow::SetGeometryvoid SetGeometry(unsigned width, unsigned height)Set window geometry. Will be applied if supported by used web display (like CEF or Chromium)Definition RWebWindow.hxx:262; ROOT::RWebWindow::TerminateROOTvoid TerminateROOT()Terminate ROOT session Tries to correctly close THttpServer, associated with RWebWindowsManager After...Definition RWebWindow.cxx:1893; ROOT::RWebWindow::fUseCurrentDirbool fUseCurrentDir! if window can access local files via currentdir/ path of http serverDefinition RWebWindow.hxx:155; ROOT::RWebWindow::Sendvoid Send(unsigned connid, const std::string &data)Sends data to specified connection.Definition RWebWindow.cxx:1609; ROOT::RWebWindow::Showunsigned Show(const RWebDisplayArgs &args="""")Show window in specified location.Definition RWebWindow.cxx:191; ROOT::RWebWindow::GetServerTHttpServer * GetServer()Return THttpServer instance serving requests to the window.Definition RWebWindow.cxx:181; ROOT::RWebWindow::AddDisplayHandleunsigned AddDisplayHandle(bool headless_mode, const std::string &key, std::unique_ptr< RWebDisplayHandle > &handle)Add display handle and associated key Key is large random string generated when starting new window W...Definition RWebWindow.cxx:482; ROOT::RWebWindow::ConnectionsList_tstd::vector< std::shared_ptr< WebConn > > ConnectionsList_tDefinition RWebWindow.hxx:134; ROOT::RWebWindow::AssignThreadIdvoid AssignThreadId()Assign thread id which has to be used f",MatchSource.WIKI,doc/v632/RWebWindow_8hxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/RWebWindow_8hxx_source.html
https://root.cern/doc/v632/RWebWindow_8hxx_source.html:31551,Security,authenticat,authentication,31551,"ndow.hxx:354; ROOT::RWebWindow::AddEmbedWindowunsigned AddEmbedWindow(std::shared_ptr< RWebWindow > window, unsigned connid, int channel)Add embed window.Definition RWebWindow.cxx:1846; ROOT::RWebWindow::SetDisconnectCallBackvoid SetDisconnectCallBack(WebWindowConnectCallback_t func)Set call-back function for disconnecting.Definition RWebWindow.cxx:1753; ROOT::RWebWindow::GetConnectionsstd::vector< unsigned > GetConnections(unsigned excludeid=0) constreturns vector with all existing connections ids One also can exclude specified connection from retur...Definition RWebWindow.cxx:1387; ROOT::RWebWindow::SetDataCallBackvoid SetDataCallBack(WebWindowDataCallback_t func)Set call-back function for data, received from the clients via websocket.Definition RWebWindow.cxx:1733; ROOT::RWebWindow::fOperationTmoutfloat fOperationTmout! timeout in seconds to perform synchronous operation, default 50sDefinition RWebWindow.hxx:168; ROOT::RWebWindow::fRequireAuthKeybool fRequireAuthKey! defines if authentication key always required when connect to the widgetDefinition RWebWindow.hxx:146; ROOT::RWebWindow::gStartDialogFuncstatic std::function< bool(const std::shared_ptr< RWebWindow > &, unsigned, const std::string &)> gStartDialogFuncDefinition RWebWindow.hxx:235; ROOT::RWebWindow::SetUserArgsvoid SetUserArgs(const std::string &args)Set arbitrary JSON data, which is accessible via conn.getUserArgs() method in JavaScript This JSON co...Definition RWebWindow.cxx:1310; ROOT::RWebWindow::fConnTokenstd::string fConnToken! value of ""token"" URL parameter which should be provided for connecting windowDefinition RWebWindow.hxx:153; ROOT::RWebWindow::GetHeightunsigned GetHeight() constreturns configured window height (0 - default)Definition RWebWindow.hxx:282; ROOT::RWebWindow::ShowWindowstatic unsigned ShowWindow(std::shared_ptr< RWebWindow > window, const RWebDisplayArgs &args="""")Static method to show web window Has to be used instead of RWebWindow::Show() when window potentially...Definitio",MatchSource.WIKI,doc/v632/RWebWindow_8hxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/RWebWindow_8hxx_source.html
https://root.cern/doc/v632/RWebWindow_8hxx_source.html:31926,Security,access,accessible,31926,".Definition RWebWindow.cxx:1753; ROOT::RWebWindow::GetConnectionsstd::vector< unsigned > GetConnections(unsigned excludeid=0) constreturns vector with all existing connections ids One also can exclude specified connection from retur...Definition RWebWindow.cxx:1387; ROOT::RWebWindow::SetDataCallBackvoid SetDataCallBack(WebWindowDataCallback_t func)Set call-back function for data, received from the clients via websocket.Definition RWebWindow.cxx:1733; ROOT::RWebWindow::fOperationTmoutfloat fOperationTmout! timeout in seconds to perform synchronous operation, default 50sDefinition RWebWindow.hxx:168; ROOT::RWebWindow::fRequireAuthKeybool fRequireAuthKey! defines if authentication key always required when connect to the widgetDefinition RWebWindow.hxx:146; ROOT::RWebWindow::gStartDialogFuncstatic std::function< bool(const std::shared_ptr< RWebWindow > &, unsigned, const std::string &)> gStartDialogFuncDefinition RWebWindow.hxx:235; ROOT::RWebWindow::SetUserArgsvoid SetUserArgs(const std::string &args)Set arbitrary JSON data, which is accessible via conn.getUserArgs() method in JavaScript This JSON co...Definition RWebWindow.cxx:1310; ROOT::RWebWindow::fConnTokenstd::string fConnToken! value of ""token"" URL parameter which should be provided for connecting windowDefinition RWebWindow.hxx:153; ROOT::RWebWindow::GetHeightunsigned GetHeight() constreturns configured window height (0 - default)Definition RWebWindow.hxx:282; ROOT::RWebWindow::ShowWindowstatic unsigned ShowWindow(std::shared_ptr< RWebWindow > window, const RWebDisplayArgs &args="""")Static method to show web window Has to be used instead of RWebWindow::Show() when window potentially...Definition RWebWindow.cxx:1915; ROOT::RWebWindow::fWSHandlerstd::shared_ptr< RWebWindowWSHandler > fWSHandler! specialize websocket handler for all incoming connectionsDefinition RWebWindow.hxx:147; ROOT::RWebWindow::StopThreadvoid StopThread()Stop special thread.Definition RWebWindow.cxx:1702; ROOT::RWebWindow::SubmitDatavoid Submi",MatchSource.WIKI,doc/v632/RWebWindow_8hxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/RWebWindow_8hxx_source.html
https://root.cern/doc/v632/RWebWindow_8hxx_source.html:33149,Security,checksum,checksum,33149,"h should be provided for connecting windowDefinition RWebWindow.hxx:153; ROOT::RWebWindow::GetHeightunsigned GetHeight() constreturns configured window height (0 - default)Definition RWebWindow.hxx:282; ROOT::RWebWindow::ShowWindowstatic unsigned ShowWindow(std::shared_ptr< RWebWindow > window, const RWebDisplayArgs &args="""")Static method to show web window Has to be used instead of RWebWindow::Show() when window potentially...Definition RWebWindow.cxx:1915; ROOT::RWebWindow::fWSHandlerstd::shared_ptr< RWebWindowWSHandler > fWSHandler! specialize websocket handler for all incoming connectionsDefinition RWebWindow.hxx:147; ROOT::RWebWindow::StopThreadvoid StopThread()Stop special thread.Definition RWebWindow.cxx:1702; ROOT::RWebWindow::SubmitDatavoid SubmitData(unsigned connid, bool txt, std::string &&data, int chid=1)Internal method to send data.Definition RWebWindow.cxx:1529; ROOT::RWebWindow::HMACstatic std::string HMAC(const std::string &key, const std::string &sessionKey, const char *msg, int msglen)Calculate HMAC checksum for provided key and message Key combained from connection key and session ke...Definition RWebWindow.cxx:1992; ROOT::RWebWindow::~RWebWindow~RWebWindow()RWebWindow destructor Closes all connections and remove window from manager.Definition RWebWindow.cxx:85; ROOT::RWebWindow::EmbedFileDialogstatic bool EmbedFileDialog(const std::shared_ptr< RWebWindow > &window, unsigned connid, const std::string &args)Create dialog instance to use as embedded dialog inside provided widget Loads libROOTBrowserv7 and tr...Definition RWebWindow.cxx:1977; ROOT::RWebWindow::CloseConnectionvoid CloseConnection(unsigned connid)Close specified connection.Definition RWebWindow.cxx:1447; ROOT::RWebWindow::fPendingConnConnectionsList_t fPendingConn! list of pending connection with pre-assigned keysDefinition RWebWindow.hxx:149; ROOT::RWebWindow::GetConnectionIdunsigned GetConnectionId(int num=0) constReturns connection id for specified connection sequence number Only ac",MatchSource.WIKI,doc/v632/RWebWindow_8hxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/RWebWindow_8hxx_source.html
https://root.cern/doc/v632/RWebWindow_8hxx_source.html:35129,Security,authenticat,authentication,35129,"y active connections are returned -...Definition RWebWindow.cxx:1370; ROOT::RWebWindow::GetConnTokenstd::string GetConnToken() constReturns configured connection token.Definition RWebWindow.cxx:725; ROOT::RWebWindow::GetOperationTmoutfloat GetOperationTmout() constReturns timeout for synchronous WebWindow operations.Definition RWebWindow.hxx:351; ROOT::RWebWindow::SetConnLimitvoid SetConnLimit(unsigned lmt=0)Configure maximal number of allowed connections - 0 is unlimited Will not affect already existing con...Definition RWebWindow.cxx:693; ROOT::RWebWindow::SetPanelNamevoid SetPanelName(const std::string &name)Configure window to show some of existing JSROOT panels It uses ""file:rootui5sys/panel/panel....Definition RWebWindow.cxx:132; ROOT::RWebWindow::SetPositionvoid SetPosition(unsigned x, unsigned y)Set window position. Will be applied if supported by used web display (like CEF or Chromium)Definition RWebWindow.hxx:269; ROOT::RWebWindow::IsRequireAuthKeybool IsRequireAuthKey() constreturns true if authentication string is requiredDefinition RWebWindow.hxx:320; ROOT::RWebWindow::RWebWindowRWebWindow()RWebWindow constructor Should be defined here because of std::unique_ptr<RWebWindowWSHandler>Definition RWebWindow.cxx:76; ROOT::RWebWindow::SetNativeOnlyConnvoid SetNativeOnlyConn(bool on=true)configures that only native (own-created) connections are allowedDefinition RWebWindow.hxx:308; ROOT::RWebWindow::fProtocolPrefixstd::string fProtocolPrefix! prefix for created files namesDefinition RWebWindow.hxx:173; ROOT::RWebWindow::GetSendQueueLengthint GetSendQueueLength(unsigned connid) constReturns send queue length for specified connection.Definition RWebWindow.cxx:1509; ROOT::RWebWindow::RemoveConnectionstd::shared_ptr< WebConn > RemoveConnection(unsigned wsid)Remove connection with given websocket id.Definition RWebWindow.cxx:279; ROOT::RWebWindow::CreateWSHandlerstd::shared_ptr< RWebWindowWSHandler > CreateWSHandler(std::shared_ptr< RWebWindowsManager > mgr, unsigne",MatchSource.WIKI,doc/v632/RWebWindow_8hxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/RWebWindow_8hxx_source.html
https://root.cern/doc/v632/RWebWindow_8hxx_source.html:37841,Security,access,access,37841,"tavoid RecordData(const std::string &fname=""protocol.json"", const std::string &fprefix="""")Configures recording of communication data in protocol file Provided filename will be used to store J...Definition RWebWindow.cxx:1355; ROOT::RWebWindow::fUseProcessEventsbool fUseProcessEvents! all window functionality will run through process eventsDefinition RWebWindow.hxx:143; ROOT::RWebWindow::GetDisplayConnectionunsigned GetDisplayConnection() constReturns first connection id where window is displayed It could be that connection(s) not yet fully es...Definition RWebWindow.cxx:244; ROOT::RWebWindow::fMaxQueueLengthunsigned fMaxQueueLength! maximal number of queue entriesDefinition RWebWindow.hxx:156; ROOT::RWebWindow::fXint fXDefinition RWebWindow.hxx:167; ROOT::RWebWindow::GetConnLimitunsigned GetConnLimit() constreturns configured connections limit (0 - default)Definition RWebWindow.cxx:703; ROOT::RWebWindow::GetRelativeAddrstd::string GetRelativeAddr(const std::shared_ptr< RWebWindow > &win) constReturns relative URL address for the specified window Address can be required if one needs to access ...Definition RWebWindow.cxx:1260; ROOT::RWebWindow::SetStartDialogFuncstatic void SetStartDialogFunc(std::function< bool(const std::shared_ptr< RWebWindow > &, unsigned, const std::string &)>)Configure func which has to be used for starting dialog.Definition RWebWindow.cxx:1953; ROOT::RWebWindow::fPanelNamestd::string fPanelName! panel name which should be shown in the windowDefinition RWebWindow.hxx:140; ROOT::RWebWindow::Runvoid Run(double tm=0.)Run window functionality for specified time If no action can be performed - just sleep specified time...Definition RWebWindow.cxx:1827; ROOT::RWebWindow::fHeightunsigned fHeight! initial window width and height when displayed, zeros are ignoredDefinition RWebWindow.hxx:166; ROOT::RWebWindow::GetAddrstd::string GetAddr() constReturns window address which is used in URL.Definition RWebWindow.cxx:1250; ROOT::RWebWindow::fMgrstd::shared_pt",MatchSource.WIKI,doc/v632/RWebWindow_8hxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/RWebWindow_8hxx_source.html
https://root.cern/doc/v632/RWebWindow_8hxx_source.html:41995,Security,access,access,41995,"Window::GetWidthunsigned GetWidth() constreturns configured window width (0 - default) actual window width can be differentDefinition RWebWindow.hxx:278; ROOT::RWebWindow::fWindowThrdstd::thread fWindowThrd! special thread for that windowDefinition RWebWindow.hxx:163; ROOT::RWebWindow::ProvideQueueEntryvoid ProvideQueueEntry(unsigned connid, EQueueEntryKind kind, std::string &&arg)Provide data to user callback User callback must be executed in the window thread.Definition RWebWindow.cxx:421; ROOT::RWebWindow::HasKeybool HasKey(const std::string &key, bool also_newkey=false) constReturns true if provided key value already exists (in processes map or in existing connections) In sp...Definition RWebWindow.cxx:558; ROOT::RWebWindow::CompleteWSSendvoid CompleteWSSend(unsigned wsid)Complete websocket send operation Clear ""doing send"" flag and check if next operation has to be start...Definition RWebWindow.cxx:1088; ROOT::RWebWindow::IsUseCurrentDirbool IsUseCurrentDir() constreturns true if window can access local files via currentdir/ path of http serverDefinition RWebWindow.hxx:328; ROOT::RWebWindow::fUseServerThreadsbool fUseServerThreads! indicates that server thread is using, no special window threadDefinition RWebWindow.hxx:142; ROOT::RWebWindow::FindHeadlessConnectionunsigned FindHeadlessConnection()Returns connection id of window running in headless mode This can be special connection which may run...Definition RWebWindow.cxx:221; ROOT::RWebWindow::WaitForTimedint WaitForTimed(WebWindowWaitFunc_t check)Waits until provided check function or lambdas returns non-zero value Check function has following si...Definition RWebWindow.cxx:1803; ROOT::RWebWindow::fProcessMTbool fProcessMT! if window event processing performed in dedicated threadDefinition RWebWindow.hxx:144; ROOT::RWebWindow::fProtocolCntint fProtocolCnt! counter for protocol recordingDefinition RWebWindow.hxx:171; ROOT::RWebWindow::SetClientVersionvoid SetClientVersion(const std::string &vers)Set client ve",MatchSource.WIKI,doc/v632/RWebWindow_8hxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/RWebWindow_8hxx_source.html
https://root.cern/doc/v632/RWebWindow_8hxx_source.html:43758,Security,authenticat,authentication,43758,"cated threadDefinition RWebWindow.hxx:144; ROOT::RWebWindow::fProtocolCntint fProtocolCnt! counter for protocol recordingDefinition RWebWindow.hxx:171; ROOT::RWebWindow::SetClientVersionvoid SetClientVersion(const std::string &vers)Set client version, used as prefix in scripts URL When changed, web browser will reload all related J...Definition RWebWindow.cxx:1289; ROOT::RWebWindow::RemoveMasterConnectionvoid RemoveMasterConnection(unsigned connid=0)Remove master connection - if any.Definition RWebWindow.cxx:343; ROOT::RWebWindow::RemoveEmbedWindowvoid RemoveEmbedWindow(unsigned connid, int channel)Remove RWebWindow associated with the channelfEmbed.Definition RWebWindow.cxx:1867; ROOT::RWebWindow::SetCallBacksvoid SetCallBacks(WebWindowConnectCallback_t conn, WebWindowDataCallback_t data, WebWindowConnectCallback_t disconn=nullptr)Set call-backs function for connect, data and disconnect events.Definition RWebWindow.cxx:1772; ROOT::RWebWindow::SetRequireAuthKeyvoid SetRequireAuthKey(bool on)Configure if authentication key in connection string is required.Definition RWebWindow.hxx:316; ROOT::RWebWindow::GenerateKeystd::string GenerateKey() constGenerate new unique key for the window.Definition RWebWindow.cxx:611; ROOT::RWebWindow::SetUseCurrentDirvoid SetUseCurrentDir(bool on=true)Configure if window can access local files via currentdir/ path of http server.Definition RWebWindow.hxx:324; ROOT::RWebWindow::fDisconnCallbackWebWindowConnectCallback_t fDisconnCallback! callback for disconnect eventDefinition RWebWindow.hxx:159; ROOT::RWebWindow::GetMaxQueueLengthunsigned GetMaxQueueLength() constReturn maximal queue length of data which can be held by window.Definition RWebWindow.hxx:304; ROOT::RWebWindow::EQueueEntryKindEQueueEntryKindDefinition RWebWindow.hxx:124; ROOT::RWebWindow::kind_Disconnect@ kind_DisconnectDefinition RWebWindow.hxx:124; ROOT::RWebWindow::kind_Connect@ kind_ConnectDefinition RWebWindow.hxx:124; ROOT::RWebWindow::kind_None@ kind_NoneDefinition RWe",MatchSource.WIKI,doc/v632/RWebWindow_8hxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/RWebWindow_8hxx_source.html
https://root.cern/doc/v632/RWebWindow_8hxx_source.html:44064,Security,access,access,44064,"rowser will reload all related J...Definition RWebWindow.cxx:1289; ROOT::RWebWindow::RemoveMasterConnectionvoid RemoveMasterConnection(unsigned connid=0)Remove master connection - if any.Definition RWebWindow.cxx:343; ROOT::RWebWindow::RemoveEmbedWindowvoid RemoveEmbedWindow(unsigned connid, int channel)Remove RWebWindow associated with the channelfEmbed.Definition RWebWindow.cxx:1867; ROOT::RWebWindow::SetCallBacksvoid SetCallBacks(WebWindowConnectCallback_t conn, WebWindowDataCallback_t data, WebWindowConnectCallback_t disconn=nullptr)Set call-backs function for connect, data and disconnect events.Definition RWebWindow.cxx:1772; ROOT::RWebWindow::SetRequireAuthKeyvoid SetRequireAuthKey(bool on)Configure if authentication key in connection string is required.Definition RWebWindow.hxx:316; ROOT::RWebWindow::GenerateKeystd::string GenerateKey() constGenerate new unique key for the window.Definition RWebWindow.cxx:611; ROOT::RWebWindow::SetUseCurrentDirvoid SetUseCurrentDir(bool on=true)Configure if window can access local files via currentdir/ path of http server.Definition RWebWindow.hxx:324; ROOT::RWebWindow::fDisconnCallbackWebWindowConnectCallback_t fDisconnCallback! callback for disconnect eventDefinition RWebWindow.hxx:159; ROOT::RWebWindow::GetMaxQueueLengthunsigned GetMaxQueueLength() constReturn maximal queue length of data which can be held by window.Definition RWebWindow.hxx:304; ROOT::RWebWindow::EQueueEntryKindEQueueEntryKindDefinition RWebWindow.hxx:124; ROOT::RWebWindow::kind_Disconnect@ kind_DisconnectDefinition RWebWindow.hxx:124; ROOT::RWebWindow::kind_Connect@ kind_ConnectDefinition RWebWindow.hxx:124; ROOT::RWebWindow::kind_None@ kind_NoneDefinition RWebWindow.hxx:124; ROOT::RWebWindow::kind_Data@ kind_DataDefinition RWebWindow.hxx:124; ROOT::RWebWindow::IsFileDialogMessagestatic bool IsFileDialogMessage(const std::string &msg)Check if this could be the message send by client to start new file dialog If returns true,...Definition RWebWindow.cxx:196",MatchSource.WIKI,doc/v632/RWebWindow_8hxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/RWebWindow_8hxx_source.html
https://root.cern/doc/v632/RWebWindow_8hxx_source.html:9107,Usability,clear,cleared,9107,,MatchSource.WIKI,doc/v632/RWebWindow_8hxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/RWebWindow_8hxx_source.html
https://root.cern/doc/v632/RWebWindow_8hxx_source.html:23342,Usability,clear,cleared,23342,"tion If there are many connections - only same master is allowed.Definition RWebWindow.cxx:310; ROOT::RWebWindow::fConnMutexstd::mutex fConnMutex! mutex used to protect connection listDefinition RWebWindow.hxx:151; ROOT::RWebWindow::fDataCallbackWebWindowDataCallback_t fDataCallback! main callback when data over channel 1 is arrivedDefinition RWebWindow.hxx:158; ROOT::RWebWindow::CheckInactiveConnectionsvoid CheckInactiveConnections()Check if there are connection which are inactive for longer time For instance, batch browser will be ...Definition RWebWindow.cxx:658; ROOT::RWebWindow::fIdunsigned fId! unique identifierDefinition RWebWindow.hxx:141; ROOT::RWebWindow::fHasWindowThrdbool fHasWindowThrd! indicate if special window thread was startedDefinition RWebWindow.hxx:162; ROOT::RWebWindow::fMasterConnsstd::vector< MasterConn > fMasterConns! master connectionsDefinition RWebWindow.hxx:138; ROOT::RWebWindow::SetClearOnClosevoid SetClearOnClose(const std::shared_ptr< void > &handle=nullptr)Set handle which is cleared when last active connection is closed Typically can be used to destroy we...Definition RWebWindow.cxx:1764; ROOT::RWebWindow::StartThreadvoid StartThread()Start special thread which will be used by the window to handle all callbacks One has to be sure,...Definition RWebWindow.cxx:1680; ROOT::RWebWindow::fConnCntunsigned fConnCnt! counter of new connections to assign idsDefinition RWebWindow.hxx:148; ROOT::RWebWindow::fProtocolConnIdunsigned fProtocolConnId! connection id, which is used for writing protocolDefinition RWebWindow.hxx:172; ROOT::RWebWindow::GetWindowConnectionsConnectionsList_t GetWindowConnections(unsigned connid=0, bool only_active=false) constreturns connection list (or all active connections)Definition RWebWindow.cxx:1458; ROOT::RWebWindow::fSendMTbool fSendMT! true is special threads should be used for sending dataDefinition RWebWindow.hxx:145; ROOT::RWebWindow::fCallbacksThrdIdstd::thread::id fCallbacksThrdId! thread id where callbacks ",MatchSource.WIKI,doc/v632/RWebWindow_8hxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/RWebWindow_8hxx_source.html
https://root.cern/doc/v632/RWebWindow_8hxx_source.html:39850,Usability,clear,cleared,39850,":fProtocolFileNamestd::string fProtocolFileName! local file where communication protocol will be writtenDefinition RWebWindow.hxx:170; ROOT::RWebWindow::GetYint GetY() constreturns configured window Y position (-1 - default)Definition RWebWindow.hxx:290; ROOT::RWebWindow::fNativeOnlyConnbool fNativeOnlyConn! only native connection are allowed, created by Show() methodDefinition RWebWindow.hxx:154; ROOT::RWebWindow::GetManagerstd::shared_ptr< RWebWindowsManager > GetManager() constReturns window manager.Definition RWebWindow.hxx:251; ROOT::RWebWindow::fConnConnectionsList_t fConn! list of all accepted connectionsDefinition RWebWindow.hxx:150; ROOT::RWebWindow::fConnCallbackWebWindowConnectCallback_t fConnCallback! callback for connect eventDefinition RWebWindow.hxx:157; ROOT::RWebWindow::CheckPendingConnectionsvoid CheckPendingConnections()Check if started process(es) establish connection.Definition RWebWindow.cxx:624; ROOT::RWebWindow::fClearOnClosestd::shared_ptr< void > fClearOnClose! entry which is cleared when last connection is closedDefinition RWebWindow.hxx:176; ROOT::RWebWindow::fInputQueueMutexstd::mutex fInputQueueMutex! mutex to protect input queueDefinition RWebWindow.hxx:165; ROOT::RWebWindow::_MakeSendHeaderstd::string _MakeSendHeader(std::shared_ptr< WebConn > &conn, bool txt, const std::string &data, int chid)Internal method to prepare text part of send data Should be called under locked connection mutex.Definition RWebWindow.cxx:1107; ROOT::RWebWindow::timestamp_tstd::chrono::time_point< std::chrono::system_clock > timestamp_tDefinition RWebWindow.hxx:60; ROOT::RWebWindow::SetMaxQueueLengthvoid SetMaxQueueLength(unsigned len=10)configures maximal queue length of data which can be held by windowDefinition RWebWindow.hxx:300; ROOT::RWebWindow::ProcessWSbool ProcessWS(THttpCallArg &arg)Processing of websockets call-backs, invoked from RWebWindowWSHandler Method invoked from http server...Definition RWebWindow.cxx:736; ROOT::RWebWindow::HasConnectionboo",MatchSource.WIKI,doc/v632/RWebWindow_8hxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/RWebWindow_8hxx_source.html
https://root.cern/doc/v632/StringConv_8hxx_source.html:3409,Availability,failure,failure,3409," the result; 60 exp = 1;; 61 } else if (bytes > 0) {; 62 exp = std::min( (int) (std::log(bytes) / std::log(unit)),; 63 (int) (sizeof(suffix) / sizeof(suffix[0]) - 1));; 64 }; 65 *coeff = bytes / std::pow(unit, exp);; 66 *units = suffix[exp][!si];; 67}; 68 ; 69enum class EFromHumanReadableSize {; 70 kSuccess,; 71 kParseFail,; 72 kOverflow; 73};; 74 ; 75///////////////////////////////////////////////////////////////////////////////; 76/// Convert strings like the following into byte counts; 77/// 5MB, 5 MB, 5M, 3.7GB, 123b, 456kB, 3.7GiB, 5MiB; 78/// with some amount of forgiveness baked into the parsing.; 79/// For this routine we use the official SI unit where the [i] is reserved; 80/// for the 'legacy' power of two units. 1KB = 1000 bytes, 1KiB = 1024 bytes.; 81/// \param str the string to be parsed; 82/// \param value will be updated with the result if and only if the parse is successful and does not overflow for the type of value.; 83/// \return return a EFromHumanReadableSize enum value indicating the success or failure of the parse.; 84///; 85template <typename T>; 86EFromHumanReadableSize FromHumanReadableSize(std::string_view str, T &value); 87{; 88 try {; 89 size_t cur, size = str.size();; 90 // Parse leading numeric factor; 91 const double coeff = stod(std::string(str.data(), str.size()), &cur);; 92 ; 93 // Skip any intermediate white space; 94 while (cur<size && isspace(str[cur])) ++cur;; 95 ; 96 // Read off first character which should be an SI prefix; 97 int exp = 0, unit = 1000;; 98 ; 99 auto result = [coeff,&exp,&unit,&value]() {; 100 double v = exp ? coeff * std::pow(unit, exp / 3) : coeff;; 101 if (v < (double) std::numeric_limits<T>::max()) {; 102 value = (T)v;; 103 return EFromHumanReadableSize::kSuccess;; 104 } else {; 105 return EFromHumanReadableSize::kOverflow;; 106 }; 107 };; 108 if (cur==size) return result();; 109 ; 110 switch (toupper(str[cur])) {; 111 case 'B': exp = 0; break;; 112 case 'K': exp = 3; break;; 113 case 'M': exp = 6; break;; ",MatchSource.WIKI,doc/v632/StringConv_8hxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/StringConv_8hxx_source.html
https://root.cern/doc/v632/StringConv_8hxx_source.html:5220,Availability,error,error,5220,"std::string_view str, T &value); 87{; 88 try {; 89 size_t cur, size = str.size();; 90 // Parse leading numeric factor; 91 const double coeff = stod(std::string(str.data(), str.size()), &cur);; 92 ; 93 // Skip any intermediate white space; 94 while (cur<size && isspace(str[cur])) ++cur;; 95 ; 96 // Read off first character which should be an SI prefix; 97 int exp = 0, unit = 1000;; 98 ; 99 auto result = [coeff,&exp,&unit,&value]() {; 100 double v = exp ? coeff * std::pow(unit, exp / 3) : coeff;; 101 if (v < (double) std::numeric_limits<T>::max()) {; 102 value = (T)v;; 103 return EFromHumanReadableSize::kSuccess;; 104 } else {; 105 return EFromHumanReadableSize::kOverflow;; 106 }; 107 };; 108 if (cur==size) return result();; 109 ; 110 switch (toupper(str[cur])) {; 111 case 'B': exp = 0; break;; 112 case 'K': exp = 3; break;; 113 case 'M': exp = 6; break;; 114 case 'G': exp = 9; break;; 115 case 'T': exp = 12; break;; 116 case 'E': exp = 15; break;; 117 case 'Z': exp = 18; break;; 118 case 'Y': exp = 21; break;; 119 ; 120 default: return EFromHumanReadableSize::kParseFail;; 121 }; 122 ++cur;; 123 ; 124 // If an 'i' or 'I' is present use non-SI factor-of-1024 units; 125 if (cur<size && toupper(str[cur]) == 'I') {; 126 ++cur;; 127 unit = 1024;; 128 }; 129 ; 130 if (cur==size) return result();; 131 ; 132 // Next character must be one of B/empty/whitespace; 133 switch (toupper(str[cur])) {; 134 case 'B':; 135 case ' ':; 136 case '\t': ++cur; break;; 137 ; 138 case '\0': return result();; 139 ; 140 default: return EFromHumanReadableSize::kParseFail;; 141 }; 142 ; 143 // Skip any remaining white space; 144 // while (cur<size && isspace(str[cur])) ++cur;; 145 ; 146 // Do not:; 147 // Parse error on anything but a null terminator; 148 // if (cur<size) return -1;; 149 ; 150 return result();; 151 } catch (...) {; 152 return EFromHumanReadableSize::kParseFail;; 153 }; 154 ; 155}; 156 ; 157} // namespace ROOT.; 158 ; 159#endif // ROOT_StringConv; sizesize_t size(const MatrixT &matr",MatchSource.WIKI,doc/v632/StringConv_8hxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/StringConv_8hxx_source.html
https://root.cern/doc/v632/StringConv_8hxx_source.html:3217,Deployability,update,updated,3217,"nt) (std::log(bytes) / std::log(unit); 58 // in the case of bytes==unit ends up surprisingly to be zero; 59 // rather than one, so 'hard code' the result; 60 exp = 1;; 61 } else if (bytes > 0) {; 62 exp = std::min( (int) (std::log(bytes) / std::log(unit)),; 63 (int) (sizeof(suffix) / sizeof(suffix[0]) - 1));; 64 }; 65 *coeff = bytes / std::pow(unit, exp);; 66 *units = suffix[exp][!si];; 67}; 68 ; 69enum class EFromHumanReadableSize {; 70 kSuccess,; 71 kParseFail,; 72 kOverflow; 73};; 74 ; 75///////////////////////////////////////////////////////////////////////////////; 76/// Convert strings like the following into byte counts; 77/// 5MB, 5 MB, 5M, 3.7GB, 123b, 456kB, 3.7GiB, 5MiB; 78/// with some amount of forgiveness baked into the parsing.; 79/// For this routine we use the official SI unit where the [i] is reserved; 80/// for the 'legacy' power of two units. 1KB = 1000 bytes, 1KiB = 1024 bytes.; 81/// \param str the string to be parsed; 82/// \param value will be updated with the result if and only if the parse is successful and does not overflow for the type of value.; 83/// \return return a EFromHumanReadableSize enum value indicating the success or failure of the parse.; 84///; 85template <typename T>; 86EFromHumanReadableSize FromHumanReadableSize(std::string_view str, T &value); 87{; 88 try {; 89 size_t cur, size = str.size();; 90 // Parse leading numeric factor; 91 const double coeff = stod(std::string(str.data(), str.size()), &cur);; 92 ; 93 // Skip any intermediate white space; 94 while (cur<size && isspace(str[cur])) ++cur;; 95 ; 96 // Read off first character which should be an SI prefix; 97 int exp = 0, unit = 1000;; 98 ; 99 auto result = [coeff,&exp,&unit,&value]() {; 100 double v = exp ? coeff * std::pow(unit, exp / 3) : coeff;; 101 if (v < (double) std::numeric_limits<T>::max()) {; 102 value = (T)v;; 103 return EFromHumanReadableSize::kSuccess;; 104 } else {; 105 return EFromHumanReadableSize::kOverflow;; 106 }; 107 };; 108 if (cur==size) return re",MatchSource.WIKI,doc/v632/StringConv_8hxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/StringConv_8hxx_source.html
https://root.cern/doc/v632/StringConv_8hxx_source.html:3090,Energy Efficiency,power,power,3090,"B"" },; 51 { ""ZB"", ""ZiB"" },; 52 { ""YB"", ""YiB"" } };; 53 value_type unit = si ? 1000 : 1024;; 54 int exp = 0;; 55 if (bytes == unit) {; 56 // On some 32bit platforms, the result of; 57 // (int) (std::log(bytes) / std::log(unit); 58 // in the case of bytes==unit ends up surprisingly to be zero; 59 // rather than one, so 'hard code' the result; 60 exp = 1;; 61 } else if (bytes > 0) {; 62 exp = std::min( (int) (std::log(bytes) / std::log(unit)),; 63 (int) (sizeof(suffix) / sizeof(suffix[0]) - 1));; 64 }; 65 *coeff = bytes / std::pow(unit, exp);; 66 *units = suffix[exp][!si];; 67}; 68 ; 69enum class EFromHumanReadableSize {; 70 kSuccess,; 71 kParseFail,; 72 kOverflow; 73};; 74 ; 75///////////////////////////////////////////////////////////////////////////////; 76/// Convert strings like the following into byte counts; 77/// 5MB, 5 MB, 5M, 3.7GB, 123b, 456kB, 3.7GiB, 5MiB; 78/// with some amount of forgiveness baked into the parsing.; 79/// For this routine we use the official SI unit where the [i] is reserved; 80/// for the 'legacy' power of two units. 1KB = 1000 bytes, 1KiB = 1024 bytes.; 81/// \param str the string to be parsed; 82/// \param value will be updated with the result if and only if the parse is successful and does not overflow for the type of value.; 83/// \return return a EFromHumanReadableSize enum value indicating the success or failure of the parse.; 84///; 85template <typename T>; 86EFromHumanReadableSize FromHumanReadableSize(std::string_view str, T &value); 87{; 88 try {; 89 size_t cur, size = str.size();; 90 // Parse leading numeric factor; 91 const double coeff = stod(std::string(str.data(), str.size()), &cur);; 92 ; 93 // Skip any intermediate white space; 94 while (cur<size && isspace(str[cur])) ++cur;; 95 ; 96 // Read off first character which should be an SI prefix; 97 int exp = 0, unit = 1000;; 98 ; 99 auto result = [coeff,&exp,&unit,&value]() {; 100 double v = exp ? coeff * std::pow(unit, exp / 3) : coeff;; 101 if (v < (double) std::numeric_lim",MatchSource.WIKI,doc/v632/StringConv_8hxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/StringConv_8hxx_source.html
https://root.cern/doc/v632/StringConv_8hxx_source.html:3004,Integrability,rout,routine,3004,"B"" },; 51 { ""ZB"", ""ZiB"" },; 52 { ""YB"", ""YiB"" } };; 53 value_type unit = si ? 1000 : 1024;; 54 int exp = 0;; 55 if (bytes == unit) {; 56 // On some 32bit platforms, the result of; 57 // (int) (std::log(bytes) / std::log(unit); 58 // in the case of bytes==unit ends up surprisingly to be zero; 59 // rather than one, so 'hard code' the result; 60 exp = 1;; 61 } else if (bytes > 0) {; 62 exp = std::min( (int) (std::log(bytes) / std::log(unit)),; 63 (int) (sizeof(suffix) / sizeof(suffix[0]) - 1));; 64 }; 65 *coeff = bytes / std::pow(unit, exp);; 66 *units = suffix[exp][!si];; 67}; 68 ; 69enum class EFromHumanReadableSize {; 70 kSuccess,; 71 kParseFail,; 72 kOverflow; 73};; 74 ; 75///////////////////////////////////////////////////////////////////////////////; 76/// Convert strings like the following into byte counts; 77/// 5MB, 5 MB, 5M, 3.7GB, 123b, 456kB, 3.7GiB, 5MiB; 78/// with some amount of forgiveness baked into the parsing.; 79/// For this routine we use the official SI unit where the [i] is reserved; 80/// for the 'legacy' power of two units. 1KB = 1000 bytes, 1KiB = 1024 bytes.; 81/// \param str the string to be parsed; 82/// \param value will be updated with the result if and only if the parse is successful and does not overflow for the type of value.; 83/// \return return a EFromHumanReadableSize enum value indicating the success or failure of the parse.; 84///; 85template <typename T>; 86EFromHumanReadableSize FromHumanReadableSize(std::string_view str, T &value); 87{; 88 try {; 89 size_t cur, size = str.size();; 90 // Parse leading numeric factor; 91 const double coeff = stod(std::string(str.data(), str.size()), &cur);; 92 ; 93 // Skip any intermediate white space; 94 while (cur<size && isspace(str[cur])) ++cur;; 95 ; 96 // Read off first character which should be an SI prefix; 97 int exp = 0, unit = 1000;; 98 ; 99 auto result = [coeff,&exp,&unit,&value]() {; 100 double v = exp ? coeff * std::pow(unit, exp / 3) : coeff;; 101 if (v < (double) std::numeric_lim",MatchSource.WIKI,doc/v632/StringConv_8hxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/StringConv_8hxx_source.html
https://root.cern/doc/v632/StringConv_8hxx_source.html:2245,Testability,log,log,2245,"/info-stuff/bytecalc.html for example.; 30 ; 31///////////////////////////////////////////////////////////////////////////////; 32/// Return the size expressed in 'human readable' format.; 33/// \param bytes the size in bytes to be converted; 34/// \param si whether to use the SI units or not.; 35/// \param coeff return the size expressed in the new unit.; 36/// \param units return a pointer to the string representation of the new unit; 37template <typename value_type>; 38void ToHumanReadableSize(value_type bytes,; 39 Bool_t si,; 40 Double_t *coeff,; 41 const char **units); 42{; 43 // Static lookup table of byte-based SI units; 44 static const char *const suffix[][2] =; 45 { { ""B"", ""B"" },; 46 { ""KB"", ""KiB"" },; 47 { ""MB"", ""MiB"" },; 48 { ""GB"", ""GiB"" },; 49 { ""TB"", ""TiB"" },; 50 { ""EB"", ""EiB"" },; 51 { ""ZB"", ""ZiB"" },; 52 { ""YB"", ""YiB"" } };; 53 value_type unit = si ? 1000 : 1024;; 54 int exp = 0;; 55 if (bytes == unit) {; 56 // On some 32bit platforms, the result of; 57 // (int) (std::log(bytes) / std::log(unit); 58 // in the case of bytes==unit ends up surprisingly to be zero; 59 // rather than one, so 'hard code' the result; 60 exp = 1;; 61 } else if (bytes > 0) {; 62 exp = std::min( (int) (std::log(bytes) / std::log(unit)),; 63 (int) (sizeof(suffix) / sizeof(suffix[0]) - 1));; 64 }; 65 *coeff = bytes / std::pow(unit, exp);; 66 *units = suffix[exp][!si];; 67}; 68 ; 69enum class EFromHumanReadableSize {; 70 kSuccess,; 71 kParseFail,; 72 kOverflow; 73};; 74 ; 75///////////////////////////////////////////////////////////////////////////////; 76/// Convert strings like the following into byte counts; 77/// 5MB, 5 MB, 5M, 3.7GB, 123b, 456kB, 3.7GiB, 5MiB; 78/// with some amount of forgiveness baked into the parsing.; 79/// For this routine we use the official SI unit where the [i] is reserved; 80/// for the 'legacy' power of two units. 1KB = 1000 bytes, 1KiB = 1024 bytes.; 81/// \param str the string to be parsed; 82/// \param value will be updated with the result if and onl",MatchSource.WIKI,doc/v632/StringConv_8hxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/StringConv_8hxx_source.html
https://root.cern/doc/v632/StringConv_8hxx_source.html:2263,Testability,log,log,2263,"/info-stuff/bytecalc.html for example.; 30 ; 31///////////////////////////////////////////////////////////////////////////////; 32/// Return the size expressed in 'human readable' format.; 33/// \param bytes the size in bytes to be converted; 34/// \param si whether to use the SI units or not.; 35/// \param coeff return the size expressed in the new unit.; 36/// \param units return a pointer to the string representation of the new unit; 37template <typename value_type>; 38void ToHumanReadableSize(value_type bytes,; 39 Bool_t si,; 40 Double_t *coeff,; 41 const char **units); 42{; 43 // Static lookup table of byte-based SI units; 44 static const char *const suffix[][2] =; 45 { { ""B"", ""B"" },; 46 { ""KB"", ""KiB"" },; 47 { ""MB"", ""MiB"" },; 48 { ""GB"", ""GiB"" },; 49 { ""TB"", ""TiB"" },; 50 { ""EB"", ""EiB"" },; 51 { ""ZB"", ""ZiB"" },; 52 { ""YB"", ""YiB"" } };; 53 value_type unit = si ? 1000 : 1024;; 54 int exp = 0;; 55 if (bytes == unit) {; 56 // On some 32bit platforms, the result of; 57 // (int) (std::log(bytes) / std::log(unit); 58 // in the case of bytes==unit ends up surprisingly to be zero; 59 // rather than one, so 'hard code' the result; 60 exp = 1;; 61 } else if (bytes > 0) {; 62 exp = std::min( (int) (std::log(bytes) / std::log(unit)),; 63 (int) (sizeof(suffix) / sizeof(suffix[0]) - 1));; 64 }; 65 *coeff = bytes / std::pow(unit, exp);; 66 *units = suffix[exp][!si];; 67}; 68 ; 69enum class EFromHumanReadableSize {; 70 kSuccess,; 71 kParseFail,; 72 kOverflow; 73};; 74 ; 75///////////////////////////////////////////////////////////////////////////////; 76/// Convert strings like the following into byte counts; 77/// 5MB, 5 MB, 5M, 3.7GB, 123b, 456kB, 3.7GiB, 5MiB; 78/// with some amount of forgiveness baked into the parsing.; 79/// For this routine we use the official SI unit where the [i] is reserved; 80/// for the 'legacy' power of two units. 1KB = 1000 bytes, 1KiB = 1024 bytes.; 81/// \param str the string to be parsed; 82/// \param value will be updated with the result if and onl",MatchSource.WIKI,doc/v632/StringConv_8hxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/StringConv_8hxx_source.html
https://root.cern/doc/v632/StringConv_8hxx_source.html:2462,Testability,log,log,2462,"/info-stuff/bytecalc.html for example.; 30 ; 31///////////////////////////////////////////////////////////////////////////////; 32/// Return the size expressed in 'human readable' format.; 33/// \param bytes the size in bytes to be converted; 34/// \param si whether to use the SI units or not.; 35/// \param coeff return the size expressed in the new unit.; 36/// \param units return a pointer to the string representation of the new unit; 37template <typename value_type>; 38void ToHumanReadableSize(value_type bytes,; 39 Bool_t si,; 40 Double_t *coeff,; 41 const char **units); 42{; 43 // Static lookup table of byte-based SI units; 44 static const char *const suffix[][2] =; 45 { { ""B"", ""B"" },; 46 { ""KB"", ""KiB"" },; 47 { ""MB"", ""MiB"" },; 48 { ""GB"", ""GiB"" },; 49 { ""TB"", ""TiB"" },; 50 { ""EB"", ""EiB"" },; 51 { ""ZB"", ""ZiB"" },; 52 { ""YB"", ""YiB"" } };; 53 value_type unit = si ? 1000 : 1024;; 54 int exp = 0;; 55 if (bytes == unit) {; 56 // On some 32bit platforms, the result of; 57 // (int) (std::log(bytes) / std::log(unit); 58 // in the case of bytes==unit ends up surprisingly to be zero; 59 // rather than one, so 'hard code' the result; 60 exp = 1;; 61 } else if (bytes > 0) {; 62 exp = std::min( (int) (std::log(bytes) / std::log(unit)),; 63 (int) (sizeof(suffix) / sizeof(suffix[0]) - 1));; 64 }; 65 *coeff = bytes / std::pow(unit, exp);; 66 *units = suffix[exp][!si];; 67}; 68 ; 69enum class EFromHumanReadableSize {; 70 kSuccess,; 71 kParseFail,; 72 kOverflow; 73};; 74 ; 75///////////////////////////////////////////////////////////////////////////////; 76/// Convert strings like the following into byte counts; 77/// 5MB, 5 MB, 5M, 3.7GB, 123b, 456kB, 3.7GiB, 5MiB; 78/// with some amount of forgiveness baked into the parsing.; 79/// For this routine we use the official SI unit where the [i] is reserved; 80/// for the 'legacy' power of two units. 1KB = 1000 bytes, 1KiB = 1024 bytes.; 81/// \param str the string to be parsed; 82/// \param value will be updated with the result if and onl",MatchSource.WIKI,doc/v632/StringConv_8hxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/StringConv_8hxx_source.html
https://root.cern/doc/v632/StringConv_8hxx_source.html:2480,Testability,log,log,2480,"/info-stuff/bytecalc.html for example.; 30 ; 31///////////////////////////////////////////////////////////////////////////////; 32/// Return the size expressed in 'human readable' format.; 33/// \param bytes the size in bytes to be converted; 34/// \param si whether to use the SI units or not.; 35/// \param coeff return the size expressed in the new unit.; 36/// \param units return a pointer to the string representation of the new unit; 37template <typename value_type>; 38void ToHumanReadableSize(value_type bytes,; 39 Bool_t si,; 40 Double_t *coeff,; 41 const char **units); 42{; 43 // Static lookup table of byte-based SI units; 44 static const char *const suffix[][2] =; 45 { { ""B"", ""B"" },; 46 { ""KB"", ""KiB"" },; 47 { ""MB"", ""MiB"" },; 48 { ""GB"", ""GiB"" },; 49 { ""TB"", ""TiB"" },; 50 { ""EB"", ""EiB"" },; 51 { ""ZB"", ""ZiB"" },; 52 { ""YB"", ""YiB"" } };; 53 value_type unit = si ? 1000 : 1024;; 54 int exp = 0;; 55 if (bytes == unit) {; 56 // On some 32bit platforms, the result of; 57 // (int) (std::log(bytes) / std::log(unit); 58 // in the case of bytes==unit ends up surprisingly to be zero; 59 // rather than one, so 'hard code' the result; 60 exp = 1;; 61 } else if (bytes > 0) {; 62 exp = std::min( (int) (std::log(bytes) / std::log(unit)),; 63 (int) (sizeof(suffix) / sizeof(suffix[0]) - 1));; 64 }; 65 *coeff = bytes / std::pow(unit, exp);; 66 *units = suffix[exp][!si];; 67}; 68 ; 69enum class EFromHumanReadableSize {; 70 kSuccess,; 71 kParseFail,; 72 kOverflow; 73};; 74 ; 75///////////////////////////////////////////////////////////////////////////////; 76/// Convert strings like the following into byte counts; 77/// 5MB, 5 MB, 5M, 3.7GB, 123b, 456kB, 3.7GiB, 5MiB; 78/// with some amount of forgiveness baked into the parsing.; 79/// For this routine we use the official SI unit where the [i] is reserved; 80/// for the 'legacy' power of two units. 1KB = 1000 bytes, 1KiB = 1024 bytes.; 81/// \param str the string to be parsed; 82/// \param value will be updated with the result if and onl",MatchSource.WIKI,doc/v632/StringConv_8hxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/StringConv_8hxx_source.html
https://root.cern/doc/v632/structConfiguration.html:387,Deployability,integrat,integrateOverBinsPrecision,387,. ROOT: Configuration Struct Reference. ; ROOT ; . v6-32. Reference Guide ; . . Loading...; Searching...; No Matches. List of all members |; Public Attributes |; List of all members ; Configuration Struct Reference. . Definition at line 3 of file RooAbsTestStatistic.h. Public Attributes; std::stringaddCoefRangeName; ; boolbinnedL = false; ; boolcloneInputData = true; ; doubleintegrateOverBinsPrecision = -1.; ; RooFit::MPSplitinterleave = RooFit::BulkPartition; ; intnCPU = 1; ; std::stringrangeName; Stores the configuration parameters for RooAbsTestStatistic. ; ; boolsplitCutRange = false; ; booltakeGlobalObservablesFromData = false; ; boolverbose = true; . #include <RooAbsTestStatistic.h>; Member Data Documentation. addCoefRangeName. std::string Configuration::addCoefRangeName. Definition at line 6 of file RooAbsTestStatistic.h. binnedL. bool Configuration::binnedL = false. Definition at line 13 of file RooAbsTestStatistic.h. cloneInputData. bool Configuration::cloneInputData = true. Definition at line 11 of file RooAbsTestStatistic.h. integrateOverBinsPrecision. double Configuration::integrateOverBinsPrecision = -1. Definition at line 12 of file RooAbsTestStatistic.h. interleave. RooFit::MPSplit Configuration::interleave = RooFit::BulkPartition. Definition at line 8 of file RooAbsTestStatistic.h. nCPU. int Configuration::nCPU = 1. Definition at line 7 of file RooAbsTestStatistic.h. rangeName. std::string Configuration::rangeName. Stores the configuration parameters for RooAbsTestStatistic. ; Definition at line 5 of file RooAbsTestStatistic.h. splitCutRange. bool Configuration::splitCutRange = false. Definition at line 10 of file RooAbsTestStatistic.h. takeGlobalObservablesFromData. bool Configuration::takeGlobalObservablesFromData = false. Definition at line 14 of file RooAbsTestStatistic.h. verbose. bool Configuration::verbose = true. Definition at line 9 of file RooAbsTestStatistic.h. Collaboration diagram for Configurati,MatchSource.WIKI,doc/v632/structConfiguration.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/structConfiguration.html
https://root.cern/doc/v632/structConfiguration.html:531,Deployability,configurat,configuration,531,. ROOT: Configuration Struct Reference. ; ROOT ; . v6-32. Reference Guide ; . . Loading...; Searching...; No Matches. List of all members |; Public Attributes |; List of all members ; Configuration Struct Reference. . Definition at line 3 of file RooAbsTestStatistic.h. Public Attributes; std::stringaddCoefRangeName; ; boolbinnedL = false; ; boolcloneInputData = true; ; doubleintegrateOverBinsPrecision = -1.; ; RooFit::MPSplitinterleave = RooFit::BulkPartition; ; intnCPU = 1; ; std::stringrangeName; Stores the configuration parameters for RooAbsTestStatistic. ; ; boolsplitCutRange = false; ; booltakeGlobalObservablesFromData = false; ; boolverbose = true; . #include <RooAbsTestStatistic.h>; Member Data Documentation. addCoefRangeName. std::string Configuration::addCoefRangeName. Definition at line 6 of file RooAbsTestStatistic.h. binnedL. bool Configuration::binnedL = false. Definition at line 13 of file RooAbsTestStatistic.h. cloneInputData. bool Configuration::cloneInputData = true. Definition at line 11 of file RooAbsTestStatistic.h. integrateOverBinsPrecision. double Configuration::integrateOverBinsPrecision = -1. Definition at line 12 of file RooAbsTestStatistic.h. interleave. RooFit::MPSplit Configuration::interleave = RooFit::BulkPartition. Definition at line 8 of file RooAbsTestStatistic.h. nCPU. int Configuration::nCPU = 1. Definition at line 7 of file RooAbsTestStatistic.h. rangeName. std::string Configuration::rangeName. Stores the configuration parameters for RooAbsTestStatistic. ; Definition at line 5 of file RooAbsTestStatistic.h. splitCutRange. bool Configuration::splitCutRange = false. Definition at line 10 of file RooAbsTestStatistic.h. takeGlobalObservablesFromData. bool Configuration::takeGlobalObservablesFromData = false. Definition at line 14 of file RooAbsTestStatistic.h. verbose. bool Configuration::verbose = true. Definition at line 9 of file RooAbsTestStatistic.h. Collaboration diagram for Configurati,MatchSource.WIKI,doc/v632/structConfiguration.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/structConfiguration.html
https://root.cern/doc/v632/structConfiguration.html:1083,Deployability,integrat,integrateOverBinsPrecision,1083,"earching...; No Matches. List of all members |; Public Attributes |; List of all members ; Configuration Struct Reference. . Definition at line 3 of file RooAbsTestStatistic.h. Public Attributes; std::stringaddCoefRangeName; ; boolbinnedL = false; ; boolcloneInputData = true; ; doubleintegrateOverBinsPrecision = -1.; ; RooFit::MPSplitinterleave = RooFit::BulkPartition; ; intnCPU = 1; ; std::stringrangeName; Stores the configuration parameters for RooAbsTestStatistic. ; ; boolsplitCutRange = false; ; booltakeGlobalObservablesFromData = false; ; boolverbose = true; . #include <RooAbsTestStatistic.h>; Member Data Documentation. addCoefRangeName. std::string Configuration::addCoefRangeName. Definition at line 6 of file RooAbsTestStatistic.h. binnedL. bool Configuration::binnedL = false. Definition at line 13 of file RooAbsTestStatistic.h. cloneInputData. bool Configuration::cloneInputData = true. Definition at line 11 of file RooAbsTestStatistic.h. integrateOverBinsPrecision. double Configuration::integrateOverBinsPrecision = -1. Definition at line 12 of file RooAbsTestStatistic.h. interleave. RooFit::MPSplit Configuration::interleave = RooFit::BulkPartition. Definition at line 8 of file RooAbsTestStatistic.h. nCPU. int Configuration::nCPU = 1. Definition at line 7 of file RooAbsTestStatistic.h. rangeName. std::string Configuration::rangeName. Stores the configuration parameters for RooAbsTestStatistic. ; Definition at line 5 of file RooAbsTestStatistic.h. splitCutRange. bool Configuration::splitCutRange = false. Definition at line 10 of file RooAbsTestStatistic.h. takeGlobalObservablesFromData. bool Configuration::takeGlobalObservablesFromData = false. Definition at line 14 of file RooAbsTestStatistic.h. verbose. bool Configuration::verbose = true. Definition at line 9 of file RooAbsTestStatistic.h. Collaboration diagram for Configuration:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.; [le",MatchSource.WIKI,doc/v632/structConfiguration.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/structConfiguration.html
https://root.cern/doc/v632/structConfiguration.html:1133,Deployability,integrat,integrateOverBinsPrecision,1133,"rs |; Public Attributes |; List of all members ; Configuration Struct Reference. . Definition at line 3 of file RooAbsTestStatistic.h. Public Attributes; std::stringaddCoefRangeName; ; boolbinnedL = false; ; boolcloneInputData = true; ; doubleintegrateOverBinsPrecision = -1.; ; RooFit::MPSplitinterleave = RooFit::BulkPartition; ; intnCPU = 1; ; std::stringrangeName; Stores the configuration parameters for RooAbsTestStatistic. ; ; boolsplitCutRange = false; ; booltakeGlobalObservablesFromData = false; ; boolverbose = true; . #include <RooAbsTestStatistic.h>; Member Data Documentation. addCoefRangeName. std::string Configuration::addCoefRangeName. Definition at line 6 of file RooAbsTestStatistic.h. binnedL. bool Configuration::binnedL = false. Definition at line 13 of file RooAbsTestStatistic.h. cloneInputData. bool Configuration::cloneInputData = true. Definition at line 11 of file RooAbsTestStatistic.h. integrateOverBinsPrecision. double Configuration::integrateOverBinsPrecision = -1. Definition at line 12 of file RooAbsTestStatistic.h. interleave. RooFit::MPSplit Configuration::interleave = RooFit::BulkPartition. Definition at line 8 of file RooAbsTestStatistic.h. nCPU. int Configuration::nCPU = 1. Definition at line 7 of file RooAbsTestStatistic.h. rangeName. std::string Configuration::rangeName. Stores the configuration parameters for RooAbsTestStatistic. ; Definition at line 5 of file RooAbsTestStatistic.h. splitCutRange. bool Configuration::splitCutRange = false. Definition at line 10 of file RooAbsTestStatistic.h. takeGlobalObservablesFromData. bool Configuration::takeGlobalObservablesFromData = false. Definition at line 14 of file RooAbsTestStatistic.h. verbose. bool Configuration::verbose = true. Definition at line 9 of file RooAbsTestStatistic.h. Collaboration diagram for Configuration:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.; [legend]; The documentation for this struct wa",MatchSource.WIKI,doc/v632/structConfiguration.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/structConfiguration.html
https://root.cern/doc/v632/structConfiguration.html:1503,Deployability,configurat,configuration,1503,"false; ; boolcloneInputData = true; ; doubleintegrateOverBinsPrecision = -1.; ; RooFit::MPSplitinterleave = RooFit::BulkPartition; ; intnCPU = 1; ; std::stringrangeName; Stores the configuration parameters for RooAbsTestStatistic. ; ; boolsplitCutRange = false; ; booltakeGlobalObservablesFromData = false; ; boolverbose = true; . #include <RooAbsTestStatistic.h>; Member Data Documentation. addCoefRangeName. std::string Configuration::addCoefRangeName. Definition at line 6 of file RooAbsTestStatistic.h. binnedL. bool Configuration::binnedL = false. Definition at line 13 of file RooAbsTestStatistic.h. cloneInputData. bool Configuration::cloneInputData = true. Definition at line 11 of file RooAbsTestStatistic.h. integrateOverBinsPrecision. double Configuration::integrateOverBinsPrecision = -1. Definition at line 12 of file RooAbsTestStatistic.h. interleave. RooFit::MPSplit Configuration::interleave = RooFit::BulkPartition. Definition at line 8 of file RooAbsTestStatistic.h. nCPU. int Configuration::nCPU = 1. Definition at line 7 of file RooAbsTestStatistic.h. rangeName. std::string Configuration::rangeName. Stores the configuration parameters for RooAbsTestStatistic. ; Definition at line 5 of file RooAbsTestStatistic.h. splitCutRange. bool Configuration::splitCutRange = false. Definition at line 10 of file RooAbsTestStatistic.h. takeGlobalObservablesFromData. bool Configuration::takeGlobalObservablesFromData = false. Definition at line 14 of file RooAbsTestStatistic.h. verbose. bool Configuration::verbose = true. Definition at line 9 of file RooAbsTestStatistic.h. Collaboration diagram for Configuration:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.; [legend]; The documentation for this struct was generated from the following file:; roofit/roofitcore/inc/RooAbsTestStatistic.h. Configuration. ROOT v6-32 - Reference Guide Generated on Fri Nov 1 2024 15:10:10 (GVA Time) using Doxygen 1.9.8 ; . ",MatchSource.WIKI,doc/v632/structConfiguration.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/structConfiguration.html
https://root.cern/doc/v632/structConfiguration.html:387,Integrability,integrat,integrateOverBinsPrecision,387,. ROOT: Configuration Struct Reference. ; ROOT ; . v6-32. Reference Guide ; . . Loading...; Searching...; No Matches. List of all members |; Public Attributes |; List of all members ; Configuration Struct Reference. . Definition at line 3 of file RooAbsTestStatistic.h. Public Attributes; std::stringaddCoefRangeName; ; boolbinnedL = false; ; boolcloneInputData = true; ; doubleintegrateOverBinsPrecision = -1.; ; RooFit::MPSplitinterleave = RooFit::BulkPartition; ; intnCPU = 1; ; std::stringrangeName; Stores the configuration parameters for RooAbsTestStatistic. ; ; boolsplitCutRange = false; ; booltakeGlobalObservablesFromData = false; ; boolverbose = true; . #include <RooAbsTestStatistic.h>; Member Data Documentation. addCoefRangeName. std::string Configuration::addCoefRangeName. Definition at line 6 of file RooAbsTestStatistic.h. binnedL. bool Configuration::binnedL = false. Definition at line 13 of file RooAbsTestStatistic.h. cloneInputData. bool Configuration::cloneInputData = true. Definition at line 11 of file RooAbsTestStatistic.h. integrateOverBinsPrecision. double Configuration::integrateOverBinsPrecision = -1. Definition at line 12 of file RooAbsTestStatistic.h. interleave. RooFit::MPSplit Configuration::interleave = RooFit::BulkPartition. Definition at line 8 of file RooAbsTestStatistic.h. nCPU. int Configuration::nCPU = 1. Definition at line 7 of file RooAbsTestStatistic.h. rangeName. std::string Configuration::rangeName. Stores the configuration parameters for RooAbsTestStatistic. ; Definition at line 5 of file RooAbsTestStatistic.h. splitCutRange. bool Configuration::splitCutRange = false. Definition at line 10 of file RooAbsTestStatistic.h. takeGlobalObservablesFromData. bool Configuration::takeGlobalObservablesFromData = false. Definition at line 14 of file RooAbsTestStatistic.h. verbose. bool Configuration::verbose = true. Definition at line 9 of file RooAbsTestStatistic.h. Collaboration diagram for Configurati,MatchSource.WIKI,doc/v632/structConfiguration.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/structConfiguration.html
https://root.cern/doc/v632/structConfiguration.html:1083,Integrability,integrat,integrateOverBinsPrecision,1083,"earching...; No Matches. List of all members |; Public Attributes |; List of all members ; Configuration Struct Reference. . Definition at line 3 of file RooAbsTestStatistic.h. Public Attributes; std::stringaddCoefRangeName; ; boolbinnedL = false; ; boolcloneInputData = true; ; doubleintegrateOverBinsPrecision = -1.; ; RooFit::MPSplitinterleave = RooFit::BulkPartition; ; intnCPU = 1; ; std::stringrangeName; Stores the configuration parameters for RooAbsTestStatistic. ; ; boolsplitCutRange = false; ; booltakeGlobalObservablesFromData = false; ; boolverbose = true; . #include <RooAbsTestStatistic.h>; Member Data Documentation. addCoefRangeName. std::string Configuration::addCoefRangeName. Definition at line 6 of file RooAbsTestStatistic.h. binnedL. bool Configuration::binnedL = false. Definition at line 13 of file RooAbsTestStatistic.h. cloneInputData. bool Configuration::cloneInputData = true. Definition at line 11 of file RooAbsTestStatistic.h. integrateOverBinsPrecision. double Configuration::integrateOverBinsPrecision = -1. Definition at line 12 of file RooAbsTestStatistic.h. interleave. RooFit::MPSplit Configuration::interleave = RooFit::BulkPartition. Definition at line 8 of file RooAbsTestStatistic.h. nCPU. int Configuration::nCPU = 1. Definition at line 7 of file RooAbsTestStatistic.h. rangeName. std::string Configuration::rangeName. Stores the configuration parameters for RooAbsTestStatistic. ; Definition at line 5 of file RooAbsTestStatistic.h. splitCutRange. bool Configuration::splitCutRange = false. Definition at line 10 of file RooAbsTestStatistic.h. takeGlobalObservablesFromData. bool Configuration::takeGlobalObservablesFromData = false. Definition at line 14 of file RooAbsTestStatistic.h. verbose. bool Configuration::verbose = true. Definition at line 9 of file RooAbsTestStatistic.h. Collaboration diagram for Configuration:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.; [le",MatchSource.WIKI,doc/v632/structConfiguration.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/structConfiguration.html
https://root.cern/doc/v632/structConfiguration.html:1133,Integrability,integrat,integrateOverBinsPrecision,1133,"rs |; Public Attributes |; List of all members ; Configuration Struct Reference. . Definition at line 3 of file RooAbsTestStatistic.h. Public Attributes; std::stringaddCoefRangeName; ; boolbinnedL = false; ; boolcloneInputData = true; ; doubleintegrateOverBinsPrecision = -1.; ; RooFit::MPSplitinterleave = RooFit::BulkPartition; ; intnCPU = 1; ; std::stringrangeName; Stores the configuration parameters for RooAbsTestStatistic. ; ; boolsplitCutRange = false; ; booltakeGlobalObservablesFromData = false; ; boolverbose = true; . #include <RooAbsTestStatistic.h>; Member Data Documentation. addCoefRangeName. std::string Configuration::addCoefRangeName. Definition at line 6 of file RooAbsTestStatistic.h. binnedL. bool Configuration::binnedL = false. Definition at line 13 of file RooAbsTestStatistic.h. cloneInputData. bool Configuration::cloneInputData = true. Definition at line 11 of file RooAbsTestStatistic.h. integrateOverBinsPrecision. double Configuration::integrateOverBinsPrecision = -1. Definition at line 12 of file RooAbsTestStatistic.h. interleave. RooFit::MPSplit Configuration::interleave = RooFit::BulkPartition. Definition at line 8 of file RooAbsTestStatistic.h. nCPU. int Configuration::nCPU = 1. Definition at line 7 of file RooAbsTestStatistic.h. rangeName. std::string Configuration::rangeName. Stores the configuration parameters for RooAbsTestStatistic. ; Definition at line 5 of file RooAbsTestStatistic.h. splitCutRange. bool Configuration::splitCutRange = false. Definition at line 10 of file RooAbsTestStatistic.h. takeGlobalObservablesFromData. bool Configuration::takeGlobalObservablesFromData = false. Definition at line 14 of file RooAbsTestStatistic.h. verbose. bool Configuration::verbose = true. Definition at line 9 of file RooAbsTestStatistic.h. Collaboration diagram for Configuration:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.; [legend]; The documentation for this struct wa",MatchSource.WIKI,doc/v632/structConfiguration.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/structConfiguration.html
https://root.cern/doc/v632/structConfiguration.html:531,Modifiability,config,configuration,531,. ROOT: Configuration Struct Reference. ; ROOT ; . v6-32. Reference Guide ; . . Loading...; Searching...; No Matches. List of all members |; Public Attributes |; List of all members ; Configuration Struct Reference. . Definition at line 3 of file RooAbsTestStatistic.h. Public Attributes; std::stringaddCoefRangeName; ; boolbinnedL = false; ; boolcloneInputData = true; ; doubleintegrateOverBinsPrecision = -1.; ; RooFit::MPSplitinterleave = RooFit::BulkPartition; ; intnCPU = 1; ; std::stringrangeName; Stores the configuration parameters for RooAbsTestStatistic. ; ; boolsplitCutRange = false; ; booltakeGlobalObservablesFromData = false; ; boolverbose = true; . #include <RooAbsTestStatistic.h>; Member Data Documentation. addCoefRangeName. std::string Configuration::addCoefRangeName. Definition at line 6 of file RooAbsTestStatistic.h. binnedL. bool Configuration::binnedL = false. Definition at line 13 of file RooAbsTestStatistic.h. cloneInputData. bool Configuration::cloneInputData = true. Definition at line 11 of file RooAbsTestStatistic.h. integrateOverBinsPrecision. double Configuration::integrateOverBinsPrecision = -1. Definition at line 12 of file RooAbsTestStatistic.h. interleave. RooFit::MPSplit Configuration::interleave = RooFit::BulkPartition. Definition at line 8 of file RooAbsTestStatistic.h. nCPU. int Configuration::nCPU = 1. Definition at line 7 of file RooAbsTestStatistic.h. rangeName. std::string Configuration::rangeName. Stores the configuration parameters for RooAbsTestStatistic. ; Definition at line 5 of file RooAbsTestStatistic.h. splitCutRange. bool Configuration::splitCutRange = false. Definition at line 10 of file RooAbsTestStatistic.h. takeGlobalObservablesFromData. bool Configuration::takeGlobalObservablesFromData = false. Definition at line 14 of file RooAbsTestStatistic.h. verbose. bool Configuration::verbose = true. Definition at line 9 of file RooAbsTestStatistic.h. Collaboration diagram for Configurati,MatchSource.WIKI,doc/v632/structConfiguration.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/structConfiguration.html
https://root.cern/doc/v632/structConfiguration.html:1503,Modifiability,config,configuration,1503,"false; ; boolcloneInputData = true; ; doubleintegrateOverBinsPrecision = -1.; ; RooFit::MPSplitinterleave = RooFit::BulkPartition; ; intnCPU = 1; ; std::stringrangeName; Stores the configuration parameters for RooAbsTestStatistic. ; ; boolsplitCutRange = false; ; booltakeGlobalObservablesFromData = false; ; boolverbose = true; . #include <RooAbsTestStatistic.h>; Member Data Documentation. addCoefRangeName. std::string Configuration::addCoefRangeName. Definition at line 6 of file RooAbsTestStatistic.h. binnedL. bool Configuration::binnedL = false. Definition at line 13 of file RooAbsTestStatistic.h. cloneInputData. bool Configuration::cloneInputData = true. Definition at line 11 of file RooAbsTestStatistic.h. integrateOverBinsPrecision. double Configuration::integrateOverBinsPrecision = -1. Definition at line 12 of file RooAbsTestStatistic.h. interleave. RooFit::MPSplit Configuration::interleave = RooFit::BulkPartition. Definition at line 8 of file RooAbsTestStatistic.h. nCPU. int Configuration::nCPU = 1. Definition at line 7 of file RooAbsTestStatistic.h. rangeName. std::string Configuration::rangeName. Stores the configuration parameters for RooAbsTestStatistic. ; Definition at line 5 of file RooAbsTestStatistic.h. splitCutRange. bool Configuration::splitCutRange = false. Definition at line 10 of file RooAbsTestStatistic.h. takeGlobalObservablesFromData. bool Configuration::takeGlobalObservablesFromData = false. Definition at line 14 of file RooAbsTestStatistic.h. verbose. bool Configuration::verbose = true. Definition at line 9 of file RooAbsTestStatistic.h. Collaboration diagram for Configuration:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.; [legend]; The documentation for this struct was generated from the following file:; roofit/roofitcore/inc/RooAbsTestStatistic.h. Configuration. ROOT v6-32 - Reference Guide Generated on Fri Nov 1 2024 15:10:10 (GVA Time) using Doxygen 1.9.8 ; . ",MatchSource.WIKI,doc/v632/structConfiguration.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/structConfiguration.html
https://root.cern/doc/v632/structROOT_1_1Internal_1_1TSchemaType.html:647,Deployability,patch,patches,647,". ROOT: ROOT::Internal::TSchemaType Struct Reference. ; ROOT ; . v6-32. Reference Guide ; . . Loading...; Searching...; No Matches. List of all members |; Public Member Functions |; Public Attributes |; List of all members ; ROOT::Internal::TSchemaType Struct Reference. . Definition at line 13 of file TSchemaType.h. Public Member Functions; TSchemaType ()=default; ; TSchemaType (const char *type, const char *dim); ; TSchemaType (const std::string &type, const std::string &dim); . Public Attributes; std::stringfDimensions; ; std::stringfType; . #include </home/sftnight/build/workspace/root-makedoc-v632/rootspi/rdoc/src/v6-32-00-patches/core/foundation/res/TSchemaType.h>; Constructor & Destructor Documentation. TSchemaType() [1/3]. ROOT::Internal::TSchemaType::TSchemaType ; (; ). default . TSchemaType() [2/3]. ROOT::Internal::TSchemaType::TSchemaType ; (; const char *; type, . const char *; dim. ). inline . Definition at line 15 of file TSchemaType.h. TSchemaType() [3/3]. ROOT::Internal::TSchemaType::TSchemaType ; (; const std::string &; type, . const std::string &; dim. ). inline . Definition at line 16 of file TSchemaType.h. Member Data Documentation. fDimensions. std::string ROOT::Internal::TSchemaType::fDimensions. Definition at line 18 of file TSchemaType.h. fType. std::string ROOT::Internal::TSchemaType::fType. Definition at line 17 of file TSchemaType.h. Collaboration diagram for ROOT::Internal::TSchemaType:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.; [legend]; The documentation for this struct was generated from the following file:; core/foundation/res/TSchemaType.h. ROOTInternalTSchemaType. ROOT v6-32 - Reference Guide Generated on Fri Nov 1 2024 15:13:54 (GVA Time) using Doxygen 1.9.8 ; . ",MatchSource.WIKI,doc/v632/structROOT_1_1Internal_1_1TSchemaType.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/structROOT_1_1Internal_1_1TSchemaType.html
https://root.cern/doc/v632/structROOT_1_1RCompressionSetting.html:598,Availability,avail,available,598,". ROOT: ROOT::RCompressionSetting Struct Reference. ; ROOT ; . v6-32. Reference Guide ; . . Loading...; Searching...; No Matches. List of all members |; Classes |; Static Public Member Functions |; List of all members ; ROOT::RCompressionSetting Struct Reference. ; The global settings depend on a global variable named R__ZipMode which can be modified by a global function named R__SetZipMode. ; Both are defined in Bits.h. The default is to use the global setting and the default of the global setting is to use the ZLIB compression algorithm.; The LZMA algorithm (from the XZ package) is also available. The LZMA compression usually results in greater compression factors, but takes more CPU time and memory when compressing. LZMA memory usage is particularly high for compression levels 8 and 9.; Finally, the LZ4 package results in worse compression ratios than ZLIB but achieves much faster decompression rates. The current algorithms support level 1 to 9. The higher the level the greater the compression and more CPU time and memory resources used during compression. Level 0 means no compression.; Recommendation for the compression algorithm's levels:; ZLIB is recommended to be used with compression level 1 [101]; LZMA is recommended to be used with compression level 7-8 (higher is better, since in the case of LZMA we don't care about compression/decompression speed) [207 - 208]; LZ4 is recommended to be used with compression level 4 [404]; ZSTD is recommended to be used with compression level 5 [505] . Definition at line 45 of file Compression.h. Classes; struct EAlgorithm; ; struct EDefaults; ; struct ELevel; . Static Public Member Functions; static std::stringAlgorithmToString (EAlgorithm::EValues algorithm); . #include <Compression.h>; Member Function Documentation. AlgorithmToString(). static std::string ROOT::RCompressionSetting::AlgorithmToString ; (; EAlgorithm::EValues; algorithm). static . The documentation for this struct was generated from the follow",MatchSource.WIKI,doc/v632/structROOT_1_1RCompressionSetting.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/structROOT_1_1RCompressionSetting.html
https://root.cern/doc/v632/structROOT_1_1RCompressionSetting.html:288,Integrability,depend,depend,288,". ROOT: ROOT::RCompressionSetting Struct Reference. ; ROOT ; . v6-32. Reference Guide ; . . Loading...; Searching...; No Matches. List of all members |; Classes |; Static Public Member Functions |; List of all members ; ROOT::RCompressionSetting Struct Reference. ; The global settings depend on a global variable named R__ZipMode which can be modified by a global function named R__SetZipMode. ; Both are defined in Bits.h. The default is to use the global setting and the default of the global setting is to use the ZLIB compression algorithm.; The LZMA algorithm (from the XZ package) is also available. The LZMA compression usually results in greater compression factors, but takes more CPU time and memory when compressing. LZMA memory usage is particularly high for compression levels 8 and 9.; Finally, the LZ4 package results in worse compression ratios than ZLIB but achieves much faster decompression rates. The current algorithms support level 1 to 9. The higher the level the greater the compression and more CPU time and memory resources used during compression. Level 0 means no compression.; Recommendation for the compression algorithm's levels:; ZLIB is recommended to be used with compression level 1 [101]; LZMA is recommended to be used with compression level 7-8 (higher is better, since in the case of LZMA we don't care about compression/decompression speed) [207 - 208]; LZ4 is recommended to be used with compression level 4 [404]; ZSTD is recommended to be used with compression level 5 [505] . Definition at line 45 of file Compression.h. Classes; struct EAlgorithm; ; struct EDefaults; ; struct ELevel; . Static Public Member Functions; static std::stringAlgorithmToString (EAlgorithm::EValues algorithm); . #include <Compression.h>; Member Function Documentation. AlgorithmToString(). static std::string ROOT::RCompressionSetting::AlgorithmToString ; (; EAlgorithm::EValues; algorithm). static . The documentation for this struct was generated from the follow",MatchSource.WIKI,doc/v632/structROOT_1_1RCompressionSetting.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/structROOT_1_1RCompressionSetting.html
https://root.cern/doc/v632/structROOT_1_1RCompressionSetting.html:307,Modifiability,variab,variable,307,". ROOT: ROOT::RCompressionSetting Struct Reference. ; ROOT ; . v6-32. Reference Guide ; . . Loading...; Searching...; No Matches. List of all members |; Classes |; Static Public Member Functions |; List of all members ; ROOT::RCompressionSetting Struct Reference. ; The global settings depend on a global variable named R__ZipMode which can be modified by a global function named R__SetZipMode. ; Both are defined in Bits.h. The default is to use the global setting and the default of the global setting is to use the ZLIB compression algorithm.; The LZMA algorithm (from the XZ package) is also available. The LZMA compression usually results in greater compression factors, but takes more CPU time and memory when compressing. LZMA memory usage is particularly high for compression levels 8 and 9.; Finally, the LZ4 package results in worse compression ratios than ZLIB but achieves much faster decompression rates. The current algorithms support level 1 to 9. The higher the level the greater the compression and more CPU time and memory resources used during compression. Level 0 means no compression.; Recommendation for the compression algorithm's levels:; ZLIB is recommended to be used with compression level 1 [101]; LZMA is recommended to be used with compression level 7-8 (higher is better, since in the case of LZMA we don't care about compression/decompression speed) [207 - 208]; LZ4 is recommended to be used with compression level 4 [404]; ZSTD is recommended to be used with compression level 5 [505] . Definition at line 45 of file Compression.h. Classes; struct EAlgorithm; ; struct EDefaults; ; struct ELevel; . Static Public Member Functions; static std::stringAlgorithmToString (EAlgorithm::EValues algorithm); . #include <Compression.h>; Member Function Documentation. AlgorithmToString(). static std::string ROOT::RCompressionSetting::AlgorithmToString ; (; EAlgorithm::EValues; algorithm). static . The documentation for this struct was generated from the follow",MatchSource.WIKI,doc/v632/structROOT_1_1RCompressionSetting.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/structROOT_1_1RCompressionSetting.html
https://root.cern/doc/v632/structROOT_1_1RCompressionSetting_1_1EAlgorithm.html:880,Modifiability,inherit,inherited,880,". ROOT: ROOT::RCompressionSetting::EAlgorithm Struct Reference. ; ROOT ; . v6-32. Reference Guide ; . . Loading...; Searching...; No Matches. List of all members |; Public Types |; List of all members ; ROOT::RCompressionSetting::EAlgorithm Struct Reference. . Definition at line 83 of file Compression.h. Public Types; enum EValues { ; kInherit = -1; , kUseGlobal = 0; , kZLIB; , kLZMA; , ; kOldCompressionAlgo; , kLZ4; , kZSTD; , kUndefined. }; Note: this is only temporarily a struct and will become a enum class hence the name. More...; . #include <Compression.h>; Member Enumeration Documentation. EValues. enum ROOT::RCompressionSetting::EAlgorithm::EValues. Note: this is only temporarily a struct and will become a enum class hence the name. ; convention used. . EnumeratorkInheritSome objects use this value to denote that the compression algorithm should be inherited from the parent object (e.g., TBranch should get the algorithm from the TTree) . kUseGlobalUse the global compression algorithm. . kZLIBUse ZLIB compression. . kLZMAUse LZMA compression. . kOldCompressionAlgoUse the old compression algorithm. . kLZ4Use LZ4 compression. . kZSTDUse ZSTD compression. . kUndefinedUndefined compression algorithm (must be kept the last of the list in case a new algorithm is added). . Definition at line 85 of file Compression.h. The documentation for this struct was generated from the following file:; core/zip/inc/Compression.h. ROOTRCompressionSettingEAlgorithm. ROOT v6-32 - Reference Guide Generated on Fri Nov 1 2024 15:13:36 (GVA Time) using Doxygen 1.9.8 ; . ",MatchSource.WIKI,doc/v632/structROOT_1_1RCompressionSetting_1_1EAlgorithm.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/structROOT_1_1RCompressionSetting_1_1EAlgorithm.html
https://root.cern/doc/v632/structROOT_1_1TNumSlots.html:281,Integrability,interface,interfaces,281,". ROOT: ROOT::TNumSlots Class Reference. ; ROOT ; . v6-32. Reference Guide ; . . Loading...; Searching...; No Matches. List of all members |; Public Attributes |; Friends |; List of all members ; ROOT::TNumSlots Class Reference. ; Defines the number of threads in some of ROOT's interfaces. ; Definition at line 42 of file TThreadedObject.hxx. Public Attributes; unsigned intfVal; . Friends; booloperator!= (TNumSlots lhs, TNumSlots rhs); ; booloperator== (TNumSlots lhs, TNumSlots rhs); . #include <ROOT/TThreadedObject.hxx>; Friends And Related Symbol Documentation. operator!=. bool operator!= ; (; TNumSlots; lhs, . TNumSlots; rhs. ). friend . Definition at line 45 of file TThreadedObject.hxx. operator==. bool operator== ; (; TNumSlots; lhs, . TNumSlots; rhs. ). friend . Definition at line 44 of file TThreadedObject.hxx. Member Data Documentation. fVal. unsigned int ROOT::TNumSlots::fVal. Definition at line 43 of file TThreadedObject.hxx. Collaboration diagram for ROOT::TNumSlots:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.; [legend]; The documentation for this class was generated from the following file:; core/thread/inc/ROOT/TThreadedObject.hxx. ROOTTNumSlots. ROOT v6-32 - Reference Guide Generated on Fri Nov 1 2024 15:13:37 (GVA Time) using Doxygen 1.9.8 ; . ",MatchSource.WIKI,doc/v632/structROOT_1_1TNumSlots.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/structROOT_1_1TNumSlots.html
https://root.cern/doc/v632/TClassTable_8cxx_source.html:35044,Availability,error,error,35044,"nition RtypesCore.h:46; Short_tshort Short_tDefinition RtypesCore.h:39; kFALSEconstexpr Bool_t kFALSEDefinition RtypesCore.h:101; kNPOSconstexpr Ssiz_t kNPOSDefinition RtypesCore.h:124; kTRUEconstexpr Bool_t kTRUEDefinition RtypesCore.h:100; Option_tconst char Option_tDefinition RtypesCore.h:66; DictFuncPtr_tTClass *(* DictFuncPtr_t)()Definition Rtypes.h:80; ClassImp#define ClassImp(name)Definition Rtypes.h:377; TClassEdit.h; GetClassTableMutexstatic std::mutex & GetClassTableMutex()Definition TClassTable.cxx:60; gClassTableTClassTable * gClassTableDefinition TClassTable.cxx:47; ClassCompstatic int ClassComp(const void *a, const void *b)Definition TClassTable.cxx:794; TClassTable.h; gClassTableR__EXTERN TClassTable * gClassTableDefinition TClassTable.h:97; TClass.h; TError.h; Infovoid Info(const char *location, const char *msgfmt,...)Use this function for informational messages.Definition TError.cxx:218; Errorvoid Error(const char *location, const char *msgfmt,...)Use this function in case an error occurred.Definition TError.cxx:185; pwinID h TVirtualViewer3D TVirtualGLPainter pDefinition TGWin32VirtualGLProxy.cxx:51; optionOption_t Option_t optionDefinition TGWin32VirtualXProxy.cxx:44; dataOption_t Option_t TPoint TPoint const char GetTextMagnitude GetFillStyle GetLineColor GetLineWidth GetMarkerStyle GetTextAlign GetTextColor GetTextSize void dataDefinition TGWin32VirtualXProxy.cxx:104; rOption_t Option_t TPoint TPoint const char GetTextMagnitude GetFillStyle GetLineColor GetLineWidth GetMarkerStyle GetTextAlign GetTextColor GetTextSize void char Point_t Rectangle_t WindowAttributes_t Float_t rDefinition TGWin32VirtualXProxy.cxx:168; indexOption_t Option_t TPoint TPoint const char GetTextMagnitude GetFillStyle GetLineColor GetLineWidth GetMarkerStyle GetTextAlign GetTextColor GetTextSize void char Point_t Rectangle_t WindowAttributes_t indexDefinition TGWin32VirtualXProxy.cxx:168; idOption_t Option_t TPoint TPoint const char GetTextMagnitude GetFillStyle GetLineCol",MatchSource.WIKI,doc/v632/TClassTable_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/TClassTable_8cxx_source.html
https://root.cern/doc/v632/TClassTable_8cxx_source.html:47677,Availability,error,error,47677,"d an object in this list using its name.Definition TList.cxx:576; TList::Addvoid Add(TObject *obj) overrideDefinition TList.h:83; TMapTMap implements an associative array of (key,value) pairs using a THashTable for efficient retrieval ...Definition TMap.h:40; TNamedThe TNamed class is the base class for all named ROOT classes.Definition TNamed.h:29; TNamed::GetNameconst char * GetName() const overrideReturns name of object.Definition TNamed.h:47; TObjStringCollectable string class.Definition TObjString.h:28; TObjString::StringTString & String()Definition TObjString.h:48; TObjectMother of all ROOT objects.Definition TObject.h:41; TObject::Warningvirtual void Warning(const char *method, const char *msgfmt,...) constIssue warning message.Definition TObject.cxx:973; TObject::FindObjectvirtual TObject * FindObject(const char *name) constMust be redefined in derived classes.Definition TObject.cxx:403; TObject::Fatalvirtual void Fatal(const char *method, const char *msgfmt,...) constIssue fatal error message.Definition TObject.cxx:1015; TObject::Infovirtual void Info(const char *method, const char *msgfmt,...) constIssue info message.Definition TObject.cxx:961; TPairClass used by TMap to store (key,value) pairs.Definition TMap.h:102; TProtoClassPersistent version of a TClass.Definition TProtoClass.h:38; TROOT::Initializedstatic Bool_t Initialized()Return kTRUE if the TROOT object has been initialized.Definition TROOT.cxx:2906; TRegexpRegular expression class.Definition TRegexp.h:31; TStringBasic string class.Definition TString.h:139; TString::Dataconst char * Data() constDefinition TString.h:376; TString::RemoveTString & Remove(Ssiz_t pos)Definition TString.h:685; TString::IndexSsiz_t Index(const char *pat, Ssiz_t i=0, ECaseCompare cmp=kExact) constDefinition TString.h:651; bool; int; unsigned int; lineTLine * lineDefinition entrylistblock_figure1.C:235; nconst Int_t nDefinition legend1.C:16; ROOT::Internal::gROOTLocalR__EXTERN TROOT * gROOTLocalDefinition TROOT.h:379; ROOT",MatchSource.WIKI,doc/v632/TClassTable_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/TClassTable_8cxx_source.html
https://root.cern/doc/v632/TClassTable_8cxx_source.html:14173,Deployability,update,update,14173," 406 if (!gClassTable); 407 new TClassTable;; 408 ; 409 std::unique_lock<std::mutex> lock(GetClassTableMutex());; 410 ; 411 // check if already in table, if so return; 412 TClassRec *r = FindElement(cname, kTRUE);; 413 if (r->fName && r->fInfo) {; 414 if ( strcmp(r->fInfo->name(), typeid(ROOT::TForNamespace).name()) ==0; 415 && strcmp(info.name(), typeid(ROOT::TForNamespace).name()) ==0 ) {; 416 // We have a namespace being reloaded.; 417 // This okay we just keep the old one.; 418 return;; 419 }; 420 if (!TClassEdit::IsStdClass(cname)) {; 421 lock.unlock(); // Warning might recursively call TClassTable during gROOT init; 422 // Warn only for class that are not STD classes; 423 ::Warning(""TClassTable::Add"", ""class %s already in TClassTable"", cname);; 424 }; 425 return;; 426 } else if (ROOT::Internal::gROOTLocal && gCling) {; 427 TClass *oldcl = (TClass*)gROOT->GetListOfClasses()->FindObject(cname);; 428 if (oldcl) { // && oldcl->GetClassInfo()) {; 429 // As a work-around to ROOT-6012, we need to register the class even if; 430 // it is not a template instance, because a forward declaration in the header; 431 // files loaded by the current dictionary wil also de-activate the update; 432 // class info mechanism!; 433 ; 434 // The TClass exist and already has a class info, so it must; 435 // correspond to a class template instantiation which the interpreter; 436 // was able to make with the library containing the TClass Init.; 437 // Because it is already known to the interpreter, the update class info; 438 // will not be triggered, we need to force it.; 439 gCling->RegisterTClassUpdate(oldcl, dict);; 440 }; 441 }; 442 ; 443 if (!r->fName); 444 r->fName = StrDup(cname);; 445 r->fId = id;; 446 r->fBits = pragmabits;; 447 r->fDict = dict;; 448 r->fInfo = &info;; 449 ; 450 fgIdMap->Add(info.name(),r);; 451 ; 452 fgSorted = kFALSE;; 453}; 454 ; 455////////////////////////////////////////////////////////////////////////////////; 456/// Add a class to the class table (this is",MatchSource.WIKI,doc/v632/TClassTable_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/TClassTable_8cxx_source.html
https://root.cern/doc/v632/TClassTable_8cxx_source.html:14487,Deployability,update,update,14487,"!TClassEdit::IsStdClass(cname)) {; 421 lock.unlock(); // Warning might recursively call TClassTable during gROOT init; 422 // Warn only for class that are not STD classes; 423 ::Warning(""TClassTable::Add"", ""class %s already in TClassTable"", cname);; 424 }; 425 return;; 426 } else if (ROOT::Internal::gROOTLocal && gCling) {; 427 TClass *oldcl = (TClass*)gROOT->GetListOfClasses()->FindObject(cname);; 428 if (oldcl) { // && oldcl->GetClassInfo()) {; 429 // As a work-around to ROOT-6012, we need to register the class even if; 430 // it is not a template instance, because a forward declaration in the header; 431 // files loaded by the current dictionary wil also de-activate the update; 432 // class info mechanism!; 433 ; 434 // The TClass exist and already has a class info, so it must; 435 // correspond to a class template instantiation which the interpreter; 436 // was able to make with the library containing the TClass Init.; 437 // Because it is already known to the interpreter, the update class info; 438 // will not be triggered, we need to force it.; 439 gCling->RegisterTClassUpdate(oldcl, dict);; 440 }; 441 }; 442 ; 443 if (!r->fName); 444 r->fName = StrDup(cname);; 445 r->fId = id;; 446 r->fBits = pragmabits;; 447 r->fDict = dict;; 448 r->fInfo = &info;; 449 ; 450 fgIdMap->Add(info.name(),r);; 451 ; 452 fgSorted = kFALSE;; 453}; 454 ; 455////////////////////////////////////////////////////////////////////////////////; 456/// Add a class to the class table (this is a static function).; 457 ; 458void TClassTable::Add(TProtoClass *proto); 459{; 460 // This will be set at the lastest during TROOT construction, so before; 461 // any threading could happen.; 462 if (!gClassTable); 463 new TClassTable;; 464 ; 465 std::unique_lock<std::mutex> lock(GetClassTableMutex());; 466 ; 467 // By definition the name in the TProtoClass is (must be) the normalized; 468 // name, so there is no need to tweak it.; 469 const char *cname = proto->GetName();; 470 ; 471 // check if already ",MatchSource.WIKI,doc/v632/TClassTable_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/TClassTable_8cxx_source.html
https://root.cern/doc/v632/TClassTable_8cxx_source.html:16333,Deployability,update,update,16333,"460 // This will be set at the lastest during TROOT construction, so before; 461 // any threading could happen.; 462 if (!gClassTable); 463 new TClassTable;; 464 ; 465 std::unique_lock<std::mutex> lock(GetClassTableMutex());; 466 ; 467 // By definition the name in the TProtoClass is (must be) the normalized; 468 // name, so there is no need to tweak it.; 469 const char *cname = proto->GetName();; 470 ; 471 // check if already in table, if so return; 472 TClassRec *r = FindElement(cname, kTRUE);; 473 if (r->fName) {; 474 if (r->fProto) delete r->fProto;; 475 r->fProto = proto;; 476 TClass *oldcl = (TClass*)gROOT->GetListOfClasses()->FindObject(cname);; 477 ; 478 lock.unlock(); // FillTClass might recursively call TClassTable during gROOT init; 479 if (oldcl && oldcl->GetState() == TClass::kHasTClassInit); 480 proto->FillTClass(oldcl);; 481 return;; 482 } else if (ROOT::Internal::gROOTLocal && gCling) {; 483 TClass *oldcl = (TClass*)gROOT->GetListOfClasses()->FindObject(cname);; 484 if (oldcl) { // && oldcl->GetClassInfo()) {; 485 // As a work-around to ROOT-6012, we need to register the class even if; 486 // it is not a template instance, because a forward declaration in the header; 487 // files loaded by the current dictionary wil also de-activate the update; 488 // class info mechanism!; 489 ; 490 lock.unlock(); // Warning might recursively call TClassTable during gROOT init; 491 ::Warning(""TClassTable::Add(TProtoClass*)"",""Called for existing class without a prior call add the dictionary function."");; 492 }; 493 }; 494 ; 495 r->fName = StrDup(cname);; 496 r->fId = 0;; 497 r->fBits = 0;; 498 r->fDict = nullptr;; 499 r->fInfo = nullptr;; 500 r->fProto= proto;; 501 ; 502 fgSorted = kFALSE;; 503}; 504 ; 505////////////////////////////////////////////////////////////////////////////////; 506 ; 507ROOT::TClassAlt* TClassTable::AddAlternate(const char *normName, const char *alternate); 508{; 509 // This will be set at the lastest during TROOT construction, so before; 510 ",MatchSource.WIKI,doc/v632/TClassTable_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/TClassTable_8cxx_source.html
https://root.cern/doc/v632/TClassTable_8cxx_source.html:18263,Deployability,release,release,18263," = fgAlternate[slot]; a; a = a->fNext.get()) {; 519 if (strcmp(alternate,a->fName)==0) {; 520 if (strcmp(normName,a->fNormName) != 0) {; 521 fprintf(stderr,""Error in TClassTable::AddAlternate: ""; 522 ""Second registration of %s with a different normalized name (old: '%s', new: '%s')\n"",; 523 alternate, a->fNormName, normName);; 524 }; 525 return nullptr;; 526 }; 527 }; 528 ; 529 fgAlternate[slot] = new TClassAlt(alternate,normName,fgAlternate[slot]);; 530 return fgAlternate[slot];; 531}; 532 ; 533////////////////////////////////////////////////////////////////////////////////; 534///; 535void TClassTable::RemoveAlternate(ROOT::TClassAlt *alt); 536{; 537 if (!alt || !gClassTable); 538 return;; 539 ; 540 std::lock_guard<std::mutex> lock(GetClassTableMutex());; 541 ; 542 UInt_t slot = ROOT::ClassTableHash(alt->fName, fgSize);; 543 ; 544 if (!fgAlternate[slot]); 545 return;; 546 ; 547 if (fgAlternate[slot] == alt); 548 fgAlternate[slot] = alt->fNext.release();; 549 else {; 550 for (TClassAlt *a = fgAlternate[slot]; a; a = a->fNext.get()) {; 551 if (a->fNext.get() == alt) {; 552 a->fNext.swap( alt->fNext );; 553 assert( alt == alt->fNext.get());; 554 alt->fNext.release();; 555 }; 556 }; 557 }; 558 delete alt;; 559}; 560 ; 561////////////////////////////////////////////////////////////////////////////////; 562 ; 563Bool_t TClassTable::Check(const char *cname, std::string &normname); 564{; 565 if (!CheckClassTableInit()); 566 return kFALSE;; 567 ; 568 std::lock_guard<std::mutex> lock(GetClassTableMutex());; 569 ; 570 UInt_t slot = ROOT::ClassTableHash(cname, fgSize);; 571 ; 572 // Check if 'cname' is a known normalized name.; 573 for (TClassRec *r = fgTable[slot]; r; r = r->fNext); 574 if (strcmp(cname,r->fName)==0) return kTRUE;; 575 ; 576 // See if 'cname' is register in the list of alternate names; 577 for (const TClassAlt *a = fgAlternate[slot]; a; a = a->fNext.get()) {; 578 if (strcmp(cname,a->fName)==0) {; 579 normname = a->fNormName;; 580 return kTRUE;; 581 }; 582 }; ",MatchSource.WIKI,doc/v632/TClassTable_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/TClassTable_8cxx_source.html
https://root.cern/doc/v632/TClassTable_8cxx_source.html:18478,Deployability,release,release,18478,"ssAlt(alternate,normName,fgAlternate[slot]);; 530 return fgAlternate[slot];; 531}; 532 ; 533////////////////////////////////////////////////////////////////////////////////; 534///; 535void TClassTable::RemoveAlternate(ROOT::TClassAlt *alt); 536{; 537 if (!alt || !gClassTable); 538 return;; 539 ; 540 std::lock_guard<std::mutex> lock(GetClassTableMutex());; 541 ; 542 UInt_t slot = ROOT::ClassTableHash(alt->fName, fgSize);; 543 ; 544 if (!fgAlternate[slot]); 545 return;; 546 ; 547 if (fgAlternate[slot] == alt); 548 fgAlternate[slot] = alt->fNext.release();; 549 else {; 550 for (TClassAlt *a = fgAlternate[slot]; a; a = a->fNext.get()) {; 551 if (a->fNext.get() == alt) {; 552 a->fNext.swap( alt->fNext );; 553 assert( alt == alt->fNext.get());; 554 alt->fNext.release();; 555 }; 556 }; 557 }; 558 delete alt;; 559}; 560 ; 561////////////////////////////////////////////////////////////////////////////////; 562 ; 563Bool_t TClassTable::Check(const char *cname, std::string &normname); 564{; 565 if (!CheckClassTableInit()); 566 return kFALSE;; 567 ; 568 std::lock_guard<std::mutex> lock(GetClassTableMutex());; 569 ; 570 UInt_t slot = ROOT::ClassTableHash(cname, fgSize);; 571 ; 572 // Check if 'cname' is a known normalized name.; 573 for (TClassRec *r = fgTable[slot]; r; r = r->fNext); 574 if (strcmp(cname,r->fName)==0) return kTRUE;; 575 ; 576 // See if 'cname' is register in the list of alternate names; 577 for (const TClassAlt *a = fgAlternate[slot]; a; a = a->fNext.get()) {; 578 if (strcmp(cname,a->fName)==0) {; 579 normname = a->fNormName;; 580 return kTRUE;; 581 }; 582 }; 583 ; 584 return kFALSE;; 585}; 586 ; 587////////////////////////////////////////////////////////////////////////////////; 588/// Remove a class from the class table. This happens when a shared library; 589/// is unloaded (i.e. the dtor's of the global init objects are called).; 590 ; 591void TClassTable::Remove(const char *cname); 592{; 593 if (!CheckClassTableInit()); 594 return;; 595 ; 596 std::lock_gu",MatchSource.WIKI,doc/v632/TClassTable_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/TClassTable_8cxx_source.html
https://root.cern/doc/v632/TClassTable_8cxx_source.html:30429,Deployability,update,update,30429,"911 }; 912}; 913 ; 914////////////////////////////////////////////////////////////////////////////////; 915/// Global function called by GenerateInitInstance.; 916/// (see the ClassImp macro).; 917 ; 918ROOT::TClassAlt* ROOT::AddClassAlternate(const char *normName, const char *alternate); 919{; 920 if (!TROOT::Initialized() && !gClassTable) {; 921 GetDelayedAddClassAlternate().emplace_back(normName, alternate);; 922 // If a library is loaded before gROOT is initialized we can assume; 923 // it is hard linked along side libCore (or is libCore) thus can't; 924 // really be unloaded.; 925 return nullptr;; 926 } else {; 927 return TClassTable::AddAlternate(normName, alternate);; 928 }; 929}; 930 ; 931void ROOT::RemoveClassAlternate(TClassAlt *alt); 932{; 933 // This routine is meant to be called (indirectly) by dlclose so we; 934 // we are guaranteed that the library initialization has completed.; 935 TClassTable::RemoveAlternate(alt);; 936}; 937 ; 938////////////////////////////////////////////////////////////////////////////////; 939/// Global function to update the version number.; 940/// This is called via the RootClassVersion macro.; 941///; 942/// if cl!=0 and cname==-1, set the new class version if and only is; 943/// greater than the existing one and greater or equal to 2;; 944/// and also ignore the request if fVersionUsed is true.; 945///; 946/// Note on class version number:; 947/// - If no class has been specified, TClass::GetVersion will return -1; 948/// - The Class Version 0 request the whole object to be transient; 949/// - The Class Version 1, unless specify via ClassDef indicates that the; 950/// I/O should use the TClass checksum to distinguish the layout of the class; 951void ROOT::ResetClassVersion(TClass *cl, const char *cname, Short_t newid); 952{; 953 if (cname && cname != (void*)-1 && TClassTable::CheckClassTableInit()) {; 954 TClassTable::NormalizeThenLock guard(cname);; 955 TClassRec *r = TClassTable::FindElement(guard.GetNormalizedName().c_str",MatchSource.WIKI,doc/v632/TClassTable_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/TClassTable_8cxx_source.html
https://root.cern/doc/v632/TClassTable_8cxx_source.html:50124,Deployability,update,update,50124,"eclare tb...Definition EExecutionPolicy.hxx:4; ROOT::GetDelayedAddClassAlternatestd::vector< std::pair< const char *, const char * > > & GetDelayedAddClassAlternate()Definition TClassTable.cxx:254; ROOT::AddClassAlternateROOT::TClassAlt * AddClassAlternate(const char *normName, const char *alternate)Global function called by GenerateInitInstance.Definition TClassTable.cxx:918; ROOT::GetDelayedAddClassstd::vector< std::unique_ptr< TClassRec > > & GetDelayedAddClass()Definition TClassTable.cxx:248; ROOT::RemoveClassvoid RemoveClass(const char *cname, TClass *cl)Global function called by the dtor of a class's init class (see the ClassImp macro).Definition TClassTable.cxx:985; ROOT::AddClassvoid AddClass(const char *cname, Version_t id, const std::type_info &info, DictFuncPtr_t dict, Int_t pragmabits)Global function called by the ctor of a class's init class (see the ClassImp macro).Definition TClassTable.cxx:896; ROOT::RegisterClassTemplateTNamed * RegisterClassTemplate(const char *name, const char *file, Int_t line)Global function to register the implementation file and line of a class template (i....Definition TClassTable.cxx:1005; ROOT::ClassTableHashstatic UInt_t ClassTableHash(const char *name, UInt_t size)Definition TClassTable.cxx:237; ROOT::ResetClassVersionvoid ResetClassVersion(TClass *, const char *, Short_t)Global function to update the version number.Definition TClassTable.cxx:951; ROOT::GetROOTTROOT * GetROOT()Definition TROOT.cxx:472; ROOT::RemoveClassAlternatevoid RemoveClassAlternate(ROOT::TClassAlt *)Definition TClassTable.cxx:931; TClassEdit::IsStdClassbool IsStdClass(const char *type)return true if the class belongs to the std namespaceDefinition TClassEdit.cxx:1418; TClassEdit::GetNormalizedNamevoid GetNormalizedName(std::string &norm_name, std::string_view name)Return the normalized name.Definition TClassEdit.cxx:854. corecontsrcTClassTable.cxx. ROOT v6-32 - Reference Guide Generated on Fri Nov 1 2024 15:06:57 (GVA Time) using Doxygen 1.9.8 ; . ",MatchSource.WIKI,doc/v632/TClassTable_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/TClassTable_8cxx_source.html
https://root.cern/doc/v632/TClassTable_8cxx_source.html:46889,Energy Efficiency,efficient,efficient,46889,"tDefinition TClass.h:127; TClass::GetClassstatic TClass * GetClass(const char *name, Bool_t load=kTRUE, Bool_t silent=kFALSE)Static method returning pointer to TClass of the specified class name.Definition TClass.cxx:2968; TCollection::UseRWLockvirtual bool UseRWLock(Bool_t enable=true)Set this collection to use a RW lock upon access, making it thread safe.Definition TCollection.cxx:761; TCollection::SetOwnervirtual void SetOwner(Bool_t enable=kTRUE)Set whether this collection is the owner (enable==true) of its content.Definition TCollection.cxx:746; TInterpreter::RegisterTClassUpdatevirtual void RegisterTClassUpdate(TClass *oldcl, DictFuncPtr_t dict)=0; TIterDefinition TCollection.h:235; TListA doubly linked list.Definition TList.h:38; TList::FindObjectTObject * FindObject(const char *name) const overrideFind an object in this list using its name.Definition TList.cxx:576; TList::Addvoid Add(TObject *obj) overrideDefinition TList.h:83; TMapTMap implements an associative array of (key,value) pairs using a THashTable for efficient retrieval ...Definition TMap.h:40; TNamedThe TNamed class is the base class for all named ROOT classes.Definition TNamed.h:29; TNamed::GetNameconst char * GetName() const overrideReturns name of object.Definition TNamed.h:47; TObjStringCollectable string class.Definition TObjString.h:28; TObjString::StringTString & String()Definition TObjString.h:48; TObjectMother of all ROOT objects.Definition TObject.h:41; TObject::Warningvirtual void Warning(const char *method, const char *msgfmt,...) constIssue warning message.Definition TObject.cxx:973; TObject::FindObjectvirtual TObject * FindObject(const char *name) constMust be redefined in derived classes.Definition TObject.cxx:403; TObject::Fatalvirtual void Fatal(const char *method, const char *msgfmt,...) constIssue fatal error message.Definition TObject.cxx:1015; TObject::Infovirtual void Info(const char *method, const char *msgfmt,...) constIssue info message.Definition TObject.cxx:961; TPairCl",MatchSource.WIKI,doc/v632/TClassTable_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/TClassTable_8cxx_source.html
https://root.cern/doc/v632/TClassTable_8cxx_source.html:4323,Integrability,wrap,wrapper,4323,"/////////////////////////////////////////////////////////////////////////; 104 ; 105namespace ROOT {; 106 class TClassRec {; 107 public:; 108 TClassRec(TClassRec *next) :; 109 fName(nullptr), fId(0), fDict(nullptr), fInfo(nullptr), fProto(nullptr), fNext(next); 110 {}; 111 ; 112 ~TClassRec() {; 113 // TClassTable::fgIdMap->Remove(r->fInfo->name());; 114 delete [] fName;; 115 delete fProto;; 116 delete fNext;; 117 }; 118 ; 119 char *fName;; 120 Version_t fId;; 121 Int_t fBits;; 122 DictFuncPtr_t fDict;; 123 const std::type_info *fInfo;; 124 TProtoClass *fProto;; 125 TClassRec *fNext;; 126 };; 127 ; 128 class TClassAlt {; 129 public:; 130 TClassAlt(const char*alternate, const char *normName, TClassAlt *next) :; 131 fName(alternate), fNormName(normName), fNext(next); 132 {}; 133 ; 134 ~TClassAlt() {; 135 // Nothing more to delete.; 136 }; 137 ; 138 const char *fName; // Do not own; 139 const char *fNormName; // Do not own; 140 std::unique_ptr<TClassAlt> fNext;; 141 };; 142 ; 143#define R__USE_STD_MAP; 144 class TMapTypeToClassRec {; 145#if defined R__USE_STD_MAP; 146 // This wrapper class allow to avoid putting #include <map> in the; 147 // TROOT.h header file.; 148 public:; 149 typedef std::map<std::string, TClassRec*> IdMap_t;; 150 typedef IdMap_t::key_type key_type;; 151 typedef IdMap_t::const_iterator const_iterator;; 152 typedef IdMap_t::size_type size_type;; 153#ifdef R__WIN32; 154 // Window's std::map does NOT defined mapped_type; 155 typedef TClassRec* mapped_type;; 156#else; 157 typedef IdMap_t::mapped_type mapped_type;; 158#endif; 159 ; 160 private:; 161 IdMap_t fMap;; 162 ; 163 public:; 164 void Add(const key_type &key, mapped_type &obj) {; 165 fMap[key] = obj;; 166 }; 167 ; 168 mapped_type Find(const key_type &key) const {; 169 IdMap_t::const_iterator iter = fMap.find(key);; 170 mapped_type cl = nullptr;; 171 if (iter != fMap.end()) cl = iter->second;; 172 return cl;; 173 }; 174 ; 175 void Remove(const key_type &key) { fMap.erase(key); }; 176 ; 177 void Prin",MatchSource.WIKI,doc/v632/TClassTable_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/TClassTable_8cxx_source.html
https://root.cern/doc/v632/TClassTable_8cxx_source.html:20707,Integrability,rout,routine,20707,")); 594 return;; 595 ; 596 std::lock_guard<std::mutex> lock(GetClassTableMutex());; 597 ; 598 UInt_t slot = ROOT::ClassTableHash(cname, fgSize);; 599 ; 600 TClassRec *r;; 601 TClassRec *prev = nullptr;; 602 for (r = fgTable[slot]; r; r = r->fNext) {; 603 if (!strcmp(r->fName, cname)) {; 604 if (prev); 605 prev->fNext = r->fNext;; 606 else; 607 fgTable[slot] = r->fNext;; 608 fgIdMap->Remove(r->fInfo->name());; 609 r->fNext = nullptr; // Do not delete the others.; 610 delete r;; 611 fgTally--;; 612 fgSorted = kFALSE;; 613 break;; 614 }; 615 prev = r;; 616 }; 617}; 618 ; 619////////////////////////////////////////////////////////////////////////////////; 620/// Find a class by name in the class table (using hash of name). Returns; 621/// 0 if the class is not in the table. Unless arguments insert is true in; 622/// which case a new entry is created and returned.; 623/// `cname` must be the normalized name of the class.; 624 ; 625TClassRec *TClassTable::FindElement(const char *cname, Bool_t insert); 626{; 627 // Internal routine, no explicit lock needed here.; 628 ; 629 UInt_t slot = ROOT::ClassTableHash(cname, fgSize);; 630 ; 631 for (TClassRec *r = fgTable[slot]; r; r = r->fNext); 632 if (strcmp(cname, r->fName) == 0); 633 return r;; 634 ; 635 if (!insert); 636 return nullptr;; 637 ; 638 fgTable[slot] = new TClassRec(fgTable[slot]);; 639 ; 640 fgTally++;; 641 return fgTable[slot];; 642}; 643 ; 644////////////////////////////////////////////////////////////////////////////////; 645/// Returns the ID of a class.; 646 ; 647Version_t TClassTable::GetID(const char *cname); 648{; 649 NormalizeThenLock guard(cname);; 650 ; 651 TClassRec *r = FindElement(guard.GetNormalizedName().c_str(), kFALSE);; 652 if (r); 653 return r->fId;; 654 return -1;; 655}; 656 ; 657////////////////////////////////////////////////////////////////////////////////; 658/// Returns the pragma bits as specified in the LinkDef.h file.; 659 ; 660Int_t TClassTable::GetPragmaBits(const char *cname); 661{; 6",MatchSource.WIKI,doc/v632/TClassTable_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/TClassTable_8cxx_source.html
https://root.cern/doc/v632/TClassTable_8cxx_source.html:27725,Integrability,rout,routine,27725,"3 ; 834 Printf(""\nDefined classes"");; 835 Printf(""class version bits initialized"");; 836 Printf(""================================================================"");; 837 UInt_t last = fgTally;; 838 for (UInt_t i = 0; i < last; i++) {; 839 TClassRec *r = fgSortedTable[i];; 840 if (!r) break;; 841 n++;; 842 // Do not use TClass::GetClass to avoid any risk of autoloading.; 843 if (gROOT->GetListOfClasses()->FindObject(r->fName)) {; 844 ninit++;; 845 Printf(""%-35s %6d %7d Yes"", r->fName, r->fId, r->fBits);; 846 } else; 847 Printf(""%-35s %6d %7d No"", r->fName, r->fId, r->fBits);; 848 }; 849 Printf(""----------------------------------------------------------------"");; 850 Printf(""Total classes: %4d initialized: %4d"", n, ninit);; 851 Printf(""================================================================\n"");; 852}; 853 ; 854////////////////////////////////////////////////////////////////////////////////; 855/// Sort the class table by ascending class ID's.; 856 ; 857void TClassTable::SortTable(); 858{; 859 // Internal routine.; 860 ; 861 if (!fgSorted) {; 862 delete [] fgSortedTable;; 863 fgSortedTable = new TClassRec* [fgTally];; 864 ; 865 int j = 0;; 866 for (UInt_t i = 0; i < fgSize; i++); 867 for (TClassRec *r = fgTable[i]; r; r = r->fNext); 868 fgSortedTable[j++] = r;; 869 ; 870 ::qsort(fgSortedTable, fgTally, sizeof(TClassRec *), ::ClassComp);; 871 fgSorted = kTRUE;; 872 }; 873}; 874 ; 875////////////////////////////////////////////////////////////////////////////////; 876/// Deletes the class table (this static class function calls the dtor).; 877 ; 878void TClassTable::Terminate(); 879{; 880 if (gClassTable) {; 881 for (UInt_t i = 0; i < fgSize; i++); 882 delete fgTable[i]; // Will delete all the elements in the chain.; 883 ; 884 delete [] fgTable; fgTable = nullptr;; 885 delete [] fgSortedTable; fgSortedTable = nullptr;; 886 delete fgIdMap; fgIdMap = nullptr;; 887 fgSize = 0;; 888 SafeDelete(gClassTable);; 889 }; 890}; 891 ; 892///////////////////////////////////",MatchSource.WIKI,doc/v632/TClassTable_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/TClassTable_8cxx_source.html
https://root.cern/doc/v632/TClassTable_8cxx_source.html:30132,Integrability,rout,routine,30132,"r));; 903 r->fName = StrDup(cname);; 904 r->fId = id;; 905 r->fBits = pragmabits;; 906 r->fDict = dict;; 907 r->fInfo = &info;; 908 GetDelayedAddClass().emplace_back(std::move(r));; 909 } else {; 910 TClassTable::Add(cname, id, info, dict, pragmabits);; 911 }; 912}; 913 ; 914////////////////////////////////////////////////////////////////////////////////; 915/// Global function called by GenerateInitInstance.; 916/// (see the ClassImp macro).; 917 ; 918ROOT::TClassAlt* ROOT::AddClassAlternate(const char *normName, const char *alternate); 919{; 920 if (!TROOT::Initialized() && !gClassTable) {; 921 GetDelayedAddClassAlternate().emplace_back(normName, alternate);; 922 // If a library is loaded before gROOT is initialized we can assume; 923 // it is hard linked along side libCore (or is libCore) thus can't; 924 // really be unloaded.; 925 return nullptr;; 926 } else {; 927 return TClassTable::AddAlternate(normName, alternate);; 928 }; 929}; 930 ; 931void ROOT::RemoveClassAlternate(TClassAlt *alt); 932{; 933 // This routine is meant to be called (indirectly) by dlclose so we; 934 // we are guaranteed that the library initialization has completed.; 935 TClassTable::RemoveAlternate(alt);; 936}; 937 ; 938////////////////////////////////////////////////////////////////////////////////; 939/// Global function to update the version number.; 940/// This is called via the RootClassVersion macro.; 941///; 942/// if cl!=0 and cname==-1, set the new class version if and only is; 943/// greater than the existing one and greater or equal to 2;; 944/// and also ignore the request if fVersionUsed is true.; 945///; 946/// Note on class version number:; 947/// - If no class has been specified, TClass::GetVersion will return -1; 948/// - The Class Version 0 request the whole object to be transient; 949/// - The Class Version 1, unless specify via ClassDef indicates that the; 950/// I/O should use the TClass checksum to distinguish the layout of the class; 951void ROOT::ResetClassVersion(T",MatchSource.WIKI,doc/v632/TClassTable_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/TClassTable_8cxx_source.html
https://root.cern/doc/v632/TClassTable_8cxx_source.html:34918,Integrability,message,messages,34918,"trix; Bool_tbool Bool_tDefinition RtypesCore.h:63; Version_tshort Version_tDefinition RtypesCore.h:65; UInt_tunsigned int UInt_tDefinition RtypesCore.h:46; Short_tshort Short_tDefinition RtypesCore.h:39; kFALSEconstexpr Bool_t kFALSEDefinition RtypesCore.h:101; kNPOSconstexpr Ssiz_t kNPOSDefinition RtypesCore.h:124; kTRUEconstexpr Bool_t kTRUEDefinition RtypesCore.h:100; Option_tconst char Option_tDefinition RtypesCore.h:66; DictFuncPtr_tTClass *(* DictFuncPtr_t)()Definition Rtypes.h:80; ClassImp#define ClassImp(name)Definition Rtypes.h:377; TClassEdit.h; GetClassTableMutexstatic std::mutex & GetClassTableMutex()Definition TClassTable.cxx:60; gClassTableTClassTable * gClassTableDefinition TClassTable.cxx:47; ClassCompstatic int ClassComp(const void *a, const void *b)Definition TClassTable.cxx:794; TClassTable.h; gClassTableR__EXTERN TClassTable * gClassTableDefinition TClassTable.h:97; TClass.h; TError.h; Infovoid Info(const char *location, const char *msgfmt,...)Use this function for informational messages.Definition TError.cxx:218; Errorvoid Error(const char *location, const char *msgfmt,...)Use this function in case an error occurred.Definition TError.cxx:185; pwinID h TVirtualViewer3D TVirtualGLPainter pDefinition TGWin32VirtualGLProxy.cxx:51; optionOption_t Option_t optionDefinition TGWin32VirtualXProxy.cxx:44; dataOption_t Option_t TPoint TPoint const char GetTextMagnitude GetFillStyle GetLineColor GetLineWidth GetMarkerStyle GetTextAlign GetTextColor GetTextSize void dataDefinition TGWin32VirtualXProxy.cxx:104; rOption_t Option_t TPoint TPoint const char GetTextMagnitude GetFillStyle GetLineColor GetLineWidth GetMarkerStyle GetTextAlign GetTextColor GetTextSize void char Point_t Rectangle_t WindowAttributes_t Float_t rDefinition TGWin32VirtualXProxy.cxx:168; indexOption_t Option_t TPoint TPoint const char GetTextMagnitude GetFillStyle GetLineColor GetLineWidth GetMarkerStyle GetTextAlign GetTextColor GetTextSize void char Point_t Rectangle_t WindowAttributes_",MatchSource.WIKI,doc/v632/TClassTable_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/TClassTable_8cxx_source.html
https://root.cern/doc/v632/TClassTable_8cxx_source.html:47411,Integrability,message,message,47411,"x:746; TInterpreter::RegisterTClassUpdatevirtual void RegisterTClassUpdate(TClass *oldcl, DictFuncPtr_t dict)=0; TIterDefinition TCollection.h:235; TListA doubly linked list.Definition TList.h:38; TList::FindObjectTObject * FindObject(const char *name) const overrideFind an object in this list using its name.Definition TList.cxx:576; TList::Addvoid Add(TObject *obj) overrideDefinition TList.h:83; TMapTMap implements an associative array of (key,value) pairs using a THashTable for efficient retrieval ...Definition TMap.h:40; TNamedThe TNamed class is the base class for all named ROOT classes.Definition TNamed.h:29; TNamed::GetNameconst char * GetName() const overrideReturns name of object.Definition TNamed.h:47; TObjStringCollectable string class.Definition TObjString.h:28; TObjString::StringTString & String()Definition TObjString.h:48; TObjectMother of all ROOT objects.Definition TObject.h:41; TObject::Warningvirtual void Warning(const char *method, const char *msgfmt,...) constIssue warning message.Definition TObject.cxx:973; TObject::FindObjectvirtual TObject * FindObject(const char *name) constMust be redefined in derived classes.Definition TObject.cxx:403; TObject::Fatalvirtual void Fatal(const char *method, const char *msgfmt,...) constIssue fatal error message.Definition TObject.cxx:1015; TObject::Infovirtual void Info(const char *method, const char *msgfmt,...) constIssue info message.Definition TObject.cxx:961; TPairClass used by TMap to store (key,value) pairs.Definition TMap.h:102; TProtoClassPersistent version of a TClass.Definition TProtoClass.h:38; TROOT::Initializedstatic Bool_t Initialized()Return kTRUE if the TROOT object has been initialized.Definition TROOT.cxx:2906; TRegexpRegular expression class.Definition TRegexp.h:31; TStringBasic string class.Definition TString.h:139; TString::Dataconst char * Data() constDefinition TString.h:376; TString::RemoveTString & Remove(Ssiz_t pos)Definition TString.h:685; TString::IndexSsiz_t Index(const char *pat, S",MatchSource.WIKI,doc/v632/TClassTable_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/TClassTable_8cxx_source.html
https://root.cern/doc/v632/TClassTable_8cxx_source.html:47683,Integrability,message,message,47683,"d an object in this list using its name.Definition TList.cxx:576; TList::Addvoid Add(TObject *obj) overrideDefinition TList.h:83; TMapTMap implements an associative array of (key,value) pairs using a THashTable for efficient retrieval ...Definition TMap.h:40; TNamedThe TNamed class is the base class for all named ROOT classes.Definition TNamed.h:29; TNamed::GetNameconst char * GetName() const overrideReturns name of object.Definition TNamed.h:47; TObjStringCollectable string class.Definition TObjString.h:28; TObjString::StringTString & String()Definition TObjString.h:48; TObjectMother of all ROOT objects.Definition TObject.h:41; TObject::Warningvirtual void Warning(const char *method, const char *msgfmt,...) constIssue warning message.Definition TObject.cxx:973; TObject::FindObjectvirtual TObject * FindObject(const char *name) constMust be redefined in derived classes.Definition TObject.cxx:403; TObject::Fatalvirtual void Fatal(const char *method, const char *msgfmt,...) constIssue fatal error message.Definition TObject.cxx:1015; TObject::Infovirtual void Info(const char *method, const char *msgfmt,...) constIssue info message.Definition TObject.cxx:961; TPairClass used by TMap to store (key,value) pairs.Definition TMap.h:102; TProtoClassPersistent version of a TClass.Definition TProtoClass.h:38; TROOT::Initializedstatic Bool_t Initialized()Return kTRUE if the TROOT object has been initialized.Definition TROOT.cxx:2906; TRegexpRegular expression class.Definition TRegexp.h:31; TStringBasic string class.Definition TString.h:139; TString::Dataconst char * Data() constDefinition TString.h:376; TString::RemoveTString & Remove(Ssiz_t pos)Definition TString.h:685; TString::IndexSsiz_t Index(const char *pat, Ssiz_t i=0, ECaseCompare cmp=kExact) constDefinition TString.h:651; bool; int; unsigned int; lineTLine * lineDefinition entrylistblock_figure1.C:235; nconst Int_t nDefinition legend1.C:16; ROOT::Internal::gROOTLocalR__EXTERN TROOT * gROOTLocalDefinition TROOT.h:379; ROOT",MatchSource.WIKI,doc/v632/TClassTable_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/TClassTable_8cxx_source.html
https://root.cern/doc/v632/TClassTable_8cxx_source.html:47811,Integrability,message,message,47811,"apTMap implements an associative array of (key,value) pairs using a THashTable for efficient retrieval ...Definition TMap.h:40; TNamedThe TNamed class is the base class for all named ROOT classes.Definition TNamed.h:29; TNamed::GetNameconst char * GetName() const overrideReturns name of object.Definition TNamed.h:47; TObjStringCollectable string class.Definition TObjString.h:28; TObjString::StringTString & String()Definition TObjString.h:48; TObjectMother of all ROOT objects.Definition TObject.h:41; TObject::Warningvirtual void Warning(const char *method, const char *msgfmt,...) constIssue warning message.Definition TObject.cxx:973; TObject::FindObjectvirtual TObject * FindObject(const char *name) constMust be redefined in derived classes.Definition TObject.cxx:403; TObject::Fatalvirtual void Fatal(const char *method, const char *msgfmt,...) constIssue fatal error message.Definition TObject.cxx:1015; TObject::Infovirtual void Info(const char *method, const char *msgfmt,...) constIssue info message.Definition TObject.cxx:961; TPairClass used by TMap to store (key,value) pairs.Definition TMap.h:102; TProtoClassPersistent version of a TClass.Definition TProtoClass.h:38; TROOT::Initializedstatic Bool_t Initialized()Return kTRUE if the TROOT object has been initialized.Definition TROOT.cxx:2906; TRegexpRegular expression class.Definition TRegexp.h:31; TStringBasic string class.Definition TString.h:139; TString::Dataconst char * Data() constDefinition TString.h:376; TString::RemoveTString & Remove(Ssiz_t pos)Definition TString.h:685; TString::IndexSsiz_t Index(const char *pat, Ssiz_t i=0, ECaseCompare cmp=kExact) constDefinition TString.h:651; bool; int; unsigned int; lineTLine * lineDefinition entrylistblock_figure1.C:235; nconst Int_t nDefinition legend1.C:16; ROOT::Internal::gROOTLocalR__EXTERN TROOT * gROOTLocalDefinition TROOT.h:379; ROOTtbb::task_arena is an alias of tbb::interface7::task_arena, which doesn't allow to forward declare tb...Definition EExecutionPolicy",MatchSource.WIKI,doc/v632/TClassTable_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/TClassTable_8cxx_source.html
https://root.cern/doc/v632/TClassTable_8cxx_source.html:10101,Performance,load,load,10101," the table does not exist but the delayed list does, then; 306/// create the table and return true.; 307 ; 308inline Bool_t TClassTable::CheckClassTableInit(); 309{; 310 // This will be set at the lastest during TROOT construction, so before; 311 // any threading could happen.; 312 if (!gClassTable || !fgTable) {; 313 if (GetDelayedAddClass().size()) {; 314 new TClassTable;; 315 return kTRUE;; 316 }; 317 return kFALSE;; 318 }; 319 return kTRUE;; 320}; 321 ; 322////////////////////////////////////////////////////////////////////////////////; 323/// Print the class table. Before printing the table is sorted; 324/// alphabetically. Only classes specified in option are listed.; 325/// The default is to list all classes.; 326/// Standard wildcarding notation supported.; 327 ; 328void TClassTable::Print(Option_t *option) const; 329{; 330 std::lock_guard<std::mutex> lock(GetClassTableMutex());; 331 ; 332 // This is the very rare case (i.e. called before any dictionary load); 333 // so we don't need to execute this outside of the critical section.; 334 if (fgTally == 0 || !fgTable); 335 return;; 336 ; 337 SortTable();; 338 ; 339 int n = 0, ninit = 0, nl = 0;; 340 ; 341 if (!option) option = """";; 342 int nch = strlen(option);; 343 TRegexp re(option, kTRUE);; 344 ; 345 Printf(""\nDefined classes"");; 346 Printf(""class version bits initialized"");; 347 Printf(""================================================================"");; 348 for (UInt_t i = 0; i < fgTally; i++) {; 349 TClassRec *r = fgSortedTable[i];; 350 if (!r) break;; 351 n++;; 352 TString s = r->fName;; 353 if (nch && strcmp(option,r->fName) && s.Index(re) == kNPOS) continue;; 354 nl++;; 355 if (TClass::GetClass(r->fName, kFALSE)) {; 356 ninit++;; 357 Printf(""%-35s %6d %7d Yes"", r->fName, r->fId, r->fBits);; 358 } else; 359 Printf(""%-35s %6d %7d No"", r->fName, r->fId, r->fBits);; 360 }; 361 Printf(""----------------------------------------------------------------"");; 362 Printf(""Listed Classes: %4d Total classes: %4d ini",MatchSource.WIKI,doc/v632/TClassTable_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/TClassTable_8cxx_source.html
https://root.cern/doc/v632/TClassTable_8cxx_source.html:14115,Performance,load,loaded,14115," 406 if (!gClassTable); 407 new TClassTable;; 408 ; 409 std::unique_lock<std::mutex> lock(GetClassTableMutex());; 410 ; 411 // check if already in table, if so return; 412 TClassRec *r = FindElement(cname, kTRUE);; 413 if (r->fName && r->fInfo) {; 414 if ( strcmp(r->fInfo->name(), typeid(ROOT::TForNamespace).name()) ==0; 415 && strcmp(info.name(), typeid(ROOT::TForNamespace).name()) ==0 ) {; 416 // We have a namespace being reloaded.; 417 // This okay we just keep the old one.; 418 return;; 419 }; 420 if (!TClassEdit::IsStdClass(cname)) {; 421 lock.unlock(); // Warning might recursively call TClassTable during gROOT init; 422 // Warn only for class that are not STD classes; 423 ::Warning(""TClassTable::Add"", ""class %s already in TClassTable"", cname);; 424 }; 425 return;; 426 } else if (ROOT::Internal::gROOTLocal && gCling) {; 427 TClass *oldcl = (TClass*)gROOT->GetListOfClasses()->FindObject(cname);; 428 if (oldcl) { // && oldcl->GetClassInfo()) {; 429 // As a work-around to ROOT-6012, we need to register the class even if; 430 // it is not a template instance, because a forward declaration in the header; 431 // files loaded by the current dictionary wil also de-activate the update; 432 // class info mechanism!; 433 ; 434 // The TClass exist and already has a class info, so it must; 435 // correspond to a class template instantiation which the interpreter; 436 // was able to make with the library containing the TClass Init.; 437 // Because it is already known to the interpreter, the update class info; 438 // will not be triggered, we need to force it.; 439 gCling->RegisterTClassUpdate(oldcl, dict);; 440 }; 441 }; 442 ; 443 if (!r->fName); 444 r->fName = StrDup(cname);; 445 r->fId = id;; 446 r->fBits = pragmabits;; 447 r->fDict = dict;; 448 r->fInfo = &info;; 449 ; 450 fgIdMap->Add(info.name(),r);; 451 ; 452 fgSorted = kFALSE;; 453}; 454 ; 455////////////////////////////////////////////////////////////////////////////////; 456/// Add a class to the class table (this is",MatchSource.WIKI,doc/v632/TClassTable_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/TClassTable_8cxx_source.html
https://root.cern/doc/v632/TClassTable_8cxx_source.html:16275,Performance,load,loaded,16275,"460 // This will be set at the lastest during TROOT construction, so before; 461 // any threading could happen.; 462 if (!gClassTable); 463 new TClassTable;; 464 ; 465 std::unique_lock<std::mutex> lock(GetClassTableMutex());; 466 ; 467 // By definition the name in the TProtoClass is (must be) the normalized; 468 // name, so there is no need to tweak it.; 469 const char *cname = proto->GetName();; 470 ; 471 // check if already in table, if so return; 472 TClassRec *r = FindElement(cname, kTRUE);; 473 if (r->fName) {; 474 if (r->fProto) delete r->fProto;; 475 r->fProto = proto;; 476 TClass *oldcl = (TClass*)gROOT->GetListOfClasses()->FindObject(cname);; 477 ; 478 lock.unlock(); // FillTClass might recursively call TClassTable during gROOT init; 479 if (oldcl && oldcl->GetState() == TClass::kHasTClassInit); 480 proto->FillTClass(oldcl);; 481 return;; 482 } else if (ROOT::Internal::gROOTLocal && gCling) {; 483 TClass *oldcl = (TClass*)gROOT->GetListOfClasses()->FindObject(cname);; 484 if (oldcl) { // && oldcl->GetClassInfo()) {; 485 // As a work-around to ROOT-6012, we need to register the class even if; 486 // it is not a template instance, because a forward declaration in the header; 487 // files loaded by the current dictionary wil also de-activate the update; 488 // class info mechanism!; 489 ; 490 lock.unlock(); // Warning might recursively call TClassTable during gROOT init; 491 ::Warning(""TClassTable::Add(TProtoClass*)"",""Called for existing class without a prior call add the dictionary function."");; 492 }; 493 }; 494 ; 495 r->fName = StrDup(cname);; 496 r->fId = 0;; 497 r->fBits = 0;; 498 r->fDict = nullptr;; 499 r->fInfo = nullptr;; 500 r->fProto= proto;; 501 ; 502 fgSorted = kFALSE;; 503}; 504 ; 505////////////////////////////////////////////////////////////////////////////////; 506 ; 507ROOT::TClassAlt* TClassTable::AddAlternate(const char *normName, const char *alternate); 508{; 509 // This will be set at the lastest during TROOT construction, so before; 510 ",MatchSource.WIKI,doc/v632/TClassTable_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/TClassTable_8cxx_source.html
https://root.cern/doc/v632/TClassTable_8cxx_source.html:29798,Performance,load,loaded,29798,".; 895 ; 896void ROOT::AddClass(const char *cname, Version_t id,; 897 const std::type_info& info,; 898 DictFuncPtr_t dict,; 899 Int_t pragmabits); 900{; 901 if (!TROOT::Initialized() && !gClassTable) {; 902 auto r = std::unique_ptr<TClassRec>(new TClassRec(nullptr));; 903 r->fName = StrDup(cname);; 904 r->fId = id;; 905 r->fBits = pragmabits;; 906 r->fDict = dict;; 907 r->fInfo = &info;; 908 GetDelayedAddClass().emplace_back(std::move(r));; 909 } else {; 910 TClassTable::Add(cname, id, info, dict, pragmabits);; 911 }; 912}; 913 ; 914////////////////////////////////////////////////////////////////////////////////; 915/// Global function called by GenerateInitInstance.; 916/// (see the ClassImp macro).; 917 ; 918ROOT::TClassAlt* ROOT::AddClassAlternate(const char *normName, const char *alternate); 919{; 920 if (!TROOT::Initialized() && !gClassTable) {; 921 GetDelayedAddClassAlternate().emplace_back(normName, alternate);; 922 // If a library is loaded before gROOT is initialized we can assume; 923 // it is hard linked along side libCore (or is libCore) thus can't; 924 // really be unloaded.; 925 return nullptr;; 926 } else {; 927 return TClassTable::AddAlternate(normName, alternate);; 928 }; 929}; 930 ; 931void ROOT::RemoveClassAlternate(TClassAlt *alt); 932{; 933 // This routine is meant to be called (indirectly) by dlclose so we; 934 // we are guaranteed that the library initialization has completed.; 935 TClassTable::RemoveAlternate(alt);; 936}; 937 ; 938////////////////////////////////////////////////////////////////////////////////; 939/// Global function to update the version number.; 940/// This is called via the RootClassVersion macro.; 941///; 942/// if cl!=0 and cname==-1, set the new class version if and only is; 943/// greater than the existing one and greater or equal to 2;; 944/// and also ignore the request if fVersionUsed is true.; 945///; 946/// Note on class version number:; 947/// - If no class has been specified, TClass::GetVersion will return -1; 94",MatchSource.WIKI,doc/v632/TClassTable_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/TClassTable_8cxx_source.html
https://root.cern/doc/v632/TClassTable_8cxx_source.html:45946,Performance,load,load,45946,"assTable::AddAlternatestatic ROOT::TClassAlt * AddAlternate(const char *normname, const char *alternate)Definition TClassTable.cxx:507; TClassTable::fgCursorstatic UInt_t fgCursorDefinition TClassTable.h:53; TClassTClass instances represent classes, structs and namespaces in the ROOT type system.Definition TClass.h:81; TClass::GetStateEState GetState() constDefinition TClass.h:488; TClass::fClassVersionVersion_t fClassVersionDefinition TClass.h:221; TClass::SetUnloadedvoid SetUnloaded()Call this method to indicate that the shared library containing this class's code has been removed (u...Definition TClass.cxx:6309; TClass::SetClassVersionvoid SetClassVersion(Version_t version)Private function.Definition TClass.cxx:5675; TClass::fVersionUsedstd::atomic< Bool_t > fVersionUsedsaved remember if fOffsetStreamer has been set.Definition TClass.h:262; TClass::kHasTClassInit@ kHasTClassInitDefinition TClass.h:127; TClass::GetClassstatic TClass * GetClass(const char *name, Bool_t load=kTRUE, Bool_t silent=kFALSE)Static method returning pointer to TClass of the specified class name.Definition TClass.cxx:2968; TCollection::UseRWLockvirtual bool UseRWLock(Bool_t enable=true)Set this collection to use a RW lock upon access, making it thread safe.Definition TCollection.cxx:761; TCollection::SetOwnervirtual void SetOwner(Bool_t enable=kTRUE)Set whether this collection is the owner (enable==true) of its content.Definition TCollection.cxx:746; TInterpreter::RegisterTClassUpdatevirtual void RegisterTClassUpdate(TClass *oldcl, DictFuncPtr_t dict)=0; TIterDefinition TCollection.h:235; TListA doubly linked list.Definition TList.h:38; TList::FindObjectTObject * FindObject(const char *name) const overrideFind an object in this list using its name.Definition TList.cxx:576; TList::Addvoid Add(TObject *obj) overrideDefinition TList.h:83; TMapTMap implements an associative array of (key,value) pairs using a THashTable for efficient retrieval ...Definition TMap.h:40; TNamedThe TNamed class is t",MatchSource.WIKI,doc/v632/TClassTable_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/TClassTable_8cxx_source.html
https://root.cern/doc/v632/TClassTable_8cxx_source.html:996,Safety,safe,safe,996,". ROOT: core/cont/src/TClassTable.cxx Source File. ; ROOT ; . v6-32. Reference Guide ; . . Loading...; Searching...; No Matches. TClassTable.cxx. Go to the documentation of this file. 1// @(#)root/cont:$Id$; 2// Author: Fons Rademakers 11/08/95; 3 ; 4/*************************************************************************; 5 * Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; 6 * All rights reserved. *; 7 * *; 8 * For the licensing terms see $ROOTSYS/LICENSE. *; 9 * For the list of contributors see $ROOTSYS/README/CREDITS. *; 10 *************************************************************************/; 11 ; 12/** \class TClassTable; 13\ingroup Containers; 14This class registers for all classes their name, id and dictionary; 15function in a hash table. Classes are automatically added by the; 16ctor of a special init class when a global of this init class is; 17initialized when the program starts (see the ClassImp macro).; 18 ; 19All functions in TClassTable are thread-safe.; 20*/; 21 ; 22#include ""TClassTable.h""; 23 ; 24#include ""TClass.h""; 25#include ""TClassEdit.h""; 26#include ""TProtoClass.h""; 27#include ""TList.h""; 28#include ""TROOT.h""; 29#include ""TString.h""; 30#include ""TError.h""; 31#include ""TRegexp.h""; 32 ; 33#include ""TObjString.h""; 34#include ""TMap.h""; 35 ; 36#include ""TInterpreter.h""; 37 ; 38#include <map>; 39#include <memory>; 40#include <typeinfo>; 41#include <cstdlib>; 42#include <string>; 43#include <mutex>; 44 ; 45using namespace ROOT;; 46 ; 47TClassTable *gClassTable;; 48 ; 49TClassAlt **TClassTable::fgAlternate;; 50TClassRec **TClassTable::fgTable;; 51TClassRec **TClassTable::fgSortedTable;; 52UInt_t TClassTable::fgSize;; 53std::atomic<UInt_t> TClassTable::fgTally;; 54Bool_t TClassTable::fgSorted;; 55UInt_t TClassTable::fgCursor;; 56TClassTable::IdMap_t *TClassTable::fgIdMap;; 57 ; 58ClassImp(TClassTable);; 59 ; 60static std::mutex &GetClassTableMutex(); 61{; 62 static std::mutex sMutex;; 63 return sMutex;; 64}; 65 ; 66// RAII to first nor",MatchSource.WIKI,doc/v632/TClassTable_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/TClassTable_8cxx_source.html
https://root.cern/doc/v632/TClassTable_8cxx_source.html:4346,Safety,avoid,avoid,4346,"/////////////////////////////////////////////////////////////////////////; 104 ; 105namespace ROOT {; 106 class TClassRec {; 107 public:; 108 TClassRec(TClassRec *next) :; 109 fName(nullptr), fId(0), fDict(nullptr), fInfo(nullptr), fProto(nullptr), fNext(next); 110 {}; 111 ; 112 ~TClassRec() {; 113 // TClassTable::fgIdMap->Remove(r->fInfo->name());; 114 delete [] fName;; 115 delete fProto;; 116 delete fNext;; 117 }; 118 ; 119 char *fName;; 120 Version_t fId;; 121 Int_t fBits;; 122 DictFuncPtr_t fDict;; 123 const std::type_info *fInfo;; 124 TProtoClass *fProto;; 125 TClassRec *fNext;; 126 };; 127 ; 128 class TClassAlt {; 129 public:; 130 TClassAlt(const char*alternate, const char *normName, TClassAlt *next) :; 131 fName(alternate), fNormName(normName), fNext(next); 132 {}; 133 ; 134 ~TClassAlt() {; 135 // Nothing more to delete.; 136 }; 137 ; 138 const char *fName; // Do not own; 139 const char *fNormName; // Do not own; 140 std::unique_ptr<TClassAlt> fNext;; 141 };; 142 ; 143#define R__USE_STD_MAP; 144 class TMapTypeToClassRec {; 145#if defined R__USE_STD_MAP; 146 // This wrapper class allow to avoid putting #include <map> in the; 147 // TROOT.h header file.; 148 public:; 149 typedef std::map<std::string, TClassRec*> IdMap_t;; 150 typedef IdMap_t::key_type key_type;; 151 typedef IdMap_t::const_iterator const_iterator;; 152 typedef IdMap_t::size_type size_type;; 153#ifdef R__WIN32; 154 // Window's std::map does NOT defined mapped_type; 155 typedef TClassRec* mapped_type;; 156#else; 157 typedef IdMap_t::mapped_type mapped_type;; 158#endif; 159 ; 160 private:; 161 IdMap_t fMap;; 162 ; 163 public:; 164 void Add(const key_type &key, mapped_type &obj) {; 165 fMap[key] = obj;; 166 }; 167 ; 168 mapped_type Find(const key_type &key) const {; 169 IdMap_t::const_iterator iter = fMap.find(key);; 170 mapped_type cl = nullptr;; 171 if (iter != fMap.end()) cl = iter->second;; 172 return cl;; 173 }; 174 ; 175 void Remove(const key_type &key) { fMap.erase(key); }; 176 ; 177 void Prin",MatchSource.WIKI,doc/v632/TClassTable_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/TClassTable_8cxx_source.html
https://root.cern/doc/v632/TClassTable_8cxx_source.html:8626,Safety,avoid,avoid,8626,"//////; 262/// TClassTable is a singleton (i.e. only one can exist per application).; 263 ; 264TClassTable::TClassTable(); 265{; 266 if (gClassTable) return;; 267 ; 268 fgSize = 1009; //this is the result of (int)TMath::NextPrime(1000);; 269 fgTable = new TClassRec* [fgSize];; 270 fgAlternate = new TClassAlt* [fgSize];; 271 fgIdMap = new IdMap_t;; 272 memset(fgTable, 0, fgSize * sizeof(TClassRec*));; 273 memset(fgAlternate, 0, fgSize * sizeof(TClassAlt*));; 274 gClassTable = this;; 275 ; 276 for (auto &&r : GetDelayedAddClass()) {; 277 AddClass(r->fName, r->fId, *r->fInfo, r->fDict, r->fBits);; 278 };; 279 GetDelayedAddClass().clear();; 280 ; 281 for (auto &&r : GetDelayedAddClassAlternate()) {; 282 AddAlternate(r.first, r.second);; 283 }; 284 GetDelayedAddClassAlternate().clear();; 285}; 286 ; 287////////////////////////////////////////////////////////////////////////////////; 288/// TClassTable singleton is deleted in Terminate().; 289 ; 290TClassTable::~TClassTable(); 291{; 292 // Try to avoid spurious warning from memory leak checkers.; 293 if (gClassTable != this) return;; 294 ; 295 for (UInt_t i = 0; i < fgSize; i++) {; 296 delete fgTable[i]; // Will delete all the elements in the chain.; 297 }; 298 delete [] fgTable; fgTable = nullptr;; 299 delete [] fgSortedTable; fgSortedTable = nullptr;; 300 delete fgIdMap; fgIdMap = nullptr;; 301}; 302 ; 303////////////////////////////////////////////////////////////////////////////////; 304/// Return true fs the table exist.; 305/// If the table does not exist but the delayed list does, then; 306/// create the table and return true.; 307 ; 308inline Bool_t TClassTable::CheckClassTableInit(); 309{; 310 // This will be set at the lastest during TROOT construction, so before; 311 // any threading could happen.; 312 if (!gClassTable || !fgTable) {; 313 if (GetDelayedAddClass().size()) {; 314 new TClassTable;; 315 return kTRUE;; 316 }; 317 return kFALSE;; 318 }; 319 return kTRUE;; 320}; 321 ; 322///////////////////////////////",MatchSource.WIKI,doc/v632/TClassTable_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/TClassTable_8cxx_source.html
https://root.cern/doc/v632/TClassTable_8cxx_source.html:27038,Safety,avoid,avoid,27038,"///////////////////////////////////////////////////////////////////; 803/// Returns next class from sorted class table. Don't use this iterator; 804/// while modifying the class table. The class table can be modified; 805/// when making calls like TClass::GetClass(), etc.; 806 ; 807char *TClassTable::Next(); 808{; 809 std::lock_guard<std::mutex> lock(GetClassTableMutex());; 810 ; 811 if (fgCursor < fgTally) {; 812 TClassRec *r = fgSortedTable[fgCursor++];; 813 return r->fName;; 814 }; 815 ; 816 return nullptr;; 817}; 818 ; 819////////////////////////////////////////////////////////////////////////////////; 820/// Print the class table. Before printing the table is sorted; 821/// alphabetically.; 822 ; 823void TClassTable::PrintTable(); 824{; 825 if (fgTally == 0 || !fgTable); 826 return;; 827 ; 828 std::lock_guard<std::mutex> lock(GetClassTableMutex());; 829 ; 830 SortTable();; 831 ; 832 int n = 0, ninit = 0;; 833 ; 834 Printf(""\nDefined classes"");; 835 Printf(""class version bits initialized"");; 836 Printf(""================================================================"");; 837 UInt_t last = fgTally;; 838 for (UInt_t i = 0; i < last; i++) {; 839 TClassRec *r = fgSortedTable[i];; 840 if (!r) break;; 841 n++;; 842 // Do not use TClass::GetClass to avoid any risk of autoloading.; 843 if (gROOT->GetListOfClasses()->FindObject(r->fName)) {; 844 ninit++;; 845 Printf(""%-35s %6d %7d Yes"", r->fName, r->fId, r->fBits);; 846 } else; 847 Printf(""%-35s %6d %7d No"", r->fName, r->fId, r->fBits);; 848 }; 849 Printf(""----------------------------------------------------------------"");; 850 Printf(""Total classes: %4d initialized: %4d"", n, ninit);; 851 Printf(""================================================================\n"");; 852}; 853 ; 854////////////////////////////////////////////////////////////////////////////////; 855/// Sort the class table by ascending class ID's.; 856 ; 857void TClassTable::SortTable(); 858{; 859 // Internal routine.; 860 ; 861 if (!fgSorted) {; 862 dele",MatchSource.WIKI,doc/v632/TClassTable_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/TClassTable_8cxx_source.html
https://root.cern/doc/v632/TClassTable_8cxx_source.html:27048,Safety,risk,risk,27048,"///////////////////////////////////////////////////////////////////; 803/// Returns next class from sorted class table. Don't use this iterator; 804/// while modifying the class table. The class table can be modified; 805/// when making calls like TClass::GetClass(), etc.; 806 ; 807char *TClassTable::Next(); 808{; 809 std::lock_guard<std::mutex> lock(GetClassTableMutex());; 810 ; 811 if (fgCursor < fgTally) {; 812 TClassRec *r = fgSortedTable[fgCursor++];; 813 return r->fName;; 814 }; 815 ; 816 return nullptr;; 817}; 818 ; 819////////////////////////////////////////////////////////////////////////////////; 820/// Print the class table. Before printing the table is sorted; 821/// alphabetically.; 822 ; 823void TClassTable::PrintTable(); 824{; 825 if (fgTally == 0 || !fgTable); 826 return;; 827 ; 828 std::lock_guard<std::mutex> lock(GetClassTableMutex());; 829 ; 830 SortTable();; 831 ; 832 int n = 0, ninit = 0;; 833 ; 834 Printf(""\nDefined classes"");; 835 Printf(""class version bits initialized"");; 836 Printf(""================================================================"");; 837 UInt_t last = fgTally;; 838 for (UInt_t i = 0; i < last; i++) {; 839 TClassRec *r = fgSortedTable[i];; 840 if (!r) break;; 841 n++;; 842 // Do not use TClass::GetClass to avoid any risk of autoloading.; 843 if (gROOT->GetListOfClasses()->FindObject(r->fName)) {; 844 ninit++;; 845 Printf(""%-35s %6d %7d Yes"", r->fName, r->fId, r->fBits);; 846 } else; 847 Printf(""%-35s %6d %7d No"", r->fName, r->fId, r->fBits);; 848 }; 849 Printf(""----------------------------------------------------------------"");; 850 Printf(""Total classes: %4d initialized: %4d"", n, ninit);; 851 Printf(""================================================================\n"");; 852}; 853 ; 854////////////////////////////////////////////////////////////////////////////////; 855/// Sort the class table by ascending class ID's.; 856 ; 857void TClassTable::SortTable(); 858{; 859 // Internal routine.; 860 ; 861 if (!fgSorted) {; 862 dele",MatchSource.WIKI,doc/v632/TClassTable_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/TClassTable_8cxx_source.html
https://root.cern/doc/v632/TClassTable_8cxx_source.html:46208,Safety,safe,safe,46208,"Definition TClassTable.h:53; TClassTClass instances represent classes, structs and namespaces in the ROOT type system.Definition TClass.h:81; TClass::GetStateEState GetState() constDefinition TClass.h:488; TClass::fClassVersionVersion_t fClassVersionDefinition TClass.h:221; TClass::SetUnloadedvoid SetUnloaded()Call this method to indicate that the shared library containing this class's code has been removed (u...Definition TClass.cxx:6309; TClass::SetClassVersionvoid SetClassVersion(Version_t version)Private function.Definition TClass.cxx:5675; TClass::fVersionUsedstd::atomic< Bool_t > fVersionUsedsaved remember if fOffsetStreamer has been set.Definition TClass.h:262; TClass::kHasTClassInit@ kHasTClassInitDefinition TClass.h:127; TClass::GetClassstatic TClass * GetClass(const char *name, Bool_t load=kTRUE, Bool_t silent=kFALSE)Static method returning pointer to TClass of the specified class name.Definition TClass.cxx:2968; TCollection::UseRWLockvirtual bool UseRWLock(Bool_t enable=true)Set this collection to use a RW lock upon access, making it thread safe.Definition TCollection.cxx:761; TCollection::SetOwnervirtual void SetOwner(Bool_t enable=kTRUE)Set whether this collection is the owner (enable==true) of its content.Definition TCollection.cxx:746; TInterpreter::RegisterTClassUpdatevirtual void RegisterTClassUpdate(TClass *oldcl, DictFuncPtr_t dict)=0; TIterDefinition TCollection.h:235; TListA doubly linked list.Definition TList.h:38; TList::FindObjectTObject * FindObject(const char *name) const overrideFind an object in this list using its name.Definition TList.cxx:576; TList::Addvoid Add(TObject *obj) overrideDefinition TList.h:83; TMapTMap implements an associative array of (key,value) pairs using a THashTable for efficient retrieval ...Definition TMap.h:40; TNamedThe TNamed class is the base class for all named ROOT classes.Definition TNamed.h:29; TNamed::GetNameconst char * GetName() const overrideReturns name of object.Definition TNamed.h:47; TObjStringColle",MatchSource.WIKI,doc/v632/TClassTable_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/TClassTable_8cxx_source.html
https://root.cern/doc/v632/TClassTable_8cxx_source.html:764,Security,hash,hash,764,". ROOT: core/cont/src/TClassTable.cxx Source File. ; ROOT ; . v6-32. Reference Guide ; . . Loading...; Searching...; No Matches. TClassTable.cxx. Go to the documentation of this file. 1// @(#)root/cont:$Id$; 2// Author: Fons Rademakers 11/08/95; 3 ; 4/*************************************************************************; 5 * Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; 6 * All rights reserved. *; 7 * *; 8 * For the licensing terms see $ROOTSYS/LICENSE. *; 9 * For the list of contributors see $ROOTSYS/README/CREDITS. *; 10 *************************************************************************/; 11 ; 12/** \class TClassTable; 13\ingroup Containers; 14This class registers for all classes their name, id and dictionary; 15function in a hash table. Classes are automatically added by the; 16ctor of a special init class when a global of this init class is; 17initialized when the program starts (see the ClassImp macro).; 18 ; 19All functions in TClassTable are thread-safe.; 20*/; 21 ; 22#include ""TClassTable.h""; 23 ; 24#include ""TClass.h""; 25#include ""TClassEdit.h""; 26#include ""TProtoClass.h""; 27#include ""TList.h""; 28#include ""TROOT.h""; 29#include ""TString.h""; 30#include ""TError.h""; 31#include ""TRegexp.h""; 32 ; 33#include ""TObjString.h""; 34#include ""TMap.h""; 35 ; 36#include ""TInterpreter.h""; 37 ; 38#include <map>; 39#include <memory>; 40#include <typeinfo>; 41#include <cstdlib>; 42#include <string>; 43#include <mutex>; 44 ; 45using namespace ROOT;; 46 ; 47TClassTable *gClassTable;; 48 ; 49TClassAlt **TClassTable::fgAlternate;; 50TClassRec **TClassTable::fgTable;; 51TClassRec **TClassTable::fgSortedTable;; 52UInt_t TClassTable::fgSize;; 53std::atomic<UInt_t> TClassTable::fgTally;; 54Bool_t TClassTable::fgSorted;; 55UInt_t TClassTable::fgCursor;; 56TClassTable::IdMap_t *TClassTable::fgIdMap;; 57 ; 58ClassImp(TClassTable);; 59 ; 60static std::mutex &GetClassTableMutex(); 61{; 62 static std::mutex sMutex;; 63 return sMutex;; 64}; 65 ; 66// RAII to first nor",MatchSource.WIKI,doc/v632/TClassTable_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/TClassTable_8cxx_source.html
https://root.cern/doc/v632/TClassTable_8cxx_source.html:20388,Security,hash,hash,20388,"; 580 return kTRUE;; 581 }; 582 }; 583 ; 584 return kFALSE;; 585}; 586 ; 587////////////////////////////////////////////////////////////////////////////////; 588/// Remove a class from the class table. This happens when a shared library; 589/// is unloaded (i.e. the dtor's of the global init objects are called).; 590 ; 591void TClassTable::Remove(const char *cname); 592{; 593 if (!CheckClassTableInit()); 594 return;; 595 ; 596 std::lock_guard<std::mutex> lock(GetClassTableMutex());; 597 ; 598 UInt_t slot = ROOT::ClassTableHash(cname, fgSize);; 599 ; 600 TClassRec *r;; 601 TClassRec *prev = nullptr;; 602 for (r = fgTable[slot]; r; r = r->fNext) {; 603 if (!strcmp(r->fName, cname)) {; 604 if (prev); 605 prev->fNext = r->fNext;; 606 else; 607 fgTable[slot] = r->fNext;; 608 fgIdMap->Remove(r->fInfo->name());; 609 r->fNext = nullptr; // Do not delete the others.; 610 delete r;; 611 fgTally--;; 612 fgSorted = kFALSE;; 613 break;; 614 }; 615 prev = r;; 616 }; 617}; 618 ; 619////////////////////////////////////////////////////////////////////////////////; 620/// Find a class by name in the class table (using hash of name). Returns; 621/// 0 if the class is not in the table. Unless arguments insert is true in; 622/// which case a new entry is created and returned.; 623/// `cname` must be the normalized name of the class.; 624 ; 625TClassRec *TClassTable::FindElement(const char *cname, Bool_t insert); 626{; 627 // Internal routine, no explicit lock needed here.; 628 ; 629 UInt_t slot = ROOT::ClassTableHash(cname, fgSize);; 630 ; 631 for (TClassRec *r = fgTable[slot]; r; r = r->fNext); 632 if (strcmp(cname, r->fName) == 0); 633 return r;; 634 ; 635 if (!insert); 636 return nullptr;; 637 ; 638 fgTable[slot] = new TClassRec(fgTable[slot]);; 639 ; 640 fgTally++;; 641 return fgTable[slot];; 642}; 643 ; 644////////////////////////////////////////////////////////////////////////////////; 645/// Returns the ID of a class.; 646 ; 647Version_t TClassTable::GetID(const char *cname); 648{",MatchSource.WIKI,doc/v632/TClassTable_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/TClassTable_8cxx_source.html
https://root.cern/doc/v632/TClassTable_8cxx_source.html:22025,Security,hash,hash,22025," 0); 633 return r;; 634 ; 635 if (!insert); 636 return nullptr;; 637 ; 638 fgTable[slot] = new TClassRec(fgTable[slot]);; 639 ; 640 fgTally++;; 641 return fgTable[slot];; 642}; 643 ; 644////////////////////////////////////////////////////////////////////////////////; 645/// Returns the ID of a class.; 646 ; 647Version_t TClassTable::GetID(const char *cname); 648{; 649 NormalizeThenLock guard(cname);; 650 ; 651 TClassRec *r = FindElement(guard.GetNormalizedName().c_str(), kFALSE);; 652 if (r); 653 return r->fId;; 654 return -1;; 655}; 656 ; 657////////////////////////////////////////////////////////////////////////////////; 658/// Returns the pragma bits as specified in the LinkDef.h file.; 659 ; 660Int_t TClassTable::GetPragmaBits(const char *cname); 661{; 662 NormalizeThenLock guard(cname);; 663 ; 664 TClassRec *r = FindElement(guard.GetNormalizedName().c_str(), kFALSE);; 665 if (r); 666 return r->fBits;; 667 return 0;; 668}; 669 ; 670////////////////////////////////////////////////////////////////////////////////; 671/// Given the class name returns the Dictionary() function of a class; 672/// (uses hash of name).; 673 ; 674DictFuncPtr_t TClassTable::GetDict(const char *cname); 675{; 676 if (gDebug > 9) {; 677 ::Info(""GetDict"", ""searches for %s"", cname);; 678 fgIdMap->Print();; 679 }; 680 NormalizeThenLock guard(cname);; 681 ; 682 TClassRec *r = FindElement(guard.GetNormalizedName().c_str(), kFALSE);; 683 if (r); 684 return r->fDict;; 685 return nullptr;; 686}; 687 ; 688////////////////////////////////////////////////////////////////////////////////; 689/// Given the std::type_info returns the Dictionary() function of a class; 690/// (uses hash of std::type_info::name()).; 691 ; 692DictFuncPtr_t TClassTable::GetDict(const std::type_info& info); 693{; 694 if (!CheckClassTableInit()); 695 return nullptr;; 696 ; 697 if (gDebug > 9); 698 ROOT::GetROOT(); // Info might recursively call TClassTable during the gROOT init; 699 ; 700 std::lock_guard<std::mutex> lock(GetCla",MatchSource.WIKI,doc/v632/TClassTable_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/TClassTable_8cxx_source.html
https://root.cern/doc/v632/TClassTable_8cxx_source.html:22576,Security,hash,hash,22576,"//////////////////////////////////////////////////////////////////////////; 658/// Returns the pragma bits as specified in the LinkDef.h file.; 659 ; 660Int_t TClassTable::GetPragmaBits(const char *cname); 661{; 662 NormalizeThenLock guard(cname);; 663 ; 664 TClassRec *r = FindElement(guard.GetNormalizedName().c_str(), kFALSE);; 665 if (r); 666 return r->fBits;; 667 return 0;; 668}; 669 ; 670////////////////////////////////////////////////////////////////////////////////; 671/// Given the class name returns the Dictionary() function of a class; 672/// (uses hash of name).; 673 ; 674DictFuncPtr_t TClassTable::GetDict(const char *cname); 675{; 676 if (gDebug > 9) {; 677 ::Info(""GetDict"", ""searches for %s"", cname);; 678 fgIdMap->Print();; 679 }; 680 NormalizeThenLock guard(cname);; 681 ; 682 TClassRec *r = FindElement(guard.GetNormalizedName().c_str(), kFALSE);; 683 if (r); 684 return r->fDict;; 685 return nullptr;; 686}; 687 ; 688////////////////////////////////////////////////////////////////////////////////; 689/// Given the std::type_info returns the Dictionary() function of a class; 690/// (uses hash of std::type_info::name()).; 691 ; 692DictFuncPtr_t TClassTable::GetDict(const std::type_info& info); 693{; 694 if (!CheckClassTableInit()); 695 return nullptr;; 696 ; 697 if (gDebug > 9); 698 ROOT::GetROOT(); // Info might recursively call TClassTable during the gROOT init; 699 ; 700 std::lock_guard<std::mutex> lock(GetClassTableMutex());; 701 ; 702 if (gDebug > 9) {; 703 ::Info(""GetDict"", ""searches for %s at 0x%zx"", info.name(), (size_t)&info);; 704 fgIdMap->Print();; 705 }; 706 ; 707 TClassRec *r = fgIdMap->Find(info.name());; 708 if (r); 709 return r->fDict;; 710 return nullptr;; 711}; 712 ; 713////////////////////////////////////////////////////////////////////////////////; 714/// Given the normalized class name returns the Dictionary() function of a class; 715/// (uses hash of name).; 716 ; 717DictFuncPtr_t TClassTable::GetDictNorm(const char *cname); 718{; 719 ",MatchSource.WIKI,doc/v632/TClassTable_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/TClassTable_8cxx_source.html
https://root.cern/doc/v632/TClassTable_8cxx_source.html:23367,Security,hash,hash,23367,"ame);; 681 ; 682 TClassRec *r = FindElement(guard.GetNormalizedName().c_str(), kFALSE);; 683 if (r); 684 return r->fDict;; 685 return nullptr;; 686}; 687 ; 688////////////////////////////////////////////////////////////////////////////////; 689/// Given the std::type_info returns the Dictionary() function of a class; 690/// (uses hash of std::type_info::name()).; 691 ; 692DictFuncPtr_t TClassTable::GetDict(const std::type_info& info); 693{; 694 if (!CheckClassTableInit()); 695 return nullptr;; 696 ; 697 if (gDebug > 9); 698 ROOT::GetROOT(); // Info might recursively call TClassTable during the gROOT init; 699 ; 700 std::lock_guard<std::mutex> lock(GetClassTableMutex());; 701 ; 702 if (gDebug > 9) {; 703 ::Info(""GetDict"", ""searches for %s at 0x%zx"", info.name(), (size_t)&info);; 704 fgIdMap->Print();; 705 }; 706 ; 707 TClassRec *r = fgIdMap->Find(info.name());; 708 if (r); 709 return r->fDict;; 710 return nullptr;; 711}; 712 ; 713////////////////////////////////////////////////////////////////////////////////; 714/// Given the normalized class name returns the Dictionary() function of a class; 715/// (uses hash of name).; 716 ; 717DictFuncPtr_t TClassTable::GetDictNorm(const char *cname); 718{; 719 if (!CheckClassTableInit()); 720 return nullptr;; 721 ; 722 if (gDebug > 9); 723 ROOT::GetROOT(); // Info might recursively call TClassTable during the gROOT init; 724 ; 725 std::lock_guard<std::mutex> lock(GetClassTableMutex());; 726 ; 727 if (gDebug > 9) {; 728 ::Info(""GetDict"", ""searches for %s"", cname);; 729 fgIdMap->Print();; 730 }; 731 ; 732 TClassRec *r = FindElement(cname, kFALSE);; 733 if (r); 734 return r->fDict;; 735 return nullptr;; 736}; 737 ; 738////////////////////////////////////////////////////////////////////////////////; 739/// Given the class name returns the TClassProto object for the class.; 740/// (uses hash of name).; 741 ; 742TProtoClass *TClassTable::GetProto(const char *cname); 743{; 744 if (gDebug > 9) {; 745 ::Info(""GetDict"", ""searches for %s"",",MatchSource.WIKI,doc/v632/TClassTable_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/TClassTable_8cxx_source.html
https://root.cern/doc/v632/TClassTable_8cxx_source.html:24095,Security,hash,hash,24095,"p->Find(info.name());; 708 if (r); 709 return r->fDict;; 710 return nullptr;; 711}; 712 ; 713////////////////////////////////////////////////////////////////////////////////; 714/// Given the normalized class name returns the Dictionary() function of a class; 715/// (uses hash of name).; 716 ; 717DictFuncPtr_t TClassTable::GetDictNorm(const char *cname); 718{; 719 if (!CheckClassTableInit()); 720 return nullptr;; 721 ; 722 if (gDebug > 9); 723 ROOT::GetROOT(); // Info might recursively call TClassTable during the gROOT init; 724 ; 725 std::lock_guard<std::mutex> lock(GetClassTableMutex());; 726 ; 727 if (gDebug > 9) {; 728 ::Info(""GetDict"", ""searches for %s"", cname);; 729 fgIdMap->Print();; 730 }; 731 ; 732 TClassRec *r = FindElement(cname, kFALSE);; 733 if (r); 734 return r->fDict;; 735 return nullptr;; 736}; 737 ; 738////////////////////////////////////////////////////////////////////////////////; 739/// Given the class name returns the TClassProto object for the class.; 740/// (uses hash of name).; 741 ; 742TProtoClass *TClassTable::GetProto(const char *cname); 743{; 744 if (gDebug > 9) {; 745 ::Info(""GetDict"", ""searches for %s"", cname);; 746 }; 747 ; 748 if (!CheckClassTableInit()); 749 return nullptr;; 750 ; 751 NormalizeThenLock guard(cname);; 752 ; 753 if (gDebug > 9) {; 754 // Because of the early call to Info, gROOT is already initialized; 755 // and thus this will not cause a recursive call to TClassTable.; 756 ::Info(""GetDict"", ""searches for %s"", cname);; 757 fgIdMap->Print();; 758 }; 759 ; 760 TClassRec *r = FindElement(guard.GetNormalizedName().c_str(), kFALSE);; 761 if (r); 762 return r->fProto;; 763 return nullptr;; 764}; 765 ; 766////////////////////////////////////////////////////////////////////////////////; 767/// Given the class normalized name returns the TClassProto object for the class.; 768/// (uses hash of name).; 769 ; 770TProtoClass *TClassTable::GetProtoNorm(const char *cname); 771{; 772 if (gDebug > 9) {; 773 ::Info(""GetDict"", ""searches f",MatchSource.WIKI,doc/v632/TClassTable_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/TClassTable_8cxx_source.html
https://root.cern/doc/v632/TClassTable_8cxx_source.html:24949,Security,hash,hash,24949,"/////////////////////////////////////////////////////////; 739/// Given the class name returns the TClassProto object for the class.; 740/// (uses hash of name).; 741 ; 742TProtoClass *TClassTable::GetProto(const char *cname); 743{; 744 if (gDebug > 9) {; 745 ::Info(""GetDict"", ""searches for %s"", cname);; 746 }; 747 ; 748 if (!CheckClassTableInit()); 749 return nullptr;; 750 ; 751 NormalizeThenLock guard(cname);; 752 ; 753 if (gDebug > 9) {; 754 // Because of the early call to Info, gROOT is already initialized; 755 // and thus this will not cause a recursive call to TClassTable.; 756 ::Info(""GetDict"", ""searches for %s"", cname);; 757 fgIdMap->Print();; 758 }; 759 ; 760 TClassRec *r = FindElement(guard.GetNormalizedName().c_str(), kFALSE);; 761 if (r); 762 return r->fProto;; 763 return nullptr;; 764}; 765 ; 766////////////////////////////////////////////////////////////////////////////////; 767/// Given the class normalized name returns the TClassProto object for the class.; 768/// (uses hash of name).; 769 ; 770TProtoClass *TClassTable::GetProtoNorm(const char *cname); 771{; 772 if (gDebug > 9) {; 773 ::Info(""GetDict"", ""searches for %s"", cname);; 774 }; 775 ; 776 if (!CheckClassTableInit()); 777 return nullptr;; 778 ; 779 std::lock_guard<std::mutex> lock(GetClassTableMutex());; 780 ; 781 if (gDebug > 9) {; 782 fgIdMap->Print();; 783 }; 784 ; 785 TClassRec *r = FindElement(cname, kFALSE);; 786 if (r); 787 return r->fProto;; 788 return nullptr;; 789}; 790 ; 791////////////////////////////////////////////////////////////////////////////////; 792 ; 793extern ""C"" {; 794 static int ClassComp(const void *a, const void *b); 795 {; 796 // Function used for sorting classes alphabetically.; 797 ; 798 return strcmp((*(TClassRec **)a)->fName, (*(TClassRec **)b)->fName);; 799 }; 800}; 801 ; 802////////////////////////////////////////////////////////////////////////////////; 803/// Returns next class from sorted class table. Don't use this iterator; 804/// while modifying the class ",MatchSource.WIKI,doc/v632/TClassTable_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/TClassTable_8cxx_source.html
https://root.cern/doc/v632/TClassTable_8cxx_source.html:31023,Security,checksum,checksum,31023,"me, alternate);; 928 }; 929}; 930 ; 931void ROOT::RemoveClassAlternate(TClassAlt *alt); 932{; 933 // This routine is meant to be called (indirectly) by dlclose so we; 934 // we are guaranteed that the library initialization has completed.; 935 TClassTable::RemoveAlternate(alt);; 936}; 937 ; 938////////////////////////////////////////////////////////////////////////////////; 939/// Global function to update the version number.; 940/// This is called via the RootClassVersion macro.; 941///; 942/// if cl!=0 and cname==-1, set the new class version if and only is; 943/// greater than the existing one and greater or equal to 2;; 944/// and also ignore the request if fVersionUsed is true.; 945///; 946/// Note on class version number:; 947/// - If no class has been specified, TClass::GetVersion will return -1; 948/// - The Class Version 0 request the whole object to be transient; 949/// - The Class Version 1, unless specify via ClassDef indicates that the; 950/// I/O should use the TClass checksum to distinguish the layout of the class; 951void ROOT::ResetClassVersion(TClass *cl, const char *cname, Short_t newid); 952{; 953 if (cname && cname != (void*)-1 && TClassTable::CheckClassTableInit()) {; 954 TClassTable::NormalizeThenLock guard(cname);; 955 TClassRec *r = TClassTable::FindElement(guard.GetNormalizedName().c_str(), kFALSE);; 956 if (r); 957 r->fId = newid;; 958 }; 959 if (cl) {; 960 if (cl->fVersionUsed) {; 961 // Problem, the reset is called after the first usage!; 962 if (cname!=(void*)-1); 963 Error(""ResetClassVersion"",""Version number of %s can not be changed after first usage!"",; 964 cl->GetName());; 965 } else {; 966 if (newid < 0) {; 967 Error(""SetClassVersion"",""The class version (for %s) must be positive (value %d is ignored)"",cl->GetName(),newid);; 968 }; 969 if (cname==(void*)-1) {; 970 if (cl->fClassVersion<newid && 2<=newid) {; 971 cl->SetClassVersion(newid);; 972 }; 973 } else {; 974 cl->SetClassVersion(newid);; 975 }; 976 }; 977 }; 978}; 979 ; 980 ; 98",MatchSource.WIKI,doc/v632/TClassTable_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/TClassTable_8cxx_source.html
https://root.cern/doc/v632/TClassTable_8cxx_source.html:41260,Security,hash,hash,41260,"orIdMap_t::const_iterator const_iteratorDefinition TClass.cxx:372; ROOT::TMapTypeToTClass::key_typeIdMap_t::key_type key_typeDefinition TClass.cxx:371; TClassTable::NormalizeThenLockDefinition TClassTable.cxx:70; TClassTable::NormalizeThenLock::GetNormalizedNameconst std::string & GetNormalizedName() constDefinition TClassTable.cxx:98; TClassTable::NormalizeThenLock::fNormalizedNamestd::string fNormalizedNameDefinition TClassTable.cxx:71; TClassTable::NormalizeThenLock::NormalizeThenLockNormalizeThenLock(const NormalizeThenLock &)=delete; TClassTable::NormalizeThenLock::~NormalizeThenLock~NormalizeThenLock()Definition TClassTable.cxx:94; TClassTable::NormalizeThenLock::NormalizeThenLockNormalizeThenLock(const char *cname)Definition TClassTable.cxx:80; TClassTable::NormalizeThenLock::NormalizeThenLockNormalizeThenLock(NormalizeThenLock &&)=delete; TClassTable::NormalizeThenLock::NormalizeThenLockNormalizeThenLock()=delete; TClassTable::NormalizeThenLock::operator=NormalizeThenLock & operator=(const NormalizeThenLock &)=delete; TClassTable::NormalizeThenLock::operator=NormalizeThenLock & operator=(NormalizeThenLock &&)=delete; TClassTableThis class registers for all classes their name, id and dictionary function in a hash table.Definition TClassTable.h:37; TClassTable::PrintTablestatic void PrintTable()Print the class table.Definition TClassTable.cxx:823; TClassTable::GetPragmaBitsstatic Int_t GetPragmaBits(const char *name)Returns the pragma bits as specified in the LinkDef.h file.Definition TClassTable.cxx:660; TClassTable::GetDictstatic DictFuncPtr_t GetDict(const char *cname)Given the class name returns the Dictionary() function of a class (uses hash of name).Definition TClassTable.cxx:674; TClassTable::GetIDstatic Version_t GetID(const char *cname)Returns the ID of a class.Definition TClassTable.cxx:647; TClassTable::IdMap_tROOT::TMapTypeToClassRec IdMap_tDefinition TClassTable.h:43; TClassTable::SortTablestatic void SortTable()Sort the class table by ascending c",MatchSource.WIKI,doc/v632/TClassTable_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/TClassTable_8cxx_source.html
https://root.cern/doc/v632/TClassTable_8cxx_source.html:41701,Security,hash,hash,41701,"Lock()Definition TClassTable.cxx:94; TClassTable::NormalizeThenLock::NormalizeThenLockNormalizeThenLock(const char *cname)Definition TClassTable.cxx:80; TClassTable::NormalizeThenLock::NormalizeThenLockNormalizeThenLock(NormalizeThenLock &&)=delete; TClassTable::NormalizeThenLock::NormalizeThenLockNormalizeThenLock()=delete; TClassTable::NormalizeThenLock::operator=NormalizeThenLock & operator=(const NormalizeThenLock &)=delete; TClassTable::NormalizeThenLock::operator=NormalizeThenLock & operator=(NormalizeThenLock &&)=delete; TClassTableThis class registers for all classes their name, id and dictionary function in a hash table.Definition TClassTable.h:37; TClassTable::PrintTablestatic void PrintTable()Print the class table.Definition TClassTable.cxx:823; TClassTable::GetPragmaBitsstatic Int_t GetPragmaBits(const char *name)Returns the pragma bits as specified in the LinkDef.h file.Definition TClassTable.cxx:660; TClassTable::GetDictstatic DictFuncPtr_t GetDict(const char *cname)Given the class name returns the Dictionary() function of a class (uses hash of name).Definition TClassTable.cxx:674; TClassTable::GetIDstatic Version_t GetID(const char *cname)Returns the ID of a class.Definition TClassTable.cxx:647; TClassTable::IdMap_tROOT::TMapTypeToClassRec IdMap_tDefinition TClassTable.h:43; TClassTable::SortTablestatic void SortTable()Sort the class table by ascending class ID's.Definition TClassTable.cxx:857; TClassTable::GetProtoNormstatic TProtoClass * GetProtoNorm(const char *cname)Given the class normalized name returns the TClassProto object for the class.Definition TClassTable.cxx:770; TClassTable::GetDictNormstatic DictFuncPtr_t GetDictNorm(const char *cname)Given the normalized class name returns the Dictionary() function of a class (uses hash of name).Definition TClassTable.cxx:717; TClassTable::fgAlternatestatic ROOT::TClassAlt ** fgAlternateDefinition TClassTable.h:46; TClassTable::Printvoid Print(Option_t *option="""") const overridePrint the class table.D",MatchSource.WIKI,doc/v632/TClassTable_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/TClassTable_8cxx_source.html
https://root.cern/doc/v632/TClassTable_8cxx_source.html:42411,Security,hash,hash,42411," PrintTable()Print the class table.Definition TClassTable.cxx:823; TClassTable::GetPragmaBitsstatic Int_t GetPragmaBits(const char *name)Returns the pragma bits as specified in the LinkDef.h file.Definition TClassTable.cxx:660; TClassTable::GetDictstatic DictFuncPtr_t GetDict(const char *cname)Given the class name returns the Dictionary() function of a class (uses hash of name).Definition TClassTable.cxx:674; TClassTable::GetIDstatic Version_t GetID(const char *cname)Returns the ID of a class.Definition TClassTable.cxx:647; TClassTable::IdMap_tROOT::TMapTypeToClassRec IdMap_tDefinition TClassTable.h:43; TClassTable::SortTablestatic void SortTable()Sort the class table by ascending class ID's.Definition TClassTable.cxx:857; TClassTable::GetProtoNormstatic TProtoClass * GetProtoNorm(const char *cname)Given the class normalized name returns the TClassProto object for the class.Definition TClassTable.cxx:770; TClassTable::GetDictNormstatic DictFuncPtr_t GetDictNorm(const char *cname)Given the normalized class name returns the Dictionary() function of a class (uses hash of name).Definition TClassTable.cxx:717; TClassTable::fgAlternatestatic ROOT::TClassAlt ** fgAlternateDefinition TClassTable.h:46; TClassTable::Printvoid Print(Option_t *option="""") const overridePrint the class table.Definition TClassTable.cxx:328; TClassTable::Terminatestatic void Terminate()Deletes the class table (this static class function calls the dtor).Definition TClassTable.cxx:878; TClassTable::GetProtostatic TProtoClass * GetProto(const char *cname)Given the class name returns the TClassProto object for the class.Definition TClassTable.cxx:742; TClassTable::fgTallystatic std::atomic< UInt_t > fgTallyDefinition TClassTable.h:51; TClassTable::TClassTableTClassTable()TClassTable is a singleton (i.e. only one can exist per application).Definition TClassTable.cxx:264; TClassTable::Nextstatic char * Next()Returns next class from sorted class table.Definition TClassTable.cxx:807; TClassTable::Atstatic c",MatchSource.WIKI,doc/v632/TClassTable_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/TClassTable_8cxx_source.html
https://root.cern/doc/v632/TClassTable_8cxx_source.html:44707,Security,hash,hash,44707," void Remove(const char *cname)Remove a class from the class table.Definition TClassTable.cxx:591; TClassTable::fgSortedTablestatic ROOT::TClassRec ** fgSortedTableDefinition TClassTable.h:48; TClassTable::fgTablestatic ROOT::TClassRec ** fgTableDefinition TClassTable.h:47; TClassTable::fgIdMapstatic IdMap_t * fgIdMapDefinition TClassTable.h:49; TClassTable::CheckClassTableInitstatic Bool_t CheckClassTableInit()Return true fs the table exist.Definition TClassTable.cxx:308; TClassTable::Addstatic void Add(const char *cname, Version_t id, const std::type_info &info, DictFuncPtr_t dict, Int_t pragmabits)Add a class to the class table (this is a static function).Definition TClassTable.cxx:398; TClassTable::~TClassTable~TClassTable()TClassTable singleton is deleted in Terminate().Definition TClassTable.cxx:290; TClassTable::RemoveAlternatestatic void RemoveAlternate(ROOT::TClassAlt *alt)Definition TClassTable.cxx:535; TClassTable::FindElementstatic ROOT::TClassRec * FindElement(const char *cname, Bool_t insert)Find a class by name in the class table (using hash of name).Definition TClassTable.cxx:625; TClassTable::fgSortedstatic Bool_t fgSortedDefinition TClassTable.h:52; TClassTable::fgSizestatic UInt_t fgSizeDefinition TClassTable.h:50; TClassTable::Classesint Classes()Definition TClassTable.cxx:388; TClassTable::AddAlternatestatic ROOT::TClassAlt * AddAlternate(const char *normname, const char *alternate)Definition TClassTable.cxx:507; TClassTable::fgCursorstatic UInt_t fgCursorDefinition TClassTable.h:53; TClassTClass instances represent classes, structs and namespaces in the ROOT type system.Definition TClass.h:81; TClass::GetStateEState GetState() constDefinition TClass.h:488; TClass::fClassVersionVersion_t fClassVersionDefinition TClass.h:221; TClass::SetUnloadedvoid SetUnloaded()Call this method to indicate that the shared library containing this class's code has been removed (u...Definition TClass.cxx:6309; TClass::SetClassVersionvoid SetClassVersion(Version_t v",MatchSource.WIKI,doc/v632/TClassTable_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/TClassTable_8cxx_source.html
https://root.cern/doc/v632/TClassTable_8cxx_source.html:46183,Security,access,access,46183,"Definition TClassTable.h:53; TClassTClass instances represent classes, structs and namespaces in the ROOT type system.Definition TClass.h:81; TClass::GetStateEState GetState() constDefinition TClass.h:488; TClass::fClassVersionVersion_t fClassVersionDefinition TClass.h:221; TClass::SetUnloadedvoid SetUnloaded()Call this method to indicate that the shared library containing this class's code has been removed (u...Definition TClass.cxx:6309; TClass::SetClassVersionvoid SetClassVersion(Version_t version)Private function.Definition TClass.cxx:5675; TClass::fVersionUsedstd::atomic< Bool_t > fVersionUsedsaved remember if fOffsetStreamer has been set.Definition TClass.h:262; TClass::kHasTClassInit@ kHasTClassInitDefinition TClass.h:127; TClass::GetClassstatic TClass * GetClass(const char *name, Bool_t load=kTRUE, Bool_t silent=kFALSE)Static method returning pointer to TClass of the specified class name.Definition TClass.cxx:2968; TCollection::UseRWLockvirtual bool UseRWLock(Bool_t enable=true)Set this collection to use a RW lock upon access, making it thread safe.Definition TCollection.cxx:761; TCollection::SetOwnervirtual void SetOwner(Bool_t enable=kTRUE)Set whether this collection is the owner (enable==true) of its content.Definition TCollection.cxx:746; TInterpreter::RegisterTClassUpdatevirtual void RegisterTClassUpdate(TClass *oldcl, DictFuncPtr_t dict)=0; TIterDefinition TCollection.h:235; TListA doubly linked list.Definition TList.h:38; TList::FindObjectTObject * FindObject(const char *name) const overrideFind an object in this list using its name.Definition TList.cxx:576; TList::Addvoid Add(TObject *obj) overrideDefinition TList.h:83; TMapTMap implements an associative array of (key,value) pairs using a THashTable for efficient retrieval ...Definition TMap.h:40; TNamedThe TNamed class is the base class for all named ROOT classes.Definition TNamed.h:29; TNamed::GetNameconst char * GetName() const overrideReturns name of object.Definition TNamed.h:47; TObjStringColle",MatchSource.WIKI,doc/v632/TClassTable_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/TClassTable_8cxx_source.html
https://root.cern/doc/v632/TClassTable_8cxx_source.html:18428,Testability,assert,assert,18428,"me) != 0) {; 521 fprintf(stderr,""Error in TClassTable::AddAlternate: ""; 522 ""Second registration of %s with a different normalized name (old: '%s', new: '%s')\n"",; 523 alternate, a->fNormName, normName);; 524 }; 525 return nullptr;; 526 }; 527 }; 528 ; 529 fgAlternate[slot] = new TClassAlt(alternate,normName,fgAlternate[slot]);; 530 return fgAlternate[slot];; 531}; 532 ; 533////////////////////////////////////////////////////////////////////////////////; 534///; 535void TClassTable::RemoveAlternate(ROOT::TClassAlt *alt); 536{; 537 if (!alt || !gClassTable); 538 return;; 539 ; 540 std::lock_guard<std::mutex> lock(GetClassTableMutex());; 541 ; 542 UInt_t slot = ROOT::ClassTableHash(alt->fName, fgSize);; 543 ; 544 if (!fgAlternate[slot]); 545 return;; 546 ; 547 if (fgAlternate[slot] == alt); 548 fgAlternate[slot] = alt->fNext.release();; 549 else {; 550 for (TClassAlt *a = fgAlternate[slot]; a; a = a->fNext.get()) {; 551 if (a->fNext.get() == alt) {; 552 a->fNext.swap( alt->fNext );; 553 assert( alt == alt->fNext.get());; 554 alt->fNext.release();; 555 }; 556 }; 557 }; 558 delete alt;; 559}; 560 ; 561////////////////////////////////////////////////////////////////////////////////; 562 ; 563Bool_t TClassTable::Check(const char *cname, std::string &normname); 564{; 565 if (!CheckClassTableInit()); 566 return kFALSE;; 567 ; 568 std::lock_guard<std::mutex> lock(GetClassTableMutex());; 569 ; 570 UInt_t slot = ROOT::ClassTableHash(cname, fgSize);; 571 ; 572 // Check if 'cname' is a known normalized name.; 573 for (TClassRec *r = fgTable[slot]; r; r = r->fNext); 574 if (strcmp(cname,r->fName)==0) return kTRUE;; 575 ; 576 // See if 'cname' is register in the list of alternate names; 577 for (const TClassAlt *a = fgAlternate[slot]; a; a = a->fNext.get()) {; 578 if (strcmp(cname,a->fName)==0) {; 579 normname = a->fNormName;; 580 return kTRUE;; 581 }; 582 }; 583 ; 584 return kFALSE;; 585}; 586 ; 587////////////////////////////////////////////////////////////////////////////////; 5",MatchSource.WIKI,doc/v632/TClassTable_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/TClassTable_8cxx_source.html
https://root.cern/doc/v632/TClassTable_8cxx_source.html:8255,Usability,clear,clear,8255,"3 ; 254 std::vector<std::pair<const char *, const char *>> &GetDelayedAddClassAlternate(); 255 {; 256 static std::vector<std::pair<const char *, const char *>> delayedAddClassAlternate;; 257 return delayedAddClassAlternate;; 258 }; 259}; 260 ; 261////////////////////////////////////////////////////////////////////////////////; 262/// TClassTable is a singleton (i.e. only one can exist per application).; 263 ; 264TClassTable::TClassTable(); 265{; 266 if (gClassTable) return;; 267 ; 268 fgSize = 1009; //this is the result of (int)TMath::NextPrime(1000);; 269 fgTable = new TClassRec* [fgSize];; 270 fgAlternate = new TClassAlt* [fgSize];; 271 fgIdMap = new IdMap_t;; 272 memset(fgTable, 0, fgSize * sizeof(TClassRec*));; 273 memset(fgAlternate, 0, fgSize * sizeof(TClassAlt*));; 274 gClassTable = this;; 275 ; 276 for (auto &&r : GetDelayedAddClass()) {; 277 AddClass(r->fName, r->fId, *r->fInfo, r->fDict, r->fBits);; 278 };; 279 GetDelayedAddClass().clear();; 280 ; 281 for (auto &&r : GetDelayedAddClassAlternate()) {; 282 AddAlternate(r.first, r.second);; 283 }; 284 GetDelayedAddClassAlternate().clear();; 285}; 286 ; 287////////////////////////////////////////////////////////////////////////////////; 288/// TClassTable singleton is deleted in Terminate().; 289 ; 290TClassTable::~TClassTable(); 291{; 292 // Try to avoid spurious warning from memory leak checkers.; 293 if (gClassTable != this) return;; 294 ; 295 for (UInt_t i = 0; i < fgSize; i++) {; 296 delete fgTable[i]; // Will delete all the elements in the chain.; 297 }; 298 delete [] fgTable; fgTable = nullptr;; 299 delete [] fgSortedTable; fgSortedTable = nullptr;; 300 delete fgIdMap; fgIdMap = nullptr;; 301}; 302 ; 303////////////////////////////////////////////////////////////////////////////////; 304/// Return true fs the table exist.; 305/// If the table does not exist but the delayed list does, then; 306/// create the table and return true.; 307 ; 308inline Bool_t TClassTable::CheckClassTableInit(); 309{; 310 // Th",MatchSource.WIKI,doc/v632/TClassTable_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/TClassTable_8cxx_source.html
https://root.cern/doc/v632/TClassTable_8cxx_source.html:8404,Usability,clear,clear,8404," 257 return delayedAddClassAlternate;; 258 }; 259}; 260 ; 261////////////////////////////////////////////////////////////////////////////////; 262/// TClassTable is a singleton (i.e. only one can exist per application).; 263 ; 264TClassTable::TClassTable(); 265{; 266 if (gClassTable) return;; 267 ; 268 fgSize = 1009; //this is the result of (int)TMath::NextPrime(1000);; 269 fgTable = new TClassRec* [fgSize];; 270 fgAlternate = new TClassAlt* [fgSize];; 271 fgIdMap = new IdMap_t;; 272 memset(fgTable, 0, fgSize * sizeof(TClassRec*));; 273 memset(fgAlternate, 0, fgSize * sizeof(TClassAlt*));; 274 gClassTable = this;; 275 ; 276 for (auto &&r : GetDelayedAddClass()) {; 277 AddClass(r->fName, r->fId, *r->fInfo, r->fDict, r->fBits);; 278 };; 279 GetDelayedAddClass().clear();; 280 ; 281 for (auto &&r : GetDelayedAddClassAlternate()) {; 282 AddAlternate(r.first, r.second);; 283 }; 284 GetDelayedAddClassAlternate().clear();; 285}; 286 ; 287////////////////////////////////////////////////////////////////////////////////; 288/// TClassTable singleton is deleted in Terminate().; 289 ; 290TClassTable::~TClassTable(); 291{; 292 // Try to avoid spurious warning from memory leak checkers.; 293 if (gClassTable != this) return;; 294 ; 295 for (UInt_t i = 0; i < fgSize; i++) {; 296 delete fgTable[i]; // Will delete all the elements in the chain.; 297 }; 298 delete [] fgTable; fgTable = nullptr;; 299 delete [] fgSortedTable; fgSortedTable = nullptr;; 300 delete fgIdMap; fgIdMap = nullptr;; 301}; 302 ; 303////////////////////////////////////////////////////////////////////////////////; 304/// Return true fs the table exist.; 305/// If the table does not exist but the delayed list does, then; 306/// create the table and return true.; 307 ; 308inline Bool_t TClassTable::CheckClassTableInit(); 309{; 310 // This will be set at the lastest during TROOT construction, so before; 311 // any threading could happen.; 312 if (!gClassTable || !fgTable) {; 313 if (GetDelayedAddClass().size()) {; 314 ",MatchSource.WIKI,doc/v632/TClassTable_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/TClassTable_8cxx_source.html
https://root.cern/doc/v632/TClass_8cxx_source.html:40631,Availability,avail,available,40631,"lptr), fClassMenuList(nullptr),; 1109 fDeclFileName(""""), fImplFileName(""""), fDeclFileLine(0), fImplFileLine(0),; 1110 fInstanceCount(0), fOnHeap(0),; 1111 fCheckSum(0), fCollectionProxy(nullptr), fClassVersion(0), fClassInfo(nullptr),; 1112 fTypeInfo(nullptr), fShowMembers(nullptr),; 1113 fStreamer(nullptr), fIsA(nullptr), fGlobalIsA(nullptr), fIsAMethod(nullptr),; 1114 fMerge(nullptr), fResetAfterMerge(nullptr), fNew(nullptr), fNewArray(nullptr), fDelete(nullptr), fDeleteArray(nullptr),; 1115 fDestructor(nullptr), fDirAutoAdd(nullptr), fStreamerFunc(nullptr), fConvStreamerFunc(nullptr), fSizeof(-1),; 1116 fCanSplit(-1), fIsSyntheticPair(kFALSE), fHasCustomStreamerMember(kFALSE), fProperty(0), fClassProperty(0), fHasRootPcmInfo(kFALSE), fCanLoadClassInfo(kFALSE),; 1117 fIsOffsetStreamerSet(kFALSE), fVersionUsed(kFALSE), fRuntimeProperties(0), fOffsetStreamer(0), fStreamerType(TClass::kDefault),; 1118 fState(kNoInfo),; 1119 fCurrentInfo(nullptr), fLastReadInfo(nullptr), fRefProxy(nullptr),; 1120 fSchemaRules(nullptr), fStreamerImpl(&TClass::StreamerDefault); 1121{; 1122 R__LOCKGUARD(gInterpreterMutex);; 1123 ; 1124 if (!gROOT); 1125 ::Fatal(""TClass::TClass"", ""ROOT system not initialized"");; 1126 ; 1127 {; 1128 TMmallocDescTemp setreset;; 1129 fStreamerInfo = new TObjArray(1, -2);; 1130 }; 1131 fDeclFileLine = -2; // -2 for standalone TClass (checked in dtor); 1132 ; 1133 SetBit(kLoading);; 1134 if (!gInterpreter); 1135 ::Fatal(""TClass::TClass"", ""gInterpreter not initialized"");; 1136 ; 1137 gInterpreter->SetClassInfo(this); // sets fClassInfo pointer; 1138 if (!silent && !fClassInfo && !TClassEdit::IsArtificial(name)); 1139 ::Warning(""TClass::TClass"", ""no dictionary for class %s is available"", name);; 1140 ResetBit(kLoading);; 1141 ; 1142 if (fClassInfo) SetTitle(gCling->ClassInfo_Title(fClassInfo));; 1143 fConversionStreamerInfo = nullptr;; 1144}; 1145 ; 1146////////////////////////////////////////////////////////////////////////////////; 1147/// Internal constructor.",MatchSource.WIKI,doc/v632/TClass_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/TClass_8cxx_source.html
https://root.cern/doc/v632/TClass_8cxx_source.html:59677,Availability,avail,available,59677,"7 gInterpreter->SetClassInfo(this, kFALSE, silent); // sets fClassInfo pointer; 1518 if (fClassInfo) {; 1519 // This should be moved out of GetCheckSum itself however the last time; 1520 // we tried this cause problem, in particular in the end-of-process operation.; 1521 // fCheckSum = GetCheckSum(kLatestCheckSum);; 1522 } else {; 1523 if (!fClassInfo) {; 1524 if (IsZombie()) {; 1525 TClass::RemoveClass(this);; 1526 return;; 1527 }; 1528 }; 1529 }; 1530 }; 1531 }; 1532 if (!silent && (!fClassInfo && !fCanLoadClassInfo) && !isStl && !TClassEdit::IsArtificial(fName) &&; 1533 !TClassEdit::IsInterpreterDetail(fName.Data()) ) {; 1534 if (fState == kHasTClassInit) {; 1535 if (fImplFileLine == -1 && fClassVersion == 0) {; 1536 // We have a 'transient' class with a ClassDefInline and apparently no interpreter; 1537 // information. Since it is transient, it is more than likely that the lack; 1538 // will be harmles.; 1539 } else {; 1540 ::Error(""TClass::Init"", ""no interpreter information for class %s is available even though it has a TClass ""; 1541 ""initialization routine."",; 1542 fName.Data());; 1543 }; 1544 } else {; 1545 const bool ispairbase = TClassEdit::IsStdPairBase(fName.Data()) && !IsFromRootCling();; 1546 if (!ispairbase); 1547 ::Warning(""TClass::Init"", ""no dictionary for class %s is available"", fName.Data());; 1548 }; 1549 }; 1550 ; 1551 fgClassCount++;; 1552 SetUniqueID(fgClassCount);; 1553 ; 1554 // Make the typedef-expanded -> original hash table entries.; 1555 // There may be several entries for any given key.; 1556 // We only make entries if the typedef-expanded name; 1557 // is different from the original name.; 1558 TString resolvedThis;; 1559 if (!givenInfo && strchr (name, '<')) {; 1560 if ( fName != name) {; 1561 if (!fgClassTypedefHash) {; 1562 fgClassTypedefHash = new THashTable (100, 5);; 1563 fgClassTypedefHash->SetOwner (kTRUE);; 1564 }; 1565 ; 1566 fgClassTypedefHash->Add (new TNameMapNode (name, fName));; 1567 SetBit (kHasNameMapNode);; 1568 ; 156",MatchSource.WIKI,doc/v632/TClass_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/TClass_8cxx_source.html
https://root.cern/doc/v632/TClass_8cxx_source.html:59973,Availability,avail,available,59973,"peration.; 1521 // fCheckSum = GetCheckSum(kLatestCheckSum);; 1522 } else {; 1523 if (!fClassInfo) {; 1524 if (IsZombie()) {; 1525 TClass::RemoveClass(this);; 1526 return;; 1527 }; 1528 }; 1529 }; 1530 }; 1531 }; 1532 if (!silent && (!fClassInfo && !fCanLoadClassInfo) && !isStl && !TClassEdit::IsArtificial(fName) &&; 1533 !TClassEdit::IsInterpreterDetail(fName.Data()) ) {; 1534 if (fState == kHasTClassInit) {; 1535 if (fImplFileLine == -1 && fClassVersion == 0) {; 1536 // We have a 'transient' class with a ClassDefInline and apparently no interpreter; 1537 // information. Since it is transient, it is more than likely that the lack; 1538 // will be harmles.; 1539 } else {; 1540 ::Error(""TClass::Init"", ""no interpreter information for class %s is available even though it has a TClass ""; 1541 ""initialization routine."",; 1542 fName.Data());; 1543 }; 1544 } else {; 1545 const bool ispairbase = TClassEdit::IsStdPairBase(fName.Data()) && !IsFromRootCling();; 1546 if (!ispairbase); 1547 ::Warning(""TClass::Init"", ""no dictionary for class %s is available"", fName.Data());; 1548 }; 1549 }; 1550 ; 1551 fgClassCount++;; 1552 SetUniqueID(fgClassCount);; 1553 ; 1554 // Make the typedef-expanded -> original hash table entries.; 1555 // There may be several entries for any given key.; 1556 // We only make entries if the typedef-expanded name; 1557 // is different from the original name.; 1558 TString resolvedThis;; 1559 if (!givenInfo && strchr (name, '<')) {; 1560 if ( fName != name) {; 1561 if (!fgClassTypedefHash) {; 1562 fgClassTypedefHash = new THashTable (100, 5);; 1563 fgClassTypedefHash->SetOwner (kTRUE);; 1564 }; 1565 ; 1566 fgClassTypedefHash->Add (new TNameMapNode (name, fName));; 1567 SetBit (kHasNameMapNode);; 1568 ; 1569 }; 1570 resolvedThis = TClassEdit::ResolveTypedef (name, kTRUE);; 1571 if (resolvedThis != name) {; 1572 if (!fgClassTypedefHash) {; 1573 fgClassTypedefHash = new THashTable (100, 5);; 1574 fgClassTypedefHash->SetOwner (kTRUE);; 1575 }; 1576 ; 1577 fgClas",MatchSource.WIKI,doc/v632/TClass_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/TClass_8cxx_source.html
https://root.cern/doc/v632/TClass_8cxx_source.html:67078,Availability,error,error,67078,"sMenuList; fClassMenuList=nullptr;; 1727 ; 1728 fIsOffsetStreamerSet=kFALSE;; 1729 ; 1730 if ( fIsA ) delete fIsA;; 1731 ; 1732 if ( fRefProxy ) fRefProxy->Release();; 1733 fRefProxy = nullptr;; 1734 ; 1735 delete fStreamer;; 1736 delete fCollectionProxy;; 1737 delete fIsAMethod.load();; 1738 delete fSchemaRules;; 1739 if (fConversionStreamerInfo.load()) {; 1740 std::map<std::string, TObjArray*>::iterator it;; 1741 std::map<std::string, TObjArray*>::iterator end = (*fConversionStreamerInfo).end();; 1742 for( it = (*fConversionStreamerInfo).begin(); it != end; ++it ) {; 1743 delete it->second;; 1744 }; 1745 delete fConversionStreamerInfo.load();; 1746 }; 1747}; 1748 ; 1749////////////////////////////////////////////////////////////////////////////////; 1750 ; 1751namespace {; 1752 Int_t ReadRulesContent(FILE *f); 1753 {; 1754 // Read a class.rules file which contains one rule per line with comment; 1755 // starting with a #; 1756 // Returns the number of rules loaded.; 1757 // Returns -1 in case of error.; 1758 ; 1759 R__ASSERT(f!=nullptr);; 1760 TString rule(1024);; 1761 int c, state = 0;; 1762 Int_t count = 0;; 1763 ; 1764 while ((c = fgetc(f)) != EOF) {; 1765 if (c == 13) // ignore CR; 1766 continue;; 1767 if (c == '\n') {; 1768 if (state != 3) {; 1769 state = 0;; 1770 if (rule.Length() > 0) {; 1771 if (TClass::AddRule(rule)) {; 1772 ++count;; 1773 }; 1774 rule.Clear();; 1775 }; 1776 }; 1777 continue;; 1778 }; 1779 switch (state) {; 1780 case 0: // start of line; 1781 switch (c) {; 1782 case ' ':; 1783 case '\t':; 1784 break;; 1785 case '#':; 1786 state = 1;; 1787 break;; 1788 default:; 1789 state = 2;; 1790 break;; 1791 }; 1792 break;; 1793 ; 1794 case 1: // comment; 1795 break;; 1796 ; 1797 case 2: // rule; 1798 switch (c) {; 1799 case '\\':; 1800 state = 3; // Continuation request; 1801 default:; 1802 break;; 1803 }; 1804 break;; 1805 }; 1806 switch (state) {; 1807 case 2:; 1808 rule.Append(c);; 1809 break;; 1810 }; 1811 }; 1812 return count;; 1813 }; 1814}; 18",MatchSource.WIKI,doc/v632/TClass_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/TClass_8cxx_source.html
https://root.cern/doc/v632/TClass_8cxx_source.html:69019,Availability,error,error,69019,"reak;; 1810 }; 1811 }; 1812 return count;; 1813 }; 1814}; 1815 ; 1816////////////////////////////////////////////////////////////////////////////////; 1817/// Read the class.rules files from the default location:.; 1818/// $ROOTSYS/etc/class.rules (or ROOTETCDIR/class.rules); 1819 ; 1820Int_t TClass::ReadRules(); 1821{; 1822 static const char *suffix = ""class.rules"";; 1823 TString sname = suffix;; 1824 gSystem->PrependPathName(TROOT::GetEtcDir(), sname);; 1825 ; 1826 Int_t res = -1;; 1827 ; 1828 FILE * f = fopen(sname,""r"");; 1829 if (f != nullptr) {; 1830 res = ReadRulesContent(f);; 1831 fclose(f);; 1832 } else {; 1833 ::Error(""TClass::ReadRules()"", ""Cannot find rules file %s"", sname.Data());; 1834 }; 1835 return res;; 1836}; 1837 ; 1838////////////////////////////////////////////////////////////////////////////////; 1839/// Read a class.rules file which contains one rule per line with comment; 1840/// starting with a #; 1841/// - Returns the number of rules loaded.; 1842/// - Returns -1 in case of error.; 1843 ; 1844Int_t TClass::ReadRules( const char *filename ); 1845{; 1846 if (!filename || !filename[0]) {; 1847 ::Error(""TClass::ReadRules"", ""no file name specified"");; 1848 return -1;; 1849 }; 1850 ; 1851 FILE * f = fopen(filename,""r"");; 1852 if (f == nullptr) {; 1853 ::Error(""TClass::ReadRules"",""Failed to open %s\n"",filename);; 1854 return -1;; 1855 }; 1856 Int_t count = ReadRulesContent(f);; 1857 ; 1858 fclose(f);; 1859 return count;; 1860 ; 1861}; 1862 ; 1863////////////////////////////////////////////////////////////////////////////////; 1864/// Add a schema evolution customization rule.; 1865/// The syntax of the rule can be either the short form:; 1866/// ~~~ {.cpp}; 1867/// [type=Read] classname membername [attributes=... ] [version=[...] ] [checksum=[...] ] [oldtype=...] [code={...}]; 1868/// ~~~; 1869/// or the long form; 1870/// ~~~ {.cpp}; 1871/// [type=Read] sourceClass=classname [targetclass=newClassname] [ source=""type membername; [type2 membername2]",MatchSource.WIKI,doc/v632/TClass_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/TClass_8cxx_source.html
https://root.cern/doc/v632/TClass_8cxx_source.html:78394,Availability,error,error,78394,"ild .first, .second just fine; 2065 // and those for which the user explicitly requested a dictionary.; 2066 if (!isTransient && GetState() != kHasTClassInit; 2067 && TClassEdit::IsStdClass(GetName()); 2068 && !TClassEdit::IsStdPair(GetName())) {; 2069 Error(""BuildRealData"", ""Inspection for %s not supported!"", GetName());; 2070 }; 2071 ; 2072 // The following statement will recursively call; 2073 // all the subclasses of this class.; 2074 fRealData = new TList;; 2075 TBuildRealData brd(pointer, this);; 2076 ; 2077 // CallShowMember will force a call to InheritsFrom, which indirectly; 2078 // calls TClass::GetClass. It forces the loading of new typedefs in; 2079 // case some of them were not yet loaded.; 2080 if ( ! CallShowMembers(pointer, brd, isTransient) ) {; 2081 if ( isTransient ) {; 2082 // This is a transient data member, so it is probably fine to not have; 2083 // access to its content. However let's no mark it as definitively setup,; 2084 // since another class might use this class for a persistent data member and; 2085 // in this case we really want the error message.; 2086 delete fRealData;; 2087 fRealData = nullptr;; 2088 } else {; 2089 Error(""BuildRealData"", ""Cannot find any ShowMembers function for %s!"", GetName());; 2090 }; 2091 }; 2092 ; 2093 // Take this opportunity to build the real data for base classes.; 2094 // In case one base class is abstract, it would not be possible later; 2095 // to create the list of real data for this abstract class.; 2096 TBaseClass* base = nullptr;; 2097 TIter next(GetListOfBases());; 2098 while ((base = (TBaseClass*) next())) {; 2099 if (base->IsSTLContainer()) {; 2100 continue;; 2101 }; 2102 TClass* c = base->GetClassPointer();; 2103 if (c) {; 2104 c->BuildRealData(nullptr, isTransient);; 2105 }; 2106 }; 2107}; 2108 ; 2109////////////////////////////////////////////////////////////////////////////////; 2110/// Build the list of real data for an emulated class; 2111 ; 2112void TClass::BuildEmulatedRealData(const char *",MatchSource.WIKI,doc/v632/TClass_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/TClass_8cxx_source.html
https://root.cern/doc/v632/TClass_8cxx_source.html:85658,Availability,avail,available,85658,"} else if (TVirtualStreamerInfo* sinfo = GetStreamerInfo()) {; 2229 sinfo->CallShowMembers(obj, insp, isTransient);; 2230 return kTRUE;; 2231 } // isATObject; 2232 } // fShowMembers is set; 2233 ; 2234 return kFALSE;; 2235}; 2236 ; 2237////////////////////////////////////////////////////////////////////////////////; 2238/// Do a ShowMembers() traversal of all members and base classes' members; 2239/// using the reflection information from the interpreter. Works also for; 2240/// interpreted objects.; 2241 ; 2242void TClass::InterpretedShowMembers(void* obj, TMemberInspector &insp, Bool_t isTransient); 2243{; 2244 return gInterpreter->InspectMembers(insp, obj, this, isTransient);; 2245}; 2246 ; 2247Bool_t TClass::CanSplitBaseAllow(); 2248{; 2249 if (fCanSplit >= 0) {; 2250 return ! ( fCanSplit & 0x2 );; 2251 }; 2252 ; 2253 R__LOCKGUARD(gInterpreterMutex);; 2254 ; 2255 if (GetCollectionProxy() != nullptr) {; 2256 // A collection can never affect its derived class 'splittability'; 2257 return kTRUE;; 2258 }; 2259 ; 2260 if (this == TRef::Class()) { fCanSplit = 2; return kFALSE; }; 2261 if (this == TRefArray::Class()) { fCanSplit = 2; return kFALSE; }; 2262 if (this == TArray::Class()) { fCanSplit = 2; return kFALSE; }; 2263 if (this == TClonesArray::Class()) { fCanSplit = 1; return kTRUE; }; 2264 if (this == TCollection::Class()) { fCanSplit = 2; return kFALSE; }; 2265 ; 2266 // TTree is not always available (for example in rootcling), so we need; 2267 // to grab it silently.; 2268 auto refTreeClass( TClass::GetClass(""TTree"",kTRUE,kTRUE) );; 2269 if (this == refTreeClass) { fCanSplit = 2; return kFALSE; }; 2270 ; 2271 if (!HasDataMemberInfo()) {; 2272 TVirtualStreamerInfo *sinfo = ((TClass *)this)->GetCurrentStreamerInfo();; 2273 if (sinfo==nullptr) sinfo = GetStreamerInfo();; 2274 TIter next(sinfo->GetElements());; 2275 TStreamerElement *element;; 2276 while ((element = (TStreamerElement*)next())) {; 2277 if (element->IsA() == TStreamerBase::Class()) {; 2278 TClass *cl",MatchSource.WIKI,doc/v632/TClass_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/TClass_8cxx_source.html
https://root.cern/doc/v632/TClass_8cxx_source.html:103615,Availability,avail,available,103615,"t;; 2733 offset += baseclass->Size();; 2734 } else if (element->IsA() == TStreamerSTL::Class()) {; 2735 TStreamerSTL *base = (TStreamerSTL*)element;; 2736 TClass *baseclass = base->GetClassPointer();; 2737 if (!baseclass) return -1;; 2738 Int_t subOffset = baseclass->GetBaseClassOffsetRecurse(cl);; 2739 if (subOffset == -2) return -2;; 2740 if (subOffset != -1) return offset+subOffset;; 2741 offset += baseclass->Size();; 2742 ; 2743 } else {; 2744 Error(""GetBaseClassOffsetRecurse"",""Unexpected element type for base class: %s\n"",element->IsA()->GetName());; 2745 }; 2746 }; 2747 }; 2748 return -1;; 2749 }; 2750 }; 2751 ; 2752 TClass *c;; 2753 Int_t off;; 2754 TBaseClass *inh;; 2755 TObjLink *lnk = nullptr;; 2756 if (fBase.load() == nullptr); 2757 lnk = GetListOfBases()->FirstLink();; 2758 else; 2759 lnk = fBase.load()->FirstLink();; 2760 ; 2761 // otherwise look at inheritance tree; 2762 while (lnk) {; 2763 inh = (TBaseClass *)lnk->GetObject();; 2764 //use option load=kFALSE to avoid a warning like:; 2765 //""Warning in <TClass::TClass>: no dictionary for class TRefCnt is available""; 2766 //We can not afford to not have the class if it exist, so we; 2767 //use kTRUE.; 2768 c = inh->GetClassPointer(kTRUE); // kFALSE);; 2769 if (c) {; 2770 if (cl == c) {; 2771 if ((inh->Property() & kIsVirtualBase) != 0); 2772 return -2;; 2773 return inh->GetDelta();; 2774 }; 2775 off = c->GetBaseClassOffsetRecurse(cl);; 2776 if (off == -2) return -2;; 2777 if (off != -1) {; 2778 return off + inh->GetDelta();; 2779 }; 2780 }; 2781 lnk = lnk->Next();; 2782 }; 2783 return -1;; 2784}; 2785 ; 2786////////////////////////////////////////////////////////////////////////////////; 2787/// - Return data member offset to the base class ""cl"".; 2788/// - Returns -1 in case ""cl"" is not a base class.; 2789/// Takes care of multiple inheritance.; 2790 ; 2791Int_t TClass::GetBaseClassOffset(const TClass *toBase, void *address, bool isDerivedObject); 2792{; 2793 // Warning(""GetBaseClassOffset"",""Requires th",MatchSource.WIKI,doc/v632/TClass_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/TClass_8cxx_source.html
https://root.cern/doc/v632/TClass_8cxx_source.html:112870,Availability,avail,available,112870,"e,""struct "",7)==0) name += 7;; 2981 ; 2982 if (!gROOT->GetListOfClasses()) return nullptr;; 2983 ; 2984 // FindObject will take the read lock before actually getting the; 2985 // TClass pointer so we will need not get a partially initialized; 2986 // object.; 2987 TClass *cl = (TClass*)gROOT->GetListOfClasses()->FindObject(name);; 2988 ; 2989 // Early return to release the lock without having to execute the; 2990 // long-ish normalization.; 2991 if (cl && (cl->IsLoaded() || cl->TestBit(kUnloading))) return cl;; 2992 ; 2993 R__WRITE_LOCKGUARD(ROOT::gCoreMutex);; 2994 ; 2995 // Now that we got the write lock, another thread may have constructed the; 2996 // TClass while we were waiting, so we need to do the checks again.; 2997 ; 2998 cl = (TClass*)gROOT->GetListOfClasses()->FindObject(name);; 2999 if (cl) {; 3000 if (cl->IsLoaded() || cl->TestBit(kUnloading)) return cl;; 3001 ; 3002 // We could speed-up some of the search by adding (the equivalent of); 3003 //; 3004 // if (cl->GetState() == kInterpreter) return cl; 3005 //; 3006 // In this case, if a ROOT dictionary was available when the TClass; 3007 // was first requested it would have been used and if a ROOT dictionary is; 3008 // loaded later on TClassTable::Add will take care of updating the TClass.; 3009 // So as far as ROOT dictionary are concerned, if the current TClass is; 3010 // in interpreted state, we are sure there is nothing to load.; 3011 //; 3012 // However (see TROOT::LoadClass), the TClass can also be loaded/provided; 3013 // by a user provided TClassGenerator. We have no way of knowing whether; 3014 // those do (or even can) behave the same way as the ROOT dictionary and; 3015 // have the 'dictionary is now available for use' step informs the existing; 3016 // TClass that their dictionary is now available.; 3017 ; 3018 //we may pass here in case of a dummy class created by TVirtualStreamerInfo; 3019 load = kTRUE;; 3020 }; 3021 ; 3022 if (TClassEdit::IsArtificial(name)) {; 3023 // If there is a @ sy",MatchSource.WIKI,doc/v632/TClass_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/TClass_8cxx_source.html
https://root.cern/doc/v632/TClass_8cxx_source.html:113489,Availability,avail,available,113489,"e were waiting, so we need to do the checks again.; 2997 ; 2998 cl = (TClass*)gROOT->GetListOfClasses()->FindObject(name);; 2999 if (cl) {; 3000 if (cl->IsLoaded() || cl->TestBit(kUnloading)) return cl;; 3001 ; 3002 // We could speed-up some of the search by adding (the equivalent of); 3003 //; 3004 // if (cl->GetState() == kInterpreter) return cl; 3005 //; 3006 // In this case, if a ROOT dictionary was available when the TClass; 3007 // was first requested it would have been used and if a ROOT dictionary is; 3008 // loaded later on TClassTable::Add will take care of updating the TClass.; 3009 // So as far as ROOT dictionary are concerned, if the current TClass is; 3010 // in interpreted state, we are sure there is nothing to load.; 3011 //; 3012 // However (see TROOT::LoadClass), the TClass can also be loaded/provided; 3013 // by a user provided TClassGenerator. We have no way of knowing whether; 3014 // those do (or even can) behave the same way as the ROOT dictionary and; 3015 // have the 'dictionary is now available for use' step informs the existing; 3016 // TClass that their dictionary is now available.; 3017 ; 3018 //we may pass here in case of a dummy class created by TVirtualStreamerInfo; 3019 load = kTRUE;; 3020 }; 3021 ; 3022 if (TClassEdit::IsArtificial(name)) {; 3023 // If there is a @ symbol (followed by a version number) then this is a synthetic class name created; 3024 // from an already normalized name for the purpose of supporting schema evolution.; 3025 // There is no dictionary or interpreter information about this kind of class, the only; 3026 // (undesirable) side-effect of doing the search would be a waste of CPU time and potential; 3027 // auto-loading or auto-parsing based on the scope of the name.; 3028 return cl;; 3029 }; 3030 ; 3031 // To avoid spurious auto parsing, let's check if the name as-is is; 3032 // known in the TClassTable.; 3033 DictFuncPtr_t dict = TClassTable::GetDictNorm(name);; 3034 if (dict) {; 3035 // The name is normalize",MatchSource.WIKI,doc/v632/TClass_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/TClass_8cxx_source.html
https://root.cern/doc/v632/TClass_8cxx_source.html:113579,Availability,avail,available,113579,"e were waiting, so we need to do the checks again.; 2997 ; 2998 cl = (TClass*)gROOT->GetListOfClasses()->FindObject(name);; 2999 if (cl) {; 3000 if (cl->IsLoaded() || cl->TestBit(kUnloading)) return cl;; 3001 ; 3002 // We could speed-up some of the search by adding (the equivalent of); 3003 //; 3004 // if (cl->GetState() == kInterpreter) return cl; 3005 //; 3006 // In this case, if a ROOT dictionary was available when the TClass; 3007 // was first requested it would have been used and if a ROOT dictionary is; 3008 // loaded later on TClassTable::Add will take care of updating the TClass.; 3009 // So as far as ROOT dictionary are concerned, if the current TClass is; 3010 // in interpreted state, we are sure there is nothing to load.; 3011 //; 3012 // However (see TROOT::LoadClass), the TClass can also be loaded/provided; 3013 // by a user provided TClassGenerator. We have no way of knowing whether; 3014 // those do (or even can) behave the same way as the ROOT dictionary and; 3015 // have the 'dictionary is now available for use' step informs the existing; 3016 // TClass that their dictionary is now available.; 3017 ; 3018 //we may pass here in case of a dummy class created by TVirtualStreamerInfo; 3019 load = kTRUE;; 3020 }; 3021 ; 3022 if (TClassEdit::IsArtificial(name)) {; 3023 // If there is a @ symbol (followed by a version number) then this is a synthetic class name created; 3024 // from an already normalized name for the purpose of supporting schema evolution.; 3025 // There is no dictionary or interpreter information about this kind of class, the only; 3026 // (undesirable) side-effect of doing the search would be a waste of CPU time and potential; 3027 // auto-loading or auto-parsing based on the scope of the name.; 3028 return cl;; 3029 }; 3030 ; 3031 // To avoid spurious auto parsing, let's check if the name as-is is; 3032 // known in the TClassTable.; 3033 DictFuncPtr_t dict = TClassTable::GetDictNorm(name);; 3034 if (dict) {; 3035 // The name is normalize",MatchSource.WIKI,doc/v632/TClass_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/TClass_8cxx_source.html
https://root.cern/doc/v632/TClass_8cxx_source.html:148292,Availability,avail,available,148292,"xt(GetListOfMethods(), kIterBackward);; 3889 while ((method = (TMethod*)next())) {; 3890 m = (TMethod*)list->FindObject(method->GetName());; 3891 if (method->IsMenuItem() != kMenuNoMenu) {; 3892 if (!m); 3893 list->AddFirst(method);; 3894 } else {; 3895 if (m && m->GetNargs() == method->GetNargs()); 3896 list->Remove(m);; 3897 }; 3898 }; 3899}; 3900 ; 3901////////////////////////////////////////////////////////////////////////////////; 3902/// Check whether a class has a dictionary or not.; 3903/// This is equivalent to ask if a class is coming from a bootstrapping; 3904/// procedure initiated during the loading of a library.; 3905 ; 3906Bool_t TClass::HasDictionary() const; 3907{; 3908 return IsLoaded();; 3909}; 3910 ; 3911////////////////////////////////////////////////////////////////////////////////; 3912/// Check whether a class has a dictionary or ROOT can load one.; 3913/// This is equivalent to ask HasDictionary() or whether a library is known; 3914/// where it can be loaded from, or whether a Dictionary function is; 3915/// available because the class's dictionary library was already loaded.; 3916 ; 3917Bool_t TClass::HasDictionarySelection(const char* clname); 3918{; 3919 if (TClass* cl = (TClass*)gROOT->GetListOfClasses()->FindObject(clname)); 3920 return cl->IsLoaded();; 3921 return gClassTable->GetDict(clname) || gInterpreter->GetClassSharedLibs(clname);; 3922}; 3923 ; 3924////////////////////////////////////////////////////////////////////////////////; 3925/// Verify the base classes always.; 3926 ; 3927void TClass::GetMissingDictionariesForBaseClasses(TCollection& result, TCollection& visited, bool recurse); 3928{; 3929 TList* lb = GetListOfBases();; 3930 if (!lb) return;; 3931 TIter nextBase(lb);; 3932 TBaseClass* base = nullptr;; 3933 while ((base = (TBaseClass*)nextBase())) {; 3934 TClass* baseCl = base->GetClassPointer();; 3935 if (baseCl) {; 3936 baseCl->GetMissingDictionariesWithRecursionCheck(result, visited, recurse);; 3937 }; 3938 }; 3939}; 39",MatchSource.WIKI,doc/v632/TClass_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/TClass_8cxx_source.html
https://root.cern/doc/v632/TClass_8cxx_source.html:179899,Availability,avail,available,179899,"UARD(gInterpreterMutex);; 4717 ; 4718 TClass *emulated = TClass::GetClass(newname);; 4719 ; 4720 if (emulated); 4721 sinfo = emulated->GetStreamerInfo(version);; 4722 ; 4723 if (!sinfo) {; 4724 // The emulated version of the streamerInfo is explicitly requested and has; 4725 // not been built yet.; 4726 ; 4727 sinfo = (TVirtualStreamerInfo*) fStreamerInfo->At(version);; 4728 ; 4729 if (!sinfo && (version != fClassVersion)) {; 4730 // When the requested version does not exist we return; 4731 // the TVirtualStreamerInfo for the currently loaded class version.; 4732 // FIXME: This arguably makes no sense, we should warn and return nothing instead.; 4733 sinfo = (TVirtualStreamerInfo*) fStreamerInfo->At(fClassVersion);; 4734 }; 4735 ; 4736 if (!sinfo) {; 4737 // Let's take the first available StreamerInfo as a start; 4738 Int_t ninfos = fStreamerInfo->GetEntriesFast() - 1;; 4739 for (Int_t i = -1; sinfo == nullptr && i < ninfos; ++i); 4740 sinfo = (TVirtualStreamerInfo *)fStreamerInfo->UncheckedAt(i);; 4741 }; 4742 ; 4743 if (sinfo) {; 4744 sinfo = dynamic_cast<TVirtualStreamerInfo *>(sinfo->Clone());; 4745 if (sinfo) {; 4746 sinfo->SetClass(nullptr);; 4747 sinfo->SetName(newname);; 4748 sinfo->BuildCheck();; 4749 sinfo->BuildOld();; 4750 sinfo->GetClass()->AddRule(TString::Format(""sourceClass=%s targetClass=%s"",GetName(),newname.Data()));; 4751 } else {; 4752 Error(""GetStreamerInfoAbstractEmulated"", ""could not create TVirtualStreamerInfo"");; 4753 }; 4754 }; 4755 }; 4756 return sinfo;; 4757}; 4758 ; 4759////////////////////////////////////////////////////////////////////////////////; 4760/// For the case where the requestor class is emulated and this class is abstract,; 4761/// returns a pointer to the TVirtualStreamerInfo object for version with an emulated; 4762/// representation whether or not the class is loaded.; 4763///; 4764/// If the object does not exist, it is created; 4765///; 4766/// Warning: If we create a new streamer info, whether or not the build; 4767//",MatchSource.WIKI,doc/v632/TClass_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/TClass_8cxx_source.html
https://root.cern/doc/v632/TClass_8cxx_source.html:182318,Availability,avail,available,182318,"UARD(gInterpreterMutex);; 4780 ; 4781 TClass *emulated = TClass::GetClass(newname);; 4782 ; 4783 if (emulated); 4784 sinfo = emulated->FindStreamerInfo(checksum);; 4785 ; 4786 if (!sinfo) {; 4787 // The emulated version of the streamerInfo is explicitly requested and has; 4788 // not been built yet.; 4789 ; 4790 sinfo = (TVirtualStreamerInfo*) FindStreamerInfo(checksum);; 4791 ; 4792 if (!sinfo && (checksum != fCheckSum)) {; 4793 // When the requested version does not exist we return; 4794 // the TVirtualStreamerInfo for the currently loaded class version.; 4795 // FIXME: This arguably makes no sense, we should warn and return nothing instead.; 4796 sinfo = (TVirtualStreamerInfo*) fStreamerInfo->At(fClassVersion);; 4797 }; 4798 ; 4799 if (!sinfo) {; 4800 // Let's take the first available StreamerInfo as a start; 4801 Int_t ninfos = fStreamerInfo->GetEntriesFast() - 1;; 4802 for (Int_t i = -1; sinfo == nullptr && i < ninfos; ++i); 4803 sinfo = (TVirtualStreamerInfo *)fStreamerInfo->UncheckedAt(i);; 4804 }; 4805 ; 4806 if (sinfo) {; 4807 sinfo = dynamic_cast<TVirtualStreamerInfo*>( sinfo->Clone() );; 4808 if (sinfo) {; 4809 sinfo->SetClass(nullptr);; 4810 sinfo->SetName( newname );; 4811 sinfo->BuildCheck();; 4812 sinfo->BuildOld();; 4813 sinfo->GetClass()->AddRule(TString::Format(""sourceClass=%s targetClass=%s"",GetName(),newname.Data()));; 4814 } else {; 4815 Error(""GetStreamerInfoAbstractEmulated"", ""could not create TVirtualStreamerInfo"");; 4816 }; 4817 }; 4818 }; 4819 return sinfo;; 4820}; 4821 ; 4822////////////////////////////////////////////////////////////////////////////////; 4823/// When the class kIgnoreTObjectStreamer bit is set, the automatically; 4824/// generated Streamer will not call TObject::Streamer.; 4825/// This option saves the TObject space overhead on the file.; 4826/// However, the information (fBits, fUniqueID) of TObject is lost.; 4827///; 4828/// Note that to be effective for objects streamed object-wise this function; 4829/// must be called ",MatchSource.WIKI,doc/v632/TClass_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/TClass_8cxx_source.html
https://root.cern/doc/v632/TClass_8cxx_source.html:187179,Availability,down,down,187179,"; 4886{; 4887 if (!cl) return kFALSE;; 4888 if (cl == this) return kTRUE;; 4889 ; 4890 if (!HasDataMemberInfo()) {; 4891 TVirtualStreamerInfo *sinfo = ((TClass *)this)->GetCurrentStreamerInfo();; 4892 if (sinfo==nullptr) sinfo = GetStreamerInfo();; 4893 TIter next(sinfo->GetElements());; 4894 TStreamerElement *element;; 4895 while ((element = (TStreamerElement*)next())) {; 4896 if (element->IsA() == TStreamerBase::Class()) {; 4897 TClass *clbase = element->GetClassPointer();; 4898 if (!clbase) return kFALSE; //missing class; 4899 if (clbase->InheritsFrom(cl)) return kTRUE;; 4900 }; 4901 }; 4902 return kFALSE;; 4903 }; 4904 // cast const away (only for member fBase which can be set in GetListOfBases()); 4905 if (((TClass *)this)->GetBaseClass(cl)) return kTRUE;; 4906 return kFALSE;; 4907}; 4908 ; 4909////////////////////////////////////////////////////////////////////////////////; 4910/// Cast obj of this class type up to baseclass cl if up is true.; 4911/// Cast obj of this class type down from baseclass cl if up is false.; 4912/// If this class is not a baseclass of cl return 0, else the pointer; 4913/// to the cl part of this (up) or to this (down).; 4914 ; 4915void *TClass::DynamicCast(const TClass *cl, void *obj, Bool_t up); 4916{; 4917 if (cl == this) return obj;; 4918 ; 4919 if (!HasDataMemberInfo()) return nullptr;; 4920 ; 4921 Int_t off;; 4922 if ((off = GetBaseClassOffset(cl, obj)) != -1) {; 4923 if (up); 4924 return (void*)((Longptr_t)obj+off);; 4925 else; 4926 return (void*)((Longptr_t)obj-off);; 4927 }; 4928 return nullptr;; 4929}; 4930 ; 4931////////////////////////////////////////////////////////////////////////////////; 4932/// Cast obj of this class type up to baseclass cl if up is true.; 4933/// Cast obj of this class type down from baseclass cl if up is false.; 4934/// If this class is not a baseclass of cl return 0, else the pointer; 4935/// to the cl part of this (up) or to this (down).; 4936 ; 4937const void *TClass::DynamicCast(const TClass *cl",MatchSource.WIKI,doc/v632/TClass_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/TClass_8cxx_source.html
https://root.cern/doc/v632/TClass_8cxx_source.html:187342,Availability,down,down,187342,"erInfo()) {; 4891 TVirtualStreamerInfo *sinfo = ((TClass *)this)->GetCurrentStreamerInfo();; 4892 if (sinfo==nullptr) sinfo = GetStreamerInfo();; 4893 TIter next(sinfo->GetElements());; 4894 TStreamerElement *element;; 4895 while ((element = (TStreamerElement*)next())) {; 4896 if (element->IsA() == TStreamerBase::Class()) {; 4897 TClass *clbase = element->GetClassPointer();; 4898 if (!clbase) return kFALSE; //missing class; 4899 if (clbase->InheritsFrom(cl)) return kTRUE;; 4900 }; 4901 }; 4902 return kFALSE;; 4903 }; 4904 // cast const away (only for member fBase which can be set in GetListOfBases()); 4905 if (((TClass *)this)->GetBaseClass(cl)) return kTRUE;; 4906 return kFALSE;; 4907}; 4908 ; 4909////////////////////////////////////////////////////////////////////////////////; 4910/// Cast obj of this class type up to baseclass cl if up is true.; 4911/// Cast obj of this class type down from baseclass cl if up is false.; 4912/// If this class is not a baseclass of cl return 0, else the pointer; 4913/// to the cl part of this (up) or to this (down).; 4914 ; 4915void *TClass::DynamicCast(const TClass *cl, void *obj, Bool_t up); 4916{; 4917 if (cl == this) return obj;; 4918 ; 4919 if (!HasDataMemberInfo()) return nullptr;; 4920 ; 4921 Int_t off;; 4922 if ((off = GetBaseClassOffset(cl, obj)) != -1) {; 4923 if (up); 4924 return (void*)((Longptr_t)obj+off);; 4925 else; 4926 return (void*)((Longptr_t)obj-off);; 4927 }; 4928 return nullptr;; 4929}; 4930 ; 4931////////////////////////////////////////////////////////////////////////////////; 4932/// Cast obj of this class type up to baseclass cl if up is true.; 4933/// Cast obj of this class type down from baseclass cl if up is false.; 4934/// If this class is not a baseclass of cl return 0, else the pointer; 4935/// to the cl part of this (up) or to this (down).; 4936 ; 4937const void *TClass::DynamicCast(const TClass *cl, const void *obj, Bool_t up); 4938{; 4939 return DynamicCast(cl,const_cast<void*>(obj),up);; 4940}; 494",MatchSource.WIKI,doc/v632/TClass_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/TClass_8cxx_source.html
https://root.cern/doc/v632/TClass_8cxx_source.html:187949,Availability,down,down,187949,"; 4906 return kFALSE;; 4907}; 4908 ; 4909////////////////////////////////////////////////////////////////////////////////; 4910/// Cast obj of this class type up to baseclass cl if up is true.; 4911/// Cast obj of this class type down from baseclass cl if up is false.; 4912/// If this class is not a baseclass of cl return 0, else the pointer; 4913/// to the cl part of this (up) or to this (down).; 4914 ; 4915void *TClass::DynamicCast(const TClass *cl, void *obj, Bool_t up); 4916{; 4917 if (cl == this) return obj;; 4918 ; 4919 if (!HasDataMemberInfo()) return nullptr;; 4920 ; 4921 Int_t off;; 4922 if ((off = GetBaseClassOffset(cl, obj)) != -1) {; 4923 if (up); 4924 return (void*)((Longptr_t)obj+off);; 4925 else; 4926 return (void*)((Longptr_t)obj-off);; 4927 }; 4928 return nullptr;; 4929}; 4930 ; 4931////////////////////////////////////////////////////////////////////////////////; 4932/// Cast obj of this class type up to baseclass cl if up is true.; 4933/// Cast obj of this class type down from baseclass cl if up is false.; 4934/// If this class is not a baseclass of cl return 0, else the pointer; 4935/// to the cl part of this (up) or to this (down).; 4936 ; 4937const void *TClass::DynamicCast(const TClass *cl, const void *obj, Bool_t up); 4938{; 4939 return DynamicCast(cl,const_cast<void*>(obj),up);; 4940}; 4941 ; 4942////////////////////////////////////////////////////////////////////////////////; 4943/// Return a pointer to a newly allocated object of this class.; 4944/// The class must have a default constructor. For meaning of; 4945/// defConstructor, see TClass::IsCallingNew().; 4946///; 4947/// If quiet is true, do no issue a message via Error on case; 4948/// of problems, just return 0.; 4949///; 4950/// The constructor actually called here can be customized by; 4951/// using the rootcint pragma:; 4952/// ~~~ {.cpp}; 4953/// #pragma link C++ ioctortype UserClass;; 4954/// ~~~; 4955/// For example, with this pragma and a class named MyClass,; 4956/// this me",MatchSource.WIKI,doc/v632/TClass_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/TClass_8cxx_source.html
https://root.cern/doc/v632/TClass_8cxx_source.html:188112,Availability,down,down,188112,"//////////////////; 4910/// Cast obj of this class type up to baseclass cl if up is true.; 4911/// Cast obj of this class type down from baseclass cl if up is false.; 4912/// If this class is not a baseclass of cl return 0, else the pointer; 4913/// to the cl part of this (up) or to this (down).; 4914 ; 4915void *TClass::DynamicCast(const TClass *cl, void *obj, Bool_t up); 4916{; 4917 if (cl == this) return obj;; 4918 ; 4919 if (!HasDataMemberInfo()) return nullptr;; 4920 ; 4921 Int_t off;; 4922 if ((off = GetBaseClassOffset(cl, obj)) != -1) {; 4923 if (up); 4924 return (void*)((Longptr_t)obj+off);; 4925 else; 4926 return (void*)((Longptr_t)obj-off);; 4927 }; 4928 return nullptr;; 4929}; 4930 ; 4931////////////////////////////////////////////////////////////////////////////////; 4932/// Cast obj of this class type up to baseclass cl if up is true.; 4933/// Cast obj of this class type down from baseclass cl if up is false.; 4934/// If this class is not a baseclass of cl return 0, else the pointer; 4935/// to the cl part of this (up) or to this (down).; 4936 ; 4937const void *TClass::DynamicCast(const TClass *cl, const void *obj, Bool_t up); 4938{; 4939 return DynamicCast(cl,const_cast<void*>(obj),up);; 4940}; 4941 ; 4942////////////////////////////////////////////////////////////////////////////////; 4943/// Return a pointer to a newly allocated object of this class.; 4944/// The class must have a default constructor. For meaning of; 4945/// defConstructor, see TClass::IsCallingNew().; 4946///; 4947/// If quiet is true, do no issue a message via Error on case; 4948/// of problems, just return 0.; 4949///; 4950/// The constructor actually called here can be customized by; 4951/// using the rootcint pragma:; 4952/// ~~~ {.cpp}; 4953/// #pragma link C++ ioctortype UserClass;; 4954/// ~~~; 4955/// For example, with this pragma and a class named MyClass,; 4956/// this method will called the first of the following 3; 4957/// constructors which exists and is public:; 4958///",MatchSource.WIKI,doc/v632/TClass_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/TClass_8cxx_source.html
https://root.cern/doc/v632/TClass_8cxx_source.html:192342,Availability,avail,available,192342,"[This is very unlikely to work, but who knows!]; 5018 {; 5019 TClass__GetCallingNewRAII callingNew(defConstructor);; 5020 p = gCling->ClassInfo_New(GetClassInfo());; 5021 }; 5022 if (!p && !quiet) {; 5023 //Error(""New"", ""cannot create object of class %s version %d"", GetName(), fClassVersion);; 5024 Error(""New"", ""cannot create object of class %s"", GetName());; 5025 }; 5026 } else if (!HasInterpreterInfo() && fCollectionProxy) {; 5027 // There is no dictionary at all, so this is an emulated; 5028 // class; however we do have the services of a collection proxy,; 5029 // so this is an emulated STL class.; 5030 {; 5031 TClass__GetCallingNewRAII callingNew(defConstructor);; 5032 p = fCollectionProxy->NewObject();; 5033 }; 5034 if (!p && !quiet) {; 5035 //Error(""New"", ""cannot create object of class %s version %d"", GetName(), fClassVersion);; 5036 Error(""New"", ""cannot create object of class %s"", GetName());; 5037 }; 5038 } else if (!HasInterpreterInfo() && !fCollectionProxy) {; 5039 // There is no dictionary at all and we do not have; 5040 // the services of a collection proxy available, so; 5041 // use the streamer info to approximate calling a; 5042 // constructor (basically we just make sure that the; 5043 // pointer data members are null, unless they are marked; 5044 // as preallocated with the ""->"" comment, in which case; 5045 // we default-construct an object to point at).; 5046 ; 5047 // Do not register any TObject's that we create; 5048 // as a result of creating this object.; 5049 // FIXME: Why do we do this?; 5050 // FIXME: Partial Answer: Is this because we may never actually deregister them???; 5051 ; 5052 Bool_t statsave = GetObjectStat();; 5053 if(statsave) {; 5054 SetObjectStat(kFALSE);; 5055 }; 5056 TVirtualStreamerInfo* sinfo = GetStreamerInfo();; 5057 if (!sinfo) {; 5058 if (!quiet); 5059 Error(""New"", ""Cannot construct class '%s' version %d, no streamer info available!"", GetName(), fClassVersion);; 5060 return nullptr;; 5061 }; 5062 ; 5063 {; 5064 TClass__",MatchSource.WIKI,doc/v632/TClass_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/TClass_8cxx_source.html
https://root.cern/doc/v632/TClass_8cxx_source.html:193157,Availability,avail,available,193157,"ClassVersion);; 5036 Error(""New"", ""cannot create object of class %s"", GetName());; 5037 }; 5038 } else if (!HasInterpreterInfo() && !fCollectionProxy) {; 5039 // There is no dictionary at all and we do not have; 5040 // the services of a collection proxy available, so; 5041 // use the streamer info to approximate calling a; 5042 // constructor (basically we just make sure that the; 5043 // pointer data members are null, unless they are marked; 5044 // as preallocated with the ""->"" comment, in which case; 5045 // we default-construct an object to point at).; 5046 ; 5047 // Do not register any TObject's that we create; 5048 // as a result of creating this object.; 5049 // FIXME: Why do we do this?; 5050 // FIXME: Partial Answer: Is this because we may never actually deregister them???; 5051 ; 5052 Bool_t statsave = GetObjectStat();; 5053 if(statsave) {; 5054 SetObjectStat(kFALSE);; 5055 }; 5056 TVirtualStreamerInfo* sinfo = GetStreamerInfo();; 5057 if (!sinfo) {; 5058 if (!quiet); 5059 Error(""New"", ""Cannot construct class '%s' version %d, no streamer info available!"", GetName(), fClassVersion);; 5060 return nullptr;; 5061 }; 5062 ; 5063 {; 5064 TClass__GetCallingNewRAII callingNew(defConstructor);; 5065 p = { sinfo->New(), sinfo};; 5066 }; 5067 ; 5068 // FIXME: Mistake? See note above at the GetObjectStat() call.; 5069 // Allow TObject's to be registered again.; 5070 if(statsave) {; 5071 SetObjectStat(statsave);; 5072 }; 5073 ; 5074 if (!p) {; 5075 Error(""New"", ""Failed to construct class '%s' using streamer info"", GetName());; 5076 }; 5077 ; 5078 return p;; 5079 } else {; 5080 Fatal(""New"", ""This cannot happen!"");; 5081 }; 5082 ; 5083 return p;; 5084}; 5085 ; 5086////////////////////////////////////////////////////////////////////////////////; 5087/// Return a pointer to a newly allocated object of this class.; 5088/// The class must have a default constructor. For meaning of; 5089/// defConstructor, see TClass::IsCallingNew().; 5090 ; 5091void *TClass::New(void *arena,",MatchSource.WIKI,doc/v632/TClass_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/TClass_8cxx_source.html
https://root.cern/doc/v632/TClass_8cxx_source.html:196566,Availability,avail,available,196566," new operator, hopefully the class; 5128 // library is loaded and there will be a default; 5129 // constructor we can call.; 5130 // [This is very unlikely to work, but who knows!]; 5131 {; 5132 TClass__GetCallingNewRAII callingNew(defConstructor);; 5133 p = gCling->ClassInfo_New(GetClassInfo(),arena);; 5134 }; 5135 if (!p) {; 5136 Error(""New with placement"", ""cannot create object of class %s version %d at address %p"", GetName(), fClassVersion, arena);; 5137 }; 5138 } else if (!HasInterpreterInfo() && fCollectionProxy) {; 5139 // There is no dictionary at all, so this is an emulated; 5140 // class; however we do have the services of a collection proxy,; 5141 // so this is an emulated STL class.; 5142 {; 5143 TClass__GetCallingNewRAII callingNew(defConstructor);; 5144 p = fCollectionProxy->NewObject(arena);; 5145 }; 5146 } else if (!HasInterpreterInfo() && !fCollectionProxy) {; 5147 // There is no dictionary at all and we do not have; 5148 // the services of a collection proxy available, so; 5149 // use the streamer info to approximate calling a; 5150 // constructor (basically we just make sure that the; 5151 // pointer data members are null, unless they are marked; 5152 // as preallocated with the ""->"" comment, in which case; 5153 // we default-construct an object to point at).; 5154 ; 5155 // ???BUG??? ???WHY???; 5156 // Do not register any TObject's that we create; 5157 // as a result of creating this object.; 5158 Bool_t statsave = GetObjectStat();; 5159 if(statsave) {; 5160 SetObjectStat(kFALSE);; 5161 }; 5162 ; 5163 TVirtualStreamerInfo* sinfo = GetStreamerInfo();; 5164 if (!sinfo) {; 5165 Error(""New with placement"", ""Cannot construct class '%s' version %d at address %p, no streamer info available!"", GetName(), fClassVersion, arena);; 5166 return nullptr;; 5167 }; 5168 ; 5169 {; 5170 TClass__GetCallingNewRAII callingNew(defConstructor);; 5171 p = { sinfo->New(arena), sinfo };; 5172 }; 5173 ; 5174 // ???BUG???; 5175 // Allow TObject's to be registered again.; 517",MatchSource.WIKI,doc/v632/TClass_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/TClass_8cxx_source.html
https://root.cern/doc/v632/TClass_8cxx_source.html:197297,Availability,avail,available,197297,"43 TClass__GetCallingNewRAII callingNew(defConstructor);; 5144 p = fCollectionProxy->NewObject(arena);; 5145 }; 5146 } else if (!HasInterpreterInfo() && !fCollectionProxy) {; 5147 // There is no dictionary at all and we do not have; 5148 // the services of a collection proxy available, so; 5149 // use the streamer info to approximate calling a; 5150 // constructor (basically we just make sure that the; 5151 // pointer data members are null, unless they are marked; 5152 // as preallocated with the ""->"" comment, in which case; 5153 // we default-construct an object to point at).; 5154 ; 5155 // ???BUG??? ???WHY???; 5156 // Do not register any TObject's that we create; 5157 // as a result of creating this object.; 5158 Bool_t statsave = GetObjectStat();; 5159 if(statsave) {; 5160 SetObjectStat(kFALSE);; 5161 }; 5162 ; 5163 TVirtualStreamerInfo* sinfo = GetStreamerInfo();; 5164 if (!sinfo) {; 5165 Error(""New with placement"", ""Cannot construct class '%s' version %d at address %p, no streamer info available!"", GetName(), fClassVersion, arena);; 5166 return nullptr;; 5167 }; 5168 ; 5169 {; 5170 TClass__GetCallingNewRAII callingNew(defConstructor);; 5171 p = { sinfo->New(arena), sinfo };; 5172 }; 5173 ; 5174 // ???BUG???; 5175 // Allow TObject's to be registered again.; 5176 if(statsave) {; 5177 SetObjectStat(statsave);; 5178 }; 5179 ; 5180 } else {; 5181 Error(""New with placement"", ""This cannot happen!"");; 5182 }; 5183 ; 5184 return p;; 5185}; 5186 ; 5187////////////////////////////////////////////////////////////////////////////////; 5188/// Return a pointer to a newly allocated array of objects; 5189/// of this class.; 5190/// The class must have a default constructor. For meaning of; 5191/// defConstructor, see TClass::IsCallingNew().; 5192 ; 5193void *TClass::NewArray(Long_t nElements, ENewType defConstructor) const; 5194{; 5195 auto obj = NewObjectArray(nElements, defConstructor);; 5196 if (obj.GetPtr() && obj.GetAllocator()) {; 5197 // Register the object for special",MatchSource.WIKI,doc/v632/TClass_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/TClass_8cxx_source.html
https://root.cern/doc/v632/TClass_8cxx_source.html:200583,Availability,avail,available,200583,"eter; 5230 // call the new operator, hopefully the class; 5231 // library is loaded and there will be a default; 5232 // constructor we can call.; 5233 // [This is very unlikely to work, but who knows!]; 5234 {; 5235 TClass__GetCallingNewRAII callingNew(defConstructor);; 5236 p = gCling->ClassInfo_New(GetClassInfo(),nElements);; 5237 }; 5238 if (!p) {; 5239 Error(""NewArray"", ""cannot create object of class %s version %d"", GetName(), fClassVersion);; 5240 }; 5241 } else if (!HasInterpreterInfo() && fCollectionProxy) {; 5242 // There is no dictionary at all, so this is an emulated; 5243 // class; however we do have the services of a collection proxy,; 5244 // so this is an emulated STL class.; 5245 {; 5246 TClass__GetCallingNewRAII callingNew(defConstructor);; 5247 p = fCollectionProxy->NewObjectArray(nElements);; 5248 }; 5249 } else if (!HasInterpreterInfo() && !fCollectionProxy) {; 5250 // There is no dictionary at all and we do not have; 5251 // the services of a collection proxy available, so; 5252 // use the streamer info to approximate calling a; 5253 // constructor (basically we just make sure that the; 5254 // pointer data members are null, unless they are marked; 5255 // as preallocated with the ""->"" comment, in which case; 5256 // we default-construct an object to point at).; 5257 ; 5258 // ???BUG??? ???WHY???; 5259 // Do not register any TObject's that we create; 5260 // as a result of creating this object.; 5261 Bool_t statsave = GetObjectStat();; 5262 if(statsave) {; 5263 SetObjectStat(kFALSE);; 5264 }; 5265 ; 5266 TVirtualStreamerInfo* sinfo = GetStreamerInfo();; 5267 if (!sinfo) {; 5268 Error(""NewArray"", ""Cannot construct class '%s' version %d, no streamer info available!"", GetName(), fClassVersion);; 5269 return nullptr;; 5270 }; 5271 ; 5272 {; 5273 TClass__GetCallingNewRAII callingNew(defConstructor);; 5274 p = { sinfo->NewArray(nElements), sinfo };; 5275 }; 5276 ; 5277 // ???BUG???; 5278 // Allow TObject's to be registered again.; 5279 if(statsave) {;",MatchSource.WIKI,doc/v632/TClass_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/TClass_8cxx_source.html
https://root.cern/doc/v632/TClass_8cxx_source.html:201290,Availability,avail,available,201290,"5246 TClass__GetCallingNewRAII callingNew(defConstructor);; 5247 p = fCollectionProxy->NewObjectArray(nElements);; 5248 }; 5249 } else if (!HasInterpreterInfo() && !fCollectionProxy) {; 5250 // There is no dictionary at all and we do not have; 5251 // the services of a collection proxy available, so; 5252 // use the streamer info to approximate calling a; 5253 // constructor (basically we just make sure that the; 5254 // pointer data members are null, unless they are marked; 5255 // as preallocated with the ""->"" comment, in which case; 5256 // we default-construct an object to point at).; 5257 ; 5258 // ???BUG??? ???WHY???; 5259 // Do not register any TObject's that we create; 5260 // as a result of creating this object.; 5261 Bool_t statsave = GetObjectStat();; 5262 if(statsave) {; 5263 SetObjectStat(kFALSE);; 5264 }; 5265 ; 5266 TVirtualStreamerInfo* sinfo = GetStreamerInfo();; 5267 if (!sinfo) {; 5268 Error(""NewArray"", ""Cannot construct class '%s' version %d, no streamer info available!"", GetName(), fClassVersion);; 5269 return nullptr;; 5270 }; 5271 ; 5272 {; 5273 TClass__GetCallingNewRAII callingNew(defConstructor);; 5274 p = { sinfo->NewArray(nElements), sinfo };; 5275 }; 5276 ; 5277 // ???BUG???; 5278 // Allow TObject's to be registered again.; 5279 if(statsave) {; 5280 SetObjectStat(statsave);; 5281 }; 5282 ; 5283 } else {; 5284 Error(""NewArray"", ""This cannot happen!"");; 5285 }; 5286 ; 5287 return p;; 5288}; 5289 ; 5290////////////////////////////////////////////////////////////////////////////////; 5291/// Return a pointer to a newly allocated object of this class.; 5292/// The class must have a default constructor. For meaning of; 5293/// defConstructor, see TClass::IsCallingNew().; 5294 ; 5295void *TClass::NewArray(Long_t nElements, void *arena, ENewType defConstructor) const; 5296{; 5297 auto obj = NewObjectArray(nElements, arena, defConstructor);; 5298 if (obj.GetPtr() && obj.GetAllocator()) {; 5299 // Register the object for special handling in the des",MatchSource.WIKI,doc/v632/TClass_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/TClass_8cxx_source.html
https://root.cern/doc/v632/TClass_8cxx_source.html:203922,Availability,avail,available,203922,"ments, void *arena, ENewType defConstructor) const; 5311{; 5312 ObjectPtr p;; 5313 ; 5314 if (fNewArray) {; 5315 // We have the new operator wrapper function,; 5316 // so there is a dictionary and it was generated; 5317 // by rootcint, so there should be a default; 5318 // constructor we can call through the wrapper.; 5319 {; 5320 TClass__GetCallingNewRAII callingNew(defConstructor);; 5321 p = fNewArray(nElements, arena);; 5322 }; 5323 if (!p) {; 5324 Error(""NewArray with placement"", ""cannot create object of class %s version %d at address %p"", GetName(), fClassVersion, arena);; 5325 }; 5326 } else if (HasInterpreterInfo()) {; 5327 // We have the dictionary but do not have the constructor wrapper,; 5328 // so the dictionary was not generated by rootcint (it was made either; 5329 // by cint or by some external mechanism). Let's try to create the; 5330 // object by having the interpreter call the new operator, either the; 5331 // class library is loaded and there is a default constructor we can; 5332 // call, or the class is interpreted and we will call the default; 5333 // constructor that way, or no default constructor is available and; 5334 // we fail.; 5335 {; 5336 TClass__GetCallingNewRAII callingNew(defConstructor);; 5337 p = gCling->ClassInfo_New(GetClassInfo(),nElements, arena);; 5338 }; 5339 if (!p) {; 5340 Error(""NewArray with placement"", ""cannot create object of class %s version %d at address %p"", GetName(), fClassVersion, arena);; 5341 }; 5342 } else if (!HasInterpreterInfo() && fCollectionProxy) {; 5343 // There is no dictionary at all, so this is an emulated; 5344 // class; however we do have the services of a collection proxy,; 5345 // so this is an emulated STL class.; 5346 {; 5347 TClass__GetCallingNewRAII callingNew(defConstructor);; 5348 p = fCollectionProxy->NewObjectArray(nElements, arena);; 5349 }; 5350 } else if (!HasInterpreterInfo() && !fCollectionProxy) {; 5351 // There is no dictionary at all and we do not have; 5352 // the services of a colle",MatchSource.WIKI,doc/v632/TClass_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/TClass_8cxx_source.html
https://root.cern/doc/v632/TClass_8cxx_source.html:204796,Availability,avail,available,204796,"/ call, or the class is interpreted and we will call the default; 5333 // constructor that way, or no default constructor is available and; 5334 // we fail.; 5335 {; 5336 TClass__GetCallingNewRAII callingNew(defConstructor);; 5337 p = gCling->ClassInfo_New(GetClassInfo(),nElements, arena);; 5338 }; 5339 if (!p) {; 5340 Error(""NewArray with placement"", ""cannot create object of class %s version %d at address %p"", GetName(), fClassVersion, arena);; 5341 }; 5342 } else if (!HasInterpreterInfo() && fCollectionProxy) {; 5343 // There is no dictionary at all, so this is an emulated; 5344 // class; however we do have the services of a collection proxy,; 5345 // so this is an emulated STL class.; 5346 {; 5347 TClass__GetCallingNewRAII callingNew(defConstructor);; 5348 p = fCollectionProxy->NewObjectArray(nElements, arena);; 5349 }; 5350 } else if (!HasInterpreterInfo() && !fCollectionProxy) {; 5351 // There is no dictionary at all and we do not have; 5352 // the services of a collection proxy available, so; 5353 // use the streamer info to approximate calling a; 5354 // constructor (basically we just make sure that the; 5355 // pointer data members are null, unless they are marked; 5356 // as preallocated with the ""->"" comment, in which case; 5357 // we default-construct an object to point at).; 5358 ; 5359 // ???BUG??? ???WHY???; 5360 // Do not register any TObject's that we create; 5361 // as a result of creating this object.; 5362 Bool_t statsave = GetObjectStat();; 5363 if(statsave) {; 5364 SetObjectStat(kFALSE);; 5365 }; 5366 ; 5367 TVirtualStreamerInfo* sinfo = GetStreamerInfo();; 5368 if (!sinfo) {; 5369 Error(""NewArray with placement"", ""Cannot construct class '%s' version %d at address %p, no streamer info available!"", GetName(), fClassVersion, arena);; 5370 return nullptr;; 5371 }; 5372 ; 5373 {; 5374 TClass__GetCallingNewRAII callingNew(defConstructor);; 5375 p = { sinfo->NewArray(nElements, arena), sinfo };; 5376 }; 5377 ; 5378 // ???BUG???; 5379 // Allow TObject's",MatchSource.WIKI,doc/v632/TClass_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/TClass_8cxx_source.html
https://root.cern/doc/v632/TClass_8cxx_source.html:205532,Availability,avail,available,205532,"II callingNew(defConstructor);; 5348 p = fCollectionProxy->NewObjectArray(nElements, arena);; 5349 }; 5350 } else if (!HasInterpreterInfo() && !fCollectionProxy) {; 5351 // There is no dictionary at all and we do not have; 5352 // the services of a collection proxy available, so; 5353 // use the streamer info to approximate calling a; 5354 // constructor (basically we just make sure that the; 5355 // pointer data members are null, unless they are marked; 5356 // as preallocated with the ""->"" comment, in which case; 5357 // we default-construct an object to point at).; 5358 ; 5359 // ???BUG??? ???WHY???; 5360 // Do not register any TObject's that we create; 5361 // as a result of creating this object.; 5362 Bool_t statsave = GetObjectStat();; 5363 if(statsave) {; 5364 SetObjectStat(kFALSE);; 5365 }; 5366 ; 5367 TVirtualStreamerInfo* sinfo = GetStreamerInfo();; 5368 if (!sinfo) {; 5369 Error(""NewArray with placement"", ""Cannot construct class '%s' version %d at address %p, no streamer info available!"", GetName(), fClassVersion, arena);; 5370 return nullptr;; 5371 }; 5372 ; 5373 {; 5374 TClass__GetCallingNewRAII callingNew(defConstructor);; 5375 p = { sinfo->NewArray(nElements, arena), sinfo };; 5376 }; 5377 ; 5378 // ???BUG???; 5379 // Allow TObject's to be registered again.; 5380 if(statsave) {; 5381 SetObjectStat(statsave);; 5382 }; 5383 ; 5384 if (fStreamerType & kEmulatedStreamer) {; 5385 // We always register emulated objects, we need to always; 5386 // use the streamer info to destroy them.; 5387 }; 5388 ; 5389 return p;; 5390 } else {; 5391 Error(""NewArray with placement"", ""This cannot happen!"");; 5392 }; 5393 ; 5394 return p;; 5395}; 5396 ; 5397////////////////////////////////////////////////////////////////////////////////; 5398/// Explicitly call destructor for object.; 5399 ; 5400void TClass::Destructor(void *obj, Bool_t dtorOnly); 5401{; 5402 // Do nothing if passed a null pointer.; 5403 if (obj == nullptr) return;; 5404 ; 5405 void* p = obj;; 5406 ; 5407 if",MatchSource.WIKI,doc/v632/TClass_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/TClass_8cxx_source.html
https://root.cern/doc/v632/TClass_8cxx_source.html:207812,Availability,avail,available,207812,"se if (HasInterpreterInfo()) {; 5414 // We have the dictionary but do not have the; 5415 // destruct/delete wrapper, so the dictionary was; 5416 // not generated by rootcint (it could have been; 5417 // created by cint or by some external mechanism).; 5418 // Let's have the interpreter call the destructor,; 5419 // either the code will be in a loaded library,; 5420 // or it will be interpreted, otherwise we fail; 5421 // because there is no destructor code at all.; 5422 if (dtorOnly) {; 5423 gCling->ClassInfo_Destruct(fClassInfo,p);; 5424 } else {; 5425 gCling->ClassInfo_Delete(fClassInfo,p);; 5426 }; 5427 } else if (!HasInterpreterInfo() && fCollectionProxy) {; 5428 // There is no dictionary at all, so this is an emulated; 5429 // class; however we do have the services of a collection proxy,; 5430 // so this is an emulated STL class.; 5431 GetCollectionProxy()->Destructor(p, dtorOnly);; 5432 } else if (!HasInterpreterInfo() && !fCollectionProxy) {; 5433 // There is no dictionary at all and we do not have; 5434 // the services of a collection proxy available, so; 5435 // use the streamer info to approximate calling a; 5436 // destructor.; 5437 ; 5438 Bool_t inRepo = kTRUE;; 5439 Bool_t currentVersion = kFALSE;; 5440 ; 5441 // Was this object allocated through TClass?; 5442 Version_t objVer = -1;; 5443 {; 5444 R__LOCKGUARD2(fOVRMutex);; 5445 RepoCont_t::iterator iter = fObjectVersionRepository.find(p);; 5446 if (iter == fObjectVersionRepository.end()) {; 5447 // No, it wasn't, skip special version handling.; 5448 //Error(""Destructor2"", ""Attempt to delete unregistered object of class '%s' at address %p!"", GetName(), p);; 5449 inRepo = kFALSE;; 5450 } else {; 5451 //objVer = iter->second;; 5452 for (; (iter != fObjectVersionRepository.end()) && (iter->first == p); ++iter) {; 5453 objVer = iter->second;; 5454 if (objVer == fClassVersion) {; 5455 currentVersion = kTRUE;; 5456 break;; 5457 }; 5458 }; 5459 }; 5460 }; 5461 ; 5462 if (!inRepo || currentVersion) {; 5463 // The",MatchSource.WIKI,doc/v632/TClass_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/TClass_8cxx_source.html
https://root.cern/doc/v632/TClass_8cxx_source.html:209027,Availability,avail,available,209027,"r == fObjectVersionRepository.end()) {; 5447 // No, it wasn't, skip special version handling.; 5448 //Error(""Destructor2"", ""Attempt to delete unregistered object of class '%s' at address %p!"", GetName(), p);; 5449 inRepo = kFALSE;; 5450 } else {; 5451 //objVer = iter->second;; 5452 for (; (iter != fObjectVersionRepository.end()) && (iter->first == p); ++iter) {; 5453 objVer = iter->second;; 5454 if (objVer == fClassVersion) {; 5455 currentVersion = kTRUE;; 5456 break;; 5457 }; 5458 }; 5459 }; 5460 }; 5461 ; 5462 if (!inRepo || currentVersion) {; 5463 // The object was allocated using code for the same class version; 5464 // as is loaded now. We may proceed without worry.; 5465 TVirtualStreamerInfo* si = GetStreamerInfo();; 5466 if (si) {; 5467 si->Destructor(p, dtorOnly);; 5468 } else {; 5469 Error(""Destructor"", ""No streamer info available for class '%s' version %d at address %p, cannot destruct emulated object!"", GetName(), fClassVersion, p);; 5470 Error(""Destructor"", ""length of fStreamerInfo is %d"", fStreamerInfo->GetSize());; 5471 Int_t i = fStreamerInfo->LowerBound();; 5472 for (Int_t v = 0; v < fStreamerInfo->GetSize(); ++v, ++i) {; 5473 Error(""Destructor"", ""fStreamerInfo->At(%d): %p"", i, fStreamerInfo->At(i));; 5474 if (fStreamerInfo->At(i) != nullptr) {; 5475 Error(""Destructor"", ""Doing Dump() ..."");; 5476 ((TVirtualStreamerInfo*)fStreamerInfo->At(i))->Dump();; 5477 }; 5478 }; 5479 }; 5480 } else {; 5481 // The loaded class version is not the same as the version of the code; 5482 // which was used to allocate this object. The best we can do is use; 5483 // the TVirtualStreamerInfo to try to free up some of the allocated memory.; 5484 TVirtualStreamerInfo* si = (TVirtualStreamerInfo*) fStreamerInfo->At(objVer);; 5485 if (si) {; 5486 si->Destructor(p, dtorOnly);; 5487 } else {; 5488 Error(""Destructor"", ""No streamer info available for class '%s' version %d, cannot destruct object at addr: %p"", GetName(), objVer, p);; 5489 Error(""Destructor"", ""length of fStreamerIn",MatchSource.WIKI,doc/v632/TClass_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/TClass_8cxx_source.html
https://root.cern/doc/v632/TClass_8cxx_source.html:210041,Availability,avail,available,210041,"ength of fStreamerInfo is %d"", fStreamerInfo->GetSize());; 5471 Int_t i = fStreamerInfo->LowerBound();; 5472 for (Int_t v = 0; v < fStreamerInfo->GetSize(); ++v, ++i) {; 5473 Error(""Destructor"", ""fStreamerInfo->At(%d): %p"", i, fStreamerInfo->At(i));; 5474 if (fStreamerInfo->At(i) != nullptr) {; 5475 Error(""Destructor"", ""Doing Dump() ..."");; 5476 ((TVirtualStreamerInfo*)fStreamerInfo->At(i))->Dump();; 5477 }; 5478 }; 5479 }; 5480 } else {; 5481 // The loaded class version is not the same as the version of the code; 5482 // which was used to allocate this object. The best we can do is use; 5483 // the TVirtualStreamerInfo to try to free up some of the allocated memory.; 5484 TVirtualStreamerInfo* si = (TVirtualStreamerInfo*) fStreamerInfo->At(objVer);; 5485 if (si) {; 5486 si->Destructor(p, dtorOnly);; 5487 } else {; 5488 Error(""Destructor"", ""No streamer info available for class '%s' version %d, cannot destruct object at addr: %p"", GetName(), objVer, p);; 5489 Error(""Destructor"", ""length of fStreamerInfo is %d"", fStreamerInfo->GetSize());; 5490 Int_t i = fStreamerInfo->LowerBound();; 5491 for (Int_t v = 0; v < fStreamerInfo->GetSize(); ++v, ++i) {; 5492 Error(""Destructor2"", ""fStreamerInfo->At(%d): %p"", i, fStreamerInfo->At(i));; 5493 if (fStreamerInfo->At(i) != nullptr) {; 5494 // Do some debugging output.; 5495 Error(""Destructor2"", ""Doing Dump() ..."");; 5496 ((TVirtualStreamerInfo*)fStreamerInfo->At(i))->Dump();; 5497 }; 5498 }; 5499 }; 5500 }; 5501 ; 5502 if (inRepo && p) {; 5503 UnregisterAddressInRepository(""TClass::Destructor"",p,this);; 5504 }; 5505 } else {; 5506 Error(""Destructor"", ""This cannot happen! (class %s)"", GetName());; 5507 }; 5508}; 5509 ; 5510////////////////////////////////////////////////////////////////////////////////; 5511/// Explicitly call destructor for object.; 5512 ; 5513void TClass::Destructor(TClass::ObjectPtr obj, Bool_t dtorOnly); 5514{; 5515 // Do nothing if passed a null pointer.; 5516 if (obj.GetPtr() == nullptr); 5517 return;; 5518 ",MatchSource.WIKI,doc/v632/TClass_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/TClass_8cxx_source.html
https://root.cern/doc/v632/TClass_8cxx_source.html:212839,Availability,avail,available,212839,"teArray"", ""Destructor only is not supported!"");; 5540 } else {; 5541 // We have the array delete wrapper, use it.; 5542 fDeleteArray(ary);; 5543 }; 5544 } else if (HasInterpreterInfo()) {; 5545 // We have the dictionary but do not have the; 5546 // array delete wrapper, so the dictionary was; 5547 // not generated by rootcint. Let's try to; 5548 // delete the array by having the interpreter; 5549 // call the array delete operator, hopefully; 5550 // the class library is loaded and there will be; 5551 // a destructor we can call.; 5552 gCling->ClassInfo_DeleteArray(GetClassInfo(),ary, dtorOnly);; 5553 } else if (!HasInterpreterInfo() && fCollectionProxy) {; 5554 // There is no dictionary at all, so this is an emulated; 5555 // class; however we do have the services of a collection proxy,; 5556 // so this is an emulated STL class.; 5557 GetCollectionProxy()->DeleteArray(ary, dtorOnly);; 5558 } else if (!HasInterpreterInfo() && !fCollectionProxy) {; 5559 // There is no dictionary at all and we do not have; 5560 // the services of a collection proxy available, so; 5561 // use the streamer info to approximate calling the; 5562 // array destructor.; 5563 ; 5564 Bool_t inRepo = kTRUE;; 5565 Bool_t currentVersion = kFALSE;; 5566 ; 5567 // Was this array object allocated through TClass?; 5568 Version_t objVer = -1;; 5569 {; 5570 R__LOCKGUARD2(fOVRMutex);; 5571 RepoCont_t::iterator iter = fObjectVersionRepository.find(p);; 5572 if (iter == fObjectVersionRepository.end()) {; 5573 // No, it wasn't, we cannot know what to do.; 5574 //Error(""DeleteArray"", ""Attempt to delete unregistered array object, element type '%s', at address %p!"", GetName(), p);; 5575 inRepo = kFALSE;; 5576 } else {; 5577 for (; (iter != fObjectVersionRepository.end()) && (iter->first == p); ++iter) {; 5578 objVer = iter->second;; 5579 if (objVer == fClassVersion) {; 5580 currentVersion = kTRUE;; 5581 break;; 5582 }; 5583 }; 5584 }; 5585 }; 5586 ; 5587 if (!inRepo || currentVersion) {; 5588 // The object was",MatchSource.WIKI,doc/v632/TClass_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/TClass_8cxx_source.html
https://root.cern/doc/v632/TClass_8cxx_source.html:214049,Availability,avail,available,214049,"itory.find(p);; 5572 if (iter == fObjectVersionRepository.end()) {; 5573 // No, it wasn't, we cannot know what to do.; 5574 //Error(""DeleteArray"", ""Attempt to delete unregistered array object, element type '%s', at address %p!"", GetName(), p);; 5575 inRepo = kFALSE;; 5576 } else {; 5577 for (; (iter != fObjectVersionRepository.end()) && (iter->first == p); ++iter) {; 5578 objVer = iter->second;; 5579 if (objVer == fClassVersion) {; 5580 currentVersion = kTRUE;; 5581 break;; 5582 }; 5583 }; 5584 }; 5585 }; 5586 ; 5587 if (!inRepo || currentVersion) {; 5588 // The object was allocated using code for the same class version; 5589 // as is loaded now. We may proceed without worry.; 5590 TVirtualStreamerInfo* si = GetStreamerInfo();; 5591 if (si) {; 5592 si->DeleteArray(ary, dtorOnly);; 5593 } else {; 5594 Error(""DeleteArray"", ""No streamer info available for class '%s' version %d at address %p, cannot destruct object!"", GetName(), fClassVersion, ary);; 5595 Error(""DeleteArray"", ""length of fStreamerInfo is %d"", fStreamerInfo->GetSize());; 5596 Int_t i = fStreamerInfo->LowerBound();; 5597 for (Int_t v = 0; v < fStreamerInfo->GetSize(); ++v, ++i) {; 5598 Error(""DeleteArray"", ""fStreamerInfo->At(%d): %p"", v, fStreamerInfo->At(i));; 5599 if (fStreamerInfo->At(i)) {; 5600 Error(""DeleteArray"", ""Doing Dump() ..."");; 5601 ((TVirtualStreamerInfo*)fStreamerInfo->At(i))->Dump();; 5602 }; 5603 }; 5604 }; 5605 } else {; 5606 // The loaded class version is not the same as the version of the code; 5607 // which was used to allocate this array. The best we can do is use; 5608 // the TVirtualStreamerInfo to try to free up some of the allocated memory.; 5609 TVirtualStreamerInfo* si = (TVirtualStreamerInfo*) fStreamerInfo->At(objVer);; 5610 if (si) {; 5611 si->DeleteArray(ary, dtorOnly);; 5612 } else {; 5613 Error(""DeleteArray"", ""No streamer info available for class '%s' version %d at address %p, cannot destruct object!"", GetName(), objVer, ary);; 5614 Error(""DeleteArray"", ""length of fStream",MatchSource.WIKI,doc/v632/TClass_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/TClass_8cxx_source.html
https://root.cern/doc/v632/TClass_8cxx_source.html:215051,Availability,avail,available,215051,"Array"", ""length of fStreamerInfo is %d"", fStreamerInfo->GetSize());; 5596 Int_t i = fStreamerInfo->LowerBound();; 5597 for (Int_t v = 0; v < fStreamerInfo->GetSize(); ++v, ++i) {; 5598 Error(""DeleteArray"", ""fStreamerInfo->At(%d): %p"", v, fStreamerInfo->At(i));; 5599 if (fStreamerInfo->At(i)) {; 5600 Error(""DeleteArray"", ""Doing Dump() ..."");; 5601 ((TVirtualStreamerInfo*)fStreamerInfo->At(i))->Dump();; 5602 }; 5603 }; 5604 }; 5605 } else {; 5606 // The loaded class version is not the same as the version of the code; 5607 // which was used to allocate this array. The best we can do is use; 5608 // the TVirtualStreamerInfo to try to free up some of the allocated memory.; 5609 TVirtualStreamerInfo* si = (TVirtualStreamerInfo*) fStreamerInfo->At(objVer);; 5610 if (si) {; 5611 si->DeleteArray(ary, dtorOnly);; 5612 } else {; 5613 Error(""DeleteArray"", ""No streamer info available for class '%s' version %d at address %p, cannot destruct object!"", GetName(), objVer, ary);; 5614 Error(""DeleteArray"", ""length of fStreamerInfo is %d"", fStreamerInfo->GetSize());; 5615 Int_t i = fStreamerInfo->LowerBound();; 5616 for (Int_t v = 0; v < fStreamerInfo->GetSize(); ++v, ++i) {; 5617 Error(""DeleteArray"", ""fStreamerInfo->At(%d): %p"", v, fStreamerInfo->At(i));; 5618 if (fStreamerInfo->At(i)) {; 5619 // Print some debugging info.; 5620 Error(""DeleteArray"", ""Doing Dump() ..."");; 5621 ((TVirtualStreamerInfo*)fStreamerInfo->At(i))->Dump();; 5622 }; 5623 }; 5624 }; 5625 }; 5626 ; 5627 // Deregister the object for special handling in the destructor.; 5628 if (inRepo && p) {; 5629 UnregisterAddressInRepository(""TClass::DeleteArray"",p,this);; 5630 }; 5631 } else {; 5632 Error(""DeleteArray"", ""This cannot happen! (class '%s')"", GetName());; 5633 }; 5634}; 5635 ; 5636////////////////////////////////////////////////////////////////////////////////; 5637/// Explicitly call operator delete[] for an array.; 5638 ; 5639void TClass::DeleteArray(TClass::ObjectPtr obj, Bool_t dtorOnly); 5640{; 5641 // Do noth",MatchSource.WIKI,doc/v632/TClass_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/TClass_8cxx_source.html
https://root.cern/doc/v632/TClass_8cxx_source.html:222898,Availability,avail,available,222898,"ostLoadCheck();; 5787 return ncl;; 5788 }; 5789 return nullptr;; 5790}; 5791 ; 5792////////////////////////////////////////////////////////////////////////////////; 5793/// Helper function used by TClass::GetClass().; 5794/// This function attempts to load the dictionary for 'classname'; 5795/// from the list of generator.; 5796/// If silent is 'true', do not warn about missing dictionary for the class.; 5797/// (typically used for class that are used only for transient members); 5798///; 5799/// The 'requestedname' is expected to be already normalized.; 5800 ; 5801TClass *TClass::LoadClassCustom(const char *requestedname, Bool_t silent); 5802{; 5803 // This function does not (and should not) attempt to check in the; 5804 // list of loaded classes or in the typedef.; 5805 ; 5806 TIter next(gROOT->GetListOfClassGenerators());; 5807 TClassGenerator *gen;; 5808 while ((gen = (TClassGenerator*) next())) {; 5809 TClass *cl = gen->GetClass(requestedname, kTRUE, silent);; 5810 if (cl) {; 5811 cl->PostLoadCheck();; 5812 return cl;; 5813 }; 5814 }; 5815 return nullptr;; 5816}; 5817 ; 5818////////////////////////////////////////////////////////////////////////////////; 5819/// Try to load the ClassInfo if available. This function may require parsing; 5820/// the header file and/or loading data from the clang pcm. If further calls to; 5821/// this function cannot affect the value of fClassInfo, fCanLoadClassInfo is set; 5822/// to false.; 5823 ; 5824void TClass::LoadClassInfo() const; 5825{; 5826 R__LOCKGUARD(gInterpreterMutex);; 5827 ; 5828 // Return if another thread already loaded the info; 5829 // while we were waiting for the lock; 5830 if (!fCanLoadClassInfo || TestBit(kLoading)); 5831 return;; 5832 ; 5833 bool autoParse = !gInterpreter->IsAutoParsingSuspended();; 5834 ; 5835 if (autoParse); 5836 gInterpreter->AutoParse(GetName());; 5837 ; 5838 if (!fClassInfo); 5839 gInterpreter->SetClassInfo(const_cast<TClass *>(this));; 5840 ; 5841 if (autoParse && !fClassInfo) {; 5842",MatchSource.WIKI,doc/v632/TClass_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/TClass_8cxx_source.html
https://root.cern/doc/v632/TClass_8cxx_source.html:224029,Availability,avail,available,224029,"ther calls to; 5821/// this function cannot affect the value of fClassInfo, fCanLoadClassInfo is set; 5822/// to false.; 5823 ; 5824void TClass::LoadClassInfo() const; 5825{; 5826 R__LOCKGUARD(gInterpreterMutex);; 5827 ; 5828 // Return if another thread already loaded the info; 5829 // while we were waiting for the lock; 5830 if (!fCanLoadClassInfo || TestBit(kLoading)); 5831 return;; 5832 ; 5833 bool autoParse = !gInterpreter->IsAutoParsingSuspended();; 5834 ; 5835 if (autoParse); 5836 gInterpreter->AutoParse(GetName());; 5837 ; 5838 if (!fClassInfo); 5839 gInterpreter->SetClassInfo(const_cast<TClass *>(this));; 5840 ; 5841 if (autoParse && !fClassInfo) {; 5842 if (fImplFileLine == -1 && fClassVersion == 0) {; 5843 // We have a 'transient' class with a ClassDefInline and apparently no interpreter; 5844 // information. Since it is transient, it is more than likely that the lack; 5845 // will be harmles.; 5846 } else {; 5847 ::Error(""TClass::LoadClassInfo"", ""no interpreter information for class %s is available""; 5848 "" even though it has a TClass initialization routine."",; 5849 fName.Data());; 5850 }; 5851 return;; 5852 }; 5853 ; 5854 fCanLoadClassInfo = false;; 5855}; 5856 ; 5857////////////////////////////////////////////////////////////////////////////////; 5858/// Store class description on I/O buffer.; 5859 ; 5860void TClass::Store(TBuffer &b) const; 5861{; 5862 b.WriteString(GetName());; 5863}; 5864 ; 5865////////////////////////////////////////////////////////////////////////////////; 5866/// Global function called by a class' static Dictionary() method; 5867/// (see the ClassDef macro).; 5868 ; 5869TClass *ROOT::CreateClass(const char *cname, Version_t id,; 5870 const std::type_info &info, TVirtualIsAProxy *isa,; 5871 const char *dfil, const char *ifil,; 5872 Int_t dl, Int_t il); 5873{; 5874 // When called via TMapFile (e.g. Update()) make sure that the dictionary; 5875 // gets allocated on the heap and not in the mapped file.; 5876 TMmallocDescTemp setreset;;",MatchSource.WIKI,doc/v632/TClass_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/TClass_8cxx_source.html
https://root.cern/doc/v632/TClass_8cxx_source.html:238454,Availability,down,downside,238454,"o);; 6168 // Must set this last since other threads may read fProperty; 6169 // and think all test bits have been properly set.; 6170 kl->fProperty = gCling->ClassInfo_Property(fClassInfo);; 6171 }; 6172 } else {; 6173 ; 6174 if (fStreamer) {; 6175 kl->fStreamerType = kExternal;; 6176 kl->fStreamerImpl = &TClass::StreamerExternal;; 6177 }; 6178 ; 6179 kl->fStreamerType |= kEmulatedStreamer;; 6180 kl->SetStreamerImpl();; 6181 // fProperty was *not* set so that it can be forced to be recalculated; 6182 // next time.; 6183 return 0;; 6184 }; 6185 ; 6186 return fProperty;; 6187}; 6188 ; 6189////////////////////////////////////////////////////////////////////////////////; 6190/// Internal routine to set calculate the class properties that can only be; 6191/// known at run-time, for example whether the Hash member function and the; 6192/// destructor are consistent.; 6193 ; 6194void TClass::SetRuntimeProperties(); 6195{; 6196 // For now, no need to lock this routines as fRuntimeProperties is; 6197 // the only atomic set here and this is done at the end; 6198 // and there is no downside if the execution is done twice.; 6199 ; 6200 // Note SetRuntimeProperties is set to const as it is technically; 6201 // thread-safe.; 6202 ; 6203 UChar_t properties = static_cast<UChar_t>(ERuntimeProperties::kSet);; 6204 ; 6205 if (ROOT::Internal::TCheckHashRecursiveRemoveConsistency::Check(*this)); 6206 properties |= static_cast<UChar_t>(ERuntimeProperties::kConsistentHash);; 6207 ; 6208 const_cast<TClass *>(this)->fRuntimeProperties = properties;; 6209}; 6210 ; 6211////////////////////////////////////////////////////////////////////////////////; 6212/// Internal routine to set fStreamerImpl based on the value of; 6213/// fStreamerType.; 6214 ; 6215void TClass::SetStreamerImpl(); 6216{; 6217 switch (fStreamerType) {; 6218 case kTObject: fStreamerImpl = &TClass::StreamerTObject; break;; 6219 case kForeign: fStreamerImpl = &TClass::StreamerStreamerInfo; break;; 6220 case kExternal: fStreamer",MatchSource.WIKI,doc/v632/TClass_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/TClass_8cxx_source.html
https://root.cern/doc/v632/TClass_8cxx_source.html:253499,Availability,avail,available,253499,"l implementation detail.; 6578 TList *tlb = ((TClass*)this)->GetListOfBases();; 6579 if (tlb && !GetCollectionProxy() && !TClassEdit::IsStdPair(GetName())) {; 6580 // Loop over bases if not a proxied collection or a pair; 6581 ; 6582 TIter nextBase(tlb);; 6583 ; 6584 TBaseClass *tbc=nullptr;; 6585 while((tbc=(TBaseClass*)nextBase())) {; 6586 name = tbc->GetName();; 6587 Bool_t isSTL = TClassEdit::IsSTLCont(name);; 6588 if (isSTL); 6589 name = TClassEdit::ShortType( name, TClassEdit::kDropStlDefault );; 6590 il = name.Length();; 6591 for (int i=0; i<il; i++) id = id*3+name[i];; 6592 if (code > kNoBaseCheckSum && !isSTL) {; 6593 if (tbc->GetClassPointer() == nullptr) {; 6594 Error(""GetCheckSum"",""Calculating the checksum for (%s) requires the base class (%s) meta information to be available!"",; 6595 GetName(),tbc->GetName());; 6596 isvalid = kFALSE;; 6597 return 0;; 6598 } else; 6599 id = id*3 + tbc->GetClassPointer()->GetCheckSum();; 6600 }; 6601 }/*EndBaseLoop*/; 6602 }; 6603 TList *tlm = ((TClass*)this)->GetListOfDataMembers();; 6604 if (tlm) { // Loop over members; 6605 TIter nextMemb(tlm);; 6606 TDataMember *tdm=nullptr;; 6607 Long_t prop = 0;; 6608 while((tdm=(TDataMember*)nextMemb())) {; 6609 if (!tdm->IsPersistent()) continue;; 6610 // combine properties; 6611 prop = (tdm->Property());; 6612 TDataType* tdt = tdm->GetDataType();; 6613 if (tdt) prop |= tdt->Property();; 6614 ; 6615 if ( prop&kIsStatic) continue;; 6616 name = tdm->GetName(); il = name.Length();; 6617 if ( (code > kNoEnum) && code != kReflex && code != kReflexNoComment && prop&kIsEnum); 6618 id = id*3 + 1;; 6619 ; 6620 int i;; 6621 for (i=0; i<il; i++) id = id*3+name[i];; 6622 ; 6623 if (code > kWithTypeDef || code == kReflexNoComment) {; 6624 type = tdm->GetTrueTypeName();; 6625 // GetTrueTypeName uses GetFullyQualifiedName which already drops; 6626 // the default template parameter, so we no longer need to do this.; 6627 //if (TClassEdit::IsSTLCont(type)); 6628 // type = TClassEdit::ShortType( typ",MatchSource.WIKI,doc/v632/TClass_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/TClass_8cxx_source.html
https://root.cern/doc/v632/TClass_8cxx_source.html:319656,Availability,avail,available,319656,"Bool_t HasNoInfoOrEmuOrFwdDeclaredDecl(const char *)Definition TClass.cxx:3398; TClass::fOVRMutexTVirtualMutex * fOVRMutexDefinition TClass.h:342; TClass::GetListOfEnumsTList * GetListOfEnums(Bool_t load=kTRUE)Return a list containing the TEnums of a class.Definition TClass.cxx:3686; TClass::IsStartingWithTObjectBool_t IsStartingWithTObject() constReturns true if this class inherits from TObject and if the start of the TObject parts is at the very...Definition TClass.cxx:5929; TClass::GetListOfMethodsTList * GetListOfMethods(Bool_t load=kTRUE)Return list containing the TMethods of a class.Definition TClass.cxx:3812; TClass::TClassTClass()Internal, default constructor.Definition TClass.cxx:1065; TClass::fDeclFileLineShort_t fDeclFileLineDefinition TClass.h:215; TClass::GetNmethodsInt_t GetNmethods()Return the number of methods of this class Note that in case the list of methods is not yet created,...Definition TClass.cxx:4573; TClass::fIsOffsetStreamerSetstd::atomic< Bool_t > fIsOffsetStreamerSetIndicates whether the ClassInfo is supposed to be available.Definition TClass.h:261; TClass::IgnoreTObjectStreamervoid IgnoreTObjectStreamer(Bool_t ignore=kTRUE)When the class kIgnoreTObjectStreamer bit is set, the automatically generated Streamer will not call ...Definition TClass.cxx:4841; TClass::GetStreamerTClassStreamer * GetStreamer() constReturn the Streamer Class allowing streaming (if any).Definition TClass.cxx:2914; TClass::GetIdMapstatic IdMap_t * GetIdMap()Definition TClass.cxx:469; TClass::SetDeletevoid SetDelete(ROOT::DelFunc_t deleteFunc)Install a new wrapper around 'delete'.Definition TClass.cxx:7001; TClass::AutoBrowsestatic Int_t AutoBrowse(TObject *obj, TBrowser *browser)Browse external object inherited from TObject.Definition TClass.cxx:1966; TClass::GetNewROOT::NewFunc_t GetNew() constReturn the wrapper around new ThisClass().Definition TClass.cxx:7447; TClass::GetBaseClassTClass * GetBaseClass(const char *classname)Return pointer to the base class ""class",MatchSource.WIKI,doc/v632/TClass_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/TClass_8cxx_source.html
https://root.cern/doc/v632/TClass_8cxx_source.html:321338,Availability,avail,available,321338,"wser)Browse external object inherited from TObject.Definition TClass.cxx:1966; TClass::GetNewROOT::NewFunc_t GetNew() constReturn the wrapper around new ThisClass().Definition TClass.cxx:7447; TClass::GetBaseClassTClass * GetBaseClass(const char *classname)Return pointer to the base class ""classname"".Definition TClass.cxx:2655; TClass::GetDataMemberOffsetLongptr_t GetDataMemberOffset(const char *membername) constreturn offset for member name.Definition TClass.cxx:3477; TClass::GetNdataInt_t GetNdata()Return the number of data members of this class Note that in case the list of data members is not yet...Definition TClass.cxx:4554; TClass::SetDestructorvoid SetDestructor(ROOT::DesFunc_t destructorFunc)Install a new wrapper around the destructor.Definition TClass.cxx:7017; TClass::PostLoadCheckvirtual void PostLoadCheck()Do the initialization that can only be done after the CINT dictionary has been fully populated and ca...Definition TClass.cxx:5959; TClass::LoadClassInfovoid LoadClassInfo() constTry to load the ClassInfo if available.Definition TClass.cxx:5824; TClass::SetResetAfterMergevoid SetResetAfterMerge(ROOT::ResetAfterMergeFunc_t resetFunc)Install a new wrapper around 'ResetAfterMerge'.Definition TClass.cxx:6977; TClass::GetStreamerInfoImplTVirtualStreamerInfo * GetStreamerInfoImpl(Int_t version, Bool_t silent) constDefinition TClass.cxx:4634; TClass::MatchLegacyCheckSumBool_t MatchLegacyCheckSum(UInt_t checksum) constReturn true if the checksum passed as argument is one of the checksum value produced by the older che...Definition TClass.cxx:6494; TClass::fAllPubMethodTViewPubFunctions * fAllPubMethodDefinition TClass.h:210; TClass::ERuntimeProperties::kSet@ kSet; TClass::ERuntimeProperties::kConsistentHash@ kConsistentHash; TClass::HasInterpreterInfoBool_t HasInterpreterInfo() constDefinition TClass.h:410; TClass::AddClassstatic void AddClass(TClass *cl)static: Add a class to the list and map of classes.Definition TClass.cxx:494; TClass::GetMissingDictionarie",MatchSource.WIKI,doc/v632/TClass_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/TClass_8cxx_source.html
https://root.cern/doc/v632/TClass_8cxx_source.html:355528,Availability,avail,available,355528,"ates.h:40; TListOfFunctionTemplates::FindObjectTObject * FindObject(const char *name) const overrideSpecialize FindObject to do search for the a function just by name or create it if its not already in...Definition TListOfFunctionTemplates.cxx:175; TListOfFunctionTemplates::Loadvoid Load()Load all the functions known to the interpreter for the scope 'fClass' into this collection.Definition TListOfFunctionTemplates.cxx:356; TListOfFunctionTemplates::Deletevoid Delete(Option_t *option="""") overrideDelete all TFunction object files.Definition TListOfFunctionTemplates.cxx:164; TListOfFunctionsA collection of TFunction objects designed for fast access given a DeclId_t and for keep track of TFu...Definition TListOfFunctions.h:35; TListOfFunctions::GetTFunction * Get(DeclId_t id)Return (after creating it if necessary) the TMethod or TFunction describing the function correspondin...Definition TListOfFunctions.cxx:262; TListOfFunctions::GetListForObjectvirtual TList * GetListForObject(const char *name) constReturn the set of overloads for this name, collecting all available ones.Definition TListOfFunctions.cxx:230; TListOfFunctions::FindObjectTObject * FindObject(const TObject *obj) const overrideFind object using its hash value (returned by its Hash() member).Definition TListOfFunctions.cxx:443; TListA doubly linked list.Definition TList.h:38; TList::FindObjectTObject * FindObject(const char *name) const overrideFind an object in this list using its name.Definition TList.cxx:576; TList::Addvoid Add(TObject *obj) overrideDefinition TList.h:83; TList::RemoveTObject * Remove(TObject *obj) overrideRemove object from the list.Definition TList.cxx:820; TList::AddLastvoid AddLast(TObject *obj) overrideAdd object at the end of the list.Definition TList.cxx:150; TList::FirstLinkvirtual TObjLink * FirstLink() constDefinition TList.h:104; TList::Deletevoid Delete(Option_t *option="""") overrideRemove all objects from the list AND delete all heap based objects.Definition TList.cxx:468; TL",MatchSource.WIKI,doc/v632/TClass_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/TClass_8cxx_source.html
https://root.cern/doc/v632/TClass_8cxx_source.html:361430,Availability,error,error,361430,"ject. May be overridden for another default action.Definition TObject.cxx:198; TObject::TestBitR__ALWAYS_INLINE Bool_t TestBit(UInt_t f) constDefinition TObject.h:199; TObject::Streamervirtual void Streamer(TBuffer &)Stream an object of class TObject.Definition TObject.cxx:888; TObject::Warningvirtual void Warning(const char *method, const char *msgfmt,...) constIssue warning message.Definition TObject.cxx:973; TObject::FindObjectvirtual TObject * FindObject(const char *name) constMust be redefined in derived classes.Definition TObject.cxx:403; TObject::Classstatic TClass * Class(); TObject::IsZombieR__ALWAYS_INLINE Bool_t IsZombie() constDefinition TObject.h:153; TObject::SetBitvoid SetBit(UInt_t f, Bool_t set)Set or unset the user status bits as specified in f.Definition TObject.cxx:780; TObject::GetObjectStatstatic Bool_t GetObjectStat()Get status of object stat flag.Definition TObject.cxx:1061; TObject::Errorvirtual void Error(const char *method, const char *msgfmt,...) constIssue error message.Definition TObject.cxx:987; TObject::Fatalvirtual void Fatal(const char *method, const char *msgfmt,...) constIssue fatal error message.Definition TObject.cxx:1015; TObject::SetUniqueIDvirtual void SetUniqueID(UInt_t uid)Set the unique object id.Definition TObject.cxx:791; TObject::IsAvirtual TClass * IsA() constDefinition TObject.h:243; TObject::MakeZombievoid MakeZombie()Definition TObject.h:53; TObject::ResetBitvoid ResetBit(UInt_t f)Definition TObject.h:198; TObject::Infovirtual void Info(const char *method, const char *msgfmt,...) constIssue info message.Definition TObject.cxx:961; TPairClass used by TMap to store (key,value) pairs.Definition TMap.h:102; TProtoClassPersistent version of a TClass.Definition TProtoClass.h:38; TROOT::GetEtcDirstatic const TString & GetEtcDir()Get the sysconfig directory in the installation. Static utility function.Definition TROOT.cxx:3052; TRealDataThe TRealData class manages the effective list of all data members for a given class.Defi",MatchSource.WIKI,doc/v632/TClass_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/TClass_8cxx_source.html
https://root.cern/doc/v632/TClass_8cxx_source.html:361566,Availability,error,error,361566," f) constDefinition TObject.h:199; TObject::Streamervirtual void Streamer(TBuffer &)Stream an object of class TObject.Definition TObject.cxx:888; TObject::Warningvirtual void Warning(const char *method, const char *msgfmt,...) constIssue warning message.Definition TObject.cxx:973; TObject::FindObjectvirtual TObject * FindObject(const char *name) constMust be redefined in derived classes.Definition TObject.cxx:403; TObject::Classstatic TClass * Class(); TObject::IsZombieR__ALWAYS_INLINE Bool_t IsZombie() constDefinition TObject.h:153; TObject::SetBitvoid SetBit(UInt_t f, Bool_t set)Set or unset the user status bits as specified in f.Definition TObject.cxx:780; TObject::GetObjectStatstatic Bool_t GetObjectStat()Get status of object stat flag.Definition TObject.cxx:1061; TObject::Errorvirtual void Error(const char *method, const char *msgfmt,...) constIssue error message.Definition TObject.cxx:987; TObject::Fatalvirtual void Fatal(const char *method, const char *msgfmt,...) constIssue fatal error message.Definition TObject.cxx:1015; TObject::SetUniqueIDvirtual void SetUniqueID(UInt_t uid)Set the unique object id.Definition TObject.cxx:791; TObject::IsAvirtual TClass * IsA() constDefinition TObject.h:243; TObject::MakeZombievoid MakeZombie()Definition TObject.h:53; TObject::ResetBitvoid ResetBit(UInt_t f)Definition TObject.h:198; TObject::Infovirtual void Info(const char *method, const char *msgfmt,...) constIssue info message.Definition TObject.cxx:961; TPairClass used by TMap to store (key,value) pairs.Definition TMap.h:102; TProtoClassPersistent version of a TClass.Definition TProtoClass.h:38; TROOT::GetEtcDirstatic const TString & GetEtcDir()Get the sysconfig directory in the installation. Static utility function.Definition TROOT.cxx:3052; TRealDataThe TRealData class manages the effective list of all data members for a given class.Definition TRealData.h:30; TRealData::GetNameconst char * GetName() const overrideReturns name of object.Definition TRealData.h:52; TReal",MatchSource.WIKI,doc/v632/TClass_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/TClass_8cxx_source.html
https://root.cern/doc/v632/TClass_8cxx_source.html:376651,Availability,error,errorCode,376651,"n Rtypes.h:112; ROOT::NewFunc_tvoid *(* NewFunc_t)(void *)Definition Rtypes.h:109; ROOT::MergeFunc_tLong64_t(* MergeFunc_t)(void *, TCollection *, TFileMergeInfo *)Definition Rtypes.h:115; TClassEdit::IsStdPairBasebool IsStdPairBase(std::string_view name)Definition TClassEdit.h:188; TClassEdit::ResolveTypedefstd::string ResolveTypedef(const char *tname, bool resolveAll=false)Definition TClassEdit.cxx:1748; TClassEdit::IsStdArraybool IsStdArray(std::string_view name)Definition TClassEdit.h:183; TClassEdit::IsStdClassbool IsStdClass(const char *type)return true if the class belongs to the std namespaceDefinition TClassEdit.cxx:1418; TClassEdit::IsStdPairbool IsStdPair(std::string_view name)Definition TClassEdit.h:184; TClassEdit::IsInterpreterDetailbool IsInterpreterDetail(const char *type)Return true if the type is one the interpreter details which are only forward declared (ClassInfo_t e...Definition TClassEdit.cxx:1322; TClassEdit::DemangleTypeIdNamechar * DemangleTypeIdName(const std::type_info &ti, int &errorCode)Demangle in a portable way the type id name.Definition TClassEdit.cxx:2147; TClassEdit::IsSTLContROOT::ESTLType IsSTLCont(std::string_view type)type : type name: vector<list<classA,allocator>,allocator> result: 0 : not stl container code of cont...Definition TClassEdit.cxx:1378; TClassEdit::ShortTypestd::string ShortType(const char *typeDesc, int mode)Return the absolute type of typeDesc.Definition TClassEdit.cxx:1305; TClassEdit::IsArtificialbool IsArtificial(std::string_view name)Definition TClassEdit.h:159; TClassEdit::GetNormalizedNamevoid GetNormalizedName(std::string &norm_name, std::string_view name)Return the normalized name.Definition TClassEdit.cxx:854; TClassEdit::kDropTrailStar@ kDropTrailStarDefinition TClassEdit.h:77; TClassEdit::kDropStlDefault@ kDropStlDefaultDefinition TClassEdit.h:82; TClassEdit::IsSTLBitsetbool IsSTLBitset(const char *type)Return true is the name is std::bitset<number> or bitset<number>Definition TClassEdit.cxx:1340; TM",MatchSource.WIKI,doc/v632/TClass_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/TClass_8cxx_source.html
https://root.cern/doc/v632/TClass_8cxx_source.html:54163,Deployability,update,update,54163,"char *ifil, Int_t dl, Int_t il,; 1372 ClassInfo_t *givenInfo,; 1373 Bool_t silent); 1374{; 1375 if (!gROOT); 1376 ::Fatal(""TClass::TClass"", ""ROOT system not initialized"");; 1377 if (!name || !name[0]) {; 1378 ::Error(""TClass::Init"", ""The name parameter is invalid (null or empty)"");; 1379 MakeZombie();; 1380 return;; 1381 }; 1382 // Always strip the default STL template arguments (from any template argument or the class name); 1383 if (TClassEdit::IsArtificial(name)); 1384 fName = name; // We can assume that the artificial class name is already normalized.; 1385 else; 1386 fName = TClassEdit::ShortType(name, TClassEdit::kDropStlDefault).c_str();; 1387 ; 1388 fClassVersion = cversion;; 1389 fDeclFileName = dfil ? dfil : """";; 1390 fImplFileName = ifil ? ifil : """";; 1391 fDeclFileLine = dl;; 1392 fImplFileLine = il;; 1393 fTypeInfo = typeinfo;; 1394 fIsA = isa;; 1395 if ( fIsA ) fIsA->SetClass(this);; 1396 // See also TCling::GenerateTClass() which will update fClassVersion after creation!; 1397 fStreamerInfo = new TObjArray(fClassVersion+2+10,-1); // +10 to read new data by old; 1398 fProperty = -1;; 1399 fClassProperty = 0;; 1400 const bool ispair = TClassEdit::IsStdPair(fName);; 1401 if (ispair); 1402 SetBit(kIsForeign);; 1403 ; 1404 ResetInstanceCount();; 1405 ; 1406 TClass *oldcl = (TClass*)gROOT->GetListOfClasses()->FindObject(fName.Data());; 1407 ; 1408 InsertTClassInRegistryRAII insertRAII(fState,fName,fNoInfoOrEmuOrFwdDeclNameRegistry);; 1409 ; 1410 if (oldcl && oldcl->TestBit(kLoading)) {; 1411 // Do not recreate a class while it is already being created!; 1412 ; 1413 // We can no longer reproduce this case, to check whether we are, we use; 1414 // this code:; 1415 // Fatal(""Init"",""A bad replacement for %s was requested\n"",name);; 1416 return;; 1417 }; 1418 ; 1419 TClass **persistentRef = nullptr;; 1420 if (oldcl) {; 1421 ; 1422 persistentRef = oldcl->fPersistentRef.exchange(nullptr);; 1423 ; 1424 // The code from here is also in ForceReload.; 1425 TClass::Remo",MatchSource.WIKI,doc/v632/TClass_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/TClass_8cxx_source.html
https://root.cern/doc/v632/TClass_8cxx_source.html:55295,Deployability,update,updated,55295,"ass *oldcl = (TClass*)gROOT->GetListOfClasses()->FindObject(fName.Data());; 1407 ; 1408 InsertTClassInRegistryRAII insertRAII(fState,fName,fNoInfoOrEmuOrFwdDeclNameRegistry);; 1409 ; 1410 if (oldcl && oldcl->TestBit(kLoading)) {; 1411 // Do not recreate a class while it is already being created!; 1412 ; 1413 // We can no longer reproduce this case, to check whether we are, we use; 1414 // this code:; 1415 // Fatal(""Init"",""A bad replacement for %s was requested\n"",name);; 1416 return;; 1417 }; 1418 ; 1419 TClass **persistentRef = nullptr;; 1420 if (oldcl) {; 1421 ; 1422 persistentRef = oldcl->fPersistentRef.exchange(nullptr);; 1423 ; 1424 // The code from here is also in ForceReload.; 1425 TClass::RemoveClass(oldcl);; 1426 // move the StreamerInfo immediately so that there are; 1427 // properly updated!; 1428 ; 1429 if (oldcl->CanIgnoreTObjectStreamer()) {; 1430 IgnoreTObjectStreamer();; 1431 }; 1432 TVirtualStreamerInfo *info;; 1433 ; 1434 TIter next(oldcl->GetStreamerInfos());; 1435 while ((info = (TVirtualStreamerInfo*)next())) {; 1436 // We need to force a call to BuildOld; 1437 info->Clear(""build"");; 1438 info->SetClass(this);; 1439 fStreamerInfo->AddAtAndExpand(info,info->GetClassVersion());; 1440 }; 1441 oldcl->fStreamerInfo->Clear();; 1442 // The code diverges here from ForceReload.; 1443 ; 1444 // Move the Schema Rules too.; 1445 fSchemaRules = oldcl->fSchemaRules;; 1446 oldcl->fSchemaRules = nullptr;; 1447 ; 1448 // Move the TFunctions.; 1449 fFuncTemplate = oldcl->fFuncTemplate;; 1450 if (fFuncTemplate); 1451 fFuncTemplate->fClass = this;; 1452 oldcl->fFuncTemplate = nullptr;; 1453 fMethod.store( oldcl->fMethod );; 1454 if (fMethod); 1455 (*fMethod).fClass = this;; 1456 oldcl->fMethod = nullptr;; 1457 ; 1458 }; 1459 ; 1460 SetBit(kLoading);; 1461 // Advertise ourself as the loading class for this class name; 1462 TClass::AddClass(this);; 1463 ; 1464 Bool_t isStl = TClassEdit::IsSTLCont(fName);; 1465 ; 1466 if (!gInterpreter); 1467 ::Fatal(""TClass::Init"", ""g",MatchSource.WIKI,doc/v632/TClass_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/TClass_8cxx_source.html
https://root.cern/doc/v632/TClass_8cxx_source.html:70920,Deployability,update,updated,70920,"]; 1872/// [target=""membername3;membername4""] [attributes=... ] [version=...] [checksum=...] [code={...}|functionname]; 1873/// ~~~; 1874///; 1875/// For example to set HepMC::GenVertex::m_event to _not_ owned the object it is pointing to:; 1876/// HepMC::GenVertex m_event attributes=NotOwner; 1877///; 1878/// Semantic of the tags:; 1879/// - type : the type of the rule, valid values: Read, ReadRaw, Write, WriteRaw, the default is 'Read'.; 1880/// - sourceClass : the name of the class as it is on the rule file; 1881/// - targetClass : the name of the class as it is in the current code ; defaults to the value of sourceClass; 1882/// - source : the types and names of the data members from the class on file that are needed, the list is separated by semi-colons ';'; 1883/// - oldtype: in the short form only, indicates the type on disk of the data member.; 1884/// - target : the names of the data members updated by this rule, the list is separated by semi-colons ';'; 1885/// - attributes : list of possible qualifiers among: Owner, NotOwner; 1886/// - version : list of the version of the class layout that this rule applies to. The syntax can be [1,4,5] or [2-] or [1-3] or [-3]; 1887/// - checksum : comma delimited list of the checksums of the class layout that this rule applies to.; 1888/// - code={...} : code to be executed for the rule or name of the function implementing it.; 1889 ; 1890Bool_t TClass::AddRule( const char *rule ); 1891{; 1892 ROOT::TSchemaRule *ruleobj = new ROOT::TSchemaRule();; 1893 if (! ruleobj->SetFromRule( rule ) ) {; 1894 delete ruleobj;; 1895 return kFALSE;; 1896 }; 1897 ; 1898 R__LOCKGUARD(gInterpreterMutex);; 1899 ; 1900 TClass *cl = TClass::GetClass( ruleobj->GetTargetClass() );; 1901 if (!cl) {; 1902 // Create an empty emulated class for now.; 1903 cl = gInterpreter->GenerateTClass(ruleobj->GetTargetClass(), /* emulation = */ kTRUE, /*silent = */ kTRUE);; 1904 }; 1905 ROOT::Detail::TSchemaRuleSet* rset = cl->GetSchemaRules( kTRUE );; 1906 ; ",MatchSource.WIKI,doc/v632/TClass_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/TClass_8cxx_source.html
https://root.cern/doc/v632/TClass_8cxx_source.html:112149,Deployability,release,release,112149,"/ (typically used for classes that are used only for transient members); 2966/// Returns `nullptr` in case class is not found.; 2967 ; 2968TClass *TClass::GetClass(const char *name, Bool_t load, Bool_t silent); 2969{; 2970 return TClass::GetClass(name, load, silent, 0, 0);; 2971}; 2972 ; 2973TClass *TClass::GetClass(const char *name, Bool_t load, Bool_t silent, size_t hint_pair_offset, size_t hint_pair_size); 2974{; 2975 if (!name || !name[0]) return nullptr;; 2976 ; 2977 if (strstr(name, ""(anonymous)"")) return nullptr;; 2978 if (strstr(name, ""(unnamed)"")) return nullptr;; 2979 if (strncmp(name,""class "",6)==0) name += 6;; 2980 if (strncmp(name,""struct "",7)==0) name += 7;; 2981 ; 2982 if (!gROOT->GetListOfClasses()) return nullptr;; 2983 ; 2984 // FindObject will take the read lock before actually getting the; 2985 // TClass pointer so we will need not get a partially initialized; 2986 // object.; 2987 TClass *cl = (TClass*)gROOT->GetListOfClasses()->FindObject(name);; 2988 ; 2989 // Early return to release the lock without having to execute the; 2990 // long-ish normalization.; 2991 if (cl && (cl->IsLoaded() || cl->TestBit(kUnloading))) return cl;; 2992 ; 2993 R__WRITE_LOCKGUARD(ROOT::gCoreMutex);; 2994 ; 2995 // Now that we got the write lock, another thread may have constructed the; 2996 // TClass while we were waiting, so we need to do the checks again.; 2997 ; 2998 cl = (TClass*)gROOT->GetListOfClasses()->FindObject(name);; 2999 if (cl) {; 3000 if (cl->IsLoaded() || cl->TestBit(kUnloading)) return cl;; 3001 ; 3002 // We could speed-up some of the search by adding (the equivalent of); 3003 //; 3004 // if (cl->GetState() == kInterpreter) return cl; 3005 //; 3006 // In this case, if a ROOT dictionary was available when the TClass; 3007 // was first requested it would have been used and if a ROOT dictionary is; 3008 // loaded later on TClassTable::Add will take care of updating the TClass.; 3009 // So as far as ROOT dictionary are concerned, if the current TClass is;",MatchSource.WIKI,doc/v632/TClass_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/TClass_8cxx_source.html
https://root.cern/doc/v632/TClass_8cxx_source.html:156986,Deployability,update,update,156986,"nt kind of elements the check would be required.; 4119 TClass* t = nullptr;; 4120 if ((t = GetCollectionProxy()->GetValueClass())) {; 4121 if (!t->HasDictionary()) {; 4122 t->GetMissingDictionariesWithRecursionCheck(result, visited, recurse);; 4123 }; 4124 }; 4125 } else {; 4126 GetMissingDictionariesForMembers(result, visited, recurse);; 4127 GetMissingDictionariesForBaseClasses(result, visited, recurse);; 4128 }; 4129 }; 4130}; 4131 ; 4132////////////////////////////////////////////////////////////////////////////////; 4133/// Return kTRUE if the class has elements.; 4134 ; 4135Bool_t TClass::IsFolder(void *obj) const; 4136{; 4137 return Browse(obj,(TBrowser*)nullptr);; 4138}; 4139 ; 4140//______________________________________________________________________________; 4141//______________________________________________________________________________; 4142void TClass::ReplaceWith(TClass *newcl) const; 4143{; 4144 // Inform the other objects to replace this object by the new TClass (newcl); 4145 ; 4146 R__LOCKGUARD(gInterpreterMutex);; 4147 //we must update the class pointers pointing to 'this' in all TStreamerElements; 4148 TIter nextClass(gROOT->GetListOfClasses());; 4149 TClass *acl;; 4150 TVirtualStreamerInfo *info;; 4151 ; 4152 // Since we are in the process of replacing a TClass by a TClass; 4153 // coming from a dictionary, there is no point in loading any; 4154 // libraries during this search.; 4155 TInterpreter::SuspendAutoLoadingRAII autoloadOff(gInterpreter);; 4156 while ((acl = (TClass*)nextClass())) {; 4157 if (acl == newcl) continue;; 4158 ; 4159 TIter nextInfo(acl->GetStreamerInfos());; 4160 while ((info = (TVirtualStreamerInfo*)nextInfo())) {; 4161 ; 4162 info->Update(this, newcl);; 4163 }; 4164 }; 4165 ; 4166 gInterpreter->UnRegisterTClassUpdate(this);; 4167}; 4168 ; 4169////////////////////////////////////////////////////////////////////////////////; 4170/// Make sure that the current ClassInfo is up to date.; 4171 ; 4172void TClass::ResetClassIn",MatchSource.WIKI,doc/v632/TClass_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/TClass_8cxx_source.html
https://root.cern/doc/v632/TClass_8cxx_source.html:165048,Deployability,release,release,165048,"tMenuList() const {; 4342 if (!fClassMenuList) {; 4343 fClassMenuList = new TList();; 4344 fClassMenuList->Add(new TClassMenuItem(TClassMenuItem::kPopupStandardList, const_cast<TClass*>(this)));; 4345 }; 4346 return fClassMenuList;; 4347}; 4348 ; 4349////////////////////////////////////////////////////////////////////////////////; 4350/// Return (create an empty one if needed) the list of functions.; 4351/// The major difference with GetListOfMethod is that this returns; 4352/// the internal type of fMethod and thus can not be made public.; 4353/// It also never 'loads' the content of the list.; 4354 ; 4355TListOfFunctions *TClass::GetMethodList(); 4356{; 4357 if (!fMethod.load()) {; 4358 std::unique_ptr<TListOfFunctions> temp{ new TListOfFunctions(this) };; 4359 TListOfFunctions* expected = nullptr;; 4360 if(fMethod.compare_exchange_strong(expected, temp.get()) ) {; 4361 temp.release();; 4362 }; 4363 }; 4364 return fMethod;; 4365}; 4366 ; 4367 ; 4368////////////////////////////////////////////////////////////////////////////////; 4369/// Return pointer to method without looking at parameters.; 4370/// Does not look in (possible) base classes.; 4371/// Has the side effect of loading all the TMethod object in the list; 4372/// of the class.; 4373 ; 4374TMethod *TClass::GetMethodAny(const char *method); 4375{; 4376 if (!HasInterpreterInfo()) return nullptr;; 4377 return (TMethod*) GetMethodList()->FindObject(method);; 4378}; 4379 ; 4380////////////////////////////////////////////////////////////////////////////////; 4381/// Return pointer to method without looking at parameters.; 4382/// Does look in all base classes.; 4383 ; 4384TMethod *TClass::GetMethodAllAny(const char *method); 4385{; 4386 if (!HasInterpreterInfo()) return nullptr;; 4387 ; 4388 TMethod* m = GetMethodAny(method);; 4389 if (m) return m;; 4390 ; 4391 TBaseClass *base;; 4392 TIter nextb(GetListOfBases());; 4393 while ((base = (TBaseClass *) nextb())) {; 4394 TClass *c = base->GetClassPointer();; 4395",MatchSource.WIKI,doc/v632/TClass_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/TClass_8cxx_source.html
https://root.cern/doc/v632/TClass_8cxx_source.html:231216,Deployability,update,update,231216,"""PostLoadCheck"",""\n\; 5997 The class %s transitioned from not having a specified class version\n\; 5998 to having a specified class version (the current class version is %d).\n\; 5999 However too many different non-versioned layouts of the class have\n\; 6000 already been loaded so far. To work around this problem you can\n\; 6001 load fewer 'old' file in the same ROOT session or load the C++ library\n\; 6002 describing the class %s before opening the files or increase the version\n\; 6003 number of the class for example ClassDef(%s,%d).\n\; 6004 Do not try to write objects with the current class definition,\n\; 6005 the files might not be readable.\n"",; 6006 GetName(), fClassVersion, GetName(), GetName(), fStreamerInfo->GetLast()+1);; 6007 } else {; 6008 Warning(""PostLoadCheck"",""\n\; 6009 The StreamerInfo version %d for the class %s which was read\n\; 6010 from a file previously opened has the same version as the active class\n\; 6011 but a different checksum. You should update the version to ClassDef(%s,%d).\n\; 6012 Do not try to write objects with the current class definition,\n\; 6013 the files will not be readable.\n""; 6014 , fClassVersion, GetName(), GetName(), fStreamerInfo->GetLast()+1);; 6015 }; 6016 info->CompareContent(this,nullptr,kTRUE,kTRUE,nullptr);; 6017 SetBit(kWarned);; 6018 }; 6019 }; 6020 }; 6021 if (fCollectionProxy) {; 6022 // Update the related pair's TClass if it has already been created.; 6023 size_t noffset = 0;; 6024 if (strncmp(GetName(), ""map<"", 4) == 0); 6025 noffset = 3;; 6026 else if (strncmp(GetName(), ""multimap<"", 9) == 0); 6027 noffset = 8;; 6028 else if (strncmp(GetName(), ""unordered_map<"", 14) == 0); 6029 noffset = 13;; 6030 else if (strncmp(GetName(), ""unordered_multimap<"", 19) == 0); 6031 noffset = 18;; 6032 if (noffset) {; 6033 std::string pairname(""pair"");; 6034 pairname.append(GetName() + noffset);; 6035 auto pcl = TClass::GetClass(pairname.c_str(), false, false);; 6036 if ( pcl && !pcl->IsLoaded() && !pcl->IsSyntheticPair(",MatchSource.WIKI,doc/v632/TClass_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/TClass_8cxx_source.html
https://root.cern/doc/v632/TClass_8cxx_source.html:241681,Deployability,install,installs,241681,"nProxyInfo &info); 6245{; 6246 R__LOCKGUARD(gInterpreterMutex);; 6247 ; 6248 delete fCollectionProxy;; 6249 ; 6250 // We can not use GetStreamerInfo() instead of TVirtualStreamerInfo::Factory(); 6251 // because GetStreamerInfo call TStreamerInfo::Build which need to have fCollectionProxy; 6252 // set correctly.; 6253 ; 6254 TVirtualCollectionProxy *p = TVirtualStreamerInfo::Factory()->GenExplicitProxy(info,this);; 6255 fCollectionProxy = p;; 6256 ; 6257 AdoptStreamer(TVirtualStreamerInfo::Factory()->GenExplicitClassStreamer(info,this));; 6258 ; 6259 if (fCollectionProxy && !fSchemaRules) {; 6260 // Numeric Collections have implicit conversions:; 6261 GetSchemaRules(kTRUE);; 6262 }; 6263 fCanSplit = -1;; 6264}; 6265 ; 6266////////////////////////////////////////////////////////////////////////////////; 6267/// Change (i.e. set) the title of the TNamed.; 6268 ; 6269void TClass::SetContextMenuTitle(const char *title); 6270{; 6271 fContextMenuTitle = title;; 6272}; 6273 ; 6274////////////////////////////////////////////////////////////////////////////////; 6275/// This function installs a global IsA function for this class.; 6276/// The global IsA function will be used if there is no local IsA function (fIsA); 6277///; 6278/// A global IsA function has the signature:; 6279///; 6280/// ~~~ {.cpp}; 6281/// TClass *func( TClass *cl, const void *obj);; 6282/// ~~~; 6283///; 6284/// 'cl' is a pointer to the TClass object that corresponds to the; 6285/// 'pointer type' used to retrieve the value 'obj'; 6286///; 6287/// For example with:; 6288/// ~~~ {.cpp}; 6289/// TNamed * m = new TNamed(""example"",""test"");; 6290/// TObject* o = m; 6291/// ~~~; 6292/// and; 6293/// the global IsA function would be called with TObject::Class() as; 6294/// the first parameter and the exact numerical value in the pointer; 6295/// 'o'.; 6296///; 6297/// In other word, inside the global IsA function. it is safe to C-style; 6298/// cast the value of 'obj' into a pointer to the class described by 'c",MatchSource.WIKI,doc/v632/TClass_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/TClass_8cxx_source.html
https://root.cern/doc/v632/TClass_8cxx_source.html:245418,Deployability,update,update,245418,,MatchSource.WIKI,doc/v632/TClass_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/TClass_8cxx_source.html
https://root.cern/doc/v632/TClass_8cxx_source.html:246941,Deployability,update,update,246941,"trlcpy(temp,info,10000);; 6388 //remove heading and trailing blanks; 6389 while (*temp == ' ') temp++;; 6390 while (save[nch-1] == ' ') {nch--; save[nch] = 0;}; 6391 if (nch == 0) {delete [] save; return;}; 6392 if (save[nch-1] != ';') {save[nch] = ';'; save[nch+1] = 0;}; 6393 //remove blanks around , or ;; 6394 while ((blank = strstr(temp,""; ""))) strcpy(blank+1,blank+2);; 6395 while ((blank = strstr(temp,"" ;""))) strcpy(blank, blank+1);; 6396 while ((blank = strstr(temp,"", ""))) strcpy(blank+1,blank+2);; 6397 while ((blank = strstr(temp,"" ,""))) strcpy(blank, blank+1);; 6398 while ((blank = strstr(temp,"" ""))) strcpy(blank, blank+1);; 6399 //loop on tokens separated by ;; 6400 char *final = new char[1000];; 6401 char token[100];; 6402 while ((colon=strchr(temp,';'))) {; 6403 *colon = 0;; 6404 strlcpy(token,temp,100);; 6405 blank = strchr(token,' ');; 6406 if (blank) {; 6407 *blank = 0;; 6408 if (!gROOT->GetType(token)) {; 6409 Error(""SetStreamerInfo"",""Illegal type: %s in %s"",token,info);; 6410 return;; 6411 }; 6412 while (blank) {; 6413 strlcat(final,token,1000);; 6414 strlcat(final,"" "",1000);; 6415 comma = strchr(blank+1,','); if (comma) *comma=0;; 6416 strlcat(final,blank+1,1000);; 6417 strlcat(final,"";"",1000);; 6418 blank = comma;; 6419 }; 6420 ; 6421 } else {; 6422 if (TClass::GetClass(token,update)) {; 6423 //a class name; 6424 strlcat(final,token,1000); strlcat(final,"";"",1000);; 6425 } else {; 6426 //a data member name; 6427 dm = (TDataMember*)GetListOfDataMembers()->FindObject(token);; 6428 if (dm) {; 6429 strlcat(final,dm->GetFullTypeName(),1000);; 6430 strlcat(final,"" "",1000);; 6431 strlcat(final,token,1000); strlcat(final,"";"",1000);; 6432 } else {; 6433 Error(""SetStreamerInfo"",""Illegal name: %s in %s"",token,info);; 6434 return;; 6435 }; 6436 }; 6437 update = kFALSE;; 6438 }; 6439 temp = colon+1;; 6440 if (*temp == 0) break;; 6441 }; 6442 //// fStreamerInfo = final;; 6443 delete [] final;; 6444 delete [] save;; 6445 return;; 6446 }; 6447 ; 6448 //info is empty.",MatchSource.WIKI,doc/v632/TClass_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/TClass_8cxx_source.html
https://root.cern/doc/v632/TClass_8cxx_source.html:247414,Deployability,update,update,247414,"trlcpy(temp,info,10000);; 6388 //remove heading and trailing blanks; 6389 while (*temp == ' ') temp++;; 6390 while (save[nch-1] == ' ') {nch--; save[nch] = 0;}; 6391 if (nch == 0) {delete [] save; return;}; 6392 if (save[nch-1] != ';') {save[nch] = ';'; save[nch+1] = 0;}; 6393 //remove blanks around , or ;; 6394 while ((blank = strstr(temp,""; ""))) strcpy(blank+1,blank+2);; 6395 while ((blank = strstr(temp,"" ;""))) strcpy(blank, blank+1);; 6396 while ((blank = strstr(temp,"", ""))) strcpy(blank+1,blank+2);; 6397 while ((blank = strstr(temp,"" ,""))) strcpy(blank, blank+1);; 6398 while ((blank = strstr(temp,"" ""))) strcpy(blank, blank+1);; 6399 //loop on tokens separated by ;; 6400 char *final = new char[1000];; 6401 char token[100];; 6402 while ((colon=strchr(temp,';'))) {; 6403 *colon = 0;; 6404 strlcpy(token,temp,100);; 6405 blank = strchr(token,' ');; 6406 if (blank) {; 6407 *blank = 0;; 6408 if (!gROOT->GetType(token)) {; 6409 Error(""SetStreamerInfo"",""Illegal type: %s in %s"",token,info);; 6410 return;; 6411 }; 6412 while (blank) {; 6413 strlcat(final,token,1000);; 6414 strlcat(final,"" "",1000);; 6415 comma = strchr(blank+1,','); if (comma) *comma=0;; 6416 strlcat(final,blank+1,1000);; 6417 strlcat(final,"";"",1000);; 6418 blank = comma;; 6419 }; 6420 ; 6421 } else {; 6422 if (TClass::GetClass(token,update)) {; 6423 //a class name; 6424 strlcat(final,token,1000); strlcat(final,"";"",1000);; 6425 } else {; 6426 //a data member name; 6427 dm = (TDataMember*)GetListOfDataMembers()->FindObject(token);; 6428 if (dm) {; 6429 strlcat(final,dm->GetFullTypeName(),1000);; 6430 strlcat(final,"" "",1000);; 6431 strlcat(final,token,1000); strlcat(final,"";"",1000);; 6432 } else {; 6433 Error(""SetStreamerInfo"",""Illegal name: %s in %s"",token,info);; 6434 return;; 6435 }; 6436 }; 6437 update = kFALSE;; 6438 }; 6439 temp = colon+1;; 6440 if (*temp == 0) break;; 6441 }; 6442 //// fStreamerInfo = final;; 6443 delete [] final;; 6444 delete [] save;; 6445 return;; 6446 }; 6447 ; 6448 //info is empty.",MatchSource.WIKI,doc/v632/TClass_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/TClass_8cxx_source.html
https://root.cern/doc/v632/TClass_8cxx_source.html:248348,Deployability,update,update,248348," 6435 }; 6436 }; 6437 update = kFALSE;; 6438 }; 6439 temp = colon+1;; 6440 if (*temp == 0) break;; 6441 }; 6442 //// fStreamerInfo = final;; 6443 delete [] final;; 6444 delete [] save;; 6445 return;; 6446 }; 6447 ; 6448 //info is empty. Let's build the default Streamer descriptor; 6449 ; 6450 char *temp = new char[10000];; 6451 temp[0] = 0;; 6452 char local[100];; 6453 ; 6454 //add list of base classes; 6455 TIter nextb(GetListOfBases());; 6456 TBaseClass *base;; 6457 while ((base = (TBaseClass*) nextb())) {; 6458 snprintf(local,100,""%s;"",base->GetName());; 6459 strlcat(temp,local,10000);; 6460 }; 6461 ; 6462 //add list of data members and types; 6463 TIter nextd(GetListOfDataMembers());; 6464 while ((dm = (TDataMember *) nextd())) {; 6465 if (dm->IsEnum()) continue;; 6466 if (!dm->IsPersistent()) continue;; 6467 Long_t property = dm->Property();; 6468 if (property & kIsStatic) continue;; 6469 TClass *acl = TClass::GetClass(dm->GetTypeName(),update);; 6470 update = kFALSE;; 6471 if (acl) {; 6472 if (acl->GetClassVersion() == 0) continue;; 6473 }; 6474 ; 6475 // dm->GetArrayIndex() returns an empty string if it does not; 6476 // applies; 6477 const char * index = dm->GetArrayIndex();; 6478 if (strlen(index)==0); 6479 snprintf(local,100,""%s %s;"",dm->GetFullTypeName(),dm->GetName());; 6480 else; 6481 snprintf(local,100,""%s %s[%s];"",dm->GetFullTypeName(),dm->GetName(),index);; 6482 strlcat(temp,local,10000);; 6483 }; 6484 //fStreamerInfo = temp;; 6485 delete [] temp;; 6486*/; 6487 return nullptr;; 6488}; 6489 ; 6490////////////////////////////////////////////////////////////////////////////////; 6491/// Return true if the checksum passed as argument is one of the checksum; 6492/// value produced by the older checksum calculation algorithm.; 6493 ; 6494Bool_t TClass::MatchLegacyCheckSum(UInt_t checksum) const; 6495{; 6496 for(UInt_t i = 1; i < kLatestCheckSum; ++i) {; 6497 if ( checksum == GetCheckSum( (ECheckSum) i ) ) return kTRUE;; 6498 }; 6499 return kFALSE;; 6500}; 6",MatchSource.WIKI,doc/v632/TClass_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/TClass_8cxx_source.html
https://root.cern/doc/v632/TClass_8cxx_source.html:248363,Deployability,update,update,248363," 6435 }; 6436 }; 6437 update = kFALSE;; 6438 }; 6439 temp = colon+1;; 6440 if (*temp == 0) break;; 6441 }; 6442 //// fStreamerInfo = final;; 6443 delete [] final;; 6444 delete [] save;; 6445 return;; 6446 }; 6447 ; 6448 //info is empty. Let's build the default Streamer descriptor; 6449 ; 6450 char *temp = new char[10000];; 6451 temp[0] = 0;; 6452 char local[100];; 6453 ; 6454 //add list of base classes; 6455 TIter nextb(GetListOfBases());; 6456 TBaseClass *base;; 6457 while ((base = (TBaseClass*) nextb())) {; 6458 snprintf(local,100,""%s;"",base->GetName());; 6459 strlcat(temp,local,10000);; 6460 }; 6461 ; 6462 //add list of data members and types; 6463 TIter nextd(GetListOfDataMembers());; 6464 while ((dm = (TDataMember *) nextd())) {; 6465 if (dm->IsEnum()) continue;; 6466 if (!dm->IsPersistent()) continue;; 6467 Long_t property = dm->Property();; 6468 if (property & kIsStatic) continue;; 6469 TClass *acl = TClass::GetClass(dm->GetTypeName(),update);; 6470 update = kFALSE;; 6471 if (acl) {; 6472 if (acl->GetClassVersion() == 0) continue;; 6473 }; 6474 ; 6475 // dm->GetArrayIndex() returns an empty string if it does not; 6476 // applies; 6477 const char * index = dm->GetArrayIndex();; 6478 if (strlen(index)==0); 6479 snprintf(local,100,""%s %s;"",dm->GetFullTypeName(),dm->GetName());; 6480 else; 6481 snprintf(local,100,""%s %s[%s];"",dm->GetFullTypeName(),dm->GetName(),index);; 6482 strlcat(temp,local,10000);; 6483 }; 6484 //fStreamerInfo = temp;; 6485 delete [] temp;; 6486*/; 6487 return nullptr;; 6488}; 6489 ; 6490////////////////////////////////////////////////////////////////////////////////; 6491/// Return true if the checksum passed as argument is one of the checksum; 6492/// value produced by the older checksum calculation algorithm.; 6493 ; 6494Bool_t TClass::MatchLegacyCheckSum(UInt_t checksum) const; 6495{; 6496 for(UInt_t i = 1; i < kLatestCheckSum; ++i) {; 6497 if ( checksum == GetCheckSum( (ECheckSum) i ) ) return kTRUE;; 6498 }; 6499 return kFALSE;; 6500}; 6",MatchSource.WIKI,doc/v632/TClass_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/TClass_8cxx_source.html
https://root.cern/doc/v632/TClass_8cxx_source.html:305301,Deployability,toggle,toggle,305301,"e class used for serializing objects.Definition TBuffer.h:43; TBuildRealDataDefinition TClass.cxx:751; TBuildRealData::Inspectvoid Inspect(TClass *cl, const char *parent, const char *name, const void *addr, Bool_t isTransient) overrideThis method is called from ShowMembers() via BuildRealdata().Definition TClass.cxx:771; TBuildRealData::fRealDataClassTClass * fRealDataClassDefinition TClass.cxx:755; TBuildRealData::fRealDataObjectvoid * fRealDataObjectDefinition TClass.cxx:754; TBuildRealData::TBuildRealDataTBuildRealData(void *obj, TClass *cl)Definition TClass.cxx:758; TClassGeneratorObjects following this interface can be passed onto the TROOT object to implement a user customized w...Definition TClassGenerator.h:28; TClassGenerator::GetClassvirtual TClass * GetClass(const char *classname, Bool_t load)=0; TClassMenuItemDescribes one element of the context menu associated to a class The menu item may describe.Definition TClassMenuItem.h:31; TClassMenuItem::SetTogglevirtual void SetToggle(Bool_t toggle=kTRUE)Definition TClassMenuItem.h:75; TClassMenuItem::kIsSelf@ kIsSelfDefinition TClassMenuItem.h:37; TClassMenuItem::kPopupStandardList@ kPopupStandardListDefinition TClassMenuItem.h:35; TClassMenuItem::kPopupSeparator@ kPopupSeparatorDefinition TClassMenuItem.h:35; TClassMenuItem::kPopupUserFunction@ kPopupUserFunctionDefinition TClassMenuItem.h:35; TClassRefTClassRef is used to implement a permanent reference to a TClass object.Definition TClassRef.h:28; TClassStreamerDefinition TClassStreamer.h:26; TClassStreamer::Streamvirtual void Stream(TBuffer &b, void *objp, const TClass *onfileClass)Definition TClassStreamer.h:51; TClassStreamer::Generatevirtual TClassStreamer * Generate() constDefinition TClassStreamer.h:38; TClassTable::GetDictstatic DictFuncPtr_t GetDict(const char *cname)Given the class name returns the Dictionary() function of a class (uses hash of name).Definition TClassTable.cxx:674; TClassTable::GetProtoNormstatic TProtoClass * GetProtoNorm(const cha",MatchSource.WIKI,doc/v632/TClass_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/TClass_8cxx_source.html
https://root.cern/doc/v632/TClass_8cxx_source.html:326981,Deployability,install,installs,326981,"rapper around new ThisClass[].Definition TClass.cxx:7455; TClass::StreamerTObjectEmulatedstatic void StreamerTObjectEmulated(const TClass *pThis, void *object, TBuffer &b, const TClass *onfile_class)Case of TObjects when we do not have the library defining the class.Definition TClass.cxx:6823; TClass::fNewROOT::NewFunc_t fNewDefinition TClass.h:235; TClass::kLoading@ kLoadingDefinition TClass.h:332; TClass::kUnloading@ kUnloadingDefinition TClass.h:332; TClass::GetResetAfterMergeROOT::ResetAfterMergeFunc_t GetResetAfterMerge() constReturn the wrapper around Merge.Definition TClass.cxx:7439; TClass::GetClassMethodWithPrototypeTMethod * GetClassMethodWithPrototype(const char *name, const char *proto, Bool_t objectIsConst=kFALSE, ROOT::EFunctionMatchMode mode=ROOT::kConversionMatch)Find the method with a given prototype.Definition TClass.cxx:4527; TClass::CanIgnoreTObjectStreamerBool_t CanIgnoreTObjectStreamer()Definition TClass.h:393; TClass::SetGlobalIsAvoid SetGlobalIsA(IsAGlobalFunc_t)This function installs a global IsA function for this class.Definition TClass.cxx:6300; TClass::GetMissingDictionariesForMembersvoid GetMissingDictionariesForMembers(TCollection &result, TCollection &visited, bool recurse)Verify the Data Members.Definition TClass.cxx:3944; TClass::fStreamerInfoTObjArray * fStreamerInfoDefinition TClass.h:198; TClass::GetSchemaRulesconst ROOT::Detail::TSchemaRuleSet * GetSchemaRules() constReturn the set of the schema rules if any.Definition TClass.cxx:1932; TClass::CloneTObject * Clone(const char *newname="""") const overrideCreate a Clone of this TClass object using a different name but using the same 'dictionary'.Definition TClass.cxx:2406; TClass::fCollectionProxyTVirtualCollectionProxy * fCollectionProxyDefinition TClass.h:220; TClass::IsCallingNewstatic ENewType IsCallingNew()Static method returning the defConstructor flag passed to TClass::New().Definition TClass.cxx:5902; TClass::GetListOfBasesTList * GetListOfBases()Return list containing the TBa",MatchSource.WIKI,doc/v632/TClass_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/TClass_8cxx_source.html
https://root.cern/doc/v632/TClass_8cxx_source.html:357617,Deployability,update,updates,357617,"an associative array of (key,value) pairs using a THashTable for efficient retrieval ...Definition TMap.h:40; TMemberInspectorAbstract base class for accessing the data-members of a class.Definition TMemberInspector.h:31; TMemberInspector::Inspectvirtual void Inspect(TClass *cl, const char *parent, const char *name, const void *addr)Definition TMemberInspector.cxx:99; TMemberStreamerDefinition TMemberStreamer.h:26; TMethodArgEach ROOT method (see TMethod) has a linked list of its arguments.Definition TMethodArg.h:36; TMethodArg::GetFullTypeNameconst char * GetFullTypeName() constGet full type description of method argument, e.g.: ""class TDirectory*"".Definition TMethodArg.cxx:74; TMethodEach ROOT class (see TClass) has a linked list of methods.Definition TMethod.h:38; TMethod::GetClassTClass * GetClass() constDefinition TMethod.h:55; TMethod::IsMenuItemEMenuItemKind IsMenuItem() constDefinition TMethod.h:56; TMethod::GetListOfMethodArgsvirtual TList * GetListOfMethodArgs()Returns methodarg list and additionally updates fDataMember in TMethod by calling FindDataMember();.Definition TMethod.cxx:307; TNamed::CloneTObject * Clone(const char *newname="""") const overrideMake a clone of an object using the Streamer facility.Definition TNamed.cxx:74; TNamed::SetTitlevirtual void SetTitle(const char *title="""")Set the title of the TNamed.Definition TNamed.cxx:164; TNamed::GetNameconst char * GetName() const overrideReturns name of object.Definition TNamed.h:47; TNamed::GetTitleconst char * GetTitle() const overrideReturns title of object.Definition TNamed.h:48; TNamed::fNameTString fNameDefinition TNamed.h:32; TNamed::SetNamevirtual void SetName(const char *name)Set the name of the TNamed.Definition TNamed.cxx:140; TNamed::lsvoid ls(Option_t *option="""") const overrideList TNamed name and title.Definition TNamed.cxx:113; TObjArrayAn array of TObjects.Definition TObjArray.h:31; TObjArray::GetEntriesFastInt_t GetEntriesFast() constDefinition TObjArray.h:58; TObjArray::Clearvoid Cle",MatchSource.WIKI,doc/v632/TClass_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/TClass_8cxx_source.html
https://root.cern/doc/v632/TClass_8cxx_source.html:362268,Deployability,install,installation,362268,"; TObject::GetObjectStatstatic Bool_t GetObjectStat()Get status of object stat flag.Definition TObject.cxx:1061; TObject::Errorvirtual void Error(const char *method, const char *msgfmt,...) constIssue error message.Definition TObject.cxx:987; TObject::Fatalvirtual void Fatal(const char *method, const char *msgfmt,...) constIssue fatal error message.Definition TObject.cxx:1015; TObject::SetUniqueIDvirtual void SetUniqueID(UInt_t uid)Set the unique object id.Definition TObject.cxx:791; TObject::IsAvirtual TClass * IsA() constDefinition TObject.h:243; TObject::MakeZombievoid MakeZombie()Definition TObject.h:53; TObject::ResetBitvoid ResetBit(UInt_t f)Definition TObject.h:198; TObject::Infovirtual void Info(const char *method, const char *msgfmt,...) constIssue info message.Definition TObject.cxx:961; TPairClass used by TMap to store (key,value) pairs.Definition TMap.h:102; TProtoClassPersistent version of a TClass.Definition TProtoClass.h:38; TROOT::GetEtcDirstatic const TString & GetEtcDir()Get the sysconfig directory in the installation. Static utility function.Definition TROOT.cxx:3052; TRealDataThe TRealData class manages the effective list of all data members for a given class.Definition TRealData.h:30; TRealData::GetNameconst char * GetName() const overrideReturns name of object.Definition TRealData.h:52; TRealData::AdoptStreamervoid AdoptStreamer(TMemberStreamer *p)Definition TRealData.cxx:67; TRealData::kTransient@ kTransientDefinition TRealData.h:44; TRealData::GetThisOffsetLong_t GetThisOffset() constDefinition TRealData.h:55; TRealData::SetIsObjectvoid SetIsObject(Bool_t isObject)Definition TRealData.h:57; TRefArray::Classstatic TClass * Class(); TRef::Classstatic TClass * Class(); TStreamerBaseDefinition TStreamerElement.h:150; TStreamerBase::GetClassPointerTClass * GetClassPointer() const overrideReturns a pointer to the TClass of this element.Definition TStreamerElement.cxx:659; TStreamerBase::Classstatic TClass * Class(); TStreamerElementDefinition TStre",MatchSource.WIKI,doc/v632/TClass_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/TClass_8cxx_source.html
https://root.cern/doc/v632/TClass_8cxx_source.html:76625,Energy Efficiency,allocate,allocated,76625,"b) {; 2015 if (!fRealData) BuildRealData();; 2016 ; 2017 b->Add(GetListOfDataMembers(), ""Data Members"");; 2018 b->Add(GetListOfRealData(), ""Real Data Members"");; 2019 b->Add(GetListOfMethods(), ""Methods"");; 2020 b->Add(GetListOfBases(), ""Base Classes"");; 2021 }; 2022}; 2023 ; 2024////////////////////////////////////////////////////////////////////////////////; 2025/// Build a full list of persistent data members.; 2026/// Scans the list of all data members in the class itself and also; 2027/// in all base classes. For each persistent data member, inserts a; 2028/// TRealData object in the list fRealData.; 2029///; 2030 ; 2031void TClass::BuildRealData(void* pointer, Bool_t isTransient); 2032{; 2033 ; 2034 R__LOCKGUARD(gInterpreterMutex);; 2035 ; 2036 // Only do this once.; 2037 if (fRealData) {; 2038 return;; 2039 }; 2040 ; 2041 if (fClassVersion == 0) {; 2042 isTransient = kTRUE;; 2043 }; 2044 ; 2045 // When called via TMapFile (e.g. Update()) make sure that the dictionary; 2046 // gets allocated on the heap and not in the mapped file.; 2047 TMmallocDescTemp setreset;; 2048 ; 2049 // Handle emulated classes and STL containers specially.; 2050 if (!HasInterpreterInfo() || TClassEdit::IsSTLCont(GetName(), 0) || TClassEdit::IsSTLBitset(GetName())) {; 2051 // We are an emulated class or an STL container.; 2052 fRealData = new TList;; 2053 BuildEmulatedRealData("""", 0, this, isTransient);; 2054 return;; 2055 }; 2056 ; 2057 // return early on string; 2058 static TClassRef clRefString(""std::string"");; 2059 if (clRefString == this) {; 2060 return;; 2061 }; 2062 ; 2063 // Complain about stl classes ending up here (unique_ptr etc) - except for; 2064 // pair where we will build .first, .second just fine; 2065 // and those for which the user explicitly requested a dictionary.; 2066 if (!isTransient && GetState() != kHasTClassInit; 2067 && TClassEdit::IsStdClass(GetName()); 2068 && !TClassEdit::IsStdPair(GetName())) {; 2069 Error(""BuildRealData"", ""Inspection for %s not supported",MatchSource.WIKI,doc/v632/TClass_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/TClass_8cxx_source.html
https://root.cern/doc/v632/TClass_8cxx_source.html:82664,Energy Efficiency,allocate,allocated,82664,"er names); 2164 next.Reset();; 2165 while ((element = (TStreamerElement*)next())) {; 2166 Int_t etype = element->GetType();; 2167 if (element->IsBase() || etype == TVirtualStreamerInfo::kBase) {; 2168 //base class; 2169 Longptr_t eoffset = element->GetOffset();; 2170 TClass *cle = element->GetClassPointer();; 2171 if (cle) cle->BuildEmulatedRealData(name,offset+eoffset,cl, isTransient);; 2172 }; 2173 }; 2174}; 2175 ; 2176 ; 2177////////////////////////////////////////////////////////////////////////////////; 2178/// Calculate the offset between an object of this class to; 2179/// its base class TObject. The pointer can be adjusted by; 2180/// that offset to access any virtual method of TObject like; 2181/// Streamer() and ShowMembers().; 2182 ; 2183void TClass::CalculateStreamerOffset() const; 2184{; 2185 R__LOCKGUARD(gInterpreterMutex);; 2186 if (!fIsOffsetStreamerSet && HasInterpreterInfo()) {; 2187 // When called via TMapFile (e.g. Update()) make sure that the dictionary; 2188 // gets allocated on the heap and not in the mapped file.; 2189 ; 2190 TMmallocDescTemp setreset;; 2191 fOffsetStreamer = const_cast<TClass*>(this)->GetBaseClassOffsetRecurse(TObject::Class());; 2192 if (fStreamerType == kTObject) {; 2193 fStreamerImpl = &TClass::StreamerTObjectInitialized;; 2194 }; 2195 fIsOffsetStreamerSet = kTRUE;; 2196 }; 2197}; 2198 ; 2199 ; 2200////////////////////////////////////////////////////////////////////////////////; 2201/// Call ShowMembers() on the obj of this class type, passing insp and parent.; 2202/// isATObject is -1 if unknown, 0 if it is not a TObject, and 1 if it is a TObject.; 2203/// The function returns whether it was able to call ShowMembers().; 2204 ; 2205Bool_t TClass::CallShowMembers(const void* obj, TMemberInspector &insp, Bool_t isTransient) const; 2206{; 2207 if (fShowMembers) {; 2208 // This should always works since 'pointer' should be pointing; 2209 // to an object of the actual type of this TClass object.; 2210 fShowMembers(obj, insp, i",MatchSource.WIKI,doc/v632/TClass_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/TClass_8cxx_source.html
https://root.cern/doc/v632/TClass_8cxx_source.html:188409,Energy Efficiency,allocate,allocated,188409,"e the pointer; 4913/// to the cl part of this (up) or to this (down).; 4914 ; 4915void *TClass::DynamicCast(const TClass *cl, void *obj, Bool_t up); 4916{; 4917 if (cl == this) return obj;; 4918 ; 4919 if (!HasDataMemberInfo()) return nullptr;; 4920 ; 4921 Int_t off;; 4922 if ((off = GetBaseClassOffset(cl, obj)) != -1) {; 4923 if (up); 4924 return (void*)((Longptr_t)obj+off);; 4925 else; 4926 return (void*)((Longptr_t)obj-off);; 4927 }; 4928 return nullptr;; 4929}; 4930 ; 4931////////////////////////////////////////////////////////////////////////////////; 4932/// Cast obj of this class type up to baseclass cl if up is true.; 4933/// Cast obj of this class type down from baseclass cl if up is false.; 4934/// If this class is not a baseclass of cl return 0, else the pointer; 4935/// to the cl part of this (up) or to this (down).; 4936 ; 4937const void *TClass::DynamicCast(const TClass *cl, const void *obj, Bool_t up); 4938{; 4939 return DynamicCast(cl,const_cast<void*>(obj),up);; 4940}; 4941 ; 4942////////////////////////////////////////////////////////////////////////////////; 4943/// Return a pointer to a newly allocated object of this class.; 4944/// The class must have a default constructor. For meaning of; 4945/// defConstructor, see TClass::IsCallingNew().; 4946///; 4947/// If quiet is true, do no issue a message via Error on case; 4948/// of problems, just return 0.; 4949///; 4950/// The constructor actually called here can be customized by; 4951/// using the rootcint pragma:; 4952/// ~~~ {.cpp}; 4953/// #pragma link C++ ioctortype UserClass;; 4954/// ~~~; 4955/// For example, with this pragma and a class named MyClass,; 4956/// this method will called the first of the following 3; 4957/// constructors which exists and is public:; 4958/// ~~~ {.cpp}; 4959/// MyClass(UserClass*);; 4960/// MyClass(TRootIOCtor*);; 4961/// MyClass(); // Or a constructor with all its arguments defaulted.; 4962/// ~~~; 4963///; 4964/// When more than one pragma ioctortype is used, t",MatchSource.WIKI,doc/v632/TClass_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/TClass_8cxx_source.html
https://root.cern/doc/v632/TClass_8cxx_source.html:190167,Energy Efficiency,allocate,allocated,190167," 4961/// MyClass(); // Or a constructor with all its arguments defaulted.; 4962/// ~~~; 4963///; 4964/// When more than one pragma ioctortype is used, the first seen as priority; 4965/// For example with:; 4966/// ~~~ {.cpp}; 4967/// #pragma link C++ ioctortype UserClass1;; 4968/// #pragma link C++ ioctortype UserClass2;; 4969/// ~~~; 4970/// We look in the following order:; 4971/// ~~~ {.cpp}; 4972/// MyClass(UserClass1*);; 4973/// MyClass(UserClass2*);; 4974/// MyClass(TRootIOCtor*);; 4975/// MyClass(); // Or a constructor with all its arguments defaulted.; 4976/// ~~~; 4977 ; 4978void *TClass::New(ENewType defConstructor, Bool_t quiet) const; 4979{; 4980 auto obj = NewObject(defConstructor, quiet);; 4981 if (obj.GetPtr() && obj.GetAllocator()) {; 4982 // Register the object for special handling in the destructor.; 4983 RegisterAddressInRepository(""TClass::New"", obj.GetPtr(), this);; 4984 }; 4985 return obj.GetPtr();; 4986}; 4987 ; 4988// See TClass:New; 4989// returns a TClass::ObjectPtr which remembers if the object was allocated; 4990// via a TStreamerInfo.; 4991 ; 4992TClass::ObjectPtr TClass::NewObject(ENewType defConstructor, Bool_t quiet) const; 4993{; 4994 ObjectPtr p;; 4995 ; 4996 if (fNew) {; 4997 // We have the new operator wrapper function,; 4998 // so there is a dictionary and it was generated; 4999 // by rootcint, so there should be a default; 5000 // constructor we can call through the wrapper.; 5001 {; 5002 TClass__GetCallingNewRAII callingNew(defConstructor);; 5003 p = fNew(nullptr);; 5004 }; 5005 if (!p && !quiet) {; 5006 //Error(""New"", ""cannot create object of class %s version %d"", GetName(), fClassVersion);; 5007 Error(""New"", ""cannot create object of class %s"", GetName());; 5008 }; 5009 } else if (HasInterpreterInfo()) {; 5010 // We have the dictionary but do not have the; 5011 // constructor wrapper, so the dictionary was; 5012 // not generated by rootcint. Let's try to; 5013 // create the object by having the interpreter; 5014 // call the new ",MatchSource.WIKI,doc/v632/TClass_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/TClass_8cxx_source.html
https://root.cern/doc/v632/TClass_8cxx_source.html:193894,Energy Efficiency,allocate,allocated,193894,"that we create; 5048 // as a result of creating this object.; 5049 // FIXME: Why do we do this?; 5050 // FIXME: Partial Answer: Is this because we may never actually deregister them???; 5051 ; 5052 Bool_t statsave = GetObjectStat();; 5053 if(statsave) {; 5054 SetObjectStat(kFALSE);; 5055 }; 5056 TVirtualStreamerInfo* sinfo = GetStreamerInfo();; 5057 if (!sinfo) {; 5058 if (!quiet); 5059 Error(""New"", ""Cannot construct class '%s' version %d, no streamer info available!"", GetName(), fClassVersion);; 5060 return nullptr;; 5061 }; 5062 ; 5063 {; 5064 TClass__GetCallingNewRAII callingNew(defConstructor);; 5065 p = { sinfo->New(), sinfo};; 5066 }; 5067 ; 5068 // FIXME: Mistake? See note above at the GetObjectStat() call.; 5069 // Allow TObject's to be registered again.; 5070 if(statsave) {; 5071 SetObjectStat(statsave);; 5072 }; 5073 ; 5074 if (!p) {; 5075 Error(""New"", ""Failed to construct class '%s' using streamer info"", GetName());; 5076 }; 5077 ; 5078 return p;; 5079 } else {; 5080 Fatal(""New"", ""This cannot happen!"");; 5081 }; 5082 ; 5083 return p;; 5084}; 5085 ; 5086////////////////////////////////////////////////////////////////////////////////; 5087/// Return a pointer to a newly allocated object of this class.; 5088/// The class must have a default constructor. For meaning of; 5089/// defConstructor, see TClass::IsCallingNew().; 5090 ; 5091void *TClass::New(void *arena, ENewType defConstructor) const; 5092{; 5093 auto obj = NewObject(arena, defConstructor);; 5094 if (obj.GetPtr() && obj.GetAllocator()) {; 5095 // Register the object for special handling in the destructor.; 5096 RegisterAddressInRepository(""TClass::New with placement"", obj.GetPtr(), this);; 5097 }; 5098 return obj.GetPtr();; 5099}; 5100 ; 5101////////////////////////////////////////////////////////////////////////////////; 5102/// Return a pointer to a newly allocated object of this class.; 5103/// The class must have a default constructor. For meaning of; 5104/// defConstructor, see TClass::IsCalling",MatchSource.WIKI,doc/v632/TClass_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/TClass_8cxx_source.html
https://root.cern/doc/v632/TClass_8cxx_source.html:194552,Energy Efficiency,allocate,allocated,194552,"1 SetObjectStat(statsave);; 5072 }; 5073 ; 5074 if (!p) {; 5075 Error(""New"", ""Failed to construct class '%s' using streamer info"", GetName());; 5076 }; 5077 ; 5078 return p;; 5079 } else {; 5080 Fatal(""New"", ""This cannot happen!"");; 5081 }; 5082 ; 5083 return p;; 5084}; 5085 ; 5086////////////////////////////////////////////////////////////////////////////////; 5087/// Return a pointer to a newly allocated object of this class.; 5088/// The class must have a default constructor. For meaning of; 5089/// defConstructor, see TClass::IsCallingNew().; 5090 ; 5091void *TClass::New(void *arena, ENewType defConstructor) const; 5092{; 5093 auto obj = NewObject(arena, defConstructor);; 5094 if (obj.GetPtr() && obj.GetAllocator()) {; 5095 // Register the object for special handling in the destructor.; 5096 RegisterAddressInRepository(""TClass::New with placement"", obj.GetPtr(), this);; 5097 }; 5098 return obj.GetPtr();; 5099}; 5100 ; 5101////////////////////////////////////////////////////////////////////////////////; 5102/// Return a pointer to a newly allocated object of this class.; 5103/// The class must have a default constructor. For meaning of; 5104/// defConstructor, see TClass::IsCallingNew().; 5105 ; 5106TClass::ObjectPtr TClass::NewObject(void *arena, ENewType defConstructor) const; 5107{; 5108 ObjectPtr p;; 5109 ; 5110 if (fNew) {; 5111 // We have the new operator wrapper function,; 5112 // so there is a dictionary and it was generated; 5113 // by rootcint, so there should be a default; 5114 // constructor we can call through the wrapper.; 5115 {; 5116 TClass__GetCallingNewRAII callingNew(defConstructor);; 5117 p = fNew(arena);; 5118 }; 5119 if (!p) {; 5120 Error(""New with placement"", ""cannot create object of class %s version %d at address %p"", GetName(), fClassVersion, arena);; 5121 }; 5122 } else if (HasInterpreterInfo()) {; 5123 // We have the dictionary but do not have the; 5124 // constructor wrapper, so the dictionary was; 5125 // not generated by rootcint. Le",MatchSource.WIKI,doc/v632/TClass_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/TClass_8cxx_source.html
https://root.cern/doc/v632/TClass_8cxx_source.html:197880,Energy Efficiency,allocate,allocated,197880," marked; 5152 // as preallocated with the ""->"" comment, in which case; 5153 // we default-construct an object to point at).; 5154 ; 5155 // ???BUG??? ???WHY???; 5156 // Do not register any TObject's that we create; 5157 // as a result of creating this object.; 5158 Bool_t statsave = GetObjectStat();; 5159 if(statsave) {; 5160 SetObjectStat(kFALSE);; 5161 }; 5162 ; 5163 TVirtualStreamerInfo* sinfo = GetStreamerInfo();; 5164 if (!sinfo) {; 5165 Error(""New with placement"", ""Cannot construct class '%s' version %d at address %p, no streamer info available!"", GetName(), fClassVersion, arena);; 5166 return nullptr;; 5167 }; 5168 ; 5169 {; 5170 TClass__GetCallingNewRAII callingNew(defConstructor);; 5171 p = { sinfo->New(arena), sinfo };; 5172 }; 5173 ; 5174 // ???BUG???; 5175 // Allow TObject's to be registered again.; 5176 if(statsave) {; 5177 SetObjectStat(statsave);; 5178 }; 5179 ; 5180 } else {; 5181 Error(""New with placement"", ""This cannot happen!"");; 5182 }; 5183 ; 5184 return p;; 5185}; 5186 ; 5187////////////////////////////////////////////////////////////////////////////////; 5188/// Return a pointer to a newly allocated array of objects; 5189/// of this class.; 5190/// The class must have a default constructor. For meaning of; 5191/// defConstructor, see TClass::IsCallingNew().; 5192 ; 5193void *TClass::NewArray(Long_t nElements, ENewType defConstructor) const; 5194{; 5195 auto obj = NewObjectArray(nElements, defConstructor);; 5196 if (obj.GetPtr() && obj.GetAllocator()) {; 5197 // Register the object for special handling in the destructor.; 5198 RegisterAddressInRepository(""TClass::NewArray"", obj.GetPtr(), this);; 5199 }; 5200 return obj.GetPtr();; 5201}; 5202 ; 5203////////////////////////////////////////////////////////////////////////////////; 5204/// Return a pointer to a newly allocated array of objects; 5205/// of this class.; 5206/// The class must have a default constructor. For meaning of; 5207/// defConstructor, see TClass::IsCallingNew().; 5208 ; 5209TC",MatchSource.WIKI,doc/v632/TClass_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/TClass_8cxx_source.html
https://root.cern/doc/v632/TClass_8cxx_source.html:198566,Energy Efficiency,allocate,allocated,198566,"UG???; 5175 // Allow TObject's to be registered again.; 5176 if(statsave) {; 5177 SetObjectStat(statsave);; 5178 }; 5179 ; 5180 } else {; 5181 Error(""New with placement"", ""This cannot happen!"");; 5182 }; 5183 ; 5184 return p;; 5185}; 5186 ; 5187////////////////////////////////////////////////////////////////////////////////; 5188/// Return a pointer to a newly allocated array of objects; 5189/// of this class.; 5190/// The class must have a default constructor. For meaning of; 5191/// defConstructor, see TClass::IsCallingNew().; 5192 ; 5193void *TClass::NewArray(Long_t nElements, ENewType defConstructor) const; 5194{; 5195 auto obj = NewObjectArray(nElements, defConstructor);; 5196 if (obj.GetPtr() && obj.GetAllocator()) {; 5197 // Register the object for special handling in the destructor.; 5198 RegisterAddressInRepository(""TClass::NewArray"", obj.GetPtr(), this);; 5199 }; 5200 return obj.GetPtr();; 5201}; 5202 ; 5203////////////////////////////////////////////////////////////////////////////////; 5204/// Return a pointer to a newly allocated array of objects; 5205/// of this class.; 5206/// The class must have a default constructor. For meaning of; 5207/// defConstructor, see TClass::IsCallingNew().; 5208 ; 5209TClass::ObjectPtr TClass::NewObjectArray(Long_t nElements, ENewType defConstructor) const; 5210{; 5211 ObjectPtr p;; 5212 ; 5213 if (fNewArray) {; 5214 // We have the new operator wrapper function,; 5215 // so there is a dictionary and it was generated; 5216 // by rootcint, so there should be a default; 5217 // constructor we can call through the wrapper.; 5218 {; 5219 TClass__GetCallingNewRAII callingNew(defConstructor);; 5220 p = fNewArray(nElements, nullptr);; 5221 }; 5222 if (!p) {; 5223 Error(""NewArray"", ""cannot create object of class %s version %d"", GetName(), fClassVersion);; 5224 }; 5225 } else if (HasInterpreterInfo()) {; 5226 // We have the dictionary but do not have the; 5227 // constructor wrapper, so the dictionary was; 5228 // not generated by r",MatchSource.WIKI,doc/v632/TClass_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/TClass_8cxx_source.html
https://root.cern/doc/v632/TClass_8cxx_source.html:201865,Energy Efficiency,allocate,allocated,201865,"ta members are null, unless they are marked; 5255 // as preallocated with the ""->"" comment, in which case; 5256 // we default-construct an object to point at).; 5257 ; 5258 // ???BUG??? ???WHY???; 5259 // Do not register any TObject's that we create; 5260 // as a result of creating this object.; 5261 Bool_t statsave = GetObjectStat();; 5262 if(statsave) {; 5263 SetObjectStat(kFALSE);; 5264 }; 5265 ; 5266 TVirtualStreamerInfo* sinfo = GetStreamerInfo();; 5267 if (!sinfo) {; 5268 Error(""NewArray"", ""Cannot construct class '%s' version %d, no streamer info available!"", GetName(), fClassVersion);; 5269 return nullptr;; 5270 }; 5271 ; 5272 {; 5273 TClass__GetCallingNewRAII callingNew(defConstructor);; 5274 p = { sinfo->NewArray(nElements), sinfo };; 5275 }; 5276 ; 5277 // ???BUG???; 5278 // Allow TObject's to be registered again.; 5279 if(statsave) {; 5280 SetObjectStat(statsave);; 5281 }; 5282 ; 5283 } else {; 5284 Error(""NewArray"", ""This cannot happen!"");; 5285 }; 5286 ; 5287 return p;; 5288}; 5289 ; 5290////////////////////////////////////////////////////////////////////////////////; 5291/// Return a pointer to a newly allocated object of this class.; 5292/// The class must have a default constructor. For meaning of; 5293/// defConstructor, see TClass::IsCallingNew().; 5294 ; 5295void *TClass::NewArray(Long_t nElements, void *arena, ENewType defConstructor) const; 5296{; 5297 auto obj = NewObjectArray(nElements, arena, defConstructor);; 5298 if (obj.GetPtr() && obj.GetAllocator()) {; 5299 // Register the object for special handling in the destructor.; 5300 RegisterAddressInRepository(""TClass::NewArray with placement"", obj.GetPtr(), this);; 5301 }; 5302 return obj.GetPtr();; 5303}; 5304 ; 5305////////////////////////////////////////////////////////////////////////////////; 5306/// Return a pointer to a newly allocated object of this class.; 5307/// The class must have a default constructor. For meaning of; 5308/// defConstructor, see TClass::IsCallingNew().; 5309 ; 5310",MatchSource.WIKI,doc/v632/TClass_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/TClass_8cxx_source.html
https://root.cern/doc/v632/TClass_8cxx_source.html:202567,Energy Efficiency,allocate,allocated,202567,"??BUG???; 5278 // Allow TObject's to be registered again.; 5279 if(statsave) {; 5280 SetObjectStat(statsave);; 5281 }; 5282 ; 5283 } else {; 5284 Error(""NewArray"", ""This cannot happen!"");; 5285 }; 5286 ; 5287 return p;; 5288}; 5289 ; 5290////////////////////////////////////////////////////////////////////////////////; 5291/// Return a pointer to a newly allocated object of this class.; 5292/// The class must have a default constructor. For meaning of; 5293/// defConstructor, see TClass::IsCallingNew().; 5294 ; 5295void *TClass::NewArray(Long_t nElements, void *arena, ENewType defConstructor) const; 5296{; 5297 auto obj = NewObjectArray(nElements, arena, defConstructor);; 5298 if (obj.GetPtr() && obj.GetAllocator()) {; 5299 // Register the object for special handling in the destructor.; 5300 RegisterAddressInRepository(""TClass::NewArray with placement"", obj.GetPtr(), this);; 5301 }; 5302 return obj.GetPtr();; 5303}; 5304 ; 5305////////////////////////////////////////////////////////////////////////////////; 5306/// Return a pointer to a newly allocated object of this class.; 5307/// The class must have a default constructor. For meaning of; 5308/// defConstructor, see TClass::IsCallingNew().; 5309 ; 5310TClass::ObjectPtr TClass::NewObjectArray(Long_t nElements, void *arena, ENewType defConstructor) const; 5311{; 5312 ObjectPtr p;; 5313 ; 5314 if (fNewArray) {; 5315 // We have the new operator wrapper function,; 5316 // so there is a dictionary and it was generated; 5317 // by rootcint, so there should be a default; 5318 // constructor we can call through the wrapper.; 5319 {; 5320 TClass__GetCallingNewRAII callingNew(defConstructor);; 5321 p = fNewArray(nElements, arena);; 5322 }; 5323 if (!p) {; 5324 Error(""NewArray with placement"", ""cannot create object of class %s version %d at address %p"", GetName(), fClassVersion, arena);; 5325 }; 5326 } else if (HasInterpreterInfo()) {; 5327 // We have the dictionary but do not have the constructor wrapper,; 5328 // so the dict",MatchSource.WIKI,doc/v632/TClass_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/TClass_8cxx_source.html
https://root.cern/doc/v632/TClass_8cxx_source.html:208009,Energy Efficiency,allocate,allocated,208009,"r call the destructor,; 5419 // either the code will be in a loaded library,; 5420 // or it will be interpreted, otherwise we fail; 5421 // because there is no destructor code at all.; 5422 if (dtorOnly) {; 5423 gCling->ClassInfo_Destruct(fClassInfo,p);; 5424 } else {; 5425 gCling->ClassInfo_Delete(fClassInfo,p);; 5426 }; 5427 } else if (!HasInterpreterInfo() && fCollectionProxy) {; 5428 // There is no dictionary at all, so this is an emulated; 5429 // class; however we do have the services of a collection proxy,; 5430 // so this is an emulated STL class.; 5431 GetCollectionProxy()->Destructor(p, dtorOnly);; 5432 } else if (!HasInterpreterInfo() && !fCollectionProxy) {; 5433 // There is no dictionary at all and we do not have; 5434 // the services of a collection proxy available, so; 5435 // use the streamer info to approximate calling a; 5436 // destructor.; 5437 ; 5438 Bool_t inRepo = kTRUE;; 5439 Bool_t currentVersion = kFALSE;; 5440 ; 5441 // Was this object allocated through TClass?; 5442 Version_t objVer = -1;; 5443 {; 5444 R__LOCKGUARD2(fOVRMutex);; 5445 RepoCont_t::iterator iter = fObjectVersionRepository.find(p);; 5446 if (iter == fObjectVersionRepository.end()) {; 5447 // No, it wasn't, skip special version handling.; 5448 //Error(""Destructor2"", ""Attempt to delete unregistered object of class '%s' at address %p!"", GetName(), p);; 5449 inRepo = kFALSE;; 5450 } else {; 5451 //objVer = iter->second;; 5452 for (; (iter != fObjectVersionRepository.end()) && (iter->first == p); ++iter) {; 5453 objVer = iter->second;; 5454 if (objVer == fClassVersion) {; 5455 currentVersion = kTRUE;; 5456 break;; 5457 }; 5458 }; 5459 }; 5460 }; 5461 ; 5462 if (!inRepo || currentVersion) {; 5463 // The object was allocated using code for the same class version; 5464 // as is loaded now. We may proceed without worry.; 5465 TVirtualStreamerInfo* si = GetStreamerInfo();; 5466 if (si) {; 5467 si->Destructor(p, dtorOnly);; 5468 } else {; 5469 Error(""Destructor"", ""No streamer info availa",MatchSource.WIKI,doc/v632/TClass_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/TClass_8cxx_source.html
https://root.cern/doc/v632/TClass_8cxx_source.html:208760,Energy Efficiency,allocate,allocated,208760,"erpreterInfo() && !fCollectionProxy) {; 5433 // There is no dictionary at all and we do not have; 5434 // the services of a collection proxy available, so; 5435 // use the streamer info to approximate calling a; 5436 // destructor.; 5437 ; 5438 Bool_t inRepo = kTRUE;; 5439 Bool_t currentVersion = kFALSE;; 5440 ; 5441 // Was this object allocated through TClass?; 5442 Version_t objVer = -1;; 5443 {; 5444 R__LOCKGUARD2(fOVRMutex);; 5445 RepoCont_t::iterator iter = fObjectVersionRepository.find(p);; 5446 if (iter == fObjectVersionRepository.end()) {; 5447 // No, it wasn't, skip special version handling.; 5448 //Error(""Destructor2"", ""Attempt to delete unregistered object of class '%s' at address %p!"", GetName(), p);; 5449 inRepo = kFALSE;; 5450 } else {; 5451 //objVer = iter->second;; 5452 for (; (iter != fObjectVersionRepository.end()) && (iter->first == p); ++iter) {; 5453 objVer = iter->second;; 5454 if (objVer == fClassVersion) {; 5455 currentVersion = kTRUE;; 5456 break;; 5457 }; 5458 }; 5459 }; 5460 }; 5461 ; 5462 if (!inRepo || currentVersion) {; 5463 // The object was allocated using code for the same class version; 5464 // as is loaded now. We may proceed without worry.; 5465 TVirtualStreamerInfo* si = GetStreamerInfo();; 5466 if (si) {; 5467 si->Destructor(p, dtorOnly);; 5468 } else {; 5469 Error(""Destructor"", ""No streamer info available for class '%s' version %d at address %p, cannot destruct emulated object!"", GetName(), fClassVersion, p);; 5470 Error(""Destructor"", ""length of fStreamerInfo is %d"", fStreamerInfo->GetSize());; 5471 Int_t i = fStreamerInfo->LowerBound();; 5472 for (Int_t v = 0; v < fStreamerInfo->GetSize(); ++v, ++i) {; 5473 Error(""Destructor"", ""fStreamerInfo->At(%d): %p"", i, fStreamerInfo->At(i));; 5474 if (fStreamerInfo->At(i) != nullptr) {; 5475 Error(""Destructor"", ""Doing Dump() ..."");; 5476 ((TVirtualStreamerInfo*)fStreamerInfo->At(i))->Dump();; 5477 }; 5478 }; 5479 }; 5480 } else {; 5481 // The loaded class version is not the same as the ve",MatchSource.WIKI,doc/v632/TClass_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/TClass_8cxx_source.html
https://root.cern/doc/v632/TClass_8cxx_source.html:209717,Energy Efficiency,allocate,allocate,209717,"rrentVersion = kTRUE;; 5456 break;; 5457 }; 5458 }; 5459 }; 5460 }; 5461 ; 5462 if (!inRepo || currentVersion) {; 5463 // The object was allocated using code for the same class version; 5464 // as is loaded now. We may proceed without worry.; 5465 TVirtualStreamerInfo* si = GetStreamerInfo();; 5466 if (si) {; 5467 si->Destructor(p, dtorOnly);; 5468 } else {; 5469 Error(""Destructor"", ""No streamer info available for class '%s' version %d at address %p, cannot destruct emulated object!"", GetName(), fClassVersion, p);; 5470 Error(""Destructor"", ""length of fStreamerInfo is %d"", fStreamerInfo->GetSize());; 5471 Int_t i = fStreamerInfo->LowerBound();; 5472 for (Int_t v = 0; v < fStreamerInfo->GetSize(); ++v, ++i) {; 5473 Error(""Destructor"", ""fStreamerInfo->At(%d): %p"", i, fStreamerInfo->At(i));; 5474 if (fStreamerInfo->At(i) != nullptr) {; 5475 Error(""Destructor"", ""Doing Dump() ..."");; 5476 ((TVirtualStreamerInfo*)fStreamerInfo->At(i))->Dump();; 5477 }; 5478 }; 5479 }; 5480 } else {; 5481 // The loaded class version is not the same as the version of the code; 5482 // which was used to allocate this object. The best we can do is use; 5483 // the TVirtualStreamerInfo to try to free up some of the allocated memory.; 5484 TVirtualStreamerInfo* si = (TVirtualStreamerInfo*) fStreamerInfo->At(objVer);; 5485 if (si) {; 5486 si->Destructor(p, dtorOnly);; 5487 } else {; 5488 Error(""Destructor"", ""No streamer info available for class '%s' version %d, cannot destruct object at addr: %p"", GetName(), objVer, p);; 5489 Error(""Destructor"", ""length of fStreamerInfo is %d"", fStreamerInfo->GetSize());; 5490 Int_t i = fStreamerInfo->LowerBound();; 5491 for (Int_t v = 0; v < fStreamerInfo->GetSize(); ++v, ++i) {; 5492 Error(""Destructor2"", ""fStreamerInfo->At(%d): %p"", i, fStreamerInfo->At(i));; 5493 if (fStreamerInfo->At(i) != nullptr) {; 5494 // Do some debugging output.; 5495 Error(""Destructor2"", ""Doing Dump() ..."");; 5496 ((TVirtualStreamerInfo*)fStreamerInfo->At(i))->Dump();; 5497 }; 5498 }; 5",MatchSource.WIKI,doc/v632/TClass_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/TClass_8cxx_source.html
https://root.cern/doc/v632/TClass_8cxx_source.html:209829,Energy Efficiency,allocate,allocated,209829,"e class version; 5464 // as is loaded now. We may proceed without worry.; 5465 TVirtualStreamerInfo* si = GetStreamerInfo();; 5466 if (si) {; 5467 si->Destructor(p, dtorOnly);; 5468 } else {; 5469 Error(""Destructor"", ""No streamer info available for class '%s' version %d at address %p, cannot destruct emulated object!"", GetName(), fClassVersion, p);; 5470 Error(""Destructor"", ""length of fStreamerInfo is %d"", fStreamerInfo->GetSize());; 5471 Int_t i = fStreamerInfo->LowerBound();; 5472 for (Int_t v = 0; v < fStreamerInfo->GetSize(); ++v, ++i) {; 5473 Error(""Destructor"", ""fStreamerInfo->At(%d): %p"", i, fStreamerInfo->At(i));; 5474 if (fStreamerInfo->At(i) != nullptr) {; 5475 Error(""Destructor"", ""Doing Dump() ..."");; 5476 ((TVirtualStreamerInfo*)fStreamerInfo->At(i))->Dump();; 5477 }; 5478 }; 5479 }; 5480 } else {; 5481 // The loaded class version is not the same as the version of the code; 5482 // which was used to allocate this object. The best we can do is use; 5483 // the TVirtualStreamerInfo to try to free up some of the allocated memory.; 5484 TVirtualStreamerInfo* si = (TVirtualStreamerInfo*) fStreamerInfo->At(objVer);; 5485 if (si) {; 5486 si->Destructor(p, dtorOnly);; 5487 } else {; 5488 Error(""Destructor"", ""No streamer info available for class '%s' version %d, cannot destruct object at addr: %p"", GetName(), objVer, p);; 5489 Error(""Destructor"", ""length of fStreamerInfo is %d"", fStreamerInfo->GetSize());; 5490 Int_t i = fStreamerInfo->LowerBound();; 5491 for (Int_t v = 0; v < fStreamerInfo->GetSize(); ++v, ++i) {; 5492 Error(""Destructor2"", ""fStreamerInfo->At(%d): %p"", i, fStreamerInfo->At(i));; 5493 if (fStreamerInfo->At(i) != nullptr) {; 5494 // Do some debugging output.; 5495 Error(""Destructor2"", ""Doing Dump() ..."");; 5496 ((TVirtualStreamerInfo*)fStreamerInfo->At(i))->Dump();; 5497 }; 5498 }; 5499 }; 5500 }; 5501 ; 5502 if (inRepo && p) {; 5503 UnregisterAddressInRepository(""TClass::Destructor"",p,this);; 5504 }; 5505 } else {; 5506 Error(""Destructor"", ""This c",MatchSource.WIKI,doc/v632/TClass_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/TClass_8cxx_source.html
https://root.cern/doc/v632/TClass_8cxx_source.html:213050,Energy Efficiency,allocate,allocated,213050," 5547 // not generated by rootcint. Let's try to; 5548 // delete the array by having the interpreter; 5549 // call the array delete operator, hopefully; 5550 // the class library is loaded and there will be; 5551 // a destructor we can call.; 5552 gCling->ClassInfo_DeleteArray(GetClassInfo(),ary, dtorOnly);; 5553 } else if (!HasInterpreterInfo() && fCollectionProxy) {; 5554 // There is no dictionary at all, so this is an emulated; 5555 // class; however we do have the services of a collection proxy,; 5556 // so this is an emulated STL class.; 5557 GetCollectionProxy()->DeleteArray(ary, dtorOnly);; 5558 } else if (!HasInterpreterInfo() && !fCollectionProxy) {; 5559 // There is no dictionary at all and we do not have; 5560 // the services of a collection proxy available, so; 5561 // use the streamer info to approximate calling the; 5562 // array destructor.; 5563 ; 5564 Bool_t inRepo = kTRUE;; 5565 Bool_t currentVersion = kFALSE;; 5566 ; 5567 // Was this array object allocated through TClass?; 5568 Version_t objVer = -1;; 5569 {; 5570 R__LOCKGUARD2(fOVRMutex);; 5571 RepoCont_t::iterator iter = fObjectVersionRepository.find(p);; 5572 if (iter == fObjectVersionRepository.end()) {; 5573 // No, it wasn't, we cannot know what to do.; 5574 //Error(""DeleteArray"", ""Attempt to delete unregistered array object, element type '%s', at address %p!"", GetName(), p);; 5575 inRepo = kFALSE;; 5576 } else {; 5577 for (; (iter != fObjectVersionRepository.end()) && (iter->first == p); ++iter) {; 5578 objVer = iter->second;; 5579 if (objVer == fClassVersion) {; 5580 currentVersion = kTRUE;; 5581 break;; 5582 }; 5583 }; 5584 }; 5585 }; 5586 ; 5587 if (!inRepo || currentVersion) {; 5588 // The object was allocated using code for the same class version; 5589 // as is loaded now. We may proceed without worry.; 5590 TVirtualStreamerInfo* si = GetStreamerInfo();; 5591 if (si) {; 5592 si->DeleteArray(ary, dtorOnly);; 5593 } else {; 5594 Error(""DeleteArray"", ""No streamer info available for class '%",MatchSource.WIKI,doc/v632/TClass_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/TClass_8cxx_source.html
https://root.cern/doc/v632/TClass_8cxx_source.html:213778,Energy Efficiency,allocate,allocated,213778," (!HasInterpreterInfo() && !fCollectionProxy) {; 5559 // There is no dictionary at all and we do not have; 5560 // the services of a collection proxy available, so; 5561 // use the streamer info to approximate calling the; 5562 // array destructor.; 5563 ; 5564 Bool_t inRepo = kTRUE;; 5565 Bool_t currentVersion = kFALSE;; 5566 ; 5567 // Was this array object allocated through TClass?; 5568 Version_t objVer = -1;; 5569 {; 5570 R__LOCKGUARD2(fOVRMutex);; 5571 RepoCont_t::iterator iter = fObjectVersionRepository.find(p);; 5572 if (iter == fObjectVersionRepository.end()) {; 5573 // No, it wasn't, we cannot know what to do.; 5574 //Error(""DeleteArray"", ""Attempt to delete unregistered array object, element type '%s', at address %p!"", GetName(), p);; 5575 inRepo = kFALSE;; 5576 } else {; 5577 for (; (iter != fObjectVersionRepository.end()) && (iter->first == p); ++iter) {; 5578 objVer = iter->second;; 5579 if (objVer == fClassVersion) {; 5580 currentVersion = kTRUE;; 5581 break;; 5582 }; 5583 }; 5584 }; 5585 }; 5586 ; 5587 if (!inRepo || currentVersion) {; 5588 // The object was allocated using code for the same class version; 5589 // as is loaded now. We may proceed without worry.; 5590 TVirtualStreamerInfo* si = GetStreamerInfo();; 5591 if (si) {; 5592 si->DeleteArray(ary, dtorOnly);; 5593 } else {; 5594 Error(""DeleteArray"", ""No streamer info available for class '%s' version %d at address %p, cannot destruct object!"", GetName(), fClassVersion, ary);; 5595 Error(""DeleteArray"", ""length of fStreamerInfo is %d"", fStreamerInfo->GetSize());; 5596 Int_t i = fStreamerInfo->LowerBound();; 5597 for (Int_t v = 0; v < fStreamerInfo->GetSize(); ++v, ++i) {; 5598 Error(""DeleteArray"", ""fStreamerInfo->At(%d): %p"", v, fStreamerInfo->At(i));; 5599 if (fStreamerInfo->At(i)) {; 5600 Error(""DeleteArray"", ""Doing Dump() ..."");; 5601 ((TVirtualStreamerInfo*)fStreamerInfo->At(i))->Dump();; 5602 }; 5603 }; 5604 }; 5605 } else {; 5606 // The loaded class version is not the same as the version of th",MatchSource.WIKI,doc/v632/TClass_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/TClass_8cxx_source.html
https://root.cern/doc/v632/TClass_8cxx_source.html:214724,Energy Efficiency,allocate,allocate,214724," {; 5580 currentVersion = kTRUE;; 5581 break;; 5582 }; 5583 }; 5584 }; 5585 }; 5586 ; 5587 if (!inRepo || currentVersion) {; 5588 // The object was allocated using code for the same class version; 5589 // as is loaded now. We may proceed without worry.; 5590 TVirtualStreamerInfo* si = GetStreamerInfo();; 5591 if (si) {; 5592 si->DeleteArray(ary, dtorOnly);; 5593 } else {; 5594 Error(""DeleteArray"", ""No streamer info available for class '%s' version %d at address %p, cannot destruct object!"", GetName(), fClassVersion, ary);; 5595 Error(""DeleteArray"", ""length of fStreamerInfo is %d"", fStreamerInfo->GetSize());; 5596 Int_t i = fStreamerInfo->LowerBound();; 5597 for (Int_t v = 0; v < fStreamerInfo->GetSize(); ++v, ++i) {; 5598 Error(""DeleteArray"", ""fStreamerInfo->At(%d): %p"", v, fStreamerInfo->At(i));; 5599 if (fStreamerInfo->At(i)) {; 5600 Error(""DeleteArray"", ""Doing Dump() ..."");; 5601 ((TVirtualStreamerInfo*)fStreamerInfo->At(i))->Dump();; 5602 }; 5603 }; 5604 }; 5605 } else {; 5606 // The loaded class version is not the same as the version of the code; 5607 // which was used to allocate this array. The best we can do is use; 5608 // the TVirtualStreamerInfo to try to free up some of the allocated memory.; 5609 TVirtualStreamerInfo* si = (TVirtualStreamerInfo*) fStreamerInfo->At(objVer);; 5610 if (si) {; 5611 si->DeleteArray(ary, dtorOnly);; 5612 } else {; 5613 Error(""DeleteArray"", ""No streamer info available for class '%s' version %d at address %p, cannot destruct object!"", GetName(), objVer, ary);; 5614 Error(""DeleteArray"", ""length of fStreamerInfo is %d"", fStreamerInfo->GetSize());; 5615 Int_t i = fStreamerInfo->LowerBound();; 5616 for (Int_t v = 0; v < fStreamerInfo->GetSize(); ++v, ++i) {; 5617 Error(""DeleteArray"", ""fStreamerInfo->At(%d): %p"", v, fStreamerInfo->At(i));; 5618 if (fStreamerInfo->At(i)) {; 5619 // Print some debugging info.; 5620 Error(""DeleteArray"", ""Doing Dump() ..."");; 5621 ((TVirtualStreamerInfo*)fStreamerInfo->At(i))->Dump();; 5622 }; 5623 }; 5",MatchSource.WIKI,doc/v632/TClass_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/TClass_8cxx_source.html
https://root.cern/doc/v632/TClass_8cxx_source.html:214835,Energy Efficiency,allocate,allocated,214835," for the same class version; 5589 // as is loaded now. We may proceed without worry.; 5590 TVirtualStreamerInfo* si = GetStreamerInfo();; 5591 if (si) {; 5592 si->DeleteArray(ary, dtorOnly);; 5593 } else {; 5594 Error(""DeleteArray"", ""No streamer info available for class '%s' version %d at address %p, cannot destruct object!"", GetName(), fClassVersion, ary);; 5595 Error(""DeleteArray"", ""length of fStreamerInfo is %d"", fStreamerInfo->GetSize());; 5596 Int_t i = fStreamerInfo->LowerBound();; 5597 for (Int_t v = 0; v < fStreamerInfo->GetSize(); ++v, ++i) {; 5598 Error(""DeleteArray"", ""fStreamerInfo->At(%d): %p"", v, fStreamerInfo->At(i));; 5599 if (fStreamerInfo->At(i)) {; 5600 Error(""DeleteArray"", ""Doing Dump() ..."");; 5601 ((TVirtualStreamerInfo*)fStreamerInfo->At(i))->Dump();; 5602 }; 5603 }; 5604 }; 5605 } else {; 5606 // The loaded class version is not the same as the version of the code; 5607 // which was used to allocate this array. The best we can do is use; 5608 // the TVirtualStreamerInfo to try to free up some of the allocated memory.; 5609 TVirtualStreamerInfo* si = (TVirtualStreamerInfo*) fStreamerInfo->At(objVer);; 5610 if (si) {; 5611 si->DeleteArray(ary, dtorOnly);; 5612 } else {; 5613 Error(""DeleteArray"", ""No streamer info available for class '%s' version %d at address %p, cannot destruct object!"", GetName(), objVer, ary);; 5614 Error(""DeleteArray"", ""length of fStreamerInfo is %d"", fStreamerInfo->GetSize());; 5615 Int_t i = fStreamerInfo->LowerBound();; 5616 for (Int_t v = 0; v < fStreamerInfo->GetSize(); ++v, ++i) {; 5617 Error(""DeleteArray"", ""fStreamerInfo->At(%d): %p"", v, fStreamerInfo->At(i));; 5618 if (fStreamerInfo->At(i)) {; 5619 // Print some debugging info.; 5620 Error(""DeleteArray"", ""Doing Dump() ..."");; 5621 ((TVirtualStreamerInfo*)fStreamerInfo->At(i))->Dump();; 5622 }; 5623 }; 5624 }; 5625 }; 5626 ; 5627 // Deregister the object for special handling in the destructor.; 5628 if (inRepo && p) {; 5629 UnregisterAddressInRepository(""TClass::Delete",MatchSource.WIKI,doc/v632/TClass_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/TClass_8cxx_source.html
https://root.cern/doc/v632/TClass_8cxx_source.html:224932,Energy Efficiency,allocate,allocated,224932,".; 5846 } else {; 5847 ::Error(""TClass::LoadClassInfo"", ""no interpreter information for class %s is available""; 5848 "" even though it has a TClass initialization routine."",; 5849 fName.Data());; 5850 }; 5851 return;; 5852 }; 5853 ; 5854 fCanLoadClassInfo = false;; 5855}; 5856 ; 5857////////////////////////////////////////////////////////////////////////////////; 5858/// Store class description on I/O buffer.; 5859 ; 5860void TClass::Store(TBuffer &b) const; 5861{; 5862 b.WriteString(GetName());; 5863}; 5864 ; 5865////////////////////////////////////////////////////////////////////////////////; 5866/// Global function called by a class' static Dictionary() method; 5867/// (see the ClassDef macro).; 5868 ; 5869TClass *ROOT::CreateClass(const char *cname, Version_t id,; 5870 const std::type_info &info, TVirtualIsAProxy *isa,; 5871 const char *dfil, const char *ifil,; 5872 Int_t dl, Int_t il); 5873{; 5874 // When called via TMapFile (e.g. Update()) make sure that the dictionary; 5875 // gets allocated on the heap and not in the mapped file.; 5876 TMmallocDescTemp setreset;; 5877 return new TClass(cname, id, info, isa, dfil, ifil, dl, il);; 5878}; 5879 ; 5880////////////////////////////////////////////////////////////////////////////////; 5881/// Global function called by a class' static Dictionary() method; 5882/// (see the ClassDef macro).; 5883 ; 5884TClass *ROOT::CreateClass(const char *cname, Version_t id,; 5885 const char *dfil, const char *ifil,; 5886 Int_t dl, Int_t il); 5887{; 5888 // When called via TMapFile (e.g. Update()) make sure that the dictionary; 5889 // gets allocated on the heap and not in the mapped file.; 5890 TMmallocDescTemp setreset;; 5891 return new TClass(cname, id, dfil, ifil, dl, il);; 5892}; 5893 ; 5894////////////////////////////////////////////////////////////////////////////////; 5895/// Static method returning the defConstructor flag passed to TClass::New().; 5896/// New type is either:; 5897/// - TClass::kRealNew - when called via plain",MatchSource.WIKI,doc/v632/TClass_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/TClass_8cxx_source.html
https://root.cern/doc/v632/TClass_8cxx_source.html:225528,Energy Efficiency,allocate,allocated,225528,"///; 5866/// Global function called by a class' static Dictionary() method; 5867/// (see the ClassDef macro).; 5868 ; 5869TClass *ROOT::CreateClass(const char *cname, Version_t id,; 5870 const std::type_info &info, TVirtualIsAProxy *isa,; 5871 const char *dfil, const char *ifil,; 5872 Int_t dl, Int_t il); 5873{; 5874 // When called via TMapFile (e.g. Update()) make sure that the dictionary; 5875 // gets allocated on the heap and not in the mapped file.; 5876 TMmallocDescTemp setreset;; 5877 return new TClass(cname, id, info, isa, dfil, ifil, dl, il);; 5878}; 5879 ; 5880////////////////////////////////////////////////////////////////////////////////; 5881/// Global function called by a class' static Dictionary() method; 5882/// (see the ClassDef macro).; 5883 ; 5884TClass *ROOT::CreateClass(const char *cname, Version_t id,; 5885 const char *dfil, const char *ifil,; 5886 Int_t dl, Int_t il); 5887{; 5888 // When called via TMapFile (e.g. Update()) make sure that the dictionary; 5889 // gets allocated on the heap and not in the mapped file.; 5890 TMmallocDescTemp setreset;; 5891 return new TClass(cname, id, dfil, ifil, dl, il);; 5892}; 5893 ; 5894////////////////////////////////////////////////////////////////////////////////; 5895/// Static method returning the defConstructor flag passed to TClass::New().; 5896/// New type is either:; 5897/// - TClass::kRealNew - when called via plain new; 5898/// - TClass::kClassNew - when called via TClass::New(); 5899/// - TClass::kDummyNew - when called via TClass::New() but object is a dummy,; 5900/// in which case the object ctor might take short cuts; 5901 ; 5902TClass::ENewType TClass::IsCallingNew(); 5903{; 5904 return TClass__GetCallingNew();; 5905}; 5906 ; 5907////////////////////////////////////////////////////////////////////////////////; 5908/// Return true if the shared library of this class is currently in the a; 5909/// process's memory. Return false, after the shared library has been; 5910/// unloaded or if this is an",MatchSource.WIKI,doc/v632/TClass_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/TClass_8cxx_source.html
https://root.cern/doc/v632/TClass_8cxx_source.html:228331,Energy Efficiency,efficient,efficiently,228331,"first' from; 5927/// TObject.; 5928 ; 5929Bool_t TClass::IsStartingWithTObject() const; 5930{; 5931 if (fProperty==(-1)) Property();; 5932 return TestBit(kStartWithTObject);; 5933}; 5934 ; 5935////////////////////////////////////////////////////////////////////////////////; 5936/// Return kTRUE is the class inherits from TObject.; 5937 ; 5938Bool_t TClass::IsTObject() const; 5939{; 5940 if (fProperty==(-1)) Property();; 5941 return TestBit(kIsTObject);; 5942}; 5943 ; 5944////////////////////////////////////////////////////////////////////////////////; 5945/// Return kTRUE is the class is Foreign (the class does not have a Streamer method).; 5946 ; 5947Bool_t TClass::IsForeign() const; 5948{; 5949 if (fProperty==(-1)) Property();; 5950 // If the property are not set and the class is a pair, hard code that; 5951 // it is a unversioned/Foreign class.; 5952 return TestBit(kIsForeign);; 5953}; 5954 ; 5955////////////////////////////////////////////////////////////////////////////////; 5956/// Do the initialization that can only be done after the CINT dictionary has; 5957/// been fully populated and can not be delayed efficiently.; 5958 ; 5959void TClass::PostLoadCheck(); 5960{; 5961 // In the case of a Foreign class (loaded class without a Streamer function); 5962 // we reset fClassVersion to be -1 so that the current TVirtualStreamerInfo will not; 5963 // be confused with a previously loaded streamerInfo.; 5964 ; 5965 if (IsLoaded() && HasInterpreterInfo() && fClassVersion==1 /*&& fStreamerInfo; 5966 && fStreamerInfo->At(1)*/ && IsForeign() ); 5967 {; 5968 SetClassVersion(-1);; 5969 }; 5970 // Note: We are careful to check the class version first because checking; 5971 // for foreign can trigger an AutoParse.; 5972 else if (IsLoaded() && HasDataMemberInfo() && fStreamerInfo && ((fClassVersion > 1) || !IsForeign())); 5973 {; 5974 R__LOCKGUARD(gInterpreterMutex);; 5975 ; 5976 TVirtualStreamerInfo *info = (TVirtualStreamerInfo*)(fStreamerInfo->At(fClassVersion));; 5977 // H",MatchSource.WIKI,doc/v632/TClass_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/TClass_8cxx_source.html
https://root.cern/doc/v632/TClass_8cxx_source.html:234738,Energy Efficiency,allocate,allocated,234738," Streamer method; 6078/// kInstrumented: the class does have a Streamer method; 6079/// kExternal: the class has a free standing way of streaming itself; 6080/// kEmulatedStreamer: the class is missing its shared library.; 6081/// ~~~; 6082///; 6083/// Implementation note: the data member fProperty has the value -1; 6084/// until it is initialized.; 6085 ; 6086Long_t TClass::Property() const; 6087{; 6088 // Check if we can return without taking the lock,; 6089 // this is valid since fProperty is atomic and set as; 6090 // the last operation before return.; 6091 if (fProperty!=(-1)) return fProperty;; 6092 ; 6093 R__LOCKGUARD(gInterpreterMutex);; 6094 ; 6095 // Check if another thread set fProperty while we; 6096 // were waiting.; 6097 if (fProperty!=(-1)) return fProperty;; 6098 ; 6099 // Avoid asking about the class when it is still building; 6100 if (TestBit(kLoading)) return fProperty;; 6101 ; 6102 // When called via TMapFile (e.g. Update()) make sure that the dictionary; 6103 // gets allocated on the heap and not in the mapped file.; 6104 TMmallocDescTemp setreset;; 6105 ; 6106 TClass *kl = const_cast<TClass*>(this);; 6107 ; 6108 kl->fStreamerType = TClass::kDefault;; 6109 kl->fStreamerImpl = &TClass::StreamerDefault;; 6110 ; 6111 if (InheritsFrom(TObject::Class())) {; 6112 kl->SetBit(kIsTObject);; 6113 ; 6114 // Is it DIRECT inheritance from TObject?; 6115 Int_t delta = kl->GetBaseClassOffsetRecurse(TObject::Class());; 6116 if (delta==0) kl->SetBit(kStartWithTObject);; 6117 ; 6118 kl->fStreamerType = kTObject;; 6119 kl->fStreamerImpl = &TClass::StreamerTObject;; 6120 }; 6121 ; 6122 if (HasInterpreterInfo()) {; 6123 ; 6124 // This code used to use ClassInfo_Has|IsValidMethod but since v6; 6125 // they return true if the routine is defined in the class or any of; 6126 // its parent. We explicitly want to know whether the function is; 6127 // defined locally.; 6128 if (!const_cast<TClass*>(this)->GetClassMethodWithPrototype(""Streamer"",""TBuffer&"",kFALSE)) {; 6129 ;",MatchSource.WIKI,doc/v632/TClass_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/TClass_8cxx_source.html
https://root.cern/doc/v632/TClass_8cxx_source.html:309191,Energy Efficiency,allocate,allocated,309191,"st char *datamember) constReturn pointer to datamember object with name ""datamember"".Definition TClass.cxx:3439; TClass::fIsATVirtualIsAProxy * fIsADefinition TClass.h:229; TClass::GetListOfUsingDataMembersTList * GetListOfUsingDataMembers(Bool_t load=kTRUE)Return list containing the TDataMembers of using declarations of a class.Definition TClass.cxx:3786; TClass::ForceReloadvoid ForceReload(TClass *oldcl)we found at least one equivalent.Definition TClass.cxx:1336; TClass::fDeleteArrayROOT::DelArrFunc_t fDeleteArrayDefinition TClass.h:238; TClass::CanSplitBool_t CanSplit() constReturn true if the data member of this TClass can be saved separately.Definition TClass.cxx:2319; TClass::fStreamerTClassStreamer * fStreamerDefinition TClass.h:226; TClass::SetDirectoryAutoAddvoid SetDirectoryAutoAdd(ROOT::DirAutoAdd_t dirAutoAddFunc)Install a new wrapper around the directory auto add function.Definition TClass.cxx:7028; TClass::NewArrayvoid * NewArray(Long_t nElements, ENewType defConstructor=kClassNew) constReturn a pointer to a newly allocated array of objects of this class.Definition TClass.cxx:5193; TClass::fNoInfoOrEmuOrFwdDeclNameRegistrystatic TDeclNameRegistry fNoInfoOrEmuOrFwdDeclNameRegistryDefinition TClass.h:328; TClass::fFuncTemplateTListOfFunctionTemplates * fFuncTemplateDefinition TClass.h:206; TClass::fStreamerFuncClassStreamerFunc_t fStreamerFuncDefinition TClass.h:241; TClass::AdoptReferenceProxyvoid AdoptReferenceProxy(TVirtualRefProxy *proxy)Adopt the Reference proxy pointer to indicate that this class represents a reference.Definition TClass.cxx:6685; TClass::GetClassMethodTMethod * GetClassMethod(Longptr_t faddr)Look for a method in this class that has the interface function address faddr.Definition TClass.cxx:4483; TClass::DetermineCurrentStreamerInfoTVirtualStreamerInfo * DetermineCurrentStreamerInfo()Determine and set pointer to current TVirtualStreamerInfo.Definition TClass.cxx:5684; TClass::Browsevoid Browse(TBrowser *b) overrideThis method is call",MatchSource.WIKI,doc/v632/TClass_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/TClass_8cxx_source.html
https://root.cern/doc/v632/TClass_8cxx_source.html:311919,Energy Efficiency,allocate,allocated,311919,"nc_t GetStreamerFunc() constGet a wrapper/accessor function around this class custom streamer (member function).Definition TClass.cxx:2939; TClass::RemoveStreamerInfovoid RemoveStreamerInfo(Int_t slot)Remove and delete the StreamerInfo in the given slot.Definition TClass.cxx:7320; TClass::SetCanSplitvoid SetCanSplit(Int_t splitmode)Set the splitability of this class:Definition TClass.cxx:5658; TClass::CreateListOfDataMembersTList * CreateListOfDataMembers(std::atomic< TListOfDataMembers * > &data, TDictionary::EMemberSelection selection, bool load)Create the list containing the TDataMembers (of actual data members or members pulled in through usin...Definition TClass.cxx:3741; TClass::GetStreamerInfoAbstractEmulatedTVirtualStreamerInfo * GetStreamerInfoAbstractEmulated(Int_t version=0) constFor the case where the requestor class is emulated and this class is abstract, returns a pointer to t...Definition TClass.cxx:4709; TClass::Newvoid * New(ENewType defConstructor=kClassNew, Bool_t quiet=kFALSE) constReturn a pointer to a newly allocated object of this class.Definition TClass.cxx:4978; TClass::SetMergevoid SetMerge(ROOT::MergeFunc_t mergeFunc)Install a new wrapper around 'Merge'.Definition TClass.cxx:6969; TClass::fConversionStreamerInfoConvSIMap_t fConversionStreamerInfoDefinition TClass.h:199; TClass::fDirAutoAddROOT::DirAutoAdd_t fDirAutoAddDefinition TClass.h:240; TClass::HasDataMemberInfoBool_t HasDataMemberInfo() constDefinition TClass.h:407; TClass::fRefProxyTVirtualRefProxy * fRefProxycached streamer info used in the last read.Definition TClass.h:280; TClass::GetMenuListTList * GetMenuList() constReturn the list of menu items associated with the class.Definition TClass.cxx:4341; TClass::fMergeROOT::MergeFunc_t fMergesaved info to call a IsA member functionDefinition TClass.h:233; TClass::GetMethodTMethod * GetMethod(const char *method, const char *params, Bool_t objectIsConst=kFALSE)Find the best method (if there is one) matching the parameters.Definition T",MatchSource.WIKI,doc/v632/TClass_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/TClass_8cxx_source.html
https://root.cern/doc/v632/TClass_8cxx_source.html:333397,Energy Efficiency,allocate,allocated,333397,"tCheckSumDefinition TClass.h:117; TClass::kNoRange@ kNoRangeDefinition TClass.h:112; TClass::kCurrentCheckSum@ kCurrentCheckSumDefinition TClass.h:109; TClass::kNoBaseCheckSum@ kNoBaseCheckSumDefinition TClass.h:116; TClass::kReflex@ kReflexDefinition TClass.h:114; TClass::kReflexNoComment@ kReflexNoCommentDefinition TClass.h:111; TClass::kWithTypeDef@ kWithTypeDefDefinition TClass.h:113; TClass::kNoRangeCheck@ kNoRangeCheckDefinition TClass.h:115; TClass::kNoEnum@ kNoEnumDefinition TClass.h:110; TClass::Dumpvoid Dump() const overrideDump contents of object on stdout.Definition TClass.h:398; TClass::InheritsFromBool_t InheritsFrom(const char *cl) const overrideReturn kTRUE if this class inherits from a class with name ""classname"".Definition TClass.cxx:4874; TClass::GetBaseClassOffsetInt_t GetBaseClassOffset(const TClass *toBase, void *address=nullptr, bool isDerivedObject=true)Definition TClass.cxx:2791; TClass::NewObjectArrayObjectPtr NewObjectArray(Long_t nElements, ENewType defConstructor=kClassNew) constReturn a pointer to a newly allocated array of objects of this class.Definition TClass.cxx:5209; TClass::GetCollectionProxyTVirtualCollectionProxy * GetCollectionProxy() constReturn the proxy describing the collection (if any).Definition TClass.cxx:2897; TClass::ResetCachesvoid ResetCaches()To clean out all caches.Definition TClass.cxx:4215; TClass::fVersionUsedstd::atomic< Bool_t > fVersionUsedsaved remember if fOffsetStreamer has been set.Definition TClass.h:262; TClass::ClassPropertyLong_t ClassProperty() constReturn the C++ property of this class, eg.Definition TClass.cxx:2396; TClass::SetStreamerImplvoid SetStreamerImpl()Internal routine to set fStreamerImpl based on the value of fStreamerType.Definition TClass.cxx:6215; TClass::GetSharedLibsconst char * GetSharedLibs()Get the list of shared libraries containing the code for class cls.Definition TClass.cxx:3623; TClass::CalculateStreamerOffsetvoid CalculateStreamerOffset() constCalculate the offset between a",MatchSource.WIKI,doc/v632/TClass_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/TClass_8cxx_source.html
https://root.cern/doc/v632/TClass_8cxx_source.html:356656,Energy Efficiency,efficient,efficient,356656,"ndObject(const TObject *obj) const overrideFind object using its hash value (returned by its Hash() member).Definition TListOfFunctions.cxx:443; TListA doubly linked list.Definition TList.h:38; TList::FindObjectTObject * FindObject(const char *name) const overrideFind an object in this list using its name.Definition TList.cxx:576; TList::Addvoid Add(TObject *obj) overrideDefinition TList.h:83; TList::RemoveTObject * Remove(TObject *obj) overrideRemove object from the list.Definition TList.cxx:820; TList::AddLastvoid AddLast(TObject *obj) overrideAdd object at the end of the list.Definition TList.cxx:150; TList::FirstLinkvirtual TObjLink * FirstLink() constDefinition TList.h:104; TList::Deletevoid Delete(Option_t *option="""") overrideRemove all objects from the list AND delete all heap based objects.Definition TList.cxx:468; TList::AddFirstvoid AddFirst(TObject *obj) overrideAdd object at the beginning of the list.Definition TList.cxx:98; TMapTMap implements an associative array of (key,value) pairs using a THashTable for efficient retrieval ...Definition TMap.h:40; TMemberInspectorAbstract base class for accessing the data-members of a class.Definition TMemberInspector.h:31; TMemberInspector::Inspectvirtual void Inspect(TClass *cl, const char *parent, const char *name, const void *addr)Definition TMemberInspector.cxx:99; TMemberStreamerDefinition TMemberStreamer.h:26; TMethodArgEach ROOT method (see TMethod) has a linked list of its arguments.Definition TMethodArg.h:36; TMethodArg::GetFullTypeNameconst char * GetFullTypeName() constGet full type description of method argument, e.g.: ""class TDirectory*"".Definition TMethodArg.cxx:74; TMethodEach ROOT class (see TClass) has a linked list of methods.Definition TMethod.h:38; TMethod::GetClassTClass * GetClass() constDefinition TMethod.h:55; TMethod::IsMenuItemEMenuItemKind IsMenuItem() constDefinition TMethod.h:56; TMethod::GetListOfMethodArgsvirtual TList * GetListOfMethodArgs()Returns methodarg list and additionally upd",MatchSource.WIKI,doc/v632/TClass_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/TClass_8cxx_source.html
https://root.cern/doc/v632/TClass_8cxx_source.html:13758,Integrability,wrap,wrapper,13758,"{; 339 // Register in the repository that an object has moved.; 340 ; 341 // Move not only the object itself but also any base classes or sub-objects.; 342 size_t objsize = what->Size();; 343 long delta = (char*)newadd - (char*)oldadd;; 344 R__LOCKGUARD2(fOVRMutex);; 345 RepoCont_t::iterator cur = fObjectVersionRepository.find(oldadd);; 346 for (; cur != fObjectVersionRepository.end();) {; 347 RepoCont_t::iterator tmp = cur++;; 348 if (oldadd <= tmp->first && tmp->first < ( ((char*)oldadd) + objsize) ) {; 349 // The location is within the object, let's move it.; 350 ; 351 fObjectVersionRepository.insert(RepoCont_t::value_type(((char*)tmp->first)+delta, tmp->second));; 352 fObjectVersionRepository.erase(tmp);; 353 ; 354 } else {; 355 // -- No address, version match, we've reached the end.; 356 break;; 357 }; 358 }; 359}; 360 ; 361//______________________________________________________________________________; 362//______________________________________________________________________________; 363namespace ROOT {; 364#define R__USE_STD_MAP; 365 class TMapTypeToTClass {; 366#if defined R__USE_STD_MAP; 367 // This wrapper class allow to avoid putting #include <map> in the; 368 // TROOT.h header file.; 369 public:; 370 typedef std::map<std::string,TClass*> IdMap_t;; 371 typedef IdMap_t::key_type key_type;; 372 typedef IdMap_t::const_iterator const_iterator;; 373 typedef IdMap_t::size_type size_type;; 374#ifdef R__WIN32; 375 // Window's std::map does NOT defined mapped_type; 376 typedef TClass* mapped_type;; 377#else; 378 typedef IdMap_t::mapped_type mapped_type;; 379#endif; 380 ; 381 private:; 382 IdMap_t fMap;; 383 ; 384 public:; 385 void Add(const key_type &key, mapped_type &obj); 386 {; 387 // Add the <key,obj> pair to the map.; 388 fMap[key] = obj;; 389 }; 390 mapped_type Find(const key_type &key) const; 391 {; 392 // Find the type corresponding to the key.; 393 IdMap_t::const_iterator iter = fMap.find(key);; 394 mapped_type cl = nullptr;; 395 if (iter != fMap.end()",MatchSource.WIKI,doc/v632/TClass_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/TClass_8cxx_source.html
https://root.cern/doc/v632/TClass_8cxx_source.html:38391,Integrability,interface,interface,38391,"merMember(kFALSE), fProperty(0), fClassProperty(0), fHasRootPcmInfo(kFALSE), fCanLoadClassInfo(kFALSE),; 1079 fIsOffsetStreamerSet(kFALSE), fVersionUsed(kFALSE), fRuntimeProperties(0), fOffsetStreamer(0), fStreamerType(TClass::kDefault),; 1080 fState(kNoInfo),; 1081 fCurrentInfo(nullptr), fLastReadInfo(nullptr), fRefProxy(nullptr),; 1082 fSchemaRules(nullptr), fStreamerImpl(&TClass::StreamerDefault); 1083 ; 1084{; 1085 // Default ctor.; 1086 ; 1087 R__LOCKGUARD(gInterpreterMutex);; 1088 {; 1089 TMmallocDescTemp setreset;; 1090 fStreamerInfo = new TObjArray(1, -2);; 1091 }; 1092 fDeclFileLine = -2; // -2 for standalone TClass (checked in dtor); 1093}; 1094 ; 1095////////////////////////////////////////////////////////////////////////////////; 1096/// Create a TClass object. This object contains the full dictionary; 1097/// of a class. It has list to baseclasses, datamembers and methods.; 1098/// Use this ctor to create a standalone TClass object. Only useful; 1099/// to get a temporary TClass interface to an interpreted class. Used by TTabCom.; 1100///; 1101/// \note Use `TClass::GetClass(""ClassName"")` to get access to a TClass object for a certain class!; 1102 ; 1103TClass::TClass(const char *name, Bool_t silent) :; 1104 TDictionary(name),; 1105 fPersistentRef(nullptr),; 1106 fStreamerInfo(nullptr), fConversionStreamerInfo(nullptr), fRealData(nullptr),; 1107 fBase(nullptr), fData(nullptr), fUsingData(nullptr), fEnums(nullptr), fFuncTemplate(nullptr), fMethod(nullptr), fAllPubData(nullptr),; 1108 fAllPubMethod(nullptr), fClassMenuList(nullptr),; 1109 fDeclFileName(""""), fImplFileName(""""), fDeclFileLine(0), fImplFileLine(0),; 1110 fInstanceCount(0), fOnHeap(0),; 1111 fCheckSum(0), fCollectionProxy(nullptr), fClassVersion(0), fClassInfo(nullptr),; 1112 fTypeInfo(nullptr), fShowMembers(nullptr),; 1113 fStreamer(nullptr), fIsA(nullptr), fGlobalIsA(nullptr), fIsAMethod(nullptr),; 1114 fMerge(nullptr), fResetAfterMerge(nullptr), fNew(nullptr), fNewArray(nullptr), fDelete(nu",MatchSource.WIKI,doc/v632/TClass_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/TClass_8cxx_source.html
https://root.cern/doc/v632/TClass_8cxx_source.html:45390,Integrability,interface,interface,45390,"&TClass::StreamerDefault); 1197{; 1198 R__LOCKGUARD(gInterpreterMutex);; 1199 ; 1200 // Treat the case in which a TClass instance is created for a namespace; 1201 if (theState == kNamespaceForMeta){; 1202 fProperty = kIsNamespace;; 1203 theState = kForwardDeclared; // it immediately decays in kForwardDeclared; 1204 }; 1205 ; 1206 if (theState != kForwardDeclared && theState != kEmulated); 1207 ::Fatal(""TClass::TClass"",; 1208 ""A TClass entry cannot be initialized in a state different from kForwardDeclared or kEmulated."");; 1209 Init(name, cversion, nullptr, nullptr, nullptr, nullptr, -1, -1, nullptr, silent);; 1210}; 1211 ; 1212////////////////////////////////////////////////////////////////////////////////; 1213/// Internal constructor.; 1214///; 1215/// Create a TClass object. This object contains the full dictionary; 1216/// of a class. It has list to baseclasses, datamembers and methods.; 1217/// Use this ctor to create a standalone TClass object. Most useful; 1218/// to get a TClass interface to an interpreted class. Used by TTabCom.; 1219///; 1220/// This copies the ClassInfo (i.e. does *not* take ownership of it).; 1221///; 1222/// \note Use `TClass::GetClass(""class"")` to get access to a TClass object for a certain class!; 1223 ; 1224TClass::TClass(ClassInfo_t *classInfo, Version_t cversion,; 1225 const char *dfil, const char *ifil, Int_t dl, Int_t il, Bool_t silent) :; 1226 TDictionary(""""),; 1227 fPersistentRef(nullptr),; 1228 fStreamerInfo(nullptr), fConversionStreamerInfo(nullptr), fRealData(nullptr),; 1229 fBase(nullptr), fData(nullptr), fUsingData(nullptr), fEnums(nullptr), fFuncTemplate(nullptr), fMethod(nullptr), fAllPubData(nullptr),; 1230 fAllPubMethod(nullptr), fClassMenuList(nullptr),; 1231 fDeclFileName(""""), fImplFileName(""""), fDeclFileLine(0), fImplFileLine(0),; 1232 fInstanceCount(0), fOnHeap(0),; 1233 fCheckSum(0), fCollectionProxy(nullptr), fClassVersion(0), fClassInfo(nullptr),; 1234 fTypeInfo(nullptr), fShowMembers(nullptr),; 1235 fStreamer(n",MatchSource.WIKI,doc/v632/TClass_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/TClass_8cxx_source.html
https://root.cern/doc/v632/TClass_8cxx_source.html:59739,Integrability,rout,routine,59739,"7 gInterpreter->SetClassInfo(this, kFALSE, silent); // sets fClassInfo pointer; 1518 if (fClassInfo) {; 1519 // This should be moved out of GetCheckSum itself however the last time; 1520 // we tried this cause problem, in particular in the end-of-process operation.; 1521 // fCheckSum = GetCheckSum(kLatestCheckSum);; 1522 } else {; 1523 if (!fClassInfo) {; 1524 if (IsZombie()) {; 1525 TClass::RemoveClass(this);; 1526 return;; 1527 }; 1528 }; 1529 }; 1530 }; 1531 }; 1532 if (!silent && (!fClassInfo && !fCanLoadClassInfo) && !isStl && !TClassEdit::IsArtificial(fName) &&; 1533 !TClassEdit::IsInterpreterDetail(fName.Data()) ) {; 1534 if (fState == kHasTClassInit) {; 1535 if (fImplFileLine == -1 && fClassVersion == 0) {; 1536 // We have a 'transient' class with a ClassDefInline and apparently no interpreter; 1537 // information. Since it is transient, it is more than likely that the lack; 1538 // will be harmles.; 1539 } else {; 1540 ::Error(""TClass::Init"", ""no interpreter information for class %s is available even though it has a TClass ""; 1541 ""initialization routine."",; 1542 fName.Data());; 1543 }; 1544 } else {; 1545 const bool ispairbase = TClassEdit::IsStdPairBase(fName.Data()) && !IsFromRootCling();; 1546 if (!ispairbase); 1547 ::Warning(""TClass::Init"", ""no dictionary for class %s is available"", fName.Data());; 1548 }; 1549 }; 1550 ; 1551 fgClassCount++;; 1552 SetUniqueID(fgClassCount);; 1553 ; 1554 // Make the typedef-expanded -> original hash table entries.; 1555 // There may be several entries for any given key.; 1556 // We only make entries if the typedef-expanded name; 1557 // is different from the original name.; 1558 TString resolvedThis;; 1559 if (!givenInfo && strchr (name, '<')) {; 1560 if ( fName != name) {; 1561 if (!fgClassTypedefHash) {; 1562 fgClassTypedefHash = new THashTable (100, 5);; 1563 fgClassTypedefHash->SetOwner (kTRUE);; 1564 }; 1565 ; 1566 fgClassTypedefHash->Add (new TNameMapNode (name, fName));; 1567 SetBit (kHasNameMapNode);; 1568 ; 156",MatchSource.WIKI,doc/v632/TClass_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/TClass_8cxx_source.html
https://root.cern/doc/v632/TClass_8cxx_source.html:62404,Integrability,interface,interface,62404," fgClassTypedefHash) {; 1592 ; 1593 // Check for existing equivalent.; 1594 ; 1595 if (resolvedThis != fName) {; 1596 oldcl = (TClass*)gROOT->GetListOfClasses()->FindObject(resolvedThis);; 1597 if (oldcl && oldcl != this) {; 1598 persistentRef = oldcl->fPersistentRef.exchange(nullptr);; 1599 ForceReload (oldcl);; 1600 }; 1601 }; 1602 TIter next( fgClassTypedefHash->GetListForObject(resolvedThis) );; 1603 while ( TNameMapNode* htmp = static_cast<TNameMapNode*> (next()) ) {; 1604 if (resolvedThis != htmp->String()) continue;; 1605 oldcl = (TClass*)gROOT->GetListOfClasses()->FindObject(htmp->fOrigName); // gROOT->GetClass (htmp->fOrigName, kFALSE);; 1606 if (oldcl && oldcl != this) {; 1607 persistentRef = oldcl->fPersistentRef.exchange(nullptr);; 1608 ForceReload (oldcl);; 1609 }; 1610 }; 1611 }; 1612 if (fClassInfo) {; 1613 SetTitle(gCling->ClassInfo_Title(fClassInfo));; 1614 if ( fDeclFileName == nullptr || fDeclFileName[0] == '\0' ) {; 1615 fDeclFileName = kUndeterminedClassInfoName;; 1616 // Missing interface:; 1617 // fDeclFileLine = gInterpreter->ClassInfo_FileLine( fClassInfo );; 1618 ; 1619 // But really do not want to set ImplFileLine as it is currently the; 1620 // marker of being 'loaded' or not (reminder loaded == has a TClass bootstrap).; 1621 }; 1622 }; 1623 ; 1624 if (persistentRef) {; 1625 fPersistentRef = persistentRef;; 1626 } else {; 1627 fPersistentRef = new TClass*;; 1628 }; 1629 *fPersistentRef = this;; 1630 ; 1631 if ( isStl || !strncmp(GetName(),""stdext::hash_"",13) || !strncmp(GetName(),""__gnu_cxx::hash_"",16) ) {; 1632 if (fState != kHasTClassInit) {; 1633 // If we have a TClass compiled initialization, we can safely assume that; 1634 // there will also be a collection proxy.; 1635 fCollectionProxy = TVirtualStreamerInfo::Factory()->GenEmulatedProxy( GetName(), silent );; 1636 if (fCollectionProxy) {; 1637 fSizeof = fCollectionProxy->Sizeof();; 1638 ; 1639 // Numeric Collections have implicit conversions:; 1640 GetSchemaRules(kTRUE);; 1641 ; 1642",MatchSource.WIKI,doc/v632/TClass_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/TClass_8cxx_source.html
https://root.cern/doc/v632/TClass_8cxx_source.html:78400,Integrability,message,message,78400,"ild .first, .second just fine; 2065 // and those for which the user explicitly requested a dictionary.; 2066 if (!isTransient && GetState() != kHasTClassInit; 2067 && TClassEdit::IsStdClass(GetName()); 2068 && !TClassEdit::IsStdPair(GetName())) {; 2069 Error(""BuildRealData"", ""Inspection for %s not supported!"", GetName());; 2070 }; 2071 ; 2072 // The following statement will recursively call; 2073 // all the subclasses of this class.; 2074 fRealData = new TList;; 2075 TBuildRealData brd(pointer, this);; 2076 ; 2077 // CallShowMember will force a call to InheritsFrom, which indirectly; 2078 // calls TClass::GetClass. It forces the loading of new typedefs in; 2079 // case some of them were not yet loaded.; 2080 if ( ! CallShowMembers(pointer, brd, isTransient) ) {; 2081 if ( isTransient ) {; 2082 // This is a transient data member, so it is probably fine to not have; 2083 // access to its content. However let's no mark it as definitively setup,; 2084 // since another class might use this class for a persistent data member and; 2085 // in this case we really want the error message.; 2086 delete fRealData;; 2087 fRealData = nullptr;; 2088 } else {; 2089 Error(""BuildRealData"", ""Cannot find any ShowMembers function for %s!"", GetName());; 2090 }; 2091 }; 2092 ; 2093 // Take this opportunity to build the real data for base classes.; 2094 // In case one base class is abstract, it would not be possible later; 2095 // to create the list of real data for this abstract class.; 2096 TBaseClass* base = nullptr;; 2097 TIter next(GetListOfBases());; 2098 while ((base = (TBaseClass*) next())) {; 2099 if (base->IsSTLContainer()) {; 2100 continue;; 2101 }; 2102 TClass* c = base->GetClassPointer();; 2103 if (c) {; 2104 c->BuildRealData(nullptr, isTransient);; 2105 }; 2106 }; 2107}; 2108 ; 2109////////////////////////////////////////////////////////////////////////////////; 2110/// Build the list of real data for an emulated class; 2111 ; 2112void TClass::BuildEmulatedRealData(const char *",MatchSource.WIKI,doc/v632/TClass_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/TClass_8cxx_source.html
https://root.cern/doc/v632/TClass_8cxx_source.html:109978,Integrability,wrap,wrapper,109978,"912/// Return the Streamer Class allowing streaming (if any).; 2913 ; 2914TClassStreamer *TClass::GetStreamer() const; 2915{; 2916 if (gThreadTsd && fStreamer) {; 2917 TClassLocalStorage *local = TClassLocalStorage::GetStorage(this);; 2918 if (local==nullptr) return fStreamer;; 2919 if (local->fStreamer==nullptr) {; 2920 local->fStreamer = fStreamer->Generate();; 2921 const std::type_info &orig = ( typeid(*fStreamer) );; 2922 if (!local->fStreamer) {; 2923 Warning(""GetStreamer"",""For %s, the TClassStreamer (%s) passed's call to Generate failed!"",GetName(),orig.name());; 2924 } else {; 2925 const std::type_info &copy = ( typeid(*local->fStreamer) );; 2926 if (strcmp(orig.name(),copy.name())!=0) {; 2927 Warning(""GetStreamer"",""For %s, the TClassStreamer passed does not properly implement the Generate method (%s vs %s)\n"",GetName(),orig.name(),copy.name());; 2928 }; 2929 }; 2930 }; 2931 return local->fStreamer;; 2932 }; 2933 return fStreamer;; 2934}; 2935 ; 2936////////////////////////////////////////////////////////////////////////////////; 2937/// Get a wrapper/accessor function around this class custom streamer (member function).; 2938 ; 2939ClassStreamerFunc_t TClass::GetStreamerFunc() const; 2940{; 2941 return fStreamerFunc;; 2942}; 2943 ; 2944////////////////////////////////////////////////////////////////////////////////; 2945/// Get a wrapper/accessor function around this class custom conversion streamer (member function).; 2946 ; 2947ClassConvStreamerFunc_t TClass::GetConvStreamerFunc() const; 2948{; 2949 return fConvStreamerFunc;; 2950}; 2951 ; 2952////////////////////////////////////////////////////////////////////////////////; 2953/// Return the proxy implementing the IsA functionality.; 2954 ; 2955TVirtualIsAProxy* TClass::GetIsAProxy() const; 2956{; 2957 return fIsA;; 2958}; 2959 ; 2960////////////////////////////////////////////////////////////////////////////////; 2961/// Static method returning pointer to TClass of the specified class name.; 2962/// If lo",MatchSource.WIKI,doc/v632/TClass_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/TClass_8cxx_source.html
https://root.cern/doc/v632/TClass_8cxx_source.html:110271,Integrability,wrap,wrapper,110271,"treamer==nullptr) {; 2920 local->fStreamer = fStreamer->Generate();; 2921 const std::type_info &orig = ( typeid(*fStreamer) );; 2922 if (!local->fStreamer) {; 2923 Warning(""GetStreamer"",""For %s, the TClassStreamer (%s) passed's call to Generate failed!"",GetName(),orig.name());; 2924 } else {; 2925 const std::type_info &copy = ( typeid(*local->fStreamer) );; 2926 if (strcmp(orig.name(),copy.name())!=0) {; 2927 Warning(""GetStreamer"",""For %s, the TClassStreamer passed does not properly implement the Generate method (%s vs %s)\n"",GetName(),orig.name(),copy.name());; 2928 }; 2929 }; 2930 }; 2931 return local->fStreamer;; 2932 }; 2933 return fStreamer;; 2934}; 2935 ; 2936////////////////////////////////////////////////////////////////////////////////; 2937/// Get a wrapper/accessor function around this class custom streamer (member function).; 2938 ; 2939ClassStreamerFunc_t TClass::GetStreamerFunc() const; 2940{; 2941 return fStreamerFunc;; 2942}; 2943 ; 2944////////////////////////////////////////////////////////////////////////////////; 2945/// Get a wrapper/accessor function around this class custom conversion streamer (member function).; 2946 ; 2947ClassConvStreamerFunc_t TClass::GetConvStreamerFunc() const; 2948{; 2949 return fConvStreamerFunc;; 2950}; 2951 ; 2952////////////////////////////////////////////////////////////////////////////////; 2953/// Return the proxy implementing the IsA functionality.; 2954 ; 2955TVirtualIsAProxy* TClass::GetIsAProxy() const; 2956{; 2957 return fIsA;; 2958}; 2959 ; 2960////////////////////////////////////////////////////////////////////////////////; 2961/// Static method returning pointer to TClass of the specified class name.; 2962/// If load is true, an attempt is made to obtain the class by loading; 2963/// the appropriate shared library (directed by the rootmap file).; 2964/// If silent is 'true', do not warn about missing dictionary for the class.; 2965/// (typically used for classes that are used only for transient members); ",MatchSource.WIKI,doc/v632/TClass_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/TClass_8cxx_source.html
https://root.cern/doc/v632/TClass_8cxx_source.html:137270,Integrability,depend,depends,137270,"; 3592 ; 3593 // Strip the first component, it may be the name of; 3594 // the branch (old TBranchElement code), and try again.; 3595 std::string firstDotName(givenName.substr(firstDot + 1));; 3596 ; 3597 rd = GetRealData(firstDotName.c_str());; 3598 if (rd); 3599 return rd;; 3600 ; 3601 // Not found;; 3602 return nullptr;; 3603}; 3604 ; 3605////////////////////////////////////////////////////////////////////////////////; 3606 ; 3607TFunctionTemplate *TClass::GetFunctionTemplate(const char *name); 3608{; 3609 if (!gInterpreter || !HasInterpreterInfo()) return nullptr;; 3610 ; 3611 // The following; 3612 if (!fFuncTemplate) fFuncTemplate = new TListOfFunctionTemplates(this);; 3613 ; 3614 return (TFunctionTemplate*)fFuncTemplate->FindObject(name);; 3615}; 3616 ; 3617////////////////////////////////////////////////////////////////////////////////; 3618/// Get the list of shared libraries containing the code for class cls.; 3619/// The first library in the list is the one containing the class, the; 3620/// others are the libraries the first one depends on. Returns 0; 3621/// in case the library is not found.; 3622 ; 3623const char *TClass::GetSharedLibs(); 3624{; 3625 if (!gInterpreter) return nullptr;; 3626 ; 3627 if (fSharedLibs.IsNull()); 3628 fSharedLibs = gInterpreter->GetClassSharedLibs(fName);; 3629 ; 3630 return !fSharedLibs.IsNull() ? fSharedLibs.Data() : nullptr;; 3631}; 3632 ; 3633////////////////////////////////////////////////////////////////////////////////; 3634/// Return list containing the TBaseClass(es) of a class.; 3635 ; 3636TList *TClass::GetListOfBases(); 3637{; 3638 if (!fBase.load()) {; 3639 if (fCanLoadClassInfo) {; 3640 if (fState == kHasTClassInit) {; 3641 ; 3642 R__LOCKGUARD(gInterpreterMutex);; 3643 if (!fHasRootPcmInfo) {; 3644 // The bases are in our ProtoClass; we don't need the class info.; 3645 TProtoClass *proto = TClassTable::GetProtoNorm(GetName());; 3646 if (proto && proto->FillTClass(this)); 3647 return fBase;; 3648 }; 3649 }; 3650",MatchSource.WIKI,doc/v632/TClass_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/TClass_8cxx_source.html
https://root.cern/doc/v632/TClass_8cxx_source.html:158014,Integrability,interface,interface,158014,"treamerElements; 4148 TIter nextClass(gROOT->GetListOfClasses());; 4149 TClass *acl;; 4150 TVirtualStreamerInfo *info;; 4151 ; 4152 // Since we are in the process of replacing a TClass by a TClass; 4153 // coming from a dictionary, there is no point in loading any; 4154 // libraries during this search.; 4155 TInterpreter::SuspendAutoLoadingRAII autoloadOff(gInterpreter);; 4156 while ((acl = (TClass*)nextClass())) {; 4157 if (acl == newcl) continue;; 4158 ; 4159 TIter nextInfo(acl->GetStreamerInfos());; 4160 while ((info = (TVirtualStreamerInfo*)nextInfo())) {; 4161 ; 4162 info->Update(this, newcl);; 4163 }; 4164 }; 4165 ; 4166 gInterpreter->UnRegisterTClassUpdate(this);; 4167}; 4168 ; 4169////////////////////////////////////////////////////////////////////////////////; 4170/// Make sure that the current ClassInfo is up to date.; 4171 ; 4172void TClass::ResetClassInfo(Long_t /* tagnum */); 4173{; 4174 Warning(""ResetClassInfo(Long_t tagnum)"",""Call to deprecated interface (does nothing)"");; 4175}; 4176 ; 4177////////////////////////////////////////////////////////////////////////////////; 4178/// Make sure that the current ClassInfo is up to date.; 4179 ; 4180void TClass::ResetClassInfo(); 4181{; 4182 R__LOCKGUARD(gInterpreterMutex);; 4183 ; 4184 InsertTClassInRegistryRAII insertRAII(fState,fName,fNoInfoOrEmuOrFwdDeclNameRegistry);; 4185 ; 4186 if (fClassInfo) {; 4187 TClass::RemoveClassDeclId(gInterpreter->GetDeclId(fClassInfo));; 4188 gInterpreter->ClassInfo_Delete(fClassInfo);; 4189 fClassInfo = nullptr;; 4190 }; 4191 // We can not check at this point whether after the unload there will; 4192 // still be interpreter information about this class (as v5 was doing),; 4193 // instead this function must only be called if the definition is (about); 4194 // to be unloaded.; 4195 ; 4196 ResetCaches();; 4197 ; 4198 // We got here because the definition Decl is about to be unloaded.; 4199 if (fState != TClass::kHasTClassInit) {; 4200 if (fStreamerInfo->GetEntries() != 0) {; 42",MatchSource.WIKI,doc/v632/TClass_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/TClass_8cxx_source.html
https://root.cern/doc/v632/TClass_8cxx_source.html:169395,Integrability,interface,interface,169395,"()); 4445 if (auto base = static_cast<TBaseClass *>(item)->GetClassPointer()); 4446 if (TFunction* method = base->FindClassOrBaseMethodWithId(declId)); 4447 return static_cast<TMethod *>(method);; 4448 ; 4449 return nullptr;; 4450}; 4451 ; 4452////////////////////////////////////////////////////////////////////////////////; 4453/// Find the method with a given prototype. The proto string must be of the; 4454/// form: ""char*,int,double"". Returns 0 in case method is not found.; 4455 ; 4456TMethod *TClass::GetMethodWithPrototype(const char *method, const char *proto,; 4457 Bool_t objectIsConst /* = kFALSE */,; 4458 ROOT::EFunctionMatchMode mode /* = ROOT::kConversionMatch */); 4459{; 4460 if (fCanLoadClassInfo) LoadClassInfo();; 4461 if (!fClassInfo) return nullptr;; 4462 ; 4463 if (!gInterpreter); 4464 Fatal(""GetMethodWithPrototype"", ""gInterpreter not initialized"");; 4465 ; 4466 TInterpreter::DeclId_t decl = gInterpreter->GetFunctionWithPrototype(fClassInfo,; 4467 method, proto,; 4468 objectIsConst, mode);; 4469 ; 4470 if (!decl) return nullptr;; 4471 TMethod* f = FindClassOrBaseMethodWithId(decl);; 4472 if (f) return f;; 4473 Error(""GetMethodWithPrototype"",; 4474 ""\nDid not find matching TMethod <%s> with \""%s\"" %sfor %s"",; 4475 method,proto,objectIsConst ? ""const "" : """", GetName());; 4476 return nullptr;; 4477}; 4478 ; 4479////////////////////////////////////////////////////////////////////////////////; 4480/// Look for a method in this class that has the interface function; 4481/// address faddr.; 4482 ; 4483TMethod *TClass::GetClassMethod(Longptr_t faddr); 4484{; 4485 if (!HasInterpreterInfo()) return nullptr;; 4486 ; 4487 TMethod *m;; 4488 TIter next(GetListOfMethods());; 4489 while ((m = (TMethod *) next())) {; 4490 if (faddr == (Longptr_t)m->InterfaceMethod()); 4491 return m;; 4492 }; 4493 return nullptr;; 4494}; 4495 ; 4496////////////////////////////////////////////////////////////////////////////////; 4497/// Look for a method in this class that has the name ",MatchSource.WIKI,doc/v632/TClass_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/TClass_8cxx_source.html
https://root.cern/doc/v632/TClass_8cxx_source.html:175471,Integrability,rout,routine,175471,"called from RootClassVersion via; 4616 // ROOT::ResetClassVersion) and is 'somewhat' protected by the atomic fVersionUsed.; 4617 // However, direct access to fClassVersion should be replaced by calls to GetClassVersion to set fVersionUsed.; 4618 // Even with such a change the code here and in these functions need to be reviewed as a cursory look seem; 4619 // to indicates they are not yet properly protection against mutli-thread access.; 4620 //; 4621 // However, the use of these functions is rare and mostly done at library loading time which should; 4622 // in almost all cases preceeds the possibility of GetStreamerInfo being called from multiple thread; 4623 // on that same TClass object.; 4624 //; 4625 // Summary: need careful review but risk of problem is extremely low.; 4626 ; 4627 R__LOCKGUARD(gInterpreterMutex);; 4628 ; 4629 return GetStreamerInfoImpl(version, isTransient);; 4630};; 4631 ; 4632// Implementation of/for TStreamerInfo::GetStreamerInfo.; 4633// This routine assumes the global lock has been taken.; 4634TVirtualStreamerInfo* TClass::GetStreamerInfoImpl(Int_t version, Bool_t silent) const; 4635{; 4636 // Warning: version may be -1 for an emulated class, or -2 if the; 4637 // user requested the emulated streamerInfo for an abstract; 4638 // base class, even though we have a dictionary for it.; 4639 ; 4640 if ((version < -1) || (version >= (fStreamerInfo->GetSize()-1))) {; 4641 Error(""GetStreamerInfo"", ""class: %s, attempting to access a wrong version: %d"", GetName(), version);; 4642 // FIXME: Shouldn't we go to -1 here, or better just abort?; 4643 version = fClassVersion;; 4644 }; 4645 ; 4646 TVirtualStreamerInfo *sinfo = (TVirtualStreamerInfo *)fStreamerInfo->At(version);; 4647 ; 4648 if (!sinfo && (version != fClassVersion)) {; 4649 // When the requested version does not exist we return; 4650 // the TVirtualStreamerInfo for the currently loaded class version.; 4651 // FIXME: This arguably makes no sense, we should warn and return nothing instead.; 46",MatchSource.WIKI,doc/v632/TClass_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/TClass_8cxx_source.html
https://root.cern/doc/v632/TClass_8cxx_source.html:188611,Integrability,message,message,188611," 4924 return (void*)((Longptr_t)obj+off);; 4925 else; 4926 return (void*)((Longptr_t)obj-off);; 4927 }; 4928 return nullptr;; 4929}; 4930 ; 4931////////////////////////////////////////////////////////////////////////////////; 4932/// Cast obj of this class type up to baseclass cl if up is true.; 4933/// Cast obj of this class type down from baseclass cl if up is false.; 4934/// If this class is not a baseclass of cl return 0, else the pointer; 4935/// to the cl part of this (up) or to this (down).; 4936 ; 4937const void *TClass::DynamicCast(const TClass *cl, const void *obj, Bool_t up); 4938{; 4939 return DynamicCast(cl,const_cast<void*>(obj),up);; 4940}; 4941 ; 4942////////////////////////////////////////////////////////////////////////////////; 4943/// Return a pointer to a newly allocated object of this class.; 4944/// The class must have a default constructor. For meaning of; 4945/// defConstructor, see TClass::IsCallingNew().; 4946///; 4947/// If quiet is true, do no issue a message via Error on case; 4948/// of problems, just return 0.; 4949///; 4950/// The constructor actually called here can be customized by; 4951/// using the rootcint pragma:; 4952/// ~~~ {.cpp}; 4953/// #pragma link C++ ioctortype UserClass;; 4954/// ~~~; 4955/// For example, with this pragma and a class named MyClass,; 4956/// this method will called the first of the following 3; 4957/// constructors which exists and is public:; 4958/// ~~~ {.cpp}; 4959/// MyClass(UserClass*);; 4960/// MyClass(TRootIOCtor*);; 4961/// MyClass(); // Or a constructor with all its arguments defaulted.; 4962/// ~~~; 4963///; 4964/// When more than one pragma ioctortype is used, the first seen as priority; 4965/// For example with:; 4966/// ~~~ {.cpp}; 4967/// #pragma link C++ ioctortype UserClass1;; 4968/// #pragma link C++ ioctortype UserClass2;; 4969/// ~~~; 4970/// We look in the following order:; 4971/// ~~~ {.cpp}; 4972/// MyClass(UserClass1*);; 4973/// MyClass(UserClass2*);; 4974/// MyClass(TRootIOCtor*);",MatchSource.WIKI,doc/v632/TClass_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/TClass_8cxx_source.html
https://root.cern/doc/v632/TClass_8cxx_source.html:190384,Integrability,wrap,wrapper,190384,"rtype UserClass1;; 4968/// #pragma link C++ ioctortype UserClass2;; 4969/// ~~~; 4970/// We look in the following order:; 4971/// ~~~ {.cpp}; 4972/// MyClass(UserClass1*);; 4973/// MyClass(UserClass2*);; 4974/// MyClass(TRootIOCtor*);; 4975/// MyClass(); // Or a constructor with all its arguments defaulted.; 4976/// ~~~; 4977 ; 4978void *TClass::New(ENewType defConstructor, Bool_t quiet) const; 4979{; 4980 auto obj = NewObject(defConstructor, quiet);; 4981 if (obj.GetPtr() && obj.GetAllocator()) {; 4982 // Register the object for special handling in the destructor.; 4983 RegisterAddressInRepository(""TClass::New"", obj.GetPtr(), this);; 4984 }; 4985 return obj.GetPtr();; 4986}; 4987 ; 4988// See TClass:New; 4989// returns a TClass::ObjectPtr which remembers if the object was allocated; 4990// via a TStreamerInfo.; 4991 ; 4992TClass::ObjectPtr TClass::NewObject(ENewType defConstructor, Bool_t quiet) const; 4993{; 4994 ObjectPtr p;; 4995 ; 4996 if (fNew) {; 4997 // We have the new operator wrapper function,; 4998 // so there is a dictionary and it was generated; 4999 // by rootcint, so there should be a default; 5000 // constructor we can call through the wrapper.; 5001 {; 5002 TClass__GetCallingNewRAII callingNew(defConstructor);; 5003 p = fNew(nullptr);; 5004 }; 5005 if (!p && !quiet) {; 5006 //Error(""New"", ""cannot create object of class %s version %d"", GetName(), fClassVersion);; 5007 Error(""New"", ""cannot create object of class %s"", GetName());; 5008 }; 5009 } else if (HasInterpreterInfo()) {; 5010 // We have the dictionary but do not have the; 5011 // constructor wrapper, so the dictionary was; 5012 // not generated by rootcint. Let's try to; 5013 // create the object by having the interpreter; 5014 // call the new operator, hopefully the class; 5015 // library is loaded and there will be a default; 5016 // constructor we can call.; 5017 // [This is very unlikely to work, but who knows!]; 5018 {; 5019 TClass__GetCallingNewRAII callingNew(defConstructor);; 5020 p = g",MatchSource.WIKI,doc/v632/TClass_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/TClass_8cxx_source.html
https://root.cern/doc/v632/TClass_8cxx_source.html:190553,Integrability,wrap,wrapper,190553,"rtype UserClass1;; 4968/// #pragma link C++ ioctortype UserClass2;; 4969/// ~~~; 4970/// We look in the following order:; 4971/// ~~~ {.cpp}; 4972/// MyClass(UserClass1*);; 4973/// MyClass(UserClass2*);; 4974/// MyClass(TRootIOCtor*);; 4975/// MyClass(); // Or a constructor with all its arguments defaulted.; 4976/// ~~~; 4977 ; 4978void *TClass::New(ENewType defConstructor, Bool_t quiet) const; 4979{; 4980 auto obj = NewObject(defConstructor, quiet);; 4981 if (obj.GetPtr() && obj.GetAllocator()) {; 4982 // Register the object for special handling in the destructor.; 4983 RegisterAddressInRepository(""TClass::New"", obj.GetPtr(), this);; 4984 }; 4985 return obj.GetPtr();; 4986}; 4987 ; 4988// See TClass:New; 4989// returns a TClass::ObjectPtr which remembers if the object was allocated; 4990// via a TStreamerInfo.; 4991 ; 4992TClass::ObjectPtr TClass::NewObject(ENewType defConstructor, Bool_t quiet) const; 4993{; 4994 ObjectPtr p;; 4995 ; 4996 if (fNew) {; 4997 // We have the new operator wrapper function,; 4998 // so there is a dictionary and it was generated; 4999 // by rootcint, so there should be a default; 5000 // constructor we can call through the wrapper.; 5001 {; 5002 TClass__GetCallingNewRAII callingNew(defConstructor);; 5003 p = fNew(nullptr);; 5004 }; 5005 if (!p && !quiet) {; 5006 //Error(""New"", ""cannot create object of class %s version %d"", GetName(), fClassVersion);; 5007 Error(""New"", ""cannot create object of class %s"", GetName());; 5008 }; 5009 } else if (HasInterpreterInfo()) {; 5010 // We have the dictionary but do not have the; 5011 // constructor wrapper, so the dictionary was; 5012 // not generated by rootcint. Let's try to; 5013 // create the object by having the interpreter; 5014 // call the new operator, hopefully the class; 5015 // library is loaded and there will be a default; 5016 // constructor we can call.; 5017 // [This is very unlikely to work, but who knows!]; 5018 {; 5019 TClass__GetCallingNewRAII callingNew(defConstructor);; 5020 p = g",MatchSource.WIKI,doc/v632/TClass_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/TClass_8cxx_source.html
https://root.cern/doc/v632/TClass_8cxx_source.html:190973,Integrability,wrap,wrapper,190973,"j = NewObject(defConstructor, quiet);; 4981 if (obj.GetPtr() && obj.GetAllocator()) {; 4982 // Register the object for special handling in the destructor.; 4983 RegisterAddressInRepository(""TClass::New"", obj.GetPtr(), this);; 4984 }; 4985 return obj.GetPtr();; 4986}; 4987 ; 4988// See TClass:New; 4989// returns a TClass::ObjectPtr which remembers if the object was allocated; 4990// via a TStreamerInfo.; 4991 ; 4992TClass::ObjectPtr TClass::NewObject(ENewType defConstructor, Bool_t quiet) const; 4993{; 4994 ObjectPtr p;; 4995 ; 4996 if (fNew) {; 4997 // We have the new operator wrapper function,; 4998 // so there is a dictionary and it was generated; 4999 // by rootcint, so there should be a default; 5000 // constructor we can call through the wrapper.; 5001 {; 5002 TClass__GetCallingNewRAII callingNew(defConstructor);; 5003 p = fNew(nullptr);; 5004 }; 5005 if (!p && !quiet) {; 5006 //Error(""New"", ""cannot create object of class %s version %d"", GetName(), fClassVersion);; 5007 Error(""New"", ""cannot create object of class %s"", GetName());; 5008 }; 5009 } else if (HasInterpreterInfo()) {; 5010 // We have the dictionary but do not have the; 5011 // constructor wrapper, so the dictionary was; 5012 // not generated by rootcint. Let's try to; 5013 // create the object by having the interpreter; 5014 // call the new operator, hopefully the class; 5015 // library is loaded and there will be a default; 5016 // constructor we can call.; 5017 // [This is very unlikely to work, but who knows!]; 5018 {; 5019 TClass__GetCallingNewRAII callingNew(defConstructor);; 5020 p = gCling->ClassInfo_New(GetClassInfo());; 5021 }; 5022 if (!p && !quiet) {; 5023 //Error(""New"", ""cannot create object of class %s version %d"", GetName(), fClassVersion);; 5024 Error(""New"", ""cannot create object of class %s"", GetName());; 5025 }; 5026 } else if (!HasInterpreterInfo() && fCollectionProxy) {; 5027 // There is no dictionary at all, so this is an emulated; 5028 // class; however we do have the services of",MatchSource.WIKI,doc/v632/TClass_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/TClass_8cxx_source.html
https://root.cern/doc/v632/TClass_8cxx_source.html:194881,Integrability,wrap,wrapper,194881,"er to a newly allocated object of this class.; 5088/// The class must have a default constructor. For meaning of; 5089/// defConstructor, see TClass::IsCallingNew().; 5090 ; 5091void *TClass::New(void *arena, ENewType defConstructor) const; 5092{; 5093 auto obj = NewObject(arena, defConstructor);; 5094 if (obj.GetPtr() && obj.GetAllocator()) {; 5095 // Register the object for special handling in the destructor.; 5096 RegisterAddressInRepository(""TClass::New with placement"", obj.GetPtr(), this);; 5097 }; 5098 return obj.GetPtr();; 5099}; 5100 ; 5101////////////////////////////////////////////////////////////////////////////////; 5102/// Return a pointer to a newly allocated object of this class.; 5103/// The class must have a default constructor. For meaning of; 5104/// defConstructor, see TClass::IsCallingNew().; 5105 ; 5106TClass::ObjectPtr TClass::NewObject(void *arena, ENewType defConstructor) const; 5107{; 5108 ObjectPtr p;; 5109 ; 5110 if (fNew) {; 5111 // We have the new operator wrapper function,; 5112 // so there is a dictionary and it was generated; 5113 // by rootcint, so there should be a default; 5114 // constructor we can call through the wrapper.; 5115 {; 5116 TClass__GetCallingNewRAII callingNew(defConstructor);; 5117 p = fNew(arena);; 5118 }; 5119 if (!p) {; 5120 Error(""New with placement"", ""cannot create object of class %s version %d at address %p"", GetName(), fClassVersion, arena);; 5121 }; 5122 } else if (HasInterpreterInfo()) {; 5123 // We have the dictionary but do not have the; 5124 // constructor wrapper, so the dictionary was; 5125 // not generated by rootcint. Let's try to; 5126 // create the object by having the interpreter; 5127 // call the new operator, hopefully the class; 5128 // library is loaded and there will be a default; 5129 // constructor we can call.; 5130 // [This is very unlikely to work, but who knows!]; 5131 {; 5132 TClass__GetCallingNewRAII callingNew(defConstructor);; 5133 p = gCling->ClassInfo_New(GetClassInfo(),arena);; 5",MatchSource.WIKI,doc/v632/TClass_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/TClass_8cxx_source.html
https://root.cern/doc/v632/TClass_8cxx_source.html:195050,Integrability,wrap,wrapper,195050,"er to a newly allocated object of this class.; 5088/// The class must have a default constructor. For meaning of; 5089/// defConstructor, see TClass::IsCallingNew().; 5090 ; 5091void *TClass::New(void *arena, ENewType defConstructor) const; 5092{; 5093 auto obj = NewObject(arena, defConstructor);; 5094 if (obj.GetPtr() && obj.GetAllocator()) {; 5095 // Register the object for special handling in the destructor.; 5096 RegisterAddressInRepository(""TClass::New with placement"", obj.GetPtr(), this);; 5097 }; 5098 return obj.GetPtr();; 5099}; 5100 ; 5101////////////////////////////////////////////////////////////////////////////////; 5102/// Return a pointer to a newly allocated object of this class.; 5103/// The class must have a default constructor. For meaning of; 5104/// defConstructor, see TClass::IsCallingNew().; 5105 ; 5106TClass::ObjectPtr TClass::NewObject(void *arena, ENewType defConstructor) const; 5107{; 5108 ObjectPtr p;; 5109 ; 5110 if (fNew) {; 5111 // We have the new operator wrapper function,; 5112 // so there is a dictionary and it was generated; 5113 // by rootcint, so there should be a default; 5114 // constructor we can call through the wrapper.; 5115 {; 5116 TClass__GetCallingNewRAII callingNew(defConstructor);; 5117 p = fNew(arena);; 5118 }; 5119 if (!p) {; 5120 Error(""New with placement"", ""cannot create object of class %s version %d at address %p"", GetName(), fClassVersion, arena);; 5121 }; 5122 } else if (HasInterpreterInfo()) {; 5123 // We have the dictionary but do not have the; 5124 // constructor wrapper, so the dictionary was; 5125 // not generated by rootcint. Let's try to; 5126 // create the object by having the interpreter; 5127 // call the new operator, hopefully the class; 5128 // library is loaded and there will be a default; 5129 // constructor we can call.; 5130 // [This is very unlikely to work, but who knows!]; 5131 {; 5132 TClass__GetCallingNewRAII callingNew(defConstructor);; 5133 p = gCling->ClassInfo_New(GetClassInfo(),arena);; 5",MatchSource.WIKI,doc/v632/TClass_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/TClass_8cxx_source.html
https://root.cern/doc/v632/TClass_8cxx_source.html:195425,Integrability,wrap,wrapper,195425,"g in the destructor.; 5096 RegisterAddressInRepository(""TClass::New with placement"", obj.GetPtr(), this);; 5097 }; 5098 return obj.GetPtr();; 5099}; 5100 ; 5101////////////////////////////////////////////////////////////////////////////////; 5102/// Return a pointer to a newly allocated object of this class.; 5103/// The class must have a default constructor. For meaning of; 5104/// defConstructor, see TClass::IsCallingNew().; 5105 ; 5106TClass::ObjectPtr TClass::NewObject(void *arena, ENewType defConstructor) const; 5107{; 5108 ObjectPtr p;; 5109 ; 5110 if (fNew) {; 5111 // We have the new operator wrapper function,; 5112 // so there is a dictionary and it was generated; 5113 // by rootcint, so there should be a default; 5114 // constructor we can call through the wrapper.; 5115 {; 5116 TClass__GetCallingNewRAII callingNew(defConstructor);; 5117 p = fNew(arena);; 5118 }; 5119 if (!p) {; 5120 Error(""New with placement"", ""cannot create object of class %s version %d at address %p"", GetName(), fClassVersion, arena);; 5121 }; 5122 } else if (HasInterpreterInfo()) {; 5123 // We have the dictionary but do not have the; 5124 // constructor wrapper, so the dictionary was; 5125 // not generated by rootcint. Let's try to; 5126 // create the object by having the interpreter; 5127 // call the new operator, hopefully the class; 5128 // library is loaded and there will be a default; 5129 // constructor we can call.; 5130 // [This is very unlikely to work, but who knows!]; 5131 {; 5132 TClass__GetCallingNewRAII callingNew(defConstructor);; 5133 p = gCling->ClassInfo_New(GetClassInfo(),arena);; 5134 }; 5135 if (!p) {; 5136 Error(""New with placement"", ""cannot create object of class %s version %d at address %p"", GetName(), fClassVersion, arena);; 5137 }; 5138 } else if (!HasInterpreterInfo() && fCollectionProxy) {; 5139 // There is no dictionary at all, so this is an emulated; 5140 // class; however we do have the services of a collection proxy,; 5141 // so this is an emulated STL cla",MatchSource.WIKI,doc/v632/TClass_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/TClass_8cxx_source.html
https://root.cern/doc/v632/TClass_8cxx_source.html:198929,Integrability,wrap,wrapper,198929,"is class.; 5190/// The class must have a default constructor. For meaning of; 5191/// defConstructor, see TClass::IsCallingNew().; 5192 ; 5193void *TClass::NewArray(Long_t nElements, ENewType defConstructor) const; 5194{; 5195 auto obj = NewObjectArray(nElements, defConstructor);; 5196 if (obj.GetPtr() && obj.GetAllocator()) {; 5197 // Register the object for special handling in the destructor.; 5198 RegisterAddressInRepository(""TClass::NewArray"", obj.GetPtr(), this);; 5199 }; 5200 return obj.GetPtr();; 5201}; 5202 ; 5203////////////////////////////////////////////////////////////////////////////////; 5204/// Return a pointer to a newly allocated array of objects; 5205/// of this class.; 5206/// The class must have a default constructor. For meaning of; 5207/// defConstructor, see TClass::IsCallingNew().; 5208 ; 5209TClass::ObjectPtr TClass::NewObjectArray(Long_t nElements, ENewType defConstructor) const; 5210{; 5211 ObjectPtr p;; 5212 ; 5213 if (fNewArray) {; 5214 // We have the new operator wrapper function,; 5215 // so there is a dictionary and it was generated; 5216 // by rootcint, so there should be a default; 5217 // constructor we can call through the wrapper.; 5218 {; 5219 TClass__GetCallingNewRAII callingNew(defConstructor);; 5220 p = fNewArray(nElements, nullptr);; 5221 }; 5222 if (!p) {; 5223 Error(""NewArray"", ""cannot create object of class %s version %d"", GetName(), fClassVersion);; 5224 }; 5225 } else if (HasInterpreterInfo()) {; 5226 // We have the dictionary but do not have the; 5227 // constructor wrapper, so the dictionary was; 5228 // not generated by rootcint. Let's try to; 5229 // create the object by having the interpreter; 5230 // call the new operator, hopefully the class; 5231 // library is loaded and there will be a default; 5232 // constructor we can call.; 5233 // [This is very unlikely to work, but who knows!]; 5234 {; 5235 TClass__GetCallingNewRAII callingNew(defConstructor);; 5236 p = gCling->ClassInfo_New(GetClassInfo(),nElements);; 52",MatchSource.WIKI,doc/v632/TClass_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/TClass_8cxx_source.html
https://root.cern/doc/v632/TClass_8cxx_source.html:199098,Integrability,wrap,wrapper,199098,"is class.; 5190/// The class must have a default constructor. For meaning of; 5191/// defConstructor, see TClass::IsCallingNew().; 5192 ; 5193void *TClass::NewArray(Long_t nElements, ENewType defConstructor) const; 5194{; 5195 auto obj = NewObjectArray(nElements, defConstructor);; 5196 if (obj.GetPtr() && obj.GetAllocator()) {; 5197 // Register the object for special handling in the destructor.; 5198 RegisterAddressInRepository(""TClass::NewArray"", obj.GetPtr(), this);; 5199 }; 5200 return obj.GetPtr();; 5201}; 5202 ; 5203////////////////////////////////////////////////////////////////////////////////; 5204/// Return a pointer to a newly allocated array of objects; 5205/// of this class.; 5206/// The class must have a default constructor. For meaning of; 5207/// defConstructor, see TClass::IsCallingNew().; 5208 ; 5209TClass::ObjectPtr TClass::NewObjectArray(Long_t nElements, ENewType defConstructor) const; 5210{; 5211 ObjectPtr p;; 5212 ; 5213 if (fNewArray) {; 5214 // We have the new operator wrapper function,; 5215 // so there is a dictionary and it was generated; 5216 // by rootcint, so there should be a default; 5217 // constructor we can call through the wrapper.; 5218 {; 5219 TClass__GetCallingNewRAII callingNew(defConstructor);; 5220 p = fNewArray(nElements, nullptr);; 5221 }; 5222 if (!p) {; 5223 Error(""NewArray"", ""cannot create object of class %s version %d"", GetName(), fClassVersion);; 5224 }; 5225 } else if (HasInterpreterInfo()) {; 5226 // We have the dictionary but do not have the; 5227 // constructor wrapper, so the dictionary was; 5228 // not generated by rootcint. Let's try to; 5229 // create the object by having the interpreter; 5230 // call the new operator, hopefully the class; 5231 // library is loaded and there will be a default; 5232 // constructor we can call.; 5233 // [This is very unlikely to work, but who knows!]; 5234 {; 5235 TClass__GetCallingNewRAII callingNew(defConstructor);; 5236 p = gCling->ClassInfo_New(GetClassInfo(),nElements);; 52",MatchSource.WIKI,doc/v632/TClass_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/TClass_8cxx_source.html
https://root.cern/doc/v632/TClass_8cxx_source.html:199460,Integrability,wrap,wrapper,199460,"r.; 5198 RegisterAddressInRepository(""TClass::NewArray"", obj.GetPtr(), this);; 5199 }; 5200 return obj.GetPtr();; 5201}; 5202 ; 5203////////////////////////////////////////////////////////////////////////////////; 5204/// Return a pointer to a newly allocated array of objects; 5205/// of this class.; 5206/// The class must have a default constructor. For meaning of; 5207/// defConstructor, see TClass::IsCallingNew().; 5208 ; 5209TClass::ObjectPtr TClass::NewObjectArray(Long_t nElements, ENewType defConstructor) const; 5210{; 5211 ObjectPtr p;; 5212 ; 5213 if (fNewArray) {; 5214 // We have the new operator wrapper function,; 5215 // so there is a dictionary and it was generated; 5216 // by rootcint, so there should be a default; 5217 // constructor we can call through the wrapper.; 5218 {; 5219 TClass__GetCallingNewRAII callingNew(defConstructor);; 5220 p = fNewArray(nElements, nullptr);; 5221 }; 5222 if (!p) {; 5223 Error(""NewArray"", ""cannot create object of class %s version %d"", GetName(), fClassVersion);; 5224 }; 5225 } else if (HasInterpreterInfo()) {; 5226 // We have the dictionary but do not have the; 5227 // constructor wrapper, so the dictionary was; 5228 // not generated by rootcint. Let's try to; 5229 // create the object by having the interpreter; 5230 // call the new operator, hopefully the class; 5231 // library is loaded and there will be a default; 5232 // constructor we can call.; 5233 // [This is very unlikely to work, but who knows!]; 5234 {; 5235 TClass__GetCallingNewRAII callingNew(defConstructor);; 5236 p = gCling->ClassInfo_New(GetClassInfo(),nElements);; 5237 }; 5238 if (!p) {; 5239 Error(""NewArray"", ""cannot create object of class %s version %d"", GetName(), fClassVersion);; 5240 }; 5241 } else if (!HasInterpreterInfo() && fCollectionProxy) {; 5242 // There is no dictionary at all, so this is an emulated; 5243 // class; however we do have the services of a collection proxy,; 5244 // so this is an emulated STL class.; 5245 {; 5246 TClass__GetCall",MatchSource.WIKI,doc/v632/TClass_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/TClass_8cxx_source.html
https://root.cern/doc/v632/TClass_8cxx_source.html:202924,Integrability,wrap,wrapper,202924," class must have a default constructor. For meaning of; 5293/// defConstructor, see TClass::IsCallingNew().; 5294 ; 5295void *TClass::NewArray(Long_t nElements, void *arena, ENewType defConstructor) const; 5296{; 5297 auto obj = NewObjectArray(nElements, arena, defConstructor);; 5298 if (obj.GetPtr() && obj.GetAllocator()) {; 5299 // Register the object for special handling in the destructor.; 5300 RegisterAddressInRepository(""TClass::NewArray with placement"", obj.GetPtr(), this);; 5301 }; 5302 return obj.GetPtr();; 5303}; 5304 ; 5305////////////////////////////////////////////////////////////////////////////////; 5306/// Return a pointer to a newly allocated object of this class.; 5307/// The class must have a default constructor. For meaning of; 5308/// defConstructor, see TClass::IsCallingNew().; 5309 ; 5310TClass::ObjectPtr TClass::NewObjectArray(Long_t nElements, void *arena, ENewType defConstructor) const; 5311{; 5312 ObjectPtr p;; 5313 ; 5314 if (fNewArray) {; 5315 // We have the new operator wrapper function,; 5316 // so there is a dictionary and it was generated; 5317 // by rootcint, so there should be a default; 5318 // constructor we can call through the wrapper.; 5319 {; 5320 TClass__GetCallingNewRAII callingNew(defConstructor);; 5321 p = fNewArray(nElements, arena);; 5322 }; 5323 if (!p) {; 5324 Error(""NewArray with placement"", ""cannot create object of class %s version %d at address %p"", GetName(), fClassVersion, arena);; 5325 }; 5326 } else if (HasInterpreterInfo()) {; 5327 // We have the dictionary but do not have the constructor wrapper,; 5328 // so the dictionary was not generated by rootcint (it was made either; 5329 // by cint or by some external mechanism). Let's try to create the; 5330 // object by having the interpreter call the new operator, either the; 5331 // class library is loaded and there is a default constructor we can; 5332 // call, or the class is interpreted and we will call the default; 5333 // constructor that way, or no default con",MatchSource.WIKI,doc/v632/TClass_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/TClass_8cxx_source.html
https://root.cern/doc/v632/TClass_8cxx_source.html:203093,Integrability,wrap,wrapper,203093," class must have a default constructor. For meaning of; 5293/// defConstructor, see TClass::IsCallingNew().; 5294 ; 5295void *TClass::NewArray(Long_t nElements, void *arena, ENewType defConstructor) const; 5296{; 5297 auto obj = NewObjectArray(nElements, arena, defConstructor);; 5298 if (obj.GetPtr() && obj.GetAllocator()) {; 5299 // Register the object for special handling in the destructor.; 5300 RegisterAddressInRepository(""TClass::NewArray with placement"", obj.GetPtr(), this);; 5301 }; 5302 return obj.GetPtr();; 5303}; 5304 ; 5305////////////////////////////////////////////////////////////////////////////////; 5306/// Return a pointer to a newly allocated object of this class.; 5307/// The class must have a default constructor. For meaning of; 5308/// defConstructor, see TClass::IsCallingNew().; 5309 ; 5310TClass::ObjectPtr TClass::NewObjectArray(Long_t nElements, void *arena, ENewType defConstructor) const; 5311{; 5312 ObjectPtr p;; 5313 ; 5314 if (fNewArray) {; 5315 // We have the new operator wrapper function,; 5316 // so there is a dictionary and it was generated; 5317 // by rootcint, so there should be a default; 5318 // constructor we can call through the wrapper.; 5319 {; 5320 TClass__GetCallingNewRAII callingNew(defConstructor);; 5321 p = fNewArray(nElements, arena);; 5322 }; 5323 if (!p) {; 5324 Error(""NewArray with placement"", ""cannot create object of class %s version %d at address %p"", GetName(), fClassVersion, arena);; 5325 }; 5326 } else if (HasInterpreterInfo()) {; 5327 // We have the dictionary but do not have the constructor wrapper,; 5328 // so the dictionary was not generated by rootcint (it was made either; 5329 // by cint or by some external mechanism). Let's try to create the; 5330 // object by having the interpreter call the new operator, either the; 5331 // class library is loaded and there is a default constructor we can; 5332 // call, or the class is interpreted and we will call the default; 5333 // constructor that way, or no default con",MatchSource.WIKI,doc/v632/TClass_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/TClass_8cxx_source.html
https://root.cern/doc/v632/TClass_8cxx_source.html:203480,Integrability,wrap,wrapper,203480,"with placement"", obj.GetPtr(), this);; 5301 }; 5302 return obj.GetPtr();; 5303}; 5304 ; 5305////////////////////////////////////////////////////////////////////////////////; 5306/// Return a pointer to a newly allocated object of this class.; 5307/// The class must have a default constructor. For meaning of; 5308/// defConstructor, see TClass::IsCallingNew().; 5309 ; 5310TClass::ObjectPtr TClass::NewObjectArray(Long_t nElements, void *arena, ENewType defConstructor) const; 5311{; 5312 ObjectPtr p;; 5313 ; 5314 if (fNewArray) {; 5315 // We have the new operator wrapper function,; 5316 // so there is a dictionary and it was generated; 5317 // by rootcint, so there should be a default; 5318 // constructor we can call through the wrapper.; 5319 {; 5320 TClass__GetCallingNewRAII callingNew(defConstructor);; 5321 p = fNewArray(nElements, arena);; 5322 }; 5323 if (!p) {; 5324 Error(""NewArray with placement"", ""cannot create object of class %s version %d at address %p"", GetName(), fClassVersion, arena);; 5325 }; 5326 } else if (HasInterpreterInfo()) {; 5327 // We have the dictionary but do not have the constructor wrapper,; 5328 // so the dictionary was not generated by rootcint (it was made either; 5329 // by cint or by some external mechanism). Let's try to create the; 5330 // object by having the interpreter call the new operator, either the; 5331 // class library is loaded and there is a default constructor we can; 5332 // call, or the class is interpreted and we will call the default; 5333 // constructor that way, or no default constructor is available and; 5334 // we fail.; 5335 {; 5336 TClass__GetCallingNewRAII callingNew(defConstructor);; 5337 p = gCling->ClassInfo_New(GetClassInfo(),nElements, arena);; 5338 }; 5339 if (!p) {; 5340 Error(""NewArray with placement"", ""cannot create object of class %s version %d at address %p"", GetName(), fClassVersion, arena);; 5341 }; 5342 } else if (!HasInterpreterInfo() && fCollectionProxy) {; 5343 // There is no dictionary at all, so",MatchSource.WIKI,doc/v632/TClass_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/TClass_8cxx_source.html
https://root.cern/doc/v632/TClass_8cxx_source.html:206592,Integrability,wrap,wrapper,206592,"o available!"", GetName(), fClassVersion, arena);; 5370 return nullptr;; 5371 }; 5372 ; 5373 {; 5374 TClass__GetCallingNewRAII callingNew(defConstructor);; 5375 p = { sinfo->NewArray(nElements, arena), sinfo };; 5376 }; 5377 ; 5378 // ???BUG???; 5379 // Allow TObject's to be registered again.; 5380 if(statsave) {; 5381 SetObjectStat(statsave);; 5382 }; 5383 ; 5384 if (fStreamerType & kEmulatedStreamer) {; 5385 // We always register emulated objects, we need to always; 5386 // use the streamer info to destroy them.; 5387 }; 5388 ; 5389 return p;; 5390 } else {; 5391 Error(""NewArray with placement"", ""This cannot happen!"");; 5392 }; 5393 ; 5394 return p;; 5395}; 5396 ; 5397////////////////////////////////////////////////////////////////////////////////; 5398/// Explicitly call destructor for object.; 5399 ; 5400void TClass::Destructor(void *obj, Bool_t dtorOnly); 5401{; 5402 // Do nothing if passed a null pointer.; 5403 if (obj == nullptr) return;; 5404 ; 5405 void* p = obj;; 5406 ; 5407 if (dtorOnly && fDestructor) {; 5408 // We have the destructor wrapper, use it.; 5409 fDestructor(p);; 5410 } else if ((!dtorOnly) && fDelete) {; 5411 // We have the delete wrapper, use it.; 5412 fDelete(p);; 5413 } else if (HasInterpreterInfo()) {; 5414 // We have the dictionary but do not have the; 5415 // destruct/delete wrapper, so the dictionary was; 5416 // not generated by rootcint (it could have been; 5417 // created by cint or by some external mechanism).; 5418 // Let's have the interpreter call the destructor,; 5419 // either the code will be in a loaded library,; 5420 // or it will be interpreted, otherwise we fail; 5421 // because there is no destructor code at all.; 5422 if (dtorOnly) {; 5423 gCling->ClassInfo_Destruct(fClassInfo,p);; 5424 } else {; 5425 gCling->ClassInfo_Delete(fClassInfo,p);; 5426 }; 5427 } else if (!HasInterpreterInfo() && fCollectionProxy) {; 5428 // There is no dictionary at all, so this is an emulated; 5429 // class; however we do have the services of ",MatchSource.WIKI,doc/v632/TClass_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/TClass_8cxx_source.html
https://root.cern/doc/v632/TClass_8cxx_source.html:206702,Integrability,wrap,wrapper,206702,"New(defConstructor);; 5375 p = { sinfo->NewArray(nElements, arena), sinfo };; 5376 }; 5377 ; 5378 // ???BUG???; 5379 // Allow TObject's to be registered again.; 5380 if(statsave) {; 5381 SetObjectStat(statsave);; 5382 }; 5383 ; 5384 if (fStreamerType & kEmulatedStreamer) {; 5385 // We always register emulated objects, we need to always; 5386 // use the streamer info to destroy them.; 5387 }; 5388 ; 5389 return p;; 5390 } else {; 5391 Error(""NewArray with placement"", ""This cannot happen!"");; 5392 }; 5393 ; 5394 return p;; 5395}; 5396 ; 5397////////////////////////////////////////////////////////////////////////////////; 5398/// Explicitly call destructor for object.; 5399 ; 5400void TClass::Destructor(void *obj, Bool_t dtorOnly); 5401{; 5402 // Do nothing if passed a null pointer.; 5403 if (obj == nullptr) return;; 5404 ; 5405 void* p = obj;; 5406 ; 5407 if (dtorOnly && fDestructor) {; 5408 // We have the destructor wrapper, use it.; 5409 fDestructor(p);; 5410 } else if ((!dtorOnly) && fDelete) {; 5411 // We have the delete wrapper, use it.; 5412 fDelete(p);; 5413 } else if (HasInterpreterInfo()) {; 5414 // We have the dictionary but do not have the; 5415 // destruct/delete wrapper, so the dictionary was; 5416 // not generated by rootcint (it could have been; 5417 // created by cint or by some external mechanism).; 5418 // Let's have the interpreter call the destructor,; 5419 // either the code will be in a loaded library,; 5420 // or it will be interpreted, otherwise we fail; 5421 // because there is no destructor code at all.; 5422 if (dtorOnly) {; 5423 gCling->ClassInfo_Destruct(fClassInfo,p);; 5424 } else {; 5425 gCling->ClassInfo_Delete(fClassInfo,p);; 5426 }; 5427 } else if (!HasInterpreterInfo() && fCollectionProxy) {; 5428 // There is no dictionary at all, so this is an emulated; 5429 // class; however we do have the services of a collection proxy,; 5430 // so this is an emulated STL class.; 5431 GetCollectionProxy()->Destructor(p, dtorOnly);; 5432 } else if ",MatchSource.WIKI,doc/v632/TClass_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/TClass_8cxx_source.html
https://root.cern/doc/v632/TClass_8cxx_source.html:206855,Integrability,wrap,wrapper,206855,"ctStat(statsave);; 5382 }; 5383 ; 5384 if (fStreamerType & kEmulatedStreamer) {; 5385 // We always register emulated objects, we need to always; 5386 // use the streamer info to destroy them.; 5387 }; 5388 ; 5389 return p;; 5390 } else {; 5391 Error(""NewArray with placement"", ""This cannot happen!"");; 5392 }; 5393 ; 5394 return p;; 5395}; 5396 ; 5397////////////////////////////////////////////////////////////////////////////////; 5398/// Explicitly call destructor for object.; 5399 ; 5400void TClass::Destructor(void *obj, Bool_t dtorOnly); 5401{; 5402 // Do nothing if passed a null pointer.; 5403 if (obj == nullptr) return;; 5404 ; 5405 void* p = obj;; 5406 ; 5407 if (dtorOnly && fDestructor) {; 5408 // We have the destructor wrapper, use it.; 5409 fDestructor(p);; 5410 } else if ((!dtorOnly) && fDelete) {; 5411 // We have the delete wrapper, use it.; 5412 fDelete(p);; 5413 } else if (HasInterpreterInfo()) {; 5414 // We have the dictionary but do not have the; 5415 // destruct/delete wrapper, so the dictionary was; 5416 // not generated by rootcint (it could have been; 5417 // created by cint or by some external mechanism).; 5418 // Let's have the interpreter call the destructor,; 5419 // either the code will be in a loaded library,; 5420 // or it will be interpreted, otherwise we fail; 5421 // because there is no destructor code at all.; 5422 if (dtorOnly) {; 5423 gCling->ClassInfo_Destruct(fClassInfo,p);; 5424 } else {; 5425 gCling->ClassInfo_Delete(fClassInfo,p);; 5426 }; 5427 } else if (!HasInterpreterInfo() && fCollectionProxy) {; 5428 // There is no dictionary at all, so this is an emulated; 5429 // class; however we do have the services of a collection proxy,; 5430 // so this is an emulated STL class.; 5431 GetCollectionProxy()->Destructor(p, dtorOnly);; 5432 } else if (!HasInterpreterInfo() && !fCollectionProxy) {; 5433 // There is no dictionary at all and we do not have; 5434 // the services of a collection proxy available, so; 5435 // use the streamer info t",MatchSource.WIKI,doc/v632/TClass_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/TClass_8cxx_source.html
https://root.cern/doc/v632/TClass_8cxx_source.html:211874,Integrability,wrap,wrapper,211874,"This cannot happen! (class %s)"", GetName());; 5507 }; 5508}; 5509 ; 5510////////////////////////////////////////////////////////////////////////////////; 5511/// Explicitly call destructor for object.; 5512 ; 5513void TClass::Destructor(TClass::ObjectPtr obj, Bool_t dtorOnly); 5514{; 5515 // Do nothing if passed a null pointer.; 5516 if (obj.GetPtr() == nullptr); 5517 return;; 5518 ; 5519 if (obj.GetAllocator()) {; 5520 obj.GetAllocator()->Destructor(obj.GetPtr(), dtorOnly);; 5521 } else {; 5522 Destructor(obj.GetPtr(), dtorOnly);; 5523 }; 5524}; 5525 ; 5526////////////////////////////////////////////////////////////////////////////////; 5527/// Explicitly call operator delete[] for an array.; 5528 ; 5529void TClass::DeleteArray(void *ary, Bool_t dtorOnly); 5530{; 5531 // Do nothing if passed a null pointer.; 5532 if (ary == nullptr) return;; 5533 ; 5534 // Make a copy of the address.; 5535 void* p = ary;; 5536 ; 5537 if (fDeleteArray) {; 5538 if (dtorOnly) {; 5539 Error(""DeleteArray"", ""Destructor only is not supported!"");; 5540 } else {; 5541 // We have the array delete wrapper, use it.; 5542 fDeleteArray(ary);; 5543 }; 5544 } else if (HasInterpreterInfo()) {; 5545 // We have the dictionary but do not have the; 5546 // array delete wrapper, so the dictionary was; 5547 // not generated by rootcint. Let's try to; 5548 // delete the array by having the interpreter; 5549 // call the array delete operator, hopefully; 5550 // the class library is loaded and there will be; 5551 // a destructor we can call.; 5552 gCling->ClassInfo_DeleteArray(GetClassInfo(),ary, dtorOnly);; 5553 } else if (!HasInterpreterInfo() && fCollectionProxy) {; 5554 // There is no dictionary at all, so this is an emulated; 5555 // class; however we do have the services of a collection proxy,; 5556 // so this is an emulated STL class.; 5557 GetCollectionProxy()->DeleteArray(ary, dtorOnly);; 5558 } else if (!HasInterpreterInfo() && !fCollectionProxy) {; 5559 // There is no dictionary at all and we do n",MatchSource.WIKI,doc/v632/TClass_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/TClass_8cxx_source.html
https://root.cern/doc/v632/TClass_8cxx_source.html:212039,Integrability,wrap,wrapper,212039,"13void TClass::Destructor(TClass::ObjectPtr obj, Bool_t dtorOnly); 5514{; 5515 // Do nothing if passed a null pointer.; 5516 if (obj.GetPtr() == nullptr); 5517 return;; 5518 ; 5519 if (obj.GetAllocator()) {; 5520 obj.GetAllocator()->Destructor(obj.GetPtr(), dtorOnly);; 5521 } else {; 5522 Destructor(obj.GetPtr(), dtorOnly);; 5523 }; 5524}; 5525 ; 5526////////////////////////////////////////////////////////////////////////////////; 5527/// Explicitly call operator delete[] for an array.; 5528 ; 5529void TClass::DeleteArray(void *ary, Bool_t dtorOnly); 5530{; 5531 // Do nothing if passed a null pointer.; 5532 if (ary == nullptr) return;; 5533 ; 5534 // Make a copy of the address.; 5535 void* p = ary;; 5536 ; 5537 if (fDeleteArray) {; 5538 if (dtorOnly) {; 5539 Error(""DeleteArray"", ""Destructor only is not supported!"");; 5540 } else {; 5541 // We have the array delete wrapper, use it.; 5542 fDeleteArray(ary);; 5543 }; 5544 } else if (HasInterpreterInfo()) {; 5545 // We have the dictionary but do not have the; 5546 // array delete wrapper, so the dictionary was; 5547 // not generated by rootcint. Let's try to; 5548 // delete the array by having the interpreter; 5549 // call the array delete operator, hopefully; 5550 // the class library is loaded and there will be; 5551 // a destructor we can call.; 5552 gCling->ClassInfo_DeleteArray(GetClassInfo(),ary, dtorOnly);; 5553 } else if (!HasInterpreterInfo() && fCollectionProxy) {; 5554 // There is no dictionary at all, so this is an emulated; 5555 // class; however we do have the services of a collection proxy,; 5556 // so this is an emulated STL class.; 5557 GetCollectionProxy()->DeleteArray(ary, dtorOnly);; 5558 } else if (!HasInterpreterInfo() && !fCollectionProxy) {; 5559 // There is no dictionary at all and we do not have; 5560 // the services of a collection proxy available, so; 5561 // use the streamer info to approximate calling the; 5562 // array destructor.; 5563 ; 5564 Bool_t inRepo = kTRUE;; 5565 Bool_t currentVers",MatchSource.WIKI,doc/v632/TClass_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/TClass_8cxx_source.html
https://root.cern/doc/v632/TClass_8cxx_source.html:217080,Integrability,interface,interface,217080,"ray(TClass::ObjectPtr obj, Bool_t dtorOnly); 5640{; 5641 // Do nothing if passed a null pointer.; 5642 if (obj.GetPtr() == nullptr) return;; 5643 ; 5644 if (obj.GetAllocator()) {; 5645 obj.GetAllocator()->DeleteArray(obj.GetPtr(), dtorOnly);; 5646 } else {; 5647 DeleteArray(obj.GetPtr(), dtorOnly);; 5648 }; 5649}; 5650 ; 5651////////////////////////////////////////////////////////////////////////////////; 5652/// Set the splitability of this class:; 5653/// - -1: Use the default calculation; 5654/// - 0: Disallow splitting; 5655/// - 1: Always allow splitting.; 5656/// - 2: Disallow splitting of the class and splitting of any it's derived classes.; 5657 ; 5658void TClass::SetCanSplit(Int_t splitmode); 5659{; 5660 fCanSplit = splitmode;; 5661}; 5662 ; 5663////////////////////////////////////////////////////////////////////////////////; 5664/// Private function. Set the class version for the 'class' represented by; 5665/// this TClass object. See the public interface:; 5666/// ROOT::ResetClassVersion; 5667/// defined in TClassTable.cxx; 5668///; 5669/// Note on class version numbers:; 5670/// - If no class number has been specified, TClass::GetVersion will return -1; 5671/// - The Class Version 0 request the whole object to be transient; 5672/// - The Class Version 1, unless specified via ClassDef indicates that the; 5673/// I/O should use the TClass checksum to distinguish the layout of the class; 5674 ; 5675void TClass::SetClassVersion(Version_t version); 5676{; 5677 fClassVersion = version;; 5678 fCurrentInfo = nullptr;; 5679}; 5680 ; 5681////////////////////////////////////////////////////////////////////////////////; 5682/// Determine and set pointer to current TVirtualStreamerInfo; 5683 ; 5684TVirtualStreamerInfo* TClass::DetermineCurrentStreamerInfo(); 5685{; 5686 if(!fCurrentInfo.load()) {; 5687 R__READ_LOCKGUARD(ROOT::gCoreMutex);; 5688 fCurrentInfo = (TVirtualStreamerInfo *)(fStreamerInfo->At(fClassVersion));; 5689 }; 5690 return fCurrentInfo;; 5691}; 5692 ;",MatchSource.WIKI,doc/v632/TClass_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/TClass_8cxx_source.html
https://root.cern/doc/v632/TClass_8cxx_source.html:224091,Integrability,rout,routine,224091,"ther calls to; 5821/// this function cannot affect the value of fClassInfo, fCanLoadClassInfo is set; 5822/// to false.; 5823 ; 5824void TClass::LoadClassInfo() const; 5825{; 5826 R__LOCKGUARD(gInterpreterMutex);; 5827 ; 5828 // Return if another thread already loaded the info; 5829 // while we were waiting for the lock; 5830 if (!fCanLoadClassInfo || TestBit(kLoading)); 5831 return;; 5832 ; 5833 bool autoParse = !gInterpreter->IsAutoParsingSuspended();; 5834 ; 5835 if (autoParse); 5836 gInterpreter->AutoParse(GetName());; 5837 ; 5838 if (!fClassInfo); 5839 gInterpreter->SetClassInfo(const_cast<TClass *>(this));; 5840 ; 5841 if (autoParse && !fClassInfo) {; 5842 if (fImplFileLine == -1 && fClassVersion == 0) {; 5843 // We have a 'transient' class with a ClassDefInline and apparently no interpreter; 5844 // information. Since it is transient, it is more than likely that the lack; 5845 // will be harmles.; 5846 } else {; 5847 ::Error(""TClass::LoadClassInfo"", ""no interpreter information for class %s is available""; 5848 "" even though it has a TClass initialization routine."",; 5849 fName.Data());; 5850 }; 5851 return;; 5852 }; 5853 ; 5854 fCanLoadClassInfo = false;; 5855}; 5856 ; 5857////////////////////////////////////////////////////////////////////////////////; 5858/// Store class description on I/O buffer.; 5859 ; 5860void TClass::Store(TBuffer &b) const; 5861{; 5862 b.WriteString(GetName());; 5863}; 5864 ; 5865////////////////////////////////////////////////////////////////////////////////; 5866/// Global function called by a class' static Dictionary() method; 5867/// (see the ClassDef macro).; 5868 ; 5869TClass *ROOT::CreateClass(const char *cname, Version_t id,; 5870 const std::type_info &info, TVirtualIsAProxy *isa,; 5871 const char *dfil, const char *ifil,; 5872 Int_t dl, Int_t il); 5873{; 5874 // When called via TMapFile (e.g. Update()) make sure that the dictionary; 5875 // gets allocated on the heap and not in the mapped file.; 5876 TMmallocDescTemp setreset;;",MatchSource.WIKI,doc/v632/TClass_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/TClass_8cxx_source.html
https://root.cern/doc/v632/TClass_8cxx_source.html:235489,Integrability,rout,routine,235489,"without taking the lock,; 6089 // this is valid since fProperty is atomic and set as; 6090 // the last operation before return.; 6091 if (fProperty!=(-1)) return fProperty;; 6092 ; 6093 R__LOCKGUARD(gInterpreterMutex);; 6094 ; 6095 // Check if another thread set fProperty while we; 6096 // were waiting.; 6097 if (fProperty!=(-1)) return fProperty;; 6098 ; 6099 // Avoid asking about the class when it is still building; 6100 if (TestBit(kLoading)) return fProperty;; 6101 ; 6102 // When called via TMapFile (e.g. Update()) make sure that the dictionary; 6103 // gets allocated on the heap and not in the mapped file.; 6104 TMmallocDescTemp setreset;; 6105 ; 6106 TClass *kl = const_cast<TClass*>(this);; 6107 ; 6108 kl->fStreamerType = TClass::kDefault;; 6109 kl->fStreamerImpl = &TClass::StreamerDefault;; 6110 ; 6111 if (InheritsFrom(TObject::Class())) {; 6112 kl->SetBit(kIsTObject);; 6113 ; 6114 // Is it DIRECT inheritance from TObject?; 6115 Int_t delta = kl->GetBaseClassOffsetRecurse(TObject::Class());; 6116 if (delta==0) kl->SetBit(kStartWithTObject);; 6117 ; 6118 kl->fStreamerType = kTObject;; 6119 kl->fStreamerImpl = &TClass::StreamerTObject;; 6120 }; 6121 ; 6122 if (HasInterpreterInfo()) {; 6123 ; 6124 // This code used to use ClassInfo_Has|IsValidMethod but since v6; 6125 // they return true if the routine is defined in the class or any of; 6126 // its parent. We explicitly want to know whether the function is; 6127 // defined locally.; 6128 if (!const_cast<TClass*>(this)->GetClassMethodWithPrototype(""Streamer"",""TBuffer&"",kFALSE)) {; 6129 ; 6130 kl->SetBit(kIsForeign);; 6131 kl->fStreamerType = kForeign;; 6132 kl->fStreamerImpl = &TClass::StreamerStreamerInfo;; 6133 ; 6134 } else if ( kl->fStreamerType == TClass::kDefault ) {; 6135 if (kl->fConvStreamerFunc) {; 6136 kl->fStreamerType = kInstrumented;; 6137 kl->fStreamerImpl = &TClass::ConvStreamerInstrumented;; 6138 } else if (kl->fStreamerFunc) {; 6139 kl->fStreamerType = kInstrumented;; 6140 kl->fStreamerImpl = &T",MatchSource.WIKI,doc/v632/TClass_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/TClass_8cxx_source.html
https://root.cern/doc/v632/TClass_8cxx_source.html:238059,Integrability,rout,routine,238059,"nary as part of libCore) but do not because the user; 6164 // only include a forward declaration of TClonesArray and we do not; 6165 // forcefully load the header file either (because the autoparsing; 6166 // is intentionally disabled).; 6167 kl->fClassProperty = gCling->ClassInfo_ClassProperty(fClassInfo);; 6168 // Must set this last since other threads may read fProperty; 6169 // and think all test bits have been properly set.; 6170 kl->fProperty = gCling->ClassInfo_Property(fClassInfo);; 6171 }; 6172 } else {; 6173 ; 6174 if (fStreamer) {; 6175 kl->fStreamerType = kExternal;; 6176 kl->fStreamerImpl = &TClass::StreamerExternal;; 6177 }; 6178 ; 6179 kl->fStreamerType |= kEmulatedStreamer;; 6180 kl->SetStreamerImpl();; 6181 // fProperty was *not* set so that it can be forced to be recalculated; 6182 // next time.; 6183 return 0;; 6184 }; 6185 ; 6186 return fProperty;; 6187}; 6188 ; 6189////////////////////////////////////////////////////////////////////////////////; 6190/// Internal routine to set calculate the class properties that can only be; 6191/// known at run-time, for example whether the Hash member function and the; 6192/// destructor are consistent.; 6193 ; 6194void TClass::SetRuntimeProperties(); 6195{; 6196 // For now, no need to lock this routines as fRuntimeProperties is; 6197 // the only atomic set here and this is done at the end; 6198 // and there is no downside if the execution is done twice.; 6199 ; 6200 // Note SetRuntimeProperties is set to const as it is technically; 6201 // thread-safe.; 6202 ; 6203 UChar_t properties = static_cast<UChar_t>(ERuntimeProperties::kSet);; 6204 ; 6205 if (ROOT::Internal::TCheckHashRecursiveRemoveConsistency::Check(*this)); 6206 properties |= static_cast<UChar_t>(ERuntimeProperties::kConsistentHash);; 6207 ; 6208 const_cast<TClass *>(this)->fRuntimeProperties = properties;; 6209}; 6210 ; 6211////////////////////////////////////////////////////////////////////////////////; 6212/// Internal routine to set fStreamerImpl",MatchSource.WIKI,doc/v632/TClass_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/TClass_8cxx_source.html
https://root.cern/doc/v632/TClass_8cxx_source.html:238333,Integrability,rout,routines,238333,"o);; 6168 // Must set this last since other threads may read fProperty; 6169 // and think all test bits have been properly set.; 6170 kl->fProperty = gCling->ClassInfo_Property(fClassInfo);; 6171 }; 6172 } else {; 6173 ; 6174 if (fStreamer) {; 6175 kl->fStreamerType = kExternal;; 6176 kl->fStreamerImpl = &TClass::StreamerExternal;; 6177 }; 6178 ; 6179 kl->fStreamerType |= kEmulatedStreamer;; 6180 kl->SetStreamerImpl();; 6181 // fProperty was *not* set so that it can be forced to be recalculated; 6182 // next time.; 6183 return 0;; 6184 }; 6185 ; 6186 return fProperty;; 6187}; 6188 ; 6189////////////////////////////////////////////////////////////////////////////////; 6190/// Internal routine to set calculate the class properties that can only be; 6191/// known at run-time, for example whether the Hash member function and the; 6192/// destructor are consistent.; 6193 ; 6194void TClass::SetRuntimeProperties(); 6195{; 6196 // For now, no need to lock this routines as fRuntimeProperties is; 6197 // the only atomic set here and this is done at the end; 6198 // and there is no downside if the execution is done twice.; 6199 ; 6200 // Note SetRuntimeProperties is set to const as it is technically; 6201 // thread-safe.; 6202 ; 6203 UChar_t properties = static_cast<UChar_t>(ERuntimeProperties::kSet);; 6204 ; 6205 if (ROOT::Internal::TCheckHashRecursiveRemoveConsistency::Check(*this)); 6206 properties |= static_cast<UChar_t>(ERuntimeProperties::kConsistentHash);; 6207 ; 6208 const_cast<TClass *>(this)->fRuntimeProperties = properties;; 6209}; 6210 ; 6211////////////////////////////////////////////////////////////////////////////////; 6212/// Internal routine to set fStreamerImpl based on the value of; 6213/// fStreamerType.; 6214 ; 6215void TClass::SetStreamerImpl(); 6216{; 6217 switch (fStreamerType) {; 6218 case kTObject: fStreamerImpl = &TClass::StreamerTObject; break;; 6219 case kForeign: fStreamerImpl = &TClass::StreamerStreamerInfo; break;; 6220 case kExternal: fStreamer",MatchSource.WIKI,doc/v632/TClass_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/TClass_8cxx_source.html
https://root.cern/doc/v632/TClass_8cxx_source.html:239034,Integrability,rout,routine,239034,"e recalculated; 6182 // next time.; 6183 return 0;; 6184 }; 6185 ; 6186 return fProperty;; 6187}; 6188 ; 6189////////////////////////////////////////////////////////////////////////////////; 6190/// Internal routine to set calculate the class properties that can only be; 6191/// known at run-time, for example whether the Hash member function and the; 6192/// destructor are consistent.; 6193 ; 6194void TClass::SetRuntimeProperties(); 6195{; 6196 // For now, no need to lock this routines as fRuntimeProperties is; 6197 // the only atomic set here and this is done at the end; 6198 // and there is no downside if the execution is done twice.; 6199 ; 6200 // Note SetRuntimeProperties is set to const as it is technically; 6201 // thread-safe.; 6202 ; 6203 UChar_t properties = static_cast<UChar_t>(ERuntimeProperties::kSet);; 6204 ; 6205 if (ROOT::Internal::TCheckHashRecursiveRemoveConsistency::Check(*this)); 6206 properties |= static_cast<UChar_t>(ERuntimeProperties::kConsistentHash);; 6207 ; 6208 const_cast<TClass *>(this)->fRuntimeProperties = properties;; 6209}; 6210 ; 6211////////////////////////////////////////////////////////////////////////////////; 6212/// Internal routine to set fStreamerImpl based on the value of; 6213/// fStreamerType.; 6214 ; 6215void TClass::SetStreamerImpl(); 6216{; 6217 switch (fStreamerType) {; 6218 case kTObject: fStreamerImpl = &TClass::StreamerTObject; break;; 6219 case kForeign: fStreamerImpl = &TClass::StreamerStreamerInfo; break;; 6220 case kExternal: fStreamerImpl = &TClass::StreamerExternal; break;; 6221 case kInstrumented: {; 6222 if (fConvStreamerFunc) fStreamerImpl = &TClass::ConvStreamerInstrumented;; 6223 else if (fStreamerFunc) fStreamerImpl = &TClass::StreamerInstrumented;; 6224 else fStreamerImpl = &TClass::StreamerStreamerInfo;; 6225 break;; 6226 }; 6227 ; 6228 case kEmulatedStreamer: // intentional fall through; 6229 case kForeign|kEmulatedStreamer: // intentional fall through; 6230 case kInstrumented|kEmulatedStreamer: fStre",MatchSource.WIKI,doc/v632/TClass_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/TClass_8cxx_source.html
https://root.cern/doc/v632/TClass_8cxx_source.html:265599,Integrability,wrap,wrapper,265599,"supposed to be set properly (no longer pointing to the default).; 6883 if (pThis->fStreamerImpl.load() == &TClass::StreamerDefault) {; 6884 pThis->Fatal(""StreamerDefault"", ""fStreamerImpl not properly initialized (%d)"", pThis->fStreamerType);; 6885 } else {; 6886 (*pThis->fStreamerImpl)(pThis,object,b,onfile_class);; 6887 }; 6888}; 6889 ; 6890////////////////////////////////////////////////////////////////////////////////; 6891/// Adopt a TClassStreamer object. Ownership is transfered to this TClass; 6892/// object.; 6893 ; 6894void TClass::AdoptStreamer(TClassStreamer *str); 6895{; 6896// // This code can be used to quickly test the STL Emulation layer; 6897// Int_t k = TClassEdit::IsSTLCont(GetName());; 6898// if (k==1||k==-1) { delete str; return; }; 6899 ; 6900 R__LOCKGUARD(gInterpreterMutex);; 6901 ; 6902 if (fStreamer) delete fStreamer;; 6903 if (str) {; 6904 fStreamerType = kExternal | ( fStreamerType&kEmulatedStreamer );; 6905 fStreamer = str;; 6906 fStreamerImpl = &TClass::StreamerExternal;; 6907 } else if (fStreamer) {; 6908 // Case where there was a custom streamer and it is hereby removed,; 6909 // we need to reset fStreamerType; 6910 fStreamer = str;; 6911 fStreamerType = TClass::kDefault;; 6912 if (fProperty != -1) {; 6913 fProperty = -1;; 6914 Property();; 6915 }; 6916 }; 6917}; 6918 ; 6919////////////////////////////////////////////////////////////////////////////////; 6920/// Set a wrapper/accessor function around this class custom streamer.; 6921 ; 6922void TClass::SetStreamerFunc(ClassStreamerFunc_t strm); 6923{; 6924 R__LOCKGUARD(gInterpreterMutex);; 6925 if (fProperty != -1 && !fConvStreamerFunc &&; 6926 ( (fStreamerFunc == nullptr && strm != nullptr) || (fStreamerFunc != nullptr && strm == nullptr) ) ); 6927 {; 6928 fStreamerFunc = strm;; 6929 ; 6930 // Since initialization has already been done, make sure to tweak it; 6931 // for the new state.; 6932 if (HasInterpreterInfo() && fStreamerType != kTObject && !fStreamer) {; 6933 fStreamerType = kIn",MatchSource.WIKI,doc/v632/TClass_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/TClass_8cxx_source.html
https://root.cern/doc/v632/TClass_8cxx_source.html:266440,Integrability,wrap,wrapper,266440,"d,; 6909 // we need to reset fStreamerType; 6910 fStreamer = str;; 6911 fStreamerType = TClass::kDefault;; 6912 if (fProperty != -1) {; 6913 fProperty = -1;; 6914 Property();; 6915 }; 6916 }; 6917}; 6918 ; 6919////////////////////////////////////////////////////////////////////////////////; 6920/// Set a wrapper/accessor function around this class custom streamer.; 6921 ; 6922void TClass::SetStreamerFunc(ClassStreamerFunc_t strm); 6923{; 6924 R__LOCKGUARD(gInterpreterMutex);; 6925 if (fProperty != -1 && !fConvStreamerFunc &&; 6926 ( (fStreamerFunc == nullptr && strm != nullptr) || (fStreamerFunc != nullptr && strm == nullptr) ) ); 6927 {; 6928 fStreamerFunc = strm;; 6929 ; 6930 // Since initialization has already been done, make sure to tweak it; 6931 // for the new state.; 6932 if (HasInterpreterInfo() && fStreamerType != kTObject && !fStreamer) {; 6933 fStreamerType = kInstrumented;; 6934 fStreamerImpl = &TClass::StreamerInstrumented;; 6935 }; 6936 } else {; 6937 fStreamerFunc = strm;; 6938 }; 6939 fCanSplit = -1;; 6940}; 6941 ; 6942////////////////////////////////////////////////////////////////////////////////; 6943/// Set a wrapper/accessor function around this class custom conversion streamer.; 6944 ; 6945void TClass::SetConvStreamerFunc(ClassConvStreamerFunc_t strm); 6946{; 6947 R__LOCKGUARD(gInterpreterMutex);; 6948 if (fProperty != -1 &&; 6949 ( (fConvStreamerFunc == nullptr && strm != nullptr) || (fConvStreamerFunc != nullptr && strm == nullptr) ) ); 6950 {; 6951 fConvStreamerFunc = strm;; 6952 ; 6953 // Since initialization has already been done, make sure to tweak it; 6954 // for the new state.; 6955 if (HasInterpreterInfo() && fStreamerType != kTObject && !fStreamer) {; 6956 fStreamerType = kInstrumented;; 6957 fStreamerImpl = &TClass::ConvStreamerInstrumented;; 6958 }; 6959 } else {; 6960 fConvStreamerFunc = strm;; 6961 }; 6962 fCanSplit = -1;; 6963}; 6964 ; 6965 ; 6966////////////////////////////////////////////////////////////////////////////////; 696",MatchSource.WIKI,doc/v632/TClass_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/TClass_8cxx_source.html
https://root.cern/doc/v632/TClass_8cxx_source.html:267313,Integrability,wrap,wrapper,267313,"bject && !fStreamer) {; 6933 fStreamerType = kInstrumented;; 6934 fStreamerImpl = &TClass::StreamerInstrumented;; 6935 }; 6936 } else {; 6937 fStreamerFunc = strm;; 6938 }; 6939 fCanSplit = -1;; 6940}; 6941 ; 6942////////////////////////////////////////////////////////////////////////////////; 6943/// Set a wrapper/accessor function around this class custom conversion streamer.; 6944 ; 6945void TClass::SetConvStreamerFunc(ClassConvStreamerFunc_t strm); 6946{; 6947 R__LOCKGUARD(gInterpreterMutex);; 6948 if (fProperty != -1 &&; 6949 ( (fConvStreamerFunc == nullptr && strm != nullptr) || (fConvStreamerFunc != nullptr && strm == nullptr) ) ); 6950 {; 6951 fConvStreamerFunc = strm;; 6952 ; 6953 // Since initialization has already been done, make sure to tweak it; 6954 // for the new state.; 6955 if (HasInterpreterInfo() && fStreamerType != kTObject && !fStreamer) {; 6956 fStreamerType = kInstrumented;; 6957 fStreamerImpl = &TClass::ConvStreamerInstrumented;; 6958 }; 6959 } else {; 6960 fConvStreamerFunc = strm;; 6961 }; 6962 fCanSplit = -1;; 6963}; 6964 ; 6965 ; 6966////////////////////////////////////////////////////////////////////////////////; 6967/// Install a new wrapper around 'Merge'.; 6968 ; 6969void TClass::SetMerge(ROOT::MergeFunc_t newMerge); 6970{; 6971 fMerge = newMerge;; 6972}; 6973 ; 6974////////////////////////////////////////////////////////////////////////////////; 6975/// Install a new wrapper around 'ResetAfterMerge'.; 6976 ; 6977void TClass::SetResetAfterMerge(ROOT::ResetAfterMergeFunc_t newReset); 6978{; 6979 fResetAfterMerge = newReset;; 6980}; 6981 ; 6982////////////////////////////////////////////////////////////////////////////////; 6983/// Install a new wrapper around 'new'.; 6984 ; 6985void TClass::SetNew(ROOT::NewFunc_t newFunc); 6986{; 6987 fNew = newFunc;; 6988}; 6989 ; 6990////////////////////////////////////////////////////////////////////////////////; 6991/// Install a new wrapper around 'new []'.; 6992 ; 6993void TClass::SetNewArray(ROO",MatchSource.WIKI,doc/v632/TClass_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/TClass_8cxx_source.html
https://root.cern/doc/v632/TClass_8cxx_source.html:267554,Integrability,wrap,wrapper,267554,"tion around this class custom conversion streamer.; 6944 ; 6945void TClass::SetConvStreamerFunc(ClassConvStreamerFunc_t strm); 6946{; 6947 R__LOCKGUARD(gInterpreterMutex);; 6948 if (fProperty != -1 &&; 6949 ( (fConvStreamerFunc == nullptr && strm != nullptr) || (fConvStreamerFunc != nullptr && strm == nullptr) ) ); 6950 {; 6951 fConvStreamerFunc = strm;; 6952 ; 6953 // Since initialization has already been done, make sure to tweak it; 6954 // for the new state.; 6955 if (HasInterpreterInfo() && fStreamerType != kTObject && !fStreamer) {; 6956 fStreamerType = kInstrumented;; 6957 fStreamerImpl = &TClass::ConvStreamerInstrumented;; 6958 }; 6959 } else {; 6960 fConvStreamerFunc = strm;; 6961 }; 6962 fCanSplit = -1;; 6963}; 6964 ; 6965 ; 6966////////////////////////////////////////////////////////////////////////////////; 6967/// Install a new wrapper around 'Merge'.; 6968 ; 6969void TClass::SetMerge(ROOT::MergeFunc_t newMerge); 6970{; 6971 fMerge = newMerge;; 6972}; 6973 ; 6974////////////////////////////////////////////////////////////////////////////////; 6975/// Install a new wrapper around 'ResetAfterMerge'.; 6976 ; 6977void TClass::SetResetAfterMerge(ROOT::ResetAfterMergeFunc_t newReset); 6978{; 6979 fResetAfterMerge = newReset;; 6980}; 6981 ; 6982////////////////////////////////////////////////////////////////////////////////; 6983/// Install a new wrapper around 'new'.; 6984 ; 6985void TClass::SetNew(ROOT::NewFunc_t newFunc); 6986{; 6987 fNew = newFunc;; 6988}; 6989 ; 6990////////////////////////////////////////////////////////////////////////////////; 6991/// Install a new wrapper around 'new []'.; 6992 ; 6993void TClass::SetNewArray(ROOT::NewArrFunc_t newArrayFunc); 6994{; 6995 fNewArray = newArrayFunc;; 6996}; 6997 ; 6998////////////////////////////////////////////////////////////////////////////////; 6999/// Install a new wrapper around 'delete'.; 7000 ; 7001void TClass::SetDelete(ROOT::DelFunc_t deleteFunc); 7002{; 7003 fDelete = deleteFunc;; 7004}; 7005 ; 7",MatchSource.WIKI,doc/v632/TClass_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/TClass_8cxx_source.html
https://root.cern/doc/v632/TClass_8cxx_source.html:267835,Integrability,wrap,wrapper,267835,"| (fConvStreamerFunc != nullptr && strm == nullptr) ) ); 6950 {; 6951 fConvStreamerFunc = strm;; 6952 ; 6953 // Since initialization has already been done, make sure to tweak it; 6954 // for the new state.; 6955 if (HasInterpreterInfo() && fStreamerType != kTObject && !fStreamer) {; 6956 fStreamerType = kInstrumented;; 6957 fStreamerImpl = &TClass::ConvStreamerInstrumented;; 6958 }; 6959 } else {; 6960 fConvStreamerFunc = strm;; 6961 }; 6962 fCanSplit = -1;; 6963}; 6964 ; 6965 ; 6966////////////////////////////////////////////////////////////////////////////////; 6967/// Install a new wrapper around 'Merge'.; 6968 ; 6969void TClass::SetMerge(ROOT::MergeFunc_t newMerge); 6970{; 6971 fMerge = newMerge;; 6972}; 6973 ; 6974////////////////////////////////////////////////////////////////////////////////; 6975/// Install a new wrapper around 'ResetAfterMerge'.; 6976 ; 6977void TClass::SetResetAfterMerge(ROOT::ResetAfterMergeFunc_t newReset); 6978{; 6979 fResetAfterMerge = newReset;; 6980}; 6981 ; 6982////////////////////////////////////////////////////////////////////////////////; 6983/// Install a new wrapper around 'new'.; 6984 ; 6985void TClass::SetNew(ROOT::NewFunc_t newFunc); 6986{; 6987 fNew = newFunc;; 6988}; 6989 ; 6990////////////////////////////////////////////////////////////////////////////////; 6991/// Install a new wrapper around 'new []'.; 6992 ; 6993void TClass::SetNewArray(ROOT::NewArrFunc_t newArrayFunc); 6994{; 6995 fNewArray = newArrayFunc;; 6996}; 6997 ; 6998////////////////////////////////////////////////////////////////////////////////; 6999/// Install a new wrapper around 'delete'.; 7000 ; 7001void TClass::SetDelete(ROOT::DelFunc_t deleteFunc); 7002{; 7003 fDelete = deleteFunc;; 7004}; 7005 ; 7006////////////////////////////////////////////////////////////////////////////////; 7007/// Install a new wrapper around 'delete []'.; 7008 ; 7009void TClass::SetDeleteArray(ROOT::DelArrFunc_t deleteArrayFunc); 7010{; 7011 fDeleteArray = deleteArrayFunc;; 701",MatchSource.WIKI,doc/v632/TClass_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/TClass_8cxx_source.html
https://root.cern/doc/v632/TClass_8cxx_source.html:268066,Integrability,wrap,wrapper,268066,e != kTObject && !fStreamer) {; 6956 fStreamerType = kInstrumented;; 6957 fStreamerImpl = &TClass::ConvStreamerInstrumented;; 6958 }; 6959 } else {; 6960 fConvStreamerFunc = strm;; 6961 }; 6962 fCanSplit = -1;; 6963}; 6964 ; 6965 ; 6966////////////////////////////////////////////////////////////////////////////////; 6967/// Install a new wrapper around 'Merge'.; 6968 ; 6969void TClass::SetMerge(ROOT::MergeFunc_t newMerge); 6970{; 6971 fMerge = newMerge;; 6972}; 6973 ; 6974////////////////////////////////////////////////////////////////////////////////; 6975/// Install a new wrapper around 'ResetAfterMerge'.; 6976 ; 6977void TClass::SetResetAfterMerge(ROOT::ResetAfterMergeFunc_t newReset); 6978{; 6979 fResetAfterMerge = newReset;; 6980}; 6981 ; 6982////////////////////////////////////////////////////////////////////////////////; 6983/// Install a new wrapper around 'new'.; 6984 ; 6985void TClass::SetNew(ROOT::NewFunc_t newFunc); 6986{; 6987 fNew = newFunc;; 6988}; 6989 ; 6990////////////////////////////////////////////////////////////////////////////////; 6991/// Install a new wrapper around 'new []'.; 6992 ; 6993void TClass::SetNewArray(ROOT::NewArrFunc_t newArrayFunc); 6994{; 6995 fNewArray = newArrayFunc;; 6996}; 6997 ; 6998////////////////////////////////////////////////////////////////////////////////; 6999/// Install a new wrapper around 'delete'.; 7000 ; 7001void TClass::SetDelete(ROOT::DelFunc_t deleteFunc); 7002{; 7003 fDelete = deleteFunc;; 7004}; 7005 ; 7006////////////////////////////////////////////////////////////////////////////////; 7007/// Install a new wrapper around 'delete []'.; 7008 ; 7009void TClass::SetDeleteArray(ROOT::DelArrFunc_t deleteArrayFunc); 7010{; 7011 fDeleteArray = deleteArrayFunc;; 7012}; 7013 ; 7014////////////////////////////////////////////////////////////////////////////////; 7015/// Install a new wrapper around the destructor.; 7016 ; 7017void TClass::SetDestructor(ROOT::DesFunc_t destructorFunc); 7018{; 7019 fDestructor = des,MatchSource.WIKI,doc/v632/TClass_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/TClass_8cxx_source.html
https://root.cern/doc/v632/TClass_8cxx_source.html:268323,Integrability,wrap,wrapper,268323,///////////////////////////////////////////////////////////////////////; 6967/// Install a new wrapper around 'Merge'.; 6968 ; 6969void TClass::SetMerge(ROOT::MergeFunc_t newMerge); 6970{; 6971 fMerge = newMerge;; 6972}; 6973 ; 6974////////////////////////////////////////////////////////////////////////////////; 6975/// Install a new wrapper around 'ResetAfterMerge'.; 6976 ; 6977void TClass::SetResetAfterMerge(ROOT::ResetAfterMergeFunc_t newReset); 6978{; 6979 fResetAfterMerge = newReset;; 6980}; 6981 ; 6982////////////////////////////////////////////////////////////////////////////////; 6983/// Install a new wrapper around 'new'.; 6984 ; 6985void TClass::SetNew(ROOT::NewFunc_t newFunc); 6986{; 6987 fNew = newFunc;; 6988}; 6989 ; 6990////////////////////////////////////////////////////////////////////////////////; 6991/// Install a new wrapper around 'new []'.; 6992 ; 6993void TClass::SetNewArray(ROOT::NewArrFunc_t newArrayFunc); 6994{; 6995 fNewArray = newArrayFunc;; 6996}; 6997 ; 6998////////////////////////////////////////////////////////////////////////////////; 6999/// Install a new wrapper around 'delete'.; 7000 ; 7001void TClass::SetDelete(ROOT::DelFunc_t deleteFunc); 7002{; 7003 fDelete = deleteFunc;; 7004}; 7005 ; 7006////////////////////////////////////////////////////////////////////////////////; 7007/// Install a new wrapper around 'delete []'.; 7008 ; 7009void TClass::SetDeleteArray(ROOT::DelArrFunc_t deleteArrayFunc); 7010{; 7011 fDeleteArray = deleteArrayFunc;; 7012}; 7013 ; 7014////////////////////////////////////////////////////////////////////////////////; 7015/// Install a new wrapper around the destructor.; 7016 ; 7017void TClass::SetDestructor(ROOT::DesFunc_t destructorFunc); 7018{; 7019 fDestructor = destructorFunc;; 7020}; 7021 ; 7022////////////////////////////////////////////////////////////////////////////////; 7023/// Install a new wrapper around the directory auto add function.; 7024/// The function autoAddFunc has the signature void (*)(v,MatchSource.WIKI,doc/v632/TClass_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/TClass_8cxx_source.html
https://root.cern/doc/v632/TClass_8cxx_source.html:268569,Integrability,wrap,wrapper,268569,"///////////////////////////////////////////////////////////; 6975/// Install a new wrapper around 'ResetAfterMerge'.; 6976 ; 6977void TClass::SetResetAfterMerge(ROOT::ResetAfterMergeFunc_t newReset); 6978{; 6979 fResetAfterMerge = newReset;; 6980}; 6981 ; 6982////////////////////////////////////////////////////////////////////////////////; 6983/// Install a new wrapper around 'new'.; 6984 ; 6985void TClass::SetNew(ROOT::NewFunc_t newFunc); 6986{; 6987 fNew = newFunc;; 6988}; 6989 ; 6990////////////////////////////////////////////////////////////////////////////////; 6991/// Install a new wrapper around 'new []'.; 6992 ; 6993void TClass::SetNewArray(ROOT::NewArrFunc_t newArrayFunc); 6994{; 6995 fNewArray = newArrayFunc;; 6996}; 6997 ; 6998////////////////////////////////////////////////////////////////////////////////; 6999/// Install a new wrapper around 'delete'.; 7000 ; 7001void TClass::SetDelete(ROOT::DelFunc_t deleteFunc); 7002{; 7003 fDelete = deleteFunc;; 7004}; 7005 ; 7006////////////////////////////////////////////////////////////////////////////////; 7007/// Install a new wrapper around 'delete []'.; 7008 ; 7009void TClass::SetDeleteArray(ROOT::DelArrFunc_t deleteArrayFunc); 7010{; 7011 fDeleteArray = deleteArrayFunc;; 7012}; 7013 ; 7014////////////////////////////////////////////////////////////////////////////////; 7015/// Install a new wrapper around the destructor.; 7016 ; 7017void TClass::SetDestructor(ROOT::DesFunc_t destructorFunc); 7018{; 7019 fDestructor = destructorFunc;; 7020}; 7021 ; 7022////////////////////////////////////////////////////////////////////////////////; 7023/// Install a new wrapper around the directory auto add function.; 7024/// The function autoAddFunc has the signature void (*)(void *obj, TDirectory dir); 7025/// and should register 'obj' to the directory if dir is not null; 7026/// and unregister 'obj' from its current directory if dir is null; 7027 ; 7028void TClass::SetDirectoryAutoAdd(ROOT::DirAutoAdd_t autoAddFunc); 7029{;",MatchSource.WIKI,doc/v632/TClass_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/TClass_8cxx_source.html
https://root.cern/doc/v632/TClass_8cxx_source.html:268841,Integrability,wrap,wrapper,268841,"//////////////////////////////////////////////////////////////////////////////; 6983/// Install a new wrapper around 'new'.; 6984 ; 6985void TClass::SetNew(ROOT::NewFunc_t newFunc); 6986{; 6987 fNew = newFunc;; 6988}; 6989 ; 6990////////////////////////////////////////////////////////////////////////////////; 6991/// Install a new wrapper around 'new []'.; 6992 ; 6993void TClass::SetNewArray(ROOT::NewArrFunc_t newArrayFunc); 6994{; 6995 fNewArray = newArrayFunc;; 6996}; 6997 ; 6998////////////////////////////////////////////////////////////////////////////////; 6999/// Install a new wrapper around 'delete'.; 7000 ; 7001void TClass::SetDelete(ROOT::DelFunc_t deleteFunc); 7002{; 7003 fDelete = deleteFunc;; 7004}; 7005 ; 7006////////////////////////////////////////////////////////////////////////////////; 7007/// Install a new wrapper around 'delete []'.; 7008 ; 7009void TClass::SetDeleteArray(ROOT::DelArrFunc_t deleteArrayFunc); 7010{; 7011 fDeleteArray = deleteArrayFunc;; 7012}; 7013 ; 7014////////////////////////////////////////////////////////////////////////////////; 7015/// Install a new wrapper around the destructor.; 7016 ; 7017void TClass::SetDestructor(ROOT::DesFunc_t destructorFunc); 7018{; 7019 fDestructor = destructorFunc;; 7020}; 7021 ; 7022////////////////////////////////////////////////////////////////////////////////; 7023/// Install a new wrapper around the directory auto add function.; 7024/// The function autoAddFunc has the signature void (*)(void *obj, TDirectory dir); 7025/// and should register 'obj' to the directory if dir is not null; 7026/// and unregister 'obj' from its current directory if dir is null; 7027 ; 7028void TClass::SetDirectoryAutoAdd(ROOT::DirAutoAdd_t autoAddFunc); 7029{; 7030 fDirAutoAdd = autoAddFunc;; 7031}; 7032 ; 7033////////////////////////////////////////////////////////////////////////////////; 7034/// Find the TVirtualStreamerInfo in the StreamerInfos corresponding to checksum; 7035 ; 7036TVirtualStreamerInfo *TClass::F",MatchSource.WIKI,doc/v632/TClass_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/TClass_8cxx_source.html
https://root.cern/doc/v632/TClass_8cxx_source.html:269109,Integrability,wrap,wrapper,269109,"/////////////////////////////; 6991/// Install a new wrapper around 'new []'.; 6992 ; 6993void TClass::SetNewArray(ROOT::NewArrFunc_t newArrayFunc); 6994{; 6995 fNewArray = newArrayFunc;; 6996}; 6997 ; 6998////////////////////////////////////////////////////////////////////////////////; 6999/// Install a new wrapper around 'delete'.; 7000 ; 7001void TClass::SetDelete(ROOT::DelFunc_t deleteFunc); 7002{; 7003 fDelete = deleteFunc;; 7004}; 7005 ; 7006////////////////////////////////////////////////////////////////////////////////; 7007/// Install a new wrapper around 'delete []'.; 7008 ; 7009void TClass::SetDeleteArray(ROOT::DelArrFunc_t deleteArrayFunc); 7010{; 7011 fDeleteArray = deleteArrayFunc;; 7012}; 7013 ; 7014////////////////////////////////////////////////////////////////////////////////; 7015/// Install a new wrapper around the destructor.; 7016 ; 7017void TClass::SetDestructor(ROOT::DesFunc_t destructorFunc); 7018{; 7019 fDestructor = destructorFunc;; 7020}; 7021 ; 7022////////////////////////////////////////////////////////////////////////////////; 7023/// Install a new wrapper around the directory auto add function.; 7024/// The function autoAddFunc has the signature void (*)(void *obj, TDirectory dir); 7025/// and should register 'obj' to the directory if dir is not null; 7026/// and unregister 'obj' from its current directory if dir is null; 7027 ; 7028void TClass::SetDirectoryAutoAdd(ROOT::DirAutoAdd_t autoAddFunc); 7029{; 7030 fDirAutoAdd = autoAddFunc;; 7031}; 7032 ; 7033////////////////////////////////////////////////////////////////////////////////; 7034/// Find the TVirtualStreamerInfo in the StreamerInfos corresponding to checksum; 7035 ; 7036TVirtualStreamerInfo *TClass::FindStreamerInfo(UInt_t checksum, Bool_t isTransient) const; 7037{; 7038 TVirtualStreamerInfo *guess = fLastReadInfo;; 7039 if (guess && guess->GetCheckSum() == checksum) {; 7040 return guess;; 7041 } else {; 7042 if (fCheckSum == checksum); 7043 return GetStreamerInfo(0, isTransi",MatchSource.WIKI,doc/v632/TClass_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/TClass_8cxx_source.html
https://root.cern/doc/v632/TClass_8cxx_source.html:281799,Integrability,rout,routines,281799,"(Int_t slot); 7321{; 7322 if (fStreamerInfo->GetSize() >= slot) {; 7323 R__LOCKGUARD(gInterpreterMutex);; 7324 TVirtualStreamerInfo *info = (TVirtualStreamerInfo*)fStreamerInfo->At(slot);; 7325 fStreamerInfo->RemoveAt(fClassVersion);; 7326 if (fLastReadInfo.load() == info); 7327 fLastReadInfo = nullptr;; 7328 if (fCurrentInfo.load() == info); 7329 fCurrentInfo = nullptr;; 7330 delete info;; 7331 if (fState == kEmulated && fStreamerInfo->GetEntries() == 0) {; 7332 fState = kForwardDeclared;; 7333 }; 7334 }; 7335}; 7336 ; 7337////////////////////////////////////////////////////////////////////////////////; 7338/// Return true is the Hash/RecursiveRemove setup is consistent, i.e. when all; 7339/// classes in the class hierarchy that overload TObject::Hash do call; 7340/// ROOT::CallRecursiveRemoveIfNeeded in their destructor.; 7341/// i.e. it is safe to call the Hash virtual function during the RecursiveRemove operation.; 7342/// This routines is used for a small subset of the class for which we need; 7343/// the answer before gROOT is properly initialized.; 7344 ; 7345Bool_t ROOT::Internal::HasConsistentHashMember(const char *cname); 7346{; 7347 // Hand selection of correct classes, those classes should be; 7348 // cross-checked in testHashRecursiveRemove.cxx; 7349 static const char *handVerified[] = {; 7350 ""TEnvRec"", ""TDataType"", ""TObjArray"", ""TList"", ""THashList"",; 7351 ""TClass"", ""TCling"", ""TInterpreter"", ""TMethod"", ""ROOT::Internal::TCheckHashRecursiveRemoveConsistency"",; 7352 ""TCheckHashRecursiveRemoveConsistency"", ""TGWindow"",; 7353 ""TDirectory"", ""TDirectoryFile"", ""TObject"", ""TH1"",; 7354 ""TQClass"", ""TGlobal"" };; 7355 ; 7356 if (cname && cname[0]) {; 7357 for (auto cursor : handVerified) {; 7358 if (strcmp(cname, cursor) == 0); 7359 return true;; 7360 }; 7361 }; 7362 return false;; 7363}; 7364 ; 7365////////////////////////////////////////////////////////////////////////////////; 7366/// Return true is the Hash/RecursiveRemove setup is consistent, i.e. when all; 7367",MatchSource.WIKI,doc/v632/TClass_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/TClass_8cxx_source.html
https://root.cern/doc/v632/TClass_8cxx_source.html:283602,Integrability,rout,routine,283602,"true;; 7360 }; 7361 }; 7362 return false;; 7363}; 7364 ; 7365////////////////////////////////////////////////////////////////////////////////; 7366/// Return true is the Hash/RecursiveRemove setup is consistent, i.e. when all; 7367/// classes in the class hierarchy that overload TObject::Hash do call; 7368/// ROOT::CallRecursiveRemoveIfNeeded in their destructor.; 7369/// i.e. it is safe to call the Hash virtual function during the RecursiveRemove operation.; 7370 ; 7371Bool_t ROOT::Internal::HasConsistentHashMember(TClass &clRef); 7372{; 7373 return clRef.HasConsistentHashMember();; 7374}; 7375 ; 7376////////////////////////////////////////////////////////////////////////////////; 7377/// Return true if we have access to a constructor usable for I/O. This is; 7378/// typically the default constructor but can also be a constructor specifically; 7379/// marked for I/O (for example a constructor taking a TRootIOCtor* as an; 7380/// argument). In other words, if this routine returns true, TClass::New is; 7381/// guarantee to succeed.; 7382/// To know if the class described by this TClass has a default constructor; 7383/// (public or not), use; 7384/// \code{.cpp}; 7385/// cl->GetProperty() & kClassHasDefaultCtor; 7386/// \endcode; 7387/// To know if the class described by this TClass has a public default; 7388/// constructor use:; 7389/// \code{.cpp}; 7390/// gInterpreter->ClassInfo_HasDefaultConstructor(aClass->GetClassInfo());; 7391/// \endcode; 7392 ; 7393Bool_t TClass::HasDefaultConstructor(Bool_t testio) const; 7394{; 7395 ; 7396 if (fNew) return kTRUE;; 7397 ; 7398 if (HasInterpreterInfo()) {; 7399 R__LOCKGUARD(gInterpreterMutex);; 7400 return gCling->ClassInfo_HasDefaultConstructor(GetClassInfo(), testio);; 7401 }; 7402 if (fCollectionProxy) {; 7403 return kTRUE;; 7404 }; 7405 if (fCurrentInfo.load()) {; 7406 // Emulated class, we know how to construct them via the TStreamerInfo; 7407 return kTRUE;; 7408 }; 7409 return kFALSE;; 7410}; 7411 ; 7412////////////////",MatchSource.WIKI,doc/v632/TClass_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/TClass_8cxx_source.html
https://root.cern/doc/v632/TClass_8cxx_source.html:285236,Integrability,wrap,wrapper,285236," 7391/// \endcode; 7392 ; 7393Bool_t TClass::HasDefaultConstructor(Bool_t testio) const; 7394{; 7395 ; 7396 if (fNew) return kTRUE;; 7397 ; 7398 if (HasInterpreterInfo()) {; 7399 R__LOCKGUARD(gInterpreterMutex);; 7400 return gCling->ClassInfo_HasDefaultConstructor(GetClassInfo(), testio);; 7401 }; 7402 if (fCollectionProxy) {; 7403 return kTRUE;; 7404 }; 7405 if (fCurrentInfo.load()) {; 7406 // Emulated class, we know how to construct them via the TStreamerInfo; 7407 return kTRUE;; 7408 }; 7409 return kFALSE;; 7410}; 7411 ; 7412////////////////////////////////////////////////////////////////////////////////; 7413/// Returns true if this class has an definition and/or overload of the; 7414/// member function Hash.; 7415///; 7416/// For example to test if the class overload TObject::Hash use; 7417/// ~~~ {.cpp}; 7418/// if (cl->IsTObject() && cl->HasLocalHashMember()); 7419/// ~~~; 7420 ; 7421Bool_t TClass::HasLocalHashMember() const; 7422{; 7423 if (fProperty == (-1)); 7424 Property();; 7425 return TestBit(kHasLocalHashMember);; 7426}; 7427 ; 7428////////////////////////////////////////////////////////////////////////////////; 7429/// Return the wrapper around Merge.; 7430 ; 7431ROOT::MergeFunc_t TClass::GetMerge() const; 7432{; 7433 return fMerge;; 7434}; 7435 ; 7436////////////////////////////////////////////////////////////////////////////////; 7437/// Return the wrapper around Merge.; 7438 ; 7439ROOT::ResetAfterMergeFunc_t TClass::GetResetAfterMerge() const; 7440{; 7441 return fResetAfterMerge;; 7442}; 7443 ; 7444////////////////////////////////////////////////////////////////////////////////; 7445/// Return the wrapper around new ThisClass().; 7446 ; 7447ROOT::NewFunc_t TClass::GetNew() const; 7448{; 7449 return fNew;; 7450}; 7451 ; 7452////////////////////////////////////////////////////////////////////////////////; 7453/// Return the wrapper around new ThisClass[].; 7454 ; 7455ROOT::NewArrFunc_t TClass::GetNewArray() const; 7456{; 7457 return fNewArray;; 7458}",MatchSource.WIKI,doc/v632/TClass_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/TClass_8cxx_source.html
https://root.cern/doc/v632/TClass_8cxx_source.html:285461,Integrability,wrap,wrapper,285461,"}; 7402 if (fCollectionProxy) {; 7403 return kTRUE;; 7404 }; 7405 if (fCurrentInfo.load()) {; 7406 // Emulated class, we know how to construct them via the TStreamerInfo; 7407 return kTRUE;; 7408 }; 7409 return kFALSE;; 7410}; 7411 ; 7412////////////////////////////////////////////////////////////////////////////////; 7413/// Returns true if this class has an definition and/or overload of the; 7414/// member function Hash.; 7415///; 7416/// For example to test if the class overload TObject::Hash use; 7417/// ~~~ {.cpp}; 7418/// if (cl->IsTObject() && cl->HasLocalHashMember()); 7419/// ~~~; 7420 ; 7421Bool_t TClass::HasLocalHashMember() const; 7422{; 7423 if (fProperty == (-1)); 7424 Property();; 7425 return TestBit(kHasLocalHashMember);; 7426}; 7427 ; 7428////////////////////////////////////////////////////////////////////////////////; 7429/// Return the wrapper around Merge.; 7430 ; 7431ROOT::MergeFunc_t TClass::GetMerge() const; 7432{; 7433 return fMerge;; 7434}; 7435 ; 7436////////////////////////////////////////////////////////////////////////////////; 7437/// Return the wrapper around Merge.; 7438 ; 7439ROOT::ResetAfterMergeFunc_t TClass::GetResetAfterMerge() const; 7440{; 7441 return fResetAfterMerge;; 7442}; 7443 ; 7444////////////////////////////////////////////////////////////////////////////////; 7445/// Return the wrapper around new ThisClass().; 7446 ; 7447ROOT::NewFunc_t TClass::GetNew() const; 7448{; 7449 return fNew;; 7450}; 7451 ; 7452////////////////////////////////////////////////////////////////////////////////; 7453/// Return the wrapper around new ThisClass[].; 7454 ; 7455ROOT::NewArrFunc_t TClass::GetNewArray() const; 7456{; 7457 return fNewArray;; 7458}; 7459 ; 7460////////////////////////////////////////////////////////////////////////////////; 7461/// Return the wrapper around delete ThiObject.; 7462 ; 7463ROOT::DelFunc_t TClass::GetDelete() const; 7464{; 7465 return fDelete;; 7466}; 7467 ; 7468////////////////////////////////////////////////",MatchSource.WIKI,doc/v632/TClass_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/TClass_8cxx_source.html
https://root.cern/doc/v632/TClass_8cxx_source.html:285716,Integrability,wrap,wrapper,285716,/////////////////////////////////////////////////////////////////////////; 7413/// Returns true if this class has an definition and/or overload of the; 7414/// member function Hash.; 7415///; 7416/// For example to test if the class overload TObject::Hash use; 7417/// ~~~ {.cpp}; 7418/// if (cl->IsTObject() && cl->HasLocalHashMember()); 7419/// ~~~; 7420 ; 7421Bool_t TClass::HasLocalHashMember() const; 7422{; 7423 if (fProperty == (-1)); 7424 Property();; 7425 return TestBit(kHasLocalHashMember);; 7426}; 7427 ; 7428////////////////////////////////////////////////////////////////////////////////; 7429/// Return the wrapper around Merge.; 7430 ; 7431ROOT::MergeFunc_t TClass::GetMerge() const; 7432{; 7433 return fMerge;; 7434}; 7435 ; 7436////////////////////////////////////////////////////////////////////////////////; 7437/// Return the wrapper around Merge.; 7438 ; 7439ROOT::ResetAfterMergeFunc_t TClass::GetResetAfterMerge() const; 7440{; 7441 return fResetAfterMerge;; 7442}; 7443 ; 7444////////////////////////////////////////////////////////////////////////////////; 7445/// Return the wrapper around new ThisClass().; 7446 ; 7447ROOT::NewFunc_t TClass::GetNew() const; 7448{; 7449 return fNew;; 7450}; 7451 ; 7452////////////////////////////////////////////////////////////////////////////////; 7453/// Return the wrapper around new ThisClass[].; 7454 ; 7455ROOT::NewArrFunc_t TClass::GetNewArray() const; 7456{; 7457 return fNewArray;; 7458}; 7459 ; 7460////////////////////////////////////////////////////////////////////////////////; 7461/// Return the wrapper around delete ThiObject.; 7462 ; 7463ROOT::DelFunc_t TClass::GetDelete() const; 7464{; 7465 return fDelete;; 7466}; 7467 ; 7468////////////////////////////////////////////////////////////////////////////////; 7469/// Return the wrapper around delete [] ThiObject.; 7470 ; 7471ROOT::DelArrFunc_t TClass::GetDeleteArray() const; 7472{; 7473 return fDeleteArray;; 7474}; 7475 ; 7476/////////////////////////////////////////,MatchSource.WIKI,doc/v632/TClass_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/TClass_8cxx_source.html
https://root.cern/doc/v632/TClass_8cxx_source.html:285945,Integrability,wrap,wrapper,285945,ct::Hash use; 7417/// ~~~ {.cpp}; 7418/// if (cl->IsTObject() && cl->HasLocalHashMember()); 7419/// ~~~; 7420 ; 7421Bool_t TClass::HasLocalHashMember() const; 7422{; 7423 if (fProperty == (-1)); 7424 Property();; 7425 return TestBit(kHasLocalHashMember);; 7426}; 7427 ; 7428////////////////////////////////////////////////////////////////////////////////; 7429/// Return the wrapper around Merge.; 7430 ; 7431ROOT::MergeFunc_t TClass::GetMerge() const; 7432{; 7433 return fMerge;; 7434}; 7435 ; 7436////////////////////////////////////////////////////////////////////////////////; 7437/// Return the wrapper around Merge.; 7438 ; 7439ROOT::ResetAfterMergeFunc_t TClass::GetResetAfterMerge() const; 7440{; 7441 return fResetAfterMerge;; 7442}; 7443 ; 7444////////////////////////////////////////////////////////////////////////////////; 7445/// Return the wrapper around new ThisClass().; 7446 ; 7447ROOT::NewFunc_t TClass::GetNew() const; 7448{; 7449 return fNew;; 7450}; 7451 ; 7452////////////////////////////////////////////////////////////////////////////////; 7453/// Return the wrapper around new ThisClass[].; 7454 ; 7455ROOT::NewArrFunc_t TClass::GetNewArray() const; 7456{; 7457 return fNewArray;; 7458}; 7459 ; 7460////////////////////////////////////////////////////////////////////////////////; 7461/// Return the wrapper around delete ThiObject.; 7462 ; 7463ROOT::DelFunc_t TClass::GetDelete() const; 7464{; 7465 return fDelete;; 7466}; 7467 ; 7468////////////////////////////////////////////////////////////////////////////////; 7469/// Return the wrapper around delete [] ThiObject.; 7470 ; 7471ROOT::DelArrFunc_t TClass::GetDeleteArray() const; 7472{; 7473 return fDeleteArray;; 7474}; 7475 ; 7476////////////////////////////////////////////////////////////////////////////////; 7477/// Return the wrapper around the destructor; 7478 ; 7479ROOT::DesFunc_t TClass::GetDestructor() const; 7480{; 7481 return fDestructor;; 7482}; 7483 ; 7484///////////////////////////////////////////////,MatchSource.WIKI,doc/v632/TClass_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/TClass_8cxx_source.html
https://root.cern/doc/v632/TClass_8cxx_source.html:286187,Integrability,wrap,wrapper,286187,sLocalHashMember);; 7426}; 7427 ; 7428////////////////////////////////////////////////////////////////////////////////; 7429/// Return the wrapper around Merge.; 7430 ; 7431ROOT::MergeFunc_t TClass::GetMerge() const; 7432{; 7433 return fMerge;; 7434}; 7435 ; 7436////////////////////////////////////////////////////////////////////////////////; 7437/// Return the wrapper around Merge.; 7438 ; 7439ROOT::ResetAfterMergeFunc_t TClass::GetResetAfterMerge() const; 7440{; 7441 return fResetAfterMerge;; 7442}; 7443 ; 7444////////////////////////////////////////////////////////////////////////////////; 7445/// Return the wrapper around new ThisClass().; 7446 ; 7447ROOT::NewFunc_t TClass::GetNew() const; 7448{; 7449 return fNew;; 7450}; 7451 ; 7452////////////////////////////////////////////////////////////////////////////////; 7453/// Return the wrapper around new ThisClass[].; 7454 ; 7455ROOT::NewArrFunc_t TClass::GetNewArray() const; 7456{; 7457 return fNewArray;; 7458}; 7459 ; 7460////////////////////////////////////////////////////////////////////////////////; 7461/// Return the wrapper around delete ThiObject.; 7462 ; 7463ROOT::DelFunc_t TClass::GetDelete() const; 7464{; 7465 return fDelete;; 7466}; 7467 ; 7468////////////////////////////////////////////////////////////////////////////////; 7469/// Return the wrapper around delete [] ThiObject.; 7470 ; 7471ROOT::DelArrFunc_t TClass::GetDeleteArray() const; 7472{; 7473 return fDeleteArray;; 7474}; 7475 ; 7476////////////////////////////////////////////////////////////////////////////////; 7477/// Return the wrapper around the destructor; 7478 ; 7479ROOT::DesFunc_t TClass::GetDestructor() const; 7480{; 7481 return fDestructor;; 7482}; 7483 ; 7484////////////////////////////////////////////////////////////////////////////////; 7485/// Return the wrapper around the directory auto add function.; 7486 ; 7487ROOT::DirAutoAdd_t TClass::GetDirectoryAutoAdd() const; 7488{; 7489 return fDirAutoAdd;; 7490}; b#define b(i)Definition RS,MatchSource.WIKI,doc/v632/TClass_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/TClass_8cxx_source.html
https://root.cern/doc/v632/TClass_8cxx_source.html:286423,Integrability,wrap,wrapper,286423,"e;; 7434}; 7435 ; 7436////////////////////////////////////////////////////////////////////////////////; 7437/// Return the wrapper around Merge.; 7438 ; 7439ROOT::ResetAfterMergeFunc_t TClass::GetResetAfterMerge() const; 7440{; 7441 return fResetAfterMerge;; 7442}; 7443 ; 7444////////////////////////////////////////////////////////////////////////////////; 7445/// Return the wrapper around new ThisClass().; 7446 ; 7447ROOT::NewFunc_t TClass::GetNew() const; 7448{; 7449 return fNew;; 7450}; 7451 ; 7452////////////////////////////////////////////////////////////////////////////////; 7453/// Return the wrapper around new ThisClass[].; 7454 ; 7455ROOT::NewArrFunc_t TClass::GetNewArray() const; 7456{; 7457 return fNewArray;; 7458}; 7459 ; 7460////////////////////////////////////////////////////////////////////////////////; 7461/// Return the wrapper around delete ThiObject.; 7462 ; 7463ROOT::DelFunc_t TClass::GetDelete() const; 7464{; 7465 return fDelete;; 7466}; 7467 ; 7468////////////////////////////////////////////////////////////////////////////////; 7469/// Return the wrapper around delete [] ThiObject.; 7470 ; 7471ROOT::DelArrFunc_t TClass::GetDeleteArray() const; 7472{; 7473 return fDeleteArray;; 7474}; 7475 ; 7476////////////////////////////////////////////////////////////////////////////////; 7477/// Return the wrapper around the destructor; 7478 ; 7479ROOT::DesFunc_t TClass::GetDestructor() const; 7480{; 7481 return fDestructor;; 7482}; 7483 ; 7484////////////////////////////////////////////////////////////////////////////////; 7485/// Return the wrapper around the directory auto add function.; 7486 ; 7487ROOT::DirAutoAdd_t TClass::GetDirectoryAutoAdd() const; 7488{; 7489 return fDirAutoAdd;; 7490}; b#define b(i)Definition RSha256.hxx:100; f#define f(i)Definition RSha256.hxx:104; c#define c(i)Definition RSha256.hxx:101; a#define a(i)Definition RSha256.hxx:99; e#define e(i)Definition RSha256.hxx:103; createvirtual RooAbsTestStatistic * create(const char *name, co",MatchSource.WIKI,doc/v632/TClass_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/TClass_8cxx_source.html
https://root.cern/doc/v632/TClass_8cxx_source.html:286675,Integrability,wrap,wrapper,286675,"n the wrapper around new ThisClass().; 7446 ; 7447ROOT::NewFunc_t TClass::GetNew() const; 7448{; 7449 return fNew;; 7450}; 7451 ; 7452////////////////////////////////////////////////////////////////////////////////; 7453/// Return the wrapper around new ThisClass[].; 7454 ; 7455ROOT::NewArrFunc_t TClass::GetNewArray() const; 7456{; 7457 return fNewArray;; 7458}; 7459 ; 7460////////////////////////////////////////////////////////////////////////////////; 7461/// Return the wrapper around delete ThiObject.; 7462 ; 7463ROOT::DelFunc_t TClass::GetDelete() const; 7464{; 7465 return fDelete;; 7466}; 7467 ; 7468////////////////////////////////////////////////////////////////////////////////; 7469/// Return the wrapper around delete [] ThiObject.; 7470 ; 7471ROOT::DelArrFunc_t TClass::GetDeleteArray() const; 7472{; 7473 return fDeleteArray;; 7474}; 7475 ; 7476////////////////////////////////////////////////////////////////////////////////; 7477/// Return the wrapper around the destructor; 7478 ; 7479ROOT::DesFunc_t TClass::GetDestructor() const; 7480{; 7481 return fDestructor;; 7482}; 7483 ; 7484////////////////////////////////////////////////////////////////////////////////; 7485/// Return the wrapper around the directory auto add function.; 7486 ; 7487ROOT::DirAutoAdd_t TClass::GetDirectoryAutoAdd() const; 7488{; 7489 return fDirAutoAdd;; 7490}; b#define b(i)Definition RSha256.hxx:100; f#define f(i)Definition RSha256.hxx:104; c#define c(i)Definition RSha256.hxx:101; a#define a(i)Definition RSha256.hxx:99; e#define e(i)Definition RSha256.hxx:103; createvirtual RooAbsTestStatistic * create(const char *name, const char *title, RooAbsReal &real, RooAbsData &data, const RooArgSet &projDeps, Configuration const &cfg)=0; sizesize_t size(const MatrixT &matrix)retrieve the size of a square matrix; Bool_tbool Bool_tDefinition RtypesCore.h:63; Int_tint Int_tDefinition RtypesCore.h:45; Longptr_tlong Longptr_tDefinition RtypesCore.h:82; Version_tshort Version_tDefinition RtypesCore.h:6",MatchSource.WIKI,doc/v632/TClass_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/TClass_8cxx_source.html
https://root.cern/doc/v632/TClass_8cxx_source.html:286916,Integrability,wrap,wrapper,286916,"n the wrapper around new ThisClass().; 7446 ; 7447ROOT::NewFunc_t TClass::GetNew() const; 7448{; 7449 return fNew;; 7450}; 7451 ; 7452////////////////////////////////////////////////////////////////////////////////; 7453/// Return the wrapper around new ThisClass[].; 7454 ; 7455ROOT::NewArrFunc_t TClass::GetNewArray() const; 7456{; 7457 return fNewArray;; 7458}; 7459 ; 7460////////////////////////////////////////////////////////////////////////////////; 7461/// Return the wrapper around delete ThiObject.; 7462 ; 7463ROOT::DelFunc_t TClass::GetDelete() const; 7464{; 7465 return fDelete;; 7466}; 7467 ; 7468////////////////////////////////////////////////////////////////////////////////; 7469/// Return the wrapper around delete [] ThiObject.; 7470 ; 7471ROOT::DelArrFunc_t TClass::GetDeleteArray() const; 7472{; 7473 return fDeleteArray;; 7474}; 7475 ; 7476////////////////////////////////////////////////////////////////////////////////; 7477/// Return the wrapper around the destructor; 7478 ; 7479ROOT::DesFunc_t TClass::GetDestructor() const; 7480{; 7481 return fDestructor;; 7482}; 7483 ; 7484////////////////////////////////////////////////////////////////////////////////; 7485/// Return the wrapper around the directory auto add function.; 7486 ; 7487ROOT::DirAutoAdd_t TClass::GetDirectoryAutoAdd() const; 7488{; 7489 return fDirAutoAdd;; 7490}; b#define b(i)Definition RSha256.hxx:100; f#define f(i)Definition RSha256.hxx:104; c#define c(i)Definition RSha256.hxx:101; a#define a(i)Definition RSha256.hxx:99; e#define e(i)Definition RSha256.hxx:103; createvirtual RooAbsTestStatistic * create(const char *name, const char *title, RooAbsReal &real, RooAbsData &data, const RooArgSet &projDeps, Configuration const &cfg)=0; sizesize_t size(const MatrixT &matrix)retrieve the size of a square matrix; Bool_tbool Bool_tDefinition RtypesCore.h:63; Int_tint Int_tDefinition RtypesCore.h:45; Longptr_tlong Longptr_tDefinition RtypesCore.h:82; Version_tshort Version_tDefinition RtypesCore.h:6",MatchSource.WIKI,doc/v632/TClass_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/TClass_8cxx_source.html
https://root.cern/doc/v632/TClass_8cxx_source.html:304905,Integrability,interface,interface,304905,"ertyLong_t Property() const overrideGet property description word. For meaning of bits see EProperty.Definition TBaseClass.cxx:134; TBaseClass::GetClassPointerTClass * GetClassPointer(Bool_t load=kTRUE)Get pointer to the base class TClass.Definition TBaseClass.cxx:63; TBrowserUsing a TBrowser one can browse all ROOT objects.Definition TBrowser.h:37; TBufferBuffer base class used for serializing objects.Definition TBuffer.h:43; TBuildRealDataDefinition TClass.cxx:751; TBuildRealData::Inspectvoid Inspect(TClass *cl, const char *parent, const char *name, const void *addr, Bool_t isTransient) overrideThis method is called from ShowMembers() via BuildRealdata().Definition TClass.cxx:771; TBuildRealData::fRealDataClassTClass * fRealDataClassDefinition TClass.cxx:755; TBuildRealData::fRealDataObjectvoid * fRealDataObjectDefinition TClass.cxx:754; TBuildRealData::TBuildRealDataTBuildRealData(void *obj, TClass *cl)Definition TClass.cxx:758; TClassGeneratorObjects following this interface can be passed onto the TROOT object to implement a user customized w...Definition TClassGenerator.h:28; TClassGenerator::GetClassvirtual TClass * GetClass(const char *classname, Bool_t load)=0; TClassMenuItemDescribes one element of the context menu associated to a class The menu item may describe.Definition TClassMenuItem.h:31; TClassMenuItem::SetTogglevirtual void SetToggle(Bool_t toggle=kTRUE)Definition TClassMenuItem.h:75; TClassMenuItem::kIsSelf@ kIsSelfDefinition TClassMenuItem.h:37; TClassMenuItem::kPopupStandardList@ kPopupStandardListDefinition TClassMenuItem.h:35; TClassMenuItem::kPopupSeparator@ kPopupSeparatorDefinition TClassMenuItem.h:35; TClassMenuItem::kPopupUserFunction@ kPopupUserFunctionDefinition TClassMenuItem.h:35; TClassRefTClassRef is used to implement a permanent reference to a TClass object.Definition TClassRef.h:28; TClassStreamerDefinition TClassStreamer.h:26; TClassStreamer::Streamvirtual void Stream(TBuffer &b, void *objp, const TClass *onfileClass)Definition TC",MatchSource.WIKI,doc/v632/TClass_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/TClass_8cxx_source.html
https://root.cern/doc/v632/TClass_8cxx_source.html:308998,Integrability,wrap,wrapper,308998,"_t fObjectVersionRepositoryDefinition TClass.h:344; TClass::fShowMembersShowMembersFunc_t fShowMembersDefinition TClass.h:225; TClass::GetDataMemberTDataMember * GetDataMember(const char *datamember) constReturn pointer to datamember object with name ""datamember"".Definition TClass.cxx:3439; TClass::fIsATVirtualIsAProxy * fIsADefinition TClass.h:229; TClass::GetListOfUsingDataMembersTList * GetListOfUsingDataMembers(Bool_t load=kTRUE)Return list containing the TDataMembers of using declarations of a class.Definition TClass.cxx:3786; TClass::ForceReloadvoid ForceReload(TClass *oldcl)we found at least one equivalent.Definition TClass.cxx:1336; TClass::fDeleteArrayROOT::DelArrFunc_t fDeleteArrayDefinition TClass.h:238; TClass::CanSplitBool_t CanSplit() constReturn true if the data member of this TClass can be saved separately.Definition TClass.cxx:2319; TClass::fStreamerTClassStreamer * fStreamerDefinition TClass.h:226; TClass::SetDirectoryAutoAddvoid SetDirectoryAutoAdd(ROOT::DirAutoAdd_t dirAutoAddFunc)Install a new wrapper around the directory auto add function.Definition TClass.cxx:7028; TClass::NewArrayvoid * NewArray(Long_t nElements, ENewType defConstructor=kClassNew) constReturn a pointer to a newly allocated array of objects of this class.Definition TClass.cxx:5193; TClass::fNoInfoOrEmuOrFwdDeclNameRegistrystatic TDeclNameRegistry fNoInfoOrEmuOrFwdDeclNameRegistryDefinition TClass.h:328; TClass::fFuncTemplateTListOfFunctionTemplates * fFuncTemplateDefinition TClass.h:206; TClass::fStreamerFuncClassStreamerFunc_t fStreamerFuncDefinition TClass.h:241; TClass::AdoptReferenceProxyvoid AdoptReferenceProxy(TVirtualRefProxy *proxy)Adopt the Reference proxy pointer to indicate that this class represents a reference.Definition TClass.cxx:6685; TClass::GetClassMethodTMethod * GetClassMethod(Longptr_t faddr)Look for a method in this class that has the interface function address faddr.Definition TClass.cxx:4483; TClass::DetermineCurrentStreamerInfoTVirtualStreamerInfo * De",MatchSource.WIKI,doc/v632/TClass_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/TClass_8cxx_source.html
https://root.cern/doc/v632/TClass_8cxx_source.html:309846,Integrability,interface,interface,309846,"efinition TClass.cxx:2319; TClass::fStreamerTClassStreamer * fStreamerDefinition TClass.h:226; TClass::SetDirectoryAutoAddvoid SetDirectoryAutoAdd(ROOT::DirAutoAdd_t dirAutoAddFunc)Install a new wrapper around the directory auto add function.Definition TClass.cxx:7028; TClass::NewArrayvoid * NewArray(Long_t nElements, ENewType defConstructor=kClassNew) constReturn a pointer to a newly allocated array of objects of this class.Definition TClass.cxx:5193; TClass::fNoInfoOrEmuOrFwdDeclNameRegistrystatic TDeclNameRegistry fNoInfoOrEmuOrFwdDeclNameRegistryDefinition TClass.h:328; TClass::fFuncTemplateTListOfFunctionTemplates * fFuncTemplateDefinition TClass.h:206; TClass::fStreamerFuncClassStreamerFunc_t fStreamerFuncDefinition TClass.h:241; TClass::AdoptReferenceProxyvoid AdoptReferenceProxy(TVirtualRefProxy *proxy)Adopt the Reference proxy pointer to indicate that this class represents a reference.Definition TClass.cxx:6685; TClass::GetClassMethodTMethod * GetClassMethod(Longptr_t faddr)Look for a method in this class that has the interface function address faddr.Definition TClass.cxx:4483; TClass::DetermineCurrentStreamerInfoTVirtualStreamerInfo * DetermineCurrentStreamerInfo()Determine and set pointer to current TVirtualStreamerInfo.Definition TClass.cxx:5684; TClass::Browsevoid Browse(TBrowser *b) overrideThis method is called by a browser to get the class information.Definition TClass.cxx:2010; TClass::GetStateEState GetState() constDefinition TClass.h:488; TClass::GetCollectionTypeROOT::ESTLType GetCollectionType() constReturn the 'type' of the STL the TClass is representing.Definition TClass.cxx:2886; TClass::Drawvoid Draw(Option_t *option="""") overrideDraw detailed class inheritance structure.Definition TClass.cxx:2487; TClass::AdoptMemberStreamervoid AdoptMemberStreamer(const char *name, TMemberStreamer *strm)Adopt the TMemberStreamer pointer to by p and use it to Stream non basic member name.Definition TClass.cxx:6703; TClass::ResetInstanceCountvoid ResetInstance",MatchSource.WIKI,doc/v632/TClass_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/TClass_8cxx_source.html
https://root.cern/doc/v632/TClass_8cxx_source.html:310908,Integrability,wrap,wrapper,310908,"TClass::DetermineCurrentStreamerInfoTVirtualStreamerInfo * DetermineCurrentStreamerInfo()Determine and set pointer to current TVirtualStreamerInfo.Definition TClass.cxx:5684; TClass::Browsevoid Browse(TBrowser *b) overrideThis method is called by a browser to get the class information.Definition TClass.cxx:2010; TClass::GetStateEState GetState() constDefinition TClass.h:488; TClass::GetCollectionTypeROOT::ESTLType GetCollectionType() constReturn the 'type' of the STL the TClass is representing.Definition TClass.cxx:2886; TClass::Drawvoid Draw(Option_t *option="""") overrideDraw detailed class inheritance structure.Definition TClass.cxx:2487; TClass::AdoptMemberStreamervoid AdoptMemberStreamer(const char *name, TMemberStreamer *strm)Adopt the TMemberStreamer pointer to by p and use it to Stream non basic member name.Definition TClass.cxx:6703; TClass::ResetInstanceCountvoid ResetInstanceCount()Definition TClass.h:547; TClass::GetStreamerFuncClassStreamerFunc_t GetStreamerFunc() constGet a wrapper/accessor function around this class custom streamer (member function).Definition TClass.cxx:2939; TClass::RemoveStreamerInfovoid RemoveStreamerInfo(Int_t slot)Remove and delete the StreamerInfo in the given slot.Definition TClass.cxx:7320; TClass::SetCanSplitvoid SetCanSplit(Int_t splitmode)Set the splitability of this class:Definition TClass.cxx:5658; TClass::CreateListOfDataMembersTList * CreateListOfDataMembers(std::atomic< TListOfDataMembers * > &data, TDictionary::EMemberSelection selection, bool load)Create the list containing the TDataMembers (of actual data members or members pulled in through usin...Definition TClass.cxx:3741; TClass::GetStreamerInfoAbstractEmulatedTVirtualStreamerInfo * GetStreamerInfoAbstractEmulated(Int_t version=0) constFor the case where the requestor class is emulated and this class is abstract, returns a pointer to t...Definition TClass.cxx:4709; TClass::Newvoid * New(ENewType defConstructor=kClassNew, Bool_t quiet=kFALSE) constReturn a pointer ",MatchSource.WIKI,doc/v632/TClass_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/TClass_8cxx_source.html
https://root.cern/doc/v632/TClass_8cxx_source.html:312050,Integrability,wrap,wrapper,312050,"::RemoveStreamerInfovoid RemoveStreamerInfo(Int_t slot)Remove and delete the StreamerInfo in the given slot.Definition TClass.cxx:7320; TClass::SetCanSplitvoid SetCanSplit(Int_t splitmode)Set the splitability of this class:Definition TClass.cxx:5658; TClass::CreateListOfDataMembersTList * CreateListOfDataMembers(std::atomic< TListOfDataMembers * > &data, TDictionary::EMemberSelection selection, bool load)Create the list containing the TDataMembers (of actual data members or members pulled in through usin...Definition TClass.cxx:3741; TClass::GetStreamerInfoAbstractEmulatedTVirtualStreamerInfo * GetStreamerInfoAbstractEmulated(Int_t version=0) constFor the case where the requestor class is emulated and this class is abstract, returns a pointer to t...Definition TClass.cxx:4709; TClass::Newvoid * New(ENewType defConstructor=kClassNew, Bool_t quiet=kFALSE) constReturn a pointer to a newly allocated object of this class.Definition TClass.cxx:4978; TClass::SetMergevoid SetMerge(ROOT::MergeFunc_t mergeFunc)Install a new wrapper around 'Merge'.Definition TClass.cxx:6969; TClass::fConversionStreamerInfoConvSIMap_t fConversionStreamerInfoDefinition TClass.h:199; TClass::fDirAutoAddROOT::DirAutoAdd_t fDirAutoAddDefinition TClass.h:240; TClass::HasDataMemberInfoBool_t HasDataMemberInfo() constDefinition TClass.h:407; TClass::fRefProxyTVirtualRefProxy * fRefProxycached streamer info used in the last read.Definition TClass.h:280; TClass::GetMenuListTList * GetMenuList() constReturn the list of menu items associated with the class.Definition TClass.cxx:4341; TClass::fMergeROOT::MergeFunc_t fMergesaved info to call a IsA member functionDefinition TClass.h:233; TClass::GetMethodTMethod * GetMethod(const char *method, const char *params, Bool_t objectIsConst=kFALSE)Find the best method (if there is one) matching the parameters.Definition TClass.cxx:4411; TClass::Loadstatic TClass * Load(TBuffer &b)Load class description from I/O buffer and return class object.Definition TClass.cxx:57",MatchSource.WIKI,doc/v632/TClass_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/TClass_8cxx_source.html
https://root.cern/doc/v632/TClass_8cxx_source.html:313183,Integrability,wrap,wrapper,313183,"merInfoDefinition TClass.h:199; TClass::fDirAutoAddROOT::DirAutoAdd_t fDirAutoAddDefinition TClass.h:240; TClass::HasDataMemberInfoBool_t HasDataMemberInfo() constDefinition TClass.h:407; TClass::fRefProxyTVirtualRefProxy * fRefProxycached streamer info used in the last read.Definition TClass.h:280; TClass::GetMenuListTList * GetMenuList() constReturn the list of menu items associated with the class.Definition TClass.cxx:4341; TClass::fMergeROOT::MergeFunc_t fMergesaved info to call a IsA member functionDefinition TClass.h:233; TClass::GetMethodTMethod * GetMethod(const char *method, const char *params, Bool_t objectIsConst=kFALSE)Find the best method (if there is one) matching the parameters.Definition TClass.cxx:4411; TClass::Loadstatic TClass * Load(TBuffer &b)Load class description from I/O buffer and return class object.Definition TClass.cxx:5715; TClass::fStateEState fStatecached of the streaming method to useDefinition TClass.h:277; TClass::GetDestructorROOT::DesFunc_t GetDestructor() constReturn the wrapper around the destructor.Definition TClass.cxx:7479; TClass::GetMethodWithPrototypeTMethod * GetMethodWithPrototype(const char *method, const char *proto, Bool_t objectIsConst=kFALSE, ROOT::EFunctionMatchMode mode=ROOT::kConversionMatch)Find the method with a given prototype.Definition TClass.cxx:4456; TClass::CopyCollectionProxyvoid CopyCollectionProxy(const TVirtualCollectionProxy &)Replaces the collection proxy for this class.Definition TClass.cxx:2470; TClass::fStreamerTypeInt_t fStreamerTypesaved info to call StreamerDefinition TClass.h:276; TClass::fRealDataTList * fRealDataDefinition TClass.h:200; TClass::fOnHeapUInt_t fOnHeapDefinition TClass.h:218; TClass::lsvoid ls(Option_t *opt="""") const overrideThe ls function lists the contents of a class on stdout.Definition TClass.cxx:4258; TClass::fBasestd::atomic< TList * > fBaseDefinition TClass.h:201; TClass::fCanSplitstd::atomic< Char_t > fCanSplitDefinition TClass.h:245; TClass::HasDictionaryBool_t HasDi",MatchSource.WIKI,doc/v632/TClass_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/TClass_8cxx_source.html
https://root.cern/doc/v632/TClass_8cxx_source.html:316533,Integrability,wrap,wrapper,316533,"_t load=kTRUE)Return TListOfFunctionTemplates for a class.Definition TClass.cxx:3798; TClass::DynamicCastvoid * DynamicCast(const TClass *base, void *obj, Bool_t up=kTRUE)Cast obj of this class type up to baseclass cl if up is true.Definition TClass.cxx:4915; TClass::fImplFileNameconst char * fImplFileNameDefinition TClass.h:214; TClass::RegisterStreamerInfovoid RegisterStreamerInfo(TVirtualStreamerInfo *info)Register the StreamerInfo in the given slot, change the State of the TClass as appropriate.Definition TClass.cxx:7296; TClass::fCheckSumstd::atomic< UInt_t > fCheckSumDefinition TClass.h:219; TClass::UnregisterAddressInRepositoryvoid UnregisterAddressInRepository(const char *where, void *location, const TClass *what) constDefinition TClass.cxx:318; TClass::fMethodstd::atomic< TListOfFunctions * > fMethodDefinition TClass.h:207; TClass::RemoveClassDeclIdstatic void RemoveClassDeclId(TDictionary::DeclId_t id)Definition TClass.cxx:536; TClass::SetNewArrayvoid SetNewArray(ROOT::NewArrFunc_t newArrayFunc)Install a new wrapper around 'new []'.Definition TClass.cxx:6993; TClass::CallShowMembersBool_t CallShowMembers(const void *obj, TMemberInspector &insp, Bool_t isTransient=kFALSE) constCall ShowMembers() on the obj of this class type, passing insp and parent.Definition TClass.cxx:2205; TClass::fDeclFileNameconst char * fDeclFileNameDefinition TClass.h:213; TClass::SetCollectionProxyvoid SetCollectionProxy(const ROOT::Detail::TCollectionProxyInfo &)Create the collection proxy object (and the streamer object) from using the information in the TColle...Definition TClass.cxx:6244; TClass::HasDictionarySelectionstatic Bool_t HasDictionarySelection(const char *clname)Check whether a class has a dictionary or ROOT can load one.Definition TClass.cxx:3917; TClass::AdoptSchemaRulesvoid AdoptSchemaRules(ROOT::Detail::TSchemaRuleSet *rules)Adopt a new set of Data Model Evolution rules.Definition TClass.cxx:1920; TClass::StreamerInstrumentedstatic void StreamerInstrumented(const ",MatchSource.WIKI,doc/v632/TClass_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/TClass_8cxx_source.html
https://root.cern/doc/v632/TClass_8cxx_source.html:318135,Integrability,wrap,wrapper,318135,"sDictionarySelectionstatic Bool_t HasDictionarySelection(const char *clname)Check whether a class has a dictionary or ROOT can load one.Definition TClass.cxx:3917; TClass::AdoptSchemaRulesvoid AdoptSchemaRules(ROOT::Detail::TSchemaRuleSet *rules)Adopt a new set of Data Model Evolution rules.Definition TClass.cxx:1920; TClass::StreamerInstrumentedstatic void StreamerInstrumented(const TClass *pThis, void *object, TBuffer &b, const TClass *onfile_class)Case of instrumented class with a library.Definition TClass.cxx:6836; TClass::SetStreamerInfoTVirtualStreamerInfo * SetStreamerInfo(Int_t version, const char *info="""")Info is a string describing the names and types of attributes written by the class Streamer function.Definition TClass.cxx:6373; TClass::fgClassCountstatic std::atomic< Int_t > fgClassCountDefinition TClass.h:326; TClass::GetCurrentStreamerInfoTVirtualStreamerInfo * GetCurrentStreamerInfo()Definition TClass.h:439; TClass::GetDirectoryAutoAddROOT::DirAutoAdd_t GetDirectoryAutoAdd() constReturn the wrapper around the directory auto add function.Definition TClass.cxx:7487; TClass::AddImplFilevoid AddImplFile(const char *filename, int line)Definition TClass.cxx:1952; TClass::GetListOfMethodOverloadsTCollection * GetListOfMethodOverloads(const char *name) constReturn the collection of functions named ""name"".Definition TClass.cxx:3827; TClass::fEnumsstd::atomic< TListOfEnums * > fEnumsDefinition TClass.h:205; TClass::HasNoInfoOrEmuOrFwdDeclaredDeclstatic Bool_t HasNoInfoOrEmuOrFwdDeclaredDecl(const char *)Definition TClass.cxx:3398; TClass::fOVRMutexTVirtualMutex * fOVRMutexDefinition TClass.h:342; TClass::GetListOfEnumsTList * GetListOfEnums(Bool_t load=kTRUE)Return a list containing the TEnums of a class.Definition TClass.cxx:3686; TClass::IsStartingWithTObjectBool_t IsStartingWithTObject() constReturns true if this class inherits from TObject and if the start of the TObject parts is at the very...Definition TClass.cxx:5929; TClass::GetListOfMethodsTList * Get",MatchSource.WIKI,doc/v632/TClass_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/TClass_8cxx_source.html
https://root.cern/doc/v632/TClass_8cxx_source.html:320179,Integrability,wrap,wrapper,320179,"n list containing the TMethods of a class.Definition TClass.cxx:3812; TClass::TClassTClass()Internal, default constructor.Definition TClass.cxx:1065; TClass::fDeclFileLineShort_t fDeclFileLineDefinition TClass.h:215; TClass::GetNmethodsInt_t GetNmethods()Return the number of methods of this class Note that in case the list of methods is not yet created,...Definition TClass.cxx:4573; TClass::fIsOffsetStreamerSetstd::atomic< Bool_t > fIsOffsetStreamerSetIndicates whether the ClassInfo is supposed to be available.Definition TClass.h:261; TClass::IgnoreTObjectStreamervoid IgnoreTObjectStreamer(Bool_t ignore=kTRUE)When the class kIgnoreTObjectStreamer bit is set, the automatically generated Streamer will not call ...Definition TClass.cxx:4841; TClass::GetStreamerTClassStreamer * GetStreamer() constReturn the Streamer Class allowing streaming (if any).Definition TClass.cxx:2914; TClass::GetIdMapstatic IdMap_t * GetIdMap()Definition TClass.cxx:469; TClass::SetDeletevoid SetDelete(ROOT::DelFunc_t deleteFunc)Install a new wrapper around 'delete'.Definition TClass.cxx:7001; TClass::AutoBrowsestatic Int_t AutoBrowse(TObject *obj, TBrowser *browser)Browse external object inherited from TObject.Definition TClass.cxx:1966; TClass::GetNewROOT::NewFunc_t GetNew() constReturn the wrapper around new ThisClass().Definition TClass.cxx:7447; TClass::GetBaseClassTClass * GetBaseClass(const char *classname)Return pointer to the base class ""classname"".Definition TClass.cxx:2655; TClass::GetDataMemberOffsetLongptr_t GetDataMemberOffset(const char *membername) constreturn offset for member name.Definition TClass.cxx:3477; TClass::GetNdataInt_t GetNdata()Return the number of data members of this class Note that in case the list of data members is not yet...Definition TClass.cxx:4554; TClass::SetDestructorvoid SetDestructor(ROOT::DesFunc_t destructorFunc)Install a new wrapper around the destructor.Definition TClass.cxx:7017; TClass::PostLoadCheckvirtual void PostLoadCheck()Do the initializatio",MatchSource.WIKI,doc/v632/TClass_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/TClass_8cxx_source.html
https://root.cern/doc/v632/TClass_8cxx_source.html:320434,Integrability,wrap,wrapper,320434,"umber of methods of this class Note that in case the list of methods is not yet created,...Definition TClass.cxx:4573; TClass::fIsOffsetStreamerSetstd::atomic< Bool_t > fIsOffsetStreamerSetIndicates whether the ClassInfo is supposed to be available.Definition TClass.h:261; TClass::IgnoreTObjectStreamervoid IgnoreTObjectStreamer(Bool_t ignore=kTRUE)When the class kIgnoreTObjectStreamer bit is set, the automatically generated Streamer will not call ...Definition TClass.cxx:4841; TClass::GetStreamerTClassStreamer * GetStreamer() constReturn the Streamer Class allowing streaming (if any).Definition TClass.cxx:2914; TClass::GetIdMapstatic IdMap_t * GetIdMap()Definition TClass.cxx:469; TClass::SetDeletevoid SetDelete(ROOT::DelFunc_t deleteFunc)Install a new wrapper around 'delete'.Definition TClass.cxx:7001; TClass::AutoBrowsestatic Int_t AutoBrowse(TObject *obj, TBrowser *browser)Browse external object inherited from TObject.Definition TClass.cxx:1966; TClass::GetNewROOT::NewFunc_t GetNew() constReturn the wrapper around new ThisClass().Definition TClass.cxx:7447; TClass::GetBaseClassTClass * GetBaseClass(const char *classname)Return pointer to the base class ""classname"".Definition TClass.cxx:2655; TClass::GetDataMemberOffsetLongptr_t GetDataMemberOffset(const char *membername) constreturn offset for member name.Definition TClass.cxx:3477; TClass::GetNdataInt_t GetNdata()Return the number of data members of this class Note that in case the list of data members is not yet...Definition TClass.cxx:4554; TClass::SetDestructorvoid SetDestructor(ROOT::DesFunc_t destructorFunc)Install a new wrapper around the destructor.Definition TClass.cxx:7017; TClass::PostLoadCheckvirtual void PostLoadCheck()Do the initialization that can only be done after the CINT dictionary has been fully populated and ca...Definition TClass.cxx:5959; TClass::LoadClassInfovoid LoadClassInfo() constTry to load the ClassInfo if available.Definition TClass.cxx:5824; TClass::SetResetAfterMergevoid SetResetAf",MatchSource.WIKI,doc/v632/TClass_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/TClass_8cxx_source.html
https://root.cern/doc/v632/TClass_8cxx_source.html:321023,Integrability,wrap,wrapper,321023,"treaming (if any).Definition TClass.cxx:2914; TClass::GetIdMapstatic IdMap_t * GetIdMap()Definition TClass.cxx:469; TClass::SetDeletevoid SetDelete(ROOT::DelFunc_t deleteFunc)Install a new wrapper around 'delete'.Definition TClass.cxx:7001; TClass::AutoBrowsestatic Int_t AutoBrowse(TObject *obj, TBrowser *browser)Browse external object inherited from TObject.Definition TClass.cxx:1966; TClass::GetNewROOT::NewFunc_t GetNew() constReturn the wrapper around new ThisClass().Definition TClass.cxx:7447; TClass::GetBaseClassTClass * GetBaseClass(const char *classname)Return pointer to the base class ""classname"".Definition TClass.cxx:2655; TClass::GetDataMemberOffsetLongptr_t GetDataMemberOffset(const char *membername) constreturn offset for member name.Definition TClass.cxx:3477; TClass::GetNdataInt_t GetNdata()Return the number of data members of this class Note that in case the list of data members is not yet...Definition TClass.cxx:4554; TClass::SetDestructorvoid SetDestructor(ROOT::DesFunc_t destructorFunc)Install a new wrapper around the destructor.Definition TClass.cxx:7017; TClass::PostLoadCheckvirtual void PostLoadCheck()Do the initialization that can only be done after the CINT dictionary has been fully populated and ca...Definition TClass.cxx:5959; TClass::LoadClassInfovoid LoadClassInfo() constTry to load the ClassInfo if available.Definition TClass.cxx:5824; TClass::SetResetAfterMergevoid SetResetAfterMerge(ROOT::ResetAfterMergeFunc_t resetFunc)Install a new wrapper around 'ResetAfterMerge'.Definition TClass.cxx:6977; TClass::GetStreamerInfoImplTVirtualStreamerInfo * GetStreamerInfoImpl(Int_t version, Bool_t silent) constDefinition TClass.cxx:4634; TClass::MatchLegacyCheckSumBool_t MatchLegacyCheckSum(UInt_t checksum) constReturn true if the checksum passed as argument is one of the checksum value produced by the older che...Definition TClass.cxx:6494; TClass::fAllPubMethodTViewPubFunctions * fAllPubMethodDefinition TClass.h:210; TClass::ERuntimeProperties::kSet",MatchSource.WIKI,doc/v632/TClass_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/TClass_8cxx_source.html
https://root.cern/doc/v632/TClass_8cxx_source.html:321478,Integrability,wrap,wrapper,321478,"per around new ThisClass().Definition TClass.cxx:7447; TClass::GetBaseClassTClass * GetBaseClass(const char *classname)Return pointer to the base class ""classname"".Definition TClass.cxx:2655; TClass::GetDataMemberOffsetLongptr_t GetDataMemberOffset(const char *membername) constreturn offset for member name.Definition TClass.cxx:3477; TClass::GetNdataInt_t GetNdata()Return the number of data members of this class Note that in case the list of data members is not yet...Definition TClass.cxx:4554; TClass::SetDestructorvoid SetDestructor(ROOT::DesFunc_t destructorFunc)Install a new wrapper around the destructor.Definition TClass.cxx:7017; TClass::PostLoadCheckvirtual void PostLoadCheck()Do the initialization that can only be done after the CINT dictionary has been fully populated and ca...Definition TClass.cxx:5959; TClass::LoadClassInfovoid LoadClassInfo() constTry to load the ClassInfo if available.Definition TClass.cxx:5824; TClass::SetResetAfterMergevoid SetResetAfterMerge(ROOT::ResetAfterMergeFunc_t resetFunc)Install a new wrapper around 'ResetAfterMerge'.Definition TClass.cxx:6977; TClass::GetStreamerInfoImplTVirtualStreamerInfo * GetStreamerInfoImpl(Int_t version, Bool_t silent) constDefinition TClass.cxx:4634; TClass::MatchLegacyCheckSumBool_t MatchLegacyCheckSum(UInt_t checksum) constReturn true if the checksum passed as argument is one of the checksum value produced by the older che...Definition TClass.cxx:6494; TClass::fAllPubMethodTViewPubFunctions * fAllPubMethodDefinition TClass.h:210; TClass::ERuntimeProperties::kSet@ kSet; TClass::ERuntimeProperties::kConsistentHash@ kConsistentHash; TClass::HasInterpreterInfoBool_t HasInterpreterInfo() constDefinition TClass.h:410; TClass::AddClassstatic void AddClass(TClass *cl)static: Add a class to the list and map of classes.Definition TClass.cxx:494; TClass::GetMissingDictionariesForBaseClassesvoid GetMissingDictionariesForBaseClasses(TCollection &result, TCollection &visited, bool recurse)Verify the base classes al",MatchSource.WIKI,doc/v632/TClass_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/TClass_8cxx_source.html
https://root.cern/doc/v632/TClass_8cxx_source.html:323197,Integrability,wrap,wrapper,323197," AddClass(TClass *cl)static: Add a class to the list and map of classes.Definition TClass.cxx:494; TClass::GetMissingDictionariesForBaseClassesvoid GetMissingDictionariesForBaseClasses(TCollection &result, TCollection &visited, bool recurse)Verify the base classes always.Definition TClass.cxx:3927; TClass::fSchemaRulesROOT::Detail::TSchemaRuleSet * fSchemaRulesPointer to reference proxy if this class represents a reference.Definition TClass.h:281; TClass::fPropertystd::atomic< Long_t > fPropertyDefinition TClass.h:255; TClass::StreamerDefaultstatic void StreamerDefault(const TClass *pThis, void *object, TBuffer &b, const TClass *onfile_class)Default streaming in cases where either we have no way to know what to do or if Property() has not ye...Definition TClass.cxx:6873; TClass::SetUnloadedvoid SetUnloaded()Call this method to indicate that the shared library containing this class's code has been removed (u...Definition TClass.cxx:6309; TClass::GetDeleteArrayROOT::DelArrFunc_t GetDeleteArray() constReturn the wrapper around delete [] ThiObject.Definition TClass.cxx:7471; TClass::HasInterpreterInfoInMemoryBool_t HasInterpreterInfoInMemory() constDefinition TClass.h:409; TClass::fClassMenuListTList * fClassMenuListDefinition TClass.h:211; TClass::fConvStreamerFuncClassConvStreamerFunc_t fConvStreamerFuncDefinition TClass.h:242; TClass::BuildRealDatavoid BuildRealData(void *pointer=nullptr, Bool_t isTransient=kFALSE)Build a full list of persistent data members.Definition TClass.cxx:2031; TClass::SetRuntimePropertiesvoid SetRuntimeProperties()Internal routine to set calculate the class properties that can only be known at run-time,...Definition TClass.cxx:6194; TClass::BuildEmulatedRealDatavoid BuildEmulatedRealData(const char *name, Longptr_t offset, TClass *cl, Bool_t isTransient=kFALSE)Build the list of real data for an emulated class.Definition TClass.cxx:2112; TClass::LoadClassstatic TClass * LoadClass(const char *requestedname, Bool_t silent)Helper function used by",MatchSource.WIKI,doc/v632/TClass_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/TClass_8cxx_source.html
https://root.cern/doc/v632/TClass_8cxx_source.html:323746,Integrability,rout,routine,323746,"nst TClass *pThis, void *object, TBuffer &b, const TClass *onfile_class)Default streaming in cases where either we have no way to know what to do or if Property() has not ye...Definition TClass.cxx:6873; TClass::SetUnloadedvoid SetUnloaded()Call this method to indicate that the shared library containing this class's code has been removed (u...Definition TClass.cxx:6309; TClass::GetDeleteArrayROOT::DelArrFunc_t GetDeleteArray() constReturn the wrapper around delete [] ThiObject.Definition TClass.cxx:7471; TClass::HasInterpreterInfoInMemoryBool_t HasInterpreterInfoInMemory() constDefinition TClass.h:409; TClass::fClassMenuListTList * fClassMenuListDefinition TClass.h:211; TClass::fConvStreamerFuncClassConvStreamerFunc_t fConvStreamerFuncDefinition TClass.h:242; TClass::BuildRealDatavoid BuildRealData(void *pointer=nullptr, Bool_t isTransient=kFALSE)Build a full list of persistent data members.Definition TClass.cxx:2031; TClass::SetRuntimePropertiesvoid SetRuntimeProperties()Internal routine to set calculate the class properties that can only be known at run-time,...Definition TClass.cxx:6194; TClass::BuildEmulatedRealDatavoid BuildEmulatedRealData(const char *name, Longptr_t offset, TClass *cl, Bool_t isTransient=kFALSE)Build the list of real data for an emulated class.Definition TClass.cxx:2112; TClass::LoadClassstatic TClass * LoadClass(const char *requestedname, Bool_t silent)Helper function used by TClass::GetClass().Definition TClass.cxx:5749; TClass::fSharedLibsTString fSharedLibsDefinition TClass.h:227; TClass::GetTypeInfoconst std::type_info * GetTypeInfo() constDefinition TClass.h:496; TClass::GetListOfDataMembersTList * GetListOfDataMembers(Bool_t load=kTRUE)Return list containing the TDataMembers of a class.Definition TClass.cxx:3770; TClass::ENewTypeENewTypeDefinition TClass.h:107; TClass::kRealNew@ kRealNewDefinition TClass.h:107; TClass::Movevoid Move(void *arenaFrom, void *arenaTo) constRegister the fact that an object was moved from the memory location",MatchSource.WIKI,doc/v632/TClass_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/TClass_8cxx_source.html
https://root.cern/doc/v632/TClass_8cxx_source.html:325051,Integrability,wrap,wrapper,325051,"finition TClass.cxx:2112; TClass::LoadClassstatic TClass * LoadClass(const char *requestedname, Bool_t silent)Helper function used by TClass::GetClass().Definition TClass.cxx:5749; TClass::fSharedLibsTString fSharedLibsDefinition TClass.h:227; TClass::GetTypeInfoconst std::type_info * GetTypeInfo() constDefinition TClass.h:496; TClass::GetListOfDataMembersTList * GetListOfDataMembers(Bool_t load=kTRUE)Return list containing the TDataMembers of a class.Definition TClass.cxx:3770; TClass::ENewTypeENewTypeDefinition TClass.h:107; TClass::kRealNew@ kRealNewDefinition TClass.h:107; TClass::Movevoid Move(void *arenaFrom, void *arenaTo) constRegister the fact that an object was moved from the memory location 'arenaFrom' to the memory locatio...Definition TClass.cxx:4327; TClass::GetDeclIdMapstatic DeclIdMap_t * GetDeclIdMap()Definition TClass.cxx:480; TClass::GetDeclFileLineShort_t GetDeclFileLine() constDefinition TClass.h:429; TClass::SetStreamerFuncvoid SetStreamerFunc(ClassStreamerFunc_t strm)Set a wrapper/accessor function around this class custom streamer.Definition TClass.cxx:6922; TClass::GetImplFileNameconst char * GetImplFileName() constDefinition TClass.h:456; TClass::GetListOfRealDataTList * GetListOfRealData() constDefinition TClass.h:453; TClass::SizeInt_t Size() constReturn size of object of this class.Definition TClass.cxx:5704; TClass::SetCurrentStreamerInfovoid SetCurrentStreamerInfo(TVirtualStreamerInfo *info)Set pointer to current TVirtualStreamerInfo.Definition TClass.cxx:5696; TClass::GetDictstatic DictFuncPtr_t GetDict(const char *cname)Return a pointer to the dictionary loading function generated by rootcint.Definition TClass.cxx:3422; TClass::fOffsetStreamerLongptr_t fOffsetStreamerProperties that can only be evaluated at run-time.Definition TClass.h:275; TClass::fSizeofInt_t fSizeofDefinition TClass.h:243; TClass::GetNewArrayROOT::NewArrFunc_t GetNewArray() constReturn the wrapper around new ThisClass[].Definition TClass.cxx:7455; TClass::Streamer",MatchSource.WIKI,doc/v632/TClass_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/TClass_8cxx_source.html
https://root.cern/doc/v632/TClass_8cxx_source.html:325965,Integrability,wrap,wrapper,325965,"() constDefinition TClass.h:429; TClass::SetStreamerFuncvoid SetStreamerFunc(ClassStreamerFunc_t strm)Set a wrapper/accessor function around this class custom streamer.Definition TClass.cxx:6922; TClass::GetImplFileNameconst char * GetImplFileName() constDefinition TClass.h:456; TClass::GetListOfRealDataTList * GetListOfRealData() constDefinition TClass.h:453; TClass::SizeInt_t Size() constReturn size of object of this class.Definition TClass.cxx:5704; TClass::SetCurrentStreamerInfovoid SetCurrentStreamerInfo(TVirtualStreamerInfo *info)Set pointer to current TVirtualStreamerInfo.Definition TClass.cxx:5696; TClass::GetDictstatic DictFuncPtr_t GetDict(const char *cname)Return a pointer to the dictionary loading function generated by rootcint.Definition TClass.cxx:3422; TClass::fOffsetStreamerLongptr_t fOffsetStreamerProperties that can only be evaluated at run-time.Definition TClass.h:275; TClass::fSizeofInt_t fSizeofDefinition TClass.h:243; TClass::GetNewArrayROOT::NewArrFunc_t GetNewArray() constReturn the wrapper around new ThisClass[].Definition TClass.cxx:7455; TClass::StreamerTObjectEmulatedstatic void StreamerTObjectEmulated(const TClass *pThis, void *object, TBuffer &b, const TClass *onfile_class)Case of TObjects when we do not have the library defining the class.Definition TClass.cxx:6823; TClass::fNewROOT::NewFunc_t fNewDefinition TClass.h:235; TClass::kLoading@ kLoadingDefinition TClass.h:332; TClass::kUnloading@ kUnloadingDefinition TClass.h:332; TClass::GetResetAfterMergeROOT::ResetAfterMergeFunc_t GetResetAfterMerge() constReturn the wrapper around Merge.Definition TClass.cxx:7439; TClass::GetClassMethodWithPrototypeTMethod * GetClassMethodWithPrototype(const char *name, const char *proto, Bool_t objectIsConst=kFALSE, ROOT::EFunctionMatchMode mode=ROOT::kConversionMatch)Find the method with a given prototype.Definition TClass.cxx:4527; TClass::CanIgnoreTObjectStreamerBool_t CanIgnoreTObjectStreamer()Definition TClass.h:393; TClass::SetGlobalIsAvoid SetGl",MatchSource.WIKI,doc/v632/TClass_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/TClass_8cxx_source.html
https://root.cern/doc/v632/TClass_8cxx_source.html:326515,Integrability,wrap,wrapper,326515,"fo *info)Set pointer to current TVirtualStreamerInfo.Definition TClass.cxx:5696; TClass::GetDictstatic DictFuncPtr_t GetDict(const char *cname)Return a pointer to the dictionary loading function generated by rootcint.Definition TClass.cxx:3422; TClass::fOffsetStreamerLongptr_t fOffsetStreamerProperties that can only be evaluated at run-time.Definition TClass.h:275; TClass::fSizeofInt_t fSizeofDefinition TClass.h:243; TClass::GetNewArrayROOT::NewArrFunc_t GetNewArray() constReturn the wrapper around new ThisClass[].Definition TClass.cxx:7455; TClass::StreamerTObjectEmulatedstatic void StreamerTObjectEmulated(const TClass *pThis, void *object, TBuffer &b, const TClass *onfile_class)Case of TObjects when we do not have the library defining the class.Definition TClass.cxx:6823; TClass::fNewROOT::NewFunc_t fNewDefinition TClass.h:235; TClass::kLoading@ kLoadingDefinition TClass.h:332; TClass::kUnloading@ kUnloadingDefinition TClass.h:332; TClass::GetResetAfterMergeROOT::ResetAfterMergeFunc_t GetResetAfterMerge() constReturn the wrapper around Merge.Definition TClass.cxx:7439; TClass::GetClassMethodWithPrototypeTMethod * GetClassMethodWithPrototype(const char *name, const char *proto, Bool_t objectIsConst=kFALSE, ROOT::EFunctionMatchMode mode=ROOT::kConversionMatch)Find the method with a given prototype.Definition TClass.cxx:4527; TClass::CanIgnoreTObjectStreamerBool_t CanIgnoreTObjectStreamer()Definition TClass.h:393; TClass::SetGlobalIsAvoid SetGlobalIsA(IsAGlobalFunc_t)This function installs a global IsA function for this class.Definition TClass.cxx:6300; TClass::GetMissingDictionariesForMembersvoid GetMissingDictionariesForMembers(TCollection &result, TCollection &visited, bool recurse)Verify the Data Members.Definition TClass.cxx:3944; TClass::fStreamerInfoTObjArray * fStreamerInfoDefinition TClass.h:198; TClass::GetSchemaRulesconst ROOT::Detail::TSchemaRuleSet * GetSchemaRules() constReturn the set of the schema rules if any.Definition TClass.cxx:1932; TClass::CloneT",MatchSource.WIKI,doc/v632/TClass_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/TClass_8cxx_source.html
https://root.cern/doc/v632/TClass_8cxx_source.html:331005,Integrability,wrap,wrapper,331005,"334; TClass::kExternal@ kExternalDefinition TClass.h:334; TClass::kForeign@ kForeignDefinition TClass.h:334; TClass::kInstrumented@ kInstrumentedDefinition TClass.h:334; TClass::kTObject@ kTObjectDefinition TClass.h:334; TClass::AddRulestatic Bool_t AddRule(const char *rule)Add a schema evolution customization rule.Definition TClass.cxx:1890; TClass::IsTObjectBool_t IsTObject() constReturn kTRUE is the class inherits from TObject.Definition TClass.cxx:5938; TClass::RemoveClassstatic void RemoveClass(TClass *cl)static: Remove a class from the list and map of classesDefinition TClass.cxx:520; TClass::HasLocalHashMemberBool_t HasLocalHashMember() constReturns true if this class has an definition and/or overload of the member function Hash.Definition TClass.cxx:7421; TClass::DeleteArrayvoid DeleteArray(void *ary, Bool_t dtorOnly=kFALSE)Explicitly call operator delete[] for an array.Definition TClass.cxx:5529; TClass::GetConvStreamerFuncClassConvStreamerFunc_t GetConvStreamerFunc() constGet a wrapper/accessor function around this class custom conversion streamer (member function).Definition TClass.cxx:2947; TClass::IsForeignBool_t IsForeign() constReturn kTRUE is the class is Foreign (the class does not have a Streamer method).Definition TClass.cxx:5947; TClass::GetClassInfoClassInfo_t * GetClassInfo() constDefinition TClass.h:433; TClass::fDeleteROOT::DelFunc_t fDeleteDefinition TClass.h:237; TClass::fAllPubDataTViewPubDataMembers * fAllPubDataDefinition TClass.h:209; TClass::fClassInfoClassInfo_t * fClassInfoDefinition TClass.h:222; TClass::GetStreamerInfoTVirtualStreamerInfo * GetStreamerInfo(Int_t version=0, Bool_t isTransient=kFALSE) constreturns a pointer to the TVirtualStreamerInfo object for version If the object does not exist,...Definition TClass.cxx:4599; TClass::HasConsistentHashMemberBool_t HasConsistentHashMember()Return 'true' if we can guarantee that if this class (or any class in this class inheritance hierarch...Definition TClass.h:501; TClass::AdoptStre",MatchSource.WIKI,doc/v632/TClass_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/TClass_8cxx_source.html
https://root.cern/doc/v632/TClass_8cxx_source.html:334012,Integrability,rout,routine,334012,"ideReturn kTRUE if this class inherits from a class with name ""classname"".Definition TClass.cxx:4874; TClass::GetBaseClassOffsetInt_t GetBaseClassOffset(const TClass *toBase, void *address=nullptr, bool isDerivedObject=true)Definition TClass.cxx:2791; TClass::NewObjectArrayObjectPtr NewObjectArray(Long_t nElements, ENewType defConstructor=kClassNew) constReturn a pointer to a newly allocated array of objects of this class.Definition TClass.cxx:5209; TClass::GetCollectionProxyTVirtualCollectionProxy * GetCollectionProxy() constReturn the proxy describing the collection (if any).Definition TClass.cxx:2897; TClass::ResetCachesvoid ResetCaches()To clean out all caches.Definition TClass.cxx:4215; TClass::fVersionUsedstd::atomic< Bool_t > fVersionUsedsaved remember if fOffsetStreamer has been set.Definition TClass.h:262; TClass::ClassPropertyLong_t ClassProperty() constReturn the C++ property of this class, eg.Definition TClass.cxx:2396; TClass::SetStreamerImplvoid SetStreamerImpl()Internal routine to set fStreamerImpl based on the value of fStreamerType.Definition TClass.cxx:6215; TClass::GetSharedLibsconst char * GetSharedLibs()Get the list of shared libraries containing the code for class cls.Definition TClass.cxx:3623; TClass::CalculateStreamerOffsetvoid CalculateStreamerOffset() constCalculate the offset between an object of this class to its base class TObject.Definition TClass.cxx:2183; TClass::GetMissingDictionariesForPairElementsvoid GetMissingDictionariesForPairElements(TCollection &result, TCollection &visited, bool recurse)Definition TClass.cxx:3973; TClass::ReplaceWithvoid ReplaceWith(TClass *newcl) constDefinition TClass.cxx:4142; TClass::RegisterAddressInRepositoryvoid RegisterAddressInRepository(const char *where, void *location, const TClass *what) constDefinition TClass.cxx:290; TClass::PropertyLong_t Property() const overrideReturns the properties of the TClass as a bit field stored as a Long_t value.Definition TClass.cxx:6086; TClass::HasDefaultConstruc",MatchSource.WIKI,doc/v632/TClass_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/TClass_8cxx_source.html
https://root.cern/doc/v632/TClass_8cxx_source.html:335360,Integrability,wrap,wrapper,335360,"set between an object of this class to its base class TObject.Definition TClass.cxx:2183; TClass::GetMissingDictionariesForPairElementsvoid GetMissingDictionariesForPairElements(TCollection &result, TCollection &visited, bool recurse)Definition TClass.cxx:3973; TClass::ReplaceWithvoid ReplaceWith(TClass *newcl) constDefinition TClass.cxx:4142; TClass::RegisterAddressInRepositoryvoid RegisterAddressInRepository(const char *where, void *location, const TClass *what) constDefinition TClass.cxx:290; TClass::PropertyLong_t Property() const overrideReturns the properties of the TClass as a bit field stored as a Long_t value.Definition TClass.cxx:6086; TClass::HasDefaultConstructorBool_t HasDefaultConstructor(Bool_t testio=kFALSE) constReturn true if we have access to a constructor usable for I/O.Definition TClass.cxx:7393; TClass::GetMenuItemsvoid GetMenuItems(TList *listitems)Returns list of methods accessible by context menu.Definition TClass.cxx:3874; TClass::SetNewvoid SetNew(ROOT::NewFunc_t newFunc)Install a new wrapper around 'new'.Definition TClass.cxx:6985; TClass::fIsAMethodstd::atomic< TMethodCall * > fIsAMethodDefinition TClass.h:231; TClass::ReadRulesstatic Int_t ReadRules()Read the class.rules files from the default location:.Definition TClass.cxx:1820; TClass::CanSplitBaseAllowBool_t CanSplitBaseAllow()Pointer to the function implementing streaming for this class.Definition TClass.cxx:2247; TClass::MoveAddressInRepositoryvoid MoveAddressInRepository(const char *where, void *oldadd, void *newadd, const TClass *what) constDefinition TClass.cxx:337; TClass::fStreamerImplstd::atomic< StreamerImpl_t > fStreamerImplDefinition TClass.h:287; TClass::SetContextMenuTitlevoid SetContextMenuTitle(const char *title)Change (i.e. set) the title of the TNamed.Definition TClass.cxx:6269; TClass::SetMemberStreamervoid SetMemberStreamer(const char *name, MemberStreamerFunc_t strm)Install a new member streamer (p will be copied).Definition TClass.cxx:6744; TClass::fPersistentRef",MatchSource.WIKI,doc/v632/TClass_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/TClass_8cxx_source.html
https://root.cern/doc/v632/TClass_8cxx_source.html:338032,Integrability,wrap,wrapper,338032,"opertiesstd::atomic< UChar_t > fRuntimePropertiesDefinition TClass.h:273; TClass::EStateEStateDefinition TClass.h:121; TClass::kInterpreted@ kInterpretedDefinition TClass.h:126; TClass::kHasTClassInit@ kHasTClassInitDefinition TClass.h:127; TClass::kEmulated@ kEmulatedDefinition TClass.h:125; TClass::kNoInfo@ kNoInfoDefinition TClass.h:122; TClass::kLoaded@ kLoadedDefinition TClass.h:130; TClass::kForwardDeclared@ kForwardDeclaredDefinition TClass.h:124; TClass::kNamespaceForMeta@ kNamespaceForMetaDefinition TClass.h:131; TClass::FindConversionStreamerInfoTVirtualStreamerInfo * FindConversionStreamerInfo(const char *onfile_classname, UInt_t checksum) constReturn a Conversion StreamerInfo from the class 'classname' for the layout represented by 'checksum' ...Definition TClass.cxx:7193; TClass::GetBaseClassOffsetRecurseInt_t GetBaseClassOffsetRecurse(const TClass *toBase)Return data member offset to the base class ""cl"".Definition TClass.cxx:2705; TClass::GetDeleteROOT::DelFunc_t GetDelete() constReturn the wrapper around delete ThiObject.Definition TClass.cxx:7463; TClass::LoadClassDefaultstatic TClass * LoadClassDefault(const char *requestedname, Bool_t silent)Helper function used by TClass::GetClass().Definition TClass.cxx:5771; TClass::SetClassSizevoid SetClassSize(Int_t sizof)Definition TClass.h:307; TClass::FindClassOrBaseMethodWithIdTMethod * FindClassOrBaseMethodWithId(DeclId_t faddr)Find a method with decl id in this class or its bases.Definition TClass.cxx:4440; TClass::StreamerExternalstatic void StreamerExternal(const TClass *pThis, void *object, TBuffer &b, const TClass *onfile_class)There is special streamer for the class.Definition TClass.cxx:6788; TClass::fClassPropertyLong_t fClassPropertyProperty See TClass::Property() for details.Definition TClass.h:256; TClass::fContextMenuTitleTString fContextMenuTitleDefinition TClass.h:223; TClass::StreamerTObjectInitializedstatic void StreamerTObjectInitialized(const TClass *pThis, void *object, TBuffer &b, const",MatchSource.WIKI,doc/v632/TClass_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/TClass_8cxx_source.html
https://root.cern/doc/v632/TClass_8cxx_source.html:339561,Integrability,wrap,wrapper,339561,"rExternal(const TClass *pThis, void *object, TBuffer &b, const TClass *onfile_class)There is special streamer for the class.Definition TClass.cxx:6788; TClass::fClassPropertyLong_t fClassPropertyProperty See TClass::Property() for details.Definition TClass.h:256; TClass::fContextMenuTitleTString fContextMenuTitleDefinition TClass.h:223; TClass::StreamerTObjectInitializedstatic void StreamerTObjectInitialized(const TClass *pThis, void *object, TBuffer &b, const TClass *onfile_class)Case of TObjects when fIsOffsetStreamerSet is known to have been set.Definition TClass.cxx:6814; TClass::ConvStreamerInstrumentedstatic void ConvStreamerInstrumented(const TClass *pThis, void *object, TBuffer &b, const TClass *onfile_class)Case of instrumented class with a library.Definition TClass.cxx:6845; TClass::fCanLoadClassInfostd::atomic< Bool_t > fCanLoadClassInfoWhether info was loaded from a root pcm.Definition TClass.h:260; TClass::SetConvStreamerFuncvoid SetConvStreamerFunc(ClassConvStreamerFunc_t strm)Set a wrapper/accessor function around this class custom conversion streamer.Definition TClass.cxx:6945; TClass::FindStreamerInfoTVirtualStreamerInfo * FindStreamerInfo(TObjArray *arr, UInt_t checksum) constFind the TVirtualStreamerInfo in the StreamerInfos corresponding to checksum.Definition TClass.cxx:7066; TClass::GetMissingDictionariesvoid GetMissingDictionaries(THashTable &result, bool recurse=false)Get the classes that have a missing dictionary starting from this one.Definition TClass.cxx:4087; TClass::MakeCustomMenuListvoid MakeCustomMenuList()Makes a customizable version of the popup menu list, i.e.Definition TClass.cxx:4283; TClass::FindStreamerInfoAbstractEmulatedTVirtualStreamerInfo * FindStreamerInfoAbstractEmulated(UInt_t checksum) constFor the case where the requestor class is emulated and this class is abstract, returns a pointer to t...Definition TClass.cxx:4772; TClass::GetMethodAnyTMethod * GetMethodAny(const char *method)Return pointer to method without looking",MatchSource.WIKI,doc/v632/TClass_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/TClass_8cxx_source.html
https://root.cern/doc/v632/TClass_8cxx_source.html:340791,Integrability,wrap,wrapper,340791," the TVirtualStreamerInfo in the StreamerInfos corresponding to checksum.Definition TClass.cxx:7066; TClass::GetMissingDictionariesvoid GetMissingDictionaries(THashTable &result, bool recurse=false)Get the classes that have a missing dictionary starting from this one.Definition TClass.cxx:4087; TClass::MakeCustomMenuListvoid MakeCustomMenuList()Makes a customizable version of the popup menu list, i.e.Definition TClass.cxx:4283; TClass::FindStreamerInfoAbstractEmulatedTVirtualStreamerInfo * FindStreamerInfoAbstractEmulated(UInt_t checksum) constFor the case where the requestor class is emulated and this class is abstract, returns a pointer to t...Definition TClass.cxx:4772; TClass::GetMethodAnyTMethod * GetMethodAny(const char *method)Return pointer to method without looking at parameters.Definition TClass.cxx:4374; TClass::GetIsAProxyTVirtualIsAProxy * GetIsAProxy() constReturn the proxy implementing the IsA functionality.Definition TClass.cxx:2955; TClass::GetMergeROOT::MergeFunc_t GetMerge() constReturn the wrapper around Merge.Definition TClass.cxx:7431; TClass::fResetAfterMergeROOT::ResetAfterMergeFunc_t fResetAfterMergeDefinition TClass.h:234; TClass::IsFolderBool_t IsFolder() const overrideReturns kTRUE in case object contains browsable objects (like containers or lists of other objects).Definition TClass.h:517; TClass::fInstanceCountUInt_t fInstanceCountDefinition TClass.h:217; TClass::fHasRootPcmInfostd::atomic< Bool_t > fHasRootPcmInfoC++ Property of the class (is abstract, has virtual table, etc.)Definition TClass.h:259; TClass::GetActualClassTClass * GetActualClass(const void *object) constReturn a pointer to the real class of the object.Definition TClass.cxx:2607; TClass::fDestructorROOT::DesFunc_t fDestructorDefinition TClass.h:239; TClass::GetDeclFileNameconst char * GetDeclFileName() constReturn name of the file containing the declaration of this class.Definition TClass.cxx:3463; TClass::NewObjectObjectPtr NewObject(ENewType defConstructor=kClassNew, ",MatchSource.WIKI,doc/v632/TClass_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/TClass_8cxx_source.html
https://root.cern/doc/v632/TClass_8cxx_source.html:342058,Integrability,wrap,wrapper,342058,"owsable objects (like containers or lists of other objects).Definition TClass.h:517; TClass::fInstanceCountUInt_t fInstanceCountDefinition TClass.h:217; TClass::fHasRootPcmInfostd::atomic< Bool_t > fHasRootPcmInfoC++ Property of the class (is abstract, has virtual table, etc.)Definition TClass.h:259; TClass::GetActualClassTClass * GetActualClass(const void *object) constReturn a pointer to the real class of the object.Definition TClass.cxx:2607; TClass::fDestructorROOT::DesFunc_t fDestructorDefinition TClass.h:239; TClass::GetDeclFileNameconst char * GetDeclFileName() constReturn name of the file containing the declaration of this class.Definition TClass.cxx:3463; TClass::NewObjectObjectPtr NewObject(ENewType defConstructor=kClassNew, Bool_t quiet=kFALSE) constDefinition TClass.cxx:4992; TClass::GetRealDataTRealData * GetRealData(const char *name) constReturn pointer to TRealData element with name ""name"".Definition TClass.cxx:3503; TClass::SetDeleteArrayvoid SetDeleteArray(ROOT::DelArrFunc_t deleteArrayFunc)Install a new wrapper around 'delete []'.Definition TClass.cxx:7009; TClass::fHasCustomStreamerMemberBool_t fHasCustomStreamerMemberThe class has a Streamer method and it is implemented by the user or an older (not StreamerInfo based...Definition TClass.h:253; TClass::GetFunctionTemplateTFunctionTemplate * GetFunctionTemplate(const char *name)Definition TClass.cxx:3607; TClass::ResetClassInfovoid ResetClassInfo()Make sure that the current ClassInfo is up to date.Definition TClass.cxx:4180; TClass::fNewArrayROOT::NewArrFunc_t fNewArrayDefinition TClass.h:236; TClass::ReadBufferInt_t ReadBuffer(TBuffer &b, void *pointer, Int_t version, UInt_t start, UInt_t count)Function called by the Streamer functions to deserialize information from buffer b into object at p.Definition TClass.cxx:6758; TClass::GetMissingDictionariesWithRecursionCheckvoid GetMissingDictionariesWithRecursionCheck(TCollection &result, TCollection &visited, bool recurse)From the second level of recur",MatchSource.WIKI,doc/v632/TClass_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/TClass_8cxx_source.html
https://root.cern/doc/v632/TClass_8cxx_source.html:347909,Integrability,interface,interface,347909,"ypeBasic data type descriptor (datatype information is obtained from CINT).Definition TDataType.h:44; TDataType::GetTypeInt_t GetType() constDefinition TDataType.h:68; TDataType::PropertyLong_t Property() const overrideGet property description word. For meaning of bits see EProperty.Definition TDataType.cxx:291; TDataType::AsStringconst char * AsString(void *buf) constReturn string containing value in buffer formatted according to the basic data type.Definition TDataType.cxx:235; TDataType::GetTypeNameTString GetTypeName()Get basic type of typedef, e,g.: ""class TDirectory*"" -> ""TDirectory"".Definition TDataType.cxx:149; TDataType::GetDataTypestatic TDataType * GetDataType(EDataType type)Given a EDataType type, get the TDataType* that represents it.Definition TDataType.cxx:451; TDatime::GetDateTimestatic void GetDateTime(UInt_t datetime, Int_t &date, Int_t &time)Static function that returns the date and time.Definition TDatime.cxx:431; TDictionaryThis class defines an abstract interface that must be implemented by all classes that contain diction...Definition TDictionary.h:168; TDictionary::EMemberSelectionEMemberSelectionKinds of members to include in lists.Definition TDictionary.h:216; TDictionary::EMemberSelection::kNoUsingDecls@ kNoUsingDecls; TDictionary::EMemberSelection::kOnlyUsingDecls@ kOnlyUsingDecls; TDictionary::DeclId_tconst void * DeclId_tDefinition TDictionary.h:224; TDumpMembersDefinition TClass.cxx:554; TDumpMembers::Inspectvoid Inspect(TClass *cl, const char *parent, const char *name, const void *addr, Bool_t isTransient) overridePrint value of member mname.Definition TClass.cxx:574; TDumpMembers::TDumpMembersTDumpMembers(bool noAddr)Definition TClass.cxx:557; TDumpMembers::fNoAddrbool fNoAddrDefinition TClass.cxx:555; TEnum::GetEnumstatic TEnum * GetEnum(const std::type_info &ti, ESearchAction sa=kALoadAndInterpLookup)Definition TEnum.cxx:175; TEnum::kNone@ kNoneDefinition TEnum.h:48; TExMapThis class stores a (key,value) pair using an external hash",MatchSource.WIKI,doc/v632/TClass_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/TClass_8cxx_source.html
https://root.cern/doc/v632/TClass_8cxx_source.html:360809,Integrability,message,message,360809,"kWrapper around a TObject so it can be stored in a TList.Definition TList.h:123; TObjLink::GetObjectTObject * GetObject() constDefinition TList.h:145; TObjLink::NextTObjLink * Next()Definition TList.h:151; TObjStringCollectable string class.Definition TObjString.h:28; TObjectMother of all ROOT objects.Definition TObject.h:41; TObject::SetObjectStatstatic void SetObjectStat(Bool_t stat)Turn on/off tracking of objects in the TObjectTable.Definition TObject.cxx:1068; TObject::GetNamevirtual const char * GetName() constReturns name of object.Definition TObject.cxx:439; TObject::Browsevirtual void Browse(TBrowser *b)Browse object. May be overridden for another default action.Definition TObject.cxx:198; TObject::TestBitR__ALWAYS_INLINE Bool_t TestBit(UInt_t f) constDefinition TObject.h:199; TObject::Streamervirtual void Streamer(TBuffer &)Stream an object of class TObject.Definition TObject.cxx:888; TObject::Warningvirtual void Warning(const char *method, const char *msgfmt,...) constIssue warning message.Definition TObject.cxx:973; TObject::FindObjectvirtual TObject * FindObject(const char *name) constMust be redefined in derived classes.Definition TObject.cxx:403; TObject::Classstatic TClass * Class(); TObject::IsZombieR__ALWAYS_INLINE Bool_t IsZombie() constDefinition TObject.h:153; TObject::SetBitvoid SetBit(UInt_t f, Bool_t set)Set or unset the user status bits as specified in f.Definition TObject.cxx:780; TObject::GetObjectStatstatic Bool_t GetObjectStat()Get status of object stat flag.Definition TObject.cxx:1061; TObject::Errorvirtual void Error(const char *method, const char *msgfmt,...) constIssue error message.Definition TObject.cxx:987; TObject::Fatalvirtual void Fatal(const char *method, const char *msgfmt,...) constIssue fatal error message.Definition TObject.cxx:1015; TObject::SetUniqueIDvirtual void SetUniqueID(UInt_t uid)Set the unique object id.Definition TObject.cxx:791; TObject::IsAvirtual TClass * IsA() constDefinition TObject.h:243; TObject::MakeZombie",MatchSource.WIKI,doc/v632/TClass_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/TClass_8cxx_source.html
https://root.cern/doc/v632/TClass_8cxx_source.html:361436,Integrability,message,message,361436,"ject. May be overridden for another default action.Definition TObject.cxx:198; TObject::TestBitR__ALWAYS_INLINE Bool_t TestBit(UInt_t f) constDefinition TObject.h:199; TObject::Streamervirtual void Streamer(TBuffer &)Stream an object of class TObject.Definition TObject.cxx:888; TObject::Warningvirtual void Warning(const char *method, const char *msgfmt,...) constIssue warning message.Definition TObject.cxx:973; TObject::FindObjectvirtual TObject * FindObject(const char *name) constMust be redefined in derived classes.Definition TObject.cxx:403; TObject::Classstatic TClass * Class(); TObject::IsZombieR__ALWAYS_INLINE Bool_t IsZombie() constDefinition TObject.h:153; TObject::SetBitvoid SetBit(UInt_t f, Bool_t set)Set or unset the user status bits as specified in f.Definition TObject.cxx:780; TObject::GetObjectStatstatic Bool_t GetObjectStat()Get status of object stat flag.Definition TObject.cxx:1061; TObject::Errorvirtual void Error(const char *method, const char *msgfmt,...) constIssue error message.Definition TObject.cxx:987; TObject::Fatalvirtual void Fatal(const char *method, const char *msgfmt,...) constIssue fatal error message.Definition TObject.cxx:1015; TObject::SetUniqueIDvirtual void SetUniqueID(UInt_t uid)Set the unique object id.Definition TObject.cxx:791; TObject::IsAvirtual TClass * IsA() constDefinition TObject.h:243; TObject::MakeZombievoid MakeZombie()Definition TObject.h:53; TObject::ResetBitvoid ResetBit(UInt_t f)Definition TObject.h:198; TObject::Infovirtual void Info(const char *method, const char *msgfmt,...) constIssue info message.Definition TObject.cxx:961; TPairClass used by TMap to store (key,value) pairs.Definition TMap.h:102; TProtoClassPersistent version of a TClass.Definition TProtoClass.h:38; TROOT::GetEtcDirstatic const TString & GetEtcDir()Get the sysconfig directory in the installation. Static utility function.Definition TROOT.cxx:3052; TRealDataThe TRealData class manages the effective list of all data members for a given class.Defi",MatchSource.WIKI,doc/v632/TClass_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/TClass_8cxx_source.html
https://root.cern/doc/v632/TClass_8cxx_source.html:361572,Integrability,message,message,361572," f) constDefinition TObject.h:199; TObject::Streamervirtual void Streamer(TBuffer &)Stream an object of class TObject.Definition TObject.cxx:888; TObject::Warningvirtual void Warning(const char *method, const char *msgfmt,...) constIssue warning message.Definition TObject.cxx:973; TObject::FindObjectvirtual TObject * FindObject(const char *name) constMust be redefined in derived classes.Definition TObject.cxx:403; TObject::Classstatic TClass * Class(); TObject::IsZombieR__ALWAYS_INLINE Bool_t IsZombie() constDefinition TObject.h:153; TObject::SetBitvoid SetBit(UInt_t f, Bool_t set)Set or unset the user status bits as specified in f.Definition TObject.cxx:780; TObject::GetObjectStatstatic Bool_t GetObjectStat()Get status of object stat flag.Definition TObject.cxx:1061; TObject::Errorvirtual void Error(const char *method, const char *msgfmt,...) constIssue error message.Definition TObject.cxx:987; TObject::Fatalvirtual void Fatal(const char *method, const char *msgfmt,...) constIssue fatal error message.Definition TObject.cxx:1015; TObject::SetUniqueIDvirtual void SetUniqueID(UInt_t uid)Set the unique object id.Definition TObject.cxx:791; TObject::IsAvirtual TClass * IsA() constDefinition TObject.h:243; TObject::MakeZombievoid MakeZombie()Definition TObject.h:53; TObject::ResetBitvoid ResetBit(UInt_t f)Definition TObject.h:198; TObject::Infovirtual void Info(const char *method, const char *msgfmt,...) constIssue info message.Definition TObject.cxx:961; TPairClass used by TMap to store (key,value) pairs.Definition TMap.h:102; TProtoClassPersistent version of a TClass.Definition TProtoClass.h:38; TROOT::GetEtcDirstatic const TString & GetEtcDir()Get the sysconfig directory in the installation. Static utility function.Definition TROOT.cxx:3052; TRealDataThe TRealData class manages the effective list of all data members for a given class.Definition TRealData.h:30; TRealData::GetNameconst char * GetName() const overrideReturns name of object.Definition TRealData.h:52; TReal",MatchSource.WIKI,doc/v632/TClass_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/TClass_8cxx_source.html
https://root.cern/doc/v632/TClass_8cxx_source.html:362002,Integrability,message,message,362002,"atic TClass * Class(); TObject::IsZombieR__ALWAYS_INLINE Bool_t IsZombie() constDefinition TObject.h:153; TObject::SetBitvoid SetBit(UInt_t f, Bool_t set)Set or unset the user status bits as specified in f.Definition TObject.cxx:780; TObject::GetObjectStatstatic Bool_t GetObjectStat()Get status of object stat flag.Definition TObject.cxx:1061; TObject::Errorvirtual void Error(const char *method, const char *msgfmt,...) constIssue error message.Definition TObject.cxx:987; TObject::Fatalvirtual void Fatal(const char *method, const char *msgfmt,...) constIssue fatal error message.Definition TObject.cxx:1015; TObject::SetUniqueIDvirtual void SetUniqueID(UInt_t uid)Set the unique object id.Definition TObject.cxx:791; TObject::IsAvirtual TClass * IsA() constDefinition TObject.h:243; TObject::MakeZombievoid MakeZombie()Definition TObject.h:53; TObject::ResetBitvoid ResetBit(UInt_t f)Definition TObject.h:198; TObject::Infovirtual void Info(const char *method, const char *msgfmt,...) constIssue info message.Definition TObject.cxx:961; TPairClass used by TMap to store (key,value) pairs.Definition TMap.h:102; TProtoClassPersistent version of a TClass.Definition TProtoClass.h:38; TROOT::GetEtcDirstatic const TString & GetEtcDir()Get the sysconfig directory in the installation. Static utility function.Definition TROOT.cxx:3052; TRealDataThe TRealData class manages the effective list of all data members for a given class.Definition TRealData.h:30; TRealData::GetNameconst char * GetName() const overrideReturns name of object.Definition TRealData.h:52; TRealData::AdoptStreamervoid AdoptStreamer(TMemberStreamer *p)Definition TRealData.cxx:67; TRealData::kTransient@ kTransientDefinition TRealData.h:44; TRealData::GetThisOffsetLong_t GetThisOffset() constDefinition TRealData.h:55; TRealData::SetIsObjectvoid SetIsObject(Bool_t isObject)Definition TRealData.h:57; TRefArray::Classstatic TClass * Class(); TRef::Classstatic TClass * Class(); TStreamerBaseDefinition TStreamerElement.h:150; T",MatchSource.WIKI,doc/v632/TClass_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/TClass_8cxx_source.html
https://root.cern/doc/v632/TClass_8cxx_source.html:365872,Integrability,interface,interface,365872,"ool_t IsNull() constDefinition TString.h:414; TString::HashUInt_t Hash(ECaseCompare cmp=kExact) constReturn hash value.Definition TString.cxx:677; TString::RemoveTString & Remove(Ssiz_t pos)Definition TString.h:685; TString::Formatstatic TString Format(const char *fmt,...)Static method which formats a string using a printf style format descriptor and return a TString.Definition TString.cxx:2378; TString::Formvoid Form(const char *fmt,...)Formats a string using a printf style format descriptor.Definition TString.cxx:2356; TString::Classstatic TClass * Class(); TString::ContainsBool_t Contains(const char *pat, ECaseCompare cmp=kExact) constDefinition TString.h:632; TString::IndexSsiz_t Index(const char *pat, Ssiz_t i=0, ECaseCompare cmp=kExact) constDefinition TString.h:651; TSystem::PrependPathNamevirtual const char * PrependPathName(const char *dir, TString &name)Concatenate a directory and a file name.Definition TSystem.cxx:1081; TViewPubDataMembersView implementing the TList interface and giving access all the TDictionary describing public data me...Definition TViewPubDataMembers.h:28; TViewPubDataMembers::Loadvoid Load()Load all the DataMembers known to the interpreter for the scope 'fClass' and all its bases classes.Definition TViewPubDataMembers.cxx:298; TViewPubDataMembers::Deletevoid Delete(Option_t *option="""") overrideDelete is not allowed in this class.Definition TViewPubDataMembers.cxx:78; TViewPubFunctionsView implementing the TList interface and giving access all the TFunction describing public methods i...Definition TViewPubFunctions.h:28; TViewPubFunctions::Loadvoid Load()Load all the functions known to the interpreter for the scope 'fClass' and all its bases classes.Definition TViewPubFunctions.cxx:298; TViewPubFunctions::Deletevoid Delete(Option_t *option="""") overrideDelete is not allowed in this class.Definition TViewPubFunctions.cxx:78; TVirtualCollectionProxy::TPushPopRAII helper class that ensures that PushProxy() / PopProxy() are called when ente",MatchSource.WIKI,doc/v632/TClass_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/TClass_8cxx_source.html
https://root.cern/doc/v632/TClass_8cxx_source.html:366348,Integrability,interface,interface,366348,"e format descriptor.Definition TString.cxx:2356; TString::Classstatic TClass * Class(); TString::ContainsBool_t Contains(const char *pat, ECaseCompare cmp=kExact) constDefinition TString.h:632; TString::IndexSsiz_t Index(const char *pat, Ssiz_t i=0, ECaseCompare cmp=kExact) constDefinition TString.h:651; TSystem::PrependPathNamevirtual const char * PrependPathName(const char *dir, TString &name)Concatenate a directory and a file name.Definition TSystem.cxx:1081; TViewPubDataMembersView implementing the TList interface and giving access all the TDictionary describing public data me...Definition TViewPubDataMembers.h:28; TViewPubDataMembers::Loadvoid Load()Load all the DataMembers known to the interpreter for the scope 'fClass' and all its bases classes.Definition TViewPubDataMembers.cxx:298; TViewPubDataMembers::Deletevoid Delete(Option_t *option="""") overrideDelete is not allowed in this class.Definition TViewPubDataMembers.cxx:78; TViewPubFunctionsView implementing the TList interface and giving access all the TFunction describing public methods i...Definition TViewPubFunctions.h:28; TViewPubFunctions::Loadvoid Load()Load all the functions known to the interpreter for the scope 'fClass' and all its bases classes.Definition TViewPubFunctions.cxx:298; TViewPubFunctions::Deletevoid Delete(Option_t *option="""") overrideDelete is not allowed in this class.Definition TViewPubFunctions.cxx:78; TVirtualCollectionProxy::TPushPopRAII helper class that ensures that PushProxy() / PopProxy() are called when entering / leaving a C++...Definition TVirtualCollectionProxy.h:75; TVirtualCollectionProxyDefines a common interface to inspect/change the contents of an object that represents a collection.Definition TVirtualCollectionProxy.h:52; TVirtualCollectionProxy::GetPropertiesvirtual Int_t GetProperties() constReturn miscallenous properties of the proxy (see TVirtualCollectionProxy::EProperty)Definition TVirtualCollectionProxy.h:108; TVirtualCollectionProxy::Sizeofvirtual UInt_t Sizeo",MatchSource.WIKI,doc/v632/TClass_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/TClass_8cxx_source.html
https://root.cern/doc/v632/TClass_8cxx_source.html:366985,Integrability,interface,interface,366985,"s::Loadvoid Load()Load all the DataMembers known to the interpreter for the scope 'fClass' and all its bases classes.Definition TViewPubDataMembers.cxx:298; TViewPubDataMembers::Deletevoid Delete(Option_t *option="""") overrideDelete is not allowed in this class.Definition TViewPubDataMembers.cxx:78; TViewPubFunctionsView implementing the TList interface and giving access all the TFunction describing public methods i...Definition TViewPubFunctions.h:28; TViewPubFunctions::Loadvoid Load()Load all the functions known to the interpreter for the scope 'fClass' and all its bases classes.Definition TViewPubFunctions.cxx:298; TViewPubFunctions::Deletevoid Delete(Option_t *option="""") overrideDelete is not allowed in this class.Definition TViewPubFunctions.cxx:78; TVirtualCollectionProxy::TPushPopRAII helper class that ensures that PushProxy() / PopProxy() are called when entering / leaving a C++...Definition TVirtualCollectionProxy.h:75; TVirtualCollectionProxyDefines a common interface to inspect/change the contents of an object that represents a collection.Definition TVirtualCollectionProxy.h:52; TVirtualCollectionProxy::GetPropertiesvirtual Int_t GetProperties() constReturn miscallenous properties of the proxy (see TVirtualCollectionProxy::EProperty)Definition TVirtualCollectionProxy.h:108; TVirtualCollectionProxy::Sizeofvirtual UInt_t Sizeof() const =0Return the sizeof() of the collection object.; TVirtualCollectionProxy::NewObjectArrayvirtual TClass::ObjectPtr NewObjectArray(Int_t nElements) constConstruct an array of nElements container objects and return the base address of the array.Definition TVirtualCollectionProxy.h:133; TVirtualCollectionProxy::Destructorvirtual void Destructor(void *p, Bool_t dtorOnly=kFALSE) constExecute the container destructor.Definition TVirtualCollectionProxy.h:144; TVirtualCollectionProxy::kIsEmulated@ kIsEmulatedDefinition TVirtualCollectionProxy.h:67; TVirtualCollectionProxy::DeleteArrayvirtual void DeleteArray(void *p, Bool_t dtorOnly=kFA",MatchSource.WIKI,doc/v632/TClass_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/TClass_8cxx_source.html
https://root.cern/doc/v632/TClass_8cxx_source.html:369292,Integrability,interface,interface,369292,"TClass representing the value type...; TVirtualCollectionProxy::NewObjectvirtual TClass::ObjectPtr NewObject() constConstruct a new container object and return its address.Definition TVirtualCollectionProxy.h:115; TVirtualCollectionProxy::Atvirtual void * At(UInt_t idx)=0Return the address of the value at index idx; TVirtualCollectionProxy::Sizevirtual UInt_t Size() const =0Return the current number of elements in the container.; TVirtualCollectionProxy::Generatevirtual TVirtualCollectionProxy * Generate() const =0Returns a clean object of the actual class that derives from TVirtualCollectionProxy.; TVirtualCollectionProxy::Resetvirtual Bool_t Reset()Reset the information gathered from StreamerInfos and value's TClass.Definition TVirtualCollectionProxy.h:95; TVirtualCollectionProxy::HasPointersvirtual Bool_t HasPointers() const =0Return true if the content is of type 'pointer to'.; TVirtualIsAProxyDefinition TVirtualIsAProxy.h:27; TVirtualIsAProxy::SetClassvirtual void SetClass(TClass *cl)=0; TVirtualMutexThis class implements a mutex interface.Definition TVirtualMutex.h:32; TVirtualPad::TContextsmall helper class to store/restore gPad context in TPad methodsDefinition TVirtualPad.h:61; TVirtualPad::TContext::GetSavedauto GetSaved() constDefinition TVirtualPad.h:69; TVirtualPadTVirtualPad is an abstract base class for the Pad and Canvas classes.Definition TVirtualPad.h:51; TVirtualPad::cdvirtual TVirtualPad * cd(Int_t subpadnumber=0)=0; TVirtualPad::DrawClassObjectvirtual void DrawClassObject(const TObject *obj, Option_t *option="""")=0; TVirtualRefProxyDefinition TVirtualRefProxy.h:81; TVirtualRefProxy::Releasevirtual void Release()=0; TVirtualRefProxy::SetClassvirtual void SetClass(TClass *classptr)=0; TVirtualRefProxy::Clonevirtual TVirtualRefProxy * Clone() const =0; TVirtualStreamerInfoAbstract Interface class describing Streamer information for one class.Definition TVirtualStreamerInfo.h:44; TVirtualStreamerInfo::GenerateInfoForPairvirtual TVirtualStreamerInfo *",MatchSource.WIKI,doc/v632/TClass_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/TClass_8cxx_source.html
https://root.cern/doc/v632/TClass_8cxx_source.html:74132,Modifiability,inherit,inherited,74132,"SchemaRuleSet* TClass::GetSchemaRules() const; 1933{; 1934 return fSchemaRules;; 1935}; 1936 ; 1937////////////////////////////////////////////////////////////////////////////////; 1938/// Return the set of the schema rules if any.; 1939/// If create is true, create an empty set; 1940 ; 1941ROOT::Detail::TSchemaRuleSet* TClass::GetSchemaRules(Bool_t create); 1942{; 1943 if (create && fSchemaRules == nullptr) {; 1944 fSchemaRules = new ROOT::Detail::TSchemaRuleSet();; 1945 fSchemaRules->SetClass( this );; 1946 }; 1947 return fSchemaRules;; 1948}; 1949 ; 1950////////////////////////////////////////////////////////////////////////////////; 1951 ; 1952void TClass::AddImplFile(const char* filename, int line) {; 1953 // Currently reset the implementation file and line.; 1954 // In the close future, it will actually add this file and line; 1955 // to a ""list"" of implementation files.; 1956 ; 1957 fImplFileName = filename;; 1958 fImplFileLine = line;; 1959}; 1960 ; 1961////////////////////////////////////////////////////////////////////////////////; 1962/// Browse external object inherited from TObject.; 1963/// It passes through inheritance tree and calls TBrowser::Add; 1964/// in appropriate cases. Static function.; 1965 ; 1966Int_t TClass::AutoBrowse(TObject *obj, TBrowser *b); 1967{; 1968 if (!obj) return 0;; 1969 ; 1970 TAutoInspector insp(b);; 1971 obj->ShowMembers(insp);; 1972 return insp.fCount;; 1973}; 1974 ; 1975////////////////////////////////////////////////////////////////////////////////; 1976/// Browse objects of of the class described by this TClass object.; 1977 ; 1978Int_t TClass::Browse(void *obj, TBrowser *b) const; 1979{; 1980 if (!obj) return 0;; 1981 ; 1982 TClass *actual = GetActualClass(obj);; 1983 if (IsTObject()) {; 1984 // Call TObject::Browse.; 1985 ; 1986 if (!fIsOffsetStreamerSet) {; 1987 CalculateStreamerOffset();; 1988 }; 1989 TObject* realTObject = (TObject*)((size_t)obj + fOffsetStreamer);; 1990 realTObject->Browse(b);; 1991 return 1;; 1992",MatchSource.WIKI,doc/v632/TClass_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/TClass_8cxx_source.html
https://root.cern/doc/v632/TClass_8cxx_source.html:74183,Modifiability,inherit,inheritance,74183,"//////////////////; 1938/// Return the set of the schema rules if any.; 1939/// If create is true, create an empty set; 1940 ; 1941ROOT::Detail::TSchemaRuleSet* TClass::GetSchemaRules(Bool_t create); 1942{; 1943 if (create && fSchemaRules == nullptr) {; 1944 fSchemaRules = new ROOT::Detail::TSchemaRuleSet();; 1945 fSchemaRules->SetClass( this );; 1946 }; 1947 return fSchemaRules;; 1948}; 1949 ; 1950////////////////////////////////////////////////////////////////////////////////; 1951 ; 1952void TClass::AddImplFile(const char* filename, int line) {; 1953 // Currently reset the implementation file and line.; 1954 // In the close future, it will actually add this file and line; 1955 // to a ""list"" of implementation files.; 1956 ; 1957 fImplFileName = filename;; 1958 fImplFileLine = line;; 1959}; 1960 ; 1961////////////////////////////////////////////////////////////////////////////////; 1962/// Browse external object inherited from TObject.; 1963/// It passes through inheritance tree and calls TBrowser::Add; 1964/// in appropriate cases. Static function.; 1965 ; 1966Int_t TClass::AutoBrowse(TObject *obj, TBrowser *b); 1967{; 1968 if (!obj) return 0;; 1969 ; 1970 TAutoInspector insp(b);; 1971 obj->ShowMembers(insp);; 1972 return insp.fCount;; 1973}; 1974 ; 1975////////////////////////////////////////////////////////////////////////////////; 1976/// Browse objects of of the class described by this TClass object.; 1977 ; 1978Int_t TClass::Browse(void *obj, TBrowser *b) const; 1979{; 1980 if (!obj) return 0;; 1981 ; 1982 TClass *actual = GetActualClass(obj);; 1983 if (IsTObject()) {; 1984 // Call TObject::Browse.; 1985 ; 1986 if (!fIsOffsetStreamerSet) {; 1987 CalculateStreamerOffset();; 1988 }; 1989 TObject* realTObject = (TObject*)((size_t)obj + fOffsetStreamer);; 1990 realTObject->Browse(b);; 1991 return 1;; 1992 } else if (actual != this) {; 1993 return actual->Browse(obj, b);; 1994 } else if (GetCollectionProxy()) {; 1995 ; 1996 // do something useful.; 1997 ; 1998 } e",MatchSource.WIKI,doc/v632/TClass_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/TClass_8cxx_source.html
https://root.cern/doc/v632/TClass_8cxx_source.html:86817,Modifiability,inherit,inheritance,86817,"72 TVirtualStreamerInfo *sinfo = ((TClass *)this)->GetCurrentStreamerInfo();; 2273 if (sinfo==nullptr) sinfo = GetStreamerInfo();; 2274 TIter next(sinfo->GetElements());; 2275 TStreamerElement *element;; 2276 while ((element = (TStreamerElement*)next())) {; 2277 if (element->IsA() == TStreamerBase::Class()) {; 2278 TClass *clbase = element->GetClassPointer();; 2279 if (!clbase) {; 2280 // If there is a missing base class, we can't split the immediate; 2281 // derived class.; 2282 fCanSplit = 0;; 2283 return kFALSE;; 2284 } else if (!clbase->CanSplitBaseAllow()) {; 2285 fCanSplit = 2;; 2286 return kFALSE;; 2287 }; 2288 }; 2289 }; 2290 }; 2291 ; 2292 // If we don't have data member info there is no more information; 2293 // we can find out.; 2294 if (!HasDataMemberInfo()) return kTRUE;; 2295 ; 2296 TObjLink *lnk = GetListOfBases() ? fBase.load()->FirstLink() : nullptr;; 2297 ; 2298 // Look at inheritance tree; 2299 while (lnk) {; 2300 TBaseClass *base = (TBaseClass*) lnk->GetObject();; 2301 TClass *c = base->GetClassPointer();; 2302 if(!c) {; 2303 // If there is a missing base class, we can't split the immediate; 2304 // derived class.; 2305 fCanSplit = 0;; 2306 return kFALSE;; 2307 } else if (!c->CanSplitBaseAllow()) {; 2308 fCanSplit = 2;; 2309 return kFALSE;; 2310 }; 2311 lnk = lnk->Next();; 2312 }; 2313 return kTRUE;; 2314}; 2315 ; 2316////////////////////////////////////////////////////////////////////////////////; 2317/// Return true if the data member of this TClass can be saved separately.; 2318 ; 2319Bool_t TClass::CanSplit() const; 2320{; 2321 // Note: add the possibility to set it for the class and the derived class.; 2322 // save the info in TVirtualStreamerInfo; 2323 // deal with the info in MakeProject; 2324 if (fCanSplit >= 0) {; 2325 // The user explicitly set the value; 2326 return (fCanSplit & 0x1) == 1;; 2327 }; 2328 ; 2329 R__LOCKGUARD(gInterpreterMutex);; 2330 TClass *This = const_cast<TClass*>(this);; 2331 ; 2332 if (this == TObject::Class()) { T",MatchSource.WIKI,doc/v632/TClass_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/TClass_8cxx_source.html
https://root.cern/doc/v632/TClass_8cxx_source.html:93343,Modifiability,inherit,inheritance,93343,"nd we will not be; 2454 // able to properly copy the collection proxy; 2455 if (fCollectionProxy && !copy->IsZombie()) {; 2456 copy->CopyCollectionProxy(*fCollectionProxy);; 2457 }; 2458 copy->SetClassSize(fSizeof);; 2459 if (fRefProxy) {; 2460 copy->AdoptReferenceProxy( fRefProxy->Clone() );; 2461 }; 2462 TClass::AddClass(const_cast<TClass*>(this));; 2463 return copy;; 2464}; 2465 ; 2466////////////////////////////////////////////////////////////////////////////////; 2467/// Replaces the collection proxy for this class. The provided object is cloned; 2468/// and the copy is then owned by `TClass`.; 2469 ; 2470void TClass::CopyCollectionProxy(const TVirtualCollectionProxy &orig); 2471{; 2472// // This code was used too quickly test the STL Emulation layer; 2473// Int_t k = TClassEdit::IsSTLCont(GetName());; 2474// if (k==1||k==-1) return;; 2475 ; 2476 delete fCollectionProxy;; 2477 fCollectionProxy = orig.Generate();; 2478}; 2479 ; 2480////////////////////////////////////////////////////////////////////////////////; 2481/// Draw detailed class inheritance structure.; 2482/// If a class B inherits from a class A, the description of B is drawn; 2483/// on the right side of the description of A.; 2484/// Member functions overridden by B are shown in class A with a blue line; 2485/// erasing the corresponding member function; 2486 ; 2487void TClass::Draw(Option_t *option); 2488{; 2489 if (!HasInterpreterInfo()) return;; 2490 ; 2491 TVirtualPad::TContext ctxt(kTRUE);; 2492 ; 2493 // Should we create a new canvas?; 2494 TString opt = option;; 2495 if (!ctxt.GetSaved() || !opt.Contains(""same"")) {; 2496 TVirtualPad *padclass = (TVirtualPad*)(gROOT->GetListOfCanvases())->FindObject(""R__class"");; 2497 if (!padclass) {; 2498 gROOT->ProcessLine(""new TCanvas(\""R__class\"",\""class\"",20,20,1000,750);"");; 2499 } else {; 2500 padclass->cd();; 2501 }; 2502 }; 2503 ; 2504 if (gPad); 2505 gPad->DrawClassObject(this,option);; 2506}; 2507 ; 2508/////////////////////////////////////////////",MatchSource.WIKI,doc/v632/TClass_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/TClass_8cxx_source.html
https://root.cern/doc/v632/TClass_8cxx_source.html:93388,Modifiability,inherit,inherits,93388,"nProxy(*fCollectionProxy);; 2457 }; 2458 copy->SetClassSize(fSizeof);; 2459 if (fRefProxy) {; 2460 copy->AdoptReferenceProxy( fRefProxy->Clone() );; 2461 }; 2462 TClass::AddClass(const_cast<TClass*>(this));; 2463 return copy;; 2464}; 2465 ; 2466////////////////////////////////////////////////////////////////////////////////; 2467/// Replaces the collection proxy for this class. The provided object is cloned; 2468/// and the copy is then owned by `TClass`.; 2469 ; 2470void TClass::CopyCollectionProxy(const TVirtualCollectionProxy &orig); 2471{; 2472// // This code was used too quickly test the STL Emulation layer; 2473// Int_t k = TClassEdit::IsSTLCont(GetName());; 2474// if (k==1||k==-1) return;; 2475 ; 2476 delete fCollectionProxy;; 2477 fCollectionProxy = orig.Generate();; 2478}; 2479 ; 2480////////////////////////////////////////////////////////////////////////////////; 2481/// Draw detailed class inheritance structure.; 2482/// If a class B inherits from a class A, the description of B is drawn; 2483/// on the right side of the description of A.; 2484/// Member functions overridden by B are shown in class A with a blue line; 2485/// erasing the corresponding member function; 2486 ; 2487void TClass::Draw(Option_t *option); 2488{; 2489 if (!HasInterpreterInfo()) return;; 2490 ; 2491 TVirtualPad::TContext ctxt(kTRUE);; 2492 ; 2493 // Should we create a new canvas?; 2494 TString opt = option;; 2495 if (!ctxt.GetSaved() || !opt.Contains(""same"")) {; 2496 TVirtualPad *padclass = (TVirtualPad*)(gROOT->GetListOfCanvases())->FindObject(""R__class"");; 2497 if (!padclass) {; 2498 gROOT->ProcessLine(""new TCanvas(\""R__class\"",\""class\"",20,20,1000,750);"");; 2499 } else {; 2500 padclass->cd();; 2501 }; 2502 }; 2503 ; 2504 if (gPad); 2505 gPad->DrawClassObject(this,option);; 2506}; 2507 ; 2508////////////////////////////////////////////////////////////////////////////////; 2509/// Dump contents of object on stdout.; 2510/// Using the information in the object dictionary; 2511/// e",MatchSource.WIKI,doc/v632/TClass_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/TClass_8cxx_source.html
https://root.cern/doc/v632/TClass_8cxx_source.html:99639,Modifiability,inherit,inheritance,99639,"erInfo()) {; 2627 ; 2628 TVirtualIsAProxy *isa = nullptr;; 2629 if (GetClassInfo() && gCling->ClassInfo_HasMethod(fClassInfo,""IsA"")) {; 2630 isa = (TVirtualIsAProxy*)gROOT->ProcessLineFast(TString::Format(""new ::TInstrumentedIsAProxy<%s>(0);"",GetName()));; 2631 }; 2632 else {; 2633 isa = (TVirtualIsAProxy*)gROOT->ProcessLineFast(TString::Format(""new ::TIsAProxy(typeid(%s));"",GetName()));; 2634 }; 2635 if (isa) {; 2636 R__LOCKGUARD(gInterpreterMutex);; 2637 const_cast<TClass*>(this)->fIsA = isa;; 2638 }; 2639 if (fIsA) {; 2640 return (*fIsA)(object); // ROOT::IsA((ThisClass*)object);; 2641 }; 2642 }; 2643 TVirtualStreamerInfo* sinfo = GetStreamerInfo();; 2644 if (sinfo) {; 2645 return sinfo->GetActualClass(object);; 2646 }; 2647 return (TClass*)this;; 2648 }; 2649}; 2650 ; 2651////////////////////////////////////////////////////////////////////////////////; 2652/// Return pointer to the base class ""classname"". Returns 0 in case; 2653/// ""classname"" is not a base class. Takes care of multiple inheritance.; 2654 ; 2655TClass *TClass::GetBaseClass(const char *classname); 2656{; 2657 // check if class name itself is equal to classname; 2658 if (strcmp(GetName(), classname) == 0) return this;; 2659 ; 2660 if (!HasDataMemberInfo()) return nullptr;; 2661 ; 2662 // Make sure we deal with possible aliases, we could also have normalized; 2663 // the name.; 2664 TClass *search = TClass::GetClass(classname,kTRUE,kTRUE);; 2665 ; 2666 if (search) return GetBaseClass(search);; 2667 else return nullptr;; 2668}; 2669 ; 2670////////////////////////////////////////////////////////////////////////////////; 2671/// Return pointer to the base class ""cl"". Returns 0 in case ""cl""; 2672/// is not a base class. Takes care of multiple inheritance.; 2673 ; 2674TClass *TClass::GetBaseClass(const TClass *cl); 2675{; 2676 // check if class name itself is equal to classname; 2677 if (cl == this) return this;; 2678 ; 2679 if (!HasDataMemberInfo()) return nullptr;; 2680 ; 2681 TObjLink *lnk = GetListO",MatchSource.WIKI,doc/v632/TClass_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/TClass_8cxx_source.html
https://root.cern/doc/v632/TClass_8cxx_source.html:100369,Modifiability,inherit,inheritance,100369,"}; 2647 return (TClass*)this;; 2648 }; 2649}; 2650 ; 2651////////////////////////////////////////////////////////////////////////////////; 2652/// Return pointer to the base class ""classname"". Returns 0 in case; 2653/// ""classname"" is not a base class. Takes care of multiple inheritance.; 2654 ; 2655TClass *TClass::GetBaseClass(const char *classname); 2656{; 2657 // check if class name itself is equal to classname; 2658 if (strcmp(GetName(), classname) == 0) return this;; 2659 ; 2660 if (!HasDataMemberInfo()) return nullptr;; 2661 ; 2662 // Make sure we deal with possible aliases, we could also have normalized; 2663 // the name.; 2664 TClass *search = TClass::GetClass(classname,kTRUE,kTRUE);; 2665 ; 2666 if (search) return GetBaseClass(search);; 2667 else return nullptr;; 2668}; 2669 ; 2670////////////////////////////////////////////////////////////////////////////////; 2671/// Return pointer to the base class ""cl"". Returns 0 in case ""cl""; 2672/// is not a base class. Takes care of multiple inheritance.; 2673 ; 2674TClass *TClass::GetBaseClass(const TClass *cl); 2675{; 2676 // check if class name itself is equal to classname; 2677 if (cl == this) return this;; 2678 ; 2679 if (!HasDataMemberInfo()) return nullptr;; 2680 ; 2681 TObjLink *lnk = GetListOfBases() ? fBase.load()->FirstLink() : nullptr;; 2682 ; 2683 // otherwise look at inheritance tree; 2684 while (lnk) {; 2685 TClass *c, *c1;; 2686 TBaseClass *base = (TBaseClass*) lnk->GetObject();; 2687 c = base->GetClassPointer();; 2688 if (c) {; 2689 if (cl == c) return c;; 2690 c1 = c->GetBaseClass(cl);; 2691 if (c1) return c1;; 2692 }; 2693 lnk = lnk->Next();; 2694 }; 2695 return nullptr;; 2696}; 2697 ; 2698////////////////////////////////////////////////////////////////////////////////; 2699/// Return data member offset to the base class ""cl"".; 2700/// - Returns -1 in case ""cl"" is not a base class.; 2701/// - Returns -2 if cl is a base class, but we can't find the offset; 2702/// because it's virtual.; 2703/// Take",MatchSource.WIKI,doc/v632/TClass_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/TClass_8cxx_source.html
https://root.cern/doc/v632/TClass_8cxx_source.html:100715,Modifiability,inherit,inheritance,100715," we deal with possible aliases, we could also have normalized; 2663 // the name.; 2664 TClass *search = TClass::GetClass(classname,kTRUE,kTRUE);; 2665 ; 2666 if (search) return GetBaseClass(search);; 2667 else return nullptr;; 2668}; 2669 ; 2670////////////////////////////////////////////////////////////////////////////////; 2671/// Return pointer to the base class ""cl"". Returns 0 in case ""cl""; 2672/// is not a base class. Takes care of multiple inheritance.; 2673 ; 2674TClass *TClass::GetBaseClass(const TClass *cl); 2675{; 2676 // check if class name itself is equal to classname; 2677 if (cl == this) return this;; 2678 ; 2679 if (!HasDataMemberInfo()) return nullptr;; 2680 ; 2681 TObjLink *lnk = GetListOfBases() ? fBase.load()->FirstLink() : nullptr;; 2682 ; 2683 // otherwise look at inheritance tree; 2684 while (lnk) {; 2685 TClass *c, *c1;; 2686 TBaseClass *base = (TBaseClass*) lnk->GetObject();; 2687 c = base->GetClassPointer();; 2688 if (c) {; 2689 if (cl == c) return c;; 2690 c1 = c->GetBaseClass(cl);; 2691 if (c1) return c1;; 2692 }; 2693 lnk = lnk->Next();; 2694 }; 2695 return nullptr;; 2696}; 2697 ; 2698////////////////////////////////////////////////////////////////////////////////; 2699/// Return data member offset to the base class ""cl"".; 2700/// - Returns -1 in case ""cl"" is not a base class.; 2701/// - Returns -2 if cl is a base class, but we can't find the offset; 2702/// because it's virtual.; 2703/// Takes care of multiple inheritance.; 2704 ; 2705Int_t TClass::GetBaseClassOffsetRecurse(const TClass *cl); 2706{; 2707 // check if class name itself is equal to classname; 2708 if (cl == this) return 0;; 2709 ; 2710 if (!fBase.load()) {; 2711 if (fCanLoadClassInfo) LoadClassInfo();; 2712 // If the information was not provided by the root pcm files and; 2713 // if we can not find the ClassInfo, we have to fall back to the; 2714 // StreamerInfo; 2715 if (!fClassInfo) {; 2716 TVirtualStreamerInfo *sinfo = GetCurrentStreamerInfo();; 2717 if (!sinfo) return -",MatchSource.WIKI,doc/v632/TClass_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/TClass_8cxx_source.html
https://root.cern/doc/v632/TClass_8cxx_source.html:101382,Modifiability,inherit,inheritance,101382,"heritance.; 2673 ; 2674TClass *TClass::GetBaseClass(const TClass *cl); 2675{; 2676 // check if class name itself is equal to classname; 2677 if (cl == this) return this;; 2678 ; 2679 if (!HasDataMemberInfo()) return nullptr;; 2680 ; 2681 TObjLink *lnk = GetListOfBases() ? fBase.load()->FirstLink() : nullptr;; 2682 ; 2683 // otherwise look at inheritance tree; 2684 while (lnk) {; 2685 TClass *c, *c1;; 2686 TBaseClass *base = (TBaseClass*) lnk->GetObject();; 2687 c = base->GetClassPointer();; 2688 if (c) {; 2689 if (cl == c) return c;; 2690 c1 = c->GetBaseClass(cl);; 2691 if (c1) return c1;; 2692 }; 2693 lnk = lnk->Next();; 2694 }; 2695 return nullptr;; 2696}; 2697 ; 2698////////////////////////////////////////////////////////////////////////////////; 2699/// Return data member offset to the base class ""cl"".; 2700/// - Returns -1 in case ""cl"" is not a base class.; 2701/// - Returns -2 if cl is a base class, but we can't find the offset; 2702/// because it's virtual.; 2703/// Takes care of multiple inheritance.; 2704 ; 2705Int_t TClass::GetBaseClassOffsetRecurse(const TClass *cl); 2706{; 2707 // check if class name itself is equal to classname; 2708 if (cl == this) return 0;; 2709 ; 2710 if (!fBase.load()) {; 2711 if (fCanLoadClassInfo) LoadClassInfo();; 2712 // If the information was not provided by the root pcm files and; 2713 // if we can not find the ClassInfo, we have to fall back to the; 2714 // StreamerInfo; 2715 if (!fClassInfo) {; 2716 TVirtualStreamerInfo *sinfo = GetCurrentStreamerInfo();; 2717 if (!sinfo) return -1;; 2718 TStreamerElement *element;; 2719 Int_t offset = 0;; 2720 ; 2721 TObjArray &elems = *(sinfo->GetElements());; 2722 Int_t size = elems.GetLast()+1;; 2723 for(Int_t i=0; i<size; i++) {; 2724 element = (TStreamerElement*)elems[i];; 2725 if (element->IsBase()) {; 2726 if (element->IsA() == TStreamerBase::Class()) {; 2727 TStreamerBase *base = (TStreamerBase*)element;; 2728 TClass *baseclass = base->GetClassPointer();; 2729 if (!baseclass) return",MatchSource.WIKI,doc/v632/TClass_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/TClass_8cxx_source.html
https://root.cern/doc/v632/TClass_8cxx_source.html:103405,Modifiability,inherit,inheritance,103405,"t;; 2733 offset += baseclass->Size();; 2734 } else if (element->IsA() == TStreamerSTL::Class()) {; 2735 TStreamerSTL *base = (TStreamerSTL*)element;; 2736 TClass *baseclass = base->GetClassPointer();; 2737 if (!baseclass) return -1;; 2738 Int_t subOffset = baseclass->GetBaseClassOffsetRecurse(cl);; 2739 if (subOffset == -2) return -2;; 2740 if (subOffset != -1) return offset+subOffset;; 2741 offset += baseclass->Size();; 2742 ; 2743 } else {; 2744 Error(""GetBaseClassOffsetRecurse"",""Unexpected element type for base class: %s\n"",element->IsA()->GetName());; 2745 }; 2746 }; 2747 }; 2748 return -1;; 2749 }; 2750 }; 2751 ; 2752 TClass *c;; 2753 Int_t off;; 2754 TBaseClass *inh;; 2755 TObjLink *lnk = nullptr;; 2756 if (fBase.load() == nullptr); 2757 lnk = GetListOfBases()->FirstLink();; 2758 else; 2759 lnk = fBase.load()->FirstLink();; 2760 ; 2761 // otherwise look at inheritance tree; 2762 while (lnk) {; 2763 inh = (TBaseClass *)lnk->GetObject();; 2764 //use option load=kFALSE to avoid a warning like:; 2765 //""Warning in <TClass::TClass>: no dictionary for class TRefCnt is available""; 2766 //We can not afford to not have the class if it exist, so we; 2767 //use kTRUE.; 2768 c = inh->GetClassPointer(kTRUE); // kFALSE);; 2769 if (c) {; 2770 if (cl == c) {; 2771 if ((inh->Property() & kIsVirtualBase) != 0); 2772 return -2;; 2773 return inh->GetDelta();; 2774 }; 2775 off = c->GetBaseClassOffsetRecurse(cl);; 2776 if (off == -2) return -2;; 2777 if (off != -1) {; 2778 return off + inh->GetDelta();; 2779 }; 2780 }; 2781 lnk = lnk->Next();; 2782 }; 2783 return -1;; 2784}; 2785 ; 2786////////////////////////////////////////////////////////////////////////////////; 2787/// - Return data member offset to the base class ""cl"".; 2788/// - Returns -1 in case ""cl"" is not a base class.; 2789/// Takes care of multiple inheritance.; 2790 ; 2791Int_t TClass::GetBaseClassOffset(const TClass *toBase, void *address, bool isDerivedObject); 2792{; 2793 // Warning(""GetBaseClassOffset"",""Requires th",MatchSource.WIKI,doc/v632/TClass_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/TClass_8cxx_source.html
https://root.cern/doc/v632/TClass_8cxx_source.html:104357,Modifiability,inherit,inheritance,104357,"ase.load()->FirstLink();; 2760 ; 2761 // otherwise look at inheritance tree; 2762 while (lnk) {; 2763 inh = (TBaseClass *)lnk->GetObject();; 2764 //use option load=kFALSE to avoid a warning like:; 2765 //""Warning in <TClass::TClass>: no dictionary for class TRefCnt is available""; 2766 //We can not afford to not have the class if it exist, so we; 2767 //use kTRUE.; 2768 c = inh->GetClassPointer(kTRUE); // kFALSE);; 2769 if (c) {; 2770 if (cl == c) {; 2771 if ((inh->Property() & kIsVirtualBase) != 0); 2772 return -2;; 2773 return inh->GetDelta();; 2774 }; 2775 off = c->GetBaseClassOffsetRecurse(cl);; 2776 if (off == -2) return -2;; 2777 if (off != -1) {; 2778 return off + inh->GetDelta();; 2779 }; 2780 }; 2781 lnk = lnk->Next();; 2782 }; 2783 return -1;; 2784}; 2785 ; 2786////////////////////////////////////////////////////////////////////////////////; 2787/// - Return data member offset to the base class ""cl"".; 2788/// - Returns -1 in case ""cl"" is not a base class.; 2789/// Takes care of multiple inheritance.; 2790 ; 2791Int_t TClass::GetBaseClassOffset(const TClass *toBase, void *address, bool isDerivedObject); 2792{; 2793 // Warning(""GetBaseClassOffset"",""Requires the use of fClassInfo for %s to %s"",GetName(),toBase->GetName());; 2794 ; 2795 if (this == toBase) return 0;; 2796 ; 2797 if ((!address /* || !has_virtual_base */) &&; 2798 (!HasInterpreterInfoInMemory() || !toBase->HasInterpreterInfoInMemory())) {; 2799 // At least of the ClassInfo have not been loaded in memory yet and; 2800 // since there is no virtual base class (or we don't have enough so it; 2801 // would not make a difference) we can use the 'static' information; 2802 Int_t offset = GetBaseClassOffsetRecurse (toBase);; 2803 if (offset != -2) {; 2804 return offset;; 2805 }; 2806 return offset;; 2807 }; 2808 ; 2809 ClassInfo_t* derived = GetClassInfo();; 2810 ClassInfo_t* base = toBase->GetClassInfo();; 2811 if(derived && base) {; 2812 // TClingClassInfo::GetBaseOffset takes the lock.; 2813 return gCli",MatchSource.WIKI,doc/v632/TClass_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/TClass_8cxx_source.html
https://root.cern/doc/v632/TClass_8cxx_source.html:173562,Modifiability,variab,variable,173562,"/// number of currently loaded methods use:; 4571/// cl->GetListOfMethods(false)->GetSize();; 4572 ; 4573Int_t TClass::GetNmethods(); 4574{; 4575 if (!HasInterpreterInfo()) return 0;; 4576 ; 4577 TList *lm = GetListOfMethods();; 4578 if (lm); 4579 return lm->GetSize();; 4580 else; 4581 return 0;; 4582}; 4583 ; 4584////////////////////////////////////////////////////////////////////////////////; 4585/// returns a pointer to the TVirtualStreamerInfo object for version; 4586/// If the object does not exist, it is created; 4587///; 4588/// Note: There are two special version numbers:; 4589///; 4590/// - 0: Use the class version from the currently loaded class library.; 4591/// - -1: Assume no class library loaded (emulated class).; 4592///; 4593/// Warning: If we create a new streamer info, whether or not the build; 4594/// optimizes is controlled externally to us by a global variable!; 4595/// Don't call us unless you have set that variable properly; 4596/// with TStreamer::Optimize()!; 4597///; 4598 ; 4599TVirtualStreamerInfo* TClass::GetStreamerInfo(Int_t version /* = 0 */, Bool_t isTransient /* = false */) const; 4600{; 4601 TVirtualStreamerInfo *sinfo = fLastReadInfo;; 4602 ; 4603 // Version 0 is special, it means the currently loaded version.; 4604 // We need to set it at the beginning to be able to guess it correctly.; 4605 ; 4606 if (version == 0); 4607 version = fClassVersion;; 4608 ; 4609 // If the StreamerInfo is assigned to the fLastReadInfo, we are; 4610 // guaranteed it was built and compiled.; 4611 if (sinfo && sinfo->GetClassVersion() == version); 4612 return sinfo;; 4613 ; 4614 // Note that the access to fClassVersion above is technically not thread-safe with a low probably of problems.; 4615 // fClassVersion is not an atomic and is modified TClass::SetClassVersion (called from RootClassVersion via; 4616 // ROOT::ResetClassVersion) and is 'somewhat' protected by the atomic fVersionUsed.; 4617 // However, direct access to fClassVersion should be replaced",MatchSource.WIKI,doc/v632/TClass_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/TClass_8cxx_source.html
https://root.cern/doc/v632/TClass_8cxx_source.html:173620,Modifiability,variab,variable,173620,"/// number of currently loaded methods use:; 4571/// cl->GetListOfMethods(false)->GetSize();; 4572 ; 4573Int_t TClass::GetNmethods(); 4574{; 4575 if (!HasInterpreterInfo()) return 0;; 4576 ; 4577 TList *lm = GetListOfMethods();; 4578 if (lm); 4579 return lm->GetSize();; 4580 else; 4581 return 0;; 4582}; 4583 ; 4584////////////////////////////////////////////////////////////////////////////////; 4585/// returns a pointer to the TVirtualStreamerInfo object for version; 4586/// If the object does not exist, it is created; 4587///; 4588/// Note: There are two special version numbers:; 4589///; 4590/// - 0: Use the class version from the currently loaded class library.; 4591/// - -1: Assume no class library loaded (emulated class).; 4592///; 4593/// Warning: If we create a new streamer info, whether or not the build; 4594/// optimizes is controlled externally to us by a global variable!; 4595/// Don't call us unless you have set that variable properly; 4596/// with TStreamer::Optimize()!; 4597///; 4598 ; 4599TVirtualStreamerInfo* TClass::GetStreamerInfo(Int_t version /* = 0 */, Bool_t isTransient /* = false */) const; 4600{; 4601 TVirtualStreamerInfo *sinfo = fLastReadInfo;; 4602 ; 4603 // Version 0 is special, it means the currently loaded version.; 4604 // We need to set it at the beginning to be able to guess it correctly.; 4605 ; 4606 if (version == 0); 4607 version = fClassVersion;; 4608 ; 4609 // If the StreamerInfo is assigned to the fLastReadInfo, we are; 4610 // guaranteed it was built and compiled.; 4611 if (sinfo && sinfo->GetClassVersion() == version); 4612 return sinfo;; 4613 ; 4614 // Note that the access to fClassVersion above is technically not thread-safe with a low probably of problems.; 4615 // fClassVersion is not an atomic and is modified TClass::SetClassVersion (called from RootClassVersion via; 4616 // ROOT::ResetClassVersion) and is 'somewhat' protected by the atomic fVersionUsed.; 4617 // However, direct access to fClassVersion should be replaced",MatchSource.WIKI,doc/v632/TClass_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/TClass_8cxx_source.html
https://root.cern/doc/v632/TClass_8cxx_source.html:178737,Modifiability,variab,variable,178737,"/////////////////////////////////////////////////////////////////////////////; 4692/// For the case where the requestor class is emulated and this class is abstract,; 4693/// returns a pointer to the TVirtualStreamerInfo object for version with an emulated; 4694/// representation whether or not the class is loaded.; 4695///; 4696/// If the object does not exist, it is created; 4697///; 4698/// Note: There are two special version numbers:; 4699///; 4700/// - 0: Use the class version from the currently loaded class library.; 4701/// - -1: Assume no class library loaded (emulated class).; 4702///; 4703/// Warning: If we create a new streamer info, whether or not the build; 4704/// optimizes is controlled externally to us by a global variable!; 4705/// Don't call us unless you have set that variable properly; 4706/// with TStreamer::Optimize()!; 4707///; 4708 ; 4709TVirtualStreamerInfo* TClass::GetStreamerInfoAbstractEmulated(Int_t version /* = 0 */) const; 4710{; 4711 TVirtualStreamerInfo *sinfo = nullptr;; 4712 ; 4713 TString newname(GetName());; 4714 newname += ""@@emulated"";; 4715 ; 4716 R__LOCKGUARD(gInterpreterMutex);; 4717 ; 4718 TClass *emulated = TClass::GetClass(newname);; 4719 ; 4720 if (emulated); 4721 sinfo = emulated->GetStreamerInfo(version);; 4722 ; 4723 if (!sinfo) {; 4724 // The emulated version of the streamerInfo is explicitly requested and has; 4725 // not been built yet.; 4726 ; 4727 sinfo = (TVirtualStreamerInfo*) fStreamerInfo->At(version);; 4728 ; 4729 if (!sinfo && (version != fClassVersion)) {; 4730 // When the requested version does not exist we return; 4731 // the TVirtualStreamerInfo for the currently loaded class version.; 4732 // FIXME: This arguably makes no sense, we should warn and return nothing instead.; 4733 sinfo = (TVirtualStreamerInfo*) fStreamerInfo->At(fClassVersion);; 4734 }; 4735 ; 4736 if (!sinfo) {; 4737 // Let's take the first available StreamerInfo as a start; 4738 Int_t ninfos = fStreamerInfo->GetEntriesFast() - 1;; 4739 f",MatchSource.WIKI,doc/v632/TClass_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/TClass_8cxx_source.html
https://root.cern/doc/v632/TClass_8cxx_source.html:178795,Modifiability,variab,variable,178795,"/////////////////////////////////////////////////////////////////////////////; 4692/// For the case where the requestor class is emulated and this class is abstract,; 4693/// returns a pointer to the TVirtualStreamerInfo object for version with an emulated; 4694/// representation whether or not the class is loaded.; 4695///; 4696/// If the object does not exist, it is created; 4697///; 4698/// Note: There are two special version numbers:; 4699///; 4700/// - 0: Use the class version from the currently loaded class library.; 4701/// - -1: Assume no class library loaded (emulated class).; 4702///; 4703/// Warning: If we create a new streamer info, whether or not the build; 4704/// optimizes is controlled externally to us by a global variable!; 4705/// Don't call us unless you have set that variable properly; 4706/// with TStreamer::Optimize()!; 4707///; 4708 ; 4709TVirtualStreamerInfo* TClass::GetStreamerInfoAbstractEmulated(Int_t version /* = 0 */) const; 4710{; 4711 TVirtualStreamerInfo *sinfo = nullptr;; 4712 ; 4713 TString newname(GetName());; 4714 newname += ""@@emulated"";; 4715 ; 4716 R__LOCKGUARD(gInterpreterMutex);; 4717 ; 4718 TClass *emulated = TClass::GetClass(newname);; 4719 ; 4720 if (emulated); 4721 sinfo = emulated->GetStreamerInfo(version);; 4722 ; 4723 if (!sinfo) {; 4724 // The emulated version of the streamerInfo is explicitly requested and has; 4725 // not been built yet.; 4726 ; 4727 sinfo = (TVirtualStreamerInfo*) fStreamerInfo->At(version);; 4728 ; 4729 if (!sinfo && (version != fClassVersion)) {; 4730 // When the requested version does not exist we return; 4731 // the TVirtualStreamerInfo for the currently loaded class version.; 4732 // FIXME: This arguably makes no sense, we should warn and return nothing instead.; 4733 sinfo = (TVirtualStreamerInfo*) fStreamerInfo->At(fClassVersion);; 4734 }; 4735 ; 4736 if (!sinfo) {; 4737 // Let's take the first available StreamerInfo as a start; 4738 Int_t ninfos = fStreamerInfo->GetEntriesFast() - 1;; 4739 f",MatchSource.WIKI,doc/v632/TClass_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/TClass_8cxx_source.html
https://root.cern/doc/v632/TClass_8cxx_source.html:181164,Modifiability,variab,variable,181164,"TString::Format(""sourceClass=%s targetClass=%s"",GetName(),newname.Data()));; 4751 } else {; 4752 Error(""GetStreamerInfoAbstractEmulated"", ""could not create TVirtualStreamerInfo"");; 4753 }; 4754 }; 4755 }; 4756 return sinfo;; 4757}; 4758 ; 4759////////////////////////////////////////////////////////////////////////////////; 4760/// For the case where the requestor class is emulated and this class is abstract,; 4761/// returns a pointer to the TVirtualStreamerInfo object for version with an emulated; 4762/// representation whether or not the class is loaded.; 4763///; 4764/// If the object does not exist, it is created; 4765///; 4766/// Warning: If we create a new streamer info, whether or not the build; 4767/// optimizes is controlled externally to us by a global variable!; 4768/// Don't call us unless you have set that variable properly; 4769/// with TStreamer::Optimize()!; 4770///; 4771 ; 4772TVirtualStreamerInfo* TClass::FindStreamerInfoAbstractEmulated(UInt_t checksum) const; 4773{; 4774 TVirtualStreamerInfo *sinfo = nullptr;; 4775 ; 4776 TString newname(GetName());; 4777 newname += ""@@emulated"";; 4778 ; 4779 R__LOCKGUARD(gInterpreterMutex);; 4780 ; 4781 TClass *emulated = TClass::GetClass(newname);; 4782 ; 4783 if (emulated); 4784 sinfo = emulated->FindStreamerInfo(checksum);; 4785 ; 4786 if (!sinfo) {; 4787 // The emulated version of the streamerInfo is explicitly requested and has; 4788 // not been built yet.; 4789 ; 4790 sinfo = (TVirtualStreamerInfo*) FindStreamerInfo(checksum);; 4791 ; 4792 if (!sinfo && (checksum != fCheckSum)) {; 4793 // When the requested version does not exist we return; 4794 // the TVirtualStreamerInfo for the currently loaded class version.; 4795 // FIXME: This arguably makes no sense, we should warn and return nothing instead.; 4796 sinfo = (TVirtualStreamerInfo*) fStreamerInfo->At(fClassVersion);; 4797 }; 4798 ; 4799 if (!sinfo) {; 4800 // Let's take the first available StreamerInfo as a start; 4801 Int_t ninfos = fStreamerInfo->Get",MatchSource.WIKI,doc/v632/TClass_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/TClass_8cxx_source.html
https://root.cern/doc/v632/TClass_8cxx_source.html:181222,Modifiability,variab,variable,181222,"TString::Format(""sourceClass=%s targetClass=%s"",GetName(),newname.Data()));; 4751 } else {; 4752 Error(""GetStreamerInfoAbstractEmulated"", ""could not create TVirtualStreamerInfo"");; 4753 }; 4754 }; 4755 }; 4756 return sinfo;; 4757}; 4758 ; 4759////////////////////////////////////////////////////////////////////////////////; 4760/// For the case where the requestor class is emulated and this class is abstract,; 4761/// returns a pointer to the TVirtualStreamerInfo object for version with an emulated; 4762/// representation whether or not the class is loaded.; 4763///; 4764/// If the object does not exist, it is created; 4765///; 4766/// Warning: If we create a new streamer info, whether or not the build; 4767/// optimizes is controlled externally to us by a global variable!; 4768/// Don't call us unless you have set that variable properly; 4769/// with TStreamer::Optimize()!; 4770///; 4771 ; 4772TVirtualStreamerInfo* TClass::FindStreamerInfoAbstractEmulated(UInt_t checksum) const; 4773{; 4774 TVirtualStreamerInfo *sinfo = nullptr;; 4775 ; 4776 TString newname(GetName());; 4777 newname += ""@@emulated"";; 4778 ; 4779 R__LOCKGUARD(gInterpreterMutex);; 4780 ; 4781 TClass *emulated = TClass::GetClass(newname);; 4782 ; 4783 if (emulated); 4784 sinfo = emulated->FindStreamerInfo(checksum);; 4785 ; 4786 if (!sinfo) {; 4787 // The emulated version of the streamerInfo is explicitly requested and has; 4788 // not been built yet.; 4789 ; 4790 sinfo = (TVirtualStreamerInfo*) FindStreamerInfo(checksum);; 4791 ; 4792 if (!sinfo && (checksum != fCheckSum)) {; 4793 // When the requested version does not exist we return; 4794 // the TVirtualStreamerInfo for the currently loaded class version.; 4795 // FIXME: This arguably makes no sense, we should warn and return nothing instead.; 4796 sinfo = (TVirtualStreamerInfo*) fStreamerInfo->At(fClassVersion);; 4797 }; 4798 ; 4799 if (!sinfo) {; 4800 // Let's take the first available StreamerInfo as a start; 4801 Int_t ninfos = fStreamerInfo->Get",MatchSource.WIKI,doc/v632/TClass_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/TClass_8cxx_source.html
https://root.cern/doc/v632/TClass_8cxx_source.html:185540,Modifiability,inherit,inherits,185540,"jectStreamer)) return;; 4849 if (!doIgnore && !TestBit(kIgnoreTObjectStreamer)) return;; 4850 TVirtualStreamerInfo *sinfo = GetCurrentStreamerInfo();; 4851 if (sinfo) {; 4852 if (sinfo->IsCompiled()) {; 4853 // -- Warn the user that what they are doing cannot work.; 4854 // Note: The reason is that TVirtualStreamerInfo::Build() examines; 4855 // the kIgnoreTObjectStreamer bit and sets the TStreamerElement; 4856 // type for the TObject base class streamer element it creates; 4857 // to -1 as a flag. Later on the TStreamerInfo::Compile(); 4858 // member function sees the flag and does not insert the base; 4859 // class element into the compiled streamer info. None of this; 4860 // machinery works correctly if we are called after the streamer; 4861 // info has already been built and compiled.; 4862 Error(""IgnoreTObjectStreamer"",""Must be called before the creation of StreamerInfo"");; 4863 return;; 4864 }; 4865 }; 4866 if (doIgnore) SetBit (kIgnoreTObjectStreamer);; 4867 else ResetBit(kIgnoreTObjectStreamer);; 4868}; 4869 ; 4870////////////////////////////////////////////////////////////////////////////////; 4871/// Return kTRUE if this class inherits from a class with name ""classname"".; 4872/// note that the function returns kTRUE in case classname is the class itself; 4873 ; 4874Bool_t TClass::InheritsFrom(const char *classname) const; 4875{; 4876 if (strcmp(GetName(), classname) == 0) return kTRUE;; 4877 ; 4878 return InheritsFrom(TClass::GetClass(classname,kTRUE,kTRUE));; 4879}; 4880 ; 4881////////////////////////////////////////////////////////////////////////////////; 4882/// Return kTRUE if this class inherits from class cl.; 4883/// note that the function returns KTRUE in case cl is the class itself; 4884 ; 4885Bool_t TClass::InheritsFrom(const TClass *cl) const; 4886{; 4887 if (!cl) return kFALSE;; 4888 if (cl == this) return kTRUE;; 4889 ; 4890 if (!HasDataMemberInfo()) {; 4891 TVirtualStreamerInfo *sinfo = ((TClass *)this)->GetCurrentStreamerInfo();; 4892 if (",MatchSource.WIKI,doc/v632/TClass_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/TClass_8cxx_source.html
https://root.cern/doc/v632/TClass_8cxx_source.html:186015,Modifiability,inherit,inherits,186015,"the TObject base class streamer element it creates; 4857 // to -1 as a flag. Later on the TStreamerInfo::Compile(); 4858 // member function sees the flag and does not insert the base; 4859 // class element into the compiled streamer info. None of this; 4860 // machinery works correctly if we are called after the streamer; 4861 // info has already been built and compiled.; 4862 Error(""IgnoreTObjectStreamer"",""Must be called before the creation of StreamerInfo"");; 4863 return;; 4864 }; 4865 }; 4866 if (doIgnore) SetBit (kIgnoreTObjectStreamer);; 4867 else ResetBit(kIgnoreTObjectStreamer);; 4868}; 4869 ; 4870////////////////////////////////////////////////////////////////////////////////; 4871/// Return kTRUE if this class inherits from a class with name ""classname"".; 4872/// note that the function returns kTRUE in case classname is the class itself; 4873 ; 4874Bool_t TClass::InheritsFrom(const char *classname) const; 4875{; 4876 if (strcmp(GetName(), classname) == 0) return kTRUE;; 4877 ; 4878 return InheritsFrom(TClass::GetClass(classname,kTRUE,kTRUE));; 4879}; 4880 ; 4881////////////////////////////////////////////////////////////////////////////////; 4882/// Return kTRUE if this class inherits from class cl.; 4883/// note that the function returns KTRUE in case cl is the class itself; 4884 ; 4885Bool_t TClass::InheritsFrom(const TClass *cl) const; 4886{; 4887 if (!cl) return kFALSE;; 4888 if (cl == this) return kTRUE;; 4889 ; 4890 if (!HasDataMemberInfo()) {; 4891 TVirtualStreamerInfo *sinfo = ((TClass *)this)->GetCurrentStreamerInfo();; 4892 if (sinfo==nullptr) sinfo = GetStreamerInfo();; 4893 TIter next(sinfo->GetElements());; 4894 TStreamerElement *element;; 4895 while ((element = (TStreamerElement*)next())) {; 4896 if (element->IsA() == TStreamerBase::Class()) {; 4897 TClass *clbase = element->GetClassPointer();; 4898 if (!clbase) return kFALSE; //missing class; 4899 if (clbase->InheritsFrom(cl)) return kTRUE;; 4900 }; 4901 }; 4902 return kFALSE;; 4903 }; 4904 /",MatchSource.WIKI,doc/v632/TClass_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/TClass_8cxx_source.html
https://root.cern/doc/v632/TClass_8cxx_source.html:226805,Modifiability,inherit,inherits,226805,"////////////////////; 5895/// Static method returning the defConstructor flag passed to TClass::New().; 5896/// New type is either:; 5897/// - TClass::kRealNew - when called via plain new; 5898/// - TClass::kClassNew - when called via TClass::New(); 5899/// - TClass::kDummyNew - when called via TClass::New() but object is a dummy,; 5900/// in which case the object ctor might take short cuts; 5901 ; 5902TClass::ENewType TClass::IsCallingNew(); 5903{; 5904 return TClass__GetCallingNew();; 5905}; 5906 ; 5907////////////////////////////////////////////////////////////////////////////////; 5908/// Return true if the shared library of this class is currently in the a; 5909/// process's memory. Return false, after the shared library has been; 5910/// unloaded or if this is an 'emulated' class created from a file's StreamerInfo.; 5911 ; 5912Bool_t TClass::IsLoaded() const; 5913{; 5914 return fState == kHasTClassInit;; 5915}; 5916 ; 5917////////////////////////////////////////////////////////////////////////////////; 5918/// Returns true if this class inherits from TObject and if the start of; 5919/// the TObject parts is at the very beginning of the objects.; 5920/// Concretely this means that the following code is proper for this class:; 5921/// ~~~ {.cpp}; 5922/// ThisClass *ptr;; 5923/// void *void_ptr = (void)ptr;; 5924/// TObject *obj = (TObject*)void_ptr;; 5925/// ~~~; 5926/// This code would be wrong if 'ThisClass' did not inherit 'first' from; 5927/// TObject.; 5928 ; 5929Bool_t TClass::IsStartingWithTObject() const; 5930{; 5931 if (fProperty==(-1)) Property();; 5932 return TestBit(kStartWithTObject);; 5933}; 5934 ; 5935////////////////////////////////////////////////////////////////////////////////; 5936/// Return kTRUE is the class inherits from TObject.; 5937 ; 5938Bool_t TClass::IsTObject() const; 5939{; 5940 if (fProperty==(-1)) Property();; 5941 return TestBit(kIsTObject);; 5942}; 5943 ; 5944/////////////////////////////////////////////////////////////////////",MatchSource.WIKI,doc/v632/TClass_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/TClass_8cxx_source.html
https://root.cern/doc/v632/TClass_8cxx_source.html:227192,Modifiability,inherit,inherit,227192,"ght take short cuts; 5901 ; 5902TClass::ENewType TClass::IsCallingNew(); 5903{; 5904 return TClass__GetCallingNew();; 5905}; 5906 ; 5907////////////////////////////////////////////////////////////////////////////////; 5908/// Return true if the shared library of this class is currently in the a; 5909/// process's memory. Return false, after the shared library has been; 5910/// unloaded or if this is an 'emulated' class created from a file's StreamerInfo.; 5911 ; 5912Bool_t TClass::IsLoaded() const; 5913{; 5914 return fState == kHasTClassInit;; 5915}; 5916 ; 5917////////////////////////////////////////////////////////////////////////////////; 5918/// Returns true if this class inherits from TObject and if the start of; 5919/// the TObject parts is at the very beginning of the objects.; 5920/// Concretely this means that the following code is proper for this class:; 5921/// ~~~ {.cpp}; 5922/// ThisClass *ptr;; 5923/// void *void_ptr = (void)ptr;; 5924/// TObject *obj = (TObject*)void_ptr;; 5925/// ~~~; 5926/// This code would be wrong if 'ThisClass' did not inherit 'first' from; 5927/// TObject.; 5928 ; 5929Bool_t TClass::IsStartingWithTObject() const; 5930{; 5931 if (fProperty==(-1)) Property();; 5932 return TestBit(kStartWithTObject);; 5933}; 5934 ; 5935////////////////////////////////////////////////////////////////////////////////; 5936/// Return kTRUE is the class inherits from TObject.; 5937 ; 5938Bool_t TClass::IsTObject() const; 5939{; 5940 if (fProperty==(-1)) Property();; 5941 return TestBit(kIsTObject);; 5942}; 5943 ; 5944////////////////////////////////////////////////////////////////////////////////; 5945/// Return kTRUE is the class is Foreign (the class does not have a Streamer method).; 5946 ; 5947Bool_t TClass::IsForeign() const; 5948{; 5949 if (fProperty==(-1)) Property();; 5950 // If the property are not set and the class is a pair, hard code that; 5951 // it is a unversioned/Foreign class.; 5952 return TestBit(kIsForeign);; 5953}; 5954 ; 5955///////",MatchSource.WIKI,doc/v632/TClass_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/TClass_8cxx_source.html
https://root.cern/doc/v632/TClass_8cxx_source.html:227510,Modifiability,inherit,inherits,227510,"f this class is currently in the a; 5909/// process's memory. Return false, after the shared library has been; 5910/// unloaded or if this is an 'emulated' class created from a file's StreamerInfo.; 5911 ; 5912Bool_t TClass::IsLoaded() const; 5913{; 5914 return fState == kHasTClassInit;; 5915}; 5916 ; 5917////////////////////////////////////////////////////////////////////////////////; 5918/// Returns true if this class inherits from TObject and if the start of; 5919/// the TObject parts is at the very beginning of the objects.; 5920/// Concretely this means that the following code is proper for this class:; 5921/// ~~~ {.cpp}; 5922/// ThisClass *ptr;; 5923/// void *void_ptr = (void)ptr;; 5924/// TObject *obj = (TObject*)void_ptr;; 5925/// ~~~; 5926/// This code would be wrong if 'ThisClass' did not inherit 'first' from; 5927/// TObject.; 5928 ; 5929Bool_t TClass::IsStartingWithTObject() const; 5930{; 5931 if (fProperty==(-1)) Property();; 5932 return TestBit(kStartWithTObject);; 5933}; 5934 ; 5935////////////////////////////////////////////////////////////////////////////////; 5936/// Return kTRUE is the class inherits from TObject.; 5937 ; 5938Bool_t TClass::IsTObject() const; 5939{; 5940 if (fProperty==(-1)) Property();; 5941 return TestBit(kIsTObject);; 5942}; 5943 ; 5944////////////////////////////////////////////////////////////////////////////////; 5945/// Return kTRUE is the class is Foreign (the class does not have a Streamer method).; 5946 ; 5947Bool_t TClass::IsForeign() const; 5948{; 5949 if (fProperty==(-1)) Property();; 5950 // If the property are not set and the class is a pair, hard code that; 5951 // it is a unversioned/Foreign class.; 5952 return TestBit(kIsForeign);; 5953}; 5954 ; 5955////////////////////////////////////////////////////////////////////////////////; 5956/// Do the initialization that can only be done after the CINT dictionary has; 5957/// been fully populated and can not be delayed efficiently.; 5958 ; 5959void TClass::PostLoadChec",MatchSource.WIKI,doc/v632/TClass_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/TClass_8cxx_source.html
https://root.cern/doc/v632/TClass_8cxx_source.html:233395,Modifiability,inherit,inherits,233395,"->fCollectionProxy && acl->fCollectionProxy->GetValueClass() == pcl) {; 6045 acl->fCollectionProxy->Reset();; 6046 }; 6047 }; 6048 ; 6049 TIter next(pcl->GetStreamerInfos());; 6050 while (auto info = (TVirtualStreamerInfo*)next()) {; 6051 if (info->IsBuilt()) {; 6052 info->Clear(""build"");; 6053 info->BuildOld();; 6054 }; 6055 }; 6056 fCollectionProxy->GetValueClass();; 6057 }; 6058 }; 6059 }; 6060}; 6061 ; 6062////////////////////////////////////////////////////////////////////////////////; 6063/// Returns the properties of the TClass as a bit field stored as a `Long_t` value.; 6064///; 6065/// The bit values used for the return value are defined in the enum EProperty (in TDictionary.h); 6066///; 6067/// Also sets `TObject::fBits` and `fStreamerType` to cache information about the; 6068/// class. The bits stored in `TObject::fBits` are; 6069/// ~~~ {.cpp}; 6070/// kIsTObject : the class inherits from TObject; 6071/// kStartWithTObject: TObject is the left-most class in the inheritance tree; 6072/// kIsForeign : the class doe not have a Streamer method; 6073/// ~~~; 6074/// The value of `fStreamerType` are; 6075/// ~~~ {.cpp}; 6076/// kTObject : the class inherits from TObject; 6077/// kForeign : the class does not have a Streamer method; 6078/// kInstrumented: the class does have a Streamer method; 6079/// kExternal: the class has a free standing way of streaming itself; 6080/// kEmulatedStreamer: the class is missing its shared library.; 6081/// ~~~; 6082///; 6083/// Implementation note: the data member fProperty has the value -1; 6084/// until it is initialized.; 6085 ; 6086Long_t TClass::Property() const; 6087{; 6088 // Check if we can return without taking the lock,; 6089 // this is valid since fProperty is atomic and set as; 6090 // the last operation before return.; 6091 if (fProperty!=(-1)) return fProperty;; 6092 ; 6093 R__LOCKGUARD(gInterpreterMutex);; 6094 ; 6095 // Check if another thread set fProperty while we; 6096 // were waiting.; 6097 if (fProperty!=(",MatchSource.WIKI,doc/v632/TClass_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/TClass_8cxx_source.html
https://root.cern/doc/v632/TClass_8cxx_source.html:233483,Modifiability,inherit,inheritance,233483,"->fCollectionProxy && acl->fCollectionProxy->GetValueClass() == pcl) {; 6045 acl->fCollectionProxy->Reset();; 6046 }; 6047 }; 6048 ; 6049 TIter next(pcl->GetStreamerInfos());; 6050 while (auto info = (TVirtualStreamerInfo*)next()) {; 6051 if (info->IsBuilt()) {; 6052 info->Clear(""build"");; 6053 info->BuildOld();; 6054 }; 6055 }; 6056 fCollectionProxy->GetValueClass();; 6057 }; 6058 }; 6059 }; 6060}; 6061 ; 6062////////////////////////////////////////////////////////////////////////////////; 6063/// Returns the properties of the TClass as a bit field stored as a `Long_t` value.; 6064///; 6065/// The bit values used for the return value are defined in the enum EProperty (in TDictionary.h); 6066///; 6067/// Also sets `TObject::fBits` and `fStreamerType` to cache information about the; 6068/// class. The bits stored in `TObject::fBits` are; 6069/// ~~~ {.cpp}; 6070/// kIsTObject : the class inherits from TObject; 6071/// kStartWithTObject: TObject is the left-most class in the inheritance tree; 6072/// kIsForeign : the class doe not have a Streamer method; 6073/// ~~~; 6074/// The value of `fStreamerType` are; 6075/// ~~~ {.cpp}; 6076/// kTObject : the class inherits from TObject; 6077/// kForeign : the class does not have a Streamer method; 6078/// kInstrumented: the class does have a Streamer method; 6079/// kExternal: the class has a free standing way of streaming itself; 6080/// kEmulatedStreamer: the class is missing its shared library.; 6081/// ~~~; 6082///; 6083/// Implementation note: the data member fProperty has the value -1; 6084/// until it is initialized.; 6085 ; 6086Long_t TClass::Property() const; 6087{; 6088 // Check if we can return without taking the lock,; 6089 // this is valid since fProperty is atomic and set as; 6090 // the last operation before return.; 6091 if (fProperty!=(-1)) return fProperty;; 6092 ; 6093 R__LOCKGUARD(gInterpreterMutex);; 6094 ; 6095 // Check if another thread set fProperty while we; 6096 // were waiting.; 6097 if (fProperty!=(",MatchSource.WIKI,doc/v632/TClass_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/TClass_8cxx_source.html
https://root.cern/doc/v632/TClass_8cxx_source.html:233668,Modifiability,inherit,inherits,233668,"o->BuildOld();; 6054 }; 6055 }; 6056 fCollectionProxy->GetValueClass();; 6057 }; 6058 }; 6059 }; 6060}; 6061 ; 6062////////////////////////////////////////////////////////////////////////////////; 6063/// Returns the properties of the TClass as a bit field stored as a `Long_t` value.; 6064///; 6065/// The bit values used for the return value are defined in the enum EProperty (in TDictionary.h); 6066///; 6067/// Also sets `TObject::fBits` and `fStreamerType` to cache information about the; 6068/// class. The bits stored in `TObject::fBits` are; 6069/// ~~~ {.cpp}; 6070/// kIsTObject : the class inherits from TObject; 6071/// kStartWithTObject: TObject is the left-most class in the inheritance tree; 6072/// kIsForeign : the class doe not have a Streamer method; 6073/// ~~~; 6074/// The value of `fStreamerType` are; 6075/// ~~~ {.cpp}; 6076/// kTObject : the class inherits from TObject; 6077/// kForeign : the class does not have a Streamer method; 6078/// kInstrumented: the class does have a Streamer method; 6079/// kExternal: the class has a free standing way of streaming itself; 6080/// kEmulatedStreamer: the class is missing its shared library.; 6081/// ~~~; 6082///; 6083/// Implementation note: the data member fProperty has the value -1; 6084/// until it is initialized.; 6085 ; 6086Long_t TClass::Property() const; 6087{; 6088 // Check if we can return without taking the lock,; 6089 // this is valid since fProperty is atomic and set as; 6090 // the last operation before return.; 6091 if (fProperty!=(-1)) return fProperty;; 6092 ; 6093 R__LOCKGUARD(gInterpreterMutex);; 6094 ; 6095 // Check if another thread set fProperty while we; 6096 // were waiting.; 6097 if (fProperty!=(-1)) return fProperty;; 6098 ; 6099 // Avoid asking about the class when it is still building; 6100 if (TestBit(kLoading)) return fProperty;; 6101 ; 6102 // When called via TMapFile (e.g. Update()) make sure that the dictionary; 6103 // gets allocated on the heap and not in the mapped file.; 6104 T",MatchSource.WIKI,doc/v632/TClass_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/TClass_8cxx_source.html
https://root.cern/doc/v632/TClass_8cxx_source.html:235087,Modifiability,inherit,inheritance,235087,"without taking the lock,; 6089 // this is valid since fProperty is atomic and set as; 6090 // the last operation before return.; 6091 if (fProperty!=(-1)) return fProperty;; 6092 ; 6093 R__LOCKGUARD(gInterpreterMutex);; 6094 ; 6095 // Check if another thread set fProperty while we; 6096 // were waiting.; 6097 if (fProperty!=(-1)) return fProperty;; 6098 ; 6099 // Avoid asking about the class when it is still building; 6100 if (TestBit(kLoading)) return fProperty;; 6101 ; 6102 // When called via TMapFile (e.g. Update()) make sure that the dictionary; 6103 // gets allocated on the heap and not in the mapped file.; 6104 TMmallocDescTemp setreset;; 6105 ; 6106 TClass *kl = const_cast<TClass*>(this);; 6107 ; 6108 kl->fStreamerType = TClass::kDefault;; 6109 kl->fStreamerImpl = &TClass::StreamerDefault;; 6110 ; 6111 if (InheritsFrom(TObject::Class())) {; 6112 kl->SetBit(kIsTObject);; 6113 ; 6114 // Is it DIRECT inheritance from TObject?; 6115 Int_t delta = kl->GetBaseClassOffsetRecurse(TObject::Class());; 6116 if (delta==0) kl->SetBit(kStartWithTObject);; 6117 ; 6118 kl->fStreamerType = kTObject;; 6119 kl->fStreamerImpl = &TClass::StreamerTObject;; 6120 }; 6121 ; 6122 if (HasInterpreterInfo()) {; 6123 ; 6124 // This code used to use ClassInfo_Has|IsValidMethod but since v6; 6125 // they return true if the routine is defined in the class or any of; 6126 // its parent. We explicitly want to know whether the function is; 6127 // defined locally.; 6128 if (!const_cast<TClass*>(this)->GetClassMethodWithPrototype(""Streamer"",""TBuffer&"",kFALSE)) {; 6129 ; 6130 kl->SetBit(kIsForeign);; 6131 kl->fStreamerType = kForeign;; 6132 kl->fStreamerImpl = &TClass::StreamerStreamerInfo;; 6133 ; 6134 } else if ( kl->fStreamerType == TClass::kDefault ) {; 6135 if (kl->fConvStreamerFunc) {; 6136 kl->fStreamerType = kInstrumented;; 6137 kl->fStreamerImpl = &TClass::ConvStreamerInstrumented;; 6138 } else if (kl->fStreamerFunc) {; 6139 kl->fStreamerType = kInstrumented;; 6140 kl->fStreamerImpl = &T",MatchSource.WIKI,doc/v632/TClass_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/TClass_8cxx_source.html
https://root.cern/doc/v632/TClass_8cxx_source.html:251400,Modifiability,variab,variable,251400,"k sum is built from the names/types of base classes and; 6528/// data members.; 6529/// Original algorithm from Victor Perevovchikov (perev@bnl.gov).; 6530///; 6531/// The valid range of code is determined by ECheckSum.; 6532///; 6533/// - kNoEnum: data members of type enum are not counted in the checksum; 6534/// - kNoRange: return the checksum of data members and base classes, not including the ranges and array size found in comments.; 6535/// - kWithTypeDef: use the sugared type name in the calculation.; 6536///; 6537/// This is needed for backward compatibility.; 6538///; 6539/// WARNING: this function must be kept in sync with TStreamerInfo::GetCheckSum.; 6540/// They are both used to handle backward compatibility and should both return the same values.; 6541/// TStreamerInfo uses the information in TStreamerElement while TClass uses the information; 6542/// from TClass::GetListOfBases and TClass::GetListOfDataMembers.; 6543 ; 6544UInt_t TClass::GetCheckSum(ECheckSum code, Bool_t &isvalid) const; 6545{; 6546 // fCheckSum is an atomic variable. Also once it has; 6547 // transition from a zero Value it never changes. If two; 6548 // thread reach past this if statement and calculated the; 6549 // 'kLastestCheckSum', they will by definition obtain the; 6550 // same value, so technically we could simply have:; 6551 // if (fCheckSum && code == kCurrentCheckSum) return fCheckSum;; 6552 // However save a little bit of barrier time by calling load(); 6553 // only once.; 6554 ; 6555 isvalid = kTRUE;; 6556 ; 6557 UInt_t currentChecksum = fCheckSum.load();; 6558 if (currentChecksum && code == kCurrentCheckSum) return currentChecksum;; 6559 ; 6560 R__LOCKGUARD(gInterpreterMutex);; 6561 ; 6562 // kCurrentCheckSum (0) is the default parameter value and should be kept; 6563 // for backward compatibility, too be able to use the inequality checks,; 6564 // we need to set the code to the largest value.; 6565 if (code == kCurrentCheckSum) code = kLatestCheckSum;; 6566 ; 6567 UInt_t",MatchSource.WIKI,doc/v632/TClass_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/TClass_8cxx_source.html
https://root.cern/doc/v632/TClass_8cxx_source.html:310505,Modifiability,inherit,inheritance,310505,"s::fStreamerFuncClassStreamerFunc_t fStreamerFuncDefinition TClass.h:241; TClass::AdoptReferenceProxyvoid AdoptReferenceProxy(TVirtualRefProxy *proxy)Adopt the Reference proxy pointer to indicate that this class represents a reference.Definition TClass.cxx:6685; TClass::GetClassMethodTMethod * GetClassMethod(Longptr_t faddr)Look for a method in this class that has the interface function address faddr.Definition TClass.cxx:4483; TClass::DetermineCurrentStreamerInfoTVirtualStreamerInfo * DetermineCurrentStreamerInfo()Determine and set pointer to current TVirtualStreamerInfo.Definition TClass.cxx:5684; TClass::Browsevoid Browse(TBrowser *b) overrideThis method is called by a browser to get the class information.Definition TClass.cxx:2010; TClass::GetStateEState GetState() constDefinition TClass.h:488; TClass::GetCollectionTypeROOT::ESTLType GetCollectionType() constReturn the 'type' of the STL the TClass is representing.Definition TClass.cxx:2886; TClass::Drawvoid Draw(Option_t *option="""") overrideDraw detailed class inheritance structure.Definition TClass.cxx:2487; TClass::AdoptMemberStreamervoid AdoptMemberStreamer(const char *name, TMemberStreamer *strm)Adopt the TMemberStreamer pointer to by p and use it to Stream non basic member name.Definition TClass.cxx:6703; TClass::ResetInstanceCountvoid ResetInstanceCount()Definition TClass.h:547; TClass::GetStreamerFuncClassStreamerFunc_t GetStreamerFunc() constGet a wrapper/accessor function around this class custom streamer (member function).Definition TClass.cxx:2939; TClass::RemoveStreamerInfovoid RemoveStreamerInfo(Int_t slot)Remove and delete the StreamerInfo in the given slot.Definition TClass.cxx:7320; TClass::SetCanSplitvoid SetCanSplit(Int_t splitmode)Set the splitability of this class:Definition TClass.cxx:5658; TClass::CreateListOfDataMembersTList * CreateListOfDataMembers(std::atomic< TListOfDataMembers * > &data, TDictionary::EMemberSelection selection, bool load)Create the list containing the TDataMembers (of ",MatchSource.WIKI,doc/v632/TClass_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/TClass_8cxx_source.html
https://root.cern/doc/v632/TClass_8cxx_source.html:318973,Modifiability,inherit,inherits,318973,"tCurrentStreamerInfoTVirtualStreamerInfo * GetCurrentStreamerInfo()Definition TClass.h:439; TClass::GetDirectoryAutoAddROOT::DirAutoAdd_t GetDirectoryAutoAdd() constReturn the wrapper around the directory auto add function.Definition TClass.cxx:7487; TClass::AddImplFilevoid AddImplFile(const char *filename, int line)Definition TClass.cxx:1952; TClass::GetListOfMethodOverloadsTCollection * GetListOfMethodOverloads(const char *name) constReturn the collection of functions named ""name"".Definition TClass.cxx:3827; TClass::fEnumsstd::atomic< TListOfEnums * > fEnumsDefinition TClass.h:205; TClass::HasNoInfoOrEmuOrFwdDeclaredDeclstatic Bool_t HasNoInfoOrEmuOrFwdDeclaredDecl(const char *)Definition TClass.cxx:3398; TClass::fOVRMutexTVirtualMutex * fOVRMutexDefinition TClass.h:342; TClass::GetListOfEnumsTList * GetListOfEnums(Bool_t load=kTRUE)Return a list containing the TEnums of a class.Definition TClass.cxx:3686; TClass::IsStartingWithTObjectBool_t IsStartingWithTObject() constReturns true if this class inherits from TObject and if the start of the TObject parts is at the very...Definition TClass.cxx:5929; TClass::GetListOfMethodsTList * GetListOfMethods(Bool_t load=kTRUE)Return list containing the TMethods of a class.Definition TClass.cxx:3812; TClass::TClassTClass()Internal, default constructor.Definition TClass.cxx:1065; TClass::fDeclFileLineShort_t fDeclFileLineDefinition TClass.h:215; TClass::GetNmethodsInt_t GetNmethods()Return the number of methods of this class Note that in case the list of methods is not yet created,...Definition TClass.cxx:4573; TClass::fIsOffsetStreamerSetstd::atomic< Bool_t > fIsOffsetStreamerSetIndicates whether the ClassInfo is supposed to be available.Definition TClass.h:261; TClass::IgnoreTObjectStreamervoid IgnoreTObjectStreamer(Bool_t ignore=kTRUE)When the class kIgnoreTObjectStreamer bit is set, the automatically generated Streamer will not call ...Definition TClass.cxx:4841; TClass::GetStreamerTClassStreamer * GetStreamer() constReturn",MatchSource.WIKI,doc/v632/TClass_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/TClass_8cxx_source.html
https://root.cern/doc/v632/TClass_8cxx_source.html:320328,Modifiability,inherit,inherited,320328,"ass.cxx:1065; TClass::fDeclFileLineShort_t fDeclFileLineDefinition TClass.h:215; TClass::GetNmethodsInt_t GetNmethods()Return the number of methods of this class Note that in case the list of methods is not yet created,...Definition TClass.cxx:4573; TClass::fIsOffsetStreamerSetstd::atomic< Bool_t > fIsOffsetStreamerSetIndicates whether the ClassInfo is supposed to be available.Definition TClass.h:261; TClass::IgnoreTObjectStreamervoid IgnoreTObjectStreamer(Bool_t ignore=kTRUE)When the class kIgnoreTObjectStreamer bit is set, the automatically generated Streamer will not call ...Definition TClass.cxx:4841; TClass::GetStreamerTClassStreamer * GetStreamer() constReturn the Streamer Class allowing streaming (if any).Definition TClass.cxx:2914; TClass::GetIdMapstatic IdMap_t * GetIdMap()Definition TClass.cxx:469; TClass::SetDeletevoid SetDelete(ROOT::DelFunc_t deleteFunc)Install a new wrapper around 'delete'.Definition TClass.cxx:7001; TClass::AutoBrowsestatic Int_t AutoBrowse(TObject *obj, TBrowser *browser)Browse external object inherited from TObject.Definition TClass.cxx:1966; TClass::GetNewROOT::NewFunc_t GetNew() constReturn the wrapper around new ThisClass().Definition TClass.cxx:7447; TClass::GetBaseClassTClass * GetBaseClass(const char *classname)Return pointer to the base class ""classname"".Definition TClass.cxx:2655; TClass::GetDataMemberOffsetLongptr_t GetDataMemberOffset(const char *membername) constreturn offset for member name.Definition TClass.cxx:3477; TClass::GetNdataInt_t GetNdata()Return the number of data members of this class Note that in case the list of data members is not yet...Definition TClass.cxx:4554; TClass::SetDestructorvoid SetDestructor(ROOT::DesFunc_t destructorFunc)Install a new wrapper around the destructor.Definition TClass.cxx:7017; TClass::PostLoadCheckvirtual void PostLoadCheck()Do the initialization that can only be done after the CINT dictionary has been fully populated and ca...Definition TClass.cxx:5959; TClass::LoadClassInfovoi",MatchSource.WIKI,doc/v632/TClass_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/TClass_8cxx_source.html
https://root.cern/doc/v632/TClass_8cxx_source.html:330414,Modifiability,inherit,inherits,330414,"std::type_info * fTypeInfoDefinition TClass.h:224; TClass::fLastReadInfostd::atomic< TVirtualStreamerInfo * > fLastReadInfocached current streamer info.Definition TClass.h:279; TClass::StreamerTObjectstatic void StreamerTObject(const TClass *pThis, void *object, TBuffer &b, const TClass *onfile_class)Case of TObjects.Definition TClass.cxx:6800; TClass::IsLoadedBool_t IsLoaded() constReturn true if the shared library of this class is currently in the a process's memory.Definition TClass.cxx:5912; TClass::kDefault@ kDefaultDefinition TClass.h:334; TClass::kEmulatedStreamer@ kEmulatedStreamerDefinition TClass.h:334; TClass::kExternal@ kExternalDefinition TClass.h:334; TClass::kForeign@ kForeignDefinition TClass.h:334; TClass::kInstrumented@ kInstrumentedDefinition TClass.h:334; TClass::kTObject@ kTObjectDefinition TClass.h:334; TClass::AddRulestatic Bool_t AddRule(const char *rule)Add a schema evolution customization rule.Definition TClass.cxx:1890; TClass::IsTObjectBool_t IsTObject() constReturn kTRUE is the class inherits from TObject.Definition TClass.cxx:5938; TClass::RemoveClassstatic void RemoveClass(TClass *cl)static: Remove a class from the list and map of classesDefinition TClass.cxx:520; TClass::HasLocalHashMemberBool_t HasLocalHashMember() constReturns true if this class has an definition and/or overload of the member function Hash.Definition TClass.cxx:7421; TClass::DeleteArrayvoid DeleteArray(void *ary, Bool_t dtorOnly=kFALSE)Explicitly call operator delete[] for an array.Definition TClass.cxx:5529; TClass::GetConvStreamerFuncClassConvStreamerFunc_t GetConvStreamerFunc() constGet a wrapper/accessor function around this class custom conversion streamer (member function).Definition TClass.cxx:2947; TClass::IsForeignBool_t IsForeign() constReturn kTRUE is the class is Foreign (the class does not have a Streamer method).Definition TClass.cxx:5947; TClass::GetClassInfoClassInfo_t * GetClassInfo() constDefinition TClass.h:433; TClass::fDeleteROOT::DelFunc_t fDele",MatchSource.WIKI,doc/v632/TClass_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/TClass_8cxx_source.html
https://root.cern/doc/v632/TClass_8cxx_source.html:331938,Modifiability,inherit,inheritance,331938,"delete[] for an array.Definition TClass.cxx:5529; TClass::GetConvStreamerFuncClassConvStreamerFunc_t GetConvStreamerFunc() constGet a wrapper/accessor function around this class custom conversion streamer (member function).Definition TClass.cxx:2947; TClass::IsForeignBool_t IsForeign() constReturn kTRUE is the class is Foreign (the class does not have a Streamer method).Definition TClass.cxx:5947; TClass::GetClassInfoClassInfo_t * GetClassInfo() constDefinition TClass.h:433; TClass::fDeleteROOT::DelFunc_t fDeleteDefinition TClass.h:237; TClass::fAllPubDataTViewPubDataMembers * fAllPubDataDefinition TClass.h:209; TClass::fClassInfoClassInfo_t * fClassInfoDefinition TClass.h:222; TClass::GetStreamerInfoTVirtualStreamerInfo * GetStreamerInfo(Int_t version=0, Bool_t isTransient=kFALSE) constreturns a pointer to the TVirtualStreamerInfo object for version If the object does not exist,...Definition TClass.cxx:4599; TClass::HasConsistentHashMemberBool_t HasConsistentHashMember()Return 'true' if we can guarantee that if this class (or any class in this class inheritance hierarch...Definition TClass.h:501; TClass::AdoptStreamervoid AdoptStreamer(TClassStreamer *strm)Adopt a TClassStreamer object.Definition TClass.cxx:6894; TClass::GetBaseDataMemberTClass * GetBaseDataMember(const char *datamember)Return pointer to (base) class that contains datamember.Definition TClass.cxx:2827; TClass::ECheckSumECheckSumDefinition TClass.h:108; TClass::kLatestCheckSum@ kLatestCheckSumDefinition TClass.h:117; TClass::kNoRange@ kNoRangeDefinition TClass.h:112; TClass::kCurrentCheckSum@ kCurrentCheckSumDefinition TClass.h:109; TClass::kNoBaseCheckSum@ kNoBaseCheckSumDefinition TClass.h:116; TClass::kReflex@ kReflexDefinition TClass.h:114; TClass::kReflexNoComment@ kReflexNoCommentDefinition TClass.h:111; TClass::kWithTypeDef@ kWithTypeDefDefinition TClass.h:113; TClass::kNoRangeCheck@ kNoRangeCheckDefinition TClass.h:115; TClass::kNoEnum@ kNoEnumDefinition TClass.h:110; TClass::Dumpvoid Dump() ",MatchSource.WIKI,doc/v632/TClass_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/TClass_8cxx_source.html
https://root.cern/doc/v632/TClass_8cxx_source.html:333042,Modifiability,inherit,inherits,333042,"AdoptStreamer(TClassStreamer *strm)Adopt a TClassStreamer object.Definition TClass.cxx:6894; TClass::GetBaseDataMemberTClass * GetBaseDataMember(const char *datamember)Return pointer to (base) class that contains datamember.Definition TClass.cxx:2827; TClass::ECheckSumECheckSumDefinition TClass.h:108; TClass::kLatestCheckSum@ kLatestCheckSumDefinition TClass.h:117; TClass::kNoRange@ kNoRangeDefinition TClass.h:112; TClass::kCurrentCheckSum@ kCurrentCheckSumDefinition TClass.h:109; TClass::kNoBaseCheckSum@ kNoBaseCheckSumDefinition TClass.h:116; TClass::kReflex@ kReflexDefinition TClass.h:114; TClass::kReflexNoComment@ kReflexNoCommentDefinition TClass.h:111; TClass::kWithTypeDef@ kWithTypeDefDefinition TClass.h:113; TClass::kNoRangeCheck@ kNoRangeCheckDefinition TClass.h:115; TClass::kNoEnum@ kNoEnumDefinition TClass.h:110; TClass::Dumpvoid Dump() const overrideDump contents of object on stdout.Definition TClass.h:398; TClass::InheritsFromBool_t InheritsFrom(const char *cl) const overrideReturn kTRUE if this class inherits from a class with name ""classname"".Definition TClass.cxx:4874; TClass::GetBaseClassOffsetInt_t GetBaseClassOffset(const TClass *toBase, void *address=nullptr, bool isDerivedObject=true)Definition TClass.cxx:2791; TClass::NewObjectArrayObjectPtr NewObjectArray(Long_t nElements, ENewType defConstructor=kClassNew) constReturn a pointer to a newly allocated array of objects of this class.Definition TClass.cxx:5209; TClass::GetCollectionProxyTVirtualCollectionProxy * GetCollectionProxy() constReturn the proxy describing the collection (if any).Definition TClass.cxx:2897; TClass::ResetCachesvoid ResetCaches()To clean out all caches.Definition TClass.cxx:4215; TClass::fVersionUsedstd::atomic< Bool_t > fVersionUsedsaved remember if fOffsetStreamer has been set.Definition TClass.h:262; TClass::ClassPropertyLong_t ClassProperty() constReturn the C++ property of this class, eg.Definition TClass.cxx:2396; TClass::SetStreamerImplvoid SetStreamerImpl()Internal ",MatchSource.WIKI,doc/v632/TClass_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/TClass_8cxx_source.html
https://root.cern/doc/v632/TClass_8cxx_source.html:376675,Modifiability,portab,portable,376675,"n Rtypes.h:112; ROOT::NewFunc_tvoid *(* NewFunc_t)(void *)Definition Rtypes.h:109; ROOT::MergeFunc_tLong64_t(* MergeFunc_t)(void *, TCollection *, TFileMergeInfo *)Definition Rtypes.h:115; TClassEdit::IsStdPairBasebool IsStdPairBase(std::string_view name)Definition TClassEdit.h:188; TClassEdit::ResolveTypedefstd::string ResolveTypedef(const char *tname, bool resolveAll=false)Definition TClassEdit.cxx:1748; TClassEdit::IsStdArraybool IsStdArray(std::string_view name)Definition TClassEdit.h:183; TClassEdit::IsStdClassbool IsStdClass(const char *type)return true if the class belongs to the std namespaceDefinition TClassEdit.cxx:1418; TClassEdit::IsStdPairbool IsStdPair(std::string_view name)Definition TClassEdit.h:184; TClassEdit::IsInterpreterDetailbool IsInterpreterDetail(const char *type)Return true if the type is one the interpreter details which are only forward declared (ClassInfo_t e...Definition TClassEdit.cxx:1322; TClassEdit::DemangleTypeIdNamechar * DemangleTypeIdName(const std::type_info &ti, int &errorCode)Demangle in a portable way the type id name.Definition TClassEdit.cxx:2147; TClassEdit::IsSTLContROOT::ESTLType IsSTLCont(std::string_view type)type : type name: vector<list<classA,allocator>,allocator> result: 0 : not stl container code of cont...Definition TClassEdit.cxx:1378; TClassEdit::ShortTypestd::string ShortType(const char *typeDesc, int mode)Return the absolute type of typeDesc.Definition TClassEdit.cxx:1305; TClassEdit::IsArtificialbool IsArtificial(std::string_view name)Definition TClassEdit.h:159; TClassEdit::GetNormalizedNamevoid GetNormalizedName(std::string &norm_name, std::string_view name)Return the normalized name.Definition TClassEdit.cxx:854; TClassEdit::kDropTrailStar@ kDropTrailStarDefinition TClassEdit.h:77; TClassEdit::kDropStlDefault@ kDropStlDefaultDefinition TClassEdit.h:82; TClassEdit::IsSTLBitsetbool IsSTLBitset(const char *type)Return true is the name is std::bitset<number> or bitset<number>Definition TClassEdit.cxx:1340; TM",MatchSource.WIKI,doc/v632/TClass_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/TClass_8cxx_source.html
https://root.cern/doc/v632/TClass_8cxx_source.html:1403,Performance,perform,perform,1403," Fons Rademakers. *; 6 * All rights reserved. *; 7 * *; 8 * For the licensing terms see $ROOTSYS/LICENSE. *; 9 * For the list of contributors see $ROOTSYS/README/CREDITS. *; 10 *************************************************************************/; 11 ; 12/** \class TClass; 13TClass instances represent classes, structs and namespaces in the ROOT type system.; 14 ; 15TClass instances are created starting from different sources of information:; 161. TStreamerInfo instances saved in a ROOT file which is opened. This is called in jargon an *emulated TClass*.; 172. From TProtoClass instances saved in a ROOT pcm file created by the dictionary generator and the dictionary itself.; 183. From a lookup in the AST built by cling.; 19 ; 20If a TClass instance is built through the mechanisms 1. and 2., it does not contain information about methods of the; 21class/struct/namespace it represents. Conversely, if built through 3. or 1., it does not carry the information which is necessary; 22to ROOT to perform I/O of instances of the class/struct it represents.; 23The mechanisms 1., 2. and 3. are not mutually exclusive: it can happen that during the execution of the program, all; 24the three are triggered, modifying the state of the TClass instance.; 25 ; 26In order to retrieve a TClass instance from the type system, a query can be executed as follows through the static; 27TClass::GetClass method:; 28 ; 29~~~ {.cpp}; 30auto myClassTClass_0 = TClass::GetClass(""myClass"");; 31auto myClassTClass_1 = TClass::GetClass<myClass>();; 32auto myClassTClass_2 = TClass::GetClass(myClassTypeInfo);; 33~~~; 34 ; 35The name of classes is crucial for ROOT. A careful procedure of *name normalization* is carried out for; 36each and every class. A *normalized name* is a valid C++ class name.; 37In order to access the name of a class within the ROOT type system, the method TClass::GetName() can be used.; 38*/; 39 ; 40//*-*x7.5 macros/layout_class; 41 ; 42#include ""TClass.h""; 43 ; 44#include ""strlcpy.",MatchSource.WIKI,doc/v632/TClass_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/TClass_8cxx_source.html
https://root.cern/doc/v632/TClass_8cxx_source.html:21131,Performance,load,loaded,21131,"sient) override;; 561};; 562 ; 563////////////////////////////////////////////////////////////////////////////////; 564/// Print value of member mname.; 565///; 566/// This method is called by the ShowMembers() method for each; 567/// data member when object.Dump() is invoked.; 568///; 569/// - cl is the pointer to the current class; 570/// - pname is the parent name (in case of composed objects); 571/// - mname is the data member name; 572/// - add is the data member address; 573 ; 574void TDumpMembers::Inspect(TClass *cl, const char *pname, const char *mname, const void *add, Bool_t /* isTransient */); 575{; 576 const Int_t kvalue = 30;; 577#ifdef R__B64; 578 const Int_t ktitle = 50;; 579#else; 580 const Int_t ktitle = 42;; 581#endif; 582 const Int_t kline = 1024;; 583 Int_t cdate = 0;; 584 Int_t ctime = 0;; 585 UInt_t *cdatime = nullptr;; 586 char line[kline];; 587 ; 588 TDataType *membertype;; 589 EDataType memberDataType = kNoType_t;; 590 const char *memberName;; 591 const char *memberFullTypeName;; 592 const char *memberTitle;; 593 Bool_t isapointer;; 594 Bool_t isbasic;; 595 Bool_t isarray;; 596 ; 597 if (TDataMember *member = cl->GetDataMember(mname)) {; 598 if (member->GetDataType()) {; 599 memberDataType = (EDataType)member->GetDataType()->GetType();; 600 }; 601 memberName = member->GetName();; 602 memberFullTypeName = member->GetFullTypeName();; 603 memberTitle = member->GetTitle();; 604 isapointer = member->IsaPointer();; 605 isbasic = member->IsBasic();; 606 membertype = member->GetDataType();; 607 isarray = member->GetArrayDim();; 608 } else if (!cl->IsLoaded()) {; 609 // The class is not loaded, hence it is 'emulated' and the main source of; 610 // information is the StreamerInfo.; 611 TVirtualStreamerInfo *info = cl->GetStreamerInfo();; 612 if (!info) return;; 613 const char *cursor = mname;; 614 while ( (*cursor)=='*' ) ++cursor;; 615 TString elname( cursor );; 616 Ssiz_t pos = elname.Index(""["");; 617 if ( pos != kNPOS ) {; 618 elname.Remove( pos );;",MatchSource.WIKI,doc/v632/TClass_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/TClass_8cxx_source.html
https://root.cern/doc/v632/TClass_8cxx_source.html:56305,Performance,load,loading,56305,"ed to force a call to BuildOld; 1437 info->Clear(""build"");; 1438 info->SetClass(this);; 1439 fStreamerInfo->AddAtAndExpand(info,info->GetClassVersion());; 1440 }; 1441 oldcl->fStreamerInfo->Clear();; 1442 // The code diverges here from ForceReload.; 1443 ; 1444 // Move the Schema Rules too.; 1445 fSchemaRules = oldcl->fSchemaRules;; 1446 oldcl->fSchemaRules = nullptr;; 1447 ; 1448 // Move the TFunctions.; 1449 fFuncTemplate = oldcl->fFuncTemplate;; 1450 if (fFuncTemplate); 1451 fFuncTemplate->fClass = this;; 1452 oldcl->fFuncTemplate = nullptr;; 1453 fMethod.store( oldcl->fMethod );; 1454 if (fMethod); 1455 (*fMethod).fClass = this;; 1456 oldcl->fMethod = nullptr;; 1457 ; 1458 }; 1459 ; 1460 SetBit(kLoading);; 1461 // Advertise ourself as the loading class for this class name; 1462 TClass::AddClass(this);; 1463 ; 1464 Bool_t isStl = TClassEdit::IsSTLCont(fName);; 1465 ; 1466 if (!gInterpreter); 1467 ::Fatal(""TClass::Init"", ""gInterpreter not initialized"");; 1468 ; 1469 if (givenInfo) {; 1470 bool invalid = !gInterpreter->ClassInfo_IsValid(givenInfo);; 1471 bool notloaded = !gInterpreter->ClassInfo_IsLoaded(givenInfo);; 1472 auto property = gInterpreter->ClassInfo_Property(givenInfo);; 1473 ; 1474 if (invalid || (notloaded && (property & kIsNamespace)) ||; 1475 !(property & (kIsClass | kIsStruct | kIsNamespace))) {; 1476 if (!TClassEdit::IsSTLCont(fName.Data())) {; 1477 MakeZombie();; 1478 fState = kNoInfo;; 1479 TClass::RemoveClass(this);; 1480 return;; 1481 }; 1482 }; 1483 ; 1484 if (!invalid) {; 1485 fClassInfo = gInterpreter->ClassInfo_Factory(givenInfo);; 1486 fCanLoadClassInfo = false; // avoids calls to LoadClassInfo() if info is already loaded; 1487 if (fState <= kEmulated); 1488 fState = kInterpreted;; 1489 }; 1490 }; 1491 ; 1492 // We need to check if the class it is not fwd declared for the cases where we; 1493 // created a TClass directly in the kForwardDeclared state. Indeed in those cases; 1494 // fClassInfo will always be nullptr.; 1495 if (fState!=kFor",MatchSource.WIKI,doc/v632/TClass_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/TClass_8cxx_source.html
https://root.cern/doc/v632/TClass_8cxx_source.html:57223,Performance,load,loaded,57223,"1456 oldcl->fMethod = nullptr;; 1457 ; 1458 }; 1459 ; 1460 SetBit(kLoading);; 1461 // Advertise ourself as the loading class for this class name; 1462 TClass::AddClass(this);; 1463 ; 1464 Bool_t isStl = TClassEdit::IsSTLCont(fName);; 1465 ; 1466 if (!gInterpreter); 1467 ::Fatal(""TClass::Init"", ""gInterpreter not initialized"");; 1468 ; 1469 if (givenInfo) {; 1470 bool invalid = !gInterpreter->ClassInfo_IsValid(givenInfo);; 1471 bool notloaded = !gInterpreter->ClassInfo_IsLoaded(givenInfo);; 1472 auto property = gInterpreter->ClassInfo_Property(givenInfo);; 1473 ; 1474 if (invalid || (notloaded && (property & kIsNamespace)) ||; 1475 !(property & (kIsClass | kIsStruct | kIsNamespace))) {; 1476 if (!TClassEdit::IsSTLCont(fName.Data())) {; 1477 MakeZombie();; 1478 fState = kNoInfo;; 1479 TClass::RemoveClass(this);; 1480 return;; 1481 }; 1482 }; 1483 ; 1484 if (!invalid) {; 1485 fClassInfo = gInterpreter->ClassInfo_Factory(givenInfo);; 1486 fCanLoadClassInfo = false; // avoids calls to LoadClassInfo() if info is already loaded; 1487 if (fState <= kEmulated); 1488 fState = kInterpreted;; 1489 }; 1490 }; 1491 ; 1492 // We need to check if the class it is not fwd declared for the cases where we; 1493 // created a TClass directly in the kForwardDeclared state. Indeed in those cases; 1494 // fClassInfo will always be nullptr.; 1495 if (fState!=kForwardDeclared && !fClassInfo && !TClassEdit::IsArtificial(fName)) {; 1496 ; 1497 if (fState == kHasTClassInit) {; 1498 // If the TClass is being generated from a ROOT dictionary,; 1499 // even though we do not seem to have a CINT dictionary for; 1500 // the class, we will will try to load it anyway UNLESS; 1501 // the class is an STL container (or string).; 1502 // This is because we do not expect the CINT dictionary; 1503 // to be present for all STL classes (and we can handle; 1504 // the lack of CINT dictionary in that cases).; 1505 // However, the cling the dictionary no longer carries; 1506 // an instantiation with it, unless we re",MatchSource.WIKI,doc/v632/TClass_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/TClass_8cxx_source.html
https://root.cern/doc/v632/TClass_8cxx_source.html:57836,Performance,load,load,57836,"er->ClassInfo_Property(givenInfo);; 1473 ; 1474 if (invalid || (notloaded && (property & kIsNamespace)) ||; 1475 !(property & (kIsClass | kIsStruct | kIsNamespace))) {; 1476 if (!TClassEdit::IsSTLCont(fName.Data())) {; 1477 MakeZombie();; 1478 fState = kNoInfo;; 1479 TClass::RemoveClass(this);; 1480 return;; 1481 }; 1482 }; 1483 ; 1484 if (!invalid) {; 1485 fClassInfo = gInterpreter->ClassInfo_Factory(givenInfo);; 1486 fCanLoadClassInfo = false; // avoids calls to LoadClassInfo() if info is already loaded; 1487 if (fState <= kEmulated); 1488 fState = kInterpreted;; 1489 }; 1490 }; 1491 ; 1492 // We need to check if the class it is not fwd declared for the cases where we; 1493 // created a TClass directly in the kForwardDeclared state. Indeed in those cases; 1494 // fClassInfo will always be nullptr.; 1495 if (fState!=kForwardDeclared && !fClassInfo && !TClassEdit::IsArtificial(fName)) {; 1496 ; 1497 if (fState == kHasTClassInit) {; 1498 // If the TClass is being generated from a ROOT dictionary,; 1499 // even though we do not seem to have a CINT dictionary for; 1500 // the class, we will will try to load it anyway UNLESS; 1501 // the class is an STL container (or string).; 1502 // This is because we do not expect the CINT dictionary; 1503 // to be present for all STL classes (and we can handle; 1504 // the lack of CINT dictionary in that cases).; 1505 // However, the cling the dictionary no longer carries; 1506 // an instantiation with it, unless we request the loading; 1507 // here *or* the user explicitly instantiate the template; 1508 // we would not have a ClassInfo for the template; 1509 // instantiation.; 1510 fCanLoadClassInfo = kTRUE;; 1511 // Here we check and grab the info from the rootpcm.; 1512 TProtoClass *proto = TClassTable::GetProtoNorm(GetName());; 1513 if (proto); 1514 proto->FillTClass(this);; 1515 }; 1516 if (!fHasRootPcmInfo && gInterpreter->CheckClassInfo(fName, /* autoload = */ kTRUE)) {; 1517 gInterpreter->SetClassInfo(this, kFALSE, silent); ",MatchSource.WIKI,doc/v632/TClass_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/TClass_8cxx_source.html
https://root.cern/doc/v632/TClass_8cxx_source.html:58205,Performance,load,loading,58205,"y loaded; 1487 if (fState <= kEmulated); 1488 fState = kInterpreted;; 1489 }; 1490 }; 1491 ; 1492 // We need to check if the class it is not fwd declared for the cases where we; 1493 // created a TClass directly in the kForwardDeclared state. Indeed in those cases; 1494 // fClassInfo will always be nullptr.; 1495 if (fState!=kForwardDeclared && !fClassInfo && !TClassEdit::IsArtificial(fName)) {; 1496 ; 1497 if (fState == kHasTClassInit) {; 1498 // If the TClass is being generated from a ROOT dictionary,; 1499 // even though we do not seem to have a CINT dictionary for; 1500 // the class, we will will try to load it anyway UNLESS; 1501 // the class is an STL container (or string).; 1502 // This is because we do not expect the CINT dictionary; 1503 // to be present for all STL classes (and we can handle; 1504 // the lack of CINT dictionary in that cases).; 1505 // However, the cling the dictionary no longer carries; 1506 // an instantiation with it, unless we request the loading; 1507 // here *or* the user explicitly instantiate the template; 1508 // we would not have a ClassInfo for the template; 1509 // instantiation.; 1510 fCanLoadClassInfo = kTRUE;; 1511 // Here we check and grab the info from the rootpcm.; 1512 TProtoClass *proto = TClassTable::GetProtoNorm(GetName());; 1513 if (proto); 1514 proto->FillTClass(this);; 1515 }; 1516 if (!fHasRootPcmInfo && gInterpreter->CheckClassInfo(fName, /* autoload = */ kTRUE)) {; 1517 gInterpreter->SetClassInfo(this, kFALSE, silent); // sets fClassInfo pointer; 1518 if (fClassInfo) {; 1519 // This should be moved out of GetCheckSum itself however the last time; 1520 // we tried this cause problem, in particular in the end-of-process operation.; 1521 // fCheckSum = GetCheckSum(kLatestCheckSum);; 1522 } else {; 1523 if (!fClassInfo) {; 1524 if (IsZombie()) {; 1525 TClass::RemoveClass(this);; 1526 return;; 1527 }; 1528 }; 1529 }; 1530 }; 1531 }; 1532 if (!silent && (!fClassInfo && !fCanLoadClassInfo) && !isStl && !TClassEdit::IsA",MatchSource.WIKI,doc/v632/TClass_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/TClass_8cxx_source.html
https://root.cern/doc/v632/TClass_8cxx_source.html:62596,Performance,load,loaded,62596," fgClassTypedefHash) {; 1592 ; 1593 // Check for existing equivalent.; 1594 ; 1595 if (resolvedThis != fName) {; 1596 oldcl = (TClass*)gROOT->GetListOfClasses()->FindObject(resolvedThis);; 1597 if (oldcl && oldcl != this) {; 1598 persistentRef = oldcl->fPersistentRef.exchange(nullptr);; 1599 ForceReload (oldcl);; 1600 }; 1601 }; 1602 TIter next( fgClassTypedefHash->GetListForObject(resolvedThis) );; 1603 while ( TNameMapNode* htmp = static_cast<TNameMapNode*> (next()) ) {; 1604 if (resolvedThis != htmp->String()) continue;; 1605 oldcl = (TClass*)gROOT->GetListOfClasses()->FindObject(htmp->fOrigName); // gROOT->GetClass (htmp->fOrigName, kFALSE);; 1606 if (oldcl && oldcl != this) {; 1607 persistentRef = oldcl->fPersistentRef.exchange(nullptr);; 1608 ForceReload (oldcl);; 1609 }; 1610 }; 1611 }; 1612 if (fClassInfo) {; 1613 SetTitle(gCling->ClassInfo_Title(fClassInfo));; 1614 if ( fDeclFileName == nullptr || fDeclFileName[0] == '\0' ) {; 1615 fDeclFileName = kUndeterminedClassInfoName;; 1616 // Missing interface:; 1617 // fDeclFileLine = gInterpreter->ClassInfo_FileLine( fClassInfo );; 1618 ; 1619 // But really do not want to set ImplFileLine as it is currently the; 1620 // marker of being 'loaded' or not (reminder loaded == has a TClass bootstrap).; 1621 }; 1622 }; 1623 ; 1624 if (persistentRef) {; 1625 fPersistentRef = persistentRef;; 1626 } else {; 1627 fPersistentRef = new TClass*;; 1628 }; 1629 *fPersistentRef = this;; 1630 ; 1631 if ( isStl || !strncmp(GetName(),""stdext::hash_"",13) || !strncmp(GetName(),""__gnu_cxx::hash_"",16) ) {; 1632 if (fState != kHasTClassInit) {; 1633 // If we have a TClass compiled initialization, we can safely assume that; 1634 // there will also be a collection proxy.; 1635 fCollectionProxy = TVirtualStreamerInfo::Factory()->GenEmulatedProxy( GetName(), silent );; 1636 if (fCollectionProxy) {; 1637 fSizeof = fCollectionProxy->Sizeof();; 1638 ; 1639 // Numeric Collections have implicit conversions:; 1640 GetSchemaRules(kTRUE);; 1641 ; 1642",MatchSource.WIKI,doc/v632/TClass_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/TClass_8cxx_source.html
https://root.cern/doc/v632/TClass_8cxx_source.html:62621,Performance,load,loaded,62621," fgClassTypedefHash) {; 1592 ; 1593 // Check for existing equivalent.; 1594 ; 1595 if (resolvedThis != fName) {; 1596 oldcl = (TClass*)gROOT->GetListOfClasses()->FindObject(resolvedThis);; 1597 if (oldcl && oldcl != this) {; 1598 persistentRef = oldcl->fPersistentRef.exchange(nullptr);; 1599 ForceReload (oldcl);; 1600 }; 1601 }; 1602 TIter next( fgClassTypedefHash->GetListForObject(resolvedThis) );; 1603 while ( TNameMapNode* htmp = static_cast<TNameMapNode*> (next()) ) {; 1604 if (resolvedThis != htmp->String()) continue;; 1605 oldcl = (TClass*)gROOT->GetListOfClasses()->FindObject(htmp->fOrigName); // gROOT->GetClass (htmp->fOrigName, kFALSE);; 1606 if (oldcl && oldcl != this) {; 1607 persistentRef = oldcl->fPersistentRef.exchange(nullptr);; 1608 ForceReload (oldcl);; 1609 }; 1610 }; 1611 }; 1612 if (fClassInfo) {; 1613 SetTitle(gCling->ClassInfo_Title(fClassInfo));; 1614 if ( fDeclFileName == nullptr || fDeclFileName[0] == '\0' ) {; 1615 fDeclFileName = kUndeterminedClassInfoName;; 1616 // Missing interface:; 1617 // fDeclFileLine = gInterpreter->ClassInfo_FileLine( fClassInfo );; 1618 ; 1619 // But really do not want to set ImplFileLine as it is currently the; 1620 // marker of being 'loaded' or not (reminder loaded == has a TClass bootstrap).; 1621 }; 1622 }; 1623 ; 1624 if (persistentRef) {; 1625 fPersistentRef = persistentRef;; 1626 } else {; 1627 fPersistentRef = new TClass*;; 1628 }; 1629 *fPersistentRef = this;; 1630 ; 1631 if ( isStl || !strncmp(GetName(),""stdext::hash_"",13) || !strncmp(GetName(),""__gnu_cxx::hash_"",16) ) {; 1632 if (fState != kHasTClassInit) {; 1633 // If we have a TClass compiled initialization, we can safely assume that; 1634 // there will also be a collection proxy.; 1635 fCollectionProxy = TVirtualStreamerInfo::Factory()->GenEmulatedProxy( GetName(), silent );; 1636 if (fCollectionProxy) {; 1637 fSizeof = fCollectionProxy->Sizeof();; 1638 ; 1639 // Numeric Collections have implicit conversions:; 1640 GetSchemaRules(kTRUE);; 1641 ; 1642",MatchSource.WIKI,doc/v632/TClass_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/TClass_8cxx_source.html
https://root.cern/doc/v632/TClass_8cxx_source.html:64966,Performance,load,load,64966,"en created.; 1659 ; 1660TClass::~TClass(); 1661{; 1662 R__LOCKGUARD(gInterpreterMutex);; 1663 ; 1664 // Remove from the typedef hashtables.; 1665 if (fgClassTypedefHash && TestBit (kHasNameMapNode)) {; 1666 TString resolvedThis = TClassEdit::ResolveTypedef (GetName(), kTRUE);; 1667 TIter next (fgClassTypedefHash->GetListForObject (resolvedThis));; 1668 while ( TNameMapNode* htmp = static_cast<TNameMapNode*> (next()) ) {; 1669 if (resolvedThis == htmp->String() && htmp->fOrigName == GetName()) {; 1670 fgClassTypedefHash->Remove (htmp);; 1671 delete htmp;; 1672 break;; 1673 }; 1674 }; 1675 }; 1676 ; 1677 // Not owning lists, don't call Delete(); 1678 // But this still need to be done first because the TList destructor; 1679 // does access the object contained (via GetObject()->TestBit(kCanDelete)); 1680 delete fStreamer; fStreamer =nullptr;; 1681 delete fAllPubData; fAllPubData =nullptr;; 1682 delete fAllPubMethod; fAllPubMethod=nullptr;; 1683 ; 1684 delete fPersistentRef.load();; 1685 ; 1686 if (fBase.load()); 1687 (*fBase).Delete();; 1688 delete fBase.load(); fBase = nullptr;; 1689 ; 1690 if (fData.load()); 1691 (*fData).Delete();; 1692 delete fData.load(); fData = nullptr;; 1693 ; 1694 if (fUsingData.load()); 1695 (*fUsingData).Delete();; 1696 delete fUsingData.load(); fUsingData = nullptr;; 1697 ; 1698 if (fEnums.load()); 1699 (*fEnums).Delete();; 1700 delete fEnums.load(); fEnums = nullptr;; 1701 ; 1702 if (fFuncTemplate); 1703 fFuncTemplate->Delete();; 1704 delete fFuncTemplate; fFuncTemplate = nullptr;; 1705 ; 1706 if (fMethod.load()); 1707 (*fMethod).Delete();; 1708 delete fMethod.load(); fMethod=nullptr;; 1709 ; 1710 if (fRealData); 1711 fRealData->Delete();; 1712 delete fRealData; fRealData=nullptr;; 1713 ; 1714 if (fStreamerInfo); 1715 fStreamerInfo->Delete();; 1716 delete fStreamerInfo; fStreamerInfo = nullptr;; 1717 ; 1718 if (fDeclFileLine >= -1); 1719 TClass::RemoveClass(this);; 1720 ; 1721 gCling->ClassInfo_Delete(fClassInfo);; 1722 fClassInfo=nullptr;;",MatchSource.WIKI,doc/v632/TClass_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/TClass_8cxx_source.html
https://root.cern/doc/v632/TClass_8cxx_source.html:64997,Performance,load,load,64997,"ass::~TClass(); 1661{; 1662 R__LOCKGUARD(gInterpreterMutex);; 1663 ; 1664 // Remove from the typedef hashtables.; 1665 if (fgClassTypedefHash && TestBit (kHasNameMapNode)) {; 1666 TString resolvedThis = TClassEdit::ResolveTypedef (GetName(), kTRUE);; 1667 TIter next (fgClassTypedefHash->GetListForObject (resolvedThis));; 1668 while ( TNameMapNode* htmp = static_cast<TNameMapNode*> (next()) ) {; 1669 if (resolvedThis == htmp->String() && htmp->fOrigName == GetName()) {; 1670 fgClassTypedefHash->Remove (htmp);; 1671 delete htmp;; 1672 break;; 1673 }; 1674 }; 1675 }; 1676 ; 1677 // Not owning lists, don't call Delete(); 1678 // But this still need to be done first because the TList destructor; 1679 // does access the object contained (via GetObject()->TestBit(kCanDelete)); 1680 delete fStreamer; fStreamer =nullptr;; 1681 delete fAllPubData; fAllPubData =nullptr;; 1682 delete fAllPubMethod; fAllPubMethod=nullptr;; 1683 ; 1684 delete fPersistentRef.load();; 1685 ; 1686 if (fBase.load()); 1687 (*fBase).Delete();; 1688 delete fBase.load(); fBase = nullptr;; 1689 ; 1690 if (fData.load()); 1691 (*fData).Delete();; 1692 delete fData.load(); fData = nullptr;; 1693 ; 1694 if (fUsingData.load()); 1695 (*fUsingData).Delete();; 1696 delete fUsingData.load(); fUsingData = nullptr;; 1697 ; 1698 if (fEnums.load()); 1699 (*fEnums).Delete();; 1700 delete fEnums.load(); fEnums = nullptr;; 1701 ; 1702 if (fFuncTemplate); 1703 fFuncTemplate->Delete();; 1704 delete fFuncTemplate; fFuncTemplate = nullptr;; 1705 ; 1706 if (fMethod.load()); 1707 (*fMethod).Delete();; 1708 delete fMethod.load(); fMethod=nullptr;; 1709 ; 1710 if (fRealData); 1711 fRealData->Delete();; 1712 delete fRealData; fRealData=nullptr;; 1713 ; 1714 if (fStreamerInfo); 1715 fStreamerInfo->Delete();; 1716 delete fStreamerInfo; fStreamerInfo = nullptr;; 1717 ; 1718 if (fDeclFileLine >= -1); 1719 TClass::RemoveClass(this);; 1720 ; 1721 gCling->ClassInfo_Delete(fClassInfo);; 1722 fClassInfo=nullptr;; 1723 ; 1724 if (fClassMenu",MatchSource.WIKI,doc/v632/TClass_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/TClass_8cxx_source.html
https://root.cern/doc/v632/TClass_8cxx_source.html:65049,Performance,load,load,65049,"3 ; 1664 // Remove from the typedef hashtables.; 1665 if (fgClassTypedefHash && TestBit (kHasNameMapNode)) {; 1666 TString resolvedThis = TClassEdit::ResolveTypedef (GetName(), kTRUE);; 1667 TIter next (fgClassTypedefHash->GetListForObject (resolvedThis));; 1668 while ( TNameMapNode* htmp = static_cast<TNameMapNode*> (next()) ) {; 1669 if (resolvedThis == htmp->String() && htmp->fOrigName == GetName()) {; 1670 fgClassTypedefHash->Remove (htmp);; 1671 delete htmp;; 1672 break;; 1673 }; 1674 }; 1675 }; 1676 ; 1677 // Not owning lists, don't call Delete(); 1678 // But this still need to be done first because the TList destructor; 1679 // does access the object contained (via GetObject()->TestBit(kCanDelete)); 1680 delete fStreamer; fStreamer =nullptr;; 1681 delete fAllPubData; fAllPubData =nullptr;; 1682 delete fAllPubMethod; fAllPubMethod=nullptr;; 1683 ; 1684 delete fPersistentRef.load();; 1685 ; 1686 if (fBase.load()); 1687 (*fBase).Delete();; 1688 delete fBase.load(); fBase = nullptr;; 1689 ; 1690 if (fData.load()); 1691 (*fData).Delete();; 1692 delete fData.load(); fData = nullptr;; 1693 ; 1694 if (fUsingData.load()); 1695 (*fUsingData).Delete();; 1696 delete fUsingData.load(); fUsingData = nullptr;; 1697 ; 1698 if (fEnums.load()); 1699 (*fEnums).Delete();; 1700 delete fEnums.load(); fEnums = nullptr;; 1701 ; 1702 if (fFuncTemplate); 1703 fFuncTemplate->Delete();; 1704 delete fFuncTemplate; fFuncTemplate = nullptr;; 1705 ; 1706 if (fMethod.load()); 1707 (*fMethod).Delete();; 1708 delete fMethod.load(); fMethod=nullptr;; 1709 ; 1710 if (fRealData); 1711 fRealData->Delete();; 1712 delete fRealData; fRealData=nullptr;; 1713 ; 1714 if (fStreamerInfo); 1715 fStreamerInfo->Delete();; 1716 delete fStreamerInfo; fStreamerInfo = nullptr;; 1717 ; 1718 if (fDeclFileLine >= -1); 1719 TClass::RemoveClass(this);; 1720 ; 1721 gCling->ClassInfo_Delete(fClassInfo);; 1722 fClassInfo=nullptr;; 1723 ; 1724 if (fClassMenuList); 1725 fClassMenuList->Delete();; 1726 delete fClassMenuLis",MatchSource.WIKI,doc/v632/TClass_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/TClass_8cxx_source.html
https://root.cern/doc/v632/TClass_8cxx_source.html:65097,Performance,load,load,65097," hashtables.; 1665 if (fgClassTypedefHash && TestBit (kHasNameMapNode)) {; 1666 TString resolvedThis = TClassEdit::ResolveTypedef (GetName(), kTRUE);; 1667 TIter next (fgClassTypedefHash->GetListForObject (resolvedThis));; 1668 while ( TNameMapNode* htmp = static_cast<TNameMapNode*> (next()) ) {; 1669 if (resolvedThis == htmp->String() && htmp->fOrigName == GetName()) {; 1670 fgClassTypedefHash->Remove (htmp);; 1671 delete htmp;; 1672 break;; 1673 }; 1674 }; 1675 }; 1676 ; 1677 // Not owning lists, don't call Delete(); 1678 // But this still need to be done first because the TList destructor; 1679 // does access the object contained (via GetObject()->TestBit(kCanDelete)); 1680 delete fStreamer; fStreamer =nullptr;; 1681 delete fAllPubData; fAllPubData =nullptr;; 1682 delete fAllPubMethod; fAllPubMethod=nullptr;; 1683 ; 1684 delete fPersistentRef.load();; 1685 ; 1686 if (fBase.load()); 1687 (*fBase).Delete();; 1688 delete fBase.load(); fBase = nullptr;; 1689 ; 1690 if (fData.load()); 1691 (*fData).Delete();; 1692 delete fData.load(); fData = nullptr;; 1693 ; 1694 if (fUsingData.load()); 1695 (*fUsingData).Delete();; 1696 delete fUsingData.load(); fUsingData = nullptr;; 1697 ; 1698 if (fEnums.load()); 1699 (*fEnums).Delete();; 1700 delete fEnums.load(); fEnums = nullptr;; 1701 ; 1702 if (fFuncTemplate); 1703 fFuncTemplate->Delete();; 1704 delete fFuncTemplate; fFuncTemplate = nullptr;; 1705 ; 1706 if (fMethod.load()); 1707 (*fMethod).Delete();; 1708 delete fMethod.load(); fMethod=nullptr;; 1709 ; 1710 if (fRealData); 1711 fRealData->Delete();; 1712 delete fRealData; fRealData=nullptr;; 1713 ; 1714 if (fStreamerInfo); 1715 fStreamerInfo->Delete();; 1716 delete fStreamerInfo; fStreamerInfo = nullptr;; 1717 ; 1718 if (fDeclFileLine >= -1); 1719 TClass::RemoveClass(this);; 1720 ; 1721 gCling->ClassInfo_Delete(fClassInfo);; 1722 fClassInfo=nullptr;; 1723 ; 1724 if (fClassMenuList); 1725 fClassMenuList->Delete();; 1726 delete fClassMenuList; fClassMenuList=nullptr;; 1727 ; 1",MatchSource.WIKI,doc/v632/TClass_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/TClass_8cxx_source.html
https://root.cern/doc/v632/TClass_8cxx_source.html:65149,Performance,load,load,65149,"de)) {; 1666 TString resolvedThis = TClassEdit::ResolveTypedef (GetName(), kTRUE);; 1667 TIter next (fgClassTypedefHash->GetListForObject (resolvedThis));; 1668 while ( TNameMapNode* htmp = static_cast<TNameMapNode*> (next()) ) {; 1669 if (resolvedThis == htmp->String() && htmp->fOrigName == GetName()) {; 1670 fgClassTypedefHash->Remove (htmp);; 1671 delete htmp;; 1672 break;; 1673 }; 1674 }; 1675 }; 1676 ; 1677 // Not owning lists, don't call Delete(); 1678 // But this still need to be done first because the TList destructor; 1679 // does access the object contained (via GetObject()->TestBit(kCanDelete)); 1680 delete fStreamer; fStreamer =nullptr;; 1681 delete fAllPubData; fAllPubData =nullptr;; 1682 delete fAllPubMethod; fAllPubMethod=nullptr;; 1683 ; 1684 delete fPersistentRef.load();; 1685 ; 1686 if (fBase.load()); 1687 (*fBase).Delete();; 1688 delete fBase.load(); fBase = nullptr;; 1689 ; 1690 if (fData.load()); 1691 (*fData).Delete();; 1692 delete fData.load(); fData = nullptr;; 1693 ; 1694 if (fUsingData.load()); 1695 (*fUsingData).Delete();; 1696 delete fUsingData.load(); fUsingData = nullptr;; 1697 ; 1698 if (fEnums.load()); 1699 (*fEnums).Delete();; 1700 delete fEnums.load(); fEnums = nullptr;; 1701 ; 1702 if (fFuncTemplate); 1703 fFuncTemplate->Delete();; 1704 delete fFuncTemplate; fFuncTemplate = nullptr;; 1705 ; 1706 if (fMethod.load()); 1707 (*fMethod).Delete();; 1708 delete fMethod.load(); fMethod=nullptr;; 1709 ; 1710 if (fRealData); 1711 fRealData->Delete();; 1712 delete fRealData; fRealData=nullptr;; 1713 ; 1714 if (fStreamerInfo); 1715 fStreamerInfo->Delete();; 1716 delete fStreamerInfo; fStreamerInfo = nullptr;; 1717 ; 1718 if (fDeclFileLine >= -1); 1719 TClass::RemoveClass(this);; 1720 ; 1721 gCling->ClassInfo_Delete(fClassInfo);; 1722 fClassInfo=nullptr;; 1723 ; 1724 if (fClassMenuList); 1725 fClassMenuList->Delete();; 1726 delete fClassMenuList; fClassMenuList=nullptr;; 1727 ; 1728 fIsOffsetStreamerSet=kFALSE;; 1729 ; 1730 if ( fIsA ) delete fI",MatchSource.WIKI,doc/v632/TClass_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/TClass_8cxx_source.html
https://root.cern/doc/v632/TClass_8cxx_source.html:65202,Performance,load,load,65202,"sEdit::ResolveTypedef (GetName(), kTRUE);; 1667 TIter next (fgClassTypedefHash->GetListForObject (resolvedThis));; 1668 while ( TNameMapNode* htmp = static_cast<TNameMapNode*> (next()) ) {; 1669 if (resolvedThis == htmp->String() && htmp->fOrigName == GetName()) {; 1670 fgClassTypedefHash->Remove (htmp);; 1671 delete htmp;; 1672 break;; 1673 }; 1674 }; 1675 }; 1676 ; 1677 // Not owning lists, don't call Delete(); 1678 // But this still need to be done first because the TList destructor; 1679 // does access the object contained (via GetObject()->TestBit(kCanDelete)); 1680 delete fStreamer; fStreamer =nullptr;; 1681 delete fAllPubData; fAllPubData =nullptr;; 1682 delete fAllPubMethod; fAllPubMethod=nullptr;; 1683 ; 1684 delete fPersistentRef.load();; 1685 ; 1686 if (fBase.load()); 1687 (*fBase).Delete();; 1688 delete fBase.load(); fBase = nullptr;; 1689 ; 1690 if (fData.load()); 1691 (*fData).Delete();; 1692 delete fData.load(); fData = nullptr;; 1693 ; 1694 if (fUsingData.load()); 1695 (*fUsingData).Delete();; 1696 delete fUsingData.load(); fUsingData = nullptr;; 1697 ; 1698 if (fEnums.load()); 1699 (*fEnums).Delete();; 1700 delete fEnums.load(); fEnums = nullptr;; 1701 ; 1702 if (fFuncTemplate); 1703 fFuncTemplate->Delete();; 1704 delete fFuncTemplate; fFuncTemplate = nullptr;; 1705 ; 1706 if (fMethod.load()); 1707 (*fMethod).Delete();; 1708 delete fMethod.load(); fMethod=nullptr;; 1709 ; 1710 if (fRealData); 1711 fRealData->Delete();; 1712 delete fRealData; fRealData=nullptr;; 1713 ; 1714 if (fStreamerInfo); 1715 fStreamerInfo->Delete();; 1716 delete fStreamerInfo; fStreamerInfo = nullptr;; 1717 ; 1718 if (fDeclFileLine >= -1); 1719 TClass::RemoveClass(this);; 1720 ; 1721 gCling->ClassInfo_Delete(fClassInfo);; 1722 fClassInfo=nullptr;; 1723 ; 1724 if (fClassMenuList); 1725 fClassMenuList->Delete();; 1726 delete fClassMenuList; fClassMenuList=nullptr;; 1727 ; 1728 fIsOffsetStreamerSet=kFALSE;; 1729 ; 1730 if ( fIsA ) delete fIsA;; 1731 ; 1732 if ( fRefProxy ) fRefPr",MatchSource.WIKI,doc/v632/TClass_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/TClass_8cxx_source.html
https://root.cern/doc/v632/TClass_8cxx_source.html:65264,Performance,load,load,65264,"ash->GetListForObject (resolvedThis));; 1668 while ( TNameMapNode* htmp = static_cast<TNameMapNode*> (next()) ) {; 1669 if (resolvedThis == htmp->String() && htmp->fOrigName == GetName()) {; 1670 fgClassTypedefHash->Remove (htmp);; 1671 delete htmp;; 1672 break;; 1673 }; 1674 }; 1675 }; 1676 ; 1677 // Not owning lists, don't call Delete(); 1678 // But this still need to be done first because the TList destructor; 1679 // does access the object contained (via GetObject()->TestBit(kCanDelete)); 1680 delete fStreamer; fStreamer =nullptr;; 1681 delete fAllPubData; fAllPubData =nullptr;; 1682 delete fAllPubMethod; fAllPubMethod=nullptr;; 1683 ; 1684 delete fPersistentRef.load();; 1685 ; 1686 if (fBase.load()); 1687 (*fBase).Delete();; 1688 delete fBase.load(); fBase = nullptr;; 1689 ; 1690 if (fData.load()); 1691 (*fData).Delete();; 1692 delete fData.load(); fData = nullptr;; 1693 ; 1694 if (fUsingData.load()); 1695 (*fUsingData).Delete();; 1696 delete fUsingData.load(); fUsingData = nullptr;; 1697 ; 1698 if (fEnums.load()); 1699 (*fEnums).Delete();; 1700 delete fEnums.load(); fEnums = nullptr;; 1701 ; 1702 if (fFuncTemplate); 1703 fFuncTemplate->Delete();; 1704 delete fFuncTemplate; fFuncTemplate = nullptr;; 1705 ; 1706 if (fMethod.load()); 1707 (*fMethod).Delete();; 1708 delete fMethod.load(); fMethod=nullptr;; 1709 ; 1710 if (fRealData); 1711 fRealData->Delete();; 1712 delete fRealData; fRealData=nullptr;; 1713 ; 1714 if (fStreamerInfo); 1715 fStreamerInfo->Delete();; 1716 delete fStreamerInfo; fStreamerInfo = nullptr;; 1717 ; 1718 if (fDeclFileLine >= -1); 1719 TClass::RemoveClass(this);; 1720 ; 1721 gCling->ClassInfo_Delete(fClassInfo);; 1722 fClassInfo=nullptr;; 1723 ; 1724 if (fClassMenuList); 1725 fClassMenuList->Delete();; 1726 delete fClassMenuList; fClassMenuList=nullptr;; 1727 ; 1728 fIsOffsetStreamerSet=kFALSE;; 1729 ; 1730 if ( fIsA ) delete fIsA;; 1731 ; 1732 if ( fRefProxy ) fRefProxy->Release();; 1733 fRefProxy = nullptr;; 1734 ; 1735 delete fStreamer;; ",MatchSource.WIKI,doc/v632/TClass_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/TClass_8cxx_source.html
https://root.cern/doc/v632/TClass_8cxx_source.html:65318,Performance,load,load,65318," 1668 while ( TNameMapNode* htmp = static_cast<TNameMapNode*> (next()) ) {; 1669 if (resolvedThis == htmp->String() && htmp->fOrigName == GetName()) {; 1670 fgClassTypedefHash->Remove (htmp);; 1671 delete htmp;; 1672 break;; 1673 }; 1674 }; 1675 }; 1676 ; 1677 // Not owning lists, don't call Delete(); 1678 // But this still need to be done first because the TList destructor; 1679 // does access the object contained (via GetObject()->TestBit(kCanDelete)); 1680 delete fStreamer; fStreamer =nullptr;; 1681 delete fAllPubData; fAllPubData =nullptr;; 1682 delete fAllPubMethod; fAllPubMethod=nullptr;; 1683 ; 1684 delete fPersistentRef.load();; 1685 ; 1686 if (fBase.load()); 1687 (*fBase).Delete();; 1688 delete fBase.load(); fBase = nullptr;; 1689 ; 1690 if (fData.load()); 1691 (*fData).Delete();; 1692 delete fData.load(); fData = nullptr;; 1693 ; 1694 if (fUsingData.load()); 1695 (*fUsingData).Delete();; 1696 delete fUsingData.load(); fUsingData = nullptr;; 1697 ; 1698 if (fEnums.load()); 1699 (*fEnums).Delete();; 1700 delete fEnums.load(); fEnums = nullptr;; 1701 ; 1702 if (fFuncTemplate); 1703 fFuncTemplate->Delete();; 1704 delete fFuncTemplate; fFuncTemplate = nullptr;; 1705 ; 1706 if (fMethod.load()); 1707 (*fMethod).Delete();; 1708 delete fMethod.load(); fMethod=nullptr;; 1709 ; 1710 if (fRealData); 1711 fRealData->Delete();; 1712 delete fRealData; fRealData=nullptr;; 1713 ; 1714 if (fStreamerInfo); 1715 fStreamerInfo->Delete();; 1716 delete fStreamerInfo; fStreamerInfo = nullptr;; 1717 ; 1718 if (fDeclFileLine >= -1); 1719 TClass::RemoveClass(this);; 1720 ; 1721 gCling->ClassInfo_Delete(fClassInfo);; 1722 fClassInfo=nullptr;; 1723 ; 1724 if (fClassMenuList); 1725 fClassMenuList->Delete();; 1726 delete fClassMenuList; fClassMenuList=nullptr;; 1727 ; 1728 fIsOffsetStreamerSet=kFALSE;; 1729 ; 1730 if ( fIsA ) delete fIsA;; 1731 ; 1732 if ( fRefProxy ) fRefProxy->Release();; 1733 fRefProxy = nullptr;; 1734 ; 1735 delete fStreamer;; 1736 delete fCollectionProxy;; 1737 del",MatchSource.WIKI,doc/v632/TClass_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/TClass_8cxx_source.html
https://root.cern/doc/v632/TClass_8cxx_source.html:65372,Performance,load,load,65372,"fOrigName == GetName()) {; 1670 fgClassTypedefHash->Remove (htmp);; 1671 delete htmp;; 1672 break;; 1673 }; 1674 }; 1675 }; 1676 ; 1677 // Not owning lists, don't call Delete(); 1678 // But this still need to be done first because the TList destructor; 1679 // does access the object contained (via GetObject()->TestBit(kCanDelete)); 1680 delete fStreamer; fStreamer =nullptr;; 1681 delete fAllPubData; fAllPubData =nullptr;; 1682 delete fAllPubMethod; fAllPubMethod=nullptr;; 1683 ; 1684 delete fPersistentRef.load();; 1685 ; 1686 if (fBase.load()); 1687 (*fBase).Delete();; 1688 delete fBase.load(); fBase = nullptr;; 1689 ; 1690 if (fData.load()); 1691 (*fData).Delete();; 1692 delete fData.load(); fData = nullptr;; 1693 ; 1694 if (fUsingData.load()); 1695 (*fUsingData).Delete();; 1696 delete fUsingData.load(); fUsingData = nullptr;; 1697 ; 1698 if (fEnums.load()); 1699 (*fEnums).Delete();; 1700 delete fEnums.load(); fEnums = nullptr;; 1701 ; 1702 if (fFuncTemplate); 1703 fFuncTemplate->Delete();; 1704 delete fFuncTemplate; fFuncTemplate = nullptr;; 1705 ; 1706 if (fMethod.load()); 1707 (*fMethod).Delete();; 1708 delete fMethod.load(); fMethod=nullptr;; 1709 ; 1710 if (fRealData); 1711 fRealData->Delete();; 1712 delete fRealData; fRealData=nullptr;; 1713 ; 1714 if (fStreamerInfo); 1715 fStreamerInfo->Delete();; 1716 delete fStreamerInfo; fStreamerInfo = nullptr;; 1717 ; 1718 if (fDeclFileLine >= -1); 1719 TClass::RemoveClass(this);; 1720 ; 1721 gCling->ClassInfo_Delete(fClassInfo);; 1722 fClassInfo=nullptr;; 1723 ; 1724 if (fClassMenuList); 1725 fClassMenuList->Delete();; 1726 delete fClassMenuList; fClassMenuList=nullptr;; 1727 ; 1728 fIsOffsetStreamerSet=kFALSE;; 1729 ; 1730 if ( fIsA ) delete fIsA;; 1731 ; 1732 if ( fRefProxy ) fRefProxy->Release();; 1733 fRefProxy = nullptr;; 1734 ; 1735 delete fStreamer;; 1736 delete fCollectionProxy;; 1737 delete fIsAMethod.load();; 1738 delete fSchemaRules;; 1739 if (fConversionStreamerInfo.load()) {; 1740 std::map<std::string, TObj",MatchSource.WIKI,doc/v632/TClass_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/TClass_8cxx_source.html
https://root.cern/doc/v632/TClass_8cxx_source.html:65539,Performance,load,load,65539,"k;; 1673 }; 1674 }; 1675 }; 1676 ; 1677 // Not owning lists, don't call Delete(); 1678 // But this still need to be done first because the TList destructor; 1679 // does access the object contained (via GetObject()->TestBit(kCanDelete)); 1680 delete fStreamer; fStreamer =nullptr;; 1681 delete fAllPubData; fAllPubData =nullptr;; 1682 delete fAllPubMethod; fAllPubMethod=nullptr;; 1683 ; 1684 delete fPersistentRef.load();; 1685 ; 1686 if (fBase.load()); 1687 (*fBase).Delete();; 1688 delete fBase.load(); fBase = nullptr;; 1689 ; 1690 if (fData.load()); 1691 (*fData).Delete();; 1692 delete fData.load(); fData = nullptr;; 1693 ; 1694 if (fUsingData.load()); 1695 (*fUsingData).Delete();; 1696 delete fUsingData.load(); fUsingData = nullptr;; 1697 ; 1698 if (fEnums.load()); 1699 (*fEnums).Delete();; 1700 delete fEnums.load(); fEnums = nullptr;; 1701 ; 1702 if (fFuncTemplate); 1703 fFuncTemplate->Delete();; 1704 delete fFuncTemplate; fFuncTemplate = nullptr;; 1705 ; 1706 if (fMethod.load()); 1707 (*fMethod).Delete();; 1708 delete fMethod.load(); fMethod=nullptr;; 1709 ; 1710 if (fRealData); 1711 fRealData->Delete();; 1712 delete fRealData; fRealData=nullptr;; 1713 ; 1714 if (fStreamerInfo); 1715 fStreamerInfo->Delete();; 1716 delete fStreamerInfo; fStreamerInfo = nullptr;; 1717 ; 1718 if (fDeclFileLine >= -1); 1719 TClass::RemoveClass(this);; 1720 ; 1721 gCling->ClassInfo_Delete(fClassInfo);; 1722 fClassInfo=nullptr;; 1723 ; 1724 if (fClassMenuList); 1725 fClassMenuList->Delete();; 1726 delete fClassMenuList; fClassMenuList=nullptr;; 1727 ; 1728 fIsOffsetStreamerSet=kFALSE;; 1729 ; 1730 if ( fIsA ) delete fIsA;; 1731 ; 1732 if ( fRefProxy ) fRefProxy->Release();; 1733 fRefProxy = nullptr;; 1734 ; 1735 delete fStreamer;; 1736 delete fCollectionProxy;; 1737 delete fIsAMethod.load();; 1738 delete fSchemaRules;; 1739 if (fConversionStreamerInfo.load()) {; 1740 std::map<std::string, TObjArray*>::iterator it;; 1741 std::map<std::string, TObjArray*>::iterator end = (*fConversionStrea",MatchSource.WIKI,doc/v632/TClass_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/TClass_8cxx_source.html
https://root.cern/doc/v632/TClass_8cxx_source.html:65595,Performance,load,load,65595,"();; 1685 ; 1686 if (fBase.load()); 1687 (*fBase).Delete();; 1688 delete fBase.load(); fBase = nullptr;; 1689 ; 1690 if (fData.load()); 1691 (*fData).Delete();; 1692 delete fData.load(); fData = nullptr;; 1693 ; 1694 if (fUsingData.load()); 1695 (*fUsingData).Delete();; 1696 delete fUsingData.load(); fUsingData = nullptr;; 1697 ; 1698 if (fEnums.load()); 1699 (*fEnums).Delete();; 1700 delete fEnums.load(); fEnums = nullptr;; 1701 ; 1702 if (fFuncTemplate); 1703 fFuncTemplate->Delete();; 1704 delete fFuncTemplate; fFuncTemplate = nullptr;; 1705 ; 1706 if (fMethod.load()); 1707 (*fMethod).Delete();; 1708 delete fMethod.load(); fMethod=nullptr;; 1709 ; 1710 if (fRealData); 1711 fRealData->Delete();; 1712 delete fRealData; fRealData=nullptr;; 1713 ; 1714 if (fStreamerInfo); 1715 fStreamerInfo->Delete();; 1716 delete fStreamerInfo; fStreamerInfo = nullptr;; 1717 ; 1718 if (fDeclFileLine >= -1); 1719 TClass::RemoveClass(this);; 1720 ; 1721 gCling->ClassInfo_Delete(fClassInfo);; 1722 fClassInfo=nullptr;; 1723 ; 1724 if (fClassMenuList); 1725 fClassMenuList->Delete();; 1726 delete fClassMenuList; fClassMenuList=nullptr;; 1727 ; 1728 fIsOffsetStreamerSet=kFALSE;; 1729 ; 1730 if ( fIsA ) delete fIsA;; 1731 ; 1732 if ( fRefProxy ) fRefProxy->Release();; 1733 fRefProxy = nullptr;; 1734 ; 1735 delete fStreamer;; 1736 delete fCollectionProxy;; 1737 delete fIsAMethod.load();; 1738 delete fSchemaRules;; 1739 if (fConversionStreamerInfo.load()) {; 1740 std::map<std::string, TObjArray*>::iterator it;; 1741 std::map<std::string, TObjArray*>::iterator end = (*fConversionStreamerInfo).end();; 1742 for( it = (*fConversionStreamerInfo).begin(); it != end; ++it ) {; 1743 delete it->second;; 1744 }; 1745 delete fConversionStreamerInfo.load();; 1746 }; 1747}; 1748 ; 1749////////////////////////////////////////////////////////////////////////////////; 1750 ; 1751namespace {; 1752 Int_t ReadRulesContent(FILE *f); 1753 {; 1754 // Read a class.rules file which contains one rule per line with com",MatchSource.WIKI,doc/v632/TClass_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/TClass_8cxx_source.html
https://root.cern/doc/v632/TClass_8cxx_source.html:66345,Performance,load,load,66345," fEnums = nullptr;; 1701 ; 1702 if (fFuncTemplate); 1703 fFuncTemplate->Delete();; 1704 delete fFuncTemplate; fFuncTemplate = nullptr;; 1705 ; 1706 if (fMethod.load()); 1707 (*fMethod).Delete();; 1708 delete fMethod.load(); fMethod=nullptr;; 1709 ; 1710 if (fRealData); 1711 fRealData->Delete();; 1712 delete fRealData; fRealData=nullptr;; 1713 ; 1714 if (fStreamerInfo); 1715 fStreamerInfo->Delete();; 1716 delete fStreamerInfo; fStreamerInfo = nullptr;; 1717 ; 1718 if (fDeclFileLine >= -1); 1719 TClass::RemoveClass(this);; 1720 ; 1721 gCling->ClassInfo_Delete(fClassInfo);; 1722 fClassInfo=nullptr;; 1723 ; 1724 if (fClassMenuList); 1725 fClassMenuList->Delete();; 1726 delete fClassMenuList; fClassMenuList=nullptr;; 1727 ; 1728 fIsOffsetStreamerSet=kFALSE;; 1729 ; 1730 if ( fIsA ) delete fIsA;; 1731 ; 1732 if ( fRefProxy ) fRefProxy->Release();; 1733 fRefProxy = nullptr;; 1734 ; 1735 delete fStreamer;; 1736 delete fCollectionProxy;; 1737 delete fIsAMethod.load();; 1738 delete fSchemaRules;; 1739 if (fConversionStreamerInfo.load()) {; 1740 std::map<std::string, TObjArray*>::iterator it;; 1741 std::map<std::string, TObjArray*>::iterator end = (*fConversionStreamerInfo).end();; 1742 for( it = (*fConversionStreamerInfo).begin(); it != end; ++it ) {; 1743 delete it->second;; 1744 }; 1745 delete fConversionStreamerInfo.load();; 1746 }; 1747}; 1748 ; 1749////////////////////////////////////////////////////////////////////////////////; 1750 ; 1751namespace {; 1752 Int_t ReadRulesContent(FILE *f); 1753 {; 1754 // Read a class.rules file which contains one rule per line with comment; 1755 // starting with a #; 1756 // Returns the number of rules loaded.; 1757 // Returns -1 in case of error.; 1758 ; 1759 R__ASSERT(f!=nullptr);; 1760 TString rule(1024);; 1761 int c, state = 0;; 1762 Int_t count = 0;; 1763 ; 1764 while ((c = fgetc(f)) != EOF) {; 1765 if (c == 13) // ignore CR; 1766 continue;; 1767 if (c == '\n') {; 1768 if (state != 3) {; 1769 state = 0;; 1770 if (rule.Length() > 0) ",MatchSource.WIKI,doc/v632/TClass_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/TClass_8cxx_source.html
https://root.cern/doc/v632/TClass_8cxx_source.html:66414,Performance,load,load,66414,"; fFuncTemplate = nullptr;; 1705 ; 1706 if (fMethod.load()); 1707 (*fMethod).Delete();; 1708 delete fMethod.load(); fMethod=nullptr;; 1709 ; 1710 if (fRealData); 1711 fRealData->Delete();; 1712 delete fRealData; fRealData=nullptr;; 1713 ; 1714 if (fStreamerInfo); 1715 fStreamerInfo->Delete();; 1716 delete fStreamerInfo; fStreamerInfo = nullptr;; 1717 ; 1718 if (fDeclFileLine >= -1); 1719 TClass::RemoveClass(this);; 1720 ; 1721 gCling->ClassInfo_Delete(fClassInfo);; 1722 fClassInfo=nullptr;; 1723 ; 1724 if (fClassMenuList); 1725 fClassMenuList->Delete();; 1726 delete fClassMenuList; fClassMenuList=nullptr;; 1727 ; 1728 fIsOffsetStreamerSet=kFALSE;; 1729 ; 1730 if ( fIsA ) delete fIsA;; 1731 ; 1732 if ( fRefProxy ) fRefProxy->Release();; 1733 fRefProxy = nullptr;; 1734 ; 1735 delete fStreamer;; 1736 delete fCollectionProxy;; 1737 delete fIsAMethod.load();; 1738 delete fSchemaRules;; 1739 if (fConversionStreamerInfo.load()) {; 1740 std::map<std::string, TObjArray*>::iterator it;; 1741 std::map<std::string, TObjArray*>::iterator end = (*fConversionStreamerInfo).end();; 1742 for( it = (*fConversionStreamerInfo).begin(); it != end; ++it ) {; 1743 delete it->second;; 1744 }; 1745 delete fConversionStreamerInfo.load();; 1746 }; 1747}; 1748 ; 1749////////////////////////////////////////////////////////////////////////////////; 1750 ; 1751namespace {; 1752 Int_t ReadRulesContent(FILE *f); 1753 {; 1754 // Read a class.rules file which contains one rule per line with comment; 1755 // starting with a #; 1756 // Returns the number of rules loaded.; 1757 // Returns -1 in case of error.; 1758 ; 1759 R__ASSERT(f!=nullptr);; 1760 TString rule(1024);; 1761 int c, state = 0;; 1762 Int_t count = 0;; 1763 ; 1764 while ((c = fgetc(f)) != EOF) {; 1765 if (c == 13) // ignore CR; 1766 continue;; 1767 if (c == '\n') {; 1768 if (state != 3) {; 1769 state = 0;; 1770 if (rule.Length() > 0) {; 1771 if (TClass::AddRule(rule)) {; 1772 ++count;; 1773 }; 1774 rule.Clear();; 1775 }; 1776 }; 1777 contin",MatchSource.WIKI,doc/v632/TClass_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/TClass_8cxx_source.html
https://root.cern/doc/v632/TClass_8cxx_source.html:66710,Performance,load,load,66710,"amerInfo = nullptr;; 1717 ; 1718 if (fDeclFileLine >= -1); 1719 TClass::RemoveClass(this);; 1720 ; 1721 gCling->ClassInfo_Delete(fClassInfo);; 1722 fClassInfo=nullptr;; 1723 ; 1724 if (fClassMenuList); 1725 fClassMenuList->Delete();; 1726 delete fClassMenuList; fClassMenuList=nullptr;; 1727 ; 1728 fIsOffsetStreamerSet=kFALSE;; 1729 ; 1730 if ( fIsA ) delete fIsA;; 1731 ; 1732 if ( fRefProxy ) fRefProxy->Release();; 1733 fRefProxy = nullptr;; 1734 ; 1735 delete fStreamer;; 1736 delete fCollectionProxy;; 1737 delete fIsAMethod.load();; 1738 delete fSchemaRules;; 1739 if (fConversionStreamerInfo.load()) {; 1740 std::map<std::string, TObjArray*>::iterator it;; 1741 std::map<std::string, TObjArray*>::iterator end = (*fConversionStreamerInfo).end();; 1742 for( it = (*fConversionStreamerInfo).begin(); it != end; ++it ) {; 1743 delete it->second;; 1744 }; 1745 delete fConversionStreamerInfo.load();; 1746 }; 1747}; 1748 ; 1749////////////////////////////////////////////////////////////////////////////////; 1750 ; 1751namespace {; 1752 Int_t ReadRulesContent(FILE *f); 1753 {; 1754 // Read a class.rules file which contains one rule per line with comment; 1755 // starting with a #; 1756 // Returns the number of rules loaded.; 1757 // Returns -1 in case of error.; 1758 ; 1759 R__ASSERT(f!=nullptr);; 1760 TString rule(1024);; 1761 int c, state = 0;; 1762 Int_t count = 0;; 1763 ; 1764 while ((c = fgetc(f)) != EOF) {; 1765 if (c == 13) // ignore CR; 1766 continue;; 1767 if (c == '\n') {; 1768 if (state != 3) {; 1769 state = 0;; 1770 if (rule.Length() > 0) {; 1771 if (TClass::AddRule(rule)) {; 1772 ++count;; 1773 }; 1774 rule.Clear();; 1775 }; 1776 }; 1777 continue;; 1778 }; 1779 switch (state) {; 1780 case 0: // start of line; 1781 switch (c) {; 1782 case ' ':; 1783 case '\t':; 1784 break;; 1785 case '#':; 1786 state = 1;; 1787 break;; 1788 default:; 1789 state = 2;; 1790 break;; 1791 }; 1792 break;; 1793 ; 1794 case 1: // comment; 1795 break;; 1796 ; 1797 case 2: // rule; 1798 swi",MatchSource.WIKI,doc/v632/TClass_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/TClass_8cxx_source.html
https://root.cern/doc/v632/TClass_8cxx_source.html:67039,Performance,load,loaded,67039," 1723 ; 1724 if (fClassMenuList); 1725 fClassMenuList->Delete();; 1726 delete fClassMenuList; fClassMenuList=nullptr;; 1727 ; 1728 fIsOffsetStreamerSet=kFALSE;; 1729 ; 1730 if ( fIsA ) delete fIsA;; 1731 ; 1732 if ( fRefProxy ) fRefProxy->Release();; 1733 fRefProxy = nullptr;; 1734 ; 1735 delete fStreamer;; 1736 delete fCollectionProxy;; 1737 delete fIsAMethod.load();; 1738 delete fSchemaRules;; 1739 if (fConversionStreamerInfo.load()) {; 1740 std::map<std::string, TObjArray*>::iterator it;; 1741 std::map<std::string, TObjArray*>::iterator end = (*fConversionStreamerInfo).end();; 1742 for( it = (*fConversionStreamerInfo).begin(); it != end; ++it ) {; 1743 delete it->second;; 1744 }; 1745 delete fConversionStreamerInfo.load();; 1746 }; 1747}; 1748 ; 1749////////////////////////////////////////////////////////////////////////////////; 1750 ; 1751namespace {; 1752 Int_t ReadRulesContent(FILE *f); 1753 {; 1754 // Read a class.rules file which contains one rule per line with comment; 1755 // starting with a #; 1756 // Returns the number of rules loaded.; 1757 // Returns -1 in case of error.; 1758 ; 1759 R__ASSERT(f!=nullptr);; 1760 TString rule(1024);; 1761 int c, state = 0;; 1762 Int_t count = 0;; 1763 ; 1764 while ((c = fgetc(f)) != EOF) {; 1765 if (c == 13) // ignore CR; 1766 continue;; 1767 if (c == '\n') {; 1768 if (state != 3) {; 1769 state = 0;; 1770 if (rule.Length() > 0) {; 1771 if (TClass::AddRule(rule)) {; 1772 ++count;; 1773 }; 1774 rule.Clear();; 1775 }; 1776 }; 1777 continue;; 1778 }; 1779 switch (state) {; 1780 case 0: // start of line; 1781 switch (c) {; 1782 case ' ':; 1783 case '\t':; 1784 break;; 1785 case '#':; 1786 state = 1;; 1787 break;; 1788 default:; 1789 state = 2;; 1790 break;; 1791 }; 1792 break;; 1793 ; 1794 case 1: // comment; 1795 break;; 1796 ; 1797 case 2: // rule; 1798 switch (c) {; 1799 case '\\':; 1800 state = 3; // Continuation request; 1801 default:; 1802 break;; 1803 }; 1804 break;; 1805 }; 1806 switch (state) {; 1807 case 2:; 1808 ",MatchSource.WIKI,doc/v632/TClass_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/TClass_8cxx_source.html
https://root.cern/doc/v632/TClass_8cxx_source.html:68978,Performance,load,loaded,68978,"804 break;; 1805 }; 1806 switch (state) {; 1807 case 2:; 1808 rule.Append(c);; 1809 break;; 1810 }; 1811 }; 1812 return count;; 1813 }; 1814}; 1815 ; 1816////////////////////////////////////////////////////////////////////////////////; 1817/// Read the class.rules files from the default location:.; 1818/// $ROOTSYS/etc/class.rules (or ROOTETCDIR/class.rules); 1819 ; 1820Int_t TClass::ReadRules(); 1821{; 1822 static const char *suffix = ""class.rules"";; 1823 TString sname = suffix;; 1824 gSystem->PrependPathName(TROOT::GetEtcDir(), sname);; 1825 ; 1826 Int_t res = -1;; 1827 ; 1828 FILE * f = fopen(sname,""r"");; 1829 if (f != nullptr) {; 1830 res = ReadRulesContent(f);; 1831 fclose(f);; 1832 } else {; 1833 ::Error(""TClass::ReadRules()"", ""Cannot find rules file %s"", sname.Data());; 1834 }; 1835 return res;; 1836}; 1837 ; 1838////////////////////////////////////////////////////////////////////////////////; 1839/// Read a class.rules file which contains one rule per line with comment; 1840/// starting with a #; 1841/// - Returns the number of rules loaded.; 1842/// - Returns -1 in case of error.; 1843 ; 1844Int_t TClass::ReadRules( const char *filename ); 1845{; 1846 if (!filename || !filename[0]) {; 1847 ::Error(""TClass::ReadRules"", ""no file name specified"");; 1848 return -1;; 1849 }; 1850 ; 1851 FILE * f = fopen(filename,""r"");; 1852 if (f == nullptr) {; 1853 ::Error(""TClass::ReadRules"",""Failed to open %s\n"",filename);; 1854 return -1;; 1855 }; 1856 Int_t count = ReadRulesContent(f);; 1857 ; 1858 fclose(f);; 1859 return count;; 1860 ; 1861}; 1862 ; 1863////////////////////////////////////////////////////////////////////////////////; 1864/// Add a schema evolution customization rule.; 1865/// The syntax of the rule can be either the short form:; 1866/// ~~~ {.cpp}; 1867/// [type=Read] classname membername [attributes=... ] [version=[...] ] [checksum=[...] ] [oldtype=...] [code={...}]; 1868/// ~~~; 1869/// or the long form; 1870/// ~~~ {.cpp}; 1871/// [type=Read] sourceClas",MatchSource.WIKI,doc/v632/TClass_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/TClass_8cxx_source.html
https://root.cern/doc/v632/TClass_8cxx_source.html:77951,Performance,load,loading,77951,"BuildEmulatedRealData("""", 0, this, isTransient);; 2054 return;; 2055 }; 2056 ; 2057 // return early on string; 2058 static TClassRef clRefString(""std::string"");; 2059 if (clRefString == this) {; 2060 return;; 2061 }; 2062 ; 2063 // Complain about stl classes ending up here (unique_ptr etc) - except for; 2064 // pair where we will build .first, .second just fine; 2065 // and those for which the user explicitly requested a dictionary.; 2066 if (!isTransient && GetState() != kHasTClassInit; 2067 && TClassEdit::IsStdClass(GetName()); 2068 && !TClassEdit::IsStdPair(GetName())) {; 2069 Error(""BuildRealData"", ""Inspection for %s not supported!"", GetName());; 2070 }; 2071 ; 2072 // The following statement will recursively call; 2073 // all the subclasses of this class.; 2074 fRealData = new TList;; 2075 TBuildRealData brd(pointer, this);; 2076 ; 2077 // CallShowMember will force a call to InheritsFrom, which indirectly; 2078 // calls TClass::GetClass. It forces the loading of new typedefs in; 2079 // case some of them were not yet loaded.; 2080 if ( ! CallShowMembers(pointer, brd, isTransient) ) {; 2081 if ( isTransient ) {; 2082 // This is a transient data member, so it is probably fine to not have; 2083 // access to its content. However let's no mark it as definitively setup,; 2084 // since another class might use this class for a persistent data member and; 2085 // in this case we really want the error message.; 2086 delete fRealData;; 2087 fRealData = nullptr;; 2088 } else {; 2089 Error(""BuildRealData"", ""Cannot find any ShowMembers function for %s!"", GetName());; 2090 }; 2091 }; 2092 ; 2093 // Take this opportunity to build the real data for base classes.; 2094 // In case one base class is abstract, it would not be possible later; 2095 // to create the list of real data for this abstract class.; 2096 TBaseClass* base = nullptr;; 2097 TIter next(GetListOfBases());; 2098 while ((base = (TBaseClass*) next())) {; 2099 if (base->IsSTLContainer()) {; 2100 continue;; 2101 }; 210",MatchSource.WIKI,doc/v632/TClass_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/TClass_8cxx_source.html
https://root.cern/doc/v632/TClass_8cxx_source.html:78018,Performance,load,loaded,78018,"BuildEmulatedRealData("""", 0, this, isTransient);; 2054 return;; 2055 }; 2056 ; 2057 // return early on string; 2058 static TClassRef clRefString(""std::string"");; 2059 if (clRefString == this) {; 2060 return;; 2061 }; 2062 ; 2063 // Complain about stl classes ending up here (unique_ptr etc) - except for; 2064 // pair where we will build .first, .second just fine; 2065 // and those for which the user explicitly requested a dictionary.; 2066 if (!isTransient && GetState() != kHasTClassInit; 2067 && TClassEdit::IsStdClass(GetName()); 2068 && !TClassEdit::IsStdPair(GetName())) {; 2069 Error(""BuildRealData"", ""Inspection for %s not supported!"", GetName());; 2070 }; 2071 ; 2072 // The following statement will recursively call; 2073 // all the subclasses of this class.; 2074 fRealData = new TList;; 2075 TBuildRealData brd(pointer, this);; 2076 ; 2077 // CallShowMember will force a call to InheritsFrom, which indirectly; 2078 // calls TClass::GetClass. It forces the loading of new typedefs in; 2079 // case some of them were not yet loaded.; 2080 if ( ! CallShowMembers(pointer, brd, isTransient) ) {; 2081 if ( isTransient ) {; 2082 // This is a transient data member, so it is probably fine to not have; 2083 // access to its content. However let's no mark it as definitively setup,; 2084 // since another class might use this class for a persistent data member and; 2085 // in this case we really want the error message.; 2086 delete fRealData;; 2087 fRealData = nullptr;; 2088 } else {; 2089 Error(""BuildRealData"", ""Cannot find any ShowMembers function for %s!"", GetName());; 2090 }; 2091 }; 2092 ; 2093 // Take this opportunity to build the real data for base classes.; 2094 // In case one base class is abstract, it would not be possible later; 2095 // to create the list of real data for this abstract class.; 2096 TBaseClass* base = nullptr;; 2097 TIter next(GetListOfBases());; 2098 while ((base = (TBaseClass*) next())) {; 2099 if (base->IsSTLContainer()) {; 2100 continue;; 2101 }; 210",MatchSource.WIKI,doc/v632/TClass_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/TClass_8cxx_source.html
https://root.cern/doc/v632/TClass_8cxx_source.html:86762,Performance,load,load,86762,"72 TVirtualStreamerInfo *sinfo = ((TClass *)this)->GetCurrentStreamerInfo();; 2273 if (sinfo==nullptr) sinfo = GetStreamerInfo();; 2274 TIter next(sinfo->GetElements());; 2275 TStreamerElement *element;; 2276 while ((element = (TStreamerElement*)next())) {; 2277 if (element->IsA() == TStreamerBase::Class()) {; 2278 TClass *clbase = element->GetClassPointer();; 2279 if (!clbase) {; 2280 // If there is a missing base class, we can't split the immediate; 2281 // derived class.; 2282 fCanSplit = 0;; 2283 return kFALSE;; 2284 } else if (!clbase->CanSplitBaseAllow()) {; 2285 fCanSplit = 2;; 2286 return kFALSE;; 2287 }; 2288 }; 2289 }; 2290 }; 2291 ; 2292 // If we don't have data member info there is no more information; 2293 // we can find out.; 2294 if (!HasDataMemberInfo()) return kTRUE;; 2295 ; 2296 TObjLink *lnk = GetListOfBases() ? fBase.load()->FirstLink() : nullptr;; 2297 ; 2298 // Look at inheritance tree; 2299 while (lnk) {; 2300 TBaseClass *base = (TBaseClass*) lnk->GetObject();; 2301 TClass *c = base->GetClassPointer();; 2302 if(!c) {; 2303 // If there is a missing base class, we can't split the immediate; 2304 // derived class.; 2305 fCanSplit = 0;; 2306 return kFALSE;; 2307 } else if (!c->CanSplitBaseAllow()) {; 2308 fCanSplit = 2;; 2309 return kFALSE;; 2310 }; 2311 lnk = lnk->Next();; 2312 }; 2313 return kTRUE;; 2314}; 2315 ; 2316////////////////////////////////////////////////////////////////////////////////; 2317/// Return true if the data member of this TClass can be saved separately.; 2318 ; 2319Bool_t TClass::CanSplit() const; 2320{; 2321 // Note: add the possibility to set it for the class and the derived class.; 2322 // save the info in TVirtualStreamerInfo; 2323 // deal with the info in MakeProject; 2324 if (fCanSplit >= 0) {; 2325 // The user explicitly set the value; 2326 return (fCanSplit & 0x1) == 1;; 2327 }; 2328 ; 2329 R__LOCKGUARD(gInterpreterMutex);; 2330 TClass *This = const_cast<TClass*>(this);; 2331 ; 2332 if (this == TObject::Class()) { T",MatchSource.WIKI,doc/v632/TClass_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/TClass_8cxx_source.html
https://root.cern/doc/v632/TClass_8cxx_source.html:100650,Performance,load,load,100650," we deal with possible aliases, we could also have normalized; 2663 // the name.; 2664 TClass *search = TClass::GetClass(classname,kTRUE,kTRUE);; 2665 ; 2666 if (search) return GetBaseClass(search);; 2667 else return nullptr;; 2668}; 2669 ; 2670////////////////////////////////////////////////////////////////////////////////; 2671/// Return pointer to the base class ""cl"". Returns 0 in case ""cl""; 2672/// is not a base class. Takes care of multiple inheritance.; 2673 ; 2674TClass *TClass::GetBaseClass(const TClass *cl); 2675{; 2676 // check if class name itself is equal to classname; 2677 if (cl == this) return this;; 2678 ; 2679 if (!HasDataMemberInfo()) return nullptr;; 2680 ; 2681 TObjLink *lnk = GetListOfBases() ? fBase.load()->FirstLink() : nullptr;; 2682 ; 2683 // otherwise look at inheritance tree; 2684 while (lnk) {; 2685 TClass *c, *c1;; 2686 TBaseClass *base = (TBaseClass*) lnk->GetObject();; 2687 c = base->GetClassPointer();; 2688 if (c) {; 2689 if (cl == c) return c;; 2690 c1 = c->GetBaseClass(cl);; 2691 if (c1) return c1;; 2692 }; 2693 lnk = lnk->Next();; 2694 }; 2695 return nullptr;; 2696}; 2697 ; 2698////////////////////////////////////////////////////////////////////////////////; 2699/// Return data member offset to the base class ""cl"".; 2700/// - Returns -1 in case ""cl"" is not a base class.; 2701/// - Returns -2 if cl is a base class, but we can't find the offset; 2702/// because it's virtual.; 2703/// Takes care of multiple inheritance.; 2704 ; 2705Int_t TClass::GetBaseClassOffsetRecurse(const TClass *cl); 2706{; 2707 // check if class name itself is equal to classname; 2708 if (cl == this) return 0;; 2709 ; 2710 if (!fBase.load()) {; 2711 if (fCanLoadClassInfo) LoadClassInfo();; 2712 // If the information was not provided by the root pcm files and; 2713 // if we can not find the ClassInfo, we have to fall back to the; 2714 // StreamerInfo; 2715 if (!fClassInfo) {; 2716 TVirtualStreamerInfo *sinfo = GetCurrentStreamerInfo();; 2717 if (!sinfo) return -",MatchSource.WIKI,doc/v632/TClass_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/TClass_8cxx_source.html
https://root.cern/doc/v632/TClass_8cxx_source.html:101586,Performance,load,load,101586,"ject();; 2687 c = base->GetClassPointer();; 2688 if (c) {; 2689 if (cl == c) return c;; 2690 c1 = c->GetBaseClass(cl);; 2691 if (c1) return c1;; 2692 }; 2693 lnk = lnk->Next();; 2694 }; 2695 return nullptr;; 2696}; 2697 ; 2698////////////////////////////////////////////////////////////////////////////////; 2699/// Return data member offset to the base class ""cl"".; 2700/// - Returns -1 in case ""cl"" is not a base class.; 2701/// - Returns -2 if cl is a base class, but we can't find the offset; 2702/// because it's virtual.; 2703/// Takes care of multiple inheritance.; 2704 ; 2705Int_t TClass::GetBaseClassOffsetRecurse(const TClass *cl); 2706{; 2707 // check if class name itself is equal to classname; 2708 if (cl == this) return 0;; 2709 ; 2710 if (!fBase.load()) {; 2711 if (fCanLoadClassInfo) LoadClassInfo();; 2712 // If the information was not provided by the root pcm files and; 2713 // if we can not find the ClassInfo, we have to fall back to the; 2714 // StreamerInfo; 2715 if (!fClassInfo) {; 2716 TVirtualStreamerInfo *sinfo = GetCurrentStreamerInfo();; 2717 if (!sinfo) return -1;; 2718 TStreamerElement *element;; 2719 Int_t offset = 0;; 2720 ; 2721 TObjArray &elems = *(sinfo->GetElements());; 2722 Int_t size = elems.GetLast()+1;; 2723 for(Int_t i=0; i<size; i++) {; 2724 element = (TStreamerElement*)elems[i];; 2725 if (element->IsBase()) {; 2726 if (element->IsA() == TStreamerBase::Class()) {; 2727 TStreamerBase *base = (TStreamerBase*)element;; 2728 TClass *baseclass = base->GetClassPointer();; 2729 if (!baseclass) return -1;; 2730 Int_t subOffset = baseclass->GetBaseClassOffsetRecurse(cl);; 2731 if (subOffset == -2) return -2;; 2732 if (subOffset != -1) return offset+subOffset;; 2733 offset += baseclass->Size();; 2734 } else if (element->IsA() == TStreamerSTL::Class()) {; 2735 TStreamerSTL *base = (TStreamerSTL*)element;; 2736 TClass *baseclass = base->GetClassPointer();; 2737 if (!baseclass) return -1;; 2738 Int_t subOffset = baseclass->GetBaseClassOffsetRecurse(",MatchSource.WIKI,doc/v632/TClass_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/TClass_8cxx_source.html
https://root.cern/doc/v632/TClass_8cxx_source.html:103259,Performance,load,load,103259,"s *baseclass = base->GetClassPointer();; 2729 if (!baseclass) return -1;; 2730 Int_t subOffset = baseclass->GetBaseClassOffsetRecurse(cl);; 2731 if (subOffset == -2) return -2;; 2732 if (subOffset != -1) return offset+subOffset;; 2733 offset += baseclass->Size();; 2734 } else if (element->IsA() == TStreamerSTL::Class()) {; 2735 TStreamerSTL *base = (TStreamerSTL*)element;; 2736 TClass *baseclass = base->GetClassPointer();; 2737 if (!baseclass) return -1;; 2738 Int_t subOffset = baseclass->GetBaseClassOffsetRecurse(cl);; 2739 if (subOffset == -2) return -2;; 2740 if (subOffset != -1) return offset+subOffset;; 2741 offset += baseclass->Size();; 2742 ; 2743 } else {; 2744 Error(""GetBaseClassOffsetRecurse"",""Unexpected element type for base class: %s\n"",element->IsA()->GetName());; 2745 }; 2746 }; 2747 }; 2748 return -1;; 2749 }; 2750 }; 2751 ; 2752 TClass *c;; 2753 Int_t off;; 2754 TBaseClass *inh;; 2755 TObjLink *lnk = nullptr;; 2756 if (fBase.load() == nullptr); 2757 lnk = GetListOfBases()->FirstLink();; 2758 else; 2759 lnk = fBase.load()->FirstLink();; 2760 ; 2761 // otherwise look at inheritance tree; 2762 while (lnk) {; 2763 inh = (TBaseClass *)lnk->GetObject();; 2764 //use option load=kFALSE to avoid a warning like:; 2765 //""Warning in <TClass::TClass>: no dictionary for class TRefCnt is available""; 2766 //We can not afford to not have the class if it exist, so we; 2767 //use kTRUE.; 2768 c = inh->GetClassPointer(kTRUE); // kFALSE);; 2769 if (c) {; 2770 if (cl == c) {; 2771 if ((inh->Property() & kIsVirtualBase) != 0); 2772 return -2;; 2773 return inh->GetDelta();; 2774 }; 2775 off = c->GetBaseClassOffsetRecurse(cl);; 2776 if (off == -2) return -2;; 2777 if (off != -1) {; 2778 return off + inh->GetDelta();; 2779 }; 2780 }; 2781 lnk = lnk->Next();; 2782 }; 2783 return -1;; 2784}; 2785 ; 2786////////////////////////////////////////////////////////////////////////////////; 2787/// - Return data member offset to the base class ""cl"".; 2788/// - Returns -1 in case ""cl"" i",MatchSource.WIKI,doc/v632/TClass_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/TClass_8cxx_source.html
https://root.cern/doc/v632/TClass_8cxx_source.html:103350,Performance,load,load,103350,"t;; 2733 offset += baseclass->Size();; 2734 } else if (element->IsA() == TStreamerSTL::Class()) {; 2735 TStreamerSTL *base = (TStreamerSTL*)element;; 2736 TClass *baseclass = base->GetClassPointer();; 2737 if (!baseclass) return -1;; 2738 Int_t subOffset = baseclass->GetBaseClassOffsetRecurse(cl);; 2739 if (subOffset == -2) return -2;; 2740 if (subOffset != -1) return offset+subOffset;; 2741 offset += baseclass->Size();; 2742 ; 2743 } else {; 2744 Error(""GetBaseClassOffsetRecurse"",""Unexpected element type for base class: %s\n"",element->IsA()->GetName());; 2745 }; 2746 }; 2747 }; 2748 return -1;; 2749 }; 2750 }; 2751 ; 2752 TClass *c;; 2753 Int_t off;; 2754 TBaseClass *inh;; 2755 TObjLink *lnk = nullptr;; 2756 if (fBase.load() == nullptr); 2757 lnk = GetListOfBases()->FirstLink();; 2758 else; 2759 lnk = fBase.load()->FirstLink();; 2760 ; 2761 // otherwise look at inheritance tree; 2762 while (lnk) {; 2763 inh = (TBaseClass *)lnk->GetObject();; 2764 //use option load=kFALSE to avoid a warning like:; 2765 //""Warning in <TClass::TClass>: no dictionary for class TRefCnt is available""; 2766 //We can not afford to not have the class if it exist, so we; 2767 //use kTRUE.; 2768 c = inh->GetClassPointer(kTRUE); // kFALSE);; 2769 if (c) {; 2770 if (cl == c) {; 2771 if ((inh->Property() & kIsVirtualBase) != 0); 2772 return -2;; 2773 return inh->GetDelta();; 2774 }; 2775 off = c->GetBaseClassOffsetRecurse(cl);; 2776 if (off == -2) return -2;; 2777 if (off != -1) {; 2778 return off + inh->GetDelta();; 2779 }; 2780 }; 2781 lnk = lnk->Next();; 2782 }; 2783 return -1;; 2784}; 2785 ; 2786////////////////////////////////////////////////////////////////////////////////; 2787/// - Return data member offset to the base class ""cl"".; 2788/// - Returns -1 in case ""cl"" is not a base class.; 2789/// Takes care of multiple inheritance.; 2790 ; 2791Int_t TClass::GetBaseClassOffset(const TClass *toBase, void *address, bool isDerivedObject); 2792{; 2793 // Warning(""GetBaseClassOffset"",""Requires th",MatchSource.WIKI,doc/v632/TClass_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/TClass_8cxx_source.html
https://root.cern/doc/v632/TClass_8cxx_source.html:103505,Performance,load,load,103505,"t;; 2733 offset += baseclass->Size();; 2734 } else if (element->IsA() == TStreamerSTL::Class()) {; 2735 TStreamerSTL *base = (TStreamerSTL*)element;; 2736 TClass *baseclass = base->GetClassPointer();; 2737 if (!baseclass) return -1;; 2738 Int_t subOffset = baseclass->GetBaseClassOffsetRecurse(cl);; 2739 if (subOffset == -2) return -2;; 2740 if (subOffset != -1) return offset+subOffset;; 2741 offset += baseclass->Size();; 2742 ; 2743 } else {; 2744 Error(""GetBaseClassOffsetRecurse"",""Unexpected element type for base class: %s\n"",element->IsA()->GetName());; 2745 }; 2746 }; 2747 }; 2748 return -1;; 2749 }; 2750 }; 2751 ; 2752 TClass *c;; 2753 Int_t off;; 2754 TBaseClass *inh;; 2755 TObjLink *lnk = nullptr;; 2756 if (fBase.load() == nullptr); 2757 lnk = GetListOfBases()->FirstLink();; 2758 else; 2759 lnk = fBase.load()->FirstLink();; 2760 ; 2761 // otherwise look at inheritance tree; 2762 while (lnk) {; 2763 inh = (TBaseClass *)lnk->GetObject();; 2764 //use option load=kFALSE to avoid a warning like:; 2765 //""Warning in <TClass::TClass>: no dictionary for class TRefCnt is available""; 2766 //We can not afford to not have the class if it exist, so we; 2767 //use kTRUE.; 2768 c = inh->GetClassPointer(kTRUE); // kFALSE);; 2769 if (c) {; 2770 if (cl == c) {; 2771 if ((inh->Property() & kIsVirtualBase) != 0); 2772 return -2;; 2773 return inh->GetDelta();; 2774 }; 2775 off = c->GetBaseClassOffsetRecurse(cl);; 2776 if (off == -2) return -2;; 2777 if (off != -1) {; 2778 return off + inh->GetDelta();; 2779 }; 2780 }; 2781 lnk = lnk->Next();; 2782 }; 2783 return -1;; 2784}; 2785 ; 2786////////////////////////////////////////////////////////////////////////////////; 2787/// - Return data member offset to the base class ""cl"".; 2788/// - Returns -1 in case ""cl"" is not a base class.; 2789/// Takes care of multiple inheritance.; 2790 ; 2791Int_t TClass::GetBaseClassOffset(const TClass *toBase, void *address, bool isDerivedObject); 2792{; 2793 // Warning(""GetBaseClassOffset"",""Requires th",MatchSource.WIKI,doc/v632/TClass_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/TClass_8cxx_source.html
https://root.cern/doc/v632/TClass_8cxx_source.html:104827,Performance,load,loaded,104827,"; 2772 return -2;; 2773 return inh->GetDelta();; 2774 }; 2775 off = c->GetBaseClassOffsetRecurse(cl);; 2776 if (off == -2) return -2;; 2777 if (off != -1) {; 2778 return off + inh->GetDelta();; 2779 }; 2780 }; 2781 lnk = lnk->Next();; 2782 }; 2783 return -1;; 2784}; 2785 ; 2786////////////////////////////////////////////////////////////////////////////////; 2787/// - Return data member offset to the base class ""cl"".; 2788/// - Returns -1 in case ""cl"" is not a base class.; 2789/// Takes care of multiple inheritance.; 2790 ; 2791Int_t TClass::GetBaseClassOffset(const TClass *toBase, void *address, bool isDerivedObject); 2792{; 2793 // Warning(""GetBaseClassOffset"",""Requires the use of fClassInfo for %s to %s"",GetName(),toBase->GetName());; 2794 ; 2795 if (this == toBase) return 0;; 2796 ; 2797 if ((!address /* || !has_virtual_base */) &&; 2798 (!HasInterpreterInfoInMemory() || !toBase->HasInterpreterInfoInMemory())) {; 2799 // At least of the ClassInfo have not been loaded in memory yet and; 2800 // since there is no virtual base class (or we don't have enough so it; 2801 // would not make a difference) we can use the 'static' information; 2802 Int_t offset = GetBaseClassOffsetRecurse (toBase);; 2803 if (offset != -2) {; 2804 return offset;; 2805 }; 2806 return offset;; 2807 }; 2808 ; 2809 ClassInfo_t* derived = GetClassInfo();; 2810 ClassInfo_t* base = toBase->GetClassInfo();; 2811 if(derived && base) {; 2812 // TClingClassInfo::GetBaseOffset takes the lock.; 2813 return gCling->ClassInfo_GetBaseOffset(derived, base, address, isDerivedObject);; 2814 }; 2815 else {; 2816 Int_t offset = GetBaseClassOffsetRecurse (toBase);; 2817 if (offset != -2) {; 2818 return offset;; 2819 }; 2820 }; 2821 return -1;; 2822}; 2823 ; 2824////////////////////////////////////////////////////////////////////////////////; 2825/// Return pointer to (base) class that contains datamember.; 2826 ; 2827TClass *TClass::GetBaseDataMember(const char *datamember); 2828{; 2829 if (!HasDataMemberInfo())",MatchSource.WIKI,doc/v632/TClass_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/TClass_8cxx_source.html
https://root.cern/doc/v632/TClass_8cxx_source.html:108290,Performance,optimiz,optimized,108290,"= (ULongptr_t)lmap->GetValue(hash, (Longptr_t)cl, slot)) != 0) {; 2871 } else {; 2872 local = (ULongptr_t) new TClassLocalStorage();; 2873 lmap->AddAt(slot, hash, (Longptr_t)cl, local);; 2874 }; 2875 return (TClassLocalStorage*)local;; 2876 }; 2877 return nullptr;; 2878 }; 2879 };; 2880}; 2881 ; 2882////////////////////////////////////////////////////////////////////////////////; 2883/// Return the 'type' of the STL the TClass is representing.; 2884/// and return ROOT::kNotSTL if it is not representing an STL collection.; 2885 ; 2886ROOT::ESTLType TClass::GetCollectionType() const; 2887{; 2888 auto proxy = GetCollectionProxy();; 2889 if (proxy) return (ROOT::ESTLType)proxy->GetCollectionType();; 2890 return ROOT::kNotSTL;; 2891}; 2892 ; 2893 ; 2894////////////////////////////////////////////////////////////////////////////////; 2895/// Return the proxy describing the collection (if any).; 2896 ; 2897TVirtualCollectionProxy *TClass::GetCollectionProxy() const; 2898{; 2899 // Use assert, so that this line (slow because of the TClassEdit) is completely; 2900 // removed in optimized code.; 2901 //assert(TestBit(kLoading) || !TClassEdit::IsSTLCont(fName) || fCollectionProxy || 0 == ""The TClass for the STL collection has no collection proxy!"");; 2902 if (gThreadTsd && fCollectionProxy) {; 2903 TClassLocalStorage *local = TClassLocalStorage::GetStorage(this);; 2904 if (local == nullptr) return fCollectionProxy;; 2905 if (local->fCollectionProxy==nullptr) local->fCollectionProxy = fCollectionProxy->Generate();; 2906 return local->fCollectionProxy;; 2907 }; 2908 return fCollectionProxy;; 2909}; 2910 ; 2911////////////////////////////////////////////////////////////////////////////////; 2912/// Return the Streamer Class allowing streaming (if any).; 2913 ; 2914TClassStreamer *TClass::GetStreamer() const; 2915{; 2916 if (gThreadTsd && fStreamer) {; 2917 TClassLocalStorage *local = TClassLocalStorage::GetStorage(this);; 2918 if (local==nullptr) return fStreamer;; 2919 if (local-",MatchSource.WIKI,doc/v632/TClass_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/TClass_8cxx_source.html
https://root.cern/doc/v632/TClass_8cxx_source.html:110910,Performance,load,load,110910," Get a wrapper/accessor function around this class custom streamer (member function).; 2938 ; 2939ClassStreamerFunc_t TClass::GetStreamerFunc() const; 2940{; 2941 return fStreamerFunc;; 2942}; 2943 ; 2944////////////////////////////////////////////////////////////////////////////////; 2945/// Get a wrapper/accessor function around this class custom conversion streamer (member function).; 2946 ; 2947ClassConvStreamerFunc_t TClass::GetConvStreamerFunc() const; 2948{; 2949 return fConvStreamerFunc;; 2950}; 2951 ; 2952////////////////////////////////////////////////////////////////////////////////; 2953/// Return the proxy implementing the IsA functionality.; 2954 ; 2955TVirtualIsAProxy* TClass::GetIsAProxy() const; 2956{; 2957 return fIsA;; 2958}; 2959 ; 2960////////////////////////////////////////////////////////////////////////////////; 2961/// Static method returning pointer to TClass of the specified class name.; 2962/// If load is true, an attempt is made to obtain the class by loading; 2963/// the appropriate shared library (directed by the rootmap file).; 2964/// If silent is 'true', do not warn about missing dictionary for the class.; 2965/// (typically used for classes that are used only for transient members); 2966/// Returns `nullptr` in case class is not found.; 2967 ; 2968TClass *TClass::GetClass(const char *name, Bool_t load, Bool_t silent); 2969{; 2970 return TClass::GetClass(name, load, silent, 0, 0);; 2971}; 2972 ; 2973TClass *TClass::GetClass(const char *name, Bool_t load, Bool_t silent, size_t hint_pair_offset, size_t hint_pair_size); 2974{; 2975 if (!name || !name[0]) return nullptr;; 2976 ; 2977 if (strstr(name, ""(anonymous)"")) return nullptr;; 2978 if (strstr(name, ""(unnamed)"")) return nullptr;; 2979 if (strncmp(name,""class "",6)==0) name += 6;; 2980 if (strncmp(name,""struct "",7)==0) name += 7;; 2981 ; 2982 if (!gROOT->GetListOfClasses()) return nullptr;; 2983 ; 2984 // FindObject will take the read lock before actually getting the; 2985 // TClass ",MatchSource.WIKI,doc/v632/TClass_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/TClass_8cxx_source.html
https://root.cern/doc/v632/TClass_8cxx_source.html:110966,Performance,load,loading,110966," Get a wrapper/accessor function around this class custom streamer (member function).; 2938 ; 2939ClassStreamerFunc_t TClass::GetStreamerFunc() const; 2940{; 2941 return fStreamerFunc;; 2942}; 2943 ; 2944////////////////////////////////////////////////////////////////////////////////; 2945/// Get a wrapper/accessor function around this class custom conversion streamer (member function).; 2946 ; 2947ClassConvStreamerFunc_t TClass::GetConvStreamerFunc() const; 2948{; 2949 return fConvStreamerFunc;; 2950}; 2951 ; 2952////////////////////////////////////////////////////////////////////////////////; 2953/// Return the proxy implementing the IsA functionality.; 2954 ; 2955TVirtualIsAProxy* TClass::GetIsAProxy() const; 2956{; 2957 return fIsA;; 2958}; 2959 ; 2960////////////////////////////////////////////////////////////////////////////////; 2961/// Static method returning pointer to TClass of the specified class name.; 2962/// If load is true, an attempt is made to obtain the class by loading; 2963/// the appropriate shared library (directed by the rootmap file).; 2964/// If silent is 'true', do not warn about missing dictionary for the class.; 2965/// (typically used for classes that are used only for transient members); 2966/// Returns `nullptr` in case class is not found.; 2967 ; 2968TClass *TClass::GetClass(const char *name, Bool_t load, Bool_t silent); 2969{; 2970 return TClass::GetClass(name, load, silent, 0, 0);; 2971}; 2972 ; 2973TClass *TClass::GetClass(const char *name, Bool_t load, Bool_t silent, size_t hint_pair_offset, size_t hint_pair_size); 2974{; 2975 if (!name || !name[0]) return nullptr;; 2976 ; 2977 if (strstr(name, ""(anonymous)"")) return nullptr;; 2978 if (strstr(name, ""(unnamed)"")) return nullptr;; 2979 if (strncmp(name,""class "",6)==0) name += 6;; 2980 if (strncmp(name,""struct "",7)==0) name += 7;; 2981 ; 2982 if (!gROOT->GetListOfClasses()) return nullptr;; 2983 ; 2984 // FindObject will take the read lock before actually getting the; 2985 // TClass ",MatchSource.WIKI,doc/v632/TClass_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/TClass_8cxx_source.html
https://root.cern/doc/v632/TClass_8cxx_source.html:111324,Performance,load,load,111324,"alIsAProxy* TClass::GetIsAProxy() const; 2956{; 2957 return fIsA;; 2958}; 2959 ; 2960////////////////////////////////////////////////////////////////////////////////; 2961/// Static method returning pointer to TClass of the specified class name.; 2962/// If load is true, an attempt is made to obtain the class by loading; 2963/// the appropriate shared library (directed by the rootmap file).; 2964/// If silent is 'true', do not warn about missing dictionary for the class.; 2965/// (typically used for classes that are used only for transient members); 2966/// Returns `nullptr` in case class is not found.; 2967 ; 2968TClass *TClass::GetClass(const char *name, Bool_t load, Bool_t silent); 2969{; 2970 return TClass::GetClass(name, load, silent, 0, 0);; 2971}; 2972 ; 2973TClass *TClass::GetClass(const char *name, Bool_t load, Bool_t silent, size_t hint_pair_offset, size_t hint_pair_size); 2974{; 2975 if (!name || !name[0]) return nullptr;; 2976 ; 2977 if (strstr(name, ""(anonymous)"")) return nullptr;; 2978 if (strstr(name, ""(unnamed)"")) return nullptr;; 2979 if (strncmp(name,""class "",6)==0) name += 6;; 2980 if (strncmp(name,""struct "",7)==0) name += 7;; 2981 ; 2982 if (!gROOT->GetListOfClasses()) return nullptr;; 2983 ; 2984 // FindObject will take the read lock before actually getting the; 2985 // TClass pointer so we will need not get a partially initialized; 2986 // object.; 2987 TClass *cl = (TClass*)gROOT->GetListOfClasses()->FindObject(name);; 2988 ; 2989 // Early return to release the lock without having to execute the; 2990 // long-ish normalization.; 2991 if (cl && (cl->IsLoaded() || cl->TestBit(kUnloading))) return cl;; 2992 ; 2993 R__WRITE_LOCKGUARD(ROOT::gCoreMutex);; 2994 ; 2995 // Now that we got the write lock, another thread may have constructed the; 2996 // TClass while we were waiting, so we need to do the checks again.; 2997 ; 2998 cl = (TClass*)gROOT->GetListOfClasses()->FindObject(name);; 2999 if (cl) {; 3000 if (cl->IsLoaded() || cl->TestBit(kUnloading",MatchSource.WIKI,doc/v632/TClass_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/TClass_8cxx_source.html
https://root.cern/doc/v632/TClass_8cxx_source.html:111388,Performance,load,load,111388,"alIsAProxy* TClass::GetIsAProxy() const; 2956{; 2957 return fIsA;; 2958}; 2959 ; 2960////////////////////////////////////////////////////////////////////////////////; 2961/// Static method returning pointer to TClass of the specified class name.; 2962/// If load is true, an attempt is made to obtain the class by loading; 2963/// the appropriate shared library (directed by the rootmap file).; 2964/// If silent is 'true', do not warn about missing dictionary for the class.; 2965/// (typically used for classes that are used only for transient members); 2966/// Returns `nullptr` in case class is not found.; 2967 ; 2968TClass *TClass::GetClass(const char *name, Bool_t load, Bool_t silent); 2969{; 2970 return TClass::GetClass(name, load, silent, 0, 0);; 2971}; 2972 ; 2973TClass *TClass::GetClass(const char *name, Bool_t load, Bool_t silent, size_t hint_pair_offset, size_t hint_pair_size); 2974{; 2975 if (!name || !name[0]) return nullptr;; 2976 ; 2977 if (strstr(name, ""(anonymous)"")) return nullptr;; 2978 if (strstr(name, ""(unnamed)"")) return nullptr;; 2979 if (strncmp(name,""class "",6)==0) name += 6;; 2980 if (strncmp(name,""struct "",7)==0) name += 7;; 2981 ; 2982 if (!gROOT->GetListOfClasses()) return nullptr;; 2983 ; 2984 // FindObject will take the read lock before actually getting the; 2985 // TClass pointer so we will need not get a partially initialized; 2986 // object.; 2987 TClass *cl = (TClass*)gROOT->GetListOfClasses()->FindObject(name);; 2988 ; 2989 // Early return to release the lock without having to execute the; 2990 // long-ish normalization.; 2991 if (cl && (cl->IsLoaded() || cl->TestBit(kUnloading))) return cl;; 2992 ; 2993 R__WRITE_LOCKGUARD(ROOT::gCoreMutex);; 2994 ; 2995 // Now that we got the write lock, another thread may have constructed the; 2996 // TClass while we were waiting, so we need to do the checks again.; 2997 ; 2998 cl = (TClass*)gROOT->GetListOfClasses()->FindObject(name);; 2999 if (cl) {; 3000 if (cl->IsLoaded() || cl->TestBit(kUnloading",MatchSource.WIKI,doc/v632/TClass_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/TClass_8cxx_source.html
https://root.cern/doc/v632/TClass_8cxx_source.html:111478,Performance,load,load,111478,"alIsAProxy* TClass::GetIsAProxy() const; 2956{; 2957 return fIsA;; 2958}; 2959 ; 2960////////////////////////////////////////////////////////////////////////////////; 2961/// Static method returning pointer to TClass of the specified class name.; 2962/// If load is true, an attempt is made to obtain the class by loading; 2963/// the appropriate shared library (directed by the rootmap file).; 2964/// If silent is 'true', do not warn about missing dictionary for the class.; 2965/// (typically used for classes that are used only for transient members); 2966/// Returns `nullptr` in case class is not found.; 2967 ; 2968TClass *TClass::GetClass(const char *name, Bool_t load, Bool_t silent); 2969{; 2970 return TClass::GetClass(name, load, silent, 0, 0);; 2971}; 2972 ; 2973TClass *TClass::GetClass(const char *name, Bool_t load, Bool_t silent, size_t hint_pair_offset, size_t hint_pair_size); 2974{; 2975 if (!name || !name[0]) return nullptr;; 2976 ; 2977 if (strstr(name, ""(anonymous)"")) return nullptr;; 2978 if (strstr(name, ""(unnamed)"")) return nullptr;; 2979 if (strncmp(name,""class "",6)==0) name += 6;; 2980 if (strncmp(name,""struct "",7)==0) name += 7;; 2981 ; 2982 if (!gROOT->GetListOfClasses()) return nullptr;; 2983 ; 2984 // FindObject will take the read lock before actually getting the; 2985 // TClass pointer so we will need not get a partially initialized; 2986 // object.; 2987 TClass *cl = (TClass*)gROOT->GetListOfClasses()->FindObject(name);; 2988 ; 2989 // Early return to release the lock without having to execute the; 2990 // long-ish normalization.; 2991 if (cl && (cl->IsLoaded() || cl->TestBit(kUnloading))) return cl;; 2992 ; 2993 R__WRITE_LOCKGUARD(ROOT::gCoreMutex);; 2994 ; 2995 // Now that we got the write lock, another thread may have constructed the; 2996 // TClass while we were waiting, so we need to do the checks again.; 2997 ; 2998 cl = (TClass*)gROOT->GetListOfClasses()->FindObject(name);; 2999 if (cl) {; 3000 if (cl->IsLoaded() || cl->TestBit(kUnloading",MatchSource.WIKI,doc/v632/TClass_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/TClass_8cxx_source.html
https://root.cern/doc/v632/TClass_8cxx_source.html:112986,Performance,load,loaded,112986,"e,""struct "",7)==0) name += 7;; 2981 ; 2982 if (!gROOT->GetListOfClasses()) return nullptr;; 2983 ; 2984 // FindObject will take the read lock before actually getting the; 2985 // TClass pointer so we will need not get a partially initialized; 2986 // object.; 2987 TClass *cl = (TClass*)gROOT->GetListOfClasses()->FindObject(name);; 2988 ; 2989 // Early return to release the lock without having to execute the; 2990 // long-ish normalization.; 2991 if (cl && (cl->IsLoaded() || cl->TestBit(kUnloading))) return cl;; 2992 ; 2993 R__WRITE_LOCKGUARD(ROOT::gCoreMutex);; 2994 ; 2995 // Now that we got the write lock, another thread may have constructed the; 2996 // TClass while we were waiting, so we need to do the checks again.; 2997 ; 2998 cl = (TClass*)gROOT->GetListOfClasses()->FindObject(name);; 2999 if (cl) {; 3000 if (cl->IsLoaded() || cl->TestBit(kUnloading)) return cl;; 3001 ; 3002 // We could speed-up some of the search by adding (the equivalent of); 3003 //; 3004 // if (cl->GetState() == kInterpreter) return cl; 3005 //; 3006 // In this case, if a ROOT dictionary was available when the TClass; 3007 // was first requested it would have been used and if a ROOT dictionary is; 3008 // loaded later on TClassTable::Add will take care of updating the TClass.; 3009 // So as far as ROOT dictionary are concerned, if the current TClass is; 3010 // in interpreted state, we are sure there is nothing to load.; 3011 //; 3012 // However (see TROOT::LoadClass), the TClass can also be loaded/provided; 3013 // by a user provided TClassGenerator. We have no way of knowing whether; 3014 // those do (or even can) behave the same way as the ROOT dictionary and; 3015 // have the 'dictionary is now available for use' step informs the existing; 3016 // TClass that their dictionary is now available.; 3017 ; 3018 //we may pass here in case of a dummy class created by TVirtualStreamerInfo; 3019 load = kTRUE;; 3020 }; 3021 ; 3022 if (TClassEdit::IsArtificial(name)) {; 3023 // If there is a @ sy",MatchSource.WIKI,doc/v632/TClass_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/TClass_8cxx_source.html
https://root.cern/doc/v632/TClass_8cxx_source.html:113199,Performance,load,load,113199,"// Early return to release the lock without having to execute the; 2990 // long-ish normalization.; 2991 if (cl && (cl->IsLoaded() || cl->TestBit(kUnloading))) return cl;; 2992 ; 2993 R__WRITE_LOCKGUARD(ROOT::gCoreMutex);; 2994 ; 2995 // Now that we got the write lock, another thread may have constructed the; 2996 // TClass while we were waiting, so we need to do the checks again.; 2997 ; 2998 cl = (TClass*)gROOT->GetListOfClasses()->FindObject(name);; 2999 if (cl) {; 3000 if (cl->IsLoaded() || cl->TestBit(kUnloading)) return cl;; 3001 ; 3002 // We could speed-up some of the search by adding (the equivalent of); 3003 //; 3004 // if (cl->GetState() == kInterpreter) return cl; 3005 //; 3006 // In this case, if a ROOT dictionary was available when the TClass; 3007 // was first requested it would have been used and if a ROOT dictionary is; 3008 // loaded later on TClassTable::Add will take care of updating the TClass.; 3009 // So as far as ROOT dictionary are concerned, if the current TClass is; 3010 // in interpreted state, we are sure there is nothing to load.; 3011 //; 3012 // However (see TROOT::LoadClass), the TClass can also be loaded/provided; 3013 // by a user provided TClassGenerator. We have no way of knowing whether; 3014 // those do (or even can) behave the same way as the ROOT dictionary and; 3015 // have the 'dictionary is now available for use' step informs the existing; 3016 // TClass that their dictionary is now available.; 3017 ; 3018 //we may pass here in case of a dummy class created by TVirtualStreamerInfo; 3019 load = kTRUE;; 3020 }; 3021 ; 3022 if (TClassEdit::IsArtificial(name)) {; 3023 // If there is a @ symbol (followed by a version number) then this is a synthetic class name created; 3024 // from an already normalized name for the purpose of supporting schema evolution.; 3025 // There is no dictionary or interpreter information about this kind of class, the only; 3026 // (undesirable) side-effect of doing the search would be a waste of CPU time",MatchSource.WIKI,doc/v632/TClass_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/TClass_8cxx_source.html
https://root.cern/doc/v632/TClass_8cxx_source.html:113278,Performance,load,loaded,113278,"tBit(kUnloading))) return cl;; 2992 ; 2993 R__WRITE_LOCKGUARD(ROOT::gCoreMutex);; 2994 ; 2995 // Now that we got the write lock, another thread may have constructed the; 2996 // TClass while we were waiting, so we need to do the checks again.; 2997 ; 2998 cl = (TClass*)gROOT->GetListOfClasses()->FindObject(name);; 2999 if (cl) {; 3000 if (cl->IsLoaded() || cl->TestBit(kUnloading)) return cl;; 3001 ; 3002 // We could speed-up some of the search by adding (the equivalent of); 3003 //; 3004 // if (cl->GetState() == kInterpreter) return cl; 3005 //; 3006 // In this case, if a ROOT dictionary was available when the TClass; 3007 // was first requested it would have been used and if a ROOT dictionary is; 3008 // loaded later on TClassTable::Add will take care of updating the TClass.; 3009 // So as far as ROOT dictionary are concerned, if the current TClass is; 3010 // in interpreted state, we are sure there is nothing to load.; 3011 //; 3012 // However (see TROOT::LoadClass), the TClass can also be loaded/provided; 3013 // by a user provided TClassGenerator. We have no way of knowing whether; 3014 // those do (or even can) behave the same way as the ROOT dictionary and; 3015 // have the 'dictionary is now available for use' step informs the existing; 3016 // TClass that their dictionary is now available.; 3017 ; 3018 //we may pass here in case of a dummy class created by TVirtualStreamerInfo; 3019 load = kTRUE;; 3020 }; 3021 ; 3022 if (TClassEdit::IsArtificial(name)) {; 3023 // If there is a @ symbol (followed by a version number) then this is a synthetic class name created; 3024 // from an already normalized name for the purpose of supporting schema evolution.; 3025 // There is no dictionary or interpreter information about this kind of class, the only; 3026 // (undesirable) side-effect of doing the search would be a waste of CPU time and potential; 3027 // auto-loading or auto-parsing based on the scope of the name.; 3028 return cl;; 3029 }; 3030 ; 3031 // To avoid spuri",MatchSource.WIKI,doc/v632/TClass_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/TClass_8cxx_source.html
https://root.cern/doc/v632/TClass_8cxx_source.html:113685,Performance,load,load,113685,"cl->GetState() == kInterpreter) return cl; 3005 //; 3006 // In this case, if a ROOT dictionary was available when the TClass; 3007 // was first requested it would have been used and if a ROOT dictionary is; 3008 // loaded later on TClassTable::Add will take care of updating the TClass.; 3009 // So as far as ROOT dictionary are concerned, if the current TClass is; 3010 // in interpreted state, we are sure there is nothing to load.; 3011 //; 3012 // However (see TROOT::LoadClass), the TClass can also be loaded/provided; 3013 // by a user provided TClassGenerator. We have no way of knowing whether; 3014 // those do (or even can) behave the same way as the ROOT dictionary and; 3015 // have the 'dictionary is now available for use' step informs the existing; 3016 // TClass that their dictionary is now available.; 3017 ; 3018 //we may pass here in case of a dummy class created by TVirtualStreamerInfo; 3019 load = kTRUE;; 3020 }; 3021 ; 3022 if (TClassEdit::IsArtificial(name)) {; 3023 // If there is a @ symbol (followed by a version number) then this is a synthetic class name created; 3024 // from an already normalized name for the purpose of supporting schema evolution.; 3025 // There is no dictionary or interpreter information about this kind of class, the only; 3026 // (undesirable) side-effect of doing the search would be a waste of CPU time and potential; 3027 // auto-loading or auto-parsing based on the scope of the name.; 3028 return cl;; 3029 }; 3030 ; 3031 // To avoid spurious auto parsing, let's check if the name as-is is; 3032 // known in the TClassTable.; 3033 DictFuncPtr_t dict = TClassTable::GetDictNorm(name);; 3034 if (dict) {; 3035 // The name is normalized, so the result of the first search is; 3036 // authoritative.; 3037 if (!cl && !load) return nullptr;; 3038 ; 3039 TClass *loadedcl = (dict)();; 3040 if (loadedcl) {; 3041 loadedcl->PostLoadCheck();; 3042 return loadedcl;; 3043 }; 3044 ; 3045 // We should really not fall through to here, but if we do, le",MatchSource.WIKI,doc/v632/TClass_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/TClass_8cxx_source.html
https://root.cern/doc/v632/TClass_8cxx_source.html:114160,Performance,load,loading,114160," dictionary are concerned, if the current TClass is; 3010 // in interpreted state, we are sure there is nothing to load.; 3011 //; 3012 // However (see TROOT::LoadClass), the TClass can also be loaded/provided; 3013 // by a user provided TClassGenerator. We have no way of knowing whether; 3014 // those do (or even can) behave the same way as the ROOT dictionary and; 3015 // have the 'dictionary is now available for use' step informs the existing; 3016 // TClass that their dictionary is now available.; 3017 ; 3018 //we may pass here in case of a dummy class created by TVirtualStreamerInfo; 3019 load = kTRUE;; 3020 }; 3021 ; 3022 if (TClassEdit::IsArtificial(name)) {; 3023 // If there is a @ symbol (followed by a version number) then this is a synthetic class name created; 3024 // from an already normalized name for the purpose of supporting schema evolution.; 3025 // There is no dictionary or interpreter information about this kind of class, the only; 3026 // (undesirable) side-effect of doing the search would be a waste of CPU time and potential; 3027 // auto-loading or auto-parsing based on the scope of the name.; 3028 return cl;; 3029 }; 3030 ; 3031 // To avoid spurious auto parsing, let's check if the name as-is is; 3032 // known in the TClassTable.; 3033 DictFuncPtr_t dict = TClassTable::GetDictNorm(name);; 3034 if (dict) {; 3035 // The name is normalized, so the result of the first search is; 3036 // authoritative.; 3037 if (!cl && !load) return nullptr;; 3038 ; 3039 TClass *loadedcl = (dict)();; 3040 if (loadedcl) {; 3041 loadedcl->PostLoadCheck();; 3042 return loadedcl;; 3043 }; 3044 ; 3045 // We should really not fall through to here, but if we do, let's just; 3046 // continue as before ...; 3047 }; 3048 ; 3049 std::string normalizedName;; 3050 Bool_t checkTable = kFALSE;; 3051 ; 3052 if (!cl) {; 3053 {; 3054 TInterpreter::SuspendAutoLoadingRAII autoloadOff(gInterpreter);; 3055 TClassEdit::GetNormalizedName(normalizedName, name);; 3056 }; 3057 // Try the nor",MatchSource.WIKI,doc/v632/TClass_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/TClass_8cxx_source.html
https://root.cern/doc/v632/TClass_8cxx_source.html:114546,Performance,load,load,114546,"reamerInfo; 3019 load = kTRUE;; 3020 }; 3021 ; 3022 if (TClassEdit::IsArtificial(name)) {; 3023 // If there is a @ symbol (followed by a version number) then this is a synthetic class name created; 3024 // from an already normalized name for the purpose of supporting schema evolution.; 3025 // There is no dictionary or interpreter information about this kind of class, the only; 3026 // (undesirable) side-effect of doing the search would be a waste of CPU time and potential; 3027 // auto-loading or auto-parsing based on the scope of the name.; 3028 return cl;; 3029 }; 3030 ; 3031 // To avoid spurious auto parsing, let's check if the name as-is is; 3032 // known in the TClassTable.; 3033 DictFuncPtr_t dict = TClassTable::GetDictNorm(name);; 3034 if (dict) {; 3035 // The name is normalized, so the result of the first search is; 3036 // authoritative.; 3037 if (!cl && !load) return nullptr;; 3038 ; 3039 TClass *loadedcl = (dict)();; 3040 if (loadedcl) {; 3041 loadedcl->PostLoadCheck();; 3042 return loadedcl;; 3043 }; 3044 ; 3045 // We should really not fall through to here, but if we do, let's just; 3046 // continue as before ...; 3047 }; 3048 ; 3049 std::string normalizedName;; 3050 Bool_t checkTable = kFALSE;; 3051 ; 3052 if (!cl) {; 3053 {; 3054 TInterpreter::SuspendAutoLoadingRAII autoloadOff(gInterpreter);; 3055 TClassEdit::GetNormalizedName(normalizedName, name);; 3056 }; 3057 // Try the normalized name.; 3058 if (normalizedName != name) {; 3059 cl = (TClass*)gROOT->GetListOfClasses()->FindObject(normalizedName.c_str());; 3060 ; 3061 if (cl) {; 3062 if (cl->IsLoaded() || cl->TestBit(kUnloading)) return cl;; 3063 ; 3064 //we may pass here in case of a dummy class created by TVirtualStreamerInfo; 3065 load = kTRUE;; 3066 }; 3067 checkTable = kTRUE;; 3068 }; 3069 } else {; 3070 normalizedName = cl->GetName(); // Use the fact that all TClass names are normalized.; 3071 checkTable = load && (normalizedName != name);; 3072 }; 3073 ; 3074 if (!load) return nullptr;; 3075",MatchSource.WIKI,doc/v632/TClass_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/TClass_8cxx_source.html
https://root.cern/doc/v632/TClass_8cxx_source.html:114589,Performance,load,loadedcl,114589,"reamerInfo; 3019 load = kTRUE;; 3020 }; 3021 ; 3022 if (TClassEdit::IsArtificial(name)) {; 3023 // If there is a @ symbol (followed by a version number) then this is a synthetic class name created; 3024 // from an already normalized name for the purpose of supporting schema evolution.; 3025 // There is no dictionary or interpreter information about this kind of class, the only; 3026 // (undesirable) side-effect of doing the search would be a waste of CPU time and potential; 3027 // auto-loading or auto-parsing based on the scope of the name.; 3028 return cl;; 3029 }; 3030 ; 3031 // To avoid spurious auto parsing, let's check if the name as-is is; 3032 // known in the TClassTable.; 3033 DictFuncPtr_t dict = TClassTable::GetDictNorm(name);; 3034 if (dict) {; 3035 // The name is normalized, so the result of the first search is; 3036 // authoritative.; 3037 if (!cl && !load) return nullptr;; 3038 ; 3039 TClass *loadedcl = (dict)();; 3040 if (loadedcl) {; 3041 loadedcl->PostLoadCheck();; 3042 return loadedcl;; 3043 }; 3044 ; 3045 // We should really not fall through to here, but if we do, let's just; 3046 // continue as before ...; 3047 }; 3048 ; 3049 std::string normalizedName;; 3050 Bool_t checkTable = kFALSE;; 3051 ; 3052 if (!cl) {; 3053 {; 3054 TInterpreter::SuspendAutoLoadingRAII autoloadOff(gInterpreter);; 3055 TClassEdit::GetNormalizedName(normalizedName, name);; 3056 }; 3057 // Try the normalized name.; 3058 if (normalizedName != name) {; 3059 cl = (TClass*)gROOT->GetListOfClasses()->FindObject(normalizedName.c_str());; 3060 ; 3061 if (cl) {; 3062 if (cl->IsLoaded() || cl->TestBit(kUnloading)) return cl;; 3063 ; 3064 //we may pass here in case of a dummy class created by TVirtualStreamerInfo; 3065 load = kTRUE;; 3066 }; 3067 checkTable = kTRUE;; 3068 }; 3069 } else {; 3070 normalizedName = cl->GetName(); // Use the fact that all TClass names are normalized.; 3071 checkTable = load && (normalizedName != name);; 3072 }; 3073 ; 3074 if (!load) return nullptr;; 3075",MatchSource.WIKI,doc/v632/TClass_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/TClass_8cxx_source.html
https://root.cern/doc/v632/TClass_8cxx_source.html:114620,Performance,load,loadedcl,114620,"reamerInfo; 3019 load = kTRUE;; 3020 }; 3021 ; 3022 if (TClassEdit::IsArtificial(name)) {; 3023 // If there is a @ symbol (followed by a version number) then this is a synthetic class name created; 3024 // from an already normalized name for the purpose of supporting schema evolution.; 3025 // There is no dictionary or interpreter information about this kind of class, the only; 3026 // (undesirable) side-effect of doing the search would be a waste of CPU time and potential; 3027 // auto-loading or auto-parsing based on the scope of the name.; 3028 return cl;; 3029 }; 3030 ; 3031 // To avoid spurious auto parsing, let's check if the name as-is is; 3032 // known in the TClassTable.; 3033 DictFuncPtr_t dict = TClassTable::GetDictNorm(name);; 3034 if (dict) {; 3035 // The name is normalized, so the result of the first search is; 3036 // authoritative.; 3037 if (!cl && !load) return nullptr;; 3038 ; 3039 TClass *loadedcl = (dict)();; 3040 if (loadedcl) {; 3041 loadedcl->PostLoadCheck();; 3042 return loadedcl;; 3043 }; 3044 ; 3045 // We should really not fall through to here, but if we do, let's just; 3046 // continue as before ...; 3047 }; 3048 ; 3049 std::string normalizedName;; 3050 Bool_t checkTable = kFALSE;; 3051 ; 3052 if (!cl) {; 3053 {; 3054 TInterpreter::SuspendAutoLoadingRAII autoloadOff(gInterpreter);; 3055 TClassEdit::GetNormalizedName(normalizedName, name);; 3056 }; 3057 // Try the normalized name.; 3058 if (normalizedName != name) {; 3059 cl = (TClass*)gROOT->GetListOfClasses()->FindObject(normalizedName.c_str());; 3060 ; 3061 if (cl) {; 3062 if (cl->IsLoaded() || cl->TestBit(kUnloading)) return cl;; 3063 ; 3064 //we may pass here in case of a dummy class created by TVirtualStreamerInfo; 3065 load = kTRUE;; 3066 }; 3067 checkTable = kTRUE;; 3068 }; 3069 } else {; 3070 normalizedName = cl->GetName(); // Use the fact that all TClass names are normalized.; 3071 checkTable = load && (normalizedName != name);; 3072 }; 3073 ; 3074 if (!load) return nullptr;; 3075",MatchSource.WIKI,doc/v632/TClass_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/TClass_8cxx_source.html
https://root.cern/doc/v632/TClass_8cxx_source.html:114638,Performance,load,loadedcl,114638,"reamerInfo; 3019 load = kTRUE;; 3020 }; 3021 ; 3022 if (TClassEdit::IsArtificial(name)) {; 3023 // If there is a @ symbol (followed by a version number) then this is a synthetic class name created; 3024 // from an already normalized name for the purpose of supporting schema evolution.; 3025 // There is no dictionary or interpreter information about this kind of class, the only; 3026 // (undesirable) side-effect of doing the search would be a waste of CPU time and potential; 3027 // auto-loading or auto-parsing based on the scope of the name.; 3028 return cl;; 3029 }; 3030 ; 3031 // To avoid spurious auto parsing, let's check if the name as-is is; 3032 // known in the TClassTable.; 3033 DictFuncPtr_t dict = TClassTable::GetDictNorm(name);; 3034 if (dict) {; 3035 // The name is normalized, so the result of the first search is; 3036 // authoritative.; 3037 if (!cl && !load) return nullptr;; 3038 ; 3039 TClass *loadedcl = (dict)();; 3040 if (loadedcl) {; 3041 loadedcl->PostLoadCheck();; 3042 return loadedcl;; 3043 }; 3044 ; 3045 // We should really not fall through to here, but if we do, let's just; 3046 // continue as before ...; 3047 }; 3048 ; 3049 std::string normalizedName;; 3050 Bool_t checkTable = kFALSE;; 3051 ; 3052 if (!cl) {; 3053 {; 3054 TInterpreter::SuspendAutoLoadingRAII autoloadOff(gInterpreter);; 3055 TClassEdit::GetNormalizedName(normalizedName, name);; 3056 }; 3057 // Try the normalized name.; 3058 if (normalizedName != name) {; 3059 cl = (TClass*)gROOT->GetListOfClasses()->FindObject(normalizedName.c_str());; 3060 ; 3061 if (cl) {; 3062 if (cl->IsLoaded() || cl->TestBit(kUnloading)) return cl;; 3063 ; 3064 //we may pass here in case of a dummy class created by TVirtualStreamerInfo; 3065 load = kTRUE;; 3066 }; 3067 checkTable = kTRUE;; 3068 }; 3069 } else {; 3070 normalizedName = cl->GetName(); // Use the fact that all TClass names are normalized.; 3071 checkTable = load && (normalizedName != name);; 3072 }; 3073 ; 3074 if (!load) return nullptr;; 3075",MatchSource.WIKI,doc/v632/TClass_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/TClass_8cxx_source.html
https://root.cern/doc/v632/TClass_8cxx_source.html:114678,Performance,load,loadedcl,114678,"reamerInfo; 3019 load = kTRUE;; 3020 }; 3021 ; 3022 if (TClassEdit::IsArtificial(name)) {; 3023 // If there is a @ symbol (followed by a version number) then this is a synthetic class name created; 3024 // from an already normalized name for the purpose of supporting schema evolution.; 3025 // There is no dictionary or interpreter information about this kind of class, the only; 3026 // (undesirable) side-effect of doing the search would be a waste of CPU time and potential; 3027 // auto-loading or auto-parsing based on the scope of the name.; 3028 return cl;; 3029 }; 3030 ; 3031 // To avoid spurious auto parsing, let's check if the name as-is is; 3032 // known in the TClassTable.; 3033 DictFuncPtr_t dict = TClassTable::GetDictNorm(name);; 3034 if (dict) {; 3035 // The name is normalized, so the result of the first search is; 3036 // authoritative.; 3037 if (!cl && !load) return nullptr;; 3038 ; 3039 TClass *loadedcl = (dict)();; 3040 if (loadedcl) {; 3041 loadedcl->PostLoadCheck();; 3042 return loadedcl;; 3043 }; 3044 ; 3045 // We should really not fall through to here, but if we do, let's just; 3046 // continue as before ...; 3047 }; 3048 ; 3049 std::string normalizedName;; 3050 Bool_t checkTable = kFALSE;; 3051 ; 3052 if (!cl) {; 3053 {; 3054 TInterpreter::SuspendAutoLoadingRAII autoloadOff(gInterpreter);; 3055 TClassEdit::GetNormalizedName(normalizedName, name);; 3056 }; 3057 // Try the normalized name.; 3058 if (normalizedName != name) {; 3059 cl = (TClass*)gROOT->GetListOfClasses()->FindObject(normalizedName.c_str());; 3060 ; 3061 if (cl) {; 3062 if (cl->IsLoaded() || cl->TestBit(kUnloading)) return cl;; 3063 ; 3064 //we may pass here in case of a dummy class created by TVirtualStreamerInfo; 3065 load = kTRUE;; 3066 }; 3067 checkTable = kTRUE;; 3068 }; 3069 } else {; 3070 normalizedName = cl->GetName(); // Use the fact that all TClass names are normalized.; 3071 checkTable = load && (normalizedName != name);; 3072 }; 3073 ; 3074 if (!load) return nullptr;; 3075",MatchSource.WIKI,doc/v632/TClass_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/TClass_8cxx_source.html
https://root.cern/doc/v632/TClass_8cxx_source.html:115399,Performance,load,load,115399,"TClassTable::GetDictNorm(name);; 3034 if (dict) {; 3035 // The name is normalized, so the result of the first search is; 3036 // authoritative.; 3037 if (!cl && !load) return nullptr;; 3038 ; 3039 TClass *loadedcl = (dict)();; 3040 if (loadedcl) {; 3041 loadedcl->PostLoadCheck();; 3042 return loadedcl;; 3043 }; 3044 ; 3045 // We should really not fall through to here, but if we do, let's just; 3046 // continue as before ...; 3047 }; 3048 ; 3049 std::string normalizedName;; 3050 Bool_t checkTable = kFALSE;; 3051 ; 3052 if (!cl) {; 3053 {; 3054 TInterpreter::SuspendAutoLoadingRAII autoloadOff(gInterpreter);; 3055 TClassEdit::GetNormalizedName(normalizedName, name);; 3056 }; 3057 // Try the normalized name.; 3058 if (normalizedName != name) {; 3059 cl = (TClass*)gROOT->GetListOfClasses()->FindObject(normalizedName.c_str());; 3060 ; 3061 if (cl) {; 3062 if (cl->IsLoaded() || cl->TestBit(kUnloading)) return cl;; 3063 ; 3064 //we may pass here in case of a dummy class created by TVirtualStreamerInfo; 3065 load = kTRUE;; 3066 }; 3067 checkTable = kTRUE;; 3068 }; 3069 } else {; 3070 normalizedName = cl->GetName(); // Use the fact that all TClass names are normalized.; 3071 checkTable = load && (normalizedName != name);; 3072 }; 3073 ; 3074 if (!load) return nullptr;; 3075 ; 3076// This assertion currently fails because of; 3077// TClass *c1 = TClass::GetClass(""basic_iostream<char,char_traits<char> >"");; 3078// TClass *c2 = TClass::GetClass(""std::iostream"");; 3079// where the TClassEdit normalized name of iostream is basic_iostream<char>; 3080// i.e missing the addition of the default parameter. This is because TClingLookupHelper; 3081// uses only 'part' of TMetaUtils::GetNormalizedName.; 3082 ; 3083// if (!cl) {; 3084// TDataType* dataType = (TDataType*)gROOT->GetListOfTypes()->FindObject(name);; 3085// TClass *altcl = dataType ? (TClass*)gROOT->GetListOfClasses()->FindObject(dataType->GetFullTypeName()) : 0;; 3086// if (altcl && normalizedName != altcl->GetName()); 3087// ",MatchSource.WIKI,doc/v632/TClass_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/TClass_8cxx_source.html
https://root.cern/doc/v632/TClass_8cxx_source.html:115581,Performance,load,load,115581,"but if we do, let's just; 3046 // continue as before ...; 3047 }; 3048 ; 3049 std::string normalizedName;; 3050 Bool_t checkTable = kFALSE;; 3051 ; 3052 if (!cl) {; 3053 {; 3054 TInterpreter::SuspendAutoLoadingRAII autoloadOff(gInterpreter);; 3055 TClassEdit::GetNormalizedName(normalizedName, name);; 3056 }; 3057 // Try the normalized name.; 3058 if (normalizedName != name) {; 3059 cl = (TClass*)gROOT->GetListOfClasses()->FindObject(normalizedName.c_str());; 3060 ; 3061 if (cl) {; 3062 if (cl->IsLoaded() || cl->TestBit(kUnloading)) return cl;; 3063 ; 3064 //we may pass here in case of a dummy class created by TVirtualStreamerInfo; 3065 load = kTRUE;; 3066 }; 3067 checkTable = kTRUE;; 3068 }; 3069 } else {; 3070 normalizedName = cl->GetName(); // Use the fact that all TClass names are normalized.; 3071 checkTable = load && (normalizedName != name);; 3072 }; 3073 ; 3074 if (!load) return nullptr;; 3075 ; 3076// This assertion currently fails because of; 3077// TClass *c1 = TClass::GetClass(""basic_iostream<char,char_traits<char> >"");; 3078// TClass *c2 = TClass::GetClass(""std::iostream"");; 3079// where the TClassEdit normalized name of iostream is basic_iostream<char>; 3080// i.e missing the addition of the default parameter. This is because TClingLookupHelper; 3081// uses only 'part' of TMetaUtils::GetNormalizedName.; 3082 ; 3083// if (!cl) {; 3084// TDataType* dataType = (TDataType*)gROOT->GetListOfTypes()->FindObject(name);; 3085// TClass *altcl = dataType ? (TClass*)gROOT->GetListOfClasses()->FindObject(dataType->GetFullTypeName()) : 0;; 3086// if (altcl && normalizedName != altcl->GetName()); 3087// ::Fatal(""TClass::GetClass"",""The existing name (%s) for %s is different from the normalized name: %s\n"",; 3088// altcl->GetName(), name, normalizedName.c_str());; 3089// }; 3090 ; 3091 // We want to avoid auto-parsing due to intentionally missing dictionary for std::pair.; 3092 // However, we don't need this special treatement in rootcling (there is no auto-parsing); 30",MatchSource.WIKI,doc/v632/TClass_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/TClass_8cxx_source.html
https://root.cern/doc/v632/TClass_8cxx_source.html:115641,Performance,load,load,115641,"but if we do, let's just; 3046 // continue as before ...; 3047 }; 3048 ; 3049 std::string normalizedName;; 3050 Bool_t checkTable = kFALSE;; 3051 ; 3052 if (!cl) {; 3053 {; 3054 TInterpreter::SuspendAutoLoadingRAII autoloadOff(gInterpreter);; 3055 TClassEdit::GetNormalizedName(normalizedName, name);; 3056 }; 3057 // Try the normalized name.; 3058 if (normalizedName != name) {; 3059 cl = (TClass*)gROOT->GetListOfClasses()->FindObject(normalizedName.c_str());; 3060 ; 3061 if (cl) {; 3062 if (cl->IsLoaded() || cl->TestBit(kUnloading)) return cl;; 3063 ; 3064 //we may pass here in case of a dummy class created by TVirtualStreamerInfo; 3065 load = kTRUE;; 3066 }; 3067 checkTable = kTRUE;; 3068 }; 3069 } else {; 3070 normalizedName = cl->GetName(); // Use the fact that all TClass names are normalized.; 3071 checkTable = load && (normalizedName != name);; 3072 }; 3073 ; 3074 if (!load) return nullptr;; 3075 ; 3076// This assertion currently fails because of; 3077// TClass *c1 = TClass::GetClass(""basic_iostream<char,char_traits<char> >"");; 3078// TClass *c2 = TClass::GetClass(""std::iostream"");; 3079// where the TClassEdit normalized name of iostream is basic_iostream<char>; 3080// i.e missing the addition of the default parameter. This is because TClingLookupHelper; 3081// uses only 'part' of TMetaUtils::GetNormalizedName.; 3082 ; 3083// if (!cl) {; 3084// TDataType* dataType = (TDataType*)gROOT->GetListOfTypes()->FindObject(name);; 3085// TClass *altcl = dataType ? (TClass*)gROOT->GetListOfClasses()->FindObject(dataType->GetFullTypeName()) : 0;; 3086// if (altcl && normalizedName != altcl->GetName()); 3087// ::Fatal(""TClass::GetClass"",""The existing name (%s) for %s is different from the normalized name: %s\n"",; 3088// altcl->GetName(), name, normalizedName.c_str());; 3089// }; 3090 ; 3091 // We want to avoid auto-parsing due to intentionally missing dictionary for std::pair.; 3092 // However, we don't need this special treatement in rootcling (there is no auto-parsing); 30",MatchSource.WIKI,doc/v632/TClass_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/TClass_8cxx_source.html
https://root.cern/doc/v632/TClass_8cxx_source.html:117312,Performance,load,loadedcl,117312,"tListOfClasses()->FindObject(dataType->GetFullTypeName()) : 0;; 3086// if (altcl && normalizedName != altcl->GetName()); 3087// ::Fatal(""TClass::GetClass"",""The existing name (%s) for %s is different from the normalized name: %s\n"",; 3088// altcl->GetName(), name, normalizedName.c_str());; 3089// }; 3090 ; 3091 // We want to avoid auto-parsing due to intentionally missing dictionary for std::pair.; 3092 // However, we don't need this special treatement in rootcling (there is no auto-parsing); 3093 // and we want to make that the TClass for the pair goes through the regular creation; 3094 // mechanism (i.e. in rootcling they should be in kInterpreted state and never in; 3095 // kEmulated state) so that they have proper interpreter (ClassInfo) information which; 3096 // will be used to create the TProtoClass (if one is requested for the pair).; 3097 const bool ispair = TClassEdit::IsStdPair(normalizedName) && !IsFromRootCling();; 3098 const bool ispairbase = TClassEdit::IsStdPairBase(normalizedName) && !IsFromRootCling();; 3099 ; 3100 TClass *loadedcl = nullptr;; 3101 if (checkTable) {; 3102 loadedcl = LoadClassDefault(normalizedName.c_str(),silent);; 3103 } else {; 3104 if (gInterpreter->AutoLoad(normalizedName.c_str(),kTRUE)) {; 3105 // At this point more information has been loaded. This; 3106 // information might be pertinent to the normalization of the name.; 3107 // For example it might contain or be a typedef for which we don't; 3108 // have a forward declaration (eg. typedef to instance of class; 3109 // template with default parameters). So let's redo the normalization; 3110 // as the new information (eg. typedef in TROOT::GetListOfTypes) might; 3111 // lead to a different value.; 3112 {; 3113 TInterpreter::SuspendAutoLoadingRAII autoloadOff(gInterpreter);; 3114 TClassEdit::GetNormalizedName(normalizedName, name);; 3115 }; 3116 loadedcl = LoadClassDefault(normalizedName.c_str(),silent);; 3117 }; 3118 auto e = TEnum::GetEnum(normalizedName.c_str(), TEnum::kNone)",MatchSource.WIKI,doc/v632/TClass_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/TClass_8cxx_source.html
https://root.cern/doc/v632/TClass_8cxx_source.html:117362,Performance,load,loadedcl,117362,"tListOfClasses()->FindObject(dataType->GetFullTypeName()) : 0;; 3086// if (altcl && normalizedName != altcl->GetName()); 3087// ::Fatal(""TClass::GetClass"",""The existing name (%s) for %s is different from the normalized name: %s\n"",; 3088// altcl->GetName(), name, normalizedName.c_str());; 3089// }; 3090 ; 3091 // We want to avoid auto-parsing due to intentionally missing dictionary for std::pair.; 3092 // However, we don't need this special treatement in rootcling (there is no auto-parsing); 3093 // and we want to make that the TClass for the pair goes through the regular creation; 3094 // mechanism (i.e. in rootcling they should be in kInterpreted state and never in; 3095 // kEmulated state) so that they have proper interpreter (ClassInfo) information which; 3096 // will be used to create the TProtoClass (if one is requested for the pair).; 3097 const bool ispair = TClassEdit::IsStdPair(normalizedName) && !IsFromRootCling();; 3098 const bool ispairbase = TClassEdit::IsStdPairBase(normalizedName) && !IsFromRootCling();; 3099 ; 3100 TClass *loadedcl = nullptr;; 3101 if (checkTable) {; 3102 loadedcl = LoadClassDefault(normalizedName.c_str(),silent);; 3103 } else {; 3104 if (gInterpreter->AutoLoad(normalizedName.c_str(),kTRUE)) {; 3105 // At this point more information has been loaded. This; 3106 // information might be pertinent to the normalization of the name.; 3107 // For example it might contain or be a typedef for which we don't; 3108 // have a forward declaration (eg. typedef to instance of class; 3109 // template with default parameters). So let's redo the normalization; 3110 // as the new information (eg. typedef in TROOT::GetListOfTypes) might; 3111 // lead to a different value.; 3112 {; 3113 TInterpreter::SuspendAutoLoadingRAII autoloadOff(gInterpreter);; 3114 TClassEdit::GetNormalizedName(normalizedName, name);; 3115 }; 3116 loadedcl = LoadClassDefault(normalizedName.c_str(),silent);; 3117 }; 3118 auto e = TEnum::GetEnum(normalizedName.c_str(), TEnum::kNone)",MatchSource.WIKI,doc/v632/TClass_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/TClass_8cxx_source.html
https://root.cern/doc/v632/TClass_8cxx_source.html:117552,Performance,load,loaded,117552,"rmalizedName.c_str());; 3089// }; 3090 ; 3091 // We want to avoid auto-parsing due to intentionally missing dictionary for std::pair.; 3092 // However, we don't need this special treatement in rootcling (there is no auto-parsing); 3093 // and we want to make that the TClass for the pair goes through the regular creation; 3094 // mechanism (i.e. in rootcling they should be in kInterpreted state and never in; 3095 // kEmulated state) so that they have proper interpreter (ClassInfo) information which; 3096 // will be used to create the TProtoClass (if one is requested for the pair).; 3097 const bool ispair = TClassEdit::IsStdPair(normalizedName) && !IsFromRootCling();; 3098 const bool ispairbase = TClassEdit::IsStdPairBase(normalizedName) && !IsFromRootCling();; 3099 ; 3100 TClass *loadedcl = nullptr;; 3101 if (checkTable) {; 3102 loadedcl = LoadClassDefault(normalizedName.c_str(),silent);; 3103 } else {; 3104 if (gInterpreter->AutoLoad(normalizedName.c_str(),kTRUE)) {; 3105 // At this point more information has been loaded. This; 3106 // information might be pertinent to the normalization of the name.; 3107 // For example it might contain or be a typedef for which we don't; 3108 // have a forward declaration (eg. typedef to instance of class; 3109 // template with default parameters). So let's redo the normalization; 3110 // as the new information (eg. typedef in TROOT::GetListOfTypes) might; 3111 // lead to a different value.; 3112 {; 3113 TInterpreter::SuspendAutoLoadingRAII autoloadOff(gInterpreter);; 3114 TClassEdit::GetNormalizedName(normalizedName, name);; 3115 }; 3116 loadedcl = LoadClassDefault(normalizedName.c_str(),silent);; 3117 }; 3118 auto e = TEnum::GetEnum(normalizedName.c_str(), TEnum::kNone);; 3119 if (e); 3120 return nullptr;; 3121 // Maybe this was a typedef: let's try to see if this is the case; 3122 if (!loadedcl && !ispair && !ispairbase) {; 3123 if (TDataType* theDataType = gROOT->GetType(normalizedName.c_str())){; 3124 // We have a typedef: we ",MatchSource.WIKI,doc/v632/TClass_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/TClass_8cxx_source.html
https://root.cern/doc/v632/TClass_8cxx_source.html:118122,Performance,load,loadedcl,118122,"Class (if one is requested for the pair).; 3097 const bool ispair = TClassEdit::IsStdPair(normalizedName) && !IsFromRootCling();; 3098 const bool ispairbase = TClassEdit::IsStdPairBase(normalizedName) && !IsFromRootCling();; 3099 ; 3100 TClass *loadedcl = nullptr;; 3101 if (checkTable) {; 3102 loadedcl = LoadClassDefault(normalizedName.c_str(),silent);; 3103 } else {; 3104 if (gInterpreter->AutoLoad(normalizedName.c_str(),kTRUE)) {; 3105 // At this point more information has been loaded. This; 3106 // information might be pertinent to the normalization of the name.; 3107 // For example it might contain or be a typedef for which we don't; 3108 // have a forward declaration (eg. typedef to instance of class; 3109 // template with default parameters). So let's redo the normalization; 3110 // as the new information (eg. typedef in TROOT::GetListOfTypes) might; 3111 // lead to a different value.; 3112 {; 3113 TInterpreter::SuspendAutoLoadingRAII autoloadOff(gInterpreter);; 3114 TClassEdit::GetNormalizedName(normalizedName, name);; 3115 }; 3116 loadedcl = LoadClassDefault(normalizedName.c_str(),silent);; 3117 }; 3118 auto e = TEnum::GetEnum(normalizedName.c_str(), TEnum::kNone);; 3119 if (e); 3120 return nullptr;; 3121 // Maybe this was a typedef: let's try to see if this is the case; 3122 if (!loadedcl && !ispair && !ispairbase) {; 3123 if (TDataType* theDataType = gROOT->GetType(normalizedName.c_str())){; 3124 // We have a typedef: we get the name of the underlying type; 3125 auto underlyingTypeName = theDataType->GetTypeName();; 3126 // We see if we can bootstrap a class with it; 3127 auto underlyingTypeDict = TClassTable::GetDictNorm(underlyingTypeName.Data());; 3128 if (underlyingTypeDict){; 3129 loadedcl = underlyingTypeDict();; 3130 }; 3131 ; 3132 }; 3133 }; 3134 }; 3135 if (loadedcl) return loadedcl;; 3136 ; 3137 // See if the TClassGenerator can produce the TClass we need.; 3138 loadedcl = LoadClassCustom(normalizedName.c_str(),silent);; 3139 if (loadedcl) return ",MatchSource.WIKI,doc/v632/TClass_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/TClass_8cxx_source.html
https://root.cern/doc/v632/TClass_8cxx_source.html:118377,Performance,load,loadedcl,118377,"3102 loadedcl = LoadClassDefault(normalizedName.c_str(),silent);; 3103 } else {; 3104 if (gInterpreter->AutoLoad(normalizedName.c_str(),kTRUE)) {; 3105 // At this point more information has been loaded. This; 3106 // information might be pertinent to the normalization of the name.; 3107 // For example it might contain or be a typedef for which we don't; 3108 // have a forward declaration (eg. typedef to instance of class; 3109 // template with default parameters). So let's redo the normalization; 3110 // as the new information (eg. typedef in TROOT::GetListOfTypes) might; 3111 // lead to a different value.; 3112 {; 3113 TInterpreter::SuspendAutoLoadingRAII autoloadOff(gInterpreter);; 3114 TClassEdit::GetNormalizedName(normalizedName, name);; 3115 }; 3116 loadedcl = LoadClassDefault(normalizedName.c_str(),silent);; 3117 }; 3118 auto e = TEnum::GetEnum(normalizedName.c_str(), TEnum::kNone);; 3119 if (e); 3120 return nullptr;; 3121 // Maybe this was a typedef: let's try to see if this is the case; 3122 if (!loadedcl && !ispair && !ispairbase) {; 3123 if (TDataType* theDataType = gROOT->GetType(normalizedName.c_str())){; 3124 // We have a typedef: we get the name of the underlying type; 3125 auto underlyingTypeName = theDataType->GetTypeName();; 3126 // We see if we can bootstrap a class with it; 3127 auto underlyingTypeDict = TClassTable::GetDictNorm(underlyingTypeName.Data());; 3128 if (underlyingTypeDict){; 3129 loadedcl = underlyingTypeDict();; 3130 }; 3131 ; 3132 }; 3133 }; 3134 }; 3135 if (loadedcl) return loadedcl;; 3136 ; 3137 // See if the TClassGenerator can produce the TClass we need.; 3138 loadedcl = LoadClassCustom(normalizedName.c_str(),silent);; 3139 if (loadedcl) return loadedcl;; 3140 ; 3141 // We have not been able to find a loaded TClass, return the Emulated; 3142 // TClass if we have one.; 3143 if (cl) return cl;; 3144 ; 3145 if (ispair) {; 3146 if (hint_pair_offset && hint_pair_size) {; 3147 auto pairinfo = TVirtualStreamerInfo::Factory()->GenerateIn",MatchSource.WIKI,doc/v632/TClass_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/TClass_8cxx_source.html
https://root.cern/doc/v632/TClass_8cxx_source.html:118792,Performance,load,loadedcl,118792,"110 // as the new information (eg. typedef in TROOT::GetListOfTypes) might; 3111 // lead to a different value.; 3112 {; 3113 TInterpreter::SuspendAutoLoadingRAII autoloadOff(gInterpreter);; 3114 TClassEdit::GetNormalizedName(normalizedName, name);; 3115 }; 3116 loadedcl = LoadClassDefault(normalizedName.c_str(),silent);; 3117 }; 3118 auto e = TEnum::GetEnum(normalizedName.c_str(), TEnum::kNone);; 3119 if (e); 3120 return nullptr;; 3121 // Maybe this was a typedef: let's try to see if this is the case; 3122 if (!loadedcl && !ispair && !ispairbase) {; 3123 if (TDataType* theDataType = gROOT->GetType(normalizedName.c_str())){; 3124 // We have a typedef: we get the name of the underlying type; 3125 auto underlyingTypeName = theDataType->GetTypeName();; 3126 // We see if we can bootstrap a class with it; 3127 auto underlyingTypeDict = TClassTable::GetDictNorm(underlyingTypeName.Data());; 3128 if (underlyingTypeDict){; 3129 loadedcl = underlyingTypeDict();; 3130 }; 3131 ; 3132 }; 3133 }; 3134 }; 3135 if (loadedcl) return loadedcl;; 3136 ; 3137 // See if the TClassGenerator can produce the TClass we need.; 3138 loadedcl = LoadClassCustom(normalizedName.c_str(),silent);; 3139 if (loadedcl) return loadedcl;; 3140 ; 3141 // We have not been able to find a loaded TClass, return the Emulated; 3142 // TClass if we have one.; 3143 if (cl) return cl;; 3144 ; 3145 if (ispair) {; 3146 if (hint_pair_offset && hint_pair_size) {; 3147 auto pairinfo = TVirtualStreamerInfo::Factory()->GenerateInfoForPair(normalizedName, silent, hint_pair_offset, hint_pair_size);; 3148 // Fall-through to allow TClass to be created when known by the interpreter; 3149 // This is used in the case where TStreamerInfo can not handle them.; 3150 if (pairinfo); 3151 return pairinfo->GetClass();; 3152 } else {; 3153 // Check if we have an STL container that might provide it.; 3154 static const size_t slen = strlen(""pair"");; 3155 static const char *associativeContainer[] = { ""map"", ""unordered_map"", ""multimap"",; 315",MatchSource.WIKI,doc/v632/TClass_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/TClass_8cxx_source.html
https://root.cern/doc/v632/TClass_8cxx_source.html:118874,Performance,load,loadedcl,118874,"110 // as the new information (eg. typedef in TROOT::GetListOfTypes) might; 3111 // lead to a different value.; 3112 {; 3113 TInterpreter::SuspendAutoLoadingRAII autoloadOff(gInterpreter);; 3114 TClassEdit::GetNormalizedName(normalizedName, name);; 3115 }; 3116 loadedcl = LoadClassDefault(normalizedName.c_str(),silent);; 3117 }; 3118 auto e = TEnum::GetEnum(normalizedName.c_str(), TEnum::kNone);; 3119 if (e); 3120 return nullptr;; 3121 // Maybe this was a typedef: let's try to see if this is the case; 3122 if (!loadedcl && !ispair && !ispairbase) {; 3123 if (TDataType* theDataType = gROOT->GetType(normalizedName.c_str())){; 3124 // We have a typedef: we get the name of the underlying type; 3125 auto underlyingTypeName = theDataType->GetTypeName();; 3126 // We see if we can bootstrap a class with it; 3127 auto underlyingTypeDict = TClassTable::GetDictNorm(underlyingTypeName.Data());; 3128 if (underlyingTypeDict){; 3129 loadedcl = underlyingTypeDict();; 3130 }; 3131 ; 3132 }; 3133 }; 3134 }; 3135 if (loadedcl) return loadedcl;; 3136 ; 3137 // See if the TClassGenerator can produce the TClass we need.; 3138 loadedcl = LoadClassCustom(normalizedName.c_str(),silent);; 3139 if (loadedcl) return loadedcl;; 3140 ; 3141 // We have not been able to find a loaded TClass, return the Emulated; 3142 // TClass if we have one.; 3143 if (cl) return cl;; 3144 ; 3145 if (ispair) {; 3146 if (hint_pair_offset && hint_pair_size) {; 3147 auto pairinfo = TVirtualStreamerInfo::Factory()->GenerateInfoForPair(normalizedName, silent, hint_pair_offset, hint_pair_size);; 3148 // Fall-through to allow TClass to be created when known by the interpreter; 3149 // This is used in the case where TStreamerInfo can not handle them.; 3150 if (pairinfo); 3151 return pairinfo->GetClass();; 3152 } else {; 3153 // Check if we have an STL container that might provide it.; 3154 static const size_t slen = strlen(""pair"");; 3155 static const char *associativeContainer[] = { ""map"", ""unordered_map"", ""multimap"",; 315",MatchSource.WIKI,doc/v632/TClass_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/TClass_8cxx_source.html
https://root.cern/doc/v632/TClass_8cxx_source.html:118891,Performance,load,loadedcl,118891,"110 // as the new information (eg. typedef in TROOT::GetListOfTypes) might; 3111 // lead to a different value.; 3112 {; 3113 TInterpreter::SuspendAutoLoadingRAII autoloadOff(gInterpreter);; 3114 TClassEdit::GetNormalizedName(normalizedName, name);; 3115 }; 3116 loadedcl = LoadClassDefault(normalizedName.c_str(),silent);; 3117 }; 3118 auto e = TEnum::GetEnum(normalizedName.c_str(), TEnum::kNone);; 3119 if (e); 3120 return nullptr;; 3121 // Maybe this was a typedef: let's try to see if this is the case; 3122 if (!loadedcl && !ispair && !ispairbase) {; 3123 if (TDataType* theDataType = gROOT->GetType(normalizedName.c_str())){; 3124 // We have a typedef: we get the name of the underlying type; 3125 auto underlyingTypeName = theDataType->GetTypeName();; 3126 // We see if we can bootstrap a class with it; 3127 auto underlyingTypeDict = TClassTable::GetDictNorm(underlyingTypeName.Data());; 3128 if (underlyingTypeDict){; 3129 loadedcl = underlyingTypeDict();; 3130 }; 3131 ; 3132 }; 3133 }; 3134 }; 3135 if (loadedcl) return loadedcl;; 3136 ; 3137 // See if the TClassGenerator can produce the TClass we need.; 3138 loadedcl = LoadClassCustom(normalizedName.c_str(),silent);; 3139 if (loadedcl) return loadedcl;; 3140 ; 3141 // We have not been able to find a loaded TClass, return the Emulated; 3142 // TClass if we have one.; 3143 if (cl) return cl;; 3144 ; 3145 if (ispair) {; 3146 if (hint_pair_offset && hint_pair_size) {; 3147 auto pairinfo = TVirtualStreamerInfo::Factory()->GenerateInfoForPair(normalizedName, silent, hint_pair_offset, hint_pair_size);; 3148 // Fall-through to allow TClass to be created when known by the interpreter; 3149 // This is used in the case where TStreamerInfo can not handle them.; 3150 if (pairinfo); 3151 return pairinfo->GetClass();; 3152 } else {; 3153 // Check if we have an STL container that might provide it.; 3154 static const size_t slen = strlen(""pair"");; 3155 static const char *associativeContainer[] = { ""map"", ""unordered_map"", ""multimap"",; 315",MatchSource.WIKI,doc/v632/TClass_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/TClass_8cxx_source.html
https://root.cern/doc/v632/TClass_8cxx_source.html:118982,Performance,load,loadedcl,118982,"SuspendAutoLoadingRAII autoloadOff(gInterpreter);; 3114 TClassEdit::GetNormalizedName(normalizedName, name);; 3115 }; 3116 loadedcl = LoadClassDefault(normalizedName.c_str(),silent);; 3117 }; 3118 auto e = TEnum::GetEnum(normalizedName.c_str(), TEnum::kNone);; 3119 if (e); 3120 return nullptr;; 3121 // Maybe this was a typedef: let's try to see if this is the case; 3122 if (!loadedcl && !ispair && !ispairbase) {; 3123 if (TDataType* theDataType = gROOT->GetType(normalizedName.c_str())){; 3124 // We have a typedef: we get the name of the underlying type; 3125 auto underlyingTypeName = theDataType->GetTypeName();; 3126 // We see if we can bootstrap a class with it; 3127 auto underlyingTypeDict = TClassTable::GetDictNorm(underlyingTypeName.Data());; 3128 if (underlyingTypeDict){; 3129 loadedcl = underlyingTypeDict();; 3130 }; 3131 ; 3132 }; 3133 }; 3134 }; 3135 if (loadedcl) return loadedcl;; 3136 ; 3137 // See if the TClassGenerator can produce the TClass we need.; 3138 loadedcl = LoadClassCustom(normalizedName.c_str(),silent);; 3139 if (loadedcl) return loadedcl;; 3140 ; 3141 // We have not been able to find a loaded TClass, return the Emulated; 3142 // TClass if we have one.; 3143 if (cl) return cl;; 3144 ; 3145 if (ispair) {; 3146 if (hint_pair_offset && hint_pair_size) {; 3147 auto pairinfo = TVirtualStreamerInfo::Factory()->GenerateInfoForPair(normalizedName, silent, hint_pair_offset, hint_pair_size);; 3148 // Fall-through to allow TClass to be created when known by the interpreter; 3149 // This is used in the case where TStreamerInfo can not handle them.; 3150 if (pairinfo); 3151 return pairinfo->GetClass();; 3152 } else {; 3153 // Check if we have an STL container that might provide it.; 3154 static const size_t slen = strlen(""pair"");; 3155 static const char *associativeContainer[] = { ""map"", ""unordered_map"", ""multimap"",; 3156 ""unordered_multimap"", ""set"", ""unordered_set"", ""multiset"", ""unordered_multiset"" };; 3157 for(auto contname : associativeContainer) {; 3158",MatchSource.WIKI,doc/v632/TClass_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/TClass_8cxx_source.html
https://root.cern/doc/v632/TClass_8cxx_source.html:119051,Performance,load,loadedcl,119051," 3115 }; 3116 loadedcl = LoadClassDefault(normalizedName.c_str(),silent);; 3117 }; 3118 auto e = TEnum::GetEnum(normalizedName.c_str(), TEnum::kNone);; 3119 if (e); 3120 return nullptr;; 3121 // Maybe this was a typedef: let's try to see if this is the case; 3122 if (!loadedcl && !ispair && !ispairbase) {; 3123 if (TDataType* theDataType = gROOT->GetType(normalizedName.c_str())){; 3124 // We have a typedef: we get the name of the underlying type; 3125 auto underlyingTypeName = theDataType->GetTypeName();; 3126 // We see if we can bootstrap a class with it; 3127 auto underlyingTypeDict = TClassTable::GetDictNorm(underlyingTypeName.Data());; 3128 if (underlyingTypeDict){; 3129 loadedcl = underlyingTypeDict();; 3130 }; 3131 ; 3132 }; 3133 }; 3134 }; 3135 if (loadedcl) return loadedcl;; 3136 ; 3137 // See if the TClassGenerator can produce the TClass we need.; 3138 loadedcl = LoadClassCustom(normalizedName.c_str(),silent);; 3139 if (loadedcl) return loadedcl;; 3140 ; 3141 // We have not been able to find a loaded TClass, return the Emulated; 3142 // TClass if we have one.; 3143 if (cl) return cl;; 3144 ; 3145 if (ispair) {; 3146 if (hint_pair_offset && hint_pair_size) {; 3147 auto pairinfo = TVirtualStreamerInfo::Factory()->GenerateInfoForPair(normalizedName, silent, hint_pair_offset, hint_pair_size);; 3148 // Fall-through to allow TClass to be created when known by the interpreter; 3149 // This is used in the case where TStreamerInfo can not handle them.; 3150 if (pairinfo); 3151 return pairinfo->GetClass();; 3152 } else {; 3153 // Check if we have an STL container that might provide it.; 3154 static const size_t slen = strlen(""pair"");; 3155 static const char *associativeContainer[] = { ""map"", ""unordered_map"", ""multimap"",; 3156 ""unordered_multimap"", ""set"", ""unordered_set"", ""multiset"", ""unordered_multiset"" };; 3157 for(auto contname : associativeContainer) {; 3158 std::string collname = contname;; 3159 collname.append( normalizedName.c_str() + slen );; 3160 TClass *coll",MatchSource.WIKI,doc/v632/TClass_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/TClass_8cxx_source.html
https://root.cern/doc/v632/TClass_8cxx_source.html:119068,Performance,load,loadedcl,119068," 3115 }; 3116 loadedcl = LoadClassDefault(normalizedName.c_str(),silent);; 3117 }; 3118 auto e = TEnum::GetEnum(normalizedName.c_str(), TEnum::kNone);; 3119 if (e); 3120 return nullptr;; 3121 // Maybe this was a typedef: let's try to see if this is the case; 3122 if (!loadedcl && !ispair && !ispairbase) {; 3123 if (TDataType* theDataType = gROOT->GetType(normalizedName.c_str())){; 3124 // We have a typedef: we get the name of the underlying type; 3125 auto underlyingTypeName = theDataType->GetTypeName();; 3126 // We see if we can bootstrap a class with it; 3127 auto underlyingTypeDict = TClassTable::GetDictNorm(underlyingTypeName.Data());; 3128 if (underlyingTypeDict){; 3129 loadedcl = underlyingTypeDict();; 3130 }; 3131 ; 3132 }; 3133 }; 3134 }; 3135 if (loadedcl) return loadedcl;; 3136 ; 3137 // See if the TClassGenerator can produce the TClass we need.; 3138 loadedcl = LoadClassCustom(normalizedName.c_str(),silent);; 3139 if (loadedcl) return loadedcl;; 3140 ; 3141 // We have not been able to find a loaded TClass, return the Emulated; 3142 // TClass if we have one.; 3143 if (cl) return cl;; 3144 ; 3145 if (ispair) {; 3146 if (hint_pair_offset && hint_pair_size) {; 3147 auto pairinfo = TVirtualStreamerInfo::Factory()->GenerateInfoForPair(normalizedName, silent, hint_pair_offset, hint_pair_size);; 3148 // Fall-through to allow TClass to be created when known by the interpreter; 3149 // This is used in the case where TStreamerInfo can not handle them.; 3150 if (pairinfo); 3151 return pairinfo->GetClass();; 3152 } else {; 3153 // Check if we have an STL container that might provide it.; 3154 static const size_t slen = strlen(""pair"");; 3155 static const char *associativeContainer[] = { ""map"", ""unordered_map"", ""multimap"",; 3156 ""unordered_multimap"", ""set"", ""unordered_set"", ""multiset"", ""unordered_multiset"" };; 3157 for(auto contname : associativeContainer) {; 3158 std::string collname = contname;; 3159 collname.append( normalizedName.c_str() + slen );; 3160 TClass *coll",MatchSource.WIKI,doc/v632/TClass_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/TClass_8cxx_source.html
https://root.cern/doc/v632/TClass_8cxx_source.html:119126,Performance,load,loaded,119126," 3115 }; 3116 loadedcl = LoadClassDefault(normalizedName.c_str(),silent);; 3117 }; 3118 auto e = TEnum::GetEnum(normalizedName.c_str(), TEnum::kNone);; 3119 if (e); 3120 return nullptr;; 3121 // Maybe this was a typedef: let's try to see if this is the case; 3122 if (!loadedcl && !ispair && !ispairbase) {; 3123 if (TDataType* theDataType = gROOT->GetType(normalizedName.c_str())){; 3124 // We have a typedef: we get the name of the underlying type; 3125 auto underlyingTypeName = theDataType->GetTypeName();; 3126 // We see if we can bootstrap a class with it; 3127 auto underlyingTypeDict = TClassTable::GetDictNorm(underlyingTypeName.Data());; 3128 if (underlyingTypeDict){; 3129 loadedcl = underlyingTypeDict();; 3130 }; 3131 ; 3132 }; 3133 }; 3134 }; 3135 if (loadedcl) return loadedcl;; 3136 ; 3137 // See if the TClassGenerator can produce the TClass we need.; 3138 loadedcl = LoadClassCustom(normalizedName.c_str(),silent);; 3139 if (loadedcl) return loadedcl;; 3140 ; 3141 // We have not been able to find a loaded TClass, return the Emulated; 3142 // TClass if we have one.; 3143 if (cl) return cl;; 3144 ; 3145 if (ispair) {; 3146 if (hint_pair_offset && hint_pair_size) {; 3147 auto pairinfo = TVirtualStreamerInfo::Factory()->GenerateInfoForPair(normalizedName, silent, hint_pair_offset, hint_pair_size);; 3148 // Fall-through to allow TClass to be created when known by the interpreter; 3149 // This is used in the case where TStreamerInfo can not handle them.; 3150 if (pairinfo); 3151 return pairinfo->GetClass();; 3152 } else {; 3153 // Check if we have an STL container that might provide it.; 3154 static const size_t slen = strlen(""pair"");; 3155 static const char *associativeContainer[] = { ""map"", ""unordered_map"", ""multimap"",; 3156 ""unordered_multimap"", ""set"", ""unordered_set"", ""multiset"", ""unordered_multiset"" };; 3157 for(auto contname : associativeContainer) {; 3158 std::string collname = contname;; 3159 collname.append( normalizedName.c_str() + slen );; 3160 TClass *coll",MatchSource.WIKI,doc/v632/TClass_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/TClass_8cxx_source.html
https://root.cern/doc/v632/TClass_8cxx_source.html:123794,Performance,load,load,123794,"e default arguments as requested by the user); 3219 std::string alternative;; 3220 gInterpreter->GetInterpreterTypeName(normalizedName.c_str(), alternative, kTRUE);; 3221 if (alternative.empty()); 3222 return nullptr;; 3223 const char *altname = alternative.c_str();; 3224 if (strncmp(altname, ""std::"", 5) == 0) {; 3225 // For namespace (for example std::__1), GetInterpreterTypeName does; 3226 // not strip std::, so we must do it explicitly here.; 3227 altname += 5;; 3228 }; 3229 if (altname != normalizedName && strcmp(altname, name) != 0) {; 3230 // altname now contains the full name of the class including a possible; 3231 // namespace if there has been a using namespace statement.; 3232 ; 3233 // At least in the case C<string [2]> (normalized) vs C<string[2]> (altname); 3234 // the TClassEdit normalization and the TMetaUtils normalization leads to; 3235 // two different space layout. To avoid an infinite recursion, we also; 3236 // add the test on (altname != name); 3237 ; 3238 return GetClass(altname, load);; 3239 }; 3240 ; 3241 TClass *ncl = gInterpreter->GenerateTClass(normalizedName.c_str(), /* emulation = */ kFALSE, silent);; 3242 if (!ncl->IsZombie()) {; 3243 return ncl;; 3244 }; 3245 delete ncl;; 3246 }; 3247 }; 3248 return nullptr;; 3249}; 3250 ; 3251////////////////////////////////////////////////////////////////////////////////; 3252/// Return pointer to class with name.; 3253 ; 3254TClass *TClass::GetClass(const std::type_info& typeinfo, Bool_t load, Bool_t /* silent */, size_t hint_pair_offset, size_t hint_pair_size); 3255{; 3256 if (!gROOT->GetListOfClasses()); 3257 return nullptr;; 3258 ; 3259 //protect access to TROOT::GetIdMap; 3260 R__READ_LOCKGUARD(ROOT::gCoreMutex);; 3261 ; 3262 TClass* cl = GetIdMap()->Find(typeinfo.name());; 3263 ; 3264 if (cl && cl->IsLoaded()) return cl;; 3265 ; 3266 R__WRITE_LOCKGUARD(ROOT::gCoreMutex);; 3267 ; 3268 // Now that we got the write lock, another thread may have constructed the; 3269 // TClass while we were waitin",MatchSource.WIKI,doc/v632/TClass_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/TClass_8cxx_source.html
https://root.cern/doc/v632/TClass_8cxx_source.html:124256,Performance,load,load,124256," name of the class including a possible; 3231 // namespace if there has been a using namespace statement.; 3232 ; 3233 // At least in the case C<string [2]> (normalized) vs C<string[2]> (altname); 3234 // the TClassEdit normalization and the TMetaUtils normalization leads to; 3235 // two different space layout. To avoid an infinite recursion, we also; 3236 // add the test on (altname != name); 3237 ; 3238 return GetClass(altname, load);; 3239 }; 3240 ; 3241 TClass *ncl = gInterpreter->GenerateTClass(normalizedName.c_str(), /* emulation = */ kFALSE, silent);; 3242 if (!ncl->IsZombie()) {; 3243 return ncl;; 3244 }; 3245 delete ncl;; 3246 }; 3247 }; 3248 return nullptr;; 3249}; 3250 ; 3251////////////////////////////////////////////////////////////////////////////////; 3252/// Return pointer to class with name.; 3253 ; 3254TClass *TClass::GetClass(const std::type_info& typeinfo, Bool_t load, Bool_t /* silent */, size_t hint_pair_offset, size_t hint_pair_size); 3255{; 3256 if (!gROOT->GetListOfClasses()); 3257 return nullptr;; 3258 ; 3259 //protect access to TROOT::GetIdMap; 3260 R__READ_LOCKGUARD(ROOT::gCoreMutex);; 3261 ; 3262 TClass* cl = GetIdMap()->Find(typeinfo.name());; 3263 ; 3264 if (cl && cl->IsLoaded()) return cl;; 3265 ; 3266 R__WRITE_LOCKGUARD(ROOT::gCoreMutex);; 3267 ; 3268 // Now that we got the write lock, another thread may have constructed the; 3269 // TClass while we were waiting, so we need to do the checks again.; 3270 ; 3271 cl = GetIdMap()->Find(typeinfo.name());; 3272 ; 3273 if (cl) {; 3274 if (cl->IsLoaded()) return cl;; 3275 //we may pass here in case of a dummy class created by TVirtualStreamerInfo; 3276 load = kTRUE;; 3277 } else {; 3278 // Note we might need support for typedefs and simple types!; 3279 ; 3280 // TDataType *objType = GetType(name, load);; 3281 //if (objType) {; 3282 // const char *typdfName = objType->GetTypeName();; 3283 // if (typdfName && strcmp(typdfName, name)) {; 3284 // cl = GetClass(typdfName, load);; 3285 // return cl",MatchSource.WIKI,doc/v632/TClass_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/TClass_8cxx_source.html
https://root.cern/doc/v632/TClass_8cxx_source.html:125015,Performance,load,load,125015,"n.; 3270 ; 3271 cl = GetIdMap()->Find(typeinfo.name());; 3272 ; 3273 if (cl) {; 3274 if (cl->IsLoaded()) return cl;; 3275 //we may pass here in case of a dummy class created by TVirtualStreamerInfo; 3276 load = kTRUE;; 3277 } else {; 3278 // Note we might need support for typedefs and simple types!; 3279 ; 3280 // TDataType *objType = GetType(name, load);; 3281 //if (objType) {; 3282 // const char *typdfName = objType->GetTypeName();; 3283 // if (typdfName && strcmp(typdfName, name)) {; 3284 // cl = GetClass(typdfName, load);; 3285 // return cl;; 3286 // }; 3287 // }; 3288 }; 3289 ; 3290 if (!load) return nullptr;; 3291 ; 3292 DictFuncPtr_t dict = TClassTable::GetDict(typeinfo);; 3293 if (dict) {; 3294 cl = (dict)();; 3295 if (cl) cl->PostLoadCheck();; 3296 return cl;; 3297 }; 3298 if (cl) return cl;; 3299 ; 3300 TIter next(gROOT->GetListOfClassGenerators());; 3301 TClassGenerator *gen;; 3302 while( (gen = (TClassGenerator*) next()) ) {; 3303 cl = gen->GetClass(typeinfo,load);; 3304 if (cl) {; 3305 cl->PostLoadCheck();; 3306 return cl;; 3307 }; 3308 }; 3309 ; 3310 // try AutoLoading the typeinfo; 3311 int autoload_old = gCling->SetClassAutoLoading(1);; 3312 if (!autoload_old) {; 3313 // Re-disable, we just meant to test; 3314 gCling->SetClassAutoLoading(0);; 3315 }; 3316 if (autoload_old && gInterpreter->AutoLoad(typeinfo,kTRUE)) {; 3317 // Disable autoload to avoid potential infinite recursion; 3318 TInterpreter::SuspendAutoLoadingRAII autoloadOff(gInterpreter);; 3319 cl = GetClass(typeinfo, load, hint_pair_offset, hint_pair_size);; 3320 if (cl) {; 3321 return cl;; 3322 }; 3323 }; 3324 ; 3325 if (hint_pair_offset) {; 3326 int err = 0;; 3327 char* demangled_name = TClassEdit::DemangleTypeIdName(typeinfo, err);; 3328 if (!err) {; 3329 cl = TClass::GetClass(demangled_name, load, kTRUE, hint_pair_offset, hint_pair_size);; 3330 free(demangled_name);; 3331 if (cl); 3332 return cl;; 3333 }; 3334 }; 3335 ; 3336 // last attempt. Look in the interpreter list of all (compiled+",MatchSource.WIKI,doc/v632/TClass_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/TClass_8cxx_source.html
https://root.cern/doc/v632/TClass_8cxx_source.html:125162,Performance,load,load,125162,"n.; 3270 ; 3271 cl = GetIdMap()->Find(typeinfo.name());; 3272 ; 3273 if (cl) {; 3274 if (cl->IsLoaded()) return cl;; 3275 //we may pass here in case of a dummy class created by TVirtualStreamerInfo; 3276 load = kTRUE;; 3277 } else {; 3278 // Note we might need support for typedefs and simple types!; 3279 ; 3280 // TDataType *objType = GetType(name, load);; 3281 //if (objType) {; 3282 // const char *typdfName = objType->GetTypeName();; 3283 // if (typdfName && strcmp(typdfName, name)) {; 3284 // cl = GetClass(typdfName, load);; 3285 // return cl;; 3286 // }; 3287 // }; 3288 }; 3289 ; 3290 if (!load) return nullptr;; 3291 ; 3292 DictFuncPtr_t dict = TClassTable::GetDict(typeinfo);; 3293 if (dict) {; 3294 cl = (dict)();; 3295 if (cl) cl->PostLoadCheck();; 3296 return cl;; 3297 }; 3298 if (cl) return cl;; 3299 ; 3300 TIter next(gROOT->GetListOfClassGenerators());; 3301 TClassGenerator *gen;; 3302 while( (gen = (TClassGenerator*) next()) ) {; 3303 cl = gen->GetClass(typeinfo,load);; 3304 if (cl) {; 3305 cl->PostLoadCheck();; 3306 return cl;; 3307 }; 3308 }; 3309 ; 3310 // try AutoLoading the typeinfo; 3311 int autoload_old = gCling->SetClassAutoLoading(1);; 3312 if (!autoload_old) {; 3313 // Re-disable, we just meant to test; 3314 gCling->SetClassAutoLoading(0);; 3315 }; 3316 if (autoload_old && gInterpreter->AutoLoad(typeinfo,kTRUE)) {; 3317 // Disable autoload to avoid potential infinite recursion; 3318 TInterpreter::SuspendAutoLoadingRAII autoloadOff(gInterpreter);; 3319 cl = GetClass(typeinfo, load, hint_pair_offset, hint_pair_size);; 3320 if (cl) {; 3321 return cl;; 3322 }; 3323 }; 3324 ; 3325 if (hint_pair_offset) {; 3326 int err = 0;; 3327 char* demangled_name = TClassEdit::DemangleTypeIdName(typeinfo, err);; 3328 if (!err) {; 3329 cl = TClass::GetClass(demangled_name, load, kTRUE, hint_pair_offset, hint_pair_size);; 3330 free(demangled_name);; 3331 if (cl); 3332 return cl;; 3333 }; 3334 }; 3335 ; 3336 // last attempt. Look in the interpreter list of all (compiled+",MatchSource.WIKI,doc/v632/TClass_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/TClass_8cxx_source.html
https://root.cern/doc/v632/TClass_8cxx_source.html:125336,Performance,load,load,125336,"n.; 3270 ; 3271 cl = GetIdMap()->Find(typeinfo.name());; 3272 ; 3273 if (cl) {; 3274 if (cl->IsLoaded()) return cl;; 3275 //we may pass here in case of a dummy class created by TVirtualStreamerInfo; 3276 load = kTRUE;; 3277 } else {; 3278 // Note we might need support for typedefs and simple types!; 3279 ; 3280 // TDataType *objType = GetType(name, load);; 3281 //if (objType) {; 3282 // const char *typdfName = objType->GetTypeName();; 3283 // if (typdfName && strcmp(typdfName, name)) {; 3284 // cl = GetClass(typdfName, load);; 3285 // return cl;; 3286 // }; 3287 // }; 3288 }; 3289 ; 3290 if (!load) return nullptr;; 3291 ; 3292 DictFuncPtr_t dict = TClassTable::GetDict(typeinfo);; 3293 if (dict) {; 3294 cl = (dict)();; 3295 if (cl) cl->PostLoadCheck();; 3296 return cl;; 3297 }; 3298 if (cl) return cl;; 3299 ; 3300 TIter next(gROOT->GetListOfClassGenerators());; 3301 TClassGenerator *gen;; 3302 while( (gen = (TClassGenerator*) next()) ) {; 3303 cl = gen->GetClass(typeinfo,load);; 3304 if (cl) {; 3305 cl->PostLoadCheck();; 3306 return cl;; 3307 }; 3308 }; 3309 ; 3310 // try AutoLoading the typeinfo; 3311 int autoload_old = gCling->SetClassAutoLoading(1);; 3312 if (!autoload_old) {; 3313 // Re-disable, we just meant to test; 3314 gCling->SetClassAutoLoading(0);; 3315 }; 3316 if (autoload_old && gInterpreter->AutoLoad(typeinfo,kTRUE)) {; 3317 // Disable autoload to avoid potential infinite recursion; 3318 TInterpreter::SuspendAutoLoadingRAII autoloadOff(gInterpreter);; 3319 cl = GetClass(typeinfo, load, hint_pair_offset, hint_pair_size);; 3320 if (cl) {; 3321 return cl;; 3322 }; 3323 }; 3324 ; 3325 if (hint_pair_offset) {; 3326 int err = 0;; 3327 char* demangled_name = TClassEdit::DemangleTypeIdName(typeinfo, err);; 3328 if (!err) {; 3329 cl = TClass::GetClass(demangled_name, load, kTRUE, hint_pair_offset, hint_pair_size);; 3330 free(demangled_name);; 3331 if (cl); 3332 return cl;; 3333 }; 3334 }; 3335 ; 3336 // last attempt. Look in the interpreter list of all (compiled+",MatchSource.WIKI,doc/v632/TClass_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/TClass_8cxx_source.html
https://root.cern/doc/v632/TClass_8cxx_source.html:125411,Performance,load,load,125411,"n.; 3270 ; 3271 cl = GetIdMap()->Find(typeinfo.name());; 3272 ; 3273 if (cl) {; 3274 if (cl->IsLoaded()) return cl;; 3275 //we may pass here in case of a dummy class created by TVirtualStreamerInfo; 3276 load = kTRUE;; 3277 } else {; 3278 // Note we might need support for typedefs and simple types!; 3279 ; 3280 // TDataType *objType = GetType(name, load);; 3281 //if (objType) {; 3282 // const char *typdfName = objType->GetTypeName();; 3283 // if (typdfName && strcmp(typdfName, name)) {; 3284 // cl = GetClass(typdfName, load);; 3285 // return cl;; 3286 // }; 3287 // }; 3288 }; 3289 ; 3290 if (!load) return nullptr;; 3291 ; 3292 DictFuncPtr_t dict = TClassTable::GetDict(typeinfo);; 3293 if (dict) {; 3294 cl = (dict)();; 3295 if (cl) cl->PostLoadCheck();; 3296 return cl;; 3297 }; 3298 if (cl) return cl;; 3299 ; 3300 TIter next(gROOT->GetListOfClassGenerators());; 3301 TClassGenerator *gen;; 3302 while( (gen = (TClassGenerator*) next()) ) {; 3303 cl = gen->GetClass(typeinfo,load);; 3304 if (cl) {; 3305 cl->PostLoadCheck();; 3306 return cl;; 3307 }; 3308 }; 3309 ; 3310 // try AutoLoading the typeinfo; 3311 int autoload_old = gCling->SetClassAutoLoading(1);; 3312 if (!autoload_old) {; 3313 // Re-disable, we just meant to test; 3314 gCling->SetClassAutoLoading(0);; 3315 }; 3316 if (autoload_old && gInterpreter->AutoLoad(typeinfo,kTRUE)) {; 3317 // Disable autoload to avoid potential infinite recursion; 3318 TInterpreter::SuspendAutoLoadingRAII autoloadOff(gInterpreter);; 3319 cl = GetClass(typeinfo, load, hint_pair_offset, hint_pair_size);; 3320 if (cl) {; 3321 return cl;; 3322 }; 3323 }; 3324 ; 3325 if (hint_pair_offset) {; 3326 int err = 0;; 3327 char* demangled_name = TClassEdit::DemangleTypeIdName(typeinfo, err);; 3328 if (!err) {; 3329 cl = TClass::GetClass(demangled_name, load, kTRUE, hint_pair_offset, hint_pair_size);; 3330 free(demangled_name);; 3331 if (cl); 3332 return cl;; 3333 }; 3334 }; 3335 ; 3336 // last attempt. Look in the interpreter list of all (compiled+",MatchSource.WIKI,doc/v632/TClass_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/TClass_8cxx_source.html
https://root.cern/doc/v632/TClass_8cxx_source.html:125796,Performance,load,load,125796,"n.; 3270 ; 3271 cl = GetIdMap()->Find(typeinfo.name());; 3272 ; 3273 if (cl) {; 3274 if (cl->IsLoaded()) return cl;; 3275 //we may pass here in case of a dummy class created by TVirtualStreamerInfo; 3276 load = kTRUE;; 3277 } else {; 3278 // Note we might need support for typedefs and simple types!; 3279 ; 3280 // TDataType *objType = GetType(name, load);; 3281 //if (objType) {; 3282 // const char *typdfName = objType->GetTypeName();; 3283 // if (typdfName && strcmp(typdfName, name)) {; 3284 // cl = GetClass(typdfName, load);; 3285 // return cl;; 3286 // }; 3287 // }; 3288 }; 3289 ; 3290 if (!load) return nullptr;; 3291 ; 3292 DictFuncPtr_t dict = TClassTable::GetDict(typeinfo);; 3293 if (dict) {; 3294 cl = (dict)();; 3295 if (cl) cl->PostLoadCheck();; 3296 return cl;; 3297 }; 3298 if (cl) return cl;; 3299 ; 3300 TIter next(gROOT->GetListOfClassGenerators());; 3301 TClassGenerator *gen;; 3302 while( (gen = (TClassGenerator*) next()) ) {; 3303 cl = gen->GetClass(typeinfo,load);; 3304 if (cl) {; 3305 cl->PostLoadCheck();; 3306 return cl;; 3307 }; 3308 }; 3309 ; 3310 // try AutoLoading the typeinfo; 3311 int autoload_old = gCling->SetClassAutoLoading(1);; 3312 if (!autoload_old) {; 3313 // Re-disable, we just meant to test; 3314 gCling->SetClassAutoLoading(0);; 3315 }; 3316 if (autoload_old && gInterpreter->AutoLoad(typeinfo,kTRUE)) {; 3317 // Disable autoload to avoid potential infinite recursion; 3318 TInterpreter::SuspendAutoLoadingRAII autoloadOff(gInterpreter);; 3319 cl = GetClass(typeinfo, load, hint_pair_offset, hint_pair_size);; 3320 if (cl) {; 3321 return cl;; 3322 }; 3323 }; 3324 ; 3325 if (hint_pair_offset) {; 3326 int err = 0;; 3327 char* demangled_name = TClassEdit::DemangleTypeIdName(typeinfo, err);; 3328 if (!err) {; 3329 cl = TClass::GetClass(demangled_name, load, kTRUE, hint_pair_offset, hint_pair_size);; 3330 free(demangled_name);; 3331 if (cl); 3332 return cl;; 3333 }; 3334 }; 3335 ; 3336 // last attempt. Look in the interpreter list of all (compiled+",MatchSource.WIKI,doc/v632/TClass_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/TClass_8cxx_source.html
https://root.cern/doc/v632/TClass_8cxx_source.html:126329,Performance,load,load,126329,"n.; 3270 ; 3271 cl = GetIdMap()->Find(typeinfo.name());; 3272 ; 3273 if (cl) {; 3274 if (cl->IsLoaded()) return cl;; 3275 //we may pass here in case of a dummy class created by TVirtualStreamerInfo; 3276 load = kTRUE;; 3277 } else {; 3278 // Note we might need support for typedefs and simple types!; 3279 ; 3280 // TDataType *objType = GetType(name, load);; 3281 //if (objType) {; 3282 // const char *typdfName = objType->GetTypeName();; 3283 // if (typdfName && strcmp(typdfName, name)) {; 3284 // cl = GetClass(typdfName, load);; 3285 // return cl;; 3286 // }; 3287 // }; 3288 }; 3289 ; 3290 if (!load) return nullptr;; 3291 ; 3292 DictFuncPtr_t dict = TClassTable::GetDict(typeinfo);; 3293 if (dict) {; 3294 cl = (dict)();; 3295 if (cl) cl->PostLoadCheck();; 3296 return cl;; 3297 }; 3298 if (cl) return cl;; 3299 ; 3300 TIter next(gROOT->GetListOfClassGenerators());; 3301 TClassGenerator *gen;; 3302 while( (gen = (TClassGenerator*) next()) ) {; 3303 cl = gen->GetClass(typeinfo,load);; 3304 if (cl) {; 3305 cl->PostLoadCheck();; 3306 return cl;; 3307 }; 3308 }; 3309 ; 3310 // try AutoLoading the typeinfo; 3311 int autoload_old = gCling->SetClassAutoLoading(1);; 3312 if (!autoload_old) {; 3313 // Re-disable, we just meant to test; 3314 gCling->SetClassAutoLoading(0);; 3315 }; 3316 if (autoload_old && gInterpreter->AutoLoad(typeinfo,kTRUE)) {; 3317 // Disable autoload to avoid potential infinite recursion; 3318 TInterpreter::SuspendAutoLoadingRAII autoloadOff(gInterpreter);; 3319 cl = GetClass(typeinfo, load, hint_pair_offset, hint_pair_size);; 3320 if (cl) {; 3321 return cl;; 3322 }; 3323 }; 3324 ; 3325 if (hint_pair_offset) {; 3326 int err = 0;; 3327 char* demangled_name = TClassEdit::DemangleTypeIdName(typeinfo, err);; 3328 if (!err) {; 3329 cl = TClass::GetClass(demangled_name, load, kTRUE, hint_pair_offset, hint_pair_size);; 3330 free(demangled_name);; 3331 if (cl); 3332 return cl;; 3333 }; 3334 }; 3335 ; 3336 // last attempt. Look in the interpreter list of all (compiled+",MatchSource.WIKI,doc/v632/TClass_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/TClass_8cxx_source.html
https://root.cern/doc/v632/TClass_8cxx_source.html:126613,Performance,load,load,126613,"n.; 3270 ; 3271 cl = GetIdMap()->Find(typeinfo.name());; 3272 ; 3273 if (cl) {; 3274 if (cl->IsLoaded()) return cl;; 3275 //we may pass here in case of a dummy class created by TVirtualStreamerInfo; 3276 load = kTRUE;; 3277 } else {; 3278 // Note we might need support for typedefs and simple types!; 3279 ; 3280 // TDataType *objType = GetType(name, load);; 3281 //if (objType) {; 3282 // const char *typdfName = objType->GetTypeName();; 3283 // if (typdfName && strcmp(typdfName, name)) {; 3284 // cl = GetClass(typdfName, load);; 3285 // return cl;; 3286 // }; 3287 // }; 3288 }; 3289 ; 3290 if (!load) return nullptr;; 3291 ; 3292 DictFuncPtr_t dict = TClassTable::GetDict(typeinfo);; 3293 if (dict) {; 3294 cl = (dict)();; 3295 if (cl) cl->PostLoadCheck();; 3296 return cl;; 3297 }; 3298 if (cl) return cl;; 3299 ; 3300 TIter next(gROOT->GetListOfClassGenerators());; 3301 TClassGenerator *gen;; 3302 while( (gen = (TClassGenerator*) next()) ) {; 3303 cl = gen->GetClass(typeinfo,load);; 3304 if (cl) {; 3305 cl->PostLoadCheck();; 3306 return cl;; 3307 }; 3308 }; 3309 ; 3310 // try AutoLoading the typeinfo; 3311 int autoload_old = gCling->SetClassAutoLoading(1);; 3312 if (!autoload_old) {; 3313 // Re-disable, we just meant to test; 3314 gCling->SetClassAutoLoading(0);; 3315 }; 3316 if (autoload_old && gInterpreter->AutoLoad(typeinfo,kTRUE)) {; 3317 // Disable autoload to avoid potential infinite recursion; 3318 TInterpreter::SuspendAutoLoadingRAII autoloadOff(gInterpreter);; 3319 cl = GetClass(typeinfo, load, hint_pair_offset, hint_pair_size);; 3320 if (cl) {; 3321 return cl;; 3322 }; 3323 }; 3324 ; 3325 if (hint_pair_offset) {; 3326 int err = 0;; 3327 char* demangled_name = TClassEdit::DemangleTypeIdName(typeinfo, err);; 3328 if (!err) {; 3329 cl = TClass::GetClass(demangled_name, load, kTRUE, hint_pair_offset, hint_pair_size);; 3330 free(demangled_name);; 3331 if (cl); 3332 return cl;; 3333 }; 3334 }; 3335 ; 3336 // last attempt. Look in the interpreter list of all (compiled+",MatchSource.WIKI,doc/v632/TClass_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/TClass_8cxx_source.html
https://root.cern/doc/v632/TClass_8cxx_source.html:126886,Performance,load,load,126886,"306 return cl;; 3307 }; 3308 }; 3309 ; 3310 // try AutoLoading the typeinfo; 3311 int autoload_old = gCling->SetClassAutoLoading(1);; 3312 if (!autoload_old) {; 3313 // Re-disable, we just meant to test; 3314 gCling->SetClassAutoLoading(0);; 3315 }; 3316 if (autoload_old && gInterpreter->AutoLoad(typeinfo,kTRUE)) {; 3317 // Disable autoload to avoid potential infinite recursion; 3318 TInterpreter::SuspendAutoLoadingRAII autoloadOff(gInterpreter);; 3319 cl = GetClass(typeinfo, load, hint_pair_offset, hint_pair_size);; 3320 if (cl) {; 3321 return cl;; 3322 }; 3323 }; 3324 ; 3325 if (hint_pair_offset) {; 3326 int err = 0;; 3327 char* demangled_name = TClassEdit::DemangleTypeIdName(typeinfo, err);; 3328 if (!err) {; 3329 cl = TClass::GetClass(demangled_name, load, kTRUE, hint_pair_offset, hint_pair_size);; 3330 free(demangled_name);; 3331 if (cl); 3332 return cl;; 3333 }; 3334 }; 3335 ; 3336 // last attempt. Look in the interpreter list of all (compiled+interpreted); 3337 // classes; 3338 cl = gInterpreter->GetClass(typeinfo, load);; 3339 ; 3340 return cl; // Can be zero.; 3341}; 3342 ; 3343////////////////////////////////////////////////////////////////////////////////; 3344/// Static method returning pointer to TClass of the specified ClassInfo.; 3345/// If load is true an attempt is made to obtain the class by loading; 3346/// the appropriate shared library (directed by the rootmap file).; 3347/// If silent is 'true', do not warn about missing dictionary for the class.; 3348/// (typically used for class that are used only for transient members); 3349/// Returns 0 in case class is not found.; 3350 ; 3351TClass *TClass::GetClass(ClassInfo_t *info, Bool_t load, Bool_t silent); 3352{; 3353 if (!info || !gCling->ClassInfo_IsValid(info)) return nullptr;; 3354 if (!gROOT->GetListOfClasses()) return nullptr;; 3355 ; 3356 // Technically we need the write lock only for the call to ClassInfo_FullName; 3357 // and GenerateTClass but FindObject will take the read lock (and LoadCla",MatchSource.WIKI,doc/v632/TClass_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/TClass_8cxx_source.html
https://root.cern/doc/v632/TClass_8cxx_source.html:127124,Performance,load,load,127124,"toload to avoid potential infinite recursion; 3318 TInterpreter::SuspendAutoLoadingRAII autoloadOff(gInterpreter);; 3319 cl = GetClass(typeinfo, load, hint_pair_offset, hint_pair_size);; 3320 if (cl) {; 3321 return cl;; 3322 }; 3323 }; 3324 ; 3325 if (hint_pair_offset) {; 3326 int err = 0;; 3327 char* demangled_name = TClassEdit::DemangleTypeIdName(typeinfo, err);; 3328 if (!err) {; 3329 cl = TClass::GetClass(demangled_name, load, kTRUE, hint_pair_offset, hint_pair_size);; 3330 free(demangled_name);; 3331 if (cl); 3332 return cl;; 3333 }; 3334 }; 3335 ; 3336 // last attempt. Look in the interpreter list of all (compiled+interpreted); 3337 // classes; 3338 cl = gInterpreter->GetClass(typeinfo, load);; 3339 ; 3340 return cl; // Can be zero.; 3341}; 3342 ; 3343////////////////////////////////////////////////////////////////////////////////; 3344/// Static method returning pointer to TClass of the specified ClassInfo.; 3345/// If load is true an attempt is made to obtain the class by loading; 3346/// the appropriate shared library (directed by the rootmap file).; 3347/// If silent is 'true', do not warn about missing dictionary for the class.; 3348/// (typically used for class that are used only for transient members); 3349/// Returns 0 in case class is not found.; 3350 ; 3351TClass *TClass::GetClass(ClassInfo_t *info, Bool_t load, Bool_t silent); 3352{; 3353 if (!info || !gCling->ClassInfo_IsValid(info)) return nullptr;; 3354 if (!gROOT->GetListOfClasses()) return nullptr;; 3355 ; 3356 // Technically we need the write lock only for the call to ClassInfo_FullName; 3357 // and GenerateTClass but FindObject will take the read lock (and LoadClass will; 3358 // take the write lock). Since taking/releasing the lock is expensive, let just; 3359 // take the write guard and keep it.; 3360 R__WRITE_LOCKGUARD(ROOT::gCoreMutex);; 3361 ; 3362 // Get the normalized name.; 3363 TString name( gCling->ClassInfo_FullName(info) );; 3364 ; 3365 TClass *cl = (TClass*)gROOT->GetListOfClasses",MatchSource.WIKI,doc/v632/TClass_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/TClass_8cxx_source.html
https://root.cern/doc/v632/TClass_8cxx_source.html:127179,Performance,load,loading,127179,"toload to avoid potential infinite recursion; 3318 TInterpreter::SuspendAutoLoadingRAII autoloadOff(gInterpreter);; 3319 cl = GetClass(typeinfo, load, hint_pair_offset, hint_pair_size);; 3320 if (cl) {; 3321 return cl;; 3322 }; 3323 }; 3324 ; 3325 if (hint_pair_offset) {; 3326 int err = 0;; 3327 char* demangled_name = TClassEdit::DemangleTypeIdName(typeinfo, err);; 3328 if (!err) {; 3329 cl = TClass::GetClass(demangled_name, load, kTRUE, hint_pair_offset, hint_pair_size);; 3330 free(demangled_name);; 3331 if (cl); 3332 return cl;; 3333 }; 3334 }; 3335 ; 3336 // last attempt. Look in the interpreter list of all (compiled+interpreted); 3337 // classes; 3338 cl = gInterpreter->GetClass(typeinfo, load);; 3339 ; 3340 return cl; // Can be zero.; 3341}; 3342 ; 3343////////////////////////////////////////////////////////////////////////////////; 3344/// Static method returning pointer to TClass of the specified ClassInfo.; 3345/// If load is true an attempt is made to obtain the class by loading; 3346/// the appropriate shared library (directed by the rootmap file).; 3347/// If silent is 'true', do not warn about missing dictionary for the class.; 3348/// (typically used for class that are used only for transient members); 3349/// Returns 0 in case class is not found.; 3350 ; 3351TClass *TClass::GetClass(ClassInfo_t *info, Bool_t load, Bool_t silent); 3352{; 3353 if (!info || !gCling->ClassInfo_IsValid(info)) return nullptr;; 3354 if (!gROOT->GetListOfClasses()) return nullptr;; 3355 ; 3356 // Technically we need the write lock only for the call to ClassInfo_FullName; 3357 // and GenerateTClass but FindObject will take the read lock (and LoadClass will; 3358 // take the write lock). Since taking/releasing the lock is expensive, let just; 3359 // take the write guard and keep it.; 3360 R__WRITE_LOCKGUARD(ROOT::gCoreMutex);; 3361 ; 3362 // Get the normalized name.; 3363 TString name( gCling->ClassInfo_FullName(info) );; 3364 ; 3365 TClass *cl = (TClass*)gROOT->GetListOfClasses",MatchSource.WIKI,doc/v632/TClass_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/TClass_8cxx_source.html
https://root.cern/doc/v632/TClass_8cxx_source.html:127528,Performance,load,load,127528,"angled_name);; 3331 if (cl); 3332 return cl;; 3333 }; 3334 }; 3335 ; 3336 // last attempt. Look in the interpreter list of all (compiled+interpreted); 3337 // classes; 3338 cl = gInterpreter->GetClass(typeinfo, load);; 3339 ; 3340 return cl; // Can be zero.; 3341}; 3342 ; 3343////////////////////////////////////////////////////////////////////////////////; 3344/// Static method returning pointer to TClass of the specified ClassInfo.; 3345/// If load is true an attempt is made to obtain the class by loading; 3346/// the appropriate shared library (directed by the rootmap file).; 3347/// If silent is 'true', do not warn about missing dictionary for the class.; 3348/// (typically used for class that are used only for transient members); 3349/// Returns 0 in case class is not found.; 3350 ; 3351TClass *TClass::GetClass(ClassInfo_t *info, Bool_t load, Bool_t silent); 3352{; 3353 if (!info || !gCling->ClassInfo_IsValid(info)) return nullptr;; 3354 if (!gROOT->GetListOfClasses()) return nullptr;; 3355 ; 3356 // Technically we need the write lock only for the call to ClassInfo_FullName; 3357 // and GenerateTClass but FindObject will take the read lock (and LoadClass will; 3358 // take the write lock). Since taking/releasing the lock is expensive, let just; 3359 // take the write guard and keep it.; 3360 R__WRITE_LOCKGUARD(ROOT::gCoreMutex);; 3361 ; 3362 // Get the normalized name.; 3363 TString name( gCling->ClassInfo_FullName(info) );; 3364 ; 3365 TClass *cl = (TClass*)gROOT->GetListOfClasses()->FindObject(name);; 3366 ; 3367 if (cl) {; 3368 if (cl->IsLoaded()) return cl;; 3369 ; 3370 //we may pass here in case of a dummy class created by TVirtualStreamerInfo; 3371 load = kTRUE;; 3372 ; 3373 }; 3374 ; 3375 if (!load) return nullptr;; 3376 ; 3377 TClass *loadedcl = nullptr;; 3378 if (cl) loadedcl = gROOT->LoadClass(cl->GetName(),silent);; 3379 else loadedcl = gROOT->LoadClass(name,silent);; 3380 ; 3381 if (loadedcl) return loadedcl;; 3382 ; 3383 if (cl) return cl; // If we f",MatchSource.WIKI,doc/v632/TClass_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/TClass_8cxx_source.html
https://root.cern/doc/v632/TClass_8cxx_source.html:128362,Performance,load,load,128362,"ansient members); 3349/// Returns 0 in case class is not found.; 3350 ; 3351TClass *TClass::GetClass(ClassInfo_t *info, Bool_t load, Bool_t silent); 3352{; 3353 if (!info || !gCling->ClassInfo_IsValid(info)) return nullptr;; 3354 if (!gROOT->GetListOfClasses()) return nullptr;; 3355 ; 3356 // Technically we need the write lock only for the call to ClassInfo_FullName; 3357 // and GenerateTClass but FindObject will take the read lock (and LoadClass will; 3358 // take the write lock). Since taking/releasing the lock is expensive, let just; 3359 // take the write guard and keep it.; 3360 R__WRITE_LOCKGUARD(ROOT::gCoreMutex);; 3361 ; 3362 // Get the normalized name.; 3363 TString name( gCling->ClassInfo_FullName(info) );; 3364 ; 3365 TClass *cl = (TClass*)gROOT->GetListOfClasses()->FindObject(name);; 3366 ; 3367 if (cl) {; 3368 if (cl->IsLoaded()) return cl;; 3369 ; 3370 //we may pass here in case of a dummy class created by TVirtualStreamerInfo; 3371 load = kTRUE;; 3372 ; 3373 }; 3374 ; 3375 if (!load) return nullptr;; 3376 ; 3377 TClass *loadedcl = nullptr;; 3378 if (cl) loadedcl = gROOT->LoadClass(cl->GetName(),silent);; 3379 else loadedcl = gROOT->LoadClass(name,silent);; 3380 ; 3381 if (loadedcl) return loadedcl;; 3382 ; 3383 if (cl) return cl; // If we found the class but we already have a dummy class use it.; 3384 ; 3385 // We did not find a proper TClass but we do know (we have a valid; 3386 // ClassInfo) that the class is known to the interpreter.; 3387 TClass *ncl = gInterpreter->GenerateTClass(info, silent);; 3388 if (!ncl->IsZombie()) {; 3389 return ncl;; 3390 } else {; 3391 delete ncl;; 3392 return nullptr;; 3393 }; 3394}; 3395 ; 3396////////////////////////////////////////////////////////////////////////////////; 3397 ; 3398Bool_t TClass::HasNoInfoOrEmuOrFwdDeclaredDecl(const char* name){; 3399 return fNoInfoOrEmuOrFwdDeclNameRegistry.HasDeclName(name);; 3400}; 3401 ; 3402////////////////////////////////////////////////////////////////////////////////; 3403",MatchSource.WIKI,doc/v632/TClass_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/TClass_8cxx_source.html
https://root.cern/doc/v632/TClass_8cxx_source.html:128409,Performance,load,load,128409,"ansient members); 3349/// Returns 0 in case class is not found.; 3350 ; 3351TClass *TClass::GetClass(ClassInfo_t *info, Bool_t load, Bool_t silent); 3352{; 3353 if (!info || !gCling->ClassInfo_IsValid(info)) return nullptr;; 3354 if (!gROOT->GetListOfClasses()) return nullptr;; 3355 ; 3356 // Technically we need the write lock only for the call to ClassInfo_FullName; 3357 // and GenerateTClass but FindObject will take the read lock (and LoadClass will; 3358 // take the write lock). Since taking/releasing the lock is expensive, let just; 3359 // take the write guard and keep it.; 3360 R__WRITE_LOCKGUARD(ROOT::gCoreMutex);; 3361 ; 3362 // Get the normalized name.; 3363 TString name( gCling->ClassInfo_FullName(info) );; 3364 ; 3365 TClass *cl = (TClass*)gROOT->GetListOfClasses()->FindObject(name);; 3366 ; 3367 if (cl) {; 3368 if (cl->IsLoaded()) return cl;; 3369 ; 3370 //we may pass here in case of a dummy class created by TVirtualStreamerInfo; 3371 load = kTRUE;; 3372 ; 3373 }; 3374 ; 3375 if (!load) return nullptr;; 3376 ; 3377 TClass *loadedcl = nullptr;; 3378 if (cl) loadedcl = gROOT->LoadClass(cl->GetName(),silent);; 3379 else loadedcl = gROOT->LoadClass(name,silent);; 3380 ; 3381 if (loadedcl) return loadedcl;; 3382 ; 3383 if (cl) return cl; // If we found the class but we already have a dummy class use it.; 3384 ; 3385 // We did not find a proper TClass but we do know (we have a valid; 3386 // ClassInfo) that the class is known to the interpreter.; 3387 TClass *ncl = gInterpreter->GenerateTClass(info, silent);; 3388 if (!ncl->IsZombie()) {; 3389 return ncl;; 3390 } else {; 3391 delete ncl;; 3392 return nullptr;; 3393 }; 3394}; 3395 ; 3396////////////////////////////////////////////////////////////////////////////////; 3397 ; 3398Bool_t TClass::HasNoInfoOrEmuOrFwdDeclaredDecl(const char* name){; 3399 return fNoInfoOrEmuOrFwdDeclNameRegistry.HasDeclName(name);; 3400}; 3401 ; 3402////////////////////////////////////////////////////////////////////////////////; 3403",MatchSource.WIKI,doc/v632/TClass_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/TClass_8cxx_source.html
https://root.cern/doc/v632/TClass_8cxx_source.html:128452,Performance,load,loadedcl,128452,"ansient members); 3349/// Returns 0 in case class is not found.; 3350 ; 3351TClass *TClass::GetClass(ClassInfo_t *info, Bool_t load, Bool_t silent); 3352{; 3353 if (!info || !gCling->ClassInfo_IsValid(info)) return nullptr;; 3354 if (!gROOT->GetListOfClasses()) return nullptr;; 3355 ; 3356 // Technically we need the write lock only for the call to ClassInfo_FullName; 3357 // and GenerateTClass but FindObject will take the read lock (and LoadClass will; 3358 // take the write lock). Since taking/releasing the lock is expensive, let just; 3359 // take the write guard and keep it.; 3360 R__WRITE_LOCKGUARD(ROOT::gCoreMutex);; 3361 ; 3362 // Get the normalized name.; 3363 TString name( gCling->ClassInfo_FullName(info) );; 3364 ; 3365 TClass *cl = (TClass*)gROOT->GetListOfClasses()->FindObject(name);; 3366 ; 3367 if (cl) {; 3368 if (cl->IsLoaded()) return cl;; 3369 ; 3370 //we may pass here in case of a dummy class created by TVirtualStreamerInfo; 3371 load = kTRUE;; 3372 ; 3373 }; 3374 ; 3375 if (!load) return nullptr;; 3376 ; 3377 TClass *loadedcl = nullptr;; 3378 if (cl) loadedcl = gROOT->LoadClass(cl->GetName(),silent);; 3379 else loadedcl = gROOT->LoadClass(name,silent);; 3380 ; 3381 if (loadedcl) return loadedcl;; 3382 ; 3383 if (cl) return cl; // If we found the class but we already have a dummy class use it.; 3384 ; 3385 // We did not find a proper TClass but we do know (we have a valid; 3386 // ClassInfo) that the class is known to the interpreter.; 3387 TClass *ncl = gInterpreter->GenerateTClass(info, silent);; 3388 if (!ncl->IsZombie()) {; 3389 return ncl;; 3390 } else {; 3391 delete ncl;; 3392 return nullptr;; 3393 }; 3394}; 3395 ; 3396////////////////////////////////////////////////////////////////////////////////; 3397 ; 3398Bool_t TClass::HasNoInfoOrEmuOrFwdDeclaredDecl(const char* name){; 3399 return fNoInfoOrEmuOrFwdDeclNameRegistry.HasDeclName(name);; 3400}; 3401 ; 3402////////////////////////////////////////////////////////////////////////////////; 3403",MatchSource.WIKI,doc/v632/TClass_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/TClass_8cxx_source.html
https://root.cern/doc/v632/TClass_8cxx_source.html:128486,Performance,load,loadedcl,128486,"ansient members); 3349/// Returns 0 in case class is not found.; 3350 ; 3351TClass *TClass::GetClass(ClassInfo_t *info, Bool_t load, Bool_t silent); 3352{; 3353 if (!info || !gCling->ClassInfo_IsValid(info)) return nullptr;; 3354 if (!gROOT->GetListOfClasses()) return nullptr;; 3355 ; 3356 // Technically we need the write lock only for the call to ClassInfo_FullName; 3357 // and GenerateTClass but FindObject will take the read lock (and LoadClass will; 3358 // take the write lock). Since taking/releasing the lock is expensive, let just; 3359 // take the write guard and keep it.; 3360 R__WRITE_LOCKGUARD(ROOT::gCoreMutex);; 3361 ; 3362 // Get the normalized name.; 3363 TString name( gCling->ClassInfo_FullName(info) );; 3364 ; 3365 TClass *cl = (TClass*)gROOT->GetListOfClasses()->FindObject(name);; 3366 ; 3367 if (cl) {; 3368 if (cl->IsLoaded()) return cl;; 3369 ; 3370 //we may pass here in case of a dummy class created by TVirtualStreamerInfo; 3371 load = kTRUE;; 3372 ; 3373 }; 3374 ; 3375 if (!load) return nullptr;; 3376 ; 3377 TClass *loadedcl = nullptr;; 3378 if (cl) loadedcl = gROOT->LoadClass(cl->GetName(),silent);; 3379 else loadedcl = gROOT->LoadClass(name,silent);; 3380 ; 3381 if (loadedcl) return loadedcl;; 3382 ; 3383 if (cl) return cl; // If we found the class but we already have a dummy class use it.; 3384 ; 3385 // We did not find a proper TClass but we do know (we have a valid; 3386 // ClassInfo) that the class is known to the interpreter.; 3387 TClass *ncl = gInterpreter->GenerateTClass(info, silent);; 3388 if (!ncl->IsZombie()) {; 3389 return ncl;; 3390 } else {; 3391 delete ncl;; 3392 return nullptr;; 3393 }; 3394}; 3395 ; 3396////////////////////////////////////////////////////////////////////////////////; 3397 ; 3398Bool_t TClass::HasNoInfoOrEmuOrFwdDeclaredDecl(const char* name){; 3399 return fNoInfoOrEmuOrFwdDeclNameRegistry.HasDeclName(name);; 3400}; 3401 ; 3402////////////////////////////////////////////////////////////////////////////////; 3403",MatchSource.WIKI,doc/v632/TClass_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/TClass_8cxx_source.html
https://root.cern/doc/v632/TClass_8cxx_source.html:128548,Performance,load,loadedcl,128548,"ansient members); 3349/// Returns 0 in case class is not found.; 3350 ; 3351TClass *TClass::GetClass(ClassInfo_t *info, Bool_t load, Bool_t silent); 3352{; 3353 if (!info || !gCling->ClassInfo_IsValid(info)) return nullptr;; 3354 if (!gROOT->GetListOfClasses()) return nullptr;; 3355 ; 3356 // Technically we need the write lock only for the call to ClassInfo_FullName; 3357 // and GenerateTClass but FindObject will take the read lock (and LoadClass will; 3358 // take the write lock). Since taking/releasing the lock is expensive, let just; 3359 // take the write guard and keep it.; 3360 R__WRITE_LOCKGUARD(ROOT::gCoreMutex);; 3361 ; 3362 // Get the normalized name.; 3363 TString name( gCling->ClassInfo_FullName(info) );; 3364 ; 3365 TClass *cl = (TClass*)gROOT->GetListOfClasses()->FindObject(name);; 3366 ; 3367 if (cl) {; 3368 if (cl->IsLoaded()) return cl;; 3369 ; 3370 //we may pass here in case of a dummy class created by TVirtualStreamerInfo; 3371 load = kTRUE;; 3372 ; 3373 }; 3374 ; 3375 if (!load) return nullptr;; 3376 ; 3377 TClass *loadedcl = nullptr;; 3378 if (cl) loadedcl = gROOT->LoadClass(cl->GetName(),silent);; 3379 else loadedcl = gROOT->LoadClass(name,silent);; 3380 ; 3381 if (loadedcl) return loadedcl;; 3382 ; 3383 if (cl) return cl; // If we found the class but we already have a dummy class use it.; 3384 ; 3385 // We did not find a proper TClass but we do know (we have a valid; 3386 // ClassInfo) that the class is known to the interpreter.; 3387 TClass *ncl = gInterpreter->GenerateTClass(info, silent);; 3388 if (!ncl->IsZombie()) {; 3389 return ncl;; 3390 } else {; 3391 delete ncl;; 3392 return nullptr;; 3393 }; 3394}; 3395 ; 3396////////////////////////////////////////////////////////////////////////////////; 3397 ; 3398Bool_t TClass::HasNoInfoOrEmuOrFwdDeclaredDecl(const char* name){; 3399 return fNoInfoOrEmuOrFwdDeclNameRegistry.HasDeclName(name);; 3400}; 3401 ; 3402////////////////////////////////////////////////////////////////////////////////; 3403",MatchSource.WIKI,doc/v632/TClass_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/TClass_8cxx_source.html
https://root.cern/doc/v632/TClass_8cxx_source.html:128607,Performance,load,loadedcl,128607,"ansient members); 3349/// Returns 0 in case class is not found.; 3350 ; 3351TClass *TClass::GetClass(ClassInfo_t *info, Bool_t load, Bool_t silent); 3352{; 3353 if (!info || !gCling->ClassInfo_IsValid(info)) return nullptr;; 3354 if (!gROOT->GetListOfClasses()) return nullptr;; 3355 ; 3356 // Technically we need the write lock only for the call to ClassInfo_FullName; 3357 // and GenerateTClass but FindObject will take the read lock (and LoadClass will; 3358 // take the write lock). Since taking/releasing the lock is expensive, let just; 3359 // take the write guard and keep it.; 3360 R__WRITE_LOCKGUARD(ROOT::gCoreMutex);; 3361 ; 3362 // Get the normalized name.; 3363 TString name( gCling->ClassInfo_FullName(info) );; 3364 ; 3365 TClass *cl = (TClass*)gROOT->GetListOfClasses()->FindObject(name);; 3366 ; 3367 if (cl) {; 3368 if (cl->IsLoaded()) return cl;; 3369 ; 3370 //we may pass here in case of a dummy class created by TVirtualStreamerInfo; 3371 load = kTRUE;; 3372 ; 3373 }; 3374 ; 3375 if (!load) return nullptr;; 3376 ; 3377 TClass *loadedcl = nullptr;; 3378 if (cl) loadedcl = gROOT->LoadClass(cl->GetName(),silent);; 3379 else loadedcl = gROOT->LoadClass(name,silent);; 3380 ; 3381 if (loadedcl) return loadedcl;; 3382 ; 3383 if (cl) return cl; // If we found the class but we already have a dummy class use it.; 3384 ; 3385 // We did not find a proper TClass but we do know (we have a valid; 3386 // ClassInfo) that the class is known to the interpreter.; 3387 TClass *ncl = gInterpreter->GenerateTClass(info, silent);; 3388 if (!ncl->IsZombie()) {; 3389 return ncl;; 3390 } else {; 3391 delete ncl;; 3392 return nullptr;; 3393 }; 3394}; 3395 ; 3396////////////////////////////////////////////////////////////////////////////////; 3397 ; 3398Bool_t TClass::HasNoInfoOrEmuOrFwdDeclaredDecl(const char* name){; 3399 return fNoInfoOrEmuOrFwdDeclNameRegistry.HasDeclName(name);; 3400}; 3401 ; 3402////////////////////////////////////////////////////////////////////////////////; 3403",MatchSource.WIKI,doc/v632/TClass_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/TClass_8cxx_source.html
https://root.cern/doc/v632/TClass_8cxx_source.html:128624,Performance,load,loadedcl,128624,"ansient members); 3349/// Returns 0 in case class is not found.; 3350 ; 3351TClass *TClass::GetClass(ClassInfo_t *info, Bool_t load, Bool_t silent); 3352{; 3353 if (!info || !gCling->ClassInfo_IsValid(info)) return nullptr;; 3354 if (!gROOT->GetListOfClasses()) return nullptr;; 3355 ; 3356 // Technically we need the write lock only for the call to ClassInfo_FullName; 3357 // and GenerateTClass but FindObject will take the read lock (and LoadClass will; 3358 // take the write lock). Since taking/releasing the lock is expensive, let just; 3359 // take the write guard and keep it.; 3360 R__WRITE_LOCKGUARD(ROOT::gCoreMutex);; 3361 ; 3362 // Get the normalized name.; 3363 TString name( gCling->ClassInfo_FullName(info) );; 3364 ; 3365 TClass *cl = (TClass*)gROOT->GetListOfClasses()->FindObject(name);; 3366 ; 3367 if (cl) {; 3368 if (cl->IsLoaded()) return cl;; 3369 ; 3370 //we may pass here in case of a dummy class created by TVirtualStreamerInfo; 3371 load = kTRUE;; 3372 ; 3373 }; 3374 ; 3375 if (!load) return nullptr;; 3376 ; 3377 TClass *loadedcl = nullptr;; 3378 if (cl) loadedcl = gROOT->LoadClass(cl->GetName(),silent);; 3379 else loadedcl = gROOT->LoadClass(name,silent);; 3380 ; 3381 if (loadedcl) return loadedcl;; 3382 ; 3383 if (cl) return cl; // If we found the class but we already have a dummy class use it.; 3384 ; 3385 // We did not find a proper TClass but we do know (we have a valid; 3386 // ClassInfo) that the class is known to the interpreter.; 3387 TClass *ncl = gInterpreter->GenerateTClass(info, silent);; 3388 if (!ncl->IsZombie()) {; 3389 return ncl;; 3390 } else {; 3391 delete ncl;; 3392 return nullptr;; 3393 }; 3394}; 3395 ; 3396////////////////////////////////////////////////////////////////////////////////; 3397 ; 3398Bool_t TClass::HasNoInfoOrEmuOrFwdDeclaredDecl(const char* name){; 3399 return fNoInfoOrEmuOrFwdDeclNameRegistry.HasDeclName(name);; 3400}; 3401 ; 3402////////////////////////////////////////////////////////////////////////////////; 3403",MatchSource.WIKI,doc/v632/TClass_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/TClass_8cxx_source.html
https://root.cern/doc/v632/TClass_8cxx_source.html:130104,Performance,load,loading,130104,"////////////////////////////////////////////////////////////////////; 3403 ; 3404Bool_t TClass::GetClass(DeclId_t id, std::vector<TClass*> &classes); 3405{; 3406 if (!gROOT->GetListOfClasses()) return 0;; 3407 ; 3408 DeclIdMap_t* map = GetDeclIdMap();; 3409 // Get all the TClass pointer that have the same DeclId.; 3410 DeclIdMap_t::equal_range iter = map->Find(id);; 3411 if (iter.first == iter.second) return false;; 3412 std::vector<TClass*>::iterator vectIt = classes.begin();; 3413 for (DeclIdMap_t::const_iterator it = iter.first; it != iter.second; ++it); 3414 vectIt = classes.insert(vectIt, it->second);; 3415 return true;; 3416}; 3417 ; 3418////////////////////////////////////////////////////////////////////////////////; 3419/// Return a pointer to the dictionary loading function generated by; 3420/// rootcint; 3421 ; 3422DictFuncPtr_t TClass::GetDict (const char *cname); 3423{; 3424 return TClassTable::GetDict(cname);; 3425}; 3426 ; 3427////////////////////////////////////////////////////////////////////////////////; 3428/// Return a pointer to the dictionary loading function generated by; 3429/// rootcint; 3430 ; 3431DictFuncPtr_t TClass::GetDict (const std::type_info& info); 3432{; 3433 return TClassTable::GetDict(info);; 3434}; 3435 ; 3436////////////////////////////////////////////////////////////////////////////////; 3437/// Return pointer to datamember object with name ""datamember"".; 3438 ; 3439TDataMember *TClass::GetDataMember(const char *datamember) const; 3440{; 3441 if ((!(fData.load() && (*fData).IsLoaded()) && !HasInterpreterInfo()); 3442 || datamember == nullptr) return nullptr;; 3443 ; 3444 // Strip off leading *'s and trailing [; 3445 const char *start_name = datamember;; 3446 while (*start_name == '*') ++start_name;; 3447 ; 3448 // Empty name are 'legal', they represent anonymous unions.; 3449 // if (*start_name == 0) return 0;; 3450 ; 3451 if (const char *s = strchr(start_name, '[')){; 3452 UInt_t len = s-start_name;; 3453 TString name(start_nam",MatchSource.WIKI,doc/v632/TClass_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/TClass_8cxx_source.html
https://root.cern/doc/v632/TClass_8cxx_source.html:130407,Performance,load,loading,130407,"////////////////////////////////////////////////////////////////////; 3403 ; 3404Bool_t TClass::GetClass(DeclId_t id, std::vector<TClass*> &classes); 3405{; 3406 if (!gROOT->GetListOfClasses()) return 0;; 3407 ; 3408 DeclIdMap_t* map = GetDeclIdMap();; 3409 // Get all the TClass pointer that have the same DeclId.; 3410 DeclIdMap_t::equal_range iter = map->Find(id);; 3411 if (iter.first == iter.second) return false;; 3412 std::vector<TClass*>::iterator vectIt = classes.begin();; 3413 for (DeclIdMap_t::const_iterator it = iter.first; it != iter.second; ++it); 3414 vectIt = classes.insert(vectIt, it->second);; 3415 return true;; 3416}; 3417 ; 3418////////////////////////////////////////////////////////////////////////////////; 3419/// Return a pointer to the dictionary loading function generated by; 3420/// rootcint; 3421 ; 3422DictFuncPtr_t TClass::GetDict (const char *cname); 3423{; 3424 return TClassTable::GetDict(cname);; 3425}; 3426 ; 3427////////////////////////////////////////////////////////////////////////////////; 3428/// Return a pointer to the dictionary loading function generated by; 3429/// rootcint; 3430 ; 3431DictFuncPtr_t TClass::GetDict (const std::type_info& info); 3432{; 3433 return TClassTable::GetDict(info);; 3434}; 3435 ; 3436////////////////////////////////////////////////////////////////////////////////; 3437/// Return pointer to datamember object with name ""datamember"".; 3438 ; 3439TDataMember *TClass::GetDataMember(const char *datamember) const; 3440{; 3441 if ((!(fData.load() && (*fData).IsLoaded()) && !HasInterpreterInfo()); 3442 || datamember == nullptr) return nullptr;; 3443 ; 3444 // Strip off leading *'s and trailing [; 3445 const char *start_name = datamember;; 3446 while (*start_name == '*') ++start_name;; 3447 ; 3448 // Empty name are 'legal', they represent anonymous unions.; 3449 // if (*start_name == 0) return 0;; 3450 ; 3451 if (const char *s = strchr(start_name, '[')){; 3452 UInt_t len = s-start_name;; 3453 TString name(start_nam",MatchSource.WIKI,doc/v632/TClass_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/TClass_8cxx_source.html
https://root.cern/doc/v632/TClass_8cxx_source.html:130846,Performance,load,load,130846,"er.first; it != iter.second; ++it); 3414 vectIt = classes.insert(vectIt, it->second);; 3415 return true;; 3416}; 3417 ; 3418////////////////////////////////////////////////////////////////////////////////; 3419/// Return a pointer to the dictionary loading function generated by; 3420/// rootcint; 3421 ; 3422DictFuncPtr_t TClass::GetDict (const char *cname); 3423{; 3424 return TClassTable::GetDict(cname);; 3425}; 3426 ; 3427////////////////////////////////////////////////////////////////////////////////; 3428/// Return a pointer to the dictionary loading function generated by; 3429/// rootcint; 3430 ; 3431DictFuncPtr_t TClass::GetDict (const std::type_info& info); 3432{; 3433 return TClassTable::GetDict(info);; 3434}; 3435 ; 3436////////////////////////////////////////////////////////////////////////////////; 3437/// Return pointer to datamember object with name ""datamember"".; 3438 ; 3439TDataMember *TClass::GetDataMember(const char *datamember) const; 3440{; 3441 if ((!(fData.load() && (*fData).IsLoaded()) && !HasInterpreterInfo()); 3442 || datamember == nullptr) return nullptr;; 3443 ; 3444 // Strip off leading *'s and trailing [; 3445 const char *start_name = datamember;; 3446 while (*start_name == '*') ++start_name;; 3447 ; 3448 // Empty name are 'legal', they represent anonymous unions.; 3449 // if (*start_name == 0) return 0;; 3450 ; 3451 if (const char *s = strchr(start_name, '[')){; 3452 UInt_t len = s-start_name;; 3453 TString name(start_name,len);; 3454 return (TDataMember *)((TClass*)this)->GetListOfDataMembers(kFALSE)->FindObject(name.Data());; 3455 } else {; 3456 return (TDataMember *)((TClass*)this)->GetListOfDataMembers(kFALSE)->FindObject(start_name);; 3457 }; 3458}; 3459 ; 3460////////////////////////////////////////////////////////////////////////////////; 3461/// Return name of the file containing the declaration of this class.; 3462 ; 3463const char *TClass::GetDeclFileName() const; 3464{; 3465 if (fDeclFileName == kUndeterminedClassInfoName); 3466",MatchSource.WIKI,doc/v632/TClass_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/TClass_8cxx_source.html
https://root.cern/doc/v632/TClass_8cxx_source.html:137836,Performance,load,load,137836,"->FindObject(name);; 3615}; 3616 ; 3617////////////////////////////////////////////////////////////////////////////////; 3618/// Get the list of shared libraries containing the code for class cls.; 3619/// The first library in the list is the one containing the class, the; 3620/// others are the libraries the first one depends on. Returns 0; 3621/// in case the library is not found.; 3622 ; 3623const char *TClass::GetSharedLibs(); 3624{; 3625 if (!gInterpreter) return nullptr;; 3626 ; 3627 if (fSharedLibs.IsNull()); 3628 fSharedLibs = gInterpreter->GetClassSharedLibs(fName);; 3629 ; 3630 return !fSharedLibs.IsNull() ? fSharedLibs.Data() : nullptr;; 3631}; 3632 ; 3633////////////////////////////////////////////////////////////////////////////////; 3634/// Return list containing the TBaseClass(es) of a class.; 3635 ; 3636TList *TClass::GetListOfBases(); 3637{; 3638 if (!fBase.load()) {; 3639 if (fCanLoadClassInfo) {; 3640 if (fState == kHasTClassInit) {; 3641 ; 3642 R__LOCKGUARD(gInterpreterMutex);; 3643 if (!fHasRootPcmInfo) {; 3644 // The bases are in our ProtoClass; we don't need the class info.; 3645 TProtoClass *proto = TClassTable::GetProtoNorm(GetName());; 3646 if (proto && proto->FillTClass(this)); 3647 return fBase;; 3648 }; 3649 }; 3650 // We test again on fCanLoadClassInfo has another thread may have executed it.; 3651 if (!fHasRootPcmInfo && fCanLoadClassInfo) {; 3652 LoadClassInfo();; 3653 }; 3654 }; 3655 if (!fClassInfo); 3656 return nullptr;; 3657 ; 3658 if (!gInterpreter); 3659 Fatal(""GetListOfBases"", ""gInterpreter not initialized"");; 3660 ; 3661 R__LOCKGUARD(gInterpreterMutex);; 3662 if (!fBase.load()) {; 3663 gInterpreter->CreateListOfBaseClasses(this);; 3664 }; 3665 }; 3666 return fBase;; 3667}; 3668 ; 3669////////////////////////////////////////////////////////////////////////////////; 3670/// Return a list containing the TEnums of a class.; 3671///; 3672/// The list returned is safe to use from multiple thread without explicitly; 3673/// taking th",MatchSource.WIKI,doc/v632/TClass_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/TClass_8cxx_source.html
https://root.cern/doc/v632/TClass_8cxx_source.html:138586,Performance,load,load,138586,"/ Return list containing the TBaseClass(es) of a class.; 3635 ; 3636TList *TClass::GetListOfBases(); 3637{; 3638 if (!fBase.load()) {; 3639 if (fCanLoadClassInfo) {; 3640 if (fState == kHasTClassInit) {; 3641 ; 3642 R__LOCKGUARD(gInterpreterMutex);; 3643 if (!fHasRootPcmInfo) {; 3644 // The bases are in our ProtoClass; we don't need the class info.; 3645 TProtoClass *proto = TClassTable::GetProtoNorm(GetName());; 3646 if (proto && proto->FillTClass(this)); 3647 return fBase;; 3648 }; 3649 }; 3650 // We test again on fCanLoadClassInfo has another thread may have executed it.; 3651 if (!fHasRootPcmInfo && fCanLoadClassInfo) {; 3652 LoadClassInfo();; 3653 }; 3654 }; 3655 if (!fClassInfo); 3656 return nullptr;; 3657 ; 3658 if (!gInterpreter); 3659 Fatal(""GetListOfBases"", ""gInterpreter not initialized"");; 3660 ; 3661 R__LOCKGUARD(gInterpreterMutex);; 3662 if (!fBase.load()) {; 3663 gInterpreter->CreateListOfBaseClasses(this);; 3664 }; 3665 }; 3666 return fBase;; 3667}; 3668 ; 3669////////////////////////////////////////////////////////////////////////////////; 3670/// Return a list containing the TEnums of a class.; 3671///; 3672/// The list returned is safe to use from multiple thread without explicitly; 3673/// taking the ROOT global lock.; 3674///; 3675/// In the case the TClass represents a namespace, the returned list will; 3676/// implicit take the ROOT global lock upon any access (see TListOfEnumsWithLock); 3677///; 3678/// In the case the TClass represents a class or struct and requestListLoading; 3679/// is true, the list is immutable (and thus safe to access from multiple thread; 3680/// without taking the global lock at all).; 3681///; 3682/// In the case the TClass represents a class or struct and requestListLoading; 3683/// is false, the list is mutable and thus we return a TListOfEnumsWithLock; 3684/// which will implicit take the ROOT global lock upon any access.; 3685 ; 3686TList *TClass::GetListOfEnums(Bool_t requestListLoading /* = kTRUE */); 3687{; 3688",MatchSource.WIKI,doc/v632/TClass_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/TClass_8cxx_source.html
https://root.cern/doc/v632/TClass_8cxx_source.html:139733,Performance,load,load,139733,"out explicitly; 3673/// taking the ROOT global lock.; 3674///; 3675/// In the case the TClass represents a namespace, the returned list will; 3676/// implicit take the ROOT global lock upon any access (see TListOfEnumsWithLock); 3677///; 3678/// In the case the TClass represents a class or struct and requestListLoading; 3679/// is true, the list is immutable (and thus safe to access from multiple thread; 3680/// without taking the global lock at all).; 3681///; 3682/// In the case the TClass represents a class or struct and requestListLoading; 3683/// is false, the list is mutable and thus we return a TListOfEnumsWithLock; 3684/// which will implicit take the ROOT global lock upon any access.; 3685 ; 3686TList *TClass::GetListOfEnums(Bool_t requestListLoading /* = kTRUE */); 3687{; 3688 auto temp = fEnums.load();; 3689 if (temp) {; 3690 if (requestListLoading) {; 3691 if (fProperty == -1) Property();; 3692 if (! ((kIsClass | kIsStruct | kIsUnion) & fProperty) ) {; 3693 R__LOCKGUARD(gROOTMutex);; 3694 temp->Load();; 3695 } else if ( temp->IsA() == TListOfEnumsWithLock::Class() ) {; 3696 // We have a class for which the list was not loaded fully at; 3697 // first use.; 3698 R__LOCKGUARD(gROOTMutex);; 3699 temp->Load();; 3700 }; 3701 }; 3702 return temp;; 3703 }; 3704 ; 3705 if (!requestListLoading) {; 3706 if (fProperty == -1) Property();; 3707 R__LOCKGUARD(gInterpreterMutex);; 3708 if (fEnums.load()) {; 3709 return fEnums.load();; 3710 }; 3711 ; 3712 if (IsFromRootCling()) // rootcling is single thread (this save some space in the rootpcm).; 3713 fEnums = new TListOfEnums(this);; 3714 else; 3715 fEnums = new TListOfEnumsWithLock(this);; 3716 return fEnums;; 3717 }; 3718 ; 3719 R__LOCKGUARD(gInterpreterMutex);; 3720 if (fEnums.load()) {; 3721 (*fEnums).Load();; 3722 return fEnums.load();; 3723 }; 3724 if (fProperty == -1) Property();; 3725 if ( (kIsClass | kIsStruct | kIsUnion) & fProperty) {; 3726 // For this case, the list will be immutable; 3727 temp = new TListOfEn",MatchSource.WIKI,doc/v632/TClass_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/TClass_8cxx_source.html
https://root.cern/doc/v632/TClass_8cxx_source.html:140065,Performance,load,loaded,140065,"out explicitly; 3673/// taking the ROOT global lock.; 3674///; 3675/// In the case the TClass represents a namespace, the returned list will; 3676/// implicit take the ROOT global lock upon any access (see TListOfEnumsWithLock); 3677///; 3678/// In the case the TClass represents a class or struct and requestListLoading; 3679/// is true, the list is immutable (and thus safe to access from multiple thread; 3680/// without taking the global lock at all).; 3681///; 3682/// In the case the TClass represents a class or struct and requestListLoading; 3683/// is false, the list is mutable and thus we return a TListOfEnumsWithLock; 3684/// which will implicit take the ROOT global lock upon any access.; 3685 ; 3686TList *TClass::GetListOfEnums(Bool_t requestListLoading /* = kTRUE */); 3687{; 3688 auto temp = fEnums.load();; 3689 if (temp) {; 3690 if (requestListLoading) {; 3691 if (fProperty == -1) Property();; 3692 if (! ((kIsClass | kIsStruct | kIsUnion) & fProperty) ) {; 3693 R__LOCKGUARD(gROOTMutex);; 3694 temp->Load();; 3695 } else if ( temp->IsA() == TListOfEnumsWithLock::Class() ) {; 3696 // We have a class for which the list was not loaded fully at; 3697 // first use.; 3698 R__LOCKGUARD(gROOTMutex);; 3699 temp->Load();; 3700 }; 3701 }; 3702 return temp;; 3703 }; 3704 ; 3705 if (!requestListLoading) {; 3706 if (fProperty == -1) Property();; 3707 R__LOCKGUARD(gInterpreterMutex);; 3708 if (fEnums.load()) {; 3709 return fEnums.load();; 3710 }; 3711 ; 3712 if (IsFromRootCling()) // rootcling is single thread (this save some space in the rootpcm).; 3713 fEnums = new TListOfEnums(this);; 3714 else; 3715 fEnums = new TListOfEnumsWithLock(this);; 3716 return fEnums;; 3717 }; 3718 ; 3719 R__LOCKGUARD(gInterpreterMutex);; 3720 if (fEnums.load()) {; 3721 (*fEnums).Load();; 3722 return fEnums.load();; 3723 }; 3724 if (fProperty == -1) Property();; 3725 if ( (kIsClass | kIsStruct | kIsUnion) & fProperty) {; 3726 // For this case, the list will be immutable; 3727 temp = new TListOfEn",MatchSource.WIKI,doc/v632/TClass_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/TClass_8cxx_source.html
https://root.cern/doc/v632/TClass_8cxx_source.html:140331,Performance,load,load,140331," the global lock at all).; 3681///; 3682/// In the case the TClass represents a class or struct and requestListLoading; 3683/// is false, the list is mutable and thus we return a TListOfEnumsWithLock; 3684/// which will implicit take the ROOT global lock upon any access.; 3685 ; 3686TList *TClass::GetListOfEnums(Bool_t requestListLoading /* = kTRUE */); 3687{; 3688 auto temp = fEnums.load();; 3689 if (temp) {; 3690 if (requestListLoading) {; 3691 if (fProperty == -1) Property();; 3692 if (! ((kIsClass | kIsStruct | kIsUnion) & fProperty) ) {; 3693 R__LOCKGUARD(gROOTMutex);; 3694 temp->Load();; 3695 } else if ( temp->IsA() == TListOfEnumsWithLock::Class() ) {; 3696 // We have a class for which the list was not loaded fully at; 3697 // first use.; 3698 R__LOCKGUARD(gROOTMutex);; 3699 temp->Load();; 3700 }; 3701 }; 3702 return temp;; 3703 }; 3704 ; 3705 if (!requestListLoading) {; 3706 if (fProperty == -1) Property();; 3707 R__LOCKGUARD(gInterpreterMutex);; 3708 if (fEnums.load()) {; 3709 return fEnums.load();; 3710 }; 3711 ; 3712 if (IsFromRootCling()) // rootcling is single thread (this save some space in the rootpcm).; 3713 fEnums = new TListOfEnums(this);; 3714 else; 3715 fEnums = new TListOfEnumsWithLock(this);; 3716 return fEnums;; 3717 }; 3718 ; 3719 R__LOCKGUARD(gInterpreterMutex);; 3720 if (fEnums.load()) {; 3721 (*fEnums).Load();; 3722 return fEnums.load();; 3723 }; 3724 if (fProperty == -1) Property();; 3725 if ( (kIsClass | kIsStruct | kIsUnion) & fProperty) {; 3726 // For this case, the list will be immutable; 3727 temp = new TListOfEnums(this);; 3728 } else {; 3729 //namespaces can have enums added to them; 3730 temp = new TListOfEnumsWithLock(this);; 3731 }; 3732 temp->Load();; 3733 fEnums = temp;; 3734 return temp;; 3735}; 3736 ; 3737////////////////////////////////////////////////////////////////////////////////; 3738/// Create the list containing the TDataMembers (of actual data members or members; 3739/// pulled in through using declarations) of a cl",MatchSource.WIKI,doc/v632/TClass_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/TClass_8cxx_source.html
https://root.cern/doc/v632/TClass_8cxx_source.html:140361,Performance,load,load,140361,"ts a class or struct and requestListLoading; 3683/// is false, the list is mutable and thus we return a TListOfEnumsWithLock; 3684/// which will implicit take the ROOT global lock upon any access.; 3685 ; 3686TList *TClass::GetListOfEnums(Bool_t requestListLoading /* = kTRUE */); 3687{; 3688 auto temp = fEnums.load();; 3689 if (temp) {; 3690 if (requestListLoading) {; 3691 if (fProperty == -1) Property();; 3692 if (! ((kIsClass | kIsStruct | kIsUnion) & fProperty) ) {; 3693 R__LOCKGUARD(gROOTMutex);; 3694 temp->Load();; 3695 } else if ( temp->IsA() == TListOfEnumsWithLock::Class() ) {; 3696 // We have a class for which the list was not loaded fully at; 3697 // first use.; 3698 R__LOCKGUARD(gROOTMutex);; 3699 temp->Load();; 3700 }; 3701 }; 3702 return temp;; 3703 }; 3704 ; 3705 if (!requestListLoading) {; 3706 if (fProperty == -1) Property();; 3707 R__LOCKGUARD(gInterpreterMutex);; 3708 if (fEnums.load()) {; 3709 return fEnums.load();; 3710 }; 3711 ; 3712 if (IsFromRootCling()) // rootcling is single thread (this save some space in the rootpcm).; 3713 fEnums = new TListOfEnums(this);; 3714 else; 3715 fEnums = new TListOfEnumsWithLock(this);; 3716 return fEnums;; 3717 }; 3718 ; 3719 R__LOCKGUARD(gInterpreterMutex);; 3720 if (fEnums.load()) {; 3721 (*fEnums).Load();; 3722 return fEnums.load();; 3723 }; 3724 if (fProperty == -1) Property();; 3725 if ( (kIsClass | kIsStruct | kIsUnion) & fProperty) {; 3726 // For this case, the list will be immutable; 3727 temp = new TListOfEnums(this);; 3728 } else {; 3729 //namespaces can have enums added to them; 3730 temp = new TListOfEnumsWithLock(this);; 3731 }; 3732 temp->Load();; 3733 fEnums = temp;; 3734 return temp;; 3735}; 3736 ; 3737////////////////////////////////////////////////////////////////////////////////; 3738/// Create the list containing the TDataMembers (of actual data members or members; 3739/// pulled in through using declarations) of a class.; 3740 ; 3741TList *TClass::CreateListOfDataMembers(std::atomic<TListOf",MatchSource.WIKI,doc/v632/TClass_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/TClass_8cxx_source.html
https://root.cern/doc/v632/TClass_8cxx_source.html:140671,Performance,load,load,140671,"g /* = kTRUE */); 3687{; 3688 auto temp = fEnums.load();; 3689 if (temp) {; 3690 if (requestListLoading) {; 3691 if (fProperty == -1) Property();; 3692 if (! ((kIsClass | kIsStruct | kIsUnion) & fProperty) ) {; 3693 R__LOCKGUARD(gROOTMutex);; 3694 temp->Load();; 3695 } else if ( temp->IsA() == TListOfEnumsWithLock::Class() ) {; 3696 // We have a class for which the list was not loaded fully at; 3697 // first use.; 3698 R__LOCKGUARD(gROOTMutex);; 3699 temp->Load();; 3700 }; 3701 }; 3702 return temp;; 3703 }; 3704 ; 3705 if (!requestListLoading) {; 3706 if (fProperty == -1) Property();; 3707 R__LOCKGUARD(gInterpreterMutex);; 3708 if (fEnums.load()) {; 3709 return fEnums.load();; 3710 }; 3711 ; 3712 if (IsFromRootCling()) // rootcling is single thread (this save some space in the rootpcm).; 3713 fEnums = new TListOfEnums(this);; 3714 else; 3715 fEnums = new TListOfEnumsWithLock(this);; 3716 return fEnums;; 3717 }; 3718 ; 3719 R__LOCKGUARD(gInterpreterMutex);; 3720 if (fEnums.load()) {; 3721 (*fEnums).Load();; 3722 return fEnums.load();; 3723 }; 3724 if (fProperty == -1) Property();; 3725 if ( (kIsClass | kIsStruct | kIsUnion) & fProperty) {; 3726 // For this case, the list will be immutable; 3727 temp = new TListOfEnums(this);; 3728 } else {; 3729 //namespaces can have enums added to them; 3730 temp = new TListOfEnumsWithLock(this);; 3731 }; 3732 temp->Load();; 3733 fEnums = temp;; 3734 return temp;; 3735}; 3736 ; 3737////////////////////////////////////////////////////////////////////////////////; 3738/// Create the list containing the TDataMembers (of actual data members or members; 3739/// pulled in through using declarations) of a class.; 3740 ; 3741TList *TClass::CreateListOfDataMembers(std::atomic<TListOfDataMembers*> &data, TDictionary::EMemberSelection selection, bool load); 3742{; 3743 R__LOCKGUARD(gInterpreterMutex);; 3744 ; 3745 if (!data) {; 3746 if (fCanLoadClassInfo && fState == kHasTClassInit) {; 3747 // The members are in our ProtoClass; we don't need t",MatchSource.WIKI,doc/v632/TClass_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/TClass_8cxx_source.html
https://root.cern/doc/v632/TClass_8cxx_source.html:140725,Performance,load,load,140725," for which the list was not loaded fully at; 3697 // first use.; 3698 R__LOCKGUARD(gROOTMutex);; 3699 temp->Load();; 3700 }; 3701 }; 3702 return temp;; 3703 }; 3704 ; 3705 if (!requestListLoading) {; 3706 if (fProperty == -1) Property();; 3707 R__LOCKGUARD(gInterpreterMutex);; 3708 if (fEnums.load()) {; 3709 return fEnums.load();; 3710 }; 3711 ; 3712 if (IsFromRootCling()) // rootcling is single thread (this save some space in the rootpcm).; 3713 fEnums = new TListOfEnums(this);; 3714 else; 3715 fEnums = new TListOfEnumsWithLock(this);; 3716 return fEnums;; 3717 }; 3718 ; 3719 R__LOCKGUARD(gInterpreterMutex);; 3720 if (fEnums.load()) {; 3721 (*fEnums).Load();; 3722 return fEnums.load();; 3723 }; 3724 if (fProperty == -1) Property();; 3725 if ( (kIsClass | kIsStruct | kIsUnion) & fProperty) {; 3726 // For this case, the list will be immutable; 3727 temp = new TListOfEnums(this);; 3728 } else {; 3729 //namespaces can have enums added to them; 3730 temp = new TListOfEnumsWithLock(this);; 3731 }; 3732 temp->Load();; 3733 fEnums = temp;; 3734 return temp;; 3735}; 3736 ; 3737////////////////////////////////////////////////////////////////////////////////; 3738/// Create the list containing the TDataMembers (of actual data members or members; 3739/// pulled in through using declarations) of a class.; 3740 ; 3741TList *TClass::CreateListOfDataMembers(std::atomic<TListOfDataMembers*> &data, TDictionary::EMemberSelection selection, bool load); 3742{; 3743 R__LOCKGUARD(gInterpreterMutex);; 3744 ; 3745 if (!data) {; 3746 if (fCanLoadClassInfo && fState == kHasTClassInit) {; 3747 // The members are in our ProtoClass; we don't need the class info.; 3748 TProtoClass *proto = TClassTable::GetProtoNorm(GetName());; 3749 if (proto && proto->FillTClass(this)); 3750 return data;; 3751 }; 3752 ; 3753 data = new TListOfDataMembers(this, selection);; 3754 }; 3755 if (IsClassStructOrUnion()) {; 3756 // If the we have a class or struct or union, the order; 3757 // of data members is the list",MatchSource.WIKI,doc/v632/TClass_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/TClass_8cxx_source.html
https://root.cern/doc/v632/TClass_8cxx_source.html:141488,Performance,load,load,141488,"14 else; 3715 fEnums = new TListOfEnumsWithLock(this);; 3716 return fEnums;; 3717 }; 3718 ; 3719 R__LOCKGUARD(gInterpreterMutex);; 3720 if (fEnums.load()) {; 3721 (*fEnums).Load();; 3722 return fEnums.load();; 3723 }; 3724 if (fProperty == -1) Property();; 3725 if ( (kIsClass | kIsStruct | kIsUnion) & fProperty) {; 3726 // For this case, the list will be immutable; 3727 temp = new TListOfEnums(this);; 3728 } else {; 3729 //namespaces can have enums added to them; 3730 temp = new TListOfEnumsWithLock(this);; 3731 }; 3732 temp->Load();; 3733 fEnums = temp;; 3734 return temp;; 3735}; 3736 ; 3737////////////////////////////////////////////////////////////////////////////////; 3738/// Create the list containing the TDataMembers (of actual data members or members; 3739/// pulled in through using declarations) of a class.; 3740 ; 3741TList *TClass::CreateListOfDataMembers(std::atomic<TListOfDataMembers*> &data, TDictionary::EMemberSelection selection, bool load); 3742{; 3743 R__LOCKGUARD(gInterpreterMutex);; 3744 ; 3745 if (!data) {; 3746 if (fCanLoadClassInfo && fState == kHasTClassInit) {; 3747 // The members are in our ProtoClass; we don't need the class info.; 3748 TProtoClass *proto = TClassTable::GetProtoNorm(GetName());; 3749 if (proto && proto->FillTClass(this)); 3750 return data;; 3751 }; 3752 ; 3753 data = new TListOfDataMembers(this, selection);; 3754 }; 3755 if (IsClassStructOrUnion()) {; 3756 // If the we have a class or struct or union, the order; 3757 // of data members is the list is essential since it determines their; 3758 // order on file. So we must always load. Also, the list is fixed; 3759 // since the language does not allow to add members.; 3760 if (!(*data).IsLoaded()); 3761 (*data).Load();; 3762 ; 3763 } else if (load) (*data).Load();; 3764 return data;; 3765}; 3766 ; 3767////////////////////////////////////////////////////////////////////////////////; 3768/// Return list containing the TDataMembers of a class.; 3769 ; 3770TList *TClass::GetListOf",MatchSource.WIKI,doc/v632/TClass_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/TClass_8cxx_source.html
https://root.cern/doc/v632/TClass_8cxx_source.html:142120,Performance,load,load,142120,"736 ; 3737////////////////////////////////////////////////////////////////////////////////; 3738/// Create the list containing the TDataMembers (of actual data members or members; 3739/// pulled in through using declarations) of a class.; 3740 ; 3741TList *TClass::CreateListOfDataMembers(std::atomic<TListOfDataMembers*> &data, TDictionary::EMemberSelection selection, bool load); 3742{; 3743 R__LOCKGUARD(gInterpreterMutex);; 3744 ; 3745 if (!data) {; 3746 if (fCanLoadClassInfo && fState == kHasTClassInit) {; 3747 // The members are in our ProtoClass; we don't need the class info.; 3748 TProtoClass *proto = TClassTable::GetProtoNorm(GetName());; 3749 if (proto && proto->FillTClass(this)); 3750 return data;; 3751 }; 3752 ; 3753 data = new TListOfDataMembers(this, selection);; 3754 }; 3755 if (IsClassStructOrUnion()) {; 3756 // If the we have a class or struct or union, the order; 3757 // of data members is the list is essential since it determines their; 3758 // order on file. So we must always load. Also, the list is fixed; 3759 // since the language does not allow to add members.; 3760 if (!(*data).IsLoaded()); 3761 (*data).Load();; 3762 ; 3763 } else if (load) (*data).Load();; 3764 return data;; 3765}; 3766 ; 3767////////////////////////////////////////////////////////////////////////////////; 3768/// Return list containing the TDataMembers of a class.; 3769 ; 3770TList *TClass::GetListOfDataMembers(Bool_t load /* = kTRUE */); 3771{; 3772 // Fast path, no lock? Classes load at creation time.; 3773 if (IsClassStructOrUnion()) {; 3774 auto data = fData.load();; 3775 if (data && data->IsLoaded()); 3776 return data;; 3777 } else if (!load && fData); 3778 return fData;; 3779 ; 3780 return CreateListOfDataMembers(fData, TDictionary::EMemberSelection::kNoUsingDecls, load);; 3781}; 3782 ; 3783////////////////////////////////////////////////////////////////////////////////; 3784/// Return list containing the TDataMembers of using declarations of a class.; 3785 ; 3786TList *T",MatchSource.WIKI,doc/v632/TClass_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/TClass_8cxx_source.html
https://root.cern/doc/v632/TClass_8cxx_source.html:142286,Performance,load,load,142286,"ers or members; 3739/// pulled in through using declarations) of a class.; 3740 ; 3741TList *TClass::CreateListOfDataMembers(std::atomic<TListOfDataMembers*> &data, TDictionary::EMemberSelection selection, bool load); 3742{; 3743 R__LOCKGUARD(gInterpreterMutex);; 3744 ; 3745 if (!data) {; 3746 if (fCanLoadClassInfo && fState == kHasTClassInit) {; 3747 // The members are in our ProtoClass; we don't need the class info.; 3748 TProtoClass *proto = TClassTable::GetProtoNorm(GetName());; 3749 if (proto && proto->FillTClass(this)); 3750 return data;; 3751 }; 3752 ; 3753 data = new TListOfDataMembers(this, selection);; 3754 }; 3755 if (IsClassStructOrUnion()) {; 3756 // If the we have a class or struct or union, the order; 3757 // of data members is the list is essential since it determines their; 3758 // order on file. So we must always load. Also, the list is fixed; 3759 // since the language does not allow to add members.; 3760 if (!(*data).IsLoaded()); 3761 (*data).Load();; 3762 ; 3763 } else if (load) (*data).Load();; 3764 return data;; 3765}; 3766 ; 3767////////////////////////////////////////////////////////////////////////////////; 3768/// Return list containing the TDataMembers of a class.; 3769 ; 3770TList *TClass::GetListOfDataMembers(Bool_t load /* = kTRUE */); 3771{; 3772 // Fast path, no lock? Classes load at creation time.; 3773 if (IsClassStructOrUnion()) {; 3774 auto data = fData.load();; 3775 if (data && data->IsLoaded()); 3776 return data;; 3777 } else if (!load && fData); 3778 return fData;; 3779 ; 3780 return CreateListOfDataMembers(fData, TDictionary::EMemberSelection::kNoUsingDecls, load);; 3781}; 3782 ; 3783////////////////////////////////////////////////////////////////////////////////; 3784/// Return list containing the TDataMembers of using declarations of a class.; 3785 ; 3786TList *TClass::GetListOfUsingDataMembers(Bool_t load /* = kTRUE */); 3787{; 3788 // Fast path, no lock? Classes load at creation time.; 3789 if ((!load || IsClassStructOrUn",MatchSource.WIKI,doc/v632/TClass_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/TClass_8cxx_source.html
https://root.cern/doc/v632/TClass_8cxx_source.html:142543,Performance,load,load,142543,"data) {; 3746 if (fCanLoadClassInfo && fState == kHasTClassInit) {; 3747 // The members are in our ProtoClass; we don't need the class info.; 3748 TProtoClass *proto = TClassTable::GetProtoNorm(GetName());; 3749 if (proto && proto->FillTClass(this)); 3750 return data;; 3751 }; 3752 ; 3753 data = new TListOfDataMembers(this, selection);; 3754 }; 3755 if (IsClassStructOrUnion()) {; 3756 // If the we have a class or struct or union, the order; 3757 // of data members is the list is essential since it determines their; 3758 // order on file. So we must always load. Also, the list is fixed; 3759 // since the language does not allow to add members.; 3760 if (!(*data).IsLoaded()); 3761 (*data).Load();; 3762 ; 3763 } else if (load) (*data).Load();; 3764 return data;; 3765}; 3766 ; 3767////////////////////////////////////////////////////////////////////////////////; 3768/// Return list containing the TDataMembers of a class.; 3769 ; 3770TList *TClass::GetListOfDataMembers(Bool_t load /* = kTRUE */); 3771{; 3772 // Fast path, no lock? Classes load at creation time.; 3773 if (IsClassStructOrUnion()) {; 3774 auto data = fData.load();; 3775 if (data && data->IsLoaded()); 3776 return data;; 3777 } else if (!load && fData); 3778 return fData;; 3779 ; 3780 return CreateListOfDataMembers(fData, TDictionary::EMemberSelection::kNoUsingDecls, load);; 3781}; 3782 ; 3783////////////////////////////////////////////////////////////////////////////////; 3784/// Return list containing the TDataMembers of using declarations of a class.; 3785 ; 3786TList *TClass::GetListOfUsingDataMembers(Bool_t load /* = kTRUE */); 3787{; 3788 // Fast path, no lock? Classes load at creation time.; 3789 if ((!load || IsClassStructOrUnion()) && fUsingData); 3790 return fUsingData;; 3791 ; 3792 return CreateListOfDataMembers(fUsingData, TDictionary::EMemberSelection::kOnlyUsingDecls, load);; 3793}; 3794 ; 3795////////////////////////////////////////////////////////////////////////////////; 3796/// Return TListOf",MatchSource.WIKI,doc/v632/TClass_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/TClass_8cxx_source.html
https://root.cern/doc/v632/TClass_8cxx_source.html:142607,Performance,load,load,142607,"data) {; 3746 if (fCanLoadClassInfo && fState == kHasTClassInit) {; 3747 // The members are in our ProtoClass; we don't need the class info.; 3748 TProtoClass *proto = TClassTable::GetProtoNorm(GetName());; 3749 if (proto && proto->FillTClass(this)); 3750 return data;; 3751 }; 3752 ; 3753 data = new TListOfDataMembers(this, selection);; 3754 }; 3755 if (IsClassStructOrUnion()) {; 3756 // If the we have a class or struct or union, the order; 3757 // of data members is the list is essential since it determines their; 3758 // order on file. So we must always load. Also, the list is fixed; 3759 // since the language does not allow to add members.; 3760 if (!(*data).IsLoaded()); 3761 (*data).Load();; 3762 ; 3763 } else if (load) (*data).Load();; 3764 return data;; 3765}; 3766 ; 3767////////////////////////////////////////////////////////////////////////////////; 3768/// Return list containing the TDataMembers of a class.; 3769 ; 3770TList *TClass::GetListOfDataMembers(Bool_t load /* = kTRUE */); 3771{; 3772 // Fast path, no lock? Classes load at creation time.; 3773 if (IsClassStructOrUnion()) {; 3774 auto data = fData.load();; 3775 if (data && data->IsLoaded()); 3776 return data;; 3777 } else if (!load && fData); 3778 return fData;; 3779 ; 3780 return CreateListOfDataMembers(fData, TDictionary::EMemberSelection::kNoUsingDecls, load);; 3781}; 3782 ; 3783////////////////////////////////////////////////////////////////////////////////; 3784/// Return list containing the TDataMembers of using declarations of a class.; 3785 ; 3786TList *TClass::GetListOfUsingDataMembers(Bool_t load /* = kTRUE */); 3787{; 3788 // Fast path, no lock? Classes load at creation time.; 3789 if ((!load || IsClassStructOrUnion()) && fUsingData); 3790 return fUsingData;; 3791 ; 3792 return CreateListOfDataMembers(fUsingData, TDictionary::EMemberSelection::kOnlyUsingDecls, load);; 3793}; 3794 ; 3795////////////////////////////////////////////////////////////////////////////////; 3796/// Return TListOf",MatchSource.WIKI,doc/v632/TClass_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/TClass_8cxx_source.html
https://root.cern/doc/v632/TClass_8cxx_source.html:142690,Performance,load,load,142690,"on);; 3754 }; 3755 if (IsClassStructOrUnion()) {; 3756 // If the we have a class or struct or union, the order; 3757 // of data members is the list is essential since it determines their; 3758 // order on file. So we must always load. Also, the list is fixed; 3759 // since the language does not allow to add members.; 3760 if (!(*data).IsLoaded()); 3761 (*data).Load();; 3762 ; 3763 } else if (load) (*data).Load();; 3764 return data;; 3765}; 3766 ; 3767////////////////////////////////////////////////////////////////////////////////; 3768/// Return list containing the TDataMembers of a class.; 3769 ; 3770TList *TClass::GetListOfDataMembers(Bool_t load /* = kTRUE */); 3771{; 3772 // Fast path, no lock? Classes load at creation time.; 3773 if (IsClassStructOrUnion()) {; 3774 auto data = fData.load();; 3775 if (data && data->IsLoaded()); 3776 return data;; 3777 } else if (!load && fData); 3778 return fData;; 3779 ; 3780 return CreateListOfDataMembers(fData, TDictionary::EMemberSelection::kNoUsingDecls, load);; 3781}; 3782 ; 3783////////////////////////////////////////////////////////////////////////////////; 3784/// Return list containing the TDataMembers of using declarations of a class.; 3785 ; 3786TList *TClass::GetListOfUsingDataMembers(Bool_t load /* = kTRUE */); 3787{; 3788 // Fast path, no lock? Classes load at creation time.; 3789 if ((!load || IsClassStructOrUnion()) && fUsingData); 3790 return fUsingData;; 3791 ; 3792 return CreateListOfDataMembers(fUsingData, TDictionary::EMemberSelection::kOnlyUsingDecls, load);; 3793}; 3794 ; 3795////////////////////////////////////////////////////////////////////////////////; 3796/// Return TListOfFunctionTemplates for a class.; 3797 ; 3798TList *TClass::GetListOfFunctionTemplates(Bool_t load /* = kTRUE */); 3799{; 3800 R__LOCKGUARD(gInterpreterMutex);; 3801 ; 3802 if (!fFuncTemplate) fFuncTemplate = new TListOfFunctionTemplates(this);; 3803 if (load) fFuncTemplate->Load();; 3804 return fFuncTemplate;; 3805}; 3806 ; 3807////",MatchSource.WIKI,doc/v632/TClass_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/TClass_8cxx_source.html
https://root.cern/doc/v632/TClass_8cxx_source.html:142771,Performance,load,load,142771,"on);; 3754 }; 3755 if (IsClassStructOrUnion()) {; 3756 // If the we have a class or struct or union, the order; 3757 // of data members is the list is essential since it determines their; 3758 // order on file. So we must always load. Also, the list is fixed; 3759 // since the language does not allow to add members.; 3760 if (!(*data).IsLoaded()); 3761 (*data).Load();; 3762 ; 3763 } else if (load) (*data).Load();; 3764 return data;; 3765}; 3766 ; 3767////////////////////////////////////////////////////////////////////////////////; 3768/// Return list containing the TDataMembers of a class.; 3769 ; 3770TList *TClass::GetListOfDataMembers(Bool_t load /* = kTRUE */); 3771{; 3772 // Fast path, no lock? Classes load at creation time.; 3773 if (IsClassStructOrUnion()) {; 3774 auto data = fData.load();; 3775 if (data && data->IsLoaded()); 3776 return data;; 3777 } else if (!load && fData); 3778 return fData;; 3779 ; 3780 return CreateListOfDataMembers(fData, TDictionary::EMemberSelection::kNoUsingDecls, load);; 3781}; 3782 ; 3783////////////////////////////////////////////////////////////////////////////////; 3784/// Return list containing the TDataMembers of using declarations of a class.; 3785 ; 3786TList *TClass::GetListOfUsingDataMembers(Bool_t load /* = kTRUE */); 3787{; 3788 // Fast path, no lock? Classes load at creation time.; 3789 if ((!load || IsClassStructOrUnion()) && fUsingData); 3790 return fUsingData;; 3791 ; 3792 return CreateListOfDataMembers(fUsingData, TDictionary::EMemberSelection::kOnlyUsingDecls, load);; 3793}; 3794 ; 3795////////////////////////////////////////////////////////////////////////////////; 3796/// Return TListOfFunctionTemplates for a class.; 3797 ; 3798TList *TClass::GetListOfFunctionTemplates(Bool_t load /* = kTRUE */); 3799{; 3800 R__LOCKGUARD(gInterpreterMutex);; 3801 ; 3802 if (!fFuncTemplate) fFuncTemplate = new TListOfFunctionTemplates(this);; 3803 if (load) fFuncTemplate->Load();; 3804 return fFuncTemplate;; 3805}; 3806 ; 3807////",MatchSource.WIKI,doc/v632/TClass_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/TClass_8cxx_source.html
https://root.cern/doc/v632/TClass_8cxx_source.html:142903,Performance,load,load,142903,"on);; 3754 }; 3755 if (IsClassStructOrUnion()) {; 3756 // If the we have a class or struct or union, the order; 3757 // of data members is the list is essential since it determines their; 3758 // order on file. So we must always load. Also, the list is fixed; 3759 // since the language does not allow to add members.; 3760 if (!(*data).IsLoaded()); 3761 (*data).Load();; 3762 ; 3763 } else if (load) (*data).Load();; 3764 return data;; 3765}; 3766 ; 3767////////////////////////////////////////////////////////////////////////////////; 3768/// Return list containing the TDataMembers of a class.; 3769 ; 3770TList *TClass::GetListOfDataMembers(Bool_t load /* = kTRUE */); 3771{; 3772 // Fast path, no lock? Classes load at creation time.; 3773 if (IsClassStructOrUnion()) {; 3774 auto data = fData.load();; 3775 if (data && data->IsLoaded()); 3776 return data;; 3777 } else if (!load && fData); 3778 return fData;; 3779 ; 3780 return CreateListOfDataMembers(fData, TDictionary::EMemberSelection::kNoUsingDecls, load);; 3781}; 3782 ; 3783////////////////////////////////////////////////////////////////////////////////; 3784/// Return list containing the TDataMembers of using declarations of a class.; 3785 ; 3786TList *TClass::GetListOfUsingDataMembers(Bool_t load /* = kTRUE */); 3787{; 3788 // Fast path, no lock? Classes load at creation time.; 3789 if ((!load || IsClassStructOrUnion()) && fUsingData); 3790 return fUsingData;; 3791 ; 3792 return CreateListOfDataMembers(fUsingData, TDictionary::EMemberSelection::kOnlyUsingDecls, load);; 3793}; 3794 ; 3795////////////////////////////////////////////////////////////////////////////////; 3796/// Return TListOfFunctionTemplates for a class.; 3797 ; 3798TList *TClass::GetListOfFunctionTemplates(Bool_t load /* = kTRUE */); 3799{; 3800 R__LOCKGUARD(gInterpreterMutex);; 3801 ; 3802 if (!fFuncTemplate) fFuncTemplate = new TListOfFunctionTemplates(this);; 3803 if (load) fFuncTemplate->Load();; 3804 return fFuncTemplate;; 3805}; 3806 ; 3807////",MatchSource.WIKI,doc/v632/TClass_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/TClass_8cxx_source.html
https://root.cern/doc/v632/TClass_8cxx_source.html:143153,Performance,load,load,143153,"the language does not allow to add members.; 3760 if (!(*data).IsLoaded()); 3761 (*data).Load();; 3762 ; 3763 } else if (load) (*data).Load();; 3764 return data;; 3765}; 3766 ; 3767////////////////////////////////////////////////////////////////////////////////; 3768/// Return list containing the TDataMembers of a class.; 3769 ; 3770TList *TClass::GetListOfDataMembers(Bool_t load /* = kTRUE */); 3771{; 3772 // Fast path, no lock? Classes load at creation time.; 3773 if (IsClassStructOrUnion()) {; 3774 auto data = fData.load();; 3775 if (data && data->IsLoaded()); 3776 return data;; 3777 } else if (!load && fData); 3778 return fData;; 3779 ; 3780 return CreateListOfDataMembers(fData, TDictionary::EMemberSelection::kNoUsingDecls, load);; 3781}; 3782 ; 3783////////////////////////////////////////////////////////////////////////////////; 3784/// Return list containing the TDataMembers of using declarations of a class.; 3785 ; 3786TList *TClass::GetListOfUsingDataMembers(Bool_t load /* = kTRUE */); 3787{; 3788 // Fast path, no lock? Classes load at creation time.; 3789 if ((!load || IsClassStructOrUnion()) && fUsingData); 3790 return fUsingData;; 3791 ; 3792 return CreateListOfDataMembers(fUsingData, TDictionary::EMemberSelection::kOnlyUsingDecls, load);; 3793}; 3794 ; 3795////////////////////////////////////////////////////////////////////////////////; 3796/// Return TListOfFunctionTemplates for a class.; 3797 ; 3798TList *TClass::GetListOfFunctionTemplates(Bool_t load /* = kTRUE */); 3799{; 3800 R__LOCKGUARD(gInterpreterMutex);; 3801 ; 3802 if (!fFuncTemplate) fFuncTemplate = new TListOfFunctionTemplates(this);; 3803 if (load) fFuncTemplate->Load();; 3804 return fFuncTemplate;; 3805}; 3806 ; 3807////////////////////////////////////////////////////////////////////////////////; 3808/// Return list containing the TMethods of a class.; 3809/// If load is true, the list is populated with all the defined function; 3810/// and currently instantiated function template.; 3811 ; ",MatchSource.WIKI,doc/v632/TClass_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/TClass_8cxx_source.html
https://root.cern/doc/v632/TClass_8cxx_source.html:143217,Performance,load,load,143217,"the language does not allow to add members.; 3760 if (!(*data).IsLoaded()); 3761 (*data).Load();; 3762 ; 3763 } else if (load) (*data).Load();; 3764 return data;; 3765}; 3766 ; 3767////////////////////////////////////////////////////////////////////////////////; 3768/// Return list containing the TDataMembers of a class.; 3769 ; 3770TList *TClass::GetListOfDataMembers(Bool_t load /* = kTRUE */); 3771{; 3772 // Fast path, no lock? Classes load at creation time.; 3773 if (IsClassStructOrUnion()) {; 3774 auto data = fData.load();; 3775 if (data && data->IsLoaded()); 3776 return data;; 3777 } else if (!load && fData); 3778 return fData;; 3779 ; 3780 return CreateListOfDataMembers(fData, TDictionary::EMemberSelection::kNoUsingDecls, load);; 3781}; 3782 ; 3783////////////////////////////////////////////////////////////////////////////////; 3784/// Return list containing the TDataMembers of using declarations of a class.; 3785 ; 3786TList *TClass::GetListOfUsingDataMembers(Bool_t load /* = kTRUE */); 3787{; 3788 // Fast path, no lock? Classes load at creation time.; 3789 if ((!load || IsClassStructOrUnion()) && fUsingData); 3790 return fUsingData;; 3791 ; 3792 return CreateListOfDataMembers(fUsingData, TDictionary::EMemberSelection::kOnlyUsingDecls, load);; 3793}; 3794 ; 3795////////////////////////////////////////////////////////////////////////////////; 3796/// Return TListOfFunctionTemplates for a class.; 3797 ; 3798TList *TClass::GetListOfFunctionTemplates(Bool_t load /* = kTRUE */); 3799{; 3800 R__LOCKGUARD(gInterpreterMutex);; 3801 ; 3802 if (!fFuncTemplate) fFuncTemplate = new TListOfFunctionTemplates(this);; 3803 if (load) fFuncTemplate->Load();; 3804 return fFuncTemplate;; 3805}; 3806 ; 3807////////////////////////////////////////////////////////////////////////////////; 3808/// Return list containing the TMethods of a class.; 3809/// If load is true, the list is populated with all the defined function; 3810/// and currently instantiated function template.; 3811 ; ",MatchSource.WIKI,doc/v632/TClass_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/TClass_8cxx_source.html
https://root.cern/doc/v632/TClass_8cxx_source.html:143252,Performance,load,load,143252,"/////////////; 3768/// Return list containing the TDataMembers of a class.; 3769 ; 3770TList *TClass::GetListOfDataMembers(Bool_t load /* = kTRUE */); 3771{; 3772 // Fast path, no lock? Classes load at creation time.; 3773 if (IsClassStructOrUnion()) {; 3774 auto data = fData.load();; 3775 if (data && data->IsLoaded()); 3776 return data;; 3777 } else if (!load && fData); 3778 return fData;; 3779 ; 3780 return CreateListOfDataMembers(fData, TDictionary::EMemberSelection::kNoUsingDecls, load);; 3781}; 3782 ; 3783////////////////////////////////////////////////////////////////////////////////; 3784/// Return list containing the TDataMembers of using declarations of a class.; 3785 ; 3786TList *TClass::GetListOfUsingDataMembers(Bool_t load /* = kTRUE */); 3787{; 3788 // Fast path, no lock? Classes load at creation time.; 3789 if ((!load || IsClassStructOrUnion()) && fUsingData); 3790 return fUsingData;; 3791 ; 3792 return CreateListOfDataMembers(fUsingData, TDictionary::EMemberSelection::kOnlyUsingDecls, load);; 3793}; 3794 ; 3795////////////////////////////////////////////////////////////////////////////////; 3796/// Return TListOfFunctionTemplates for a class.; 3797 ; 3798TList *TClass::GetListOfFunctionTemplates(Bool_t load /* = kTRUE */); 3799{; 3800 R__LOCKGUARD(gInterpreterMutex);; 3801 ; 3802 if (!fFuncTemplate) fFuncTemplate = new TListOfFunctionTemplates(this);; 3803 if (load) fFuncTemplate->Load();; 3804 return fFuncTemplate;; 3805}; 3806 ; 3807////////////////////////////////////////////////////////////////////////////////; 3808/// Return list containing the TMethods of a class.; 3809/// If load is true, the list is populated with all the defined function; 3810/// and currently instantiated function template.; 3811 ; 3812TList *TClass::GetListOfMethods(Bool_t load /* = kTRUE */); 3813{; 3814 R__LOCKGUARD(gInterpreterMutex);; 3815 ; 3816 if (!fMethod.load()) GetMethodList();; 3817 if (load) {; 3818 if (gDebug>0) Info(""GetListOfMethods"",""Header Parsing - Asking f",MatchSource.WIKI,doc/v632/TClass_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/TClass_8cxx_source.html
https://root.cern/doc/v632/TClass_8cxx_source.html:143428,Performance,load,load,143428,"/////////////; 3768/// Return list containing the TDataMembers of a class.; 3769 ; 3770TList *TClass::GetListOfDataMembers(Bool_t load /* = kTRUE */); 3771{; 3772 // Fast path, no lock? Classes load at creation time.; 3773 if (IsClassStructOrUnion()) {; 3774 auto data = fData.load();; 3775 if (data && data->IsLoaded()); 3776 return data;; 3777 } else if (!load && fData); 3778 return fData;; 3779 ; 3780 return CreateListOfDataMembers(fData, TDictionary::EMemberSelection::kNoUsingDecls, load);; 3781}; 3782 ; 3783////////////////////////////////////////////////////////////////////////////////; 3784/// Return list containing the TDataMembers of using declarations of a class.; 3785 ; 3786TList *TClass::GetListOfUsingDataMembers(Bool_t load /* = kTRUE */); 3787{; 3788 // Fast path, no lock? Classes load at creation time.; 3789 if ((!load || IsClassStructOrUnion()) && fUsingData); 3790 return fUsingData;; 3791 ; 3792 return CreateListOfDataMembers(fUsingData, TDictionary::EMemberSelection::kOnlyUsingDecls, load);; 3793}; 3794 ; 3795////////////////////////////////////////////////////////////////////////////////; 3796/// Return TListOfFunctionTemplates for a class.; 3797 ; 3798TList *TClass::GetListOfFunctionTemplates(Bool_t load /* = kTRUE */); 3799{; 3800 R__LOCKGUARD(gInterpreterMutex);; 3801 ; 3802 if (!fFuncTemplate) fFuncTemplate = new TListOfFunctionTemplates(this);; 3803 if (load) fFuncTemplate->Load();; 3804 return fFuncTemplate;; 3805}; 3806 ; 3807////////////////////////////////////////////////////////////////////////////////; 3808/// Return list containing the TMethods of a class.; 3809/// If load is true, the list is populated with all the defined function; 3810/// and currently instantiated function template.; 3811 ; 3812TList *TClass::GetListOfMethods(Bool_t load /* = kTRUE */); 3813{; 3814 R__LOCKGUARD(gInterpreterMutex);; 3815 ; 3816 if (!fMethod.load()) GetMethodList();; 3817 if (load) {; 3818 if (gDebug>0) Info(""GetListOfMethods"",""Header Parsing - Asking f",MatchSource.WIKI,doc/v632/TClass_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/TClass_8cxx_source.html
https://root.cern/doc/v632/TClass_8cxx_source.html:143650,Performance,load,load,143650," 3779 ; 3780 return CreateListOfDataMembers(fData, TDictionary::EMemberSelection::kNoUsingDecls, load);; 3781}; 3782 ; 3783////////////////////////////////////////////////////////////////////////////////; 3784/// Return list containing the TDataMembers of using declarations of a class.; 3785 ; 3786TList *TClass::GetListOfUsingDataMembers(Bool_t load /* = kTRUE */); 3787{; 3788 // Fast path, no lock? Classes load at creation time.; 3789 if ((!load || IsClassStructOrUnion()) && fUsingData); 3790 return fUsingData;; 3791 ; 3792 return CreateListOfDataMembers(fUsingData, TDictionary::EMemberSelection::kOnlyUsingDecls, load);; 3793}; 3794 ; 3795////////////////////////////////////////////////////////////////////////////////; 3796/// Return TListOfFunctionTemplates for a class.; 3797 ; 3798TList *TClass::GetListOfFunctionTemplates(Bool_t load /* = kTRUE */); 3799{; 3800 R__LOCKGUARD(gInterpreterMutex);; 3801 ; 3802 if (!fFuncTemplate) fFuncTemplate = new TListOfFunctionTemplates(this);; 3803 if (load) fFuncTemplate->Load();; 3804 return fFuncTemplate;; 3805}; 3806 ; 3807////////////////////////////////////////////////////////////////////////////////; 3808/// Return list containing the TMethods of a class.; 3809/// If load is true, the list is populated with all the defined function; 3810/// and currently instantiated function template.; 3811 ; 3812TList *TClass::GetListOfMethods(Bool_t load /* = kTRUE */); 3813{; 3814 R__LOCKGUARD(gInterpreterMutex);; 3815 ; 3816 if (!fMethod.load()) GetMethodList();; 3817 if (load) {; 3818 if (gDebug>0) Info(""GetListOfMethods"",""Header Parsing - Asking for all the methods of class %s: this can involve parsing."",GetName());; 3819 (*fMethod).Load();; 3820 }; 3821 return fMethod;; 3822}; 3823 ; 3824////////////////////////////////////////////////////////////////////////////////; 3825/// Return the collection of functions named ""name"".; 3826 ; 3827TCollection *TClass::GetListOfMethodOverloads(const char* name) const; 3828{; 3829 return const_",MatchSource.WIKI,doc/v632/TClass_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/TClass_8cxx_source.html
https://root.cern/doc/v632/TClass_8cxx_source.html:143811,Performance,load,load,143811," 3779 ; 3780 return CreateListOfDataMembers(fData, TDictionary::EMemberSelection::kNoUsingDecls, load);; 3781}; 3782 ; 3783////////////////////////////////////////////////////////////////////////////////; 3784/// Return list containing the TDataMembers of using declarations of a class.; 3785 ; 3786TList *TClass::GetListOfUsingDataMembers(Bool_t load /* = kTRUE */); 3787{; 3788 // Fast path, no lock? Classes load at creation time.; 3789 if ((!load || IsClassStructOrUnion()) && fUsingData); 3790 return fUsingData;; 3791 ; 3792 return CreateListOfDataMembers(fUsingData, TDictionary::EMemberSelection::kOnlyUsingDecls, load);; 3793}; 3794 ; 3795////////////////////////////////////////////////////////////////////////////////; 3796/// Return TListOfFunctionTemplates for a class.; 3797 ; 3798TList *TClass::GetListOfFunctionTemplates(Bool_t load /* = kTRUE */); 3799{; 3800 R__LOCKGUARD(gInterpreterMutex);; 3801 ; 3802 if (!fFuncTemplate) fFuncTemplate = new TListOfFunctionTemplates(this);; 3803 if (load) fFuncTemplate->Load();; 3804 return fFuncTemplate;; 3805}; 3806 ; 3807////////////////////////////////////////////////////////////////////////////////; 3808/// Return list containing the TMethods of a class.; 3809/// If load is true, the list is populated with all the defined function; 3810/// and currently instantiated function template.; 3811 ; 3812TList *TClass::GetListOfMethods(Bool_t load /* = kTRUE */); 3813{; 3814 R__LOCKGUARD(gInterpreterMutex);; 3815 ; 3816 if (!fMethod.load()) GetMethodList();; 3817 if (load) {; 3818 if (gDebug>0) Info(""GetListOfMethods"",""Header Parsing - Asking for all the methods of class %s: this can involve parsing."",GetName());; 3819 (*fMethod).Load();; 3820 }; 3821 return fMethod;; 3822}; 3823 ; 3824////////////////////////////////////////////////////////////////////////////////; 3825/// Return the collection of functions named ""name"".; 3826 ; 3827TCollection *TClass::GetListOfMethodOverloads(const char* name) const; 3828{; 3829 return const_",MatchSource.WIKI,doc/v632/TClass_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/TClass_8cxx_source.html
https://root.cern/doc/v632/TClass_8cxx_source.html:144037,Performance,load,load,144037,"s.; 3785 ; 3786TList *TClass::GetListOfUsingDataMembers(Bool_t load /* = kTRUE */); 3787{; 3788 // Fast path, no lock? Classes load at creation time.; 3789 if ((!load || IsClassStructOrUnion()) && fUsingData); 3790 return fUsingData;; 3791 ; 3792 return CreateListOfDataMembers(fUsingData, TDictionary::EMemberSelection::kOnlyUsingDecls, load);; 3793}; 3794 ; 3795////////////////////////////////////////////////////////////////////////////////; 3796/// Return TListOfFunctionTemplates for a class.; 3797 ; 3798TList *TClass::GetListOfFunctionTemplates(Bool_t load /* = kTRUE */); 3799{; 3800 R__LOCKGUARD(gInterpreterMutex);; 3801 ; 3802 if (!fFuncTemplate) fFuncTemplate = new TListOfFunctionTemplates(this);; 3803 if (load) fFuncTemplate->Load();; 3804 return fFuncTemplate;; 3805}; 3806 ; 3807////////////////////////////////////////////////////////////////////////////////; 3808/// Return list containing the TMethods of a class.; 3809/// If load is true, the list is populated with all the defined function; 3810/// and currently instantiated function template.; 3811 ; 3812TList *TClass::GetListOfMethods(Bool_t load /* = kTRUE */); 3813{; 3814 R__LOCKGUARD(gInterpreterMutex);; 3815 ; 3816 if (!fMethod.load()) GetMethodList();; 3817 if (load) {; 3818 if (gDebug>0) Info(""GetListOfMethods"",""Header Parsing - Asking for all the methods of class %s: this can involve parsing."",GetName());; 3819 (*fMethod).Load();; 3820 }; 3821 return fMethod;; 3822}; 3823 ; 3824////////////////////////////////////////////////////////////////////////////////; 3825/// Return the collection of functions named ""name"".; 3826 ; 3827TCollection *TClass::GetListOfMethodOverloads(const char* name) const; 3828{; 3829 return const_cast<TClass*>(this)->GetMethodList()->GetListForObject(name);; 3830}; 3831 ; 3832 ; 3833////////////////////////////////////////////////////////////////////////////////; 3834/// Returns a list of all public methods of this class and its base classes.; 3835/// Refers to a subset of the",MatchSource.WIKI,doc/v632/TClass_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/TClass_8cxx_source.html
https://root.cern/doc/v632/TClass_8cxx_source.html:144209,Performance,load,load,144209,"tion time.; 3789 if ((!load || IsClassStructOrUnion()) && fUsingData); 3790 return fUsingData;; 3791 ; 3792 return CreateListOfDataMembers(fUsingData, TDictionary::EMemberSelection::kOnlyUsingDecls, load);; 3793}; 3794 ; 3795////////////////////////////////////////////////////////////////////////////////; 3796/// Return TListOfFunctionTemplates for a class.; 3797 ; 3798TList *TClass::GetListOfFunctionTemplates(Bool_t load /* = kTRUE */); 3799{; 3800 R__LOCKGUARD(gInterpreterMutex);; 3801 ; 3802 if (!fFuncTemplate) fFuncTemplate = new TListOfFunctionTemplates(this);; 3803 if (load) fFuncTemplate->Load();; 3804 return fFuncTemplate;; 3805}; 3806 ; 3807////////////////////////////////////////////////////////////////////////////////; 3808/// Return list containing the TMethods of a class.; 3809/// If load is true, the list is populated with all the defined function; 3810/// and currently instantiated function template.; 3811 ; 3812TList *TClass::GetListOfMethods(Bool_t load /* = kTRUE */); 3813{; 3814 R__LOCKGUARD(gInterpreterMutex);; 3815 ; 3816 if (!fMethod.load()) GetMethodList();; 3817 if (load) {; 3818 if (gDebug>0) Info(""GetListOfMethods"",""Header Parsing - Asking for all the methods of class %s: this can involve parsing."",GetName());; 3819 (*fMethod).Load();; 3820 }; 3821 return fMethod;; 3822}; 3823 ; 3824////////////////////////////////////////////////////////////////////////////////; 3825/// Return the collection of functions named ""name"".; 3826 ; 3827TCollection *TClass::GetListOfMethodOverloads(const char* name) const; 3828{; 3829 return const_cast<TClass*>(this)->GetMethodList()->GetListForObject(name);; 3830}; 3831 ; 3832 ; 3833////////////////////////////////////////////////////////////////////////////////; 3834/// Returns a list of all public methods of this class and its base classes.; 3835/// Refers to a subset of the methods in GetListOfMethods() so don't do; 3836/// GetListOfAllPublicMethods()->Delete().; 3837/// Algorithm used to get the list is:; 38",MatchSource.WIKI,doc/v632/TClass_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/TClass_8cxx_source.html
https://root.cern/doc/v632/TClass_8cxx_source.html:144301,Performance,load,load,144301,"onary::EMemberSelection::kOnlyUsingDecls, load);; 3793}; 3794 ; 3795////////////////////////////////////////////////////////////////////////////////; 3796/// Return TListOfFunctionTemplates for a class.; 3797 ; 3798TList *TClass::GetListOfFunctionTemplates(Bool_t load /* = kTRUE */); 3799{; 3800 R__LOCKGUARD(gInterpreterMutex);; 3801 ; 3802 if (!fFuncTemplate) fFuncTemplate = new TListOfFunctionTemplates(this);; 3803 if (load) fFuncTemplate->Load();; 3804 return fFuncTemplate;; 3805}; 3806 ; 3807////////////////////////////////////////////////////////////////////////////////; 3808/// Return list containing the TMethods of a class.; 3809/// If load is true, the list is populated with all the defined function; 3810/// and currently instantiated function template.; 3811 ; 3812TList *TClass::GetListOfMethods(Bool_t load /* = kTRUE */); 3813{; 3814 R__LOCKGUARD(gInterpreterMutex);; 3815 ; 3816 if (!fMethod.load()) GetMethodList();; 3817 if (load) {; 3818 if (gDebug>0) Info(""GetListOfMethods"",""Header Parsing - Asking for all the methods of class %s: this can involve parsing."",GetName());; 3819 (*fMethod).Load();; 3820 }; 3821 return fMethod;; 3822}; 3823 ; 3824////////////////////////////////////////////////////////////////////////////////; 3825/// Return the collection of functions named ""name"".; 3826 ; 3827TCollection *TClass::GetListOfMethodOverloads(const char* name) const; 3828{; 3829 return const_cast<TClass*>(this)->GetMethodList()->GetListForObject(name);; 3830}; 3831 ; 3832 ; 3833////////////////////////////////////////////////////////////////////////////////; 3834/// Returns a list of all public methods of this class and its base classes.; 3835/// Refers to a subset of the methods in GetListOfMethods() so don't do; 3836/// GetListOfAllPublicMethods()->Delete().; 3837/// Algorithm used to get the list is:; 3838/// - put all methods of the class in the list (also protected and private; 3839/// ones).; 3840/// - loop over all base classes and add only those methods",MatchSource.WIKI,doc/v632/TClass_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/TClass_8cxx_source.html
https://root.cern/doc/v632/TClass_8cxx_source.html:144336,Performance,load,load,144336,"onary::EMemberSelection::kOnlyUsingDecls, load);; 3793}; 3794 ; 3795////////////////////////////////////////////////////////////////////////////////; 3796/// Return TListOfFunctionTemplates for a class.; 3797 ; 3798TList *TClass::GetListOfFunctionTemplates(Bool_t load /* = kTRUE */); 3799{; 3800 R__LOCKGUARD(gInterpreterMutex);; 3801 ; 3802 if (!fFuncTemplate) fFuncTemplate = new TListOfFunctionTemplates(this);; 3803 if (load) fFuncTemplate->Load();; 3804 return fFuncTemplate;; 3805}; 3806 ; 3807////////////////////////////////////////////////////////////////////////////////; 3808/// Return list containing the TMethods of a class.; 3809/// If load is true, the list is populated with all the defined function; 3810/// and currently instantiated function template.; 3811 ; 3812TList *TClass::GetListOfMethods(Bool_t load /* = kTRUE */); 3813{; 3814 R__LOCKGUARD(gInterpreterMutex);; 3815 ; 3816 if (!fMethod.load()) GetMethodList();; 3817 if (load) {; 3818 if (gDebug>0) Info(""GetListOfMethods"",""Header Parsing - Asking for all the methods of class %s: this can involve parsing."",GetName());; 3819 (*fMethod).Load();; 3820 }; 3821 return fMethod;; 3822}; 3823 ; 3824////////////////////////////////////////////////////////////////////////////////; 3825/// Return the collection of functions named ""name"".; 3826 ; 3827TCollection *TClass::GetListOfMethodOverloads(const char* name) const; 3828{; 3829 return const_cast<TClass*>(this)->GetMethodList()->GetListForObject(name);; 3830}; 3831 ; 3832 ; 3833////////////////////////////////////////////////////////////////////////////////; 3834/// Returns a list of all public methods of this class and its base classes.; 3835/// Refers to a subset of the methods in GetListOfMethods() so don't do; 3836/// GetListOfAllPublicMethods()->Delete().; 3837/// Algorithm used to get the list is:; 3838/// - put all methods of the class in the list (also protected and private; 3839/// ones).; 3840/// - loop over all base classes and add only those methods",MatchSource.WIKI,doc/v632/TClass_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/TClass_8cxx_source.html
https://root.cern/doc/v632/TClass_8cxx_source.html:145627,Performance,load,load,145627,"thodOverloads(const char* name) const; 3828{; 3829 return const_cast<TClass*>(this)->GetMethodList()->GetListForObject(name);; 3830}; 3831 ; 3832 ; 3833////////////////////////////////////////////////////////////////////////////////; 3834/// Returns a list of all public methods of this class and its base classes.; 3835/// Refers to a subset of the methods in GetListOfMethods() so don't do; 3836/// GetListOfAllPublicMethods()->Delete().; 3837/// Algorithm used to get the list is:; 3838/// - put all methods of the class in the list (also protected and private; 3839/// ones).; 3840/// - loop over all base classes and add only those methods not already in the; 3841/// list (also protected and private ones).; 3842/// - once finished, loop over resulting list and remove all private and; 3843/// protected methods.; 3844 ; 3845const TList *TClass::GetListOfAllPublicMethods(Bool_t load /* = kTRUE */); 3846{; 3847 R__LOCKGUARD(gInterpreterMutex);; 3848 ; 3849 if (!fAllPubMethod) fAllPubMethod = new TViewPubFunctions(this);; 3850 if (load) {; 3851 if (gDebug>0) Info(""GetListOfAllPublicMethods"",""Header Parsing - Asking for all the methods of class %s: this can involve parsing."",GetName());; 3852 fAllPubMethod->Load();; 3853 }; 3854 return fAllPubMethod;; 3855}; 3856 ; 3857////////////////////////////////////////////////////////////////////////////////; 3858/// Returns a list of all public data members of this class and its base; 3859/// classes. Refers to a subset of the data members in GetListOfDatamembers(); 3860/// so don't do GetListOfAllPublicDataMembers()->Delete().; 3861 ; 3862TList *TClass::GetListOfAllPublicDataMembers(Bool_t load /* = kTRUE */); 3863{; 3864 R__LOCKGUARD(gInterpreterMutex);; 3865 ; 3866 if (!fAllPubData) fAllPubData = new TViewPubDataMembers(this);; 3867 if (load) fAllPubData->Load();; 3868 return fAllPubData;; 3869}; 3870 ; 3871////////////////////////////////////////////////////////////////////////////////; 3872/// Returns list of methods accessible b",MatchSource.WIKI,doc/v632/TClass_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/TClass_8cxx_source.html
https://root.cern/doc/v632/TClass_8cxx_source.html:145781,Performance,load,load,145781,"thodOverloads(const char* name) const; 3828{; 3829 return const_cast<TClass*>(this)->GetMethodList()->GetListForObject(name);; 3830}; 3831 ; 3832 ; 3833////////////////////////////////////////////////////////////////////////////////; 3834/// Returns a list of all public methods of this class and its base classes.; 3835/// Refers to a subset of the methods in GetListOfMethods() so don't do; 3836/// GetListOfAllPublicMethods()->Delete().; 3837/// Algorithm used to get the list is:; 3838/// - put all methods of the class in the list (also protected and private; 3839/// ones).; 3840/// - loop over all base classes and add only those methods not already in the; 3841/// list (also protected and private ones).; 3842/// - once finished, loop over resulting list and remove all private and; 3843/// protected methods.; 3844 ; 3845const TList *TClass::GetListOfAllPublicMethods(Bool_t load /* = kTRUE */); 3846{; 3847 R__LOCKGUARD(gInterpreterMutex);; 3848 ; 3849 if (!fAllPubMethod) fAllPubMethod = new TViewPubFunctions(this);; 3850 if (load) {; 3851 if (gDebug>0) Info(""GetListOfAllPublicMethods"",""Header Parsing - Asking for all the methods of class %s: this can involve parsing."",GetName());; 3852 fAllPubMethod->Load();; 3853 }; 3854 return fAllPubMethod;; 3855}; 3856 ; 3857////////////////////////////////////////////////////////////////////////////////; 3858/// Returns a list of all public data members of this class and its base; 3859/// classes. Refers to a subset of the data members in GetListOfDatamembers(); 3860/// so don't do GetListOfAllPublicDataMembers()->Delete().; 3861 ; 3862TList *TClass::GetListOfAllPublicDataMembers(Bool_t load /* = kTRUE */); 3863{; 3864 R__LOCKGUARD(gInterpreterMutex);; 3865 ; 3866 if (!fAllPubData) fAllPubData = new TViewPubDataMembers(this);; 3867 if (load) fAllPubData->Load();; 3868 return fAllPubData;; 3869}; 3870 ; 3871////////////////////////////////////////////////////////////////////////////////; 3872/// Returns list of methods accessible b",MatchSource.WIKI,doc/v632/TClass_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/TClass_8cxx_source.html
https://root.cern/doc/v632/TClass_8cxx_source.html:146393,Performance,load,load,146393,"rotected methods.; 3844 ; 3845const TList *TClass::GetListOfAllPublicMethods(Bool_t load /* = kTRUE */); 3846{; 3847 R__LOCKGUARD(gInterpreterMutex);; 3848 ; 3849 if (!fAllPubMethod) fAllPubMethod = new TViewPubFunctions(this);; 3850 if (load) {; 3851 if (gDebug>0) Info(""GetListOfAllPublicMethods"",""Header Parsing - Asking for all the methods of class %s: this can involve parsing."",GetName());; 3852 fAllPubMethod->Load();; 3853 }; 3854 return fAllPubMethod;; 3855}; 3856 ; 3857////////////////////////////////////////////////////////////////////////////////; 3858/// Returns a list of all public data members of this class and its base; 3859/// classes. Refers to a subset of the data members in GetListOfDatamembers(); 3860/// so don't do GetListOfAllPublicDataMembers()->Delete().; 3861 ; 3862TList *TClass::GetListOfAllPublicDataMembers(Bool_t load /* = kTRUE */); 3863{; 3864 R__LOCKGUARD(gInterpreterMutex);; 3865 ; 3866 if (!fAllPubData) fAllPubData = new TViewPubDataMembers(this);; 3867 if (load) fAllPubData->Load();; 3868 return fAllPubData;; 3869}; 3870 ; 3871////////////////////////////////////////////////////////////////////////////////; 3872/// Returns list of methods accessible by context menu.; 3873 ; 3874void TClass::GetMenuItems(TList *list); 3875{; 3876 if (!HasInterpreterInfo()) return;; 3877 ; 3878 // get the base class; 3879 TIter nextBase(GetListOfBases(), kIterBackward);; 3880 TBaseClass *baseClass;; 3881 while ((baseClass = (TBaseClass *) nextBase())) {; 3882 TClass *base = baseClass->GetClassPointer();; 3883 if (base) base->GetMenuItems(list);; 3884 }; 3885 ; 3886 // remove methods redefined in this class with no menu; 3887 TMethod *method, *m;; 3888 TIter next(GetListOfMethods(), kIterBackward);; 3889 while ((method = (TMethod*)next())) {; 3890 m = (TMethod*)list->FindObject(method->GetName());; 3891 if (method->IsMenuItem() != kMenuNoMenu) {; 3892 if (!m); 3893 list->AddFirst(method);; 3894 } else {; 3895 if (m && m->GetNargs() == method->GetNargs());",MatchSource.WIKI,doc/v632/TClass_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/TClass_8cxx_source.html
https://root.cern/doc/v632/TClass_8cxx_source.html:146545,Performance,load,load,146545,"rotected methods.; 3844 ; 3845const TList *TClass::GetListOfAllPublicMethods(Bool_t load /* = kTRUE */); 3846{; 3847 R__LOCKGUARD(gInterpreterMutex);; 3848 ; 3849 if (!fAllPubMethod) fAllPubMethod = new TViewPubFunctions(this);; 3850 if (load) {; 3851 if (gDebug>0) Info(""GetListOfAllPublicMethods"",""Header Parsing - Asking for all the methods of class %s: this can involve parsing."",GetName());; 3852 fAllPubMethod->Load();; 3853 }; 3854 return fAllPubMethod;; 3855}; 3856 ; 3857////////////////////////////////////////////////////////////////////////////////; 3858/// Returns a list of all public data members of this class and its base; 3859/// classes. Refers to a subset of the data members in GetListOfDatamembers(); 3860/// so don't do GetListOfAllPublicDataMembers()->Delete().; 3861 ; 3862TList *TClass::GetListOfAllPublicDataMembers(Bool_t load /* = kTRUE */); 3863{; 3864 R__LOCKGUARD(gInterpreterMutex);; 3865 ; 3866 if (!fAllPubData) fAllPubData = new TViewPubDataMembers(this);; 3867 if (load) fAllPubData->Load();; 3868 return fAllPubData;; 3869}; 3870 ; 3871////////////////////////////////////////////////////////////////////////////////; 3872/// Returns list of methods accessible by context menu.; 3873 ; 3874void TClass::GetMenuItems(TList *list); 3875{; 3876 if (!HasInterpreterInfo()) return;; 3877 ; 3878 // get the base class; 3879 TIter nextBase(GetListOfBases(), kIterBackward);; 3880 TBaseClass *baseClass;; 3881 while ((baseClass = (TBaseClass *) nextBase())) {; 3882 TClass *base = baseClass->GetClassPointer();; 3883 if (base) base->GetMenuItems(list);; 3884 }; 3885 ; 3886 // remove methods redefined in this class with no menu; 3887 TMethod *method, *m;; 3888 TIter next(GetListOfMethods(), kIterBackward);; 3889 while ((method = (TMethod*)next())) {; 3890 m = (TMethod*)list->FindObject(method->GetName());; 3891 if (method->IsMenuItem() != kMenuNoMenu) {; 3892 if (!m); 3893 list->AddFirst(method);; 3894 } else {; 3895 if (m && m->GetNargs() == method->GetNargs());",MatchSource.WIKI,doc/v632/TClass_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/TClass_8cxx_source.html
https://root.cern/doc/v632/TClass_8cxx_source.html:147855,Performance,load,loading,147855,"st); 3875{; 3876 if (!HasInterpreterInfo()) return;; 3877 ; 3878 // get the base class; 3879 TIter nextBase(GetListOfBases(), kIterBackward);; 3880 TBaseClass *baseClass;; 3881 while ((baseClass = (TBaseClass *) nextBase())) {; 3882 TClass *base = baseClass->GetClassPointer();; 3883 if (base) base->GetMenuItems(list);; 3884 }; 3885 ; 3886 // remove methods redefined in this class with no menu; 3887 TMethod *method, *m;; 3888 TIter next(GetListOfMethods(), kIterBackward);; 3889 while ((method = (TMethod*)next())) {; 3890 m = (TMethod*)list->FindObject(method->GetName());; 3891 if (method->IsMenuItem() != kMenuNoMenu) {; 3892 if (!m); 3893 list->AddFirst(method);; 3894 } else {; 3895 if (m && m->GetNargs() == method->GetNargs()); 3896 list->Remove(m);; 3897 }; 3898 }; 3899}; 3900 ; 3901////////////////////////////////////////////////////////////////////////////////; 3902/// Check whether a class has a dictionary or not.; 3903/// This is equivalent to ask if a class is coming from a bootstrapping; 3904/// procedure initiated during the loading of a library.; 3905 ; 3906Bool_t TClass::HasDictionary() const; 3907{; 3908 return IsLoaded();; 3909}; 3910 ; 3911////////////////////////////////////////////////////////////////////////////////; 3912/// Check whether a class has a dictionary or ROOT can load one.; 3913/// This is equivalent to ask HasDictionary() or whether a library is known; 3914/// where it can be loaded from, or whether a Dictionary function is; 3915/// available because the class's dictionary library was already loaded.; 3916 ; 3917Bool_t TClass::HasDictionarySelection(const char* clname); 3918{; 3919 if (TClass* cl = (TClass*)gROOT->GetListOfClasses()->FindObject(clname)); 3920 return cl->IsLoaded();; 3921 return gClassTable->GetDict(clname) || gInterpreter->GetClassSharedLibs(clname);; 3922}; 3923 ; 3924////////////////////////////////////////////////////////////////////////////////; 3925/// Verify the base classes always.; 3926 ; 3927void TClass::GetMissi",MatchSource.WIKI,doc/v632/TClass_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/TClass_8cxx_source.html
https://root.cern/doc/v632/TClass_8cxx_source.html:148118,Performance,load,load,148118,"= (TBaseClass *) nextBase())) {; 3882 TClass *base = baseClass->GetClassPointer();; 3883 if (base) base->GetMenuItems(list);; 3884 }; 3885 ; 3886 // remove methods redefined in this class with no menu; 3887 TMethod *method, *m;; 3888 TIter next(GetListOfMethods(), kIterBackward);; 3889 while ((method = (TMethod*)next())) {; 3890 m = (TMethod*)list->FindObject(method->GetName());; 3891 if (method->IsMenuItem() != kMenuNoMenu) {; 3892 if (!m); 3893 list->AddFirst(method);; 3894 } else {; 3895 if (m && m->GetNargs() == method->GetNargs()); 3896 list->Remove(m);; 3897 }; 3898 }; 3899}; 3900 ; 3901////////////////////////////////////////////////////////////////////////////////; 3902/// Check whether a class has a dictionary or not.; 3903/// This is equivalent to ask if a class is coming from a bootstrapping; 3904/// procedure initiated during the loading of a library.; 3905 ; 3906Bool_t TClass::HasDictionary() const; 3907{; 3908 return IsLoaded();; 3909}; 3910 ; 3911////////////////////////////////////////////////////////////////////////////////; 3912/// Check whether a class has a dictionary or ROOT can load one.; 3913/// This is equivalent to ask HasDictionary() or whether a library is known; 3914/// where it can be loaded from, or whether a Dictionary function is; 3915/// available because the class's dictionary library was already loaded.; 3916 ; 3917Bool_t TClass::HasDictionarySelection(const char* clname); 3918{; 3919 if (TClass* cl = (TClass*)gROOT->GetListOfClasses()->FindObject(clname)); 3920 return cl->IsLoaded();; 3921 return gClassTable->GetDict(clname) || gInterpreter->GetClassSharedLibs(clname);; 3922}; 3923 ; 3924////////////////////////////////////////////////////////////////////////////////; 3925/// Verify the base classes always.; 3926 ; 3927void TClass::GetMissingDictionariesForBaseClasses(TCollection& result, TCollection& visited, bool recurse); 3928{; 3929 TList* lb = GetListOfBases();; 3930 if (!lb) return;; 3931 TIter nextBase(lb);; 3932 TBaseClass*",MatchSource.WIKI,doc/v632/TClass_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/TClass_8cxx_source.html
https://root.cern/doc/v632/TClass_8cxx_source.html:148234,Performance,load,loaded,148234,"xt(GetListOfMethods(), kIterBackward);; 3889 while ((method = (TMethod*)next())) {; 3890 m = (TMethod*)list->FindObject(method->GetName());; 3891 if (method->IsMenuItem() != kMenuNoMenu) {; 3892 if (!m); 3893 list->AddFirst(method);; 3894 } else {; 3895 if (m && m->GetNargs() == method->GetNargs()); 3896 list->Remove(m);; 3897 }; 3898 }; 3899}; 3900 ; 3901////////////////////////////////////////////////////////////////////////////////; 3902/// Check whether a class has a dictionary or not.; 3903/// This is equivalent to ask if a class is coming from a bootstrapping; 3904/// procedure initiated during the loading of a library.; 3905 ; 3906Bool_t TClass::HasDictionary() const; 3907{; 3908 return IsLoaded();; 3909}; 3910 ; 3911////////////////////////////////////////////////////////////////////////////////; 3912/// Check whether a class has a dictionary or ROOT can load one.; 3913/// This is equivalent to ask HasDictionary() or whether a library is known; 3914/// where it can be loaded from, or whether a Dictionary function is; 3915/// available because the class's dictionary library was already loaded.; 3916 ; 3917Bool_t TClass::HasDictionarySelection(const char* clname); 3918{; 3919 if (TClass* cl = (TClass*)gROOT->GetListOfClasses()->FindObject(clname)); 3920 return cl->IsLoaded();; 3921 return gClassTable->GetDict(clname) || gInterpreter->GetClassSharedLibs(clname);; 3922}; 3923 ; 3924////////////////////////////////////////////////////////////////////////////////; 3925/// Verify the base classes always.; 3926 ; 3927void TClass::GetMissingDictionariesForBaseClasses(TCollection& result, TCollection& visited, bool recurse); 3928{; 3929 TList* lb = GetListOfBases();; 3930 if (!lb) return;; 3931 TIter nextBase(lb);; 3932 TBaseClass* base = nullptr;; 3933 while ((base = (TBaseClass*)nextBase())) {; 3934 TClass* baseCl = base->GetClassPointer();; 3935 if (baseCl) {; 3936 baseCl->GetMissingDictionariesWithRecursionCheck(result, visited, recurse);; 3937 }; 3938 }; 3939}; 39",MatchSource.WIKI,doc/v632/TClass_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/TClass_8cxx_source.html
https://root.cern/doc/v632/TClass_8cxx_source.html:148353,Performance,load,loaded,148353,"xt(GetListOfMethods(), kIterBackward);; 3889 while ((method = (TMethod*)next())) {; 3890 m = (TMethod*)list->FindObject(method->GetName());; 3891 if (method->IsMenuItem() != kMenuNoMenu) {; 3892 if (!m); 3893 list->AddFirst(method);; 3894 } else {; 3895 if (m && m->GetNargs() == method->GetNargs()); 3896 list->Remove(m);; 3897 }; 3898 }; 3899}; 3900 ; 3901////////////////////////////////////////////////////////////////////////////////; 3902/// Check whether a class has a dictionary or not.; 3903/// This is equivalent to ask if a class is coming from a bootstrapping; 3904/// procedure initiated during the loading of a library.; 3905 ; 3906Bool_t TClass::HasDictionary() const; 3907{; 3908 return IsLoaded();; 3909}; 3910 ; 3911////////////////////////////////////////////////////////////////////////////////; 3912/// Check whether a class has a dictionary or ROOT can load one.; 3913/// This is equivalent to ask HasDictionary() or whether a library is known; 3914/// where it can be loaded from, or whether a Dictionary function is; 3915/// available because the class's dictionary library was already loaded.; 3916 ; 3917Bool_t TClass::HasDictionarySelection(const char* clname); 3918{; 3919 if (TClass* cl = (TClass*)gROOT->GetListOfClasses()->FindObject(clname)); 3920 return cl->IsLoaded();; 3921 return gClassTable->GetDict(clname) || gInterpreter->GetClassSharedLibs(clname);; 3922}; 3923 ; 3924////////////////////////////////////////////////////////////////////////////////; 3925/// Verify the base classes always.; 3926 ; 3927void TClass::GetMissingDictionariesForBaseClasses(TCollection& result, TCollection& visited, bool recurse); 3928{; 3929 TList* lb = GetListOfBases();; 3930 if (!lb) return;; 3931 TIter nextBase(lb);; 3932 TBaseClass* base = nullptr;; 3933 while ((base = (TBaseClass*)nextBase())) {; 3934 TClass* baseCl = base->GetClassPointer();; 3935 if (baseCl) {; 3936 baseCl->GetMissingDictionariesWithRecursionCheck(result, visited, recurse);; 3937 }; 3938 }; 3939}; 39",MatchSource.WIKI,doc/v632/TClass_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/TClass_8cxx_source.html
https://root.cern/doc/v632/TClass_8cxx_source.html:157293,Performance,load,loading,157293,"nt kind of elements the check would be required.; 4119 TClass* t = nullptr;; 4120 if ((t = GetCollectionProxy()->GetValueClass())) {; 4121 if (!t->HasDictionary()) {; 4122 t->GetMissingDictionariesWithRecursionCheck(result, visited, recurse);; 4123 }; 4124 }; 4125 } else {; 4126 GetMissingDictionariesForMembers(result, visited, recurse);; 4127 GetMissingDictionariesForBaseClasses(result, visited, recurse);; 4128 }; 4129 }; 4130}; 4131 ; 4132////////////////////////////////////////////////////////////////////////////////; 4133/// Return kTRUE if the class has elements.; 4134 ; 4135Bool_t TClass::IsFolder(void *obj) const; 4136{; 4137 return Browse(obj,(TBrowser*)nullptr);; 4138}; 4139 ; 4140//______________________________________________________________________________; 4141//______________________________________________________________________________; 4142void TClass::ReplaceWith(TClass *newcl) const; 4143{; 4144 // Inform the other objects to replace this object by the new TClass (newcl); 4145 ; 4146 R__LOCKGUARD(gInterpreterMutex);; 4147 //we must update the class pointers pointing to 'this' in all TStreamerElements; 4148 TIter nextClass(gROOT->GetListOfClasses());; 4149 TClass *acl;; 4150 TVirtualStreamerInfo *info;; 4151 ; 4152 // Since we are in the process of replacing a TClass by a TClass; 4153 // coming from a dictionary, there is no point in loading any; 4154 // libraries during this search.; 4155 TInterpreter::SuspendAutoLoadingRAII autoloadOff(gInterpreter);; 4156 while ((acl = (TClass*)nextClass())) {; 4157 if (acl == newcl) continue;; 4158 ; 4159 TIter nextInfo(acl->GetStreamerInfos());; 4160 while ((info = (TVirtualStreamerInfo*)nextInfo())) {; 4161 ; 4162 info->Update(this, newcl);; 4163 }; 4164 }; 4165 ; 4166 gInterpreter->UnRegisterTClassUpdate(this);; 4167}; 4168 ; 4169////////////////////////////////////////////////////////////////////////////////; 4170/// Make sure that the current ClassInfo is up to date.; 4171 ; 4172void TClass::ResetClassIn",MatchSource.WIKI,doc/v632/TClass_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/TClass_8cxx_source.html
https://root.cern/doc/v632/TClass_8cxx_source.html:159181,Performance,load,loaded,159181,"; 4179 ; 4180void TClass::ResetClassInfo(); 4181{; 4182 R__LOCKGUARD(gInterpreterMutex);; 4183 ; 4184 InsertTClassInRegistryRAII insertRAII(fState,fName,fNoInfoOrEmuOrFwdDeclNameRegistry);; 4185 ; 4186 if (fClassInfo) {; 4187 TClass::RemoveClassDeclId(gInterpreter->GetDeclId(fClassInfo));; 4188 gInterpreter->ClassInfo_Delete(fClassInfo);; 4189 fClassInfo = nullptr;; 4190 }; 4191 // We can not check at this point whether after the unload there will; 4192 // still be interpreter information about this class (as v5 was doing),; 4193 // instead this function must only be called if the definition is (about); 4194 // to be unloaded.; 4195 ; 4196 ResetCaches();; 4197 ; 4198 // We got here because the definition Decl is about to be unloaded.; 4199 if (fState != TClass::kHasTClassInit) {; 4200 if (fStreamerInfo->GetEntries() != 0) {; 4201 fState = TClass::kEmulated;; 4202 } else {; 4203 fState = TClass::kForwardDeclared;; 4204 }; 4205 } else {; 4206 // if the ClassInfo was loaded for a class with a TClass Init and it; 4207 // gets unloaded, should we guess it can be reloaded?; 4208 fCanLoadClassInfo = kTRUE;; 4209 }; 4210}; 4211 ; 4212////////////////////////////////////////////////////////////////////////////////; 4213/// To clean out all caches.; 4214 ; 4215void TClass::ResetCaches(); 4216{; 4217 R__ASSERT(!TestBit(kLoading) && ""Resetting the caches does not make sense during loading!"" );; 4218 ; 4219 // Not owning lists, don't call Delete(), but unload; 4220 if (fData.load()); 4221 (*fData).Unload();; 4222 if (fUsingData.load()); 4223 (*fUsingData).Unload();; 4224 if (fEnums.load()); 4225 (*fEnums).Unload();; 4226 if (fMethod.load()); 4227 (*fMethod).Unload();; 4228 ; 4229 delete fAllPubData; fAllPubData = nullptr;; 4230 ; 4231 if (fBase.load()); 4232 (*fBase).Delete();; 4233 delete fBase.load(); fBase = nullptr;; 4234 ; 4235 if (fRealData); 4236 fRealData->Delete();; 4237 delete fRealData; fRealData=nullptr;; 4238}; 4239 ; 4240/////////////////////////////////////////////",MatchSource.WIKI,doc/v632/TClass_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/TClass_8cxx_source.html
https://root.cern/doc/v632/TClass_8cxx_source.html:159453,Performance,cache,caches,159453,"; 4179 ; 4180void TClass::ResetClassInfo(); 4181{; 4182 R__LOCKGUARD(gInterpreterMutex);; 4183 ; 4184 InsertTClassInRegistryRAII insertRAII(fState,fName,fNoInfoOrEmuOrFwdDeclNameRegistry);; 4185 ; 4186 if (fClassInfo) {; 4187 TClass::RemoveClassDeclId(gInterpreter->GetDeclId(fClassInfo));; 4188 gInterpreter->ClassInfo_Delete(fClassInfo);; 4189 fClassInfo = nullptr;; 4190 }; 4191 // We can not check at this point whether after the unload there will; 4192 // still be interpreter information about this class (as v5 was doing),; 4193 // instead this function must only be called if the definition is (about); 4194 // to be unloaded.; 4195 ; 4196 ResetCaches();; 4197 ; 4198 // We got here because the definition Decl is about to be unloaded.; 4199 if (fState != TClass::kHasTClassInit) {; 4200 if (fStreamerInfo->GetEntries() != 0) {; 4201 fState = TClass::kEmulated;; 4202 } else {; 4203 fState = TClass::kForwardDeclared;; 4204 }; 4205 } else {; 4206 // if the ClassInfo was loaded for a class with a TClass Init and it; 4207 // gets unloaded, should we guess it can be reloaded?; 4208 fCanLoadClassInfo = kTRUE;; 4209 }; 4210}; 4211 ; 4212////////////////////////////////////////////////////////////////////////////////; 4213/// To clean out all caches.; 4214 ; 4215void TClass::ResetCaches(); 4216{; 4217 R__ASSERT(!TestBit(kLoading) && ""Resetting the caches does not make sense during loading!"" );; 4218 ; 4219 // Not owning lists, don't call Delete(), but unload; 4220 if (fData.load()); 4221 (*fData).Unload();; 4222 if (fUsingData.load()); 4223 (*fUsingData).Unload();; 4224 if (fEnums.load()); 4225 (*fEnums).Unload();; 4226 if (fMethod.load()); 4227 (*fMethod).Unload();; 4228 ; 4229 delete fAllPubData; fAllPubData = nullptr;; 4230 ; 4231 if (fBase.load()); 4232 (*fBase).Delete();; 4233 delete fBase.load(); fBase = nullptr;; 4234 ; 4235 if (fRealData); 4236 fRealData->Delete();; 4237 delete fRealData; fRealData=nullptr;; 4238}; 4239 ; 4240/////////////////////////////////////////////",MatchSource.WIKI,doc/v632/TClass_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/TClass_8cxx_source.html
https://root.cern/doc/v632/TClass_8cxx_source.html:159560,Performance,cache,caches,159560,"0 }; 4191 // We can not check at this point whether after the unload there will; 4192 // still be interpreter information about this class (as v5 was doing),; 4193 // instead this function must only be called if the definition is (about); 4194 // to be unloaded.; 4195 ; 4196 ResetCaches();; 4197 ; 4198 // We got here because the definition Decl is about to be unloaded.; 4199 if (fState != TClass::kHasTClassInit) {; 4200 if (fStreamerInfo->GetEntries() != 0) {; 4201 fState = TClass::kEmulated;; 4202 } else {; 4203 fState = TClass::kForwardDeclared;; 4204 }; 4205 } else {; 4206 // if the ClassInfo was loaded for a class with a TClass Init and it; 4207 // gets unloaded, should we guess it can be reloaded?; 4208 fCanLoadClassInfo = kTRUE;; 4209 }; 4210}; 4211 ; 4212////////////////////////////////////////////////////////////////////////////////; 4213/// To clean out all caches.; 4214 ; 4215void TClass::ResetCaches(); 4216{; 4217 R__ASSERT(!TestBit(kLoading) && ""Resetting the caches does not make sense during loading!"" );; 4218 ; 4219 // Not owning lists, don't call Delete(), but unload; 4220 if (fData.load()); 4221 (*fData).Unload();; 4222 if (fUsingData.load()); 4223 (*fUsingData).Unload();; 4224 if (fEnums.load()); 4225 (*fEnums).Unload();; 4226 if (fMethod.load()); 4227 (*fMethod).Unload();; 4228 ; 4229 delete fAllPubData; fAllPubData = nullptr;; 4230 ; 4231 if (fBase.load()); 4232 (*fBase).Delete();; 4233 delete fBase.load(); fBase = nullptr;; 4234 ; 4235 if (fRealData); 4236 fRealData->Delete();; 4237 delete fRealData; fRealData=nullptr;; 4238}; 4239 ; 4240////////////////////////////////////////////////////////////////////////////////; 4241/// Resets the menu list to it's standard value.; 4242 ; 4243void TClass::ResetMenuList(); 4244{; 4245 if (fClassMenuList); 4246 fClassMenuList->Delete();; 4247 else; 4248 fClassMenuList = new TList();; 4249 fClassMenuList->Add(new TClassMenuItem(TClassMenuItem::kPopupStandardList, this));; 4250}; 4251 ; 4252/////////////////////",MatchSource.WIKI,doc/v632/TClass_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/TClass_8cxx_source.html
https://root.cern/doc/v632/TClass_8cxx_source.html:159594,Performance,load,loading,159594,"0 }; 4191 // We can not check at this point whether after the unload there will; 4192 // still be interpreter information about this class (as v5 was doing),; 4193 // instead this function must only be called if the definition is (about); 4194 // to be unloaded.; 4195 ; 4196 ResetCaches();; 4197 ; 4198 // We got here because the definition Decl is about to be unloaded.; 4199 if (fState != TClass::kHasTClassInit) {; 4200 if (fStreamerInfo->GetEntries() != 0) {; 4201 fState = TClass::kEmulated;; 4202 } else {; 4203 fState = TClass::kForwardDeclared;; 4204 }; 4205 } else {; 4206 // if the ClassInfo was loaded for a class with a TClass Init and it; 4207 // gets unloaded, should we guess it can be reloaded?; 4208 fCanLoadClassInfo = kTRUE;; 4209 }; 4210}; 4211 ; 4212////////////////////////////////////////////////////////////////////////////////; 4213/// To clean out all caches.; 4214 ; 4215void TClass::ResetCaches(); 4216{; 4217 R__ASSERT(!TestBit(kLoading) && ""Resetting the caches does not make sense during loading!"" );; 4218 ; 4219 // Not owning lists, don't call Delete(), but unload; 4220 if (fData.load()); 4221 (*fData).Unload();; 4222 if (fUsingData.load()); 4223 (*fUsingData).Unload();; 4224 if (fEnums.load()); 4225 (*fEnums).Unload();; 4226 if (fMethod.load()); 4227 (*fMethod).Unload();; 4228 ; 4229 delete fAllPubData; fAllPubData = nullptr;; 4230 ; 4231 if (fBase.load()); 4232 (*fBase).Delete();; 4233 delete fBase.load(); fBase = nullptr;; 4234 ; 4235 if (fRealData); 4236 fRealData->Delete();; 4237 delete fRealData; fRealData=nullptr;; 4238}; 4239 ; 4240////////////////////////////////////////////////////////////////////////////////; 4241/// Resets the menu list to it's standard value.; 4242 ; 4243void TClass::ResetMenuList(); 4244{; 4245 if (fClassMenuList); 4246 fClassMenuList->Delete();; 4247 else; 4248 fClassMenuList = new TList();; 4249 fClassMenuList->Add(new TClassMenuItem(TClassMenuItem::kPopupStandardList, this));; 4250}; 4251 ; 4252/////////////////////",MatchSource.WIKI,doc/v632/TClass_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/TClass_8cxx_source.html
https://root.cern/doc/v632/TClass_8cxx_source.html:159689,Performance,load,load,159689,"t this class (as v5 was doing),; 4193 // instead this function must only be called if the definition is (about); 4194 // to be unloaded.; 4195 ; 4196 ResetCaches();; 4197 ; 4198 // We got here because the definition Decl is about to be unloaded.; 4199 if (fState != TClass::kHasTClassInit) {; 4200 if (fStreamerInfo->GetEntries() != 0) {; 4201 fState = TClass::kEmulated;; 4202 } else {; 4203 fState = TClass::kForwardDeclared;; 4204 }; 4205 } else {; 4206 // if the ClassInfo was loaded for a class with a TClass Init and it; 4207 // gets unloaded, should we guess it can be reloaded?; 4208 fCanLoadClassInfo = kTRUE;; 4209 }; 4210}; 4211 ; 4212////////////////////////////////////////////////////////////////////////////////; 4213/// To clean out all caches.; 4214 ; 4215void TClass::ResetCaches(); 4216{; 4217 R__ASSERT(!TestBit(kLoading) && ""Resetting the caches does not make sense during loading!"" );; 4218 ; 4219 // Not owning lists, don't call Delete(), but unload; 4220 if (fData.load()); 4221 (*fData).Unload();; 4222 if (fUsingData.load()); 4223 (*fUsingData).Unload();; 4224 if (fEnums.load()); 4225 (*fEnums).Unload();; 4226 if (fMethod.load()); 4227 (*fMethod).Unload();; 4228 ; 4229 delete fAllPubData; fAllPubData = nullptr;; 4230 ; 4231 if (fBase.load()); 4232 (*fBase).Delete();; 4233 delete fBase.load(); fBase = nullptr;; 4234 ; 4235 if (fRealData); 4236 fRealData->Delete();; 4237 delete fRealData; fRealData=nullptr;; 4238}; 4239 ; 4240////////////////////////////////////////////////////////////////////////////////; 4241/// Resets the menu list to it's standard value.; 4242 ; 4243void TClass::ResetMenuList(); 4244{; 4245 if (fClassMenuList); 4246 fClassMenuList->Delete();; 4247 else; 4248 fClassMenuList = new TList();; 4249 fClassMenuList->Add(new TClassMenuItem(TClassMenuItem::kPopupStandardList, this));; 4250}; 4251 ; 4252////////////////////////////////////////////////////////////////////////////////; 4253/// The ls function lists the contents of a class on stdout. ",MatchSource.WIKI,doc/v632/TClass_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/TClass_8cxx_source.html
https://root.cern/doc/v632/TClass_8cxx_source.html:159743,Performance,load,load,159743,"ction must only be called if the definition is (about); 4194 // to be unloaded.; 4195 ; 4196 ResetCaches();; 4197 ; 4198 // We got here because the definition Decl is about to be unloaded.; 4199 if (fState != TClass::kHasTClassInit) {; 4200 if (fStreamerInfo->GetEntries() != 0) {; 4201 fState = TClass::kEmulated;; 4202 } else {; 4203 fState = TClass::kForwardDeclared;; 4204 }; 4205 } else {; 4206 // if the ClassInfo was loaded for a class with a TClass Init and it; 4207 // gets unloaded, should we guess it can be reloaded?; 4208 fCanLoadClassInfo = kTRUE;; 4209 }; 4210}; 4211 ; 4212////////////////////////////////////////////////////////////////////////////////; 4213/// To clean out all caches.; 4214 ; 4215void TClass::ResetCaches(); 4216{; 4217 R__ASSERT(!TestBit(kLoading) && ""Resetting the caches does not make sense during loading!"" );; 4218 ; 4219 // Not owning lists, don't call Delete(), but unload; 4220 if (fData.load()); 4221 (*fData).Unload();; 4222 if (fUsingData.load()); 4223 (*fUsingData).Unload();; 4224 if (fEnums.load()); 4225 (*fEnums).Unload();; 4226 if (fMethod.load()); 4227 (*fMethod).Unload();; 4228 ; 4229 delete fAllPubData; fAllPubData = nullptr;; 4230 ; 4231 if (fBase.load()); 4232 (*fBase).Delete();; 4233 delete fBase.load(); fBase = nullptr;; 4234 ; 4235 if (fRealData); 4236 fRealData->Delete();; 4237 delete fRealData; fRealData=nullptr;; 4238}; 4239 ; 4240////////////////////////////////////////////////////////////////////////////////; 4241/// Resets the menu list to it's standard value.; 4242 ; 4243void TClass::ResetMenuList(); 4244{; 4245 if (fClassMenuList); 4246 fClassMenuList->Delete();; 4247 else; 4248 fClassMenuList = new TList();; 4249 fClassMenuList->Add(new TClassMenuItem(TClassMenuItem::kPopupStandardList, this));; 4250}; 4251 ; 4252////////////////////////////////////////////////////////////////////////////////; 4253/// The ls function lists the contents of a class on stdout. Ls output; 4254/// is typically much less verbose then D",MatchSource.WIKI,doc/v632/TClass_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/TClass_8cxx_source.html
https://root.cern/doc/v632/TClass_8cxx_source.html:159798,Performance,load,load,159798,"); 4194 // to be unloaded.; 4195 ; 4196 ResetCaches();; 4197 ; 4198 // We got here because the definition Decl is about to be unloaded.; 4199 if (fState != TClass::kHasTClassInit) {; 4200 if (fStreamerInfo->GetEntries() != 0) {; 4201 fState = TClass::kEmulated;; 4202 } else {; 4203 fState = TClass::kForwardDeclared;; 4204 }; 4205 } else {; 4206 // if the ClassInfo was loaded for a class with a TClass Init and it; 4207 // gets unloaded, should we guess it can be reloaded?; 4208 fCanLoadClassInfo = kTRUE;; 4209 }; 4210}; 4211 ; 4212////////////////////////////////////////////////////////////////////////////////; 4213/// To clean out all caches.; 4214 ; 4215void TClass::ResetCaches(); 4216{; 4217 R__ASSERT(!TestBit(kLoading) && ""Resetting the caches does not make sense during loading!"" );; 4218 ; 4219 // Not owning lists, don't call Delete(), but unload; 4220 if (fData.load()); 4221 (*fData).Unload();; 4222 if (fUsingData.load()); 4223 (*fUsingData).Unload();; 4224 if (fEnums.load()); 4225 (*fEnums).Unload();; 4226 if (fMethod.load()); 4227 (*fMethod).Unload();; 4228 ; 4229 delete fAllPubData; fAllPubData = nullptr;; 4230 ; 4231 if (fBase.load()); 4232 (*fBase).Delete();; 4233 delete fBase.load(); fBase = nullptr;; 4234 ; 4235 if (fRealData); 4236 fRealData->Delete();; 4237 delete fRealData; fRealData=nullptr;; 4238}; 4239 ; 4240////////////////////////////////////////////////////////////////////////////////; 4241/// Resets the menu list to it's standard value.; 4242 ; 4243void TClass::ResetMenuList(); 4244{; 4245 if (fClassMenuList); 4246 fClassMenuList->Delete();; 4247 else; 4248 fClassMenuList = new TList();; 4249 fClassMenuList->Add(new TClassMenuItem(TClassMenuItem::kPopupStandardList, this));; 4250}; 4251 ; 4252////////////////////////////////////////////////////////////////////////////////; 4253/// The ls function lists the contents of a class on stdout. Ls output; 4254/// is typically much less verbose then Dump().; 4255/// If options contains 'streamerinfo', r",MatchSource.WIKI,doc/v632/TClass_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/TClass_8cxx_source.html
https://root.cern/doc/v632/TClass_8cxx_source.html:159850,Performance,load,load,159850,");; 4197 ; 4198 // We got here because the definition Decl is about to be unloaded.; 4199 if (fState != TClass::kHasTClassInit) {; 4200 if (fStreamerInfo->GetEntries() != 0) {; 4201 fState = TClass::kEmulated;; 4202 } else {; 4203 fState = TClass::kForwardDeclared;; 4204 }; 4205 } else {; 4206 // if the ClassInfo was loaded for a class with a TClass Init and it; 4207 // gets unloaded, should we guess it can be reloaded?; 4208 fCanLoadClassInfo = kTRUE;; 4209 }; 4210}; 4211 ; 4212////////////////////////////////////////////////////////////////////////////////; 4213/// To clean out all caches.; 4214 ; 4215void TClass::ResetCaches(); 4216{; 4217 R__ASSERT(!TestBit(kLoading) && ""Resetting the caches does not make sense during loading!"" );; 4218 ; 4219 // Not owning lists, don't call Delete(), but unload; 4220 if (fData.load()); 4221 (*fData).Unload();; 4222 if (fUsingData.load()); 4223 (*fUsingData).Unload();; 4224 if (fEnums.load()); 4225 (*fEnums).Unload();; 4226 if (fMethod.load()); 4227 (*fMethod).Unload();; 4228 ; 4229 delete fAllPubData; fAllPubData = nullptr;; 4230 ; 4231 if (fBase.load()); 4232 (*fBase).Delete();; 4233 delete fBase.load(); fBase = nullptr;; 4234 ; 4235 if (fRealData); 4236 fRealData->Delete();; 4237 delete fRealData; fRealData=nullptr;; 4238}; 4239 ; 4240////////////////////////////////////////////////////////////////////////////////; 4241/// Resets the menu list to it's standard value.; 4242 ; 4243void TClass::ResetMenuList(); 4244{; 4245 if (fClassMenuList); 4246 fClassMenuList->Delete();; 4247 else; 4248 fClassMenuList = new TList();; 4249 fClassMenuList->Add(new TClassMenuItem(TClassMenuItem::kPopupStandardList, this));; 4250}; 4251 ; 4252////////////////////////////////////////////////////////////////////////////////; 4253/// The ls function lists the contents of a class on stdout. Ls output; 4254/// is typically much less verbose then Dump().; 4255/// If options contains 'streamerinfo', run ls on the list of streamerInfos; 4256/// and the l",MatchSource.WIKI,doc/v632/TClass_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/TClass_8cxx_source.html
https://root.cern/doc/v632/TClass_8cxx_source.html:159964,Performance,load,load,159964,"HasTClassInit) {; 4200 if (fStreamerInfo->GetEntries() != 0) {; 4201 fState = TClass::kEmulated;; 4202 } else {; 4203 fState = TClass::kForwardDeclared;; 4204 }; 4205 } else {; 4206 // if the ClassInfo was loaded for a class with a TClass Init and it; 4207 // gets unloaded, should we guess it can be reloaded?; 4208 fCanLoadClassInfo = kTRUE;; 4209 }; 4210}; 4211 ; 4212////////////////////////////////////////////////////////////////////////////////; 4213/// To clean out all caches.; 4214 ; 4215void TClass::ResetCaches(); 4216{; 4217 R__ASSERT(!TestBit(kLoading) && ""Resetting the caches does not make sense during loading!"" );; 4218 ; 4219 // Not owning lists, don't call Delete(), but unload; 4220 if (fData.load()); 4221 (*fData).Unload();; 4222 if (fUsingData.load()); 4223 (*fUsingData).Unload();; 4224 if (fEnums.load()); 4225 (*fEnums).Unload();; 4226 if (fMethod.load()); 4227 (*fMethod).Unload();; 4228 ; 4229 delete fAllPubData; fAllPubData = nullptr;; 4230 ; 4231 if (fBase.load()); 4232 (*fBase).Delete();; 4233 delete fBase.load(); fBase = nullptr;; 4234 ; 4235 if (fRealData); 4236 fRealData->Delete();; 4237 delete fRealData; fRealData=nullptr;; 4238}; 4239 ; 4240////////////////////////////////////////////////////////////////////////////////; 4241/// Resets the menu list to it's standard value.; 4242 ; 4243void TClass::ResetMenuList(); 4244{; 4245 if (fClassMenuList); 4246 fClassMenuList->Delete();; 4247 else; 4248 fClassMenuList = new TList();; 4249 fClassMenuList->Add(new TClassMenuItem(TClassMenuItem::kPopupStandardList, this));; 4250}; 4251 ; 4252////////////////////////////////////////////////////////////////////////////////; 4253/// The ls function lists the contents of a class on stdout. Ls output; 4254/// is typically much less verbose then Dump().; 4255/// If options contains 'streamerinfo', run ls on the list of streamerInfos; 4256/// and the list of conversion streamerInfos.; 4257 ; 4258void TClass::ls(Option_t *options) const; 4259{; 4260 TNamed::ls(opt",MatchSource.WIKI,doc/v632/TClass_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/TClass_8cxx_source.html
https://root.cern/doc/v632/TClass_8cxx_source.html:160016,Performance,load,load,160016,"06 // if the ClassInfo was loaded for a class with a TClass Init and it; 4207 // gets unloaded, should we guess it can be reloaded?; 4208 fCanLoadClassInfo = kTRUE;; 4209 }; 4210}; 4211 ; 4212////////////////////////////////////////////////////////////////////////////////; 4213/// To clean out all caches.; 4214 ; 4215void TClass::ResetCaches(); 4216{; 4217 R__ASSERT(!TestBit(kLoading) && ""Resetting the caches does not make sense during loading!"" );; 4218 ; 4219 // Not owning lists, don't call Delete(), but unload; 4220 if (fData.load()); 4221 (*fData).Unload();; 4222 if (fUsingData.load()); 4223 (*fUsingData).Unload();; 4224 if (fEnums.load()); 4225 (*fEnums).Unload();; 4226 if (fMethod.load()); 4227 (*fMethod).Unload();; 4228 ; 4229 delete fAllPubData; fAllPubData = nullptr;; 4230 ; 4231 if (fBase.load()); 4232 (*fBase).Delete();; 4233 delete fBase.load(); fBase = nullptr;; 4234 ; 4235 if (fRealData); 4236 fRealData->Delete();; 4237 delete fRealData; fRealData=nullptr;; 4238}; 4239 ; 4240////////////////////////////////////////////////////////////////////////////////; 4241/// Resets the menu list to it's standard value.; 4242 ; 4243void TClass::ResetMenuList(); 4244{; 4245 if (fClassMenuList); 4246 fClassMenuList->Delete();; 4247 else; 4248 fClassMenuList = new TList();; 4249 fClassMenuList->Add(new TClassMenuItem(TClassMenuItem::kPopupStandardList, this));; 4250}; 4251 ; 4252////////////////////////////////////////////////////////////////////////////////; 4253/// The ls function lists the contents of a class on stdout. Ls output; 4254/// is typically much less verbose then Dump().; 4255/// If options contains 'streamerinfo', run ls on the list of streamerInfos; 4256/// and the list of conversion streamerInfos.; 4257 ; 4258void TClass::ls(Option_t *options) const; 4259{; 4260 TNamed::ls(options);; 4261 if (options==nullptr || options[0]==0) return;; 4262 ; 4263 if (strstr(options,""streamerinfo"")!=nullptr) {; 4264 GetStreamerInfos()->ls(options);; 4265 ; 4266 if (fC",MatchSource.WIKI,doc/v632/TClass_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/TClass_8cxx_source.html
https://root.cern/doc/v632/TClass_8cxx_source.html:161176,Performance,load,load,161176,"esets the menu list to it's standard value.; 4242 ; 4243void TClass::ResetMenuList(); 4244{; 4245 if (fClassMenuList); 4246 fClassMenuList->Delete();; 4247 else; 4248 fClassMenuList = new TList();; 4249 fClassMenuList->Add(new TClassMenuItem(TClassMenuItem::kPopupStandardList, this));; 4250}; 4251 ; 4252////////////////////////////////////////////////////////////////////////////////; 4253/// The ls function lists the contents of a class on stdout. Ls output; 4254/// is typically much less verbose then Dump().; 4255/// If options contains 'streamerinfo', run ls on the list of streamerInfos; 4256/// and the list of conversion streamerInfos.; 4257 ; 4258void TClass::ls(Option_t *options) const; 4259{; 4260 TNamed::ls(options);; 4261 if (options==nullptr || options[0]==0) return;; 4262 ; 4263 if (strstr(options,""streamerinfo"")!=nullptr) {; 4264 GetStreamerInfos()->ls(options);; 4265 ; 4266 if (fConversionStreamerInfo.load()) {; 4267 std::map<std::string, TObjArray*>::iterator it;; 4268 std::map<std::string, TObjArray*>::iterator end = (*fConversionStreamerInfo).end();; 4269 for( it = (*fConversionStreamerInfo).begin(); it != end; ++it ) {; 4270 it->second->ls(options);; 4271 }; 4272 }; 4273 }; 4274}; 4275 ; 4276////////////////////////////////////////////////////////////////////////////////; 4277/// Makes a customizable version of the popup menu list, i.e. makes a list; 4278/// of TClassMenuItem objects of methods accessible by context menu.; 4279/// The standard (and different) way consists in having just one element; 4280/// in this list, corresponding to the whole standard list.; 4281/// Once the customizable version is done, one can remove or add elements.; 4282 ; 4283void TClass::MakeCustomMenuList(); 4284{; 4285 R__LOCKGUARD(gInterpreterMutex);; 4286 TClassMenuItem *menuItem;; 4287 ; 4288 // Make sure fClassMenuList is initialized and empty.; 4289 GetMenuList()->Delete();; 4290 ; 4291 TList* methodList = new TList;; 4292 GetMenuItems(methodList);; 4293 ; 4294 TMeth",MatchSource.WIKI,doc/v632/TClass_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/TClass_8cxx_source.html
https://root.cern/doc/v632/TClass_8cxx_source.html:163742,Performance,perform,perform,163742,"ass();; 4305 }; 4306 // Build the signature of the method; 4307 TString sig;; 4308 TList* margsList = method->GetListOfMethodArgs();; 4309 TIter nextarg(margsList);; 4310 while ((methodArg = (TMethodArg*)nextarg())) {; 4311 sig = sig+"",""+methodArg->GetFullTypeName();; 4312 }; 4313 if (sig.Length()!=0) sig.Remove(0,1); // remove first comma; 4314 menuItem = new TClassMenuItem(TClassMenuItem::kPopupUserFunction, this,; 4315 method->GetName(), method->GetName(),nullptr,; 4316 sig.Data(),-1,TClassMenuItem::kIsSelf);; 4317 if (method->IsMenuItem() == kMenuToggle) menuItem->SetToggle();; 4318 fClassMenuList->Add(menuItem);; 4319 }; 4320 delete methodList;; 4321}; 4322 ; 4323////////////////////////////////////////////////////////////////////////////////; 4324/// Register the fact that an object was moved from the memory location; 4325/// 'arenaFrom' to the memory location 'arenaTo'.; 4326 ; 4327void TClass::Move(void *arenaFrom, void *arenaTo) const; 4328{; 4329 // If/when we have access to a copy constructor (or better to a move; 4330 // constructor), this function should also perform the data move.; 4331 // For now we just information the repository.; 4332 ; 4333 if ((GetState() <= kEmulated) && !fCollectionProxy) {; 4334 MoveAddressInRepository(""TClass::Move"",arenaFrom,arenaTo,this);; 4335 }; 4336}; 4337 ; 4338////////////////////////////////////////////////////////////////////////////////; 4339/// Return the list of menu items associated with the class.; 4340 ; 4341TList *TClass::GetMenuList() const {; 4342 if (!fClassMenuList) {; 4343 fClassMenuList = new TList();; 4344 fClassMenuList->Add(new TClassMenuItem(TClassMenuItem::kPopupStandardList, const_cast<TClass*>(this)));; 4345 }; 4346 return fClassMenuList;; 4347}; 4348 ; 4349////////////////////////////////////////////////////////////////////////////////; 4350/// Return (create an empty one if needed) the list of functions.; 4351/// The major difference with GetListOfMethod is that this returns; 4352/// the interna",MatchSource.WIKI,doc/v632/TClass_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/TClass_8cxx_source.html
https://root.cern/doc/v632/TClass_8cxx_source.html:164728,Performance,load,loads,164728,"hould also perform the data move.; 4331 // For now we just information the repository.; 4332 ; 4333 if ((GetState() <= kEmulated) && !fCollectionProxy) {; 4334 MoveAddressInRepository(""TClass::Move"",arenaFrom,arenaTo,this);; 4335 }; 4336}; 4337 ; 4338////////////////////////////////////////////////////////////////////////////////; 4339/// Return the list of menu items associated with the class.; 4340 ; 4341TList *TClass::GetMenuList() const {; 4342 if (!fClassMenuList) {; 4343 fClassMenuList = new TList();; 4344 fClassMenuList->Add(new TClassMenuItem(TClassMenuItem::kPopupStandardList, const_cast<TClass*>(this)));; 4345 }; 4346 return fClassMenuList;; 4347}; 4348 ; 4349////////////////////////////////////////////////////////////////////////////////; 4350/// Return (create an empty one if needed) the list of functions.; 4351/// The major difference with GetListOfMethod is that this returns; 4352/// the internal type of fMethod and thus can not be made public.; 4353/// It also never 'loads' the content of the list.; 4354 ; 4355TListOfFunctions *TClass::GetMethodList(); 4356{; 4357 if (!fMethod.load()) {; 4358 std::unique_ptr<TListOfFunctions> temp{ new TListOfFunctions(this) };; 4359 TListOfFunctions* expected = nullptr;; 4360 if(fMethod.compare_exchange_strong(expected, temp.get()) ) {; 4361 temp.release();; 4362 }; 4363 }; 4364 return fMethod;; 4365}; 4366 ; 4367 ; 4368////////////////////////////////////////////////////////////////////////////////; 4369/// Return pointer to method without looking at parameters.; 4370/// Does not look in (possible) base classes.; 4371/// Has the side effect of loading all the TMethod object in the list; 4372/// of the class.; 4373 ; 4374TMethod *TClass::GetMethodAny(const char *method); 4375{; 4376 if (!HasInterpreterInfo()) return nullptr;; 4377 return (TMethod*) GetMethodList()->FindObject(method);; 4378}; 4379 ; 4380////////////////////////////////////////////////////////////////////////////////; 4381/// Return pointer to method ",MatchSource.WIKI,doc/v632/TClass_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/TClass_8cxx_source.html
https://root.cern/doc/v632/TClass_8cxx_source.html:164840,Performance,load,load,164840,"y(""TClass::Move"",arenaFrom,arenaTo,this);; 4335 }; 4336}; 4337 ; 4338////////////////////////////////////////////////////////////////////////////////; 4339/// Return the list of menu items associated with the class.; 4340 ; 4341TList *TClass::GetMenuList() const {; 4342 if (!fClassMenuList) {; 4343 fClassMenuList = new TList();; 4344 fClassMenuList->Add(new TClassMenuItem(TClassMenuItem::kPopupStandardList, const_cast<TClass*>(this)));; 4345 }; 4346 return fClassMenuList;; 4347}; 4348 ; 4349////////////////////////////////////////////////////////////////////////////////; 4350/// Return (create an empty one if needed) the list of functions.; 4351/// The major difference with GetListOfMethod is that this returns; 4352/// the internal type of fMethod and thus can not be made public.; 4353/// It also never 'loads' the content of the list.; 4354 ; 4355TListOfFunctions *TClass::GetMethodList(); 4356{; 4357 if (!fMethod.load()) {; 4358 std::unique_ptr<TListOfFunctions> temp{ new TListOfFunctions(this) };; 4359 TListOfFunctions* expected = nullptr;; 4360 if(fMethod.compare_exchange_strong(expected, temp.get()) ) {; 4361 temp.release();; 4362 }; 4363 }; 4364 return fMethod;; 4365}; 4366 ; 4367 ; 4368////////////////////////////////////////////////////////////////////////////////; 4369/// Return pointer to method without looking at parameters.; 4370/// Does not look in (possible) base classes.; 4371/// Has the side effect of loading all the TMethod object in the list; 4372/// of the class.; 4373 ; 4374TMethod *TClass::GetMethodAny(const char *method); 4375{; 4376 if (!HasInterpreterInfo()) return nullptr;; 4377 return (TMethod*) GetMethodList()->FindObject(method);; 4378}; 4379 ; 4380////////////////////////////////////////////////////////////////////////////////; 4381/// Return pointer to method without looking at parameters.; 4382/// Does look in all base classes.; 4383 ; 4384TMethod *TClass::GetMethodAllAny(const char *method); 4385{; 4386 if (!HasInterpreterInfo()) return ",MatchSource.WIKI,doc/v632/TClass_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/TClass_8cxx_source.html
https://root.cern/doc/v632/TClass_8cxx_source.html:165352,Performance,load,loading,165352,"eturn fClassMenuList;; 4347}; 4348 ; 4349////////////////////////////////////////////////////////////////////////////////; 4350/// Return (create an empty one if needed) the list of functions.; 4351/// The major difference with GetListOfMethod is that this returns; 4352/// the internal type of fMethod and thus can not be made public.; 4353/// It also never 'loads' the content of the list.; 4354 ; 4355TListOfFunctions *TClass::GetMethodList(); 4356{; 4357 if (!fMethod.load()) {; 4358 std::unique_ptr<TListOfFunctions> temp{ new TListOfFunctions(this) };; 4359 TListOfFunctions* expected = nullptr;; 4360 if(fMethod.compare_exchange_strong(expected, temp.get()) ) {; 4361 temp.release();; 4362 }; 4363 }; 4364 return fMethod;; 4365}; 4366 ; 4367 ; 4368////////////////////////////////////////////////////////////////////////////////; 4369/// Return pointer to method without looking at parameters.; 4370/// Does not look in (possible) base classes.; 4371/// Has the side effect of loading all the TMethod object in the list; 4372/// of the class.; 4373 ; 4374TMethod *TClass::GetMethodAny(const char *method); 4375{; 4376 if (!HasInterpreterInfo()) return nullptr;; 4377 return (TMethod*) GetMethodList()->FindObject(method);; 4378}; 4379 ; 4380////////////////////////////////////////////////////////////////////////////////; 4381/// Return pointer to method without looking at parameters.; 4382/// Does look in all base classes.; 4383 ; 4384TMethod *TClass::GetMethodAllAny(const char *method); 4385{; 4386 if (!HasInterpreterInfo()) return nullptr;; 4387 ; 4388 TMethod* m = GetMethodAny(method);; 4389 if (m) return m;; 4390 ; 4391 TBaseClass *base;; 4392 TIter nextb(GetListOfBases());; 4393 while ((base = (TBaseClass *) nextb())) {; 4394 TClass *c = base->GetClassPointer();; 4395 if (c) {; 4396 m = c->GetMethodAllAny(method);; 4397 if (m) return m;; 4398 }; 4399 }; 4400 ; 4401 return nullptr;; 4402}; 4403 ; 4404///////////////////////////////////////////////////////////////////////////",MatchSource.WIKI,doc/v632/TClass_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/TClass_8cxx_source.html
https://root.cern/doc/v632/TClass_8cxx_source.html:172619,Performance,load,load,172619,"f data members of this class; 4551/// Note that in case the list of data members is not yet created, it will be done; 4552/// by GetListOfDataMembers().; 4553 ; 4554Int_t TClass::GetNdata(); 4555{; 4556 if (!HasDataMemberInfo()) return 0;; 4557 ; 4558 TList *lm = GetListOfDataMembers();; 4559 if (lm); 4560 return lm->GetSize();; 4561 else; 4562 return 0;; 4563}; 4564 ; 4565////////////////////////////////////////////////////////////////////////////////; 4566/// Return the number of methods of this class; 4567/// Note that in case the list of methods is not yet created, it will be done; 4568/// by GetListOfMethods().; 4569/// This will also load/populate the list of methods, to get 'just' the; 4570/// number of currently loaded methods use:; 4571/// cl->GetListOfMethods(false)->GetSize();; 4572 ; 4573Int_t TClass::GetNmethods(); 4574{; 4575 if (!HasInterpreterInfo()) return 0;; 4576 ; 4577 TList *lm = GetListOfMethods();; 4578 if (lm); 4579 return lm->GetSize();; 4580 else; 4581 return 0;; 4582}; 4583 ; 4584////////////////////////////////////////////////////////////////////////////////; 4585/// returns a pointer to the TVirtualStreamerInfo object for version; 4586/// If the object does not exist, it is created; 4587///; 4588/// Note: There are two special version numbers:; 4589///; 4590/// - 0: Use the class version from the currently loaded class library.; 4591/// - -1: Assume no class library loaded (emulated class).; 4592///; 4593/// Warning: If we create a new streamer info, whether or not the build; 4594/// optimizes is controlled externally to us by a global variable!; 4595/// Don't call us unless you have set that variable properly; 4596/// with TStreamer::Optimize()!; 4597///; 4598 ; 4599TVirtualStreamerInfo* TClass::GetStreamerInfo(Int_t version /* = 0 */, Bool_t isTransient /* = false */) const; 4600{; 4601 TVirtualStreamerInfo *sinfo = fLastReadInfo;; 4602 ; 4603 // Version 0 is special, it means the currently loaded version.; 4604 // We need to set it at ",MatchSource.WIKI,doc/v632/TClass_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/TClass_8cxx_source.html
https://root.cern/doc/v632/TClass_8cxx_source.html:172701,Performance,load,loaded,172701,"f data members of this class; 4551/// Note that in case the list of data members is not yet created, it will be done; 4552/// by GetListOfDataMembers().; 4553 ; 4554Int_t TClass::GetNdata(); 4555{; 4556 if (!HasDataMemberInfo()) return 0;; 4557 ; 4558 TList *lm = GetListOfDataMembers();; 4559 if (lm); 4560 return lm->GetSize();; 4561 else; 4562 return 0;; 4563}; 4564 ; 4565////////////////////////////////////////////////////////////////////////////////; 4566/// Return the number of methods of this class; 4567/// Note that in case the list of methods is not yet created, it will be done; 4568/// by GetListOfMethods().; 4569/// This will also load/populate the list of methods, to get 'just' the; 4570/// number of currently loaded methods use:; 4571/// cl->GetListOfMethods(false)->GetSize();; 4572 ; 4573Int_t TClass::GetNmethods(); 4574{; 4575 if (!HasInterpreterInfo()) return 0;; 4576 ; 4577 TList *lm = GetListOfMethods();; 4578 if (lm); 4579 return lm->GetSize();; 4580 else; 4581 return 0;; 4582}; 4583 ; 4584////////////////////////////////////////////////////////////////////////////////; 4585/// returns a pointer to the TVirtualStreamerInfo object for version; 4586/// If the object does not exist, it is created; 4587///; 4588/// Note: There are two special version numbers:; 4589///; 4590/// - 0: Use the class version from the currently loaded class library.; 4591/// - -1: Assume no class library loaded (emulated class).; 4592///; 4593/// Warning: If we create a new streamer info, whether or not the build; 4594/// optimizes is controlled externally to us by a global variable!; 4595/// Don't call us unless you have set that variable properly; 4596/// with TStreamer::Optimize()!; 4597///; 4598 ; 4599TVirtualStreamerInfo* TClass::GetStreamerInfo(Int_t version /* = 0 */, Bool_t isTransient /* = false */) const; 4600{; 4601 TVirtualStreamerInfo *sinfo = fLastReadInfo;; 4602 ; 4603 // Version 0 is special, it means the currently loaded version.; 4604 // We need to set it at ",MatchSource.WIKI,doc/v632/TClass_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/TClass_8cxx_source.html
https://root.cern/doc/v632/TClass_8cxx_source.html:173328,Performance,load,loaded,173328,"f data members of this class; 4551/// Note that in case the list of data members is not yet created, it will be done; 4552/// by GetListOfDataMembers().; 4553 ; 4554Int_t TClass::GetNdata(); 4555{; 4556 if (!HasDataMemberInfo()) return 0;; 4557 ; 4558 TList *lm = GetListOfDataMembers();; 4559 if (lm); 4560 return lm->GetSize();; 4561 else; 4562 return 0;; 4563}; 4564 ; 4565////////////////////////////////////////////////////////////////////////////////; 4566/// Return the number of methods of this class; 4567/// Note that in case the list of methods is not yet created, it will be done; 4568/// by GetListOfMethods().; 4569/// This will also load/populate the list of methods, to get 'just' the; 4570/// number of currently loaded methods use:; 4571/// cl->GetListOfMethods(false)->GetSize();; 4572 ; 4573Int_t TClass::GetNmethods(); 4574{; 4575 if (!HasInterpreterInfo()) return 0;; 4576 ; 4577 TList *lm = GetListOfMethods();; 4578 if (lm); 4579 return lm->GetSize();; 4580 else; 4581 return 0;; 4582}; 4583 ; 4584////////////////////////////////////////////////////////////////////////////////; 4585/// returns a pointer to the TVirtualStreamerInfo object for version; 4586/// If the object does not exist, it is created; 4587///; 4588/// Note: There are two special version numbers:; 4589///; 4590/// - 0: Use the class version from the currently loaded class library.; 4591/// - -1: Assume no class library loaded (emulated class).; 4592///; 4593/// Warning: If we create a new streamer info, whether or not the build; 4594/// optimizes is controlled externally to us by a global variable!; 4595/// Don't call us unless you have set that variable properly; 4596/// with TStreamer::Optimize()!; 4597///; 4598 ; 4599TVirtualStreamerInfo* TClass::GetStreamerInfo(Int_t version /* = 0 */, Bool_t isTransient /* = false */) const; 4600{; 4601 TVirtualStreamerInfo *sinfo = fLastReadInfo;; 4602 ; 4603 // Version 0 is special, it means the currently loaded version.; 4604 // We need to set it at ",MatchSource.WIKI,doc/v632/TClass_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/TClass_8cxx_source.html
https://root.cern/doc/v632/TClass_8cxx_source.html:173389,Performance,load,loaded,173389,"//////////////////////////////////////////////; 4566/// Return the number of methods of this class; 4567/// Note that in case the list of methods is not yet created, it will be done; 4568/// by GetListOfMethods().; 4569/// This will also load/populate the list of methods, to get 'just' the; 4570/// number of currently loaded methods use:; 4571/// cl->GetListOfMethods(false)->GetSize();; 4572 ; 4573Int_t TClass::GetNmethods(); 4574{; 4575 if (!HasInterpreterInfo()) return 0;; 4576 ; 4577 TList *lm = GetListOfMethods();; 4578 if (lm); 4579 return lm->GetSize();; 4580 else; 4581 return 0;; 4582}; 4583 ; 4584////////////////////////////////////////////////////////////////////////////////; 4585/// returns a pointer to the TVirtualStreamerInfo object for version; 4586/// If the object does not exist, it is created; 4587///; 4588/// Note: There are two special version numbers:; 4589///; 4590/// - 0: Use the class version from the currently loaded class library.; 4591/// - -1: Assume no class library loaded (emulated class).; 4592///; 4593/// Warning: If we create a new streamer info, whether or not the build; 4594/// optimizes is controlled externally to us by a global variable!; 4595/// Don't call us unless you have set that variable properly; 4596/// with TStreamer::Optimize()!; 4597///; 4598 ; 4599TVirtualStreamerInfo* TClass::GetStreamerInfo(Int_t version /* = 0 */, Bool_t isTransient /* = false */) const; 4600{; 4601 TVirtualStreamerInfo *sinfo = fLastReadInfo;; 4602 ; 4603 // Version 0 is special, it means the currently loaded version.; 4604 // We need to set it at the beginning to be able to guess it correctly.; 4605 ; 4606 if (version == 0); 4607 version = fClassVersion;; 4608 ; 4609 // If the StreamerInfo is assigned to the fLastReadInfo, we are; 4610 // guaranteed it was built and compiled.; 4611 if (sinfo && sinfo->GetClassVersion() == version); 4612 return sinfo;; 4613 ; 4614 // Note that the access to fClassVersion above is technically not thread-safe with a l",MatchSource.WIKI,doc/v632/TClass_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/TClass_8cxx_source.html
https://root.cern/doc/v632/TClass_8cxx_source.html:173509,Performance,optimiz,optimizes,173509,"/// number of currently loaded methods use:; 4571/// cl->GetListOfMethods(false)->GetSize();; 4572 ; 4573Int_t TClass::GetNmethods(); 4574{; 4575 if (!HasInterpreterInfo()) return 0;; 4576 ; 4577 TList *lm = GetListOfMethods();; 4578 if (lm); 4579 return lm->GetSize();; 4580 else; 4581 return 0;; 4582}; 4583 ; 4584////////////////////////////////////////////////////////////////////////////////; 4585/// returns a pointer to the TVirtualStreamerInfo object for version; 4586/// If the object does not exist, it is created; 4587///; 4588/// Note: There are two special version numbers:; 4589///; 4590/// - 0: Use the class version from the currently loaded class library.; 4591/// - -1: Assume no class library loaded (emulated class).; 4592///; 4593/// Warning: If we create a new streamer info, whether or not the build; 4594/// optimizes is controlled externally to us by a global variable!; 4595/// Don't call us unless you have set that variable properly; 4596/// with TStreamer::Optimize()!; 4597///; 4598 ; 4599TVirtualStreamerInfo* TClass::GetStreamerInfo(Int_t version /* = 0 */, Bool_t isTransient /* = false */) const; 4600{; 4601 TVirtualStreamerInfo *sinfo = fLastReadInfo;; 4602 ; 4603 // Version 0 is special, it means the currently loaded version.; 4604 // We need to set it at the beginning to be able to guess it correctly.; 4605 ; 4606 if (version == 0); 4607 version = fClassVersion;; 4608 ; 4609 // If the StreamerInfo is assigned to the fLastReadInfo, we are; 4610 // guaranteed it was built and compiled.; 4611 if (sinfo && sinfo->GetClassVersion() == version); 4612 return sinfo;; 4613 ; 4614 // Note that the access to fClassVersion above is technically not thread-safe with a low probably of problems.; 4615 // fClassVersion is not an atomic and is modified TClass::SetClassVersion (called from RootClassVersion via; 4616 // ROOT::ResetClassVersion) and is 'somewhat' protected by the atomic fVersionUsed.; 4617 // However, direct access to fClassVersion should be replaced",MatchSource.WIKI,doc/v632/TClass_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/TClass_8cxx_source.html
https://root.cern/doc/v632/TClass_8cxx_source.html:173926,Performance,load,loaded,173926,"/// number of currently loaded methods use:; 4571/// cl->GetListOfMethods(false)->GetSize();; 4572 ; 4573Int_t TClass::GetNmethods(); 4574{; 4575 if (!HasInterpreterInfo()) return 0;; 4576 ; 4577 TList *lm = GetListOfMethods();; 4578 if (lm); 4579 return lm->GetSize();; 4580 else; 4581 return 0;; 4582}; 4583 ; 4584////////////////////////////////////////////////////////////////////////////////; 4585/// returns a pointer to the TVirtualStreamerInfo object for version; 4586/// If the object does not exist, it is created; 4587///; 4588/// Note: There are two special version numbers:; 4589///; 4590/// - 0: Use the class version from the currently loaded class library.; 4591/// - -1: Assume no class library loaded (emulated class).; 4592///; 4593/// Warning: If we create a new streamer info, whether or not the build; 4594/// optimizes is controlled externally to us by a global variable!; 4595/// Don't call us unless you have set that variable properly; 4596/// with TStreamer::Optimize()!; 4597///; 4598 ; 4599TVirtualStreamerInfo* TClass::GetStreamerInfo(Int_t version /* = 0 */, Bool_t isTransient /* = false */) const; 4600{; 4601 TVirtualStreamerInfo *sinfo = fLastReadInfo;; 4602 ; 4603 // Version 0 is special, it means the currently loaded version.; 4604 // We need to set it at the beginning to be able to guess it correctly.; 4605 ; 4606 if (version == 0); 4607 version = fClassVersion;; 4608 ; 4609 // If the StreamerInfo is assigned to the fLastReadInfo, we are; 4610 // guaranteed it was built and compiled.; 4611 if (sinfo && sinfo->GetClassVersion() == version); 4612 return sinfo;; 4613 ; 4614 // Note that the access to fClassVersion above is technically not thread-safe with a low probably of problems.; 4615 // fClassVersion is not an atomic and is modified TClass::SetClassVersion (called from RootClassVersion via; 4616 // ROOT::ResetClassVersion) and is 'somewhat' protected by the atomic fVersionUsed.; 4617 // However, direct access to fClassVersion should be replaced",MatchSource.WIKI,doc/v632/TClass_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/TClass_8cxx_source.html
https://root.cern/doc/v632/TClass_8cxx_source.html:175017,Performance,load,loading,175017," version = fClassVersion;; 4608 ; 4609 // If the StreamerInfo is assigned to the fLastReadInfo, we are; 4610 // guaranteed it was built and compiled.; 4611 if (sinfo && sinfo->GetClassVersion() == version); 4612 return sinfo;; 4613 ; 4614 // Note that the access to fClassVersion above is technically not thread-safe with a low probably of problems.; 4615 // fClassVersion is not an atomic and is modified TClass::SetClassVersion (called from RootClassVersion via; 4616 // ROOT::ResetClassVersion) and is 'somewhat' protected by the atomic fVersionUsed.; 4617 // However, direct access to fClassVersion should be replaced by calls to GetClassVersion to set fVersionUsed.; 4618 // Even with such a change the code here and in these functions need to be reviewed as a cursory look seem; 4619 // to indicates they are not yet properly protection against mutli-thread access.; 4620 //; 4621 // However, the use of these functions is rare and mostly done at library loading time which should; 4622 // in almost all cases preceeds the possibility of GetStreamerInfo being called from multiple thread; 4623 // on that same TClass object.; 4624 //; 4625 // Summary: need careful review but risk of problem is extremely low.; 4626 ; 4627 R__LOCKGUARD(gInterpreterMutex);; 4628 ; 4629 return GetStreamerInfoImpl(version, isTransient);; 4630};; 4631 ; 4632// Implementation of/for TStreamerInfo::GetStreamerInfo.; 4633// This routine assumes the global lock has been taken.; 4634TVirtualStreamerInfo* TClass::GetStreamerInfoImpl(Int_t version, Bool_t silent) const; 4635{; 4636 // Warning: version may be -1 for an emulated class, or -2 if the; 4637 // user requested the emulated streamerInfo for an abstract; 4638 // base class, even though we have a dictionary for it.; 4639 ; 4640 if ((version < -1) || (version >= (fStreamerInfo->GetSize()-1))) {; 4641 Error(""GetStreamerInfo"", ""class: %s, attempting to access a wrong version: %d"", GetName(), version);; 4642 // FIXME: Shouldn't we go to -1 here, or better",MatchSource.WIKI,doc/v632/TClass_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/TClass_8cxx_source.html
https://root.cern/doc/v632/TClass_8cxx_source.html:176374,Performance,load,loaded,176374,"reamerInfo being called from multiple thread; 4623 // on that same TClass object.; 4624 //; 4625 // Summary: need careful review but risk of problem is extremely low.; 4626 ; 4627 R__LOCKGUARD(gInterpreterMutex);; 4628 ; 4629 return GetStreamerInfoImpl(version, isTransient);; 4630};; 4631 ; 4632// Implementation of/for TStreamerInfo::GetStreamerInfo.; 4633// This routine assumes the global lock has been taken.; 4634TVirtualStreamerInfo* TClass::GetStreamerInfoImpl(Int_t version, Bool_t silent) const; 4635{; 4636 // Warning: version may be -1 for an emulated class, or -2 if the; 4637 // user requested the emulated streamerInfo for an abstract; 4638 // base class, even though we have a dictionary for it.; 4639 ; 4640 if ((version < -1) || (version >= (fStreamerInfo->GetSize()-1))) {; 4641 Error(""GetStreamerInfo"", ""class: %s, attempting to access a wrong version: %d"", GetName(), version);; 4642 // FIXME: Shouldn't we go to -1 here, or better just abort?; 4643 version = fClassVersion;; 4644 }; 4645 ; 4646 TVirtualStreamerInfo *sinfo = (TVirtualStreamerInfo *)fStreamerInfo->At(version);; 4647 ; 4648 if (!sinfo && (version != fClassVersion)) {; 4649 // When the requested version does not exist we return; 4650 // the TVirtualStreamerInfo for the currently loaded class version.; 4651 // FIXME: This arguably makes no sense, we should warn and return nothing instead.; 4652 // Note: This is done for STL collections; 4653 // Note: fClassVersion could be -1 here (for an emulated class).; 4654 // This is also the code path take for unversioned classes.; 4655 sinfo = (TVirtualStreamerInfo*) fStreamerInfo->At(fClassVersion);; 4656 }; 4657 ; 4658 if (!sinfo) {; 4659 // We just were not able to find a streamer info, we have to make a new one.; 4660 TMmallocDescTemp setreset;; 4661 sinfo = TVirtualStreamerInfo::Factory()->NewInfo(const_cast<TClass*>(this));; 4662 fStreamerInfo->AddAtAndExpand(sinfo, fClassVersion);; 4663 if (gDebug > 0) {; 4664 printf(""Creating StreamerInfo for class: ",MatchSource.WIKI,doc/v632/TClass_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/TClass_8cxx_source.html
https://root.cern/doc/v632/TClass_8cxx_source.html:178306,Performance,load,loaded,178306,"lass: %s, version: %d\n"", GetName(), fClassVersion);; 4665 }; 4666 if (HasDataMemberInfo() || fCollectionProxy) {; 4667 // If we do not have a StreamerInfo for this version and we do not; 4668 // have dictionary information nor a proxy, there is nothing to build!; 4669 sinfo->Build(silent);; 4670 }; 4671 } else {; 4672 if (!sinfo->IsCompiled()) {; 4673 // Streamer info has not been compiled, but exists.; 4674 // Therefore it was read in from a file and we have to do schema evolution?; 4675 // Or it didn't have a dictionary before, but does now?; 4676 sinfo->BuildOld();; 4677 }; 4678 }; 4679 ; 4680 // Cache the current info if we now have it.; 4681 if (version == fClassVersion); 4682 fCurrentInfo = sinfo;; 4683 ; 4684 // If the compilation succeeded, remember this StreamerInfo.; 4685 if (sinfo->IsCompiled()); 4686 fLastReadInfo = sinfo;; 4687 ; 4688 return sinfo;; 4689}; 4690 ; 4691////////////////////////////////////////////////////////////////////////////////; 4692/// For the case where the requestor class is emulated and this class is abstract,; 4693/// returns a pointer to the TVirtualStreamerInfo object for version with an emulated; 4694/// representation whether or not the class is loaded.; 4695///; 4696/// If the object does not exist, it is created; 4697///; 4698/// Note: There are two special version numbers:; 4699///; 4700/// - 0: Use the class version from the currently loaded class library.; 4701/// - -1: Assume no class library loaded (emulated class).; 4702///; 4703/// Warning: If we create a new streamer info, whether or not the build; 4704/// optimizes is controlled externally to us by a global variable!; 4705/// Don't call us unless you have set that variable properly; 4706/// with TStreamer::Optimize()!; 4707///; 4708 ; 4709TVirtualStreamerInfo* TClass::GetStreamerInfoAbstractEmulated(Int_t version /* = 0 */) const; 4710{; 4711 TVirtualStreamerInfo *sinfo = nullptr;; 4712 ; 4713 TString newname(GetName());; 4714 newname += ""@@emulated"";; 4715 ; 4716",MatchSource.WIKI,doc/v632/TClass_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/TClass_8cxx_source.html
https://root.cern/doc/v632/TClass_8cxx_source.html:178503,Performance,load,loaded,178503,"72 if (!sinfo->IsCompiled()) {; 4673 // Streamer info has not been compiled, but exists.; 4674 // Therefore it was read in from a file and we have to do schema evolution?; 4675 // Or it didn't have a dictionary before, but does now?; 4676 sinfo->BuildOld();; 4677 }; 4678 }; 4679 ; 4680 // Cache the current info if we now have it.; 4681 if (version == fClassVersion); 4682 fCurrentInfo = sinfo;; 4683 ; 4684 // If the compilation succeeded, remember this StreamerInfo.; 4685 if (sinfo->IsCompiled()); 4686 fLastReadInfo = sinfo;; 4687 ; 4688 return sinfo;; 4689}; 4690 ; 4691////////////////////////////////////////////////////////////////////////////////; 4692/// For the case where the requestor class is emulated and this class is abstract,; 4693/// returns a pointer to the TVirtualStreamerInfo object for version with an emulated; 4694/// representation whether or not the class is loaded.; 4695///; 4696/// If the object does not exist, it is created; 4697///; 4698/// Note: There are two special version numbers:; 4699///; 4700/// - 0: Use the class version from the currently loaded class library.; 4701/// - -1: Assume no class library loaded (emulated class).; 4702///; 4703/// Warning: If we create a new streamer info, whether or not the build; 4704/// optimizes is controlled externally to us by a global variable!; 4705/// Don't call us unless you have set that variable properly; 4706/// with TStreamer::Optimize()!; 4707///; 4708 ; 4709TVirtualStreamerInfo* TClass::GetStreamerInfoAbstractEmulated(Int_t version /* = 0 */) const; 4710{; 4711 TVirtualStreamerInfo *sinfo = nullptr;; 4712 ; 4713 TString newname(GetName());; 4714 newname += ""@@emulated"";; 4715 ; 4716 R__LOCKGUARD(gInterpreterMutex);; 4717 ; 4718 TClass *emulated = TClass::GetClass(newname);; 4719 ; 4720 if (emulated); 4721 sinfo = emulated->GetStreamerInfo(version);; 4722 ; 4723 if (!sinfo) {; 4724 // The emulated version of the streamerInfo is explicitly requested and has; 4725 // not been built yet.; 4726 ; 472",MatchSource.WIKI,doc/v632/TClass_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/TClass_8cxx_source.html
https://root.cern/doc/v632/TClass_8cxx_source.html:178564,Performance,load,loaded,178564," we have to do schema evolution?; 4675 // Or it didn't have a dictionary before, but does now?; 4676 sinfo->BuildOld();; 4677 }; 4678 }; 4679 ; 4680 // Cache the current info if we now have it.; 4681 if (version == fClassVersion); 4682 fCurrentInfo = sinfo;; 4683 ; 4684 // If the compilation succeeded, remember this StreamerInfo.; 4685 if (sinfo->IsCompiled()); 4686 fLastReadInfo = sinfo;; 4687 ; 4688 return sinfo;; 4689}; 4690 ; 4691////////////////////////////////////////////////////////////////////////////////; 4692/// For the case where the requestor class is emulated and this class is abstract,; 4693/// returns a pointer to the TVirtualStreamerInfo object for version with an emulated; 4694/// representation whether or not the class is loaded.; 4695///; 4696/// If the object does not exist, it is created; 4697///; 4698/// Note: There are two special version numbers:; 4699///; 4700/// - 0: Use the class version from the currently loaded class library.; 4701/// - -1: Assume no class library loaded (emulated class).; 4702///; 4703/// Warning: If we create a new streamer info, whether or not the build; 4704/// optimizes is controlled externally to us by a global variable!; 4705/// Don't call us unless you have set that variable properly; 4706/// with TStreamer::Optimize()!; 4707///; 4708 ; 4709TVirtualStreamerInfo* TClass::GetStreamerInfoAbstractEmulated(Int_t version /* = 0 */) const; 4710{; 4711 TVirtualStreamerInfo *sinfo = nullptr;; 4712 ; 4713 TString newname(GetName());; 4714 newname += ""@@emulated"";; 4715 ; 4716 R__LOCKGUARD(gInterpreterMutex);; 4717 ; 4718 TClass *emulated = TClass::GetClass(newname);; 4719 ; 4720 if (emulated); 4721 sinfo = emulated->GetStreamerInfo(version);; 4722 ; 4723 if (!sinfo) {; 4724 // The emulated version of the streamerInfo is explicitly requested and has; 4725 // not been built yet.; 4726 ; 4727 sinfo = (TVirtualStreamerInfo*) fStreamerInfo->At(version);; 4728 ; 4729 if (!sinfo && (version != fClassVersion)) {; 4730 // When the ",MatchSource.WIKI,doc/v632/TClass_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/TClass_8cxx_source.html
https://root.cern/doc/v632/TClass_8cxx_source.html:178684,Performance,optimiz,optimizes,178684,"/////////////////////////////////////////////////////////////////////////////; 4692/// For the case where the requestor class is emulated and this class is abstract,; 4693/// returns a pointer to the TVirtualStreamerInfo object for version with an emulated; 4694/// representation whether or not the class is loaded.; 4695///; 4696/// If the object does not exist, it is created; 4697///; 4698/// Note: There are two special version numbers:; 4699///; 4700/// - 0: Use the class version from the currently loaded class library.; 4701/// - -1: Assume no class library loaded (emulated class).; 4702///; 4703/// Warning: If we create a new streamer info, whether or not the build; 4704/// optimizes is controlled externally to us by a global variable!; 4705/// Don't call us unless you have set that variable properly; 4706/// with TStreamer::Optimize()!; 4707///; 4708 ; 4709TVirtualStreamerInfo* TClass::GetStreamerInfoAbstractEmulated(Int_t version /* = 0 */) const; 4710{; 4711 TVirtualStreamerInfo *sinfo = nullptr;; 4712 ; 4713 TString newname(GetName());; 4714 newname += ""@@emulated"";; 4715 ; 4716 R__LOCKGUARD(gInterpreterMutex);; 4717 ; 4718 TClass *emulated = TClass::GetClass(newname);; 4719 ; 4720 if (emulated); 4721 sinfo = emulated->GetStreamerInfo(version);; 4722 ; 4723 if (!sinfo) {; 4724 // The emulated version of the streamerInfo is explicitly requested and has; 4725 // not been built yet.; 4726 ; 4727 sinfo = (TVirtualStreamerInfo*) fStreamerInfo->At(version);; 4728 ; 4729 if (!sinfo && (version != fClassVersion)) {; 4730 // When the requested version does not exist we return; 4731 // the TVirtualStreamerInfo for the currently loaded class version.; 4732 // FIXME: This arguably makes no sense, we should warn and return nothing instead.; 4733 sinfo = (TVirtualStreamerInfo*) fStreamerInfo->At(fClassVersion);; 4734 }; 4735 ; 4736 if (!sinfo) {; 4737 // Let's take the first available StreamerInfo as a start; 4738 Int_t ninfos = fStreamerInfo->GetEntriesFast() - 1;; 4739 f",MatchSource.WIKI,doc/v632/TClass_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/TClass_8cxx_source.html
https://root.cern/doc/v632/TClass_8cxx_source.html:179651,Performance,load,loaded,179651," Assume no class library loaded (emulated class).; 4702///; 4703/// Warning: If we create a new streamer info, whether or not the build; 4704/// optimizes is controlled externally to us by a global variable!; 4705/// Don't call us unless you have set that variable properly; 4706/// with TStreamer::Optimize()!; 4707///; 4708 ; 4709TVirtualStreamerInfo* TClass::GetStreamerInfoAbstractEmulated(Int_t version /* = 0 */) const; 4710{; 4711 TVirtualStreamerInfo *sinfo = nullptr;; 4712 ; 4713 TString newname(GetName());; 4714 newname += ""@@emulated"";; 4715 ; 4716 R__LOCKGUARD(gInterpreterMutex);; 4717 ; 4718 TClass *emulated = TClass::GetClass(newname);; 4719 ; 4720 if (emulated); 4721 sinfo = emulated->GetStreamerInfo(version);; 4722 ; 4723 if (!sinfo) {; 4724 // The emulated version of the streamerInfo is explicitly requested and has; 4725 // not been built yet.; 4726 ; 4727 sinfo = (TVirtualStreamerInfo*) fStreamerInfo->At(version);; 4728 ; 4729 if (!sinfo && (version != fClassVersion)) {; 4730 // When the requested version does not exist we return; 4731 // the TVirtualStreamerInfo for the currently loaded class version.; 4732 // FIXME: This arguably makes no sense, we should warn and return nothing instead.; 4733 sinfo = (TVirtualStreamerInfo*) fStreamerInfo->At(fClassVersion);; 4734 }; 4735 ; 4736 if (!sinfo) {; 4737 // Let's take the first available StreamerInfo as a start; 4738 Int_t ninfos = fStreamerInfo->GetEntriesFast() - 1;; 4739 for (Int_t i = -1; sinfo == nullptr && i < ninfos; ++i); 4740 sinfo = (TVirtualStreamerInfo *)fStreamerInfo->UncheckedAt(i);; 4741 }; 4742 ; 4743 if (sinfo) {; 4744 sinfo = dynamic_cast<TVirtualStreamerInfo *>(sinfo->Clone());; 4745 if (sinfo) {; 4746 sinfo->SetClass(nullptr);; 4747 sinfo->SetName(newname);; 4748 sinfo->BuildCheck();; 4749 sinfo->BuildOld();; 4750 sinfo->GetClass()->AddRule(TString::Format(""sourceClass=%s targetClass=%s"",GetName(),newname.Data()));; 4751 } else {; 4752 Error(""GetStreamerInfoAbstractEmulated"", ""could not ",MatchSource.WIKI,doc/v632/TClass_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/TClass_8cxx_source.html
https://root.cern/doc/v632/TClass_8cxx_source.html:180946,Performance,load,loaded,180946,"kes no sense, we should warn and return nothing instead.; 4733 sinfo = (TVirtualStreamerInfo*) fStreamerInfo->At(fClassVersion);; 4734 }; 4735 ; 4736 if (!sinfo) {; 4737 // Let's take the first available StreamerInfo as a start; 4738 Int_t ninfos = fStreamerInfo->GetEntriesFast() - 1;; 4739 for (Int_t i = -1; sinfo == nullptr && i < ninfos; ++i); 4740 sinfo = (TVirtualStreamerInfo *)fStreamerInfo->UncheckedAt(i);; 4741 }; 4742 ; 4743 if (sinfo) {; 4744 sinfo = dynamic_cast<TVirtualStreamerInfo *>(sinfo->Clone());; 4745 if (sinfo) {; 4746 sinfo->SetClass(nullptr);; 4747 sinfo->SetName(newname);; 4748 sinfo->BuildCheck();; 4749 sinfo->BuildOld();; 4750 sinfo->GetClass()->AddRule(TString::Format(""sourceClass=%s targetClass=%s"",GetName(),newname.Data()));; 4751 } else {; 4752 Error(""GetStreamerInfoAbstractEmulated"", ""could not create TVirtualStreamerInfo"");; 4753 }; 4754 }; 4755 }; 4756 return sinfo;; 4757}; 4758 ; 4759////////////////////////////////////////////////////////////////////////////////; 4760/// For the case where the requestor class is emulated and this class is abstract,; 4761/// returns a pointer to the TVirtualStreamerInfo object for version with an emulated; 4762/// representation whether or not the class is loaded.; 4763///; 4764/// If the object does not exist, it is created; 4765///; 4766/// Warning: If we create a new streamer info, whether or not the build; 4767/// optimizes is controlled externally to us by a global variable!; 4768/// Don't call us unless you have set that variable properly; 4769/// with TStreamer::Optimize()!; 4770///; 4771 ; 4772TVirtualStreamerInfo* TClass::FindStreamerInfoAbstractEmulated(UInt_t checksum) const; 4773{; 4774 TVirtualStreamerInfo *sinfo = nullptr;; 4775 ; 4776 TString newname(GetName());; 4777 newname += ""@@emulated"";; 4778 ; 4779 R__LOCKGUARD(gInterpreterMutex);; 4780 ; 4781 TClass *emulated = TClass::GetClass(newname);; 4782 ; 4783 if (emulated); 4784 sinfo = emulated->FindStreamerInfo(checksum);; 4785 ; 4786 ",MatchSource.WIKI,doc/v632/TClass_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/TClass_8cxx_source.html
https://root.cern/doc/v632/TClass_8cxx_source.html:181111,Performance,optimiz,optimizes,181111,"TString::Format(""sourceClass=%s targetClass=%s"",GetName(),newname.Data()));; 4751 } else {; 4752 Error(""GetStreamerInfoAbstractEmulated"", ""could not create TVirtualStreamerInfo"");; 4753 }; 4754 }; 4755 }; 4756 return sinfo;; 4757}; 4758 ; 4759////////////////////////////////////////////////////////////////////////////////; 4760/// For the case where the requestor class is emulated and this class is abstract,; 4761/// returns a pointer to the TVirtualStreamerInfo object for version with an emulated; 4762/// representation whether or not the class is loaded.; 4763///; 4764/// If the object does not exist, it is created; 4765///; 4766/// Warning: If we create a new streamer info, whether or not the build; 4767/// optimizes is controlled externally to us by a global variable!; 4768/// Don't call us unless you have set that variable properly; 4769/// with TStreamer::Optimize()!; 4770///; 4771 ; 4772TVirtualStreamerInfo* TClass::FindStreamerInfoAbstractEmulated(UInt_t checksum) const; 4773{; 4774 TVirtualStreamerInfo *sinfo = nullptr;; 4775 ; 4776 TString newname(GetName());; 4777 newname += ""@@emulated"";; 4778 ; 4779 R__LOCKGUARD(gInterpreterMutex);; 4780 ; 4781 TClass *emulated = TClass::GetClass(newname);; 4782 ; 4783 if (emulated); 4784 sinfo = emulated->FindStreamerInfo(checksum);; 4785 ; 4786 if (!sinfo) {; 4787 // The emulated version of the streamerInfo is explicitly requested and has; 4788 // not been built yet.; 4789 ; 4790 sinfo = (TVirtualStreamerInfo*) FindStreamerInfo(checksum);; 4791 ; 4792 if (!sinfo && (checksum != fCheckSum)) {; 4793 // When the requested version does not exist we return; 4794 // the TVirtualStreamerInfo for the currently loaded class version.; 4795 // FIXME: This arguably makes no sense, we should warn and return nothing instead.; 4796 sinfo = (TVirtualStreamerInfo*) fStreamerInfo->At(fClassVersion);; 4797 }; 4798 ; 4799 if (!sinfo) {; 4800 // Let's take the first available StreamerInfo as a start; 4801 Int_t ninfos = fStreamerInfo->Get",MatchSource.WIKI,doc/v632/TClass_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/TClass_8cxx_source.html
https://root.cern/doc/v632/TClass_8cxx_source.html:182070,Performance,load,loaded,182070,"//; 4764/// If the object does not exist, it is created; 4765///; 4766/// Warning: If we create a new streamer info, whether or not the build; 4767/// optimizes is controlled externally to us by a global variable!; 4768/// Don't call us unless you have set that variable properly; 4769/// with TStreamer::Optimize()!; 4770///; 4771 ; 4772TVirtualStreamerInfo* TClass::FindStreamerInfoAbstractEmulated(UInt_t checksum) const; 4773{; 4774 TVirtualStreamerInfo *sinfo = nullptr;; 4775 ; 4776 TString newname(GetName());; 4777 newname += ""@@emulated"";; 4778 ; 4779 R__LOCKGUARD(gInterpreterMutex);; 4780 ; 4781 TClass *emulated = TClass::GetClass(newname);; 4782 ; 4783 if (emulated); 4784 sinfo = emulated->FindStreamerInfo(checksum);; 4785 ; 4786 if (!sinfo) {; 4787 // The emulated version of the streamerInfo is explicitly requested and has; 4788 // not been built yet.; 4789 ; 4790 sinfo = (TVirtualStreamerInfo*) FindStreamerInfo(checksum);; 4791 ; 4792 if (!sinfo && (checksum != fCheckSum)) {; 4793 // When the requested version does not exist we return; 4794 // the TVirtualStreamerInfo for the currently loaded class version.; 4795 // FIXME: This arguably makes no sense, we should warn and return nothing instead.; 4796 sinfo = (TVirtualStreamerInfo*) fStreamerInfo->At(fClassVersion);; 4797 }; 4798 ; 4799 if (!sinfo) {; 4800 // Let's take the first available StreamerInfo as a start; 4801 Int_t ninfos = fStreamerInfo->GetEntriesFast() - 1;; 4802 for (Int_t i = -1; sinfo == nullptr && i < ninfos; ++i); 4803 sinfo = (TVirtualStreamerInfo *)fStreamerInfo->UncheckedAt(i);; 4804 }; 4805 ; 4806 if (sinfo) {; 4807 sinfo = dynamic_cast<TVirtualStreamerInfo*>( sinfo->Clone() );; 4808 if (sinfo) {; 4809 sinfo->SetClass(nullptr);; 4810 sinfo->SetName( newname );; 4811 sinfo->BuildCheck();; 4812 sinfo->BuildOld();; 4813 sinfo->GetClass()->AddRule(TString::Format(""sourceClass=%s targetClass=%s"",GetName(),newname.Data()));; 4814 } else {; 4815 Error(""GetStreamerInfoAbstractEmulated"", ""could no",MatchSource.WIKI,doc/v632/TClass_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/TClass_8cxx_source.html
https://root.cern/doc/v632/TClass_8cxx_source.html:191178,Performance,load,loaded,191178,"embers if the object was allocated; 4990// via a TStreamerInfo.; 4991 ; 4992TClass::ObjectPtr TClass::NewObject(ENewType defConstructor, Bool_t quiet) const; 4993{; 4994 ObjectPtr p;; 4995 ; 4996 if (fNew) {; 4997 // We have the new operator wrapper function,; 4998 // so there is a dictionary and it was generated; 4999 // by rootcint, so there should be a default; 5000 // constructor we can call through the wrapper.; 5001 {; 5002 TClass__GetCallingNewRAII callingNew(defConstructor);; 5003 p = fNew(nullptr);; 5004 }; 5005 if (!p && !quiet) {; 5006 //Error(""New"", ""cannot create object of class %s version %d"", GetName(), fClassVersion);; 5007 Error(""New"", ""cannot create object of class %s"", GetName());; 5008 }; 5009 } else if (HasInterpreterInfo()) {; 5010 // We have the dictionary but do not have the; 5011 // constructor wrapper, so the dictionary was; 5012 // not generated by rootcint. Let's try to; 5013 // create the object by having the interpreter; 5014 // call the new operator, hopefully the class; 5015 // library is loaded and there will be a default; 5016 // constructor we can call.; 5017 // [This is very unlikely to work, but who knows!]; 5018 {; 5019 TClass__GetCallingNewRAII callingNew(defConstructor);; 5020 p = gCling->ClassInfo_New(GetClassInfo());; 5021 }; 5022 if (!p && !quiet) {; 5023 //Error(""New"", ""cannot create object of class %s version %d"", GetName(), fClassVersion);; 5024 Error(""New"", ""cannot create object of class %s"", GetName());; 5025 }; 5026 } else if (!HasInterpreterInfo() && fCollectionProxy) {; 5027 // There is no dictionary at all, so this is an emulated; 5028 // class; however we do have the services of a collection proxy,; 5029 // so this is an emulated STL class.; 5030 {; 5031 TClass__GetCallingNewRAII callingNew(defConstructor);; 5032 p = fCollectionProxy->NewObject();; 5033 }; 5034 if (!p && !quiet) {; 5035 //Error(""New"", ""cannot create object of class %s version %d"", GetName(), fClassVersion);; 5036 Error(""New"", ""cannot create object ",MatchSource.WIKI,doc/v632/TClass_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/TClass_8cxx_source.html
https://root.cern/doc/v632/TClass_8cxx_source.html:195630,Performance,load,loaded,195630,"he class must have a default constructor. For meaning of; 5104/// defConstructor, see TClass::IsCallingNew().; 5105 ; 5106TClass::ObjectPtr TClass::NewObject(void *arena, ENewType defConstructor) const; 5107{; 5108 ObjectPtr p;; 5109 ; 5110 if (fNew) {; 5111 // We have the new operator wrapper function,; 5112 // so there is a dictionary and it was generated; 5113 // by rootcint, so there should be a default; 5114 // constructor we can call through the wrapper.; 5115 {; 5116 TClass__GetCallingNewRAII callingNew(defConstructor);; 5117 p = fNew(arena);; 5118 }; 5119 if (!p) {; 5120 Error(""New with placement"", ""cannot create object of class %s version %d at address %p"", GetName(), fClassVersion, arena);; 5121 }; 5122 } else if (HasInterpreterInfo()) {; 5123 // We have the dictionary but do not have the; 5124 // constructor wrapper, so the dictionary was; 5125 // not generated by rootcint. Let's try to; 5126 // create the object by having the interpreter; 5127 // call the new operator, hopefully the class; 5128 // library is loaded and there will be a default; 5129 // constructor we can call.; 5130 // [This is very unlikely to work, but who knows!]; 5131 {; 5132 TClass__GetCallingNewRAII callingNew(defConstructor);; 5133 p = gCling->ClassInfo_New(GetClassInfo(),arena);; 5134 }; 5135 if (!p) {; 5136 Error(""New with placement"", ""cannot create object of class %s version %d at address %p"", GetName(), fClassVersion, arena);; 5137 }; 5138 } else if (!HasInterpreterInfo() && fCollectionProxy) {; 5139 // There is no dictionary at all, so this is an emulated; 5140 // class; however we do have the services of a collection proxy,; 5141 // so this is an emulated STL class.; 5142 {; 5143 TClass__GetCallingNewRAII callingNew(defConstructor);; 5144 p = fCollectionProxy->NewObject(arena);; 5145 }; 5146 } else if (!HasInterpreterInfo() && !fCollectionProxy) {; 5147 // There is no dictionary at all and we do not have; 5148 // the services of a collection proxy available, so; 5149 // use th",MatchSource.WIKI,doc/v632/TClass_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/TClass_8cxx_source.html
https://root.cern/doc/v632/TClass_8cxx_source.html:199665,Performance,load,loaded,199665," class must have a default constructor. For meaning of; 5207/// defConstructor, see TClass::IsCallingNew().; 5208 ; 5209TClass::ObjectPtr TClass::NewObjectArray(Long_t nElements, ENewType defConstructor) const; 5210{; 5211 ObjectPtr p;; 5212 ; 5213 if (fNewArray) {; 5214 // We have the new operator wrapper function,; 5215 // so there is a dictionary and it was generated; 5216 // by rootcint, so there should be a default; 5217 // constructor we can call through the wrapper.; 5218 {; 5219 TClass__GetCallingNewRAII callingNew(defConstructor);; 5220 p = fNewArray(nElements, nullptr);; 5221 }; 5222 if (!p) {; 5223 Error(""NewArray"", ""cannot create object of class %s version %d"", GetName(), fClassVersion);; 5224 }; 5225 } else if (HasInterpreterInfo()) {; 5226 // We have the dictionary but do not have the; 5227 // constructor wrapper, so the dictionary was; 5228 // not generated by rootcint. Let's try to; 5229 // create the object by having the interpreter; 5230 // call the new operator, hopefully the class; 5231 // library is loaded and there will be a default; 5232 // constructor we can call.; 5233 // [This is very unlikely to work, but who knows!]; 5234 {; 5235 TClass__GetCallingNewRAII callingNew(defConstructor);; 5236 p = gCling->ClassInfo_New(GetClassInfo(),nElements);; 5237 }; 5238 if (!p) {; 5239 Error(""NewArray"", ""cannot create object of class %s version %d"", GetName(), fClassVersion);; 5240 }; 5241 } else if (!HasInterpreterInfo() && fCollectionProxy) {; 5242 // There is no dictionary at all, so this is an emulated; 5243 // class; however we do have the services of a collection proxy,; 5244 // so this is an emulated STL class.; 5245 {; 5246 TClass__GetCallingNewRAII callingNew(defConstructor);; 5247 p = fCollectionProxy->NewObjectArray(nElements);; 5248 }; 5249 } else if (!HasInterpreterInfo() && !fCollectionProxy) {; 5250 // There is no dictionary at all and we do not have; 5251 // the services of a collection proxy available, so; 5252 // use the streamer info to",MatchSource.WIKI,doc/v632/TClass_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/TClass_8cxx_source.html
https://root.cern/doc/v632/TClass_8cxx_source.html:203741,Performance,load,loaded,203741,"ments, void *arena, ENewType defConstructor) const; 5311{; 5312 ObjectPtr p;; 5313 ; 5314 if (fNewArray) {; 5315 // We have the new operator wrapper function,; 5316 // so there is a dictionary and it was generated; 5317 // by rootcint, so there should be a default; 5318 // constructor we can call through the wrapper.; 5319 {; 5320 TClass__GetCallingNewRAII callingNew(defConstructor);; 5321 p = fNewArray(nElements, arena);; 5322 }; 5323 if (!p) {; 5324 Error(""NewArray with placement"", ""cannot create object of class %s version %d at address %p"", GetName(), fClassVersion, arena);; 5325 }; 5326 } else if (HasInterpreterInfo()) {; 5327 // We have the dictionary but do not have the constructor wrapper,; 5328 // so the dictionary was not generated by rootcint (it was made either; 5329 // by cint or by some external mechanism). Let's try to create the; 5330 // object by having the interpreter call the new operator, either the; 5331 // class library is loaded and there is a default constructor we can; 5332 // call, or the class is interpreted and we will call the default; 5333 // constructor that way, or no default constructor is available and; 5334 // we fail.; 5335 {; 5336 TClass__GetCallingNewRAII callingNew(defConstructor);; 5337 p = gCling->ClassInfo_New(GetClassInfo(),nElements, arena);; 5338 }; 5339 if (!p) {; 5340 Error(""NewArray with placement"", ""cannot create object of class %s version %d at address %p"", GetName(), fClassVersion, arena);; 5341 }; 5342 } else if (!HasInterpreterInfo() && fCollectionProxy) {; 5343 // There is no dictionary at all, so this is an emulated; 5344 // class; however we do have the services of a collection proxy,; 5345 // so this is an emulated STL class.; 5346 {; 5347 TClass__GetCallingNewRAII callingNew(defConstructor);; 5348 p = fCollectionProxy->NewObjectArray(nElements, arena);; 5349 }; 5350 } else if (!HasInterpreterInfo() && !fCollectionProxy) {; 5351 // There is no dictionary at all and we do not have; 5352 // the services of a colle",MatchSource.WIKI,doc/v632/TClass_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/TClass_8cxx_source.html
https://root.cern/doc/v632/TClass_8cxx_source.html:207093,Performance,load,loaded,207093,"(""NewArray with placement"", ""This cannot happen!"");; 5392 }; 5393 ; 5394 return p;; 5395}; 5396 ; 5397////////////////////////////////////////////////////////////////////////////////; 5398/// Explicitly call destructor for object.; 5399 ; 5400void TClass::Destructor(void *obj, Bool_t dtorOnly); 5401{; 5402 // Do nothing if passed a null pointer.; 5403 if (obj == nullptr) return;; 5404 ; 5405 void* p = obj;; 5406 ; 5407 if (dtorOnly && fDestructor) {; 5408 // We have the destructor wrapper, use it.; 5409 fDestructor(p);; 5410 } else if ((!dtorOnly) && fDelete) {; 5411 // We have the delete wrapper, use it.; 5412 fDelete(p);; 5413 } else if (HasInterpreterInfo()) {; 5414 // We have the dictionary but do not have the; 5415 // destruct/delete wrapper, so the dictionary was; 5416 // not generated by rootcint (it could have been; 5417 // created by cint or by some external mechanism).; 5418 // Let's have the interpreter call the destructor,; 5419 // either the code will be in a loaded library,; 5420 // or it will be interpreted, otherwise we fail; 5421 // because there is no destructor code at all.; 5422 if (dtorOnly) {; 5423 gCling->ClassInfo_Destruct(fClassInfo,p);; 5424 } else {; 5425 gCling->ClassInfo_Delete(fClassInfo,p);; 5426 }; 5427 } else if (!HasInterpreterInfo() && fCollectionProxy) {; 5428 // There is no dictionary at all, so this is an emulated; 5429 // class; however we do have the services of a collection proxy,; 5430 // so this is an emulated STL class.; 5431 GetCollectionProxy()->Destructor(p, dtorOnly);; 5432 } else if (!HasInterpreterInfo() && !fCollectionProxy) {; 5433 // There is no dictionary at all and we do not have; 5434 // the services of a collection proxy available, so; 5435 // use the streamer info to approximate calling a; 5436 // destructor.; 5437 ; 5438 Bool_t inRepo = kTRUE;; 5439 Bool_t currentVersion = kFALSE;; 5440 ; 5441 // Was this object allocated through TClass?; 5442 Version_t objVer = -1;; 5443 {; 5444 R__LOCKGUARD2(fOVRMutex);; 5",MatchSource.WIKI,doc/v632/TClass_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/TClass_8cxx_source.html
https://root.cern/doc/v632/TClass_8cxx_source.html:208823,Performance,load,loaded,208823,"erpreterInfo() && !fCollectionProxy) {; 5433 // There is no dictionary at all and we do not have; 5434 // the services of a collection proxy available, so; 5435 // use the streamer info to approximate calling a; 5436 // destructor.; 5437 ; 5438 Bool_t inRepo = kTRUE;; 5439 Bool_t currentVersion = kFALSE;; 5440 ; 5441 // Was this object allocated through TClass?; 5442 Version_t objVer = -1;; 5443 {; 5444 R__LOCKGUARD2(fOVRMutex);; 5445 RepoCont_t::iterator iter = fObjectVersionRepository.find(p);; 5446 if (iter == fObjectVersionRepository.end()) {; 5447 // No, it wasn't, skip special version handling.; 5448 //Error(""Destructor2"", ""Attempt to delete unregistered object of class '%s' at address %p!"", GetName(), p);; 5449 inRepo = kFALSE;; 5450 } else {; 5451 //objVer = iter->second;; 5452 for (; (iter != fObjectVersionRepository.end()) && (iter->first == p); ++iter) {; 5453 objVer = iter->second;; 5454 if (objVer == fClassVersion) {; 5455 currentVersion = kTRUE;; 5456 break;; 5457 }; 5458 }; 5459 }; 5460 }; 5461 ; 5462 if (!inRepo || currentVersion) {; 5463 // The object was allocated using code for the same class version; 5464 // as is loaded now. We may proceed without worry.; 5465 TVirtualStreamerInfo* si = GetStreamerInfo();; 5466 if (si) {; 5467 si->Destructor(p, dtorOnly);; 5468 } else {; 5469 Error(""Destructor"", ""No streamer info available for class '%s' version %d at address %p, cannot destruct emulated object!"", GetName(), fClassVersion, p);; 5470 Error(""Destructor"", ""length of fStreamerInfo is %d"", fStreamerInfo->GetSize());; 5471 Int_t i = fStreamerInfo->LowerBound();; 5472 for (Int_t v = 0; v < fStreamerInfo->GetSize(); ++v, ++i) {; 5473 Error(""Destructor"", ""fStreamerInfo->At(%d): %p"", i, fStreamerInfo->At(i));; 5474 if (fStreamerInfo->At(i) != nullptr) {; 5475 Error(""Destructor"", ""Doing Dump() ..."");; 5476 ((TVirtualStreamerInfo*)fStreamerInfo->At(i))->Dump();; 5477 }; 5478 }; 5479 }; 5480 } else {; 5481 // The loaded class version is not the same as the ve",MatchSource.WIKI,doc/v632/TClass_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/TClass_8cxx_source.html
https://root.cern/doc/v632/TClass_8cxx_source.html:209626,Performance,load,loaded,209626,"rrentVersion = kTRUE;; 5456 break;; 5457 }; 5458 }; 5459 }; 5460 }; 5461 ; 5462 if (!inRepo || currentVersion) {; 5463 // The object was allocated using code for the same class version; 5464 // as is loaded now. We may proceed without worry.; 5465 TVirtualStreamerInfo* si = GetStreamerInfo();; 5466 if (si) {; 5467 si->Destructor(p, dtorOnly);; 5468 } else {; 5469 Error(""Destructor"", ""No streamer info available for class '%s' version %d at address %p, cannot destruct emulated object!"", GetName(), fClassVersion, p);; 5470 Error(""Destructor"", ""length of fStreamerInfo is %d"", fStreamerInfo->GetSize());; 5471 Int_t i = fStreamerInfo->LowerBound();; 5472 for (Int_t v = 0; v < fStreamerInfo->GetSize(); ++v, ++i) {; 5473 Error(""Destructor"", ""fStreamerInfo->At(%d): %p"", i, fStreamerInfo->At(i));; 5474 if (fStreamerInfo->At(i) != nullptr) {; 5475 Error(""Destructor"", ""Doing Dump() ..."");; 5476 ((TVirtualStreamerInfo*)fStreamerInfo->At(i))->Dump();; 5477 }; 5478 }; 5479 }; 5480 } else {; 5481 // The loaded class version is not the same as the version of the code; 5482 // which was used to allocate this object. The best we can do is use; 5483 // the TVirtualStreamerInfo to try to free up some of the allocated memory.; 5484 TVirtualStreamerInfo* si = (TVirtualStreamerInfo*) fStreamerInfo->At(objVer);; 5485 if (si) {; 5486 si->Destructor(p, dtorOnly);; 5487 } else {; 5488 Error(""Destructor"", ""No streamer info available for class '%s' version %d, cannot destruct object at addr: %p"", GetName(), objVer, p);; 5489 Error(""Destructor"", ""length of fStreamerInfo is %d"", fStreamerInfo->GetSize());; 5490 Int_t i = fStreamerInfo->LowerBound();; 5491 for (Int_t v = 0; v < fStreamerInfo->GetSize(); ++v, ++i) {; 5492 Error(""Destructor2"", ""fStreamerInfo->At(%d): %p"", i, fStreamerInfo->At(i));; 5493 if (fStreamerInfo->At(i) != nullptr) {; 5494 // Do some debugging output.; 5495 Error(""Destructor2"", ""Doing Dump() ..."");; 5496 ((TVirtualStreamerInfo*)fStreamerInfo->At(i))->Dump();; 5497 }; 5498 }; 5",MatchSource.WIKI,doc/v632/TClass_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/TClass_8cxx_source.html
https://root.cern/doc/v632/TClass_8cxx_source.html:212252,Performance,load,loaded,212252,"0 obj.GetAllocator()->Destructor(obj.GetPtr(), dtorOnly);; 5521 } else {; 5522 Destructor(obj.GetPtr(), dtorOnly);; 5523 }; 5524}; 5525 ; 5526////////////////////////////////////////////////////////////////////////////////; 5527/// Explicitly call operator delete[] for an array.; 5528 ; 5529void TClass::DeleteArray(void *ary, Bool_t dtorOnly); 5530{; 5531 // Do nothing if passed a null pointer.; 5532 if (ary == nullptr) return;; 5533 ; 5534 // Make a copy of the address.; 5535 void* p = ary;; 5536 ; 5537 if (fDeleteArray) {; 5538 if (dtorOnly) {; 5539 Error(""DeleteArray"", ""Destructor only is not supported!"");; 5540 } else {; 5541 // We have the array delete wrapper, use it.; 5542 fDeleteArray(ary);; 5543 }; 5544 } else if (HasInterpreterInfo()) {; 5545 // We have the dictionary but do not have the; 5546 // array delete wrapper, so the dictionary was; 5547 // not generated by rootcint. Let's try to; 5548 // delete the array by having the interpreter; 5549 // call the array delete operator, hopefully; 5550 // the class library is loaded and there will be; 5551 // a destructor we can call.; 5552 gCling->ClassInfo_DeleteArray(GetClassInfo(),ary, dtorOnly);; 5553 } else if (!HasInterpreterInfo() && fCollectionProxy) {; 5554 // There is no dictionary at all, so this is an emulated; 5555 // class; however we do have the services of a collection proxy,; 5556 // so this is an emulated STL class.; 5557 GetCollectionProxy()->DeleteArray(ary, dtorOnly);; 5558 } else if (!HasInterpreterInfo() && !fCollectionProxy) {; 5559 // There is no dictionary at all and we do not have; 5560 // the services of a collection proxy available, so; 5561 // use the streamer info to approximate calling the; 5562 // array destructor.; 5563 ; 5564 Bool_t inRepo = kTRUE;; 5565 Bool_t currentVersion = kFALSE;; 5566 ; 5567 // Was this array object allocated through TClass?; 5568 Version_t objVer = -1;; 5569 {; 5570 R__LOCKGUARD2(fOVRMutex);; 5571 RepoCont_t::iterator iter = fObjectVersionRepository.find",MatchSource.WIKI,doc/v632/TClass_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/TClass_8cxx_source.html
https://root.cern/doc/v632/TClass_8cxx_source.html:213841,Performance,load,loaded,213841," (!HasInterpreterInfo() && !fCollectionProxy) {; 5559 // There is no dictionary at all and we do not have; 5560 // the services of a collection proxy available, so; 5561 // use the streamer info to approximate calling the; 5562 // array destructor.; 5563 ; 5564 Bool_t inRepo = kTRUE;; 5565 Bool_t currentVersion = kFALSE;; 5566 ; 5567 // Was this array object allocated through TClass?; 5568 Version_t objVer = -1;; 5569 {; 5570 R__LOCKGUARD2(fOVRMutex);; 5571 RepoCont_t::iterator iter = fObjectVersionRepository.find(p);; 5572 if (iter == fObjectVersionRepository.end()) {; 5573 // No, it wasn't, we cannot know what to do.; 5574 //Error(""DeleteArray"", ""Attempt to delete unregistered array object, element type '%s', at address %p!"", GetName(), p);; 5575 inRepo = kFALSE;; 5576 } else {; 5577 for (; (iter != fObjectVersionRepository.end()) && (iter->first == p); ++iter) {; 5578 objVer = iter->second;; 5579 if (objVer == fClassVersion) {; 5580 currentVersion = kTRUE;; 5581 break;; 5582 }; 5583 }; 5584 }; 5585 }; 5586 ; 5587 if (!inRepo || currentVersion) {; 5588 // The object was allocated using code for the same class version; 5589 // as is loaded now. We may proceed without worry.; 5590 TVirtualStreamerInfo* si = GetStreamerInfo();; 5591 if (si) {; 5592 si->DeleteArray(ary, dtorOnly);; 5593 } else {; 5594 Error(""DeleteArray"", ""No streamer info available for class '%s' version %d at address %p, cannot destruct object!"", GetName(), fClassVersion, ary);; 5595 Error(""DeleteArray"", ""length of fStreamerInfo is %d"", fStreamerInfo->GetSize());; 5596 Int_t i = fStreamerInfo->LowerBound();; 5597 for (Int_t v = 0; v < fStreamerInfo->GetSize(); ++v, ++i) {; 5598 Error(""DeleteArray"", ""fStreamerInfo->At(%d): %p"", v, fStreamerInfo->At(i));; 5599 if (fStreamerInfo->At(i)) {; 5600 Error(""DeleteArray"", ""Doing Dump() ..."");; 5601 ((TVirtualStreamerInfo*)fStreamerInfo->At(i))->Dump();; 5602 }; 5603 }; 5604 }; 5605 } else {; 5606 // The loaded class version is not the same as the version of th",MatchSource.WIKI,doc/v632/TClass_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/TClass_8cxx_source.html
https://root.cern/doc/v632/TClass_8cxx_source.html:214633,Performance,load,loaded,214633," {; 5580 currentVersion = kTRUE;; 5581 break;; 5582 }; 5583 }; 5584 }; 5585 }; 5586 ; 5587 if (!inRepo || currentVersion) {; 5588 // The object was allocated using code for the same class version; 5589 // as is loaded now. We may proceed without worry.; 5590 TVirtualStreamerInfo* si = GetStreamerInfo();; 5591 if (si) {; 5592 si->DeleteArray(ary, dtorOnly);; 5593 } else {; 5594 Error(""DeleteArray"", ""No streamer info available for class '%s' version %d at address %p, cannot destruct object!"", GetName(), fClassVersion, ary);; 5595 Error(""DeleteArray"", ""length of fStreamerInfo is %d"", fStreamerInfo->GetSize());; 5596 Int_t i = fStreamerInfo->LowerBound();; 5597 for (Int_t v = 0; v < fStreamerInfo->GetSize(); ++v, ++i) {; 5598 Error(""DeleteArray"", ""fStreamerInfo->At(%d): %p"", v, fStreamerInfo->At(i));; 5599 if (fStreamerInfo->At(i)) {; 5600 Error(""DeleteArray"", ""Doing Dump() ..."");; 5601 ((TVirtualStreamerInfo*)fStreamerInfo->At(i))->Dump();; 5602 }; 5603 }; 5604 }; 5605 } else {; 5606 // The loaded class version is not the same as the version of the code; 5607 // which was used to allocate this array. The best we can do is use; 5608 // the TVirtualStreamerInfo to try to free up some of the allocated memory.; 5609 TVirtualStreamerInfo* si = (TVirtualStreamerInfo*) fStreamerInfo->At(objVer);; 5610 if (si) {; 5611 si->DeleteArray(ary, dtorOnly);; 5612 } else {; 5613 Error(""DeleteArray"", ""No streamer info available for class '%s' version %d at address %p, cannot destruct object!"", GetName(), objVer, ary);; 5614 Error(""DeleteArray"", ""length of fStreamerInfo is %d"", fStreamerInfo->GetSize());; 5615 Int_t i = fStreamerInfo->LowerBound();; 5616 for (Int_t v = 0; v < fStreamerInfo->GetSize(); ++v, ++i) {; 5617 Error(""DeleteArray"", ""fStreamerInfo->At(%d): %p"", v, fStreamerInfo->At(i));; 5618 if (fStreamerInfo->At(i)) {; 5619 // Print some debugging info.; 5620 Error(""DeleteArray"", ""Doing Dump() ..."");; 5621 ((TVirtualStreamerInfo*)fStreamerInfo->At(i))->Dump();; 5622 }; 5623 }; 5",MatchSource.WIKI,doc/v632/TClass_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/TClass_8cxx_source.html
https://root.cern/doc/v632/TClass_8cxx_source.html:217927,Performance,load,load,217927,"// - If no class number has been specified, TClass::GetVersion will return -1; 5671/// - The Class Version 0 request the whole object to be transient; 5672/// - The Class Version 1, unless specified via ClassDef indicates that the; 5673/// I/O should use the TClass checksum to distinguish the layout of the class; 5674 ; 5675void TClass::SetClassVersion(Version_t version); 5676{; 5677 fClassVersion = version;; 5678 fCurrentInfo = nullptr;; 5679}; 5680 ; 5681////////////////////////////////////////////////////////////////////////////////; 5682/// Determine and set pointer to current TVirtualStreamerInfo; 5683 ; 5684TVirtualStreamerInfo* TClass::DetermineCurrentStreamerInfo(); 5685{; 5686 if(!fCurrentInfo.load()) {; 5687 R__READ_LOCKGUARD(ROOT::gCoreMutex);; 5688 fCurrentInfo = (TVirtualStreamerInfo *)(fStreamerInfo->At(fClassVersion));; 5689 }; 5690 return fCurrentInfo;; 5691}; 5692 ; 5693////////////////////////////////////////////////////////////////////////////////; 5694/// Set pointer to current TVirtualStreamerInfo; 5695 ; 5696void TClass::SetCurrentStreamerInfo(TVirtualStreamerInfo *info); 5697{; 5698 fCurrentInfo = info;; 5699}; 5700 ; 5701////////////////////////////////////////////////////////////////////////////////; 5702/// Return size of object of this class.; 5703 ; 5704Int_t TClass::Size() const; 5705{; 5706 if (fSizeof!=-1) return fSizeof;; 5707 if (fCollectionProxy) return fCollectionProxy->Sizeof();; 5708 if (HasInterpreterInfo()) return gCling->ClassInfo_Size(GetClassInfo());; 5709 return GetStreamerInfo()->GetSize();; 5710}; 5711 ; 5712////////////////////////////////////////////////////////////////////////////////; 5713/// Load class description from I/O buffer and return class object.; 5714 ; 5715TClass *TClass::Load(TBuffer &b); 5716{; 5717 UInt_t maxsize = 256;; 5718 char *s = new char[maxsize];; 5719 ; 5720 Int_t pos = b.Length();; 5721 ; 5722 b.ReadString(s, maxsize); // Reads at most maxsize - 1 characters, plus null at end.; 5723 while (strle",MatchSource.WIKI,doc/v632/TClass_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/TClass_8cxx_source.html
https://root.cern/doc/v632/TClass_8cxx_source.html:219883,Performance,load,load,219883,"buffer and return class object.; 5714 ; 5715TClass *TClass::Load(TBuffer &b); 5716{; 5717 UInt_t maxsize = 256;; 5718 char *s = new char[maxsize];; 5719 ; 5720 Int_t pos = b.Length();; 5721 ; 5722 b.ReadString(s, maxsize); // Reads at most maxsize - 1 characters, plus null at end.; 5723 while (strlen(s) == (maxsize - 1)) {; 5724 // The classname is too large, try again with a large buffer.; 5725 b.SetBufferOffset(pos);; 5726 maxsize = 2*maxsize;; 5727 delete [] s;; 5728 s = new char[maxsize];; 5729 b.ReadString(s, maxsize); // Reads at most maxsize - 1 characters, plus null at end.; 5730 }; 5731 ; 5732 TClass *cl = TClass::GetClass(s, kTRUE);; 5733 if (!cl); 5734 ::Error(""TClass::Load"", ""dictionary of class %s not found"", s);; 5735 ; 5736 delete [] s;; 5737 return cl;; 5738}; 5739 ; 5740////////////////////////////////////////////////////////////////////////////////; 5741/// Helper function used by TClass::GetClass().; 5742/// This function attempts to load the dictionary for 'classname'; 5743/// either from the TClassTable or from the list of generator.; 5744/// If silent is 'true', do not warn about missing dictionary for the class.; 5745/// (typically used for class that are used only for transient members); 5746///; 5747/// The 'requestedname' is expected to be already normalized.; 5748 ; 5749TClass *TClass::LoadClass(const char *requestedname, Bool_t silent); 5750{; 5751 // This function does not (and should not) attempt to check in the; 5752 // list of loaded classes or in the typedef.; 5753 ; 5754 R__LOCKGUARD(gInterpreterMutex);; 5755 ; 5756 TClass *result = LoadClassDefault(requestedname, silent);; 5757 ; 5758 if (result) return result;; 5759 else return LoadClassCustom(requestedname,silent);; 5760}; 5761 ; 5762////////////////////////////////////////////////////////////////////////////////; 5763/// Helper function used by TClass::GetClass().; 5764/// This function attempts to load the dictionary for 'classname' from; 5765/// the TClassTable or the autoloade",MatchSource.WIKI,doc/v632/TClass_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/TClass_8cxx_source.html
https://root.cern/doc/v632/TClass_8cxx_source.html:220399,Performance,load,loaded,220399,"Offset(pos);; 5726 maxsize = 2*maxsize;; 5727 delete [] s;; 5728 s = new char[maxsize];; 5729 b.ReadString(s, maxsize); // Reads at most maxsize - 1 characters, plus null at end.; 5730 }; 5731 ; 5732 TClass *cl = TClass::GetClass(s, kTRUE);; 5733 if (!cl); 5734 ::Error(""TClass::Load"", ""dictionary of class %s not found"", s);; 5735 ; 5736 delete [] s;; 5737 return cl;; 5738}; 5739 ; 5740////////////////////////////////////////////////////////////////////////////////; 5741/// Helper function used by TClass::GetClass().; 5742/// This function attempts to load the dictionary for 'classname'; 5743/// either from the TClassTable or from the list of generator.; 5744/// If silent is 'true', do not warn about missing dictionary for the class.; 5745/// (typically used for class that are used only for transient members); 5746///; 5747/// The 'requestedname' is expected to be already normalized.; 5748 ; 5749TClass *TClass::LoadClass(const char *requestedname, Bool_t silent); 5750{; 5751 // This function does not (and should not) attempt to check in the; 5752 // list of loaded classes or in the typedef.; 5753 ; 5754 R__LOCKGUARD(gInterpreterMutex);; 5755 ; 5756 TClass *result = LoadClassDefault(requestedname, silent);; 5757 ; 5758 if (result) return result;; 5759 else return LoadClassCustom(requestedname,silent);; 5760}; 5761 ; 5762////////////////////////////////////////////////////////////////////////////////; 5763/// Helper function used by TClass::GetClass().; 5764/// This function attempts to load the dictionary for 'classname' from; 5765/// the TClassTable or the autoloader.; 5766/// If silent is 'true', do not warn about missing dictionary for the class.; 5767/// (typically used for class that are used only for transient members); 5768///; 5769/// The 'requestedname' is expected to be already normalized.; 5770 ; 5771TClass *TClass::LoadClassDefault(const char *requestedname, Bool_t /* silent */); 5772{; 5773 // This function does not (and should not) attempt to check in the",MatchSource.WIKI,doc/v632/TClass_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/TClass_8cxx_source.html
https://root.cern/doc/v632/TClass_8cxx_source.html:220835,Performance,load,load,220835,"is function attempts to load the dictionary for 'classname'; 5743/// either from the TClassTable or from the list of generator.; 5744/// If silent is 'true', do not warn about missing dictionary for the class.; 5745/// (typically used for class that are used only for transient members); 5746///; 5747/// The 'requestedname' is expected to be already normalized.; 5748 ; 5749TClass *TClass::LoadClass(const char *requestedname, Bool_t silent); 5750{; 5751 // This function does not (and should not) attempt to check in the; 5752 // list of loaded classes or in the typedef.; 5753 ; 5754 R__LOCKGUARD(gInterpreterMutex);; 5755 ; 5756 TClass *result = LoadClassDefault(requestedname, silent);; 5757 ; 5758 if (result) return result;; 5759 else return LoadClassCustom(requestedname,silent);; 5760}; 5761 ; 5762////////////////////////////////////////////////////////////////////////////////; 5763/// Helper function used by TClass::GetClass().; 5764/// This function attempts to load the dictionary for 'classname' from; 5765/// the TClassTable or the autoloader.; 5766/// If silent is 'true', do not warn about missing dictionary for the class.; 5767/// (typically used for class that are used only for transient members); 5768///; 5769/// The 'requestedname' is expected to be already normalized.; 5770 ; 5771TClass *TClass::LoadClassDefault(const char *requestedname, Bool_t /* silent */); 5772{; 5773 // This function does not (and should not) attempt to check in the; 5774 // list of loaded classes or in the typedef.; 5775 ; 5776 DictFuncPtr_t dict = TClassTable::GetDictNorm(requestedname);; 5777 ; 5778 if (!dict) {; 5779 if (gInterpreter->AutoLoad(requestedname,kTRUE)) {; 5780 dict = TClassTable::GetDictNorm(requestedname);; 5781 }; 5782 }; 5783 ; 5784 if (dict) {; 5785 TClass *ncl = (dict)();; 5786 if (ncl) ncl->PostLoadCheck();; 5787 return ncl;; 5788 }; 5789 return nullptr;; 5790}; 5791 ; 5792////////////////////////////////////////////////////////////////////////////////; 5793/// Hel",MatchSource.WIKI,doc/v632/TClass_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/TClass_8cxx_source.html
https://root.cern/doc/v632/TClass_8cxx_source.html:221345,Performance,load,loaded,221345,"char *requestedname, Bool_t silent); 5750{; 5751 // This function does not (and should not) attempt to check in the; 5752 // list of loaded classes or in the typedef.; 5753 ; 5754 R__LOCKGUARD(gInterpreterMutex);; 5755 ; 5756 TClass *result = LoadClassDefault(requestedname, silent);; 5757 ; 5758 if (result) return result;; 5759 else return LoadClassCustom(requestedname,silent);; 5760}; 5761 ; 5762////////////////////////////////////////////////////////////////////////////////; 5763/// Helper function used by TClass::GetClass().; 5764/// This function attempts to load the dictionary for 'classname' from; 5765/// the TClassTable or the autoloader.; 5766/// If silent is 'true', do not warn about missing dictionary for the class.; 5767/// (typically used for class that are used only for transient members); 5768///; 5769/// The 'requestedname' is expected to be already normalized.; 5770 ; 5771TClass *TClass::LoadClassDefault(const char *requestedname, Bool_t /* silent */); 5772{; 5773 // This function does not (and should not) attempt to check in the; 5774 // list of loaded classes or in the typedef.; 5775 ; 5776 DictFuncPtr_t dict = TClassTable::GetDictNorm(requestedname);; 5777 ; 5778 if (!dict) {; 5779 if (gInterpreter->AutoLoad(requestedname,kTRUE)) {; 5780 dict = TClassTable::GetDictNorm(requestedname);; 5781 }; 5782 }; 5783 ; 5784 if (dict) {; 5785 TClass *ncl = (dict)();; 5786 if (ncl) ncl->PostLoadCheck();; 5787 return ncl;; 5788 }; 5789 return nullptr;; 5790}; 5791 ; 5792////////////////////////////////////////////////////////////////////////////////; 5793/// Helper function used by TClass::GetClass().; 5794/// This function attempts to load the dictionary for 'classname'; 5795/// from the list of generator.; 5796/// If silent is 'true', do not warn about missing dictionary for the class.; 5797/// (typically used for class that are used only for transient members); 5798///; 5799/// The 'requestedname' is expected to be already normalized.; 5800 ; 5801TClass *TCl",MatchSource.WIKI,doc/v632/TClass_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/TClass_8cxx_source.html
https://root.cern/doc/v632/TClass_8cxx_source.html:221935,Performance,load,load,221935,"not warn about missing dictionary for the class.; 5767/// (typically used for class that are used only for transient members); 5768///; 5769/// The 'requestedname' is expected to be already normalized.; 5770 ; 5771TClass *TClass::LoadClassDefault(const char *requestedname, Bool_t /* silent */); 5772{; 5773 // This function does not (and should not) attempt to check in the; 5774 // list of loaded classes or in the typedef.; 5775 ; 5776 DictFuncPtr_t dict = TClassTable::GetDictNorm(requestedname);; 5777 ; 5778 if (!dict) {; 5779 if (gInterpreter->AutoLoad(requestedname,kTRUE)) {; 5780 dict = TClassTable::GetDictNorm(requestedname);; 5781 }; 5782 }; 5783 ; 5784 if (dict) {; 5785 TClass *ncl = (dict)();; 5786 if (ncl) ncl->PostLoadCheck();; 5787 return ncl;; 5788 }; 5789 return nullptr;; 5790}; 5791 ; 5792////////////////////////////////////////////////////////////////////////////////; 5793/// Helper function used by TClass::GetClass().; 5794/// This function attempts to load the dictionary for 'classname'; 5795/// from the list of generator.; 5796/// If silent is 'true', do not warn about missing dictionary for the class.; 5797/// (typically used for class that are used only for transient members); 5798///; 5799/// The 'requestedname' is expected to be already normalized.; 5800 ; 5801TClass *TClass::LoadClassCustom(const char *requestedname, Bool_t silent); 5802{; 5803 // This function does not (and should not) attempt to check in the; 5804 // list of loaded classes or in the typedef.; 5805 ; 5806 TIter next(gROOT->GetListOfClassGenerators());; 5807 TClassGenerator *gen;; 5808 while ((gen = (TClassGenerator*) next())) {; 5809 TClass *cl = gen->GetClass(requestedname, kTRUE, silent);; 5810 if (cl) {; 5811 cl->PostLoadCheck();; 5812 return cl;; 5813 }; 5814 }; 5815 return nullptr;; 5816}; 5817 ; 5818////////////////////////////////////////////////////////////////////////////////; 5819/// Try to load the ClassInfo if available. This function may require parsing; 5820/// t",MatchSource.WIKI,doc/v632/TClass_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/TClass_8cxx_source.html
https://root.cern/doc/v632/TClass_8cxx_source.html:222426,Performance,load,loaded,222426,"d classes or in the typedef.; 5775 ; 5776 DictFuncPtr_t dict = TClassTable::GetDictNorm(requestedname);; 5777 ; 5778 if (!dict) {; 5779 if (gInterpreter->AutoLoad(requestedname,kTRUE)) {; 5780 dict = TClassTable::GetDictNorm(requestedname);; 5781 }; 5782 }; 5783 ; 5784 if (dict) {; 5785 TClass *ncl = (dict)();; 5786 if (ncl) ncl->PostLoadCheck();; 5787 return ncl;; 5788 }; 5789 return nullptr;; 5790}; 5791 ; 5792////////////////////////////////////////////////////////////////////////////////; 5793/// Helper function used by TClass::GetClass().; 5794/// This function attempts to load the dictionary for 'classname'; 5795/// from the list of generator.; 5796/// If silent is 'true', do not warn about missing dictionary for the class.; 5797/// (typically used for class that are used only for transient members); 5798///; 5799/// The 'requestedname' is expected to be already normalized.; 5800 ; 5801TClass *TClass::LoadClassCustom(const char *requestedname, Bool_t silent); 5802{; 5803 // This function does not (and should not) attempt to check in the; 5804 // list of loaded classes or in the typedef.; 5805 ; 5806 TIter next(gROOT->GetListOfClassGenerators());; 5807 TClassGenerator *gen;; 5808 while ((gen = (TClassGenerator*) next())) {; 5809 TClass *cl = gen->GetClass(requestedname, kTRUE, silent);; 5810 if (cl) {; 5811 cl->PostLoadCheck();; 5812 return cl;; 5813 }; 5814 }; 5815 return nullptr;; 5816}; 5817 ; 5818////////////////////////////////////////////////////////////////////////////////; 5819/// Try to load the ClassInfo if available. This function may require parsing; 5820/// the header file and/or loading data from the clang pcm. If further calls to; 5821/// this function cannot affect the value of fClassInfo, fCanLoadClassInfo is set; 5822/// to false.; 5823 ; 5824void TClass::LoadClassInfo() const; 5825{; 5826 R__LOCKGUARD(gInterpreterMutex);; 5827 ; 5828 // Return if another thread already loaded the info; 5829 // while we were waiting for the lock; 5830 if (!fCan",MatchSource.WIKI,doc/v632/TClass_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/TClass_8cxx_source.html
https://root.cern/doc/v632/TClass_8cxx_source.html:222876,Performance,load,load,222876,"ostLoadCheck();; 5787 return ncl;; 5788 }; 5789 return nullptr;; 5790}; 5791 ; 5792////////////////////////////////////////////////////////////////////////////////; 5793/// Helper function used by TClass::GetClass().; 5794/// This function attempts to load the dictionary for 'classname'; 5795/// from the list of generator.; 5796/// If silent is 'true', do not warn about missing dictionary for the class.; 5797/// (typically used for class that are used only for transient members); 5798///; 5799/// The 'requestedname' is expected to be already normalized.; 5800 ; 5801TClass *TClass::LoadClassCustom(const char *requestedname, Bool_t silent); 5802{; 5803 // This function does not (and should not) attempt to check in the; 5804 // list of loaded classes or in the typedef.; 5805 ; 5806 TIter next(gROOT->GetListOfClassGenerators());; 5807 TClassGenerator *gen;; 5808 while ((gen = (TClassGenerator*) next())) {; 5809 TClass *cl = gen->GetClass(requestedname, kTRUE, silent);; 5810 if (cl) {; 5811 cl->PostLoadCheck();; 5812 return cl;; 5813 }; 5814 }; 5815 return nullptr;; 5816}; 5817 ; 5818////////////////////////////////////////////////////////////////////////////////; 5819/// Try to load the ClassInfo if available. This function may require parsing; 5820/// the header file and/or loading data from the clang pcm. If further calls to; 5821/// this function cannot affect the value of fClassInfo, fCanLoadClassInfo is set; 5822/// to false.; 5823 ; 5824void TClass::LoadClassInfo() const; 5825{; 5826 R__LOCKGUARD(gInterpreterMutex);; 5827 ; 5828 // Return if another thread already loaded the info; 5829 // while we were waiting for the lock; 5830 if (!fCanLoadClassInfo || TestBit(kLoading)); 5831 return;; 5832 ; 5833 bool autoParse = !gInterpreter->IsAutoParsingSuspended();; 5834 ; 5835 if (autoParse); 5836 gInterpreter->AutoParse(GetName());; 5837 ; 5838 if (!fClassInfo); 5839 gInterpreter->SetClassInfo(const_cast<TClass *>(this));; 5840 ; 5841 if (autoParse && !fClassInfo) {; 5842",MatchSource.WIKI,doc/v632/TClass_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/TClass_8cxx_source.html
https://root.cern/doc/v632/TClass_8cxx_source.html:222975,Performance,load,loading,222975,"r 'classname'; 5795/// from the list of generator.; 5796/// If silent is 'true', do not warn about missing dictionary for the class.; 5797/// (typically used for class that are used only for transient members); 5798///; 5799/// The 'requestedname' is expected to be already normalized.; 5800 ; 5801TClass *TClass::LoadClassCustom(const char *requestedname, Bool_t silent); 5802{; 5803 // This function does not (and should not) attempt to check in the; 5804 // list of loaded classes or in the typedef.; 5805 ; 5806 TIter next(gROOT->GetListOfClassGenerators());; 5807 TClassGenerator *gen;; 5808 while ((gen = (TClassGenerator*) next())) {; 5809 TClass *cl = gen->GetClass(requestedname, kTRUE, silent);; 5810 if (cl) {; 5811 cl->PostLoadCheck();; 5812 return cl;; 5813 }; 5814 }; 5815 return nullptr;; 5816}; 5817 ; 5818////////////////////////////////////////////////////////////////////////////////; 5819/// Try to load the ClassInfo if available. This function may require parsing; 5820/// the header file and/or loading data from the clang pcm. If further calls to; 5821/// this function cannot affect the value of fClassInfo, fCanLoadClassInfo is set; 5822/// to false.; 5823 ; 5824void TClass::LoadClassInfo() const; 5825{; 5826 R__LOCKGUARD(gInterpreterMutex);; 5827 ; 5828 // Return if another thread already loaded the info; 5829 // while we were waiting for the lock; 5830 if (!fCanLoadClassInfo || TestBit(kLoading)); 5831 return;; 5832 ; 5833 bool autoParse = !gInterpreter->IsAutoParsingSuspended();; 5834 ; 5835 if (autoParse); 5836 gInterpreter->AutoParse(GetName());; 5837 ; 5838 if (!fClassInfo); 5839 gInterpreter->SetClassInfo(const_cast<TClass *>(this));; 5840 ; 5841 if (autoParse && !fClassInfo) {; 5842 if (fImplFileLine == -1 && fClassVersion == 0) {; 5843 // We have a 'transient' class with a ClassDefInline and apparently no interpreter; 5844 // information. Since it is transient, it is more than likely that the lack; 5845 // will be harmles.; 5846 } else {; 5847 ::Erro",MatchSource.WIKI,doc/v632/TClass_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/TClass_8cxx_source.html
https://root.cern/doc/v632/TClass_8cxx_source.html:223276,Performance,load,loaded,223276,"T->GetListOfClassGenerators());; 5807 TClassGenerator *gen;; 5808 while ((gen = (TClassGenerator*) next())) {; 5809 TClass *cl = gen->GetClass(requestedname, kTRUE, silent);; 5810 if (cl) {; 5811 cl->PostLoadCheck();; 5812 return cl;; 5813 }; 5814 }; 5815 return nullptr;; 5816}; 5817 ; 5818////////////////////////////////////////////////////////////////////////////////; 5819/// Try to load the ClassInfo if available. This function may require parsing; 5820/// the header file and/or loading data from the clang pcm. If further calls to; 5821/// this function cannot affect the value of fClassInfo, fCanLoadClassInfo is set; 5822/// to false.; 5823 ; 5824void TClass::LoadClassInfo() const; 5825{; 5826 R__LOCKGUARD(gInterpreterMutex);; 5827 ; 5828 // Return if another thread already loaded the info; 5829 // while we were waiting for the lock; 5830 if (!fCanLoadClassInfo || TestBit(kLoading)); 5831 return;; 5832 ; 5833 bool autoParse = !gInterpreter->IsAutoParsingSuspended();; 5834 ; 5835 if (autoParse); 5836 gInterpreter->AutoParse(GetName());; 5837 ; 5838 if (!fClassInfo); 5839 gInterpreter->SetClassInfo(const_cast<TClass *>(this));; 5840 ; 5841 if (autoParse && !fClassInfo) {; 5842 if (fImplFileLine == -1 && fClassVersion == 0) {; 5843 // We have a 'transient' class with a ClassDefInline and apparently no interpreter; 5844 // information. Since it is transient, it is more than likely that the lack; 5845 // will be harmles.; 5846 } else {; 5847 ::Error(""TClass::LoadClassInfo"", ""no interpreter information for class %s is available""; 5848 "" even though it has a TClass initialization routine."",; 5849 fName.Data());; 5850 }; 5851 return;; 5852 }; 5853 ; 5854 fCanLoadClassInfo = false;; 5855}; 5856 ; 5857////////////////////////////////////////////////////////////////////////////////; 5858/// Store class description on I/O buffer.; 5859 ; 5860void TClass::Store(TBuffer &b) const; 5861{; 5862 b.WriteString(GetName());; 5863}; 5864 ; 5865/////////////////////////////////////////",MatchSource.WIKI,doc/v632/TClass_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/TClass_8cxx_source.html
https://root.cern/doc/v632/TClass_8cxx_source.html:228433,Performance,load,loaded,228433,"Return kTRUE is the class inherits from TObject.; 5937 ; 5938Bool_t TClass::IsTObject() const; 5939{; 5940 if (fProperty==(-1)) Property();; 5941 return TestBit(kIsTObject);; 5942}; 5943 ; 5944////////////////////////////////////////////////////////////////////////////////; 5945/// Return kTRUE is the class is Foreign (the class does not have a Streamer method).; 5946 ; 5947Bool_t TClass::IsForeign() const; 5948{; 5949 if (fProperty==(-1)) Property();; 5950 // If the property are not set and the class is a pair, hard code that; 5951 // it is a unversioned/Foreign class.; 5952 return TestBit(kIsForeign);; 5953}; 5954 ; 5955////////////////////////////////////////////////////////////////////////////////; 5956/// Do the initialization that can only be done after the CINT dictionary has; 5957/// been fully populated and can not be delayed efficiently.; 5958 ; 5959void TClass::PostLoadCheck(); 5960{; 5961 // In the case of a Foreign class (loaded class without a Streamer function); 5962 // we reset fClassVersion to be -1 so that the current TVirtualStreamerInfo will not; 5963 // be confused with a previously loaded streamerInfo.; 5964 ; 5965 if (IsLoaded() && HasInterpreterInfo() && fClassVersion==1 /*&& fStreamerInfo; 5966 && fStreamerInfo->At(1)*/ && IsForeign() ); 5967 {; 5968 SetClassVersion(-1);; 5969 }; 5970 // Note: We are careful to check the class version first because checking; 5971 // for foreign can trigger an AutoParse.; 5972 else if (IsLoaded() && HasDataMemberInfo() && fStreamerInfo && ((fClassVersion > 1) || !IsForeign())); 5973 {; 5974 R__LOCKGUARD(gInterpreterMutex);; 5975 ; 5976 TVirtualStreamerInfo *info = (TVirtualStreamerInfo*)(fStreamerInfo->At(fClassVersion));; 5977 // Here we need to check whether this TVirtualStreamerInfo (which presumably has been; 5978 // loaded from a file) is consistent with the definition in the library we just loaded.; 5979 // BuildCheck is not appropriate here since it check a streamerinfo against the; 5980 // 'current st",MatchSource.WIKI,doc/v632/TClass_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/TClass_8cxx_source.html
https://root.cern/doc/v632/TClass_8cxx_source.html:228605,Performance,load,loaded,228605,"Return kTRUE is the class inherits from TObject.; 5937 ; 5938Bool_t TClass::IsTObject() const; 5939{; 5940 if (fProperty==(-1)) Property();; 5941 return TestBit(kIsTObject);; 5942}; 5943 ; 5944////////////////////////////////////////////////////////////////////////////////; 5945/// Return kTRUE is the class is Foreign (the class does not have a Streamer method).; 5946 ; 5947Bool_t TClass::IsForeign() const; 5948{; 5949 if (fProperty==(-1)) Property();; 5950 // If the property are not set and the class is a pair, hard code that; 5951 // it is a unversioned/Foreign class.; 5952 return TestBit(kIsForeign);; 5953}; 5954 ; 5955////////////////////////////////////////////////////////////////////////////////; 5956/// Do the initialization that can only be done after the CINT dictionary has; 5957/// been fully populated and can not be delayed efficiently.; 5958 ; 5959void TClass::PostLoadCheck(); 5960{; 5961 // In the case of a Foreign class (loaded class without a Streamer function); 5962 // we reset fClassVersion to be -1 so that the current TVirtualStreamerInfo will not; 5963 // be confused with a previously loaded streamerInfo.; 5964 ; 5965 if (IsLoaded() && HasInterpreterInfo() && fClassVersion==1 /*&& fStreamerInfo; 5966 && fStreamerInfo->At(1)*/ && IsForeign() ); 5967 {; 5968 SetClassVersion(-1);; 5969 }; 5970 // Note: We are careful to check the class version first because checking; 5971 // for foreign can trigger an AutoParse.; 5972 else if (IsLoaded() && HasDataMemberInfo() && fStreamerInfo && ((fClassVersion > 1) || !IsForeign())); 5973 {; 5974 R__LOCKGUARD(gInterpreterMutex);; 5975 ; 5976 TVirtualStreamerInfo *info = (TVirtualStreamerInfo*)(fStreamerInfo->At(fClassVersion));; 5977 // Here we need to check whether this TVirtualStreamerInfo (which presumably has been; 5978 // loaded from a file) is consistent with the definition in the library we just loaded.; 5979 // BuildCheck is not appropriate here since it check a streamerinfo against the; 5980 // 'current st",MatchSource.WIKI,doc/v632/TClass_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/TClass_8cxx_source.html
https://root.cern/doc/v632/TClass_8cxx_source.html:229293,Performance,load,loaded,229293,"//////////////////////////////////////; 5956/// Do the initialization that can only be done after the CINT dictionary has; 5957/// been fully populated and can not be delayed efficiently.; 5958 ; 5959void TClass::PostLoadCheck(); 5960{; 5961 // In the case of a Foreign class (loaded class without a Streamer function); 5962 // we reset fClassVersion to be -1 so that the current TVirtualStreamerInfo will not; 5963 // be confused with a previously loaded streamerInfo.; 5964 ; 5965 if (IsLoaded() && HasInterpreterInfo() && fClassVersion==1 /*&& fStreamerInfo; 5966 && fStreamerInfo->At(1)*/ && IsForeign() ); 5967 {; 5968 SetClassVersion(-1);; 5969 }; 5970 // Note: We are careful to check the class version first because checking; 5971 // for foreign can trigger an AutoParse.; 5972 else if (IsLoaded() && HasDataMemberInfo() && fStreamerInfo && ((fClassVersion > 1) || !IsForeign())); 5973 {; 5974 R__LOCKGUARD(gInterpreterMutex);; 5975 ; 5976 TVirtualStreamerInfo *info = (TVirtualStreamerInfo*)(fStreamerInfo->At(fClassVersion));; 5977 // Here we need to check whether this TVirtualStreamerInfo (which presumably has been; 5978 // loaded from a file) is consistent with the definition in the library we just loaded.; 5979 // BuildCheck is not appropriate here since it check a streamerinfo against the; 5980 // 'current streamerinfo' which, at time point, would be the same as 'info'!; 5981 if (info && GetListOfDataMembers() && !GetCollectionProxy(); 5982 && (info->GetCheckSum()!=GetCheckSum() && !info->CompareContent(this,nullptr,kFALSE,kFALSE, nullptr) && !(MatchLegacyCheckSum(info->GetCheckSum())))); 5983 {; 5984 Bool_t warn = ! TestBit(kWarned);; 5985 if (warn && info->GetOldVersion()<=2) {; 5986 // Names of STL base classes was modified in vers==3. Allocators removed; 5987 //; 5988 TIter nextBC(GetListOfBases());; 5989 TBaseClass *bc;; 5990 while ((bc=(TBaseClass*)nextBC())); 5991 {if (TClassEdit::IsSTLCont(bc->GetName())) warn = kFALSE;}; 5992 }; 5993 ; 5994 if (warn) {; 5995 ",MatchSource.WIKI,doc/v632/TClass_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/TClass_8cxx_source.html
https://root.cern/doc/v632/TClass_8cxx_source.html:229370,Performance,load,loaded,229370,"//////////////////////////////////////; 5956/// Do the initialization that can only be done after the CINT dictionary has; 5957/// been fully populated and can not be delayed efficiently.; 5958 ; 5959void TClass::PostLoadCheck(); 5960{; 5961 // In the case of a Foreign class (loaded class without a Streamer function); 5962 // we reset fClassVersion to be -1 so that the current TVirtualStreamerInfo will not; 5963 // be confused with a previously loaded streamerInfo.; 5964 ; 5965 if (IsLoaded() && HasInterpreterInfo() && fClassVersion==1 /*&& fStreamerInfo; 5966 && fStreamerInfo->At(1)*/ && IsForeign() ); 5967 {; 5968 SetClassVersion(-1);; 5969 }; 5970 // Note: We are careful to check the class version first because checking; 5971 // for foreign can trigger an AutoParse.; 5972 else if (IsLoaded() && HasDataMemberInfo() && fStreamerInfo && ((fClassVersion > 1) || !IsForeign())); 5973 {; 5974 R__LOCKGUARD(gInterpreterMutex);; 5975 ; 5976 TVirtualStreamerInfo *info = (TVirtualStreamerInfo*)(fStreamerInfo->At(fClassVersion));; 5977 // Here we need to check whether this TVirtualStreamerInfo (which presumably has been; 5978 // loaded from a file) is consistent with the definition in the library we just loaded.; 5979 // BuildCheck is not appropriate here since it check a streamerinfo against the; 5980 // 'current streamerinfo' which, at time point, would be the same as 'info'!; 5981 if (info && GetListOfDataMembers() && !GetCollectionProxy(); 5982 && (info->GetCheckSum()!=GetCheckSum() && !info->CompareContent(this,nullptr,kFALSE,kFALSE, nullptr) && !(MatchLegacyCheckSum(info->GetCheckSum())))); 5983 {; 5984 Bool_t warn = ! TestBit(kWarned);; 5985 if (warn && info->GetOldVersion()<=2) {; 5986 // Names of STL base classes was modified in vers==3. Allocators removed; 5987 //; 5988 TIter nextBC(GetListOfBases());; 5989 TBaseClass *bc;; 5990 while ((bc=(TBaseClass*)nextBC())); 5991 {if (TClassEdit::IsSTLCont(bc->GetName())) warn = kFALSE;}; 5992 }; 5993 ; 5994 if (warn) {; 5995 ",MatchSource.WIKI,doc/v632/TClass_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/TClass_8cxx_source.html
https://root.cern/doc/v632/TClass_8cxx_source.html:230502,Performance,load,loaded,230502," the; 5980 // 'current streamerinfo' which, at time point, would be the same as 'info'!; 5981 if (info && GetListOfDataMembers() && !GetCollectionProxy(); 5982 && (info->GetCheckSum()!=GetCheckSum() && !info->CompareContent(this,nullptr,kFALSE,kFALSE, nullptr) && !(MatchLegacyCheckSum(info->GetCheckSum())))); 5983 {; 5984 Bool_t warn = ! TestBit(kWarned);; 5985 if (warn && info->GetOldVersion()<=2) {; 5986 // Names of STL base classes was modified in vers==3. Allocators removed; 5987 //; 5988 TIter nextBC(GetListOfBases());; 5989 TBaseClass *bc;; 5990 while ((bc=(TBaseClass*)nextBC())); 5991 {if (TClassEdit::IsSTLCont(bc->GetName())) warn = kFALSE;}; 5992 }; 5993 ; 5994 if (warn) {; 5995 if (info->GetOnFileClassVersion()==1 && fClassVersion>1) {; 5996 Warning(""PostLoadCheck"",""\n\; 5997 The class %s transitioned from not having a specified class version\n\; 5998 to having a specified class version (the current class version is %d).\n\; 5999 However too many different non-versioned layouts of the class have\n\; 6000 already been loaded so far. To work around this problem you can\n\; 6001 load fewer 'old' file in the same ROOT session or load the C++ library\n\; 6002 describing the class %s before opening the files or increase the version\n\; 6003 number of the class for example ClassDef(%s,%d).\n\; 6004 Do not try to write objects with the current class definition,\n\; 6005 the files might not be readable.\n"",; 6006 GetName(), fClassVersion, GetName(), GetName(), fStreamerInfo->GetLast()+1);; 6007 } else {; 6008 Warning(""PostLoadCheck"",""\n\; 6009 The StreamerInfo version %d for the class %s which was read\n\; 6010 from a file previously opened has the same version as the active class\n\; 6011 but a different checksum. You should update the version to ClassDef(%s,%d).\n\; 6012 Do not try to write objects with the current class definition,\n\; 6013 the files will not be readable.\n""; 6014 , fClassVersion, GetName(), GetName(), fStreamerInfo->GetLast()+1);; 6015 }; 6016 i",MatchSource.WIKI,doc/v632/TClass_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/TClass_8cxx_source.html
https://root.cern/doc/v632/TClass_8cxx_source.html:230562,Performance,load,load,230562,"GetCheckSum() && !info->CompareContent(this,nullptr,kFALSE,kFALSE, nullptr) && !(MatchLegacyCheckSum(info->GetCheckSum())))); 5983 {; 5984 Bool_t warn = ! TestBit(kWarned);; 5985 if (warn && info->GetOldVersion()<=2) {; 5986 // Names of STL base classes was modified in vers==3. Allocators removed; 5987 //; 5988 TIter nextBC(GetListOfBases());; 5989 TBaseClass *bc;; 5990 while ((bc=(TBaseClass*)nextBC())); 5991 {if (TClassEdit::IsSTLCont(bc->GetName())) warn = kFALSE;}; 5992 }; 5993 ; 5994 if (warn) {; 5995 if (info->GetOnFileClassVersion()==1 && fClassVersion>1) {; 5996 Warning(""PostLoadCheck"",""\n\; 5997 The class %s transitioned from not having a specified class version\n\; 5998 to having a specified class version (the current class version is %d).\n\; 5999 However too many different non-versioned layouts of the class have\n\; 6000 already been loaded so far. To work around this problem you can\n\; 6001 load fewer 'old' file in the same ROOT session or load the C++ library\n\; 6002 describing the class %s before opening the files or increase the version\n\; 6003 number of the class for example ClassDef(%s,%d).\n\; 6004 Do not try to write objects with the current class definition,\n\; 6005 the files might not be readable.\n"",; 6006 GetName(), fClassVersion, GetName(), GetName(), fStreamerInfo->GetLast()+1);; 6007 } else {; 6008 Warning(""PostLoadCheck"",""\n\; 6009 The StreamerInfo version %d for the class %s which was read\n\; 6010 from a file previously opened has the same version as the active class\n\; 6011 but a different checksum. You should update the version to ClassDef(%s,%d).\n\; 6012 Do not try to write objects with the current class definition,\n\; 6013 the files will not be readable.\n""; 6014 , fClassVersion, GetName(), GetName(), fStreamerInfo->GetLast()+1);; 6015 }; 6016 info->CompareContent(this,nullptr,kTRUE,kTRUE,nullptr);; 6017 SetBit(kWarned);; 6018 }; 6019 }; 6020 }; 6021 if (fCollectionProxy) {; 6022 // Update the related pair's TClass if it has ",MatchSource.WIKI,doc/v632/TClass_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/TClass_8cxx_source.html
https://root.cern/doc/v632/TClass_8cxx_source.html:230612,Performance,load,load,230612,"GetCheckSum() && !info->CompareContent(this,nullptr,kFALSE,kFALSE, nullptr) && !(MatchLegacyCheckSum(info->GetCheckSum())))); 5983 {; 5984 Bool_t warn = ! TestBit(kWarned);; 5985 if (warn && info->GetOldVersion()<=2) {; 5986 // Names of STL base classes was modified in vers==3. Allocators removed; 5987 //; 5988 TIter nextBC(GetListOfBases());; 5989 TBaseClass *bc;; 5990 while ((bc=(TBaseClass*)nextBC())); 5991 {if (TClassEdit::IsSTLCont(bc->GetName())) warn = kFALSE;}; 5992 }; 5993 ; 5994 if (warn) {; 5995 if (info->GetOnFileClassVersion()==1 && fClassVersion>1) {; 5996 Warning(""PostLoadCheck"",""\n\; 5997 The class %s transitioned from not having a specified class version\n\; 5998 to having a specified class version (the current class version is %d).\n\; 5999 However too many different non-versioned layouts of the class have\n\; 6000 already been loaded so far. To work around this problem you can\n\; 6001 load fewer 'old' file in the same ROOT session or load the C++ library\n\; 6002 describing the class %s before opening the files or increase the version\n\; 6003 number of the class for example ClassDef(%s,%d).\n\; 6004 Do not try to write objects with the current class definition,\n\; 6005 the files might not be readable.\n"",; 6006 GetName(), fClassVersion, GetName(), GetName(), fStreamerInfo->GetLast()+1);; 6007 } else {; 6008 Warning(""PostLoadCheck"",""\n\; 6009 The StreamerInfo version %d for the class %s which was read\n\; 6010 from a file previously opened has the same version as the active class\n\; 6011 but a different checksum. You should update the version to ClassDef(%s,%d).\n\; 6012 Do not try to write objects with the current class definition,\n\; 6013 the files will not be readable.\n""; 6014 , fClassVersion, GetName(), GetName(), fStreamerInfo->GetLast()+1);; 6015 }; 6016 info->CompareContent(this,nullptr,kTRUE,kTRUE,nullptr);; 6017 SetBit(kWarned);; 6018 }; 6019 }; 6020 }; 6021 if (fCollectionProxy) {; 6022 // Update the related pair's TClass if it has ",MatchSource.WIKI,doc/v632/TClass_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/TClass_8cxx_source.html
https://root.cern/doc/v632/TClass_8cxx_source.html:233259,Performance,cache,cache,233259,"8 TInterpreter::SuspendAutoLoadingRAII autoloadOff(gInterpreter);; 6039 ; 6040 fCollectionProxy->Reset();; 6041 TIter nextClass(gROOT->GetListOfClasses());; 6042 while (auto acl = (TClass*)nextClass()) {; 6043 if (acl == this) continue;; 6044 if (acl->fCollectionProxy && acl->fCollectionProxy->GetValueClass() == pcl) {; 6045 acl->fCollectionProxy->Reset();; 6046 }; 6047 }; 6048 ; 6049 TIter next(pcl->GetStreamerInfos());; 6050 while (auto info = (TVirtualStreamerInfo*)next()) {; 6051 if (info->IsBuilt()) {; 6052 info->Clear(""build"");; 6053 info->BuildOld();; 6054 }; 6055 }; 6056 fCollectionProxy->GetValueClass();; 6057 }; 6058 }; 6059 }; 6060}; 6061 ; 6062////////////////////////////////////////////////////////////////////////////////; 6063/// Returns the properties of the TClass as a bit field stored as a `Long_t` value.; 6064///; 6065/// The bit values used for the return value are defined in the enum EProperty (in TDictionary.h); 6066///; 6067/// Also sets `TObject::fBits` and `fStreamerType` to cache information about the; 6068/// class. The bits stored in `TObject::fBits` are; 6069/// ~~~ {.cpp}; 6070/// kIsTObject : the class inherits from TObject; 6071/// kStartWithTObject: TObject is the left-most class in the inheritance tree; 6072/// kIsForeign : the class doe not have a Streamer method; 6073/// ~~~; 6074/// The value of `fStreamerType` are; 6075/// ~~~ {.cpp}; 6076/// kTObject : the class inherits from TObject; 6077/// kForeign : the class does not have a Streamer method; 6078/// kInstrumented: the class does have a Streamer method; 6079/// kExternal: the class has a free standing way of streaming itself; 6080/// kEmulatedStreamer: the class is missing its shared library.; 6081/// ~~~; 6082///; 6083/// Implementation note: the data member fProperty has the value -1; 6084/// until it is initialized.; 6085 ; 6086Long_t TClass::Property() const; 6087{; 6088 // Check if we can return without taking the lock,; 6089 // this is valid since fProperty is atomic an",MatchSource.WIKI,doc/v632/TClass_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/TClass_8cxx_source.html
https://root.cern/doc/v632/TClass_8cxx_source.html:237208,Performance,load,load,237208,"mpl = &TClass::StreamerStreamerInfo;; 6133 ; 6134 } else if ( kl->fStreamerType == TClass::kDefault ) {; 6135 if (kl->fConvStreamerFunc) {; 6136 kl->fStreamerType = kInstrumented;; 6137 kl->fStreamerImpl = &TClass::ConvStreamerInstrumented;; 6138 } else if (kl->fStreamerFunc) {; 6139 kl->fStreamerType = kInstrumented;; 6140 kl->fStreamerImpl = &TClass::StreamerInstrumented;; 6141 } else {; 6142 // We have an automatic streamer using the StreamerInfo .. no need to go through the; 6143 // Streamer method function itself.; 6144 kl->fStreamerType = kInstrumented;; 6145 kl->fStreamerImpl = &TClass::StreamerStreamerInfo;; 6146 }; 6147 }; 6148 ; 6149 if (fStreamer) {; 6150 kl->fStreamerType = kExternal;; 6151 kl->fStreamerImpl = &TClass::StreamerExternal;; 6152 }; 6153 ; 6154 if (const_cast<TClass *>(this)->GetClassMethodWithPrototype(""Hash"", """", kTRUE)) {; 6155 kl->SetBit(kHasLocalHashMember);; 6156 }; 6157 ; 6158 if (GetClassInfo()) {; 6159 // In the case where the TClass for one of ROOT's core class; 6160 // (eg TClonesArray for map<int,TClonesArray*>) is requested; 6161 // during the execution of rootcling, we could end up in a situation; 6162 // where we should have the information (since TClonesArray has; 6163 // a dictionary as part of libCore) but do not because the user; 6164 // only include a forward declaration of TClonesArray and we do not; 6165 // forcefully load the header file either (because the autoparsing; 6166 // is intentionally disabled).; 6167 kl->fClassProperty = gCling->ClassInfo_ClassProperty(fClassInfo);; 6168 // Must set this last since other threads may read fProperty; 6169 // and think all test bits have been properly set.; 6170 kl->fProperty = gCling->ClassInfo_Property(fClassInfo);; 6171 }; 6172 } else {; 6173 ; 6174 if (fStreamer) {; 6175 kl->fStreamerType = kExternal;; 6176 kl->fStreamerImpl = &TClass::StreamerExternal;; 6177 }; 6178 ; 6179 kl->fStreamerType |= kEmulatedStreamer;; 6180 kl->SetStreamerImpl();; 6181 // fProperty was *not* set",MatchSource.WIKI,doc/v632/TClass_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/TClass_8cxx_source.html
https://root.cern/doc/v632/TClass_8cxx_source.html:244031,Performance,load,load,244031,"312 // Don't redo the work.; 6313 return;; 6314 }; 6315 SetBit(kUnloading);; 6316 ; 6317 //R__ASSERT(fState == kLoaded);; 6318 if (fState != kLoaded) {; 6319 Fatal(""SetUnloaded"",""The TClass for %s is being unloaded when in state %d\n"",; 6320 GetName(),(int)fState);; 6321 }; 6322 ; 6323 InsertTClassInRegistryRAII insertRAII(fState, fName, fNoInfoOrEmuOrFwdDeclNameRegistry);; 6324 ; 6325 // Make sure SetClassInfo, re-calculated the state.; 6326 fState = kForwardDeclared;; 6327 ; 6328 delete fIsA; fIsA = nullptr;; 6329 // Disable the autoloader while calling SetClassInfo, to prevent; 6330 // the library from being reloaded!; 6331 {; 6332 TInterpreter::SuspendAutoLoadingRAII autoloadOff(gInterpreter);; 6333 TInterpreter::SuspendAutoParsing autoParseRaii(gCling);; 6334 gInterpreter->SetClassInfo(this,kTRUE);; 6335 }; 6336 fDeclFileName = nullptr;; 6337 fDeclFileLine = 0;; 6338 fImplFileName = nullptr;; 6339 fImplFileLine = 0;; 6340 fTypeInfo = nullptr;; 6341 ; 6342 if (fMethod.load()) {; 6343 (*fMethod).Unload();; 6344 }; 6345 if (fData.load()) {; 6346 (*fData).Unload();; 6347 }; 6348 if (fUsingData.load()) {; 6349 (*fUsingData).Unload();; 6350 }; 6351 if (fEnums.load()) {; 6352 (*fEnums).Unload();; 6353 }; 6354 ; 6355 if (fState <= kForwardDeclared && !fStreamerInfo->IsEmpty()) {; 6356 fState = kEmulated;; 6357 }; 6358 ; 6359 ResetBit(kUnloading);; 6360 SetBit(kUnloaded);; 6361}; 6362 ; 6363////////////////////////////////////////////////////////////////////////////////; 6364/// Info is a string describing the names and types of attributes; 6365/// written by the class Streamer function.; 6366/// If info is an empty string (when called by TObject::StreamerInfo); 6367/// the default Streamer info string is build. This corresponds to; 6368/// the case of an automatically generated Streamer.; 6369/// In case of user defined Streamer function, it is the user responsibility; 6370/// to implement a StreamerInfo function (override TObject::StreamerInfo).; 6371/// The user must ",MatchSource.WIKI,doc/v632/TClass_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/TClass_8cxx_source.html
https://root.cern/doc/v632/TClass_8cxx_source.html:244092,Performance,load,load,244092,"it(kUnloading);; 6316 ; 6317 //R__ASSERT(fState == kLoaded);; 6318 if (fState != kLoaded) {; 6319 Fatal(""SetUnloaded"",""The TClass for %s is being unloaded when in state %d\n"",; 6320 GetName(),(int)fState);; 6321 }; 6322 ; 6323 InsertTClassInRegistryRAII insertRAII(fState, fName, fNoInfoOrEmuOrFwdDeclNameRegistry);; 6324 ; 6325 // Make sure SetClassInfo, re-calculated the state.; 6326 fState = kForwardDeclared;; 6327 ; 6328 delete fIsA; fIsA = nullptr;; 6329 // Disable the autoloader while calling SetClassInfo, to prevent; 6330 // the library from being reloaded!; 6331 {; 6332 TInterpreter::SuspendAutoLoadingRAII autoloadOff(gInterpreter);; 6333 TInterpreter::SuspendAutoParsing autoParseRaii(gCling);; 6334 gInterpreter->SetClassInfo(this,kTRUE);; 6335 }; 6336 fDeclFileName = nullptr;; 6337 fDeclFileLine = 0;; 6338 fImplFileName = nullptr;; 6339 fImplFileLine = 0;; 6340 fTypeInfo = nullptr;; 6341 ; 6342 if (fMethod.load()) {; 6343 (*fMethod).Unload();; 6344 }; 6345 if (fData.load()) {; 6346 (*fData).Unload();; 6347 }; 6348 if (fUsingData.load()) {; 6349 (*fUsingData).Unload();; 6350 }; 6351 if (fEnums.load()) {; 6352 (*fEnums).Unload();; 6353 }; 6354 ; 6355 if (fState <= kForwardDeclared && !fStreamerInfo->IsEmpty()) {; 6356 fState = kEmulated;; 6357 }; 6358 ; 6359 ResetBit(kUnloading);; 6360 SetBit(kUnloaded);; 6361}; 6362 ; 6363////////////////////////////////////////////////////////////////////////////////; 6364/// Info is a string describing the names and types of attributes; 6365/// written by the class Streamer function.; 6366/// If info is an empty string (when called by TObject::StreamerInfo); 6367/// the default Streamer info string is build. This corresponds to; 6368/// the case of an automatically generated Streamer.; 6369/// In case of user defined Streamer function, it is the user responsibility; 6370/// to implement a StreamerInfo function (override TObject::StreamerInfo).; 6371/// The user must call IsA()->SetStreamerInfo(info) from this function.; 6372 ",MatchSource.WIKI,doc/v632/TClass_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/TClass_8cxx_source.html
https://root.cern/doc/v632/TClass_8cxx_source.html:244156,Performance,load,load,244156,"if (fState != kLoaded) {; 6319 Fatal(""SetUnloaded"",""The TClass for %s is being unloaded when in state %d\n"",; 6320 GetName(),(int)fState);; 6321 }; 6322 ; 6323 InsertTClassInRegistryRAII insertRAII(fState, fName, fNoInfoOrEmuOrFwdDeclNameRegistry);; 6324 ; 6325 // Make sure SetClassInfo, re-calculated the state.; 6326 fState = kForwardDeclared;; 6327 ; 6328 delete fIsA; fIsA = nullptr;; 6329 // Disable the autoloader while calling SetClassInfo, to prevent; 6330 // the library from being reloaded!; 6331 {; 6332 TInterpreter::SuspendAutoLoadingRAII autoloadOff(gInterpreter);; 6333 TInterpreter::SuspendAutoParsing autoParseRaii(gCling);; 6334 gInterpreter->SetClassInfo(this,kTRUE);; 6335 }; 6336 fDeclFileName = nullptr;; 6337 fDeclFileLine = 0;; 6338 fImplFileName = nullptr;; 6339 fImplFileLine = 0;; 6340 fTypeInfo = nullptr;; 6341 ; 6342 if (fMethod.load()) {; 6343 (*fMethod).Unload();; 6344 }; 6345 if (fData.load()) {; 6346 (*fData).Unload();; 6347 }; 6348 if (fUsingData.load()) {; 6349 (*fUsingData).Unload();; 6350 }; 6351 if (fEnums.load()) {; 6352 (*fEnums).Unload();; 6353 }; 6354 ; 6355 if (fState <= kForwardDeclared && !fStreamerInfo->IsEmpty()) {; 6356 fState = kEmulated;; 6357 }; 6358 ; 6359 ResetBit(kUnloading);; 6360 SetBit(kUnloaded);; 6361}; 6362 ; 6363////////////////////////////////////////////////////////////////////////////////; 6364/// Info is a string describing the names and types of attributes; 6365/// written by the class Streamer function.; 6366/// If info is an empty string (when called by TObject::StreamerInfo); 6367/// the default Streamer info string is build. This corresponds to; 6368/// the case of an automatically generated Streamer.; 6369/// In case of user defined Streamer function, it is the user responsibility; 6370/// to implement a StreamerInfo function (override TObject::StreamerInfo).; 6371/// The user must call IsA()->SetStreamerInfo(info) from this function.; 6372 ; 6373TVirtualStreamerInfo *TClass::SetStreamerInfo(Int_t /*versio",MatchSource.WIKI,doc/v632/TClass_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/TClass_8cxx_source.html
https://root.cern/doc/v632/TClass_8cxx_source.html:244221,Performance,load,load,244221,"for %s is being unloaded when in state %d\n"",; 6320 GetName(),(int)fState);; 6321 }; 6322 ; 6323 InsertTClassInRegistryRAII insertRAII(fState, fName, fNoInfoOrEmuOrFwdDeclNameRegistry);; 6324 ; 6325 // Make sure SetClassInfo, re-calculated the state.; 6326 fState = kForwardDeclared;; 6327 ; 6328 delete fIsA; fIsA = nullptr;; 6329 // Disable the autoloader while calling SetClassInfo, to prevent; 6330 // the library from being reloaded!; 6331 {; 6332 TInterpreter::SuspendAutoLoadingRAII autoloadOff(gInterpreter);; 6333 TInterpreter::SuspendAutoParsing autoParseRaii(gCling);; 6334 gInterpreter->SetClassInfo(this,kTRUE);; 6335 }; 6336 fDeclFileName = nullptr;; 6337 fDeclFileLine = 0;; 6338 fImplFileName = nullptr;; 6339 fImplFileLine = 0;; 6340 fTypeInfo = nullptr;; 6341 ; 6342 if (fMethod.load()) {; 6343 (*fMethod).Unload();; 6344 }; 6345 if (fData.load()) {; 6346 (*fData).Unload();; 6347 }; 6348 if (fUsingData.load()) {; 6349 (*fUsingData).Unload();; 6350 }; 6351 if (fEnums.load()) {; 6352 (*fEnums).Unload();; 6353 }; 6354 ; 6355 if (fState <= kForwardDeclared && !fStreamerInfo->IsEmpty()) {; 6356 fState = kEmulated;; 6357 }; 6358 ; 6359 ResetBit(kUnloading);; 6360 SetBit(kUnloaded);; 6361}; 6362 ; 6363////////////////////////////////////////////////////////////////////////////////; 6364/// Info is a string describing the names and types of attributes; 6365/// written by the class Streamer function.; 6366/// If info is an empty string (when called by TObject::StreamerInfo); 6367/// the default Streamer info string is build. This corresponds to; 6368/// the case of an automatically generated Streamer.; 6369/// In case of user defined Streamer function, it is the user responsibility; 6370/// to implement a StreamerInfo function (override TObject::StreamerInfo).; 6371/// The user must call IsA()->SetStreamerInfo(info) from this function.; 6372 ; 6373TVirtualStreamerInfo *TClass::SetStreamerInfo(Int_t /*version*/, const char * /*info*/); 6374{; 6375 // info is specified, ",MatchSource.WIKI,doc/v632/TClass_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/TClass_8cxx_source.html
https://root.cern/doc/v632/TClass_8cxx_source.html:251808,Performance,load,load,251808,"// - kNoRange: return the checksum of data members and base classes, not including the ranges and array size found in comments.; 6535/// - kWithTypeDef: use the sugared type name in the calculation.; 6536///; 6537/// This is needed for backward compatibility.; 6538///; 6539/// WARNING: this function must be kept in sync with TStreamerInfo::GetCheckSum.; 6540/// They are both used to handle backward compatibility and should both return the same values.; 6541/// TStreamerInfo uses the information in TStreamerElement while TClass uses the information; 6542/// from TClass::GetListOfBases and TClass::GetListOfDataMembers.; 6543 ; 6544UInt_t TClass::GetCheckSum(ECheckSum code, Bool_t &isvalid) const; 6545{; 6546 // fCheckSum is an atomic variable. Also once it has; 6547 // transition from a zero Value it never changes. If two; 6548 // thread reach past this if statement and calculated the; 6549 // 'kLastestCheckSum', they will by definition obtain the; 6550 // same value, so technically we could simply have:; 6551 // if (fCheckSum && code == kCurrentCheckSum) return fCheckSum;; 6552 // However save a little bit of barrier time by calling load(); 6553 // only once.; 6554 ; 6555 isvalid = kTRUE;; 6556 ; 6557 UInt_t currentChecksum = fCheckSum.load();; 6558 if (currentChecksum && code == kCurrentCheckSum) return currentChecksum;; 6559 ; 6560 R__LOCKGUARD(gInterpreterMutex);; 6561 ; 6562 // kCurrentCheckSum (0) is the default parameter value and should be kept; 6563 // for backward compatibility, too be able to use the inequality checks,; 6564 // we need to set the code to the largest value.; 6565 if (code == kCurrentCheckSum) code = kLatestCheckSum;; 6566 ; 6567 UInt_t id = 0;; 6568 ; 6569 int il;; 6570 TString name = GetName();; 6571 TString type;; 6572 il = name.Length();; 6573 for (int i=0; i<il; i++) id = id*3+name[i];; 6574 ; 6575 // Here we skip he base classes in case this is a pair or STL collection,; 6576 // otherwise, on some STL implementations, it can happen that",MatchSource.WIKI,doc/v632/TClass_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/TClass_8cxx_source.html
https://root.cern/doc/v632/TClass_8cxx_source.html:251913,Performance,load,load,251913," return the same values.; 6541/// TStreamerInfo uses the information in TStreamerElement while TClass uses the information; 6542/// from TClass::GetListOfBases and TClass::GetListOfDataMembers.; 6543 ; 6544UInt_t TClass::GetCheckSum(ECheckSum code, Bool_t &isvalid) const; 6545{; 6546 // fCheckSum is an atomic variable. Also once it has; 6547 // transition from a zero Value it never changes. If two; 6548 // thread reach past this if statement and calculated the; 6549 // 'kLastestCheckSum', they will by definition obtain the; 6550 // same value, so technically we could simply have:; 6551 // if (fCheckSum && code == kCurrentCheckSum) return fCheckSum;; 6552 // However save a little bit of barrier time by calling load(); 6553 // only once.; 6554 ; 6555 isvalid = kTRUE;; 6556 ; 6557 UInt_t currentChecksum = fCheckSum.load();; 6558 if (currentChecksum && code == kCurrentCheckSum) return currentChecksum;; 6559 ; 6560 R__LOCKGUARD(gInterpreterMutex);; 6561 ; 6562 // kCurrentCheckSum (0) is the default parameter value and should be kept; 6563 // for backward compatibility, too be able to use the inequality checks,; 6564 // we need to set the code to the largest value.; 6565 if (code == kCurrentCheckSum) code = kLatestCheckSum;; 6566 ; 6567 UInt_t id = 0;; 6568 ; 6569 int il;; 6570 TString name = GetName();; 6571 TString type;; 6572 il = name.Length();; 6573 for (int i=0; i<il; i++) id = id*3+name[i];; 6574 ; 6575 // Here we skip he base classes in case this is a pair or STL collection,; 6576 // otherwise, on some STL implementations, it can happen that pair has; 6577 // base classes which are an internal implementation detail.; 6578 TList *tlb = ((TClass*)this)->GetListOfBases();; 6579 if (tlb && !GetCollectionProxy() && !TClassEdit::IsStdPair(GetName())) {; 6580 // Loop over bases if not a proxied collection or a pair; 6581 ; 6582 TIter nextBase(tlb);; 6583 ; 6584 TBaseClass *tbc=nullptr;; 6585 while((tbc=(TBaseClass*)nextBase())) {; 6586 name = tbc->GetName();; 6587 Bool_t ",MatchSource.WIKI,doc/v632/TClass_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/TClass_8cxx_source.html
https://root.cern/doc/v632/TClass_8cxx_source.html:264274,Performance,load,load,264274,"65 b.WriteClassBuffer(pThis, object);; 6866 }; 6867}; 6868 ; 6869////////////////////////////////////////////////////////////////////////////////; 6870/// Default streaming in cases where either we have no way to know what to do; 6871/// or if Property() has not yet been called.; 6872 ; 6873void TClass::StreamerDefault(const TClass* pThis, void *object, TBuffer &b, const TClass *onfile_class); 6874{; 6875 if (pThis->fProperty==(-1)) {; 6876 pThis->Property();; 6877 }; 6878 ; 6879 // We could get here because after this thread started StreamerDefault; 6880 // *and* before check fProperty, another thread might have call Property; 6881 // and this fProperty when we read it, is not -1 and fStreamerImpl is; 6882 // supposed to be set properly (no longer pointing to the default).; 6883 if (pThis->fStreamerImpl.load() == &TClass::StreamerDefault) {; 6884 pThis->Fatal(""StreamerDefault"", ""fStreamerImpl not properly initialized (%d)"", pThis->fStreamerType);; 6885 } else {; 6886 (*pThis->fStreamerImpl)(pThis,object,b,onfile_class);; 6887 }; 6888}; 6889 ; 6890////////////////////////////////////////////////////////////////////////////////; 6891/// Adopt a TClassStreamer object. Ownership is transfered to this TClass; 6892/// object.; 6893 ; 6894void TClass::AdoptStreamer(TClassStreamer *str); 6895{; 6896// // This code can be used to quickly test the STL Emulation layer; 6897// Int_t k = TClassEdit::IsSTLCont(GetName());; 6898// if (k==1||k==-1) { delete str; return; }; 6899 ; 6900 R__LOCKGUARD(gInterpreterMutex);; 6901 ; 6902 if (fStreamer) delete fStreamer;; 6903 if (str) {; 6904 fStreamerType = kExternal | ( fStreamerType&kEmulatedStreamer );; 6905 fStreamer = str;; 6906 fStreamerImpl = &TClass::StreamerExternal;; 6907 } else if (fStreamer) {; 6908 // Case where there was a custom streamer and it is hereby removed,; 6909 // we need to reset fStreamerType; 6910 fStreamer = str;; 6911 fStreamerType = TClass::kDefault;; 6912 if (fProperty != -1) {; 6913 fProperty = -1;; 6914 Pr",MatchSource.WIKI,doc/v632/TClass_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/TClass_8cxx_source.html
https://root.cern/doc/v632/TClass_8cxx_source.html:272952,Performance,load,load,272952,"///////////////////////////////////////////////////////; 7095/// Return a Conversion StreamerInfo from the class represented by cl for version number 'version' to this class, if any.; 7096 ; 7097TVirtualStreamerInfo *TClass::GetConversionStreamerInfo( const TClass* cl, Int_t version ) const; 7098{; 7099 //----------------------------------------------------------------------------; 7100 // Check if the classname was specified correctly; 7101 /////////////////////////////////////////////////////////////////////////////; 7102 ; 7103 if( !cl ); 7104 return nullptr;; 7105 ; 7106 if( cl == this ); 7107 return GetStreamerInfo( version );; 7108 ; 7109 //----------------------------------------------------------------------------; 7110 // Check if we already have it; 7111 /////////////////////////////////////////////////////////////////////////////; 7112 ; 7113 TObjArray* arr = nullptr;; 7114 if (fConversionStreamerInfo.load()) {; 7115 std::map<std::string, TObjArray*>::iterator it;; 7116 R__LOCKGUARD(gInterpreterMutex);; 7117 ; 7118 it = (*fConversionStreamerInfo).find( cl->GetName() );; 7119 ; 7120 if( it != (*fConversionStreamerInfo).end() ) {; 7121 arr = it->second;; 7122 }; 7123 ; 7124 if( arr && version >= -1 && version < arr->GetSize() && arr->At( version ) ); 7125 return (TVirtualStreamerInfo*) arr->At( version );; 7126 }; 7127 ; 7128 R__LOCKGUARD(gInterpreterMutex);; 7129 ; 7130 //----------------------------------------------------------------------------; 7131 // We don't have the streamer info so find it in other class; 7132 /////////////////////////////////////////////////////////////////////////////; 7133 ; 7134 const TObjArray *clSI = cl->GetStreamerInfos();; 7135 TVirtualStreamerInfo* info = nullptr;; 7136 if( version >= -1 && version < clSI->GetSize() ); 7137 info = (TVirtualStreamerInfo*)clSI->At( version );; 7138 ; 7139 if (!info && cl->GetCollectionProxy()) {; 7140 info = cl->GetStreamerInfo(); // instantiate the StreamerInfo for STL collections.; 7141 }",MatchSource.WIKI,doc/v632/TClass_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/TClass_8cxx_source.html
https://root.cern/doc/v632/TClass_8cxx_source.html:275354,Performance,load,load,275354,"e info;; 7160 return nullptr;; 7161 }; 7162 ; 7163 if (!info->IsCompiled()) {; 7164 // Streamer info has not been compiled, but exists.; 7165 // Therefore it was read in from a file and we have to do schema evolution?; 7166 // Or it didn't have a dictionary before, but does now?; 7167 info->BuildOld();; 7168 }; 7169 ; 7170 //----------------------------------------------------------------------------; 7171 // Cache this streamer info; 7172 /////////////////////////////////////////////////////////////////////////////; 7173 ; 7174 if (!arr) {; 7175 arr = new TObjArray(version+10, -1);; 7176 if (!fConversionStreamerInfo.load()) {; 7177 fConversionStreamerInfo = new std::map<std::string, TObjArray*>();; 7178 }; 7179 (*fConversionStreamerInfo)[cl->GetName()] = arr;; 7180 }; 7181 if (arr->At(info->GetClassVersion())) {; 7182 Error(""GetConversionStreamerInfo"", ""Conversion StreamerInfo from %s to %s version %d has already been created"",; 7183 this->GetName(), info->GetName(), info->GetClassVersion());; 7184 delete arr->At(info->GetClassVersion());; 7185 }; 7186 arr->AddAtAndExpand( info, info->GetClassVersion() );; 7187 return info;; 7188}; 7189 ; 7190////////////////////////////////////////////////////////////////////////////////; 7191/// Return a Conversion StreamerInfo from the class 'classname' for the layout represented by 'checksum' to this class, if any.; 7192 ; 7193TVirtualStreamerInfo *TClass::FindConversionStreamerInfo( const char* classname, UInt_t checksum ) const; 7194{; 7195 TClass *cl = TClass::GetClass( classname );; 7196 if( !cl ); 7197 return nullptr;; 7198 return FindConversionStreamerInfo( cl, checksum );; 7199}; 7200 ; 7201////////////////////////////////////////////////////////////////////////////////; 7202/// Return a Conversion StreamerInfo from the class represented by cl for the layout represented by 'checksum' to this class, if any.; 7203 ; 7204TVirtualStreamerInfo *TClass::FindConversionStreamerInfo( const TClass* cl, UInt_t checksum ) const; 720",MatchSource.WIKI,doc/v632/TClass_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/TClass_8cxx_source.html
https://root.cern/doc/v632/TClass_8cxx_source.html:277404,Performance,load,load,277404,"/ Return a Conversion StreamerInfo from the class represented by cl for the layout represented by 'checksum' to this class, if any.; 7203 ; 7204TVirtualStreamerInfo *TClass::FindConversionStreamerInfo( const TClass* cl, UInt_t checksum ) const; 7205{; 7206 //---------------------------------------------------------------------------; 7207 // Check if the classname was specified correctly; 7208 /////////////////////////////////////////////////////////////////////////////; 7209 ; 7210 if( !cl ); 7211 return nullptr;; 7212 ; 7213 if( cl == this ); 7214 return FindStreamerInfo( checksum );; 7215 ; 7216 //----------------------------------------------------------------------------; 7217 // Check if we already have it; 7218 /////////////////////////////////////////////////////////////////////////////; 7219 ; 7220 TObjArray* arr = nullptr;; 7221 TVirtualStreamerInfo* info = nullptr;; 7222 if (fConversionStreamerInfo.load()) {; 7223 std::map<std::string, TObjArray*>::iterator it;; 7224 ; 7225 R__LOCKGUARD(gInterpreterMutex);; 7226 ; 7227 it = (*fConversionStreamerInfo).find( cl->GetName() );; 7228 ; 7229 if( it != (*fConversionStreamerInfo).end() ) {; 7230 arr = it->second;; 7231 }; 7232 if (arr) {; 7233 info = FindStreamerInfo( arr, checksum );; 7234 }; 7235 }; 7236 ; 7237 if( info ); 7238 return info;; 7239 ; 7240 R__LOCKGUARD(gInterpreterMutex);; 7241 ; 7242 //----------------------------------------------------------------------------; 7243 // Get it from the foreign class; 7244 /////////////////////////////////////////////////////////////////////////////; 7245 ; 7246 info = cl->FindStreamerInfo( checksum );; 7247 ; 7248 if( !info ); 7249 return nullptr;; 7250 ; 7251 //----------------------------------------------------------------------------; 7252 // We have the right info so we need to clone it to create new object with; 7253 // non artificial streamer elements and we should build it for current class; 7254 ////////////////////////////////////////////////////////////",MatchSource.WIKI,doc/v632/TClass_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/TClass_8cxx_source.html
https://root.cern/doc/v632/TClass_8cxx_source.html:279477,Performance,load,load,279477,"alue of the version, let's restore the sign.; 7261 if (version == -1); 7262 info->SetClassVersion(-1);; 7263 ; 7264 if( !info->BuildFor( this ) ) {; 7265 delete info;; 7266 return nullptr;; 7267 }; 7268 ; 7269 if (!info->IsCompiled()) {; 7270 // Streamer info has not been compiled, but exists.; 7271 // Therefore it was read in from a file and we have to do schema evolution?; 7272 // Or it didn't have a dictionary before, but does now?; 7273 info->BuildOld();; 7274 }; 7275 ; 7276 //----------------------------------------------------------------------------; 7277 // Cache this streamer info; 7278 /////////////////////////////////////////////////////////////////////////////; 7279 ; 7280 if (!arr) {; 7281 arr = new TObjArray(16, -2);; 7282 if (!fConversionStreamerInfo.load()) {; 7283 fConversionStreamerInfo = new std::map<std::string, TObjArray*>();; 7284 }; 7285 (*fConversionStreamerInfo)[cl->GetName()] = arr;; 7286 }; 7287 arr->AddAtAndExpand( info, info->GetClassVersion() );; 7288 ; 7289 return info;; 7290}; 7291 ; 7292////////////////////////////////////////////////////////////////////////////////; 7293/// Register the StreamerInfo in the given slot, change the State of the; 7294/// TClass as appropriate.; 7295 ; 7296void TClass::RegisterStreamerInfo(TVirtualStreamerInfo *info); 7297{; 7298 if (info) {; 7299 R__LOCKGUARD(gInterpreterMutex);; 7300 Int_t slot = info->GetClassVersion();; 7301 if (fStreamerInfo->GetSize() > (slot-fStreamerInfo->LowerBound()); 7302 && fStreamerInfo->At(slot) != nullptr; 7303 && fStreamerInfo->At(slot) != info) {; 7304 Error(""RegisterStreamerInfo"",; 7305 ""Register StreamerInfo for %s on non-empty slot (%d)."",; 7306 GetName(),slot);; 7307 }; 7308 fStreamerInfo->AddAtAndExpand(info, slot);; 7309 if (fState <= kForwardDeclared) {; 7310 fState = kEmulated;; 7311 if (fCheckSum==0 && slot==fClassVersion) fCheckSum = info->GetCheckSum();; 7312 }; 7313 }; 7314}; 7315 ; 7316//////////////////////////////////////////////////////////////////////////",MatchSource.WIKI,doc/v632/TClass_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/TClass_8cxx_source.html
https://root.cern/doc/v632/TClass_8cxx_source.html:281111,Performance,load,load,281111,"(slot-fStreamerInfo->LowerBound()); 7302 && fStreamerInfo->At(slot) != nullptr; 7303 && fStreamerInfo->At(slot) != info) {; 7304 Error(""RegisterStreamerInfo"",; 7305 ""Register StreamerInfo for %s on non-empty slot (%d)."",; 7306 GetName(),slot);; 7307 }; 7308 fStreamerInfo->AddAtAndExpand(info, slot);; 7309 if (fState <= kForwardDeclared) {; 7310 fState = kEmulated;; 7311 if (fCheckSum==0 && slot==fClassVersion) fCheckSum = info->GetCheckSum();; 7312 }; 7313 }; 7314}; 7315 ; 7316////////////////////////////////////////////////////////////////////////////////; 7317/// Remove and delete the StreamerInfo in the given slot.; 7318/// Update the slot accordingly.; 7319 ; 7320void TClass::RemoveStreamerInfo(Int_t slot); 7321{; 7322 if (fStreamerInfo->GetSize() >= slot) {; 7323 R__LOCKGUARD(gInterpreterMutex);; 7324 TVirtualStreamerInfo *info = (TVirtualStreamerInfo*)fStreamerInfo->At(slot);; 7325 fStreamerInfo->RemoveAt(fClassVersion);; 7326 if (fLastReadInfo.load() == info); 7327 fLastReadInfo = nullptr;; 7328 if (fCurrentInfo.load() == info); 7329 fCurrentInfo = nullptr;; 7330 delete info;; 7331 if (fState == kEmulated && fStreamerInfo->GetEntries() == 0) {; 7332 fState = kForwardDeclared;; 7333 }; 7334 }; 7335}; 7336 ; 7337////////////////////////////////////////////////////////////////////////////////; 7338/// Return true is the Hash/RecursiveRemove setup is consistent, i.e. when all; 7339/// classes in the class hierarchy that overload TObject::Hash do call; 7340/// ROOT::CallRecursiveRemoveIfNeeded in their destructor.; 7341/// i.e. it is safe to call the Hash virtual function during the RecursiveRemove operation.; 7342/// This routines is used for a small subset of the class for which we need; 7343/// the answer before gROOT is properly initialized.; 7344 ; 7345Bool_t ROOT::Internal::HasConsistentHashMember(const char *cname); 7346{; 7347 // Hand selection of correct classes, those classes should be; 7348 // cross-checked in testHashRecursiveRemove.cxx; 7349 static co",MatchSource.WIKI,doc/v632/TClass_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/TClass_8cxx_source.html
https://root.cern/doc/v632/TClass_8cxx_source.html:281181,Performance,load,load,281181," (%d)."",; 7306 GetName(),slot);; 7307 }; 7308 fStreamerInfo->AddAtAndExpand(info, slot);; 7309 if (fState <= kForwardDeclared) {; 7310 fState = kEmulated;; 7311 if (fCheckSum==0 && slot==fClassVersion) fCheckSum = info->GetCheckSum();; 7312 }; 7313 }; 7314}; 7315 ; 7316////////////////////////////////////////////////////////////////////////////////; 7317/// Remove and delete the StreamerInfo in the given slot.; 7318/// Update the slot accordingly.; 7319 ; 7320void TClass::RemoveStreamerInfo(Int_t slot); 7321{; 7322 if (fStreamerInfo->GetSize() >= slot) {; 7323 R__LOCKGUARD(gInterpreterMutex);; 7324 TVirtualStreamerInfo *info = (TVirtualStreamerInfo*)fStreamerInfo->At(slot);; 7325 fStreamerInfo->RemoveAt(fClassVersion);; 7326 if (fLastReadInfo.load() == info); 7327 fLastReadInfo = nullptr;; 7328 if (fCurrentInfo.load() == info); 7329 fCurrentInfo = nullptr;; 7330 delete info;; 7331 if (fState == kEmulated && fStreamerInfo->GetEntries() == 0) {; 7332 fState = kForwardDeclared;; 7333 }; 7334 }; 7335}; 7336 ; 7337////////////////////////////////////////////////////////////////////////////////; 7338/// Return true is the Hash/RecursiveRemove setup is consistent, i.e. when all; 7339/// classes in the class hierarchy that overload TObject::Hash do call; 7340/// ROOT::CallRecursiveRemoveIfNeeded in their destructor.; 7341/// i.e. it is safe to call the Hash virtual function during the RecursiveRemove operation.; 7342/// This routines is used for a small subset of the class for which we need; 7343/// the answer before gROOT is properly initialized.; 7344 ; 7345Bool_t ROOT::Internal::HasConsistentHashMember(const char *cname); 7346{; 7347 // Hand selection of correct classes, those classes should be; 7348 // cross-checked in testHashRecursiveRemove.cxx; 7349 static const char *handVerified[] = {; 7350 ""TEnvRec"", ""TDataType"", ""TObjArray"", ""TList"", ""THashList"",; 7351 ""TClass"", ""TCling"", ""TInterpreter"", ""TMethod"", ""ROOT::Internal::TCheckHashRecursiveRemoveConsistency"",; 7352 ""TCh",MatchSource.WIKI,doc/v632/TClass_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/TClass_8cxx_source.html
https://root.cern/doc/v632/TClass_8cxx_source.html:284452,Performance,load,load,284452," TClass::New is; 7381/// guarantee to succeed.; 7382/// To know if the class described by this TClass has a default constructor; 7383/// (public or not), use; 7384/// \code{.cpp}; 7385/// cl->GetProperty() & kClassHasDefaultCtor; 7386/// \endcode; 7387/// To know if the class described by this TClass has a public default; 7388/// constructor use:; 7389/// \code{.cpp}; 7390/// gInterpreter->ClassInfo_HasDefaultConstructor(aClass->GetClassInfo());; 7391/// \endcode; 7392 ; 7393Bool_t TClass::HasDefaultConstructor(Bool_t testio) const; 7394{; 7395 ; 7396 if (fNew) return kTRUE;; 7397 ; 7398 if (HasInterpreterInfo()) {; 7399 R__LOCKGUARD(gInterpreterMutex);; 7400 return gCling->ClassInfo_HasDefaultConstructor(GetClassInfo(), testio);; 7401 }; 7402 if (fCollectionProxy) {; 7403 return kTRUE;; 7404 }; 7405 if (fCurrentInfo.load()) {; 7406 // Emulated class, we know how to construct them via the TStreamerInfo; 7407 return kTRUE;; 7408 }; 7409 return kFALSE;; 7410}; 7411 ; 7412////////////////////////////////////////////////////////////////////////////////; 7413/// Returns true if this class has an definition and/or overload of the; 7414/// member function Hash.; 7415///; 7416/// For example to test if the class overload TObject::Hash use; 7417/// ~~~ {.cpp}; 7418/// if (cl->IsTObject() && cl->HasLocalHashMember()); 7419/// ~~~; 7420 ; 7421Bool_t TClass::HasLocalHashMember() const; 7422{; 7423 if (fProperty == (-1)); 7424 Property();; 7425 return TestBit(kHasLocalHashMember);; 7426}; 7427 ; 7428////////////////////////////////////////////////////////////////////////////////; 7429/// Return the wrapper around Merge.; 7430 ; 7431ROOT::MergeFunc_t TClass::GetMerge() const; 7432{; 7433 return fMerge;; 7434}; 7435 ; 7436////////////////////////////////////////////////////////////////////////////////; 7437/// Return the wrapper around Merge.; 7438 ; 7439ROOT::ResetAfterMergeFunc_t TClass::GetResetAfterMerge() const; 7440{; 7441 return fResetAfterMerge;; 7442}; 7443 ; 7444/////////",MatchSource.WIKI,doc/v632/TClass_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/TClass_8cxx_source.html
https://root.cern/doc/v632/TClass_8cxx_source.html:304112,Performance,load,load,304112,"nspector::TAutoInspectorTAutoInspector(TBrowser *b)Definition TClass.cxx:906; TAutoInspector::~TAutoInspectorvirtual ~TAutoInspector()Definition TClass.cxx:911; TAutoInspector::fCountInt_t fCountDefinition TClass.cxx:903; TAutoInspector::Inspectvoid Inspect(TClass *cl, const char *parent, const char *name, const void *addr, Bool_t isTransient) overrideThis method is called from ShowMembers() via AutoBrowse().Definition TClass.cxx:920; TBaseClassEach class (see TClass) has a linked list of its base class(es).Definition TBaseClass.h:33; TBaseClass::GetDeltaInt_t GetDelta()Get offset from ""this"" to part of base class.Definition TBaseClass.cxx:75; TBaseClass::IsSTLContainerROOT::ESTLType IsSTLContainer()Return which type (if any) of STL container the data member is.Definition TBaseClass.cxx:101; TBaseClass::PropertyLong_t Property() const overrideGet property description word. For meaning of bits see EProperty.Definition TBaseClass.cxx:134; TBaseClass::GetClassPointerTClass * GetClassPointer(Bool_t load=kTRUE)Get pointer to the base class TClass.Definition TBaseClass.cxx:63; TBrowserUsing a TBrowser one can browse all ROOT objects.Definition TBrowser.h:37; TBufferBuffer base class used for serializing objects.Definition TBuffer.h:43; TBuildRealDataDefinition TClass.cxx:751; TBuildRealData::Inspectvoid Inspect(TClass *cl, const char *parent, const char *name, const void *addr, Bool_t isTransient) overrideThis method is called from ShowMembers() via BuildRealdata().Definition TClass.cxx:771; TBuildRealData::fRealDataClassTClass * fRealDataClassDefinition TClass.cxx:755; TBuildRealData::fRealDataObjectvoid * fRealDataObjectDefinition TClass.cxx:754; TBuildRealData::TBuildRealDataTBuildRealData(void *obj, TClass *cl)Definition TClass.cxx:758; TClassGeneratorObjects following this interface can be passed onto the TROOT object to implement a user customized w...Definition TClassGenerator.h:28; TClassGenerator::GetClassvirtual TClass * GetClass(const char *classname, Bool_t lo",MatchSource.WIKI,doc/v632/TClass_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/TClass_8cxx_source.html
https://root.cern/doc/v632/TClass_8cxx_source.html:305100,Performance,load,load,305100,"oad=kTRUE)Get pointer to the base class TClass.Definition TBaseClass.cxx:63; TBrowserUsing a TBrowser one can browse all ROOT objects.Definition TBrowser.h:37; TBufferBuffer base class used for serializing objects.Definition TBuffer.h:43; TBuildRealDataDefinition TClass.cxx:751; TBuildRealData::Inspectvoid Inspect(TClass *cl, const char *parent, const char *name, const void *addr, Bool_t isTransient) overrideThis method is called from ShowMembers() via BuildRealdata().Definition TClass.cxx:771; TBuildRealData::fRealDataClassTClass * fRealDataClassDefinition TClass.cxx:755; TBuildRealData::fRealDataObjectvoid * fRealDataObjectDefinition TClass.cxx:754; TBuildRealData::TBuildRealDataTBuildRealData(void *obj, TClass *cl)Definition TClass.cxx:758; TClassGeneratorObjects following this interface can be passed onto the TROOT object to implement a user customized w...Definition TClassGenerator.h:28; TClassGenerator::GetClassvirtual TClass * GetClass(const char *classname, Bool_t load)=0; TClassMenuItemDescribes one element of the context menu associated to a class The menu item may describe.Definition TClassMenuItem.h:31; TClassMenuItem::SetTogglevirtual void SetToggle(Bool_t toggle=kTRUE)Definition TClassMenuItem.h:75; TClassMenuItem::kIsSelf@ kIsSelfDefinition TClassMenuItem.h:37; TClassMenuItem::kPopupStandardList@ kPopupStandardListDefinition TClassMenuItem.h:35; TClassMenuItem::kPopupSeparator@ kPopupSeparatorDefinition TClassMenuItem.h:35; TClassMenuItem::kPopupUserFunction@ kPopupUserFunctionDefinition TClassMenuItem.h:35; TClassRefTClassRef is used to implement a permanent reference to a TClass object.Definition TClassRef.h:28; TClassStreamerDefinition TClassStreamer.h:26; TClassStreamer::Streamvirtual void Stream(TBuffer &b, void *objp, const TClass *onfileClass)Definition TClassStreamer.h:51; TClassStreamer::Generatevirtual TClassStreamer * Generate() constDefinition TClassStreamer.h:38; TClassTable::GetDictstatic DictFuncPtr_t GetDict(const char *cname)Given the ",MatchSource.WIKI,doc/v632/TClass_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/TClass_8cxx_source.html
https://root.cern/doc/v632/TClass_8cxx_source.html:308394,Performance,load,load,308394,"eclNameRegistryTDeclNameRegistry(Int_t verbLevel=0)TDeclNameRegistry class constructor.Definition TClass.cxx:185; TClass::TDeclNameRegistry::fSpinLockstd::atomic_flag fSpinLockDefinition TClass.h:170; TClassTClass instances represent classes, structs and namespaces in the ROOT type system.Definition TClass.h:81; TClass::GetCheckSumUInt_t GetCheckSum(ECheckSum code=kCurrentCheckSum) constCall GetCheckSum with validity check.Definition TClass.cxx:6505; TClass::IsSyntheticPairBool_t IsSyntheticPair() constDefinition TClass.h:521; TClass::fObjectVersionRepositoryRepoCont_t fObjectVersionRepositoryDefinition TClass.h:344; TClass::fShowMembersShowMembersFunc_t fShowMembersDefinition TClass.h:225; TClass::GetDataMemberTDataMember * GetDataMember(const char *datamember) constReturn pointer to datamember object with name ""datamember"".Definition TClass.cxx:3439; TClass::fIsATVirtualIsAProxy * fIsADefinition TClass.h:229; TClass::GetListOfUsingDataMembersTList * GetListOfUsingDataMembers(Bool_t load=kTRUE)Return list containing the TDataMembers of using declarations of a class.Definition TClass.cxx:3786; TClass::ForceReloadvoid ForceReload(TClass *oldcl)we found at least one equivalent.Definition TClass.cxx:1336; TClass::fDeleteArrayROOT::DelArrFunc_t fDeleteArrayDefinition TClass.h:238; TClass::CanSplitBool_t CanSplit() constReturn true if the data member of this TClass can be saved separately.Definition TClass.cxx:2319; TClass::fStreamerTClassStreamer * fStreamerDefinition TClass.h:226; TClass::SetDirectoryAutoAddvoid SetDirectoryAutoAdd(ROOT::DirAutoAdd_t dirAutoAddFunc)Install a new wrapper around the directory auto add function.Definition TClass.cxx:7028; TClass::NewArrayvoid * NewArray(Long_t nElements, ENewType defConstructor=kClassNew) constReturn a pointer to a newly allocated array of objects of this class.Definition TClass.cxx:5193; TClass::fNoInfoOrEmuOrFwdDeclNameRegistrystatic TDeclNameRegistry fNoInfoOrEmuOrFwdDeclNameRegistryDefinition TClass.h:328; TClass::fFun",MatchSource.WIKI,doc/v632/TClass_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/TClass_8cxx_source.html
https://root.cern/doc/v632/TClass_8cxx_source.html:311423,Performance,load,load,311423,"presenting.Definition TClass.cxx:2886; TClass::Drawvoid Draw(Option_t *option="""") overrideDraw detailed class inheritance structure.Definition TClass.cxx:2487; TClass::AdoptMemberStreamervoid AdoptMemberStreamer(const char *name, TMemberStreamer *strm)Adopt the TMemberStreamer pointer to by p and use it to Stream non basic member name.Definition TClass.cxx:6703; TClass::ResetInstanceCountvoid ResetInstanceCount()Definition TClass.h:547; TClass::GetStreamerFuncClassStreamerFunc_t GetStreamerFunc() constGet a wrapper/accessor function around this class custom streamer (member function).Definition TClass.cxx:2939; TClass::RemoveStreamerInfovoid RemoveStreamerInfo(Int_t slot)Remove and delete the StreamerInfo in the given slot.Definition TClass.cxx:7320; TClass::SetCanSplitvoid SetCanSplit(Int_t splitmode)Set the splitability of this class:Definition TClass.cxx:5658; TClass::CreateListOfDataMembersTList * CreateListOfDataMembers(std::atomic< TListOfDataMembers * > &data, TDictionary::EMemberSelection selection, bool load)Create the list containing the TDataMembers (of actual data members or members pulled in through usin...Definition TClass.cxx:3741; TClass::GetStreamerInfoAbstractEmulatedTVirtualStreamerInfo * GetStreamerInfoAbstractEmulated(Int_t version=0) constFor the case where the requestor class is emulated and this class is abstract, returns a pointer to t...Definition TClass.cxx:4709; TClass::Newvoid * New(ENewType defConstructor=kClassNew, Bool_t quiet=kFALSE) constReturn a pointer to a newly allocated object of this class.Definition TClass.cxx:4978; TClass::SetMergevoid SetMerge(ROOT::MergeFunc_t mergeFunc)Install a new wrapper around 'Merge'.Definition TClass.cxx:6969; TClass::fConversionStreamerInfoConvSIMap_t fConversionStreamerInfoDefinition TClass.h:199; TClass::fDirAutoAddROOT::DirAutoAdd_t fDirAutoAddDefinition TClass.h:240; TClass::HasDataMemberInfoBool_t HasDataMemberInfo() constDefinition TClass.h:407; TClass::fRefProxyTVirtualRefProxy * fRefProxycac",MatchSource.WIKI,doc/v632/TClass_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/TClass_8cxx_source.html
https://root.cern/doc/v632/TClass_8cxx_source.html:314330,Performance,load,load,314330,"nst char *proto, Bool_t objectIsConst=kFALSE, ROOT::EFunctionMatchMode mode=ROOT::kConversionMatch)Find the method with a given prototype.Definition TClass.cxx:4456; TClass::CopyCollectionProxyvoid CopyCollectionProxy(const TVirtualCollectionProxy &)Replaces the collection proxy for this class.Definition TClass.cxx:2470; TClass::fStreamerTypeInt_t fStreamerTypesaved info to call StreamerDefinition TClass.h:276; TClass::fRealDataTList * fRealDataDefinition TClass.h:200; TClass::fOnHeapUInt_t fOnHeapDefinition TClass.h:218; TClass::lsvoid ls(Option_t *opt="""") const overrideThe ls function lists the contents of a class on stdout.Definition TClass.cxx:4258; TClass::fBasestd::atomic< TList * > fBaseDefinition TClass.h:201; TClass::fCanSplitstd::atomic< Char_t > fCanSplitDefinition TClass.h:245; TClass::HasDictionaryBool_t HasDictionary() constCheck whether a class has a dictionary or not.Definition TClass.cxx:3906; TClass::GetListOfAllPublicMethodsconst TList * GetListOfAllPublicMethods(Bool_t load=kTRUE)Returns a list of all public methods of this class and its base classes.Definition TClass.cxx:3845; TClass::GetListOfAllPublicDataMembersTList * GetListOfAllPublicDataMembers(Bool_t load=kTRUE)Returns a list of all public data members of this class and its base classes.Definition TClass.cxx:3862; TClass::AddClassToDeclIdMapstatic void AddClassToDeclIdMap(TDictionary::DeclId_t id, TClass *cl)static: Add a TClass* to the map of classes.Definition TClass.cxx:511; TClass::~TClassvirtual ~TClass()TClass dtor. Deletes all list that might have been created.Definition TClass.cxx:1660; TClass::fIsSyntheticPairBool_t fIsSyntheticPairIndicates whether this class can be split or not. Values are -1, 0, 1, 2.Definition TClass.h:250; TClass::Destructorvoid Destructor(void *obj, Bool_t dtorOnly=kFALSE)Explicitly call destructor for object.Definition TClass.cxx:5400; TClass::fClassVersionVersion_t fClassVersionDefinition TClass.h:221; TClass::fCurrentInfostd::atomic< TVirtualStreamerInfo ",MatchSource.WIKI,doc/v632/TClass_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/TClass_8cxx_source.html
https://root.cern/doc/v632/TClass_8cxx_source.html:314523,Performance,load,load,314523,"id CopyCollectionProxy(const TVirtualCollectionProxy &)Replaces the collection proxy for this class.Definition TClass.cxx:2470; TClass::fStreamerTypeInt_t fStreamerTypesaved info to call StreamerDefinition TClass.h:276; TClass::fRealDataTList * fRealDataDefinition TClass.h:200; TClass::fOnHeapUInt_t fOnHeapDefinition TClass.h:218; TClass::lsvoid ls(Option_t *opt="""") const overrideThe ls function lists the contents of a class on stdout.Definition TClass.cxx:4258; TClass::fBasestd::atomic< TList * > fBaseDefinition TClass.h:201; TClass::fCanSplitstd::atomic< Char_t > fCanSplitDefinition TClass.h:245; TClass::HasDictionaryBool_t HasDictionary() constCheck whether a class has a dictionary or not.Definition TClass.cxx:3906; TClass::GetListOfAllPublicMethodsconst TList * GetListOfAllPublicMethods(Bool_t load=kTRUE)Returns a list of all public methods of this class and its base classes.Definition TClass.cxx:3845; TClass::GetListOfAllPublicDataMembersTList * GetListOfAllPublicDataMembers(Bool_t load=kTRUE)Returns a list of all public data members of this class and its base classes.Definition TClass.cxx:3862; TClass::AddClassToDeclIdMapstatic void AddClassToDeclIdMap(TDictionary::DeclId_t id, TClass *cl)static: Add a TClass* to the map of classes.Definition TClass.cxx:511; TClass::~TClassvirtual ~TClass()TClass dtor. Deletes all list that might have been created.Definition TClass.cxx:1660; TClass::fIsSyntheticPairBool_t fIsSyntheticPairIndicates whether this class can be split or not. Values are -1, 0, 1, 2.Definition TClass.h:250; TClass::Destructorvoid Destructor(void *obj, Bool_t dtorOnly=kFALSE)Explicitly call destructor for object.Definition TClass.cxx:5400; TClass::fClassVersionVersion_t fClassVersionDefinition TClass.h:221; TClass::fCurrentInfostd::atomic< TVirtualStreamerInfo * > fCurrentInfoCurrent 'state' of the class (Emulated,Interpreted,Loaded)Definition TClass.h:278; TClass::GetListOfFunctionTemplatesTList * GetListOfFunctionTemplates(Bool_t load=kTRUE)Return T",MatchSource.WIKI,doc/v632/TClass_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/TClass_8cxx_source.html
https://root.cern/doc/v632/TClass_8cxx_source.html:315502,Performance,load,load,315502,"tListOfAllPublicDataMembers(Bool_t load=kTRUE)Returns a list of all public data members of this class and its base classes.Definition TClass.cxx:3862; TClass::AddClassToDeclIdMapstatic void AddClassToDeclIdMap(TDictionary::DeclId_t id, TClass *cl)static: Add a TClass* to the map of classes.Definition TClass.cxx:511; TClass::~TClassvirtual ~TClass()TClass dtor. Deletes all list that might have been created.Definition TClass.cxx:1660; TClass::fIsSyntheticPairBool_t fIsSyntheticPairIndicates whether this class can be split or not. Values are -1, 0, 1, 2.Definition TClass.h:250; TClass::Destructorvoid Destructor(void *obj, Bool_t dtorOnly=kFALSE)Explicitly call destructor for object.Definition TClass.cxx:5400; TClass::fClassVersionVersion_t fClassVersionDefinition TClass.h:221; TClass::fCurrentInfostd::atomic< TVirtualStreamerInfo * > fCurrentInfoCurrent 'state' of the class (Emulated,Interpreted,Loaded)Definition TClass.h:278; TClass::GetListOfFunctionTemplatesTList * GetListOfFunctionTemplates(Bool_t load=kTRUE)Return TListOfFunctionTemplates for a class.Definition TClass.cxx:3798; TClass::DynamicCastvoid * DynamicCast(const TClass *base, void *obj, Bool_t up=kTRUE)Cast obj of this class type up to baseclass cl if up is true.Definition TClass.cxx:4915; TClass::fImplFileNameconst char * fImplFileNameDefinition TClass.h:214; TClass::RegisterStreamerInfovoid RegisterStreamerInfo(TVirtualStreamerInfo *info)Register the StreamerInfo in the given slot, change the State of the TClass as appropriate.Definition TClass.cxx:7296; TClass::fCheckSumstd::atomic< UInt_t > fCheckSumDefinition TClass.h:219; TClass::UnregisterAddressInRepositoryvoid UnregisterAddressInRepository(const char *where, void *location, const TClass *what) constDefinition TClass.cxx:318; TClass::fMethodstd::atomic< TListOfFunctions * > fMethodDefinition TClass.h:207; TClass::RemoveClassDeclIdstatic void RemoveClassDeclId(TDictionary::DeclId_t id)Definition TClass.cxx:536; TClass::SetNewArrayvoid SetNewArray(R",MatchSource.WIKI,doc/v632/TClass_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/TClass_8cxx_source.html
https://root.cern/doc/v632/TClass_8cxx_source.html:317240,Performance,load,load,317240,"tory(const char *where, void *location, const TClass *what) constDefinition TClass.cxx:318; TClass::fMethodstd::atomic< TListOfFunctions * > fMethodDefinition TClass.h:207; TClass::RemoveClassDeclIdstatic void RemoveClassDeclId(TDictionary::DeclId_t id)Definition TClass.cxx:536; TClass::SetNewArrayvoid SetNewArray(ROOT::NewArrFunc_t newArrayFunc)Install a new wrapper around 'new []'.Definition TClass.cxx:6993; TClass::CallShowMembersBool_t CallShowMembers(const void *obj, TMemberInspector &insp, Bool_t isTransient=kFALSE) constCall ShowMembers() on the obj of this class type, passing insp and parent.Definition TClass.cxx:2205; TClass::fDeclFileNameconst char * fDeclFileNameDefinition TClass.h:213; TClass::SetCollectionProxyvoid SetCollectionProxy(const ROOT::Detail::TCollectionProxyInfo &)Create the collection proxy object (and the streamer object) from using the information in the TColle...Definition TClass.cxx:6244; TClass::HasDictionarySelectionstatic Bool_t HasDictionarySelection(const char *clname)Check whether a class has a dictionary or ROOT can load one.Definition TClass.cxx:3917; TClass::AdoptSchemaRulesvoid AdoptSchemaRules(ROOT::Detail::TSchemaRuleSet *rules)Adopt a new set of Data Model Evolution rules.Definition TClass.cxx:1920; TClass::StreamerInstrumentedstatic void StreamerInstrumented(const TClass *pThis, void *object, TBuffer &b, const TClass *onfile_class)Case of instrumented class with a library.Definition TClass.cxx:6836; TClass::SetStreamerInfoTVirtualStreamerInfo * SetStreamerInfo(Int_t version, const char *info="""")Info is a string describing the names and types of attributes written by the class Streamer function.Definition TClass.cxx:6373; TClass::fgClassCountstatic std::atomic< Int_t > fgClassCountDefinition TClass.h:326; TClass::GetCurrentStreamerInfoTVirtualStreamerInfo * GetCurrentStreamerInfo()Definition TClass.h:439; TClass::GetDirectoryAutoAddROOT::DirAutoAdd_t GetDirectoryAutoAdd() constReturn the wrapper around the directory auto ad",MatchSource.WIKI,doc/v632/TClass_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/TClass_8cxx_source.html
https://root.cern/doc/v632/TClass_8cxx_source.html:318795,Performance,load,load,318795,"es written by the class Streamer function.Definition TClass.cxx:6373; TClass::fgClassCountstatic std::atomic< Int_t > fgClassCountDefinition TClass.h:326; TClass::GetCurrentStreamerInfoTVirtualStreamerInfo * GetCurrentStreamerInfo()Definition TClass.h:439; TClass::GetDirectoryAutoAddROOT::DirAutoAdd_t GetDirectoryAutoAdd() constReturn the wrapper around the directory auto add function.Definition TClass.cxx:7487; TClass::AddImplFilevoid AddImplFile(const char *filename, int line)Definition TClass.cxx:1952; TClass::GetListOfMethodOverloadsTCollection * GetListOfMethodOverloads(const char *name) constReturn the collection of functions named ""name"".Definition TClass.cxx:3827; TClass::fEnumsstd::atomic< TListOfEnums * > fEnumsDefinition TClass.h:205; TClass::HasNoInfoOrEmuOrFwdDeclaredDeclstatic Bool_t HasNoInfoOrEmuOrFwdDeclaredDecl(const char *)Definition TClass.cxx:3398; TClass::fOVRMutexTVirtualMutex * fOVRMutexDefinition TClass.h:342; TClass::GetListOfEnumsTList * GetListOfEnums(Bool_t load=kTRUE)Return a list containing the TEnums of a class.Definition TClass.cxx:3686; TClass::IsStartingWithTObjectBool_t IsStartingWithTObject() constReturns true if this class inherits from TObject and if the start of the TObject parts is at the very...Definition TClass.cxx:5929; TClass::GetListOfMethodsTList * GetListOfMethods(Bool_t load=kTRUE)Return list containing the TMethods of a class.Definition TClass.cxx:3812; TClass::TClassTClass()Internal, default constructor.Definition TClass.cxx:1065; TClass::fDeclFileLineShort_t fDeclFileLineDefinition TClass.h:215; TClass::GetNmethodsInt_t GetNmethods()Return the number of methods of this class Note that in case the list of methods is not yet created,...Definition TClass.cxx:4573; TClass::fIsOffsetStreamerSetstd::atomic< Bool_t > fIsOffsetStreamerSetIndicates whether the ClassInfo is supposed to be available.Definition TClass.h:261; TClass::IgnoreTObjectStreamervoid IgnoreTObjectStreamer(Bool_t ignore=kTRUE)When the class kIgnoreTObjec",MatchSource.WIKI,doc/v632/TClass_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/TClass_8cxx_source.html
https://root.cern/doc/v632/TClass_8cxx_source.html:319134,Performance,load,load,319134," the wrapper around the directory auto add function.Definition TClass.cxx:7487; TClass::AddImplFilevoid AddImplFile(const char *filename, int line)Definition TClass.cxx:1952; TClass::GetListOfMethodOverloadsTCollection * GetListOfMethodOverloads(const char *name) constReturn the collection of functions named ""name"".Definition TClass.cxx:3827; TClass::fEnumsstd::atomic< TListOfEnums * > fEnumsDefinition TClass.h:205; TClass::HasNoInfoOrEmuOrFwdDeclaredDeclstatic Bool_t HasNoInfoOrEmuOrFwdDeclaredDecl(const char *)Definition TClass.cxx:3398; TClass::fOVRMutexTVirtualMutex * fOVRMutexDefinition TClass.h:342; TClass::GetListOfEnumsTList * GetListOfEnums(Bool_t load=kTRUE)Return a list containing the TEnums of a class.Definition TClass.cxx:3686; TClass::IsStartingWithTObjectBool_t IsStartingWithTObject() constReturns true if this class inherits from TObject and if the start of the TObject parts is at the very...Definition TClass.cxx:5929; TClass::GetListOfMethodsTList * GetListOfMethods(Bool_t load=kTRUE)Return list containing the TMethods of a class.Definition TClass.cxx:3812; TClass::TClassTClass()Internal, default constructor.Definition TClass.cxx:1065; TClass::fDeclFileLineShort_t fDeclFileLineDefinition TClass.h:215; TClass::GetNmethodsInt_t GetNmethods()Return the number of methods of this class Note that in case the list of methods is not yet created,...Definition TClass.cxx:4573; TClass::fIsOffsetStreamerSetstd::atomic< Bool_t > fIsOffsetStreamerSetIndicates whether the ClassInfo is supposed to be available.Definition TClass.h:261; TClass::IgnoreTObjectStreamervoid IgnoreTObjectStreamer(Bool_t ignore=kTRUE)When the class kIgnoreTObjectStreamer bit is set, the automatically generated Streamer will not call ...Definition TClass.cxx:4841; TClass::GetStreamerTClassStreamer * GetStreamer() constReturn the Streamer Class allowing streaming (if any).Definition TClass.cxx:2914; TClass::GetIdMapstatic IdMap_t * GetIdMap()Definition TClass.cxx:469; TClass::SetDeletevoid Se",MatchSource.WIKI,doc/v632/TClass_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/TClass_8cxx_source.html
https://root.cern/doc/v632/TClass_8cxx_source.html:321316,Performance,load,load,321316,"wser)Browse external object inherited from TObject.Definition TClass.cxx:1966; TClass::GetNewROOT::NewFunc_t GetNew() constReturn the wrapper around new ThisClass().Definition TClass.cxx:7447; TClass::GetBaseClassTClass * GetBaseClass(const char *classname)Return pointer to the base class ""classname"".Definition TClass.cxx:2655; TClass::GetDataMemberOffsetLongptr_t GetDataMemberOffset(const char *membername) constreturn offset for member name.Definition TClass.cxx:3477; TClass::GetNdataInt_t GetNdata()Return the number of data members of this class Note that in case the list of data members is not yet...Definition TClass.cxx:4554; TClass::SetDestructorvoid SetDestructor(ROOT::DesFunc_t destructorFunc)Install a new wrapper around the destructor.Definition TClass.cxx:7017; TClass::PostLoadCheckvirtual void PostLoadCheck()Do the initialization that can only be done after the CINT dictionary has been fully populated and ca...Definition TClass.cxx:5959; TClass::LoadClassInfovoid LoadClassInfo() constTry to load the ClassInfo if available.Definition TClass.cxx:5824; TClass::SetResetAfterMergevoid SetResetAfterMerge(ROOT::ResetAfterMergeFunc_t resetFunc)Install a new wrapper around 'ResetAfterMerge'.Definition TClass.cxx:6977; TClass::GetStreamerInfoImplTVirtualStreamerInfo * GetStreamerInfoImpl(Int_t version, Bool_t silent) constDefinition TClass.cxx:4634; TClass::MatchLegacyCheckSumBool_t MatchLegacyCheckSum(UInt_t checksum) constReturn true if the checksum passed as argument is one of the checksum value produced by the older che...Definition TClass.cxx:6494; TClass::fAllPubMethodTViewPubFunctions * fAllPubMethodDefinition TClass.h:210; TClass::ERuntimeProperties::kSet@ kSet; TClass::ERuntimeProperties::kConsistentHash@ kConsistentHash; TClass::HasInterpreterInfoBool_t HasInterpreterInfo() constDefinition TClass.h:410; TClass::AddClassstatic void AddClass(TClass *cl)static: Add a class to the list and map of classes.Definition TClass.cxx:494; TClass::GetMissingDictionarie",MatchSource.WIKI,doc/v632/TClass_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/TClass_8cxx_source.html
https://root.cern/doc/v632/TClass_8cxx_source.html:324434,Performance,load,load,324434,"TClass::fConvStreamerFuncClassConvStreamerFunc_t fConvStreamerFuncDefinition TClass.h:242; TClass::BuildRealDatavoid BuildRealData(void *pointer=nullptr, Bool_t isTransient=kFALSE)Build a full list of persistent data members.Definition TClass.cxx:2031; TClass::SetRuntimePropertiesvoid SetRuntimeProperties()Internal routine to set calculate the class properties that can only be known at run-time,...Definition TClass.cxx:6194; TClass::BuildEmulatedRealDatavoid BuildEmulatedRealData(const char *name, Longptr_t offset, TClass *cl, Bool_t isTransient=kFALSE)Build the list of real data for an emulated class.Definition TClass.cxx:2112; TClass::LoadClassstatic TClass * LoadClass(const char *requestedname, Bool_t silent)Helper function used by TClass::GetClass().Definition TClass.cxx:5749; TClass::fSharedLibsTString fSharedLibsDefinition TClass.h:227; TClass::GetTypeInfoconst std::type_info * GetTypeInfo() constDefinition TClass.h:496; TClass::GetListOfDataMembersTList * GetListOfDataMembers(Bool_t load=kTRUE)Return list containing the TDataMembers of a class.Definition TClass.cxx:3770; TClass::ENewTypeENewTypeDefinition TClass.h:107; TClass::kRealNew@ kRealNewDefinition TClass.h:107; TClass::Movevoid Move(void *arenaFrom, void *arenaTo) constRegister the fact that an object was moved from the memory location 'arenaFrom' to the memory locatio...Definition TClass.cxx:4327; TClass::GetDeclIdMapstatic DeclIdMap_t * GetDeclIdMap()Definition TClass.cxx:480; TClass::GetDeclFileLineShort_t GetDeclFileLine() constDefinition TClass.h:429; TClass::SetStreamerFuncvoid SetStreamerFunc(ClassStreamerFunc_t strm)Set a wrapper/accessor function around this class custom streamer.Definition TClass.cxx:6922; TClass::GetImplFileNameconst char * GetImplFileName() constDefinition TClass.h:456; TClass::GetListOfRealDataTList * GetListOfRealData() constDefinition TClass.h:453; TClass::SizeInt_t Size() constReturn size of object of this class.Definition TClass.cxx:5704; TClass::SetCurrentStreamerInfo",MatchSource.WIKI,doc/v632/TClass_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/TClass_8cxx_source.html
https://root.cern/doc/v632/TClass_8cxx_source.html:325654,Performance,load,loading,325654,"07; TClass::Movevoid Move(void *arenaFrom, void *arenaTo) constRegister the fact that an object was moved from the memory location 'arenaFrom' to the memory locatio...Definition TClass.cxx:4327; TClass::GetDeclIdMapstatic DeclIdMap_t * GetDeclIdMap()Definition TClass.cxx:480; TClass::GetDeclFileLineShort_t GetDeclFileLine() constDefinition TClass.h:429; TClass::SetStreamerFuncvoid SetStreamerFunc(ClassStreamerFunc_t strm)Set a wrapper/accessor function around this class custom streamer.Definition TClass.cxx:6922; TClass::GetImplFileNameconst char * GetImplFileName() constDefinition TClass.h:456; TClass::GetListOfRealDataTList * GetListOfRealData() constDefinition TClass.h:453; TClass::SizeInt_t Size() constReturn size of object of this class.Definition TClass.cxx:5704; TClass::SetCurrentStreamerInfovoid SetCurrentStreamerInfo(TVirtualStreamerInfo *info)Set pointer to current TVirtualStreamerInfo.Definition TClass.cxx:5696; TClass::GetDictstatic DictFuncPtr_t GetDict(const char *cname)Return a pointer to the dictionary loading function generated by rootcint.Definition TClass.cxx:3422; TClass::fOffsetStreamerLongptr_t fOffsetStreamerProperties that can only be evaluated at run-time.Definition TClass.h:275; TClass::fSizeofInt_t fSizeofDefinition TClass.h:243; TClass::GetNewArrayROOT::NewArrFunc_t GetNewArray() constReturn the wrapper around new ThisClass[].Definition TClass.cxx:7455; TClass::StreamerTObjectEmulatedstatic void StreamerTObjectEmulated(const TClass *pThis, void *object, TBuffer &b, const TClass *onfile_class)Case of TObjects when we do not have the library defining the class.Definition TClass.cxx:6823; TClass::fNewROOT::NewFunc_t fNewDefinition TClass.h:235; TClass::kLoading@ kLoadingDefinition TClass.h:332; TClass::kUnloading@ kUnloadingDefinition TClass.h:332; TClass::GetResetAfterMergeROOT::ResetAfterMergeFunc_t GetResetAfterMerge() constReturn the wrapper around Merge.Definition TClass.cxx:7439; TClass::GetClassMethodWithPrototypeTMethod * GetClassMet",MatchSource.WIKI,doc/v632/TClass_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/TClass_8cxx_source.html
https://root.cern/doc/v632/TClass_8cxx_source.html:333678,Performance,cache,caches,333678,"mmentDefinition TClass.h:111; TClass::kWithTypeDef@ kWithTypeDefDefinition TClass.h:113; TClass::kNoRangeCheck@ kNoRangeCheckDefinition TClass.h:115; TClass::kNoEnum@ kNoEnumDefinition TClass.h:110; TClass::Dumpvoid Dump() const overrideDump contents of object on stdout.Definition TClass.h:398; TClass::InheritsFromBool_t InheritsFrom(const char *cl) const overrideReturn kTRUE if this class inherits from a class with name ""classname"".Definition TClass.cxx:4874; TClass::GetBaseClassOffsetInt_t GetBaseClassOffset(const TClass *toBase, void *address=nullptr, bool isDerivedObject=true)Definition TClass.cxx:2791; TClass::NewObjectArrayObjectPtr NewObjectArray(Long_t nElements, ENewType defConstructor=kClassNew) constReturn a pointer to a newly allocated array of objects of this class.Definition TClass.cxx:5209; TClass::GetCollectionProxyTVirtualCollectionProxy * GetCollectionProxy() constReturn the proxy describing the collection (if any).Definition TClass.cxx:2897; TClass::ResetCachesvoid ResetCaches()To clean out all caches.Definition TClass.cxx:4215; TClass::fVersionUsedstd::atomic< Bool_t > fVersionUsedsaved remember if fOffsetStreamer has been set.Definition TClass.h:262; TClass::ClassPropertyLong_t ClassProperty() constReturn the C++ property of this class, eg.Definition TClass.cxx:2396; TClass::SetStreamerImplvoid SetStreamerImpl()Internal routine to set fStreamerImpl based on the value of fStreamerType.Definition TClass.cxx:6215; TClass::GetSharedLibsconst char * GetSharedLibs()Get the list of shared libraries containing the code for class cls.Definition TClass.cxx:3623; TClass::CalculateStreamerOffsetvoid CalculateStreamerOffset() constCalculate the offset between an object of this class to its base class TObject.Definition TClass.cxx:2183; TClass::GetMissingDictionariesForPairElementsvoid GetMissingDictionariesForPairElements(TCollection &result, TCollection &visited, bool recurse)Definition TClass.cxx:3973; TClass::ReplaceWithvoid ReplaceWith(TClass *newcl) cons",MatchSource.WIKI,doc/v632/TClass_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/TClass_8cxx_source.html
https://root.cern/doc/v632/TClass_8cxx_source.html:339426,Performance,load,loaded,339426,"BaseMethodWithId(DeclId_t faddr)Find a method with decl id in this class or its bases.Definition TClass.cxx:4440; TClass::StreamerExternalstatic void StreamerExternal(const TClass *pThis, void *object, TBuffer &b, const TClass *onfile_class)There is special streamer for the class.Definition TClass.cxx:6788; TClass::fClassPropertyLong_t fClassPropertyProperty See TClass::Property() for details.Definition TClass.h:256; TClass::fContextMenuTitleTString fContextMenuTitleDefinition TClass.h:223; TClass::StreamerTObjectInitializedstatic void StreamerTObjectInitialized(const TClass *pThis, void *object, TBuffer &b, const TClass *onfile_class)Case of TObjects when fIsOffsetStreamerSet is known to have been set.Definition TClass.cxx:6814; TClass::ConvStreamerInstrumentedstatic void ConvStreamerInstrumented(const TClass *pThis, void *object, TBuffer &b, const TClass *onfile_class)Case of instrumented class with a library.Definition TClass.cxx:6845; TClass::fCanLoadClassInfostd::atomic< Bool_t > fCanLoadClassInfoWhether info was loaded from a root pcm.Definition TClass.h:260; TClass::SetConvStreamerFuncvoid SetConvStreamerFunc(ClassConvStreamerFunc_t strm)Set a wrapper/accessor function around this class custom conversion streamer.Definition TClass.cxx:6945; TClass::FindStreamerInfoTVirtualStreamerInfo * FindStreamerInfo(TObjArray *arr, UInt_t checksum) constFind the TVirtualStreamerInfo in the StreamerInfos corresponding to checksum.Definition TClass.cxx:7066; TClass::GetMissingDictionariesvoid GetMissingDictionaries(THashTable &result, bool recurse=false)Get the classes that have a missing dictionary starting from this one.Definition TClass.cxx:4087; TClass::MakeCustomMenuListvoid MakeCustomMenuList()Makes a customizable version of the popup menu list, i.e.Definition TClass.cxx:4283; TClass::FindStreamerInfoAbstractEmulatedTVirtualStreamerInfo * FindStreamerInfoAbstractEmulated(UInt_t checksum) constFor the case where the requestor class is emulated and this class is abstrac",MatchSource.WIKI,doc/v632/TClass_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/TClass_8cxx_source.html
https://root.cern/doc/v632/TClass_8cxx_source.html:344083,Performance,load,load,344083,"::IsClassStructOrUnionbool IsClassStructOrUnion() constDefinition TClass.h:354; TClass::kHasLocalHashMember@ kHasLocalHashMemberDefinition TClass.h:96; TClass::kHasNameMapNode@ kHasNameMapNodeDefinition TClass.h:105; TClass::kIgnoreTObjectStreamer@ kIgnoreTObjectStreamerDefinition TClass.h:97; TClass::kUnloaded@ kUnloadedDefinition TClass.h:98; TClass::kWarned@ kWarnedDefinition TClass.h:104; TClass::kStartWithTObject@ kStartWithTObjectDefinition TClass.h:103; TClass::kIsTObject@ kIsTObjectDefinition TClass.h:100; TClass::kIsForeign@ kIsForeignDefinition TClass.h:101; TClass::fUsingDatastd::atomic< TListOfDataMembers * > fUsingDataDefinition TClass.h:203; TClass::GetMethodListTListOfFunctions * GetMethodList()Return (create an empty one if needed) the list of functions.Definition TClass.cxx:4355; TClass::ResetMenuListvoid ResetMenuList()Resets the menu list to it's standard value.Definition TClass.cxx:4243; TClass::GetClassstatic TClass * GetClass(const char *name, Bool_t load=kTRUE, Bool_t silent=kFALSE)Static method returning pointer to TClass of the specified class name.Definition TClass.cxx:2968; TClass::WriteBufferInt_t WriteBuffer(TBuffer &b, void *pointer, const char *info="""")Function called by the Streamer functions to serialize object at p to buffer b.Definition TClass.cxx:6779; TClass::LoadClassCustomstatic TClass * LoadClassCustom(const char *requestedname, Bool_t silent)Helper function used by TClass::GetClass().Definition TClass.cxx:5801; TClass::fImplFileLineShort_t fImplFileLineDefinition TClass.h:216; TClonesArray::Classstatic TClass * Class(); TCollectionCollection abstract base class.Definition TCollection.h:65; TCollection::Classstatic TClass * Class(); TCollection::lsvoid ls(Option_t *option="""") const overrideList (ls) all objects in this collection.Definition TCollection.cxx:382; TCollection::SetOwnervirtual void SetOwner(Bool_t enable=kTRUE)Set whether this collection is the owner (enable==true) of its content.Definition TCollection.cxx:746; TCo",MatchSource.WIKI,doc/v632/TClass_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/TClass_8cxx_source.html
https://root.cern/doc/v632/TClass_8cxx_source.html:371642,Performance,load,load,371642,"lStreamerInfo::SetClassVersionvirtual void SetClassVersion(Int_t vers)=0; TVirtualStreamerInfo::GenEmulatedClassStreamervirtual TClassStreamer * GenEmulatedClassStreamer(const char *class_name, Bool_t silent)=0; TVirtualStreamerInfo::IsCompiledBool_t IsCompiled() constDefinition TVirtualStreamerInfo.h:163; TVirtualStreamerInfo::NewInfovirtual TVirtualStreamerInfo * NewInfo(TClass *cl)=0; TVirtualStreamerInfo::GetActualClassvirtual TClass * GetActualClass(const void *obj) const =0; TVirtualStreamerInfo::GetCheckSumvirtual UInt_t GetCheckSum() const =0; TVirtualStreamerInfo::GetOffsetvirtual Int_t GetOffset(const char *) const =0; TVirtualStreamerInfo::GetElementCounterStartstatic const char * GetElementCounterStart(const char *dmTitle)Given a comment/title declaring an array counter, for example:Definition TVirtualStreamerInfo.cxx:99; TVirtualStreamerInfo::Buildvirtual void Build(Bool_t isTransient=kFALSE)=0; TVirtualStreamerInfo::BuildCheckvirtual void BuildCheck(TFile *file=nullptr, Bool_t load=kTRUE)=0; TVirtualStreamerInfo::BuildForvirtual Bool_t BuildFor(const TClass *cl)=0; TVirtualStreamerInfo::kBase@ kBaseDefinition TVirtualStreamerInfo.h:91; TVirtualStreamerInfo::kCharStar@ kCharStarDefinition TVirtualStreamerInfo.h:91; TVirtualStreamerInfo::kAny@ kAnyDefinition TVirtualStreamerInfo.h:96; TVirtualStreamerInfo::kObject@ kObjectDefinition TVirtualStreamerInfo.h:96; TVirtualStreamerInfo::kTObject@ kTObjectDefinition TVirtualStreamerInfo.h:97; TVirtualStreamerInfo::kTNamed@ kTNamedDefinition TVirtualStreamerInfo.h:97; TVirtualStreamerInfo::GenExplicitProxyvirtual TVirtualCollectionProxy * GenExplicitProxy(const ::ROOT::Detail::TCollectionProxyInfo &info, TClass *cl)=0; TVirtualStreamerInfo::NewArrayvirtual void * NewArray(Long_t nElements, void *ary=nullptr)=0; TVirtualStreamerInfo::GenEmulatedProxyvirtual TVirtualCollectionProxy * GenEmulatedProxy(const char *class_name, Bool_t silent)=0; TVirtualStreamerInfo::SetClassvirtual void SetClass(TClass *cl)=0; TVirtu",MatchSource.WIKI,doc/v632/TClass_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/TClass_8cxx_source.html
https://root.cern/doc/v632/TClass_8cxx_source.html:5523,Safety,avoid,avoid,5523,".h""; 125#include ""TRefArray.h""; 126 ; 127using std::multimap, std::make_pair, std::string;; 128 ; 129// Mutex to protect CINT and META operations; 130// (exported to be used for similar cases in related classes); 131 ; 132TVirtualMutex* gInterpreterMutex = nullptr;; 133 ; 134namespace {; 135 ; 136 static constexpr const char kUndeterminedClassInfoName[] = ""<NOT YET DETERMINED FROM fClassInfo>"";; 137 ; 138 class TMmallocDescTemp {; 139 private:; 140 void *fSave;; 141 public:; 142 TMmallocDescTemp(void *value = nullptr) :; 143 fSave(ROOT::Internal::gMmallocDesc) { ROOT::Internal::gMmallocDesc = value; }; 144 ~TMmallocDescTemp() { ROOT::Internal::gMmallocDesc = fSave; }; 145 };; 146 ; 147 // When a new class is created, we need to be able to find; 148 // if there are any existing classes that have the same name; 149 // after any typedefs are expanded. (This only really affects; 150 // template arguments.) To avoid having to search through all classes; 151 // in that case, we keep a hash table mapping from the fully; 152 // typedef-expanded names to the original class names.; 153 // An entry is made in the table only if they are actually different.; 154 //; 155 // In these objects, the TObjString base holds the typedef-expanded; 156 // name (the hash key), and fOrigName holds the original class name; 157 // (the value to which the key maps).; 158 //; 159 class TNameMapNode : public TObjString {; 160 public:; 161 TString fOrigName;; 162 ; 163 TNameMapNode(const char *typedf, const char *orig) :; 164 TObjString (typedf),; 165 fOrigName (orig); 166 {; 167 }; 168 };; 169 ; 170}; 171 ; 172std::atomic<Int_t> TClass::fgClassCount;; 173 ; 174static bool IsFromRootCling() {; 175 // rootcling also uses TCling for generating the dictionary ROOT files.; 176 const static bool foundSymbol = dlsym(RTLD_DEFAULT, ""usedToIdentifyRootClingByDlSym"");; 177 return foundSymbol;; 178}; 179 ; 180// Implementation of the TDeclNameRegistry; 181 ; 182////////////////////////////////////////////////",MatchSource.WIKI,doc/v632/TClass_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/TClass_8cxx_source.html
https://root.cern/doc/v632/TClass_8cxx_source.html:13781,Safety,avoid,avoid,13781,"{; 339 // Register in the repository that an object has moved.; 340 ; 341 // Move not only the object itself but also any base classes or sub-objects.; 342 size_t objsize = what->Size();; 343 long delta = (char*)newadd - (char*)oldadd;; 344 R__LOCKGUARD2(fOVRMutex);; 345 RepoCont_t::iterator cur = fObjectVersionRepository.find(oldadd);; 346 for (; cur != fObjectVersionRepository.end();) {; 347 RepoCont_t::iterator tmp = cur++;; 348 if (oldadd <= tmp->first && tmp->first < ( ((char*)oldadd) + objsize) ) {; 349 // The location is within the object, let's move it.; 350 ; 351 fObjectVersionRepository.insert(RepoCont_t::value_type(((char*)tmp->first)+delta, tmp->second));; 352 fObjectVersionRepository.erase(tmp);; 353 ; 354 } else {; 355 // -- No address, version match, we've reached the end.; 356 break;; 357 }; 358 }; 359}; 360 ; 361//______________________________________________________________________________; 362//______________________________________________________________________________; 363namespace ROOT {; 364#define R__USE_STD_MAP; 365 class TMapTypeToTClass {; 366#if defined R__USE_STD_MAP; 367 // This wrapper class allow to avoid putting #include <map> in the; 368 // TROOT.h header file.; 369 public:; 370 typedef std::map<std::string,TClass*> IdMap_t;; 371 typedef IdMap_t::key_type key_type;; 372 typedef IdMap_t::const_iterator const_iterator;; 373 typedef IdMap_t::size_type size_type;; 374#ifdef R__WIN32; 375 // Window's std::map does NOT defined mapped_type; 376 typedef TClass* mapped_type;; 377#else; 378 typedef IdMap_t::mapped_type mapped_type;; 379#endif; 380 ; 381 private:; 382 IdMap_t fMap;; 383 ; 384 public:; 385 void Add(const key_type &key, mapped_type &obj); 386 {; 387 // Add the <key,obj> pair to the map.; 388 fMap[key] = obj;; 389 }; 390 mapped_type Find(const key_type &key) const; 391 {; 392 // Find the type corresponding to the key.; 393 IdMap_t::const_iterator iter = fMap.find(key);; 394 mapped_type cl = nullptr;; 395 if (iter != fMap.end()",MatchSource.WIKI,doc/v632/TClass_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/TClass_8cxx_source.html
https://root.cern/doc/v632/TClass_8cxx_source.html:30575,Safety,detect,detect,30575,"efault constructor definition that can not be compiled due; 866 // to the template parameter]; 867 if (valcl) {; 868 Bool_t wantBuild = kTRUE;; 869 if (valcl->Property() & kIsAbstract) wantBuild = kFALSE;; 870 if ( (isTransient); 871 && (dmclass->GetCollectionProxy()->GetProperties() & TVirtualCollectionProxy::kIsEmulated); 872 && (!valcl->IsLoaded()) ) {; 873 // Case where the collection dictionary was not requested and; 874 // the content's dictionary was also not requested.; 875 // [This is a super set of what we need, but we can't really detect it :(]; 876 wantBuild = kFALSE;; 877 }; 878 ; 879 if (wantBuild) valcl->BuildRealData(nullptr, isTransient);; 880 }; 881 } else {; 882 void* addrForRecursion = nullptr;; 883 if (GetObjectValidity() == kValidObjectGiven); 884 addrForRecursion = const_cast<void*>(add);; 885 ; 886 dmclass->BuildRealData(addrForRecursion, isTransient);; 887 }; 888 }; 889 }; 890 }; 891 fRealDataClass->GetListOfRealData()->Add(rd);; 892 }; 893}; 894 ; 895//______________________________________________________________________________; 896//______________________________________________________________________________; 897//______________________________________________________________________________; 898 ; 899////////////////////////////////////////////////////////////////////////////////; 900 ; 901class TAutoInspector : public TMemberInspector {; 902public:; 903 Int_t fCount;; 904 TBrowser *fBrowser;; 905 ; 906 TAutoInspector(TBrowser *b); 907 {; 908 // main constructor.; 909 fBrowser = b; fCount = 0;; 910 }; 911 virtual ~TAutoInspector() {}; 912 using TMemberInspector::Inspect;; 913 void Inspect(TClass *cl, const char *parent, const char *name, const void *addr, Bool_t isTransient) override;; 914 Bool_t IsTreatingNonAccessibleTypes() override { return kFALSE; }; 915};; 916 ; 917////////////////////////////////////////////////////////////////////////////////; 918/// This method is called from ShowMembers() via AutoBrowse().; 919 ; 920void TAu",MatchSource.WIKI,doc/v632/TClass_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/TClass_8cxx_source.html
https://root.cern/doc/v632/TClass_8cxx_source.html:57172,Safety,avoid,avoids,57172,"1456 oldcl->fMethod = nullptr;; 1457 ; 1458 }; 1459 ; 1460 SetBit(kLoading);; 1461 // Advertise ourself as the loading class for this class name; 1462 TClass::AddClass(this);; 1463 ; 1464 Bool_t isStl = TClassEdit::IsSTLCont(fName);; 1465 ; 1466 if (!gInterpreter); 1467 ::Fatal(""TClass::Init"", ""gInterpreter not initialized"");; 1468 ; 1469 if (givenInfo) {; 1470 bool invalid = !gInterpreter->ClassInfo_IsValid(givenInfo);; 1471 bool notloaded = !gInterpreter->ClassInfo_IsLoaded(givenInfo);; 1472 auto property = gInterpreter->ClassInfo_Property(givenInfo);; 1473 ; 1474 if (invalid || (notloaded && (property & kIsNamespace)) ||; 1475 !(property & (kIsClass | kIsStruct | kIsNamespace))) {; 1476 if (!TClassEdit::IsSTLCont(fName.Data())) {; 1477 MakeZombie();; 1478 fState = kNoInfo;; 1479 TClass::RemoveClass(this);; 1480 return;; 1481 }; 1482 }; 1483 ; 1484 if (!invalid) {; 1485 fClassInfo = gInterpreter->ClassInfo_Factory(givenInfo);; 1486 fCanLoadClassInfo = false; // avoids calls to LoadClassInfo() if info is already loaded; 1487 if (fState <= kEmulated); 1488 fState = kInterpreted;; 1489 }; 1490 }; 1491 ; 1492 // We need to check if the class it is not fwd declared for the cases where we; 1493 // created a TClass directly in the kForwardDeclared state. Indeed in those cases; 1494 // fClassInfo will always be nullptr.; 1495 if (fState!=kForwardDeclared && !fClassInfo && !TClassEdit::IsArtificial(fName)) {; 1496 ; 1497 if (fState == kHasTClassInit) {; 1498 // If the TClass is being generated from a ROOT dictionary,; 1499 // even though we do not seem to have a CINT dictionary for; 1500 // the class, we will will try to load it anyway UNLESS; 1501 // the class is an STL container (or string).; 1502 // This is because we do not expect the CINT dictionary; 1503 // to be present for all STL classes (and we can handle; 1504 // the lack of CINT dictionary in that cases).; 1505 // However, the cling the dictionary no longer carries; 1506 // an instantiation with it, unless we re",MatchSource.WIKI,doc/v632/TClass_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/TClass_8cxx_source.html
https://root.cern/doc/v632/TClass_8cxx_source.html:63047,Safety,safe,safely,63047,"his != htmp->String()) continue;; 1605 oldcl = (TClass*)gROOT->GetListOfClasses()->FindObject(htmp->fOrigName); // gROOT->GetClass (htmp->fOrigName, kFALSE);; 1606 if (oldcl && oldcl != this) {; 1607 persistentRef = oldcl->fPersistentRef.exchange(nullptr);; 1608 ForceReload (oldcl);; 1609 }; 1610 }; 1611 }; 1612 if (fClassInfo) {; 1613 SetTitle(gCling->ClassInfo_Title(fClassInfo));; 1614 if ( fDeclFileName == nullptr || fDeclFileName[0] == '\0' ) {; 1615 fDeclFileName = kUndeterminedClassInfoName;; 1616 // Missing interface:; 1617 // fDeclFileLine = gInterpreter->ClassInfo_FileLine( fClassInfo );; 1618 ; 1619 // But really do not want to set ImplFileLine as it is currently the; 1620 // marker of being 'loaded' or not (reminder loaded == has a TClass bootstrap).; 1621 }; 1622 }; 1623 ; 1624 if (persistentRef) {; 1625 fPersistentRef = persistentRef;; 1626 } else {; 1627 fPersistentRef = new TClass*;; 1628 }; 1629 *fPersistentRef = this;; 1630 ; 1631 if ( isStl || !strncmp(GetName(),""stdext::hash_"",13) || !strncmp(GetName(),""__gnu_cxx::hash_"",16) ) {; 1632 if (fState != kHasTClassInit) {; 1633 // If we have a TClass compiled initialization, we can safely assume that; 1634 // there will also be a collection proxy.; 1635 fCollectionProxy = TVirtualStreamerInfo::Factory()->GenEmulatedProxy( GetName(), silent );; 1636 if (fCollectionProxy) {; 1637 fSizeof = fCollectionProxy->Sizeof();; 1638 ; 1639 // Numeric Collections have implicit conversions:; 1640 GetSchemaRules(kTRUE);; 1641 ; 1642 } else if (!silent) {; 1643 Warning(""Init"",""Collection proxy for %s was not properly initialized!"",GetName());; 1644 }; 1645 if (fStreamer==nullptr) {; 1646 fStreamer = TVirtualStreamerInfo::Factory()->GenEmulatedClassStreamer( GetName(), silent );; 1647 }; 1648 }; 1649 } else if (TClassEdit::IsStdPair(GetName())) {; 1650 // std::pairs have implicit conversions; 1651 GetSchemaRules(kTRUE);; 1652 }; 1653 ; 1654 ResetBit(kLoading);; 1655}; 1656 ; 1657/////////////////////////////////////////",MatchSource.WIKI,doc/v632/TClass_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/TClass_8cxx_source.html
https://root.cern/doc/v632/TClass_8cxx_source.html:103520,Safety,avoid,avoid,103520,"t;; 2733 offset += baseclass->Size();; 2734 } else if (element->IsA() == TStreamerSTL::Class()) {; 2735 TStreamerSTL *base = (TStreamerSTL*)element;; 2736 TClass *baseclass = base->GetClassPointer();; 2737 if (!baseclass) return -1;; 2738 Int_t subOffset = baseclass->GetBaseClassOffsetRecurse(cl);; 2739 if (subOffset == -2) return -2;; 2740 if (subOffset != -1) return offset+subOffset;; 2741 offset += baseclass->Size();; 2742 ; 2743 } else {; 2744 Error(""GetBaseClassOffsetRecurse"",""Unexpected element type for base class: %s\n"",element->IsA()->GetName());; 2745 }; 2746 }; 2747 }; 2748 return -1;; 2749 }; 2750 }; 2751 ; 2752 TClass *c;; 2753 Int_t off;; 2754 TBaseClass *inh;; 2755 TObjLink *lnk = nullptr;; 2756 if (fBase.load() == nullptr); 2757 lnk = GetListOfBases()->FirstLink();; 2758 else; 2759 lnk = fBase.load()->FirstLink();; 2760 ; 2761 // otherwise look at inheritance tree; 2762 while (lnk) {; 2763 inh = (TBaseClass *)lnk->GetObject();; 2764 //use option load=kFALSE to avoid a warning like:; 2765 //""Warning in <TClass::TClass>: no dictionary for class TRefCnt is available""; 2766 //We can not afford to not have the class if it exist, so we; 2767 //use kTRUE.; 2768 c = inh->GetClassPointer(kTRUE); // kFALSE);; 2769 if (c) {; 2770 if (cl == c) {; 2771 if ((inh->Property() & kIsVirtualBase) != 0); 2772 return -2;; 2773 return inh->GetDelta();; 2774 }; 2775 off = c->GetBaseClassOffsetRecurse(cl);; 2776 if (off == -2) return -2;; 2777 if (off != -1) {; 2778 return off + inh->GetDelta();; 2779 }; 2780 }; 2781 lnk = lnk->Next();; 2782 }; 2783 return -1;; 2784}; 2785 ; 2786////////////////////////////////////////////////////////////////////////////////; 2787/// - Return data member offset to the base class ""cl"".; 2788/// - Returns -1 in case ""cl"" is not a base class.; 2789/// Takes care of multiple inheritance.; 2790 ; 2791Int_t TClass::GetBaseClassOffset(const TClass *toBase, void *address, bool isDerivedObject); 2792{; 2793 // Warning(""GetBaseClassOffset"",""Requires th",MatchSource.WIKI,doc/v632/TClass_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/TClass_8cxx_source.html
https://root.cern/doc/v632/TClass_8cxx_source.html:114260,Safety,avoid,avoid,114260,"provided; 3013 // by a user provided TClassGenerator. We have no way of knowing whether; 3014 // those do (or even can) behave the same way as the ROOT dictionary and; 3015 // have the 'dictionary is now available for use' step informs the existing; 3016 // TClass that their dictionary is now available.; 3017 ; 3018 //we may pass here in case of a dummy class created by TVirtualStreamerInfo; 3019 load = kTRUE;; 3020 }; 3021 ; 3022 if (TClassEdit::IsArtificial(name)) {; 3023 // If there is a @ symbol (followed by a version number) then this is a synthetic class name created; 3024 // from an already normalized name for the purpose of supporting schema evolution.; 3025 // There is no dictionary or interpreter information about this kind of class, the only; 3026 // (undesirable) side-effect of doing the search would be a waste of CPU time and potential; 3027 // auto-loading or auto-parsing based on the scope of the name.; 3028 return cl;; 3029 }; 3030 ; 3031 // To avoid spurious auto parsing, let's check if the name as-is is; 3032 // known in the TClassTable.; 3033 DictFuncPtr_t dict = TClassTable::GetDictNorm(name);; 3034 if (dict) {; 3035 // The name is normalized, so the result of the first search is; 3036 // authoritative.; 3037 if (!cl && !load) return nullptr;; 3038 ; 3039 TClass *loadedcl = (dict)();; 3040 if (loadedcl) {; 3041 loadedcl->PostLoadCheck();; 3042 return loadedcl;; 3043 }; 3044 ; 3045 // We should really not fall through to here, but if we do, let's just; 3046 // continue as before ...; 3047 }; 3048 ; 3049 std::string normalizedName;; 3050 Bool_t checkTable = kFALSE;; 3051 ; 3052 if (!cl) {; 3053 {; 3054 TInterpreter::SuspendAutoLoadingRAII autoloadOff(gInterpreter);; 3055 TClassEdit::GetNormalizedName(normalizedName, name);; 3056 }; 3057 // Try the normalized name.; 3058 if (normalizedName != name) {; 3059 cl = (TClass*)gROOT->GetListOfClasses()->FindObject(normalizedName.c_str());; 3060 ; 3061 if (cl) {; 3062 if (cl->IsLoaded() || cl->TestBit(kUnloa",MatchSource.WIKI,doc/v632/TClass_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/TClass_8cxx_source.html
https://root.cern/doc/v632/TClass_8cxx_source.html:116582,Safety,avoid,avoid,116582,"lizedName != name);; 3072 }; 3073 ; 3074 if (!load) return nullptr;; 3075 ; 3076// This assertion currently fails because of; 3077// TClass *c1 = TClass::GetClass(""basic_iostream<char,char_traits<char> >"");; 3078// TClass *c2 = TClass::GetClass(""std::iostream"");; 3079// where the TClassEdit normalized name of iostream is basic_iostream<char>; 3080// i.e missing the addition of the default parameter. This is because TClingLookupHelper; 3081// uses only 'part' of TMetaUtils::GetNormalizedName.; 3082 ; 3083// if (!cl) {; 3084// TDataType* dataType = (TDataType*)gROOT->GetListOfTypes()->FindObject(name);; 3085// TClass *altcl = dataType ? (TClass*)gROOT->GetListOfClasses()->FindObject(dataType->GetFullTypeName()) : 0;; 3086// if (altcl && normalizedName != altcl->GetName()); 3087// ::Fatal(""TClass::GetClass"",""The existing name (%s) for %s is different from the normalized name: %s\n"",; 3088// altcl->GetName(), name, normalizedName.c_str());; 3089// }; 3090 ; 3091 // We want to avoid auto-parsing due to intentionally missing dictionary for std::pair.; 3092 // However, we don't need this special treatement in rootcling (there is no auto-parsing); 3093 // and we want to make that the TClass for the pair goes through the regular creation; 3094 // mechanism (i.e. in rootcling they should be in kInterpreted state and never in; 3095 // kEmulated state) so that they have proper interpreter (ClassInfo) information which; 3096 // will be used to create the TProtoClass (if one is requested for the pair).; 3097 const bool ispair = TClassEdit::IsStdPair(normalizedName) && !IsFromRootCling();; 3098 const bool ispairbase = TClassEdit::IsStdPairBase(normalizedName) && !IsFromRootCling();; 3099 ; 3100 TClass *loadedcl = nullptr;; 3101 if (checkTable) {; 3102 loadedcl = LoadClassDefault(normalizedName.c_str(),silent);; 3103 } else {; 3104 if (gInterpreter->AutoLoad(normalizedName.c_str(),kTRUE)) {; 3105 // At this point more information has been loaded. This; 3106 // information might be ",MatchSource.WIKI,doc/v632/TClass_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/TClass_8cxx_source.html
https://root.cern/doc/v632/TClass_8cxx_source.html:121169,Safety,avoid,avoided,121169," collcl = LoadClassDefault(collname.c_str(), silent);; 3163 if (collcl) {; 3164 auto p = collcl->GetCollectionProxy();; 3165 if (p); 3166 cl = p->GetValueClass();; 3167 if (cl); 3168 return cl;; 3169 }; 3170 }; 3171 }; 3172 } else if (TClassEdit::IsSTLCont( normalizedName.c_str() )) {; 3173 ; 3174 return gInterpreter->GenerateTClass(normalizedName.c_str(), kTRUE, silent);; 3175 }; 3176 ; 3177 // Check the interpreter only after autoparsing the template if any.; 3178 if (!ispairbase) {; 3179 std::string::size_type posLess = normalizedName.find('<');; 3180 if (posLess != std::string::npos) {; 3181 gCling->AutoParse(normalizedName.substr(0, posLess).c_str());; 3182 }; 3183 }; 3184 ; 3185 //last attempt. Look in CINT list of all (compiled+interpreted) classes; 3186 if (gDebug>0){; 3187 printf(""TClass::GetClass: Header Parsing - The representation of %s was not found in the type system. A lookup in the interpreter is about to be tried: this can cause parsing. This can be avoided selecting %s in the linkdef/selection file.\n"",normalizedName.c_str(), normalizedName.c_str());; 3188 }; 3189 if (normalizedName.length()) {; 3190 auto cci = gInterpreter->CheckClassInfo(normalizedName.c_str(), kTRUE /* autoload */,; 3191 kTRUE /*Only class, structs and ns*/);; 3192 ; 3193 // We could have an interpreted class with an inline ClassDef, in this case we do not; 3194 // want to create an 'interpreted' TClass but we want the one triggered via the call to; 3195 // the Dictionary member. If we go ahead and generate the 'interpreted' version it will; 3196 // replace if/when there is a call to IsA on an object of this type.; 3197 ; 3198 if (cci == TInterpreter::kWithClassDefInline) {; 3199 auto ci = gInterpreter->ClassInfo_Factory(normalizedName.c_str());; 3200 auto funcDecl = gInterpreter->GetFunctionWithPrototype(ci, ""Dictionary"", """", false, ROOT::kExactMatch);; 3201 auto method = gInterpreter->MethodInfo_Factory(funcDecl);; 3202 typedef void (*tcling_callfunc_Wrapper_t)(void *, int, vo",MatchSource.WIKI,doc/v632/TClass_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/TClass_8cxx_source.html
https://root.cern/doc/v632/TClass_8cxx_source.html:123676,Safety,avoid,avoid,123676,"e default arguments as requested by the user); 3219 std::string alternative;; 3220 gInterpreter->GetInterpreterTypeName(normalizedName.c_str(), alternative, kTRUE);; 3221 if (alternative.empty()); 3222 return nullptr;; 3223 const char *altname = alternative.c_str();; 3224 if (strncmp(altname, ""std::"", 5) == 0) {; 3225 // For namespace (for example std::__1), GetInterpreterTypeName does; 3226 // not strip std::, so we must do it explicitly here.; 3227 altname += 5;; 3228 }; 3229 if (altname != normalizedName && strcmp(altname, name) != 0) {; 3230 // altname now contains the full name of the class including a possible; 3231 // namespace if there has been a using namespace statement.; 3232 ; 3233 // At least in the case C<string [2]> (normalized) vs C<string[2]> (altname); 3234 // the TClassEdit normalization and the TMetaUtils normalization leads to; 3235 // two different space layout. To avoid an infinite recursion, we also; 3236 // add the test on (altname != name); 3237 ; 3238 return GetClass(altname, load);; 3239 }; 3240 ; 3241 TClass *ncl = gInterpreter->GenerateTClass(normalizedName.c_str(), /* emulation = */ kFALSE, silent);; 3242 if (!ncl->IsZombie()) {; 3243 return ncl;; 3244 }; 3245 delete ncl;; 3246 }; 3247 }; 3248 return nullptr;; 3249}; 3250 ; 3251////////////////////////////////////////////////////////////////////////////////; 3252/// Return pointer to class with name.; 3253 ; 3254TClass *TClass::GetClass(const std::type_info& typeinfo, Bool_t load, Bool_t /* silent */, size_t hint_pair_offset, size_t hint_pair_size); 3255{; 3256 if (!gROOT->GetListOfClasses()); 3257 return nullptr;; 3258 ; 3259 //protect access to TROOT::GetIdMap; 3260 R__READ_LOCKGUARD(ROOT::gCoreMutex);; 3261 ; 3262 TClass* cl = GetIdMap()->Find(typeinfo.name());; 3263 ; 3264 if (cl && cl->IsLoaded()) return cl;; 3265 ; 3266 R__WRITE_LOCKGUARD(ROOT::gCoreMutex);; 3267 ; 3268 // Now that we got the write lock, another thread may have constructed the; 3269 // TClass while we were waitin",MatchSource.WIKI,doc/v632/TClass_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/TClass_8cxx_source.html
https://root.cern/doc/v632/TClass_8cxx_source.html:126194,Safety,avoid,avoid,126194,"n.; 3270 ; 3271 cl = GetIdMap()->Find(typeinfo.name());; 3272 ; 3273 if (cl) {; 3274 if (cl->IsLoaded()) return cl;; 3275 //we may pass here in case of a dummy class created by TVirtualStreamerInfo; 3276 load = kTRUE;; 3277 } else {; 3278 // Note we might need support for typedefs and simple types!; 3279 ; 3280 // TDataType *objType = GetType(name, load);; 3281 //if (objType) {; 3282 // const char *typdfName = objType->GetTypeName();; 3283 // if (typdfName && strcmp(typdfName, name)) {; 3284 // cl = GetClass(typdfName, load);; 3285 // return cl;; 3286 // }; 3287 // }; 3288 }; 3289 ; 3290 if (!load) return nullptr;; 3291 ; 3292 DictFuncPtr_t dict = TClassTable::GetDict(typeinfo);; 3293 if (dict) {; 3294 cl = (dict)();; 3295 if (cl) cl->PostLoadCheck();; 3296 return cl;; 3297 }; 3298 if (cl) return cl;; 3299 ; 3300 TIter next(gROOT->GetListOfClassGenerators());; 3301 TClassGenerator *gen;; 3302 while( (gen = (TClassGenerator*) next()) ) {; 3303 cl = gen->GetClass(typeinfo,load);; 3304 if (cl) {; 3305 cl->PostLoadCheck();; 3306 return cl;; 3307 }; 3308 }; 3309 ; 3310 // try AutoLoading the typeinfo; 3311 int autoload_old = gCling->SetClassAutoLoading(1);; 3312 if (!autoload_old) {; 3313 // Re-disable, we just meant to test; 3314 gCling->SetClassAutoLoading(0);; 3315 }; 3316 if (autoload_old && gInterpreter->AutoLoad(typeinfo,kTRUE)) {; 3317 // Disable autoload to avoid potential infinite recursion; 3318 TInterpreter::SuspendAutoLoadingRAII autoloadOff(gInterpreter);; 3319 cl = GetClass(typeinfo, load, hint_pair_offset, hint_pair_size);; 3320 if (cl) {; 3321 return cl;; 3322 }; 3323 }; 3324 ; 3325 if (hint_pair_offset) {; 3326 int err = 0;; 3327 char* demangled_name = TClassEdit::DemangleTypeIdName(typeinfo, err);; 3328 if (!err) {; 3329 cl = TClass::GetClass(demangled_name, load, kTRUE, hint_pair_offset, hint_pair_size);; 3330 free(demangled_name);; 3331 if (cl); 3332 return cl;; 3333 }; 3334 }; 3335 ; 3336 // last attempt. Look in the interpreter list of all (compiled+",MatchSource.WIKI,doc/v632/TClass_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/TClass_8cxx_source.html
https://root.cern/doc/v632/TClass_8cxx_source.html:138879,Safety,safe,safe,138879,"lassInit) {; 3641 ; 3642 R__LOCKGUARD(gInterpreterMutex);; 3643 if (!fHasRootPcmInfo) {; 3644 // The bases are in our ProtoClass; we don't need the class info.; 3645 TProtoClass *proto = TClassTable::GetProtoNorm(GetName());; 3646 if (proto && proto->FillTClass(this)); 3647 return fBase;; 3648 }; 3649 }; 3650 // We test again on fCanLoadClassInfo has another thread may have executed it.; 3651 if (!fHasRootPcmInfo && fCanLoadClassInfo) {; 3652 LoadClassInfo();; 3653 }; 3654 }; 3655 if (!fClassInfo); 3656 return nullptr;; 3657 ; 3658 if (!gInterpreter); 3659 Fatal(""GetListOfBases"", ""gInterpreter not initialized"");; 3660 ; 3661 R__LOCKGUARD(gInterpreterMutex);; 3662 if (!fBase.load()) {; 3663 gInterpreter->CreateListOfBaseClasses(this);; 3664 }; 3665 }; 3666 return fBase;; 3667}; 3668 ; 3669////////////////////////////////////////////////////////////////////////////////; 3670/// Return a list containing the TEnums of a class.; 3671///; 3672/// The list returned is safe to use from multiple thread without explicitly; 3673/// taking the ROOT global lock.; 3674///; 3675/// In the case the TClass represents a namespace, the returned list will; 3676/// implicit take the ROOT global lock upon any access (see TListOfEnumsWithLock); 3677///; 3678/// In the case the TClass represents a class or struct and requestListLoading; 3679/// is true, the list is immutable (and thus safe to access from multiple thread; 3680/// without taking the global lock at all).; 3681///; 3682/// In the case the TClass represents a class or struct and requestListLoading; 3683/// is false, the list is mutable and thus we return a TListOfEnumsWithLock; 3684/// which will implicit take the ROOT global lock upon any access.; 3685 ; 3686TList *TClass::GetListOfEnums(Bool_t requestListLoading /* = kTRUE */); 3687{; 3688 auto temp = fEnums.load();; 3689 if (temp) {; 3690 if (requestListLoading) {; 3691 if (fProperty == -1) Property();; 3692 if (! ((kIsClass | kIsStruct | kIsUnion) & fProperty) ) {; 3693 R__L",MatchSource.WIKI,doc/v632/TClass_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/TClass_8cxx_source.html
https://root.cern/doc/v632/TClass_8cxx_source.html:139287,Safety,safe,safe,139287,")); 3647 return fBase;; 3648 }; 3649 }; 3650 // We test again on fCanLoadClassInfo has another thread may have executed it.; 3651 if (!fHasRootPcmInfo && fCanLoadClassInfo) {; 3652 LoadClassInfo();; 3653 }; 3654 }; 3655 if (!fClassInfo); 3656 return nullptr;; 3657 ; 3658 if (!gInterpreter); 3659 Fatal(""GetListOfBases"", ""gInterpreter not initialized"");; 3660 ; 3661 R__LOCKGUARD(gInterpreterMutex);; 3662 if (!fBase.load()) {; 3663 gInterpreter->CreateListOfBaseClasses(this);; 3664 }; 3665 }; 3666 return fBase;; 3667}; 3668 ; 3669////////////////////////////////////////////////////////////////////////////////; 3670/// Return a list containing the TEnums of a class.; 3671///; 3672/// The list returned is safe to use from multiple thread without explicitly; 3673/// taking the ROOT global lock.; 3674///; 3675/// In the case the TClass represents a namespace, the returned list will; 3676/// implicit take the ROOT global lock upon any access (see TListOfEnumsWithLock); 3677///; 3678/// In the case the TClass represents a class or struct and requestListLoading; 3679/// is true, the list is immutable (and thus safe to access from multiple thread; 3680/// without taking the global lock at all).; 3681///; 3682/// In the case the TClass represents a class or struct and requestListLoading; 3683/// is false, the list is mutable and thus we return a TListOfEnumsWithLock; 3684/// which will implicit take the ROOT global lock upon any access.; 3685 ; 3686TList *TClass::GetListOfEnums(Bool_t requestListLoading /* = kTRUE */); 3687{; 3688 auto temp = fEnums.load();; 3689 if (temp) {; 3690 if (requestListLoading) {; 3691 if (fProperty == -1) Property();; 3692 if (! ((kIsClass | kIsStruct | kIsUnion) & fProperty) ) {; 3693 R__LOCKGUARD(gROOTMutex);; 3694 temp->Load();; 3695 } else if ( temp->IsA() == TListOfEnumsWithLock::Class() ) {; 3696 // We have a class for which the list was not loaded fully at; 3697 // first use.; 3698 R__LOCKGUARD(gROOTMutex);; 3699 temp->Load();; 3700 }; 3701 }; ",MatchSource.WIKI,doc/v632/TClass_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/TClass_8cxx_source.html
https://root.cern/doc/v632/TClass_8cxx_source.html:174368,Safety,safe,safe,174368,"ion from the currently loaded class library.; 4591/// - -1: Assume no class library loaded (emulated class).; 4592///; 4593/// Warning: If we create a new streamer info, whether or not the build; 4594/// optimizes is controlled externally to us by a global variable!; 4595/// Don't call us unless you have set that variable properly; 4596/// with TStreamer::Optimize()!; 4597///; 4598 ; 4599TVirtualStreamerInfo* TClass::GetStreamerInfo(Int_t version /* = 0 */, Bool_t isTransient /* = false */) const; 4600{; 4601 TVirtualStreamerInfo *sinfo = fLastReadInfo;; 4602 ; 4603 // Version 0 is special, it means the currently loaded version.; 4604 // We need to set it at the beginning to be able to guess it correctly.; 4605 ; 4606 if (version == 0); 4607 version = fClassVersion;; 4608 ; 4609 // If the StreamerInfo is assigned to the fLastReadInfo, we are; 4610 // guaranteed it was built and compiled.; 4611 if (sinfo && sinfo->GetClassVersion() == version); 4612 return sinfo;; 4613 ; 4614 // Note that the access to fClassVersion above is technically not thread-safe with a low probably of problems.; 4615 // fClassVersion is not an atomic and is modified TClass::SetClassVersion (called from RootClassVersion via; 4616 // ROOT::ResetClassVersion) and is 'somewhat' protected by the atomic fVersionUsed.; 4617 // However, direct access to fClassVersion should be replaced by calls to GetClassVersion to set fVersionUsed.; 4618 // Even with such a change the code here and in these functions need to be reviewed as a cursory look seem; 4619 // to indicates they are not yet properly protection against mutli-thread access.; 4620 //; 4621 // However, the use of these functions is rare and mostly done at library loading time which should; 4622 // in almost all cases preceeds the possibility of GetStreamerInfo being called from multiple thread; 4623 // on that same TClass object.; 4624 //; 4625 // Summary: need careful review but risk of problem is extremely low.; 4626 ; 4627 R__LOCKGUARD(gInterp",MatchSource.WIKI,doc/v632/TClass_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/TClass_8cxx_source.html
https://root.cern/doc/v632/TClass_8cxx_source.html:175238,Safety,risk,risk,175238,"fo->GetClassVersion() == version); 4612 return sinfo;; 4613 ; 4614 // Note that the access to fClassVersion above is technically not thread-safe with a low probably of problems.; 4615 // fClassVersion is not an atomic and is modified TClass::SetClassVersion (called from RootClassVersion via; 4616 // ROOT::ResetClassVersion) and is 'somewhat' protected by the atomic fVersionUsed.; 4617 // However, direct access to fClassVersion should be replaced by calls to GetClassVersion to set fVersionUsed.; 4618 // Even with such a change the code here and in these functions need to be reviewed as a cursory look seem; 4619 // to indicates they are not yet properly protection against mutli-thread access.; 4620 //; 4621 // However, the use of these functions is rare and mostly done at library loading time which should; 4622 // in almost all cases preceeds the possibility of GetStreamerInfo being called from multiple thread; 4623 // on that same TClass object.; 4624 //; 4625 // Summary: need careful review but risk of problem is extremely low.; 4626 ; 4627 R__LOCKGUARD(gInterpreterMutex);; 4628 ; 4629 return GetStreamerInfoImpl(version, isTransient);; 4630};; 4631 ; 4632// Implementation of/for TStreamerInfo::GetStreamerInfo.; 4633// This routine assumes the global lock has been taken.; 4634TVirtualStreamerInfo* TClass::GetStreamerInfoImpl(Int_t version, Bool_t silent) const; 4635{; 4636 // Warning: version may be -1 for an emulated class, or -2 if the; 4637 // user requested the emulated streamerInfo for an abstract; 4638 // base class, even though we have a dictionary for it.; 4639 ; 4640 if ((version < -1) || (version >= (fStreamerInfo->GetSize()-1))) {; 4641 Error(""GetStreamerInfo"", ""class: %s, attempting to access a wrong version: %d"", GetName(), version);; 4642 // FIXME: Shouldn't we go to -1 here, or better just abort?; 4643 version = fClassVersion;; 4644 }; 4645 ; 4646 TVirtualStreamerInfo *sinfo = (TVirtualStreamerInfo *)fStreamerInfo->At(version);; 4647 ; 4648 if (!sinfo &",MatchSource.WIKI,doc/v632/TClass_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/TClass_8cxx_source.html
https://root.cern/doc/v632/TClass_8cxx_source.html:176063,Safety,abort,abort,176063,"reamerInfo being called from multiple thread; 4623 // on that same TClass object.; 4624 //; 4625 // Summary: need careful review but risk of problem is extremely low.; 4626 ; 4627 R__LOCKGUARD(gInterpreterMutex);; 4628 ; 4629 return GetStreamerInfoImpl(version, isTransient);; 4630};; 4631 ; 4632// Implementation of/for TStreamerInfo::GetStreamerInfo.; 4633// This routine assumes the global lock has been taken.; 4634TVirtualStreamerInfo* TClass::GetStreamerInfoImpl(Int_t version, Bool_t silent) const; 4635{; 4636 // Warning: version may be -1 for an emulated class, or -2 if the; 4637 // user requested the emulated streamerInfo for an abstract; 4638 // base class, even though we have a dictionary for it.; 4639 ; 4640 if ((version < -1) || (version >= (fStreamerInfo->GetSize()-1))) {; 4641 Error(""GetStreamerInfo"", ""class: %s, attempting to access a wrong version: %d"", GetName(), version);; 4642 // FIXME: Shouldn't we go to -1 here, or better just abort?; 4643 version = fClassVersion;; 4644 }; 4645 ; 4646 TVirtualStreamerInfo *sinfo = (TVirtualStreamerInfo *)fStreamerInfo->At(version);; 4647 ; 4648 if (!sinfo && (version != fClassVersion)) {; 4649 // When the requested version does not exist we return; 4650 // the TVirtualStreamerInfo for the currently loaded class version.; 4651 // FIXME: This arguably makes no sense, we should warn and return nothing instead.; 4652 // Note: This is done for STL collections; 4653 // Note: fClassVersion could be -1 here (for an emulated class).; 4654 // This is also the code path take for unversioned classes.; 4655 sinfo = (TVirtualStreamerInfo*) fStreamerInfo->At(fClassVersion);; 4656 }; 4657 ; 4658 if (!sinfo) {; 4659 // We just were not able to find a streamer info, we have to make a new one.; 4660 TMmallocDescTemp setreset;; 4661 sinfo = TVirtualStreamerInfo::Factory()->NewInfo(const_cast<TClass*>(this));; 4662 fStreamerInfo->AddAtAndExpand(sinfo, fClassVersion);; 4663 if (gDebug > 0) {; 4664 printf(""Creating StreamerInfo for class: ",MatchSource.WIKI,doc/v632/TClass_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/TClass_8cxx_source.html
https://root.cern/doc/v632/TClass_8cxx_source.html:238590,Safety,safe,safe,238590,"ClassInfo);; 6171 }; 6172 } else {; 6173 ; 6174 if (fStreamer) {; 6175 kl->fStreamerType = kExternal;; 6176 kl->fStreamerImpl = &TClass::StreamerExternal;; 6177 }; 6178 ; 6179 kl->fStreamerType |= kEmulatedStreamer;; 6180 kl->SetStreamerImpl();; 6181 // fProperty was *not* set so that it can be forced to be recalculated; 6182 // next time.; 6183 return 0;; 6184 }; 6185 ; 6186 return fProperty;; 6187}; 6188 ; 6189////////////////////////////////////////////////////////////////////////////////; 6190/// Internal routine to set calculate the class properties that can only be; 6191/// known at run-time, for example whether the Hash member function and the; 6192/// destructor are consistent.; 6193 ; 6194void TClass::SetRuntimeProperties(); 6195{; 6196 // For now, no need to lock this routines as fRuntimeProperties is; 6197 // the only atomic set here and this is done at the end; 6198 // and there is no downside if the execution is done twice.; 6199 ; 6200 // Note SetRuntimeProperties is set to const as it is technically; 6201 // thread-safe.; 6202 ; 6203 UChar_t properties = static_cast<UChar_t>(ERuntimeProperties::kSet);; 6204 ; 6205 if (ROOT::Internal::TCheckHashRecursiveRemoveConsistency::Check(*this)); 6206 properties |= static_cast<UChar_t>(ERuntimeProperties::kConsistentHash);; 6207 ; 6208 const_cast<TClass *>(this)->fRuntimeProperties = properties;; 6209}; 6210 ; 6211////////////////////////////////////////////////////////////////////////////////; 6212/// Internal routine to set fStreamerImpl based on the value of; 6213/// fStreamerType.; 6214 ; 6215void TClass::SetStreamerImpl(); 6216{; 6217 switch (fStreamerType) {; 6218 case kTObject: fStreamerImpl = &TClass::StreamerTObject; break;; 6219 case kForeign: fStreamerImpl = &TClass::StreamerStreamerInfo; break;; 6220 case kExternal: fStreamerImpl = &TClass::StreamerExternal; break;; 6221 case kInstrumented: {; 6222 if (fConvStreamerFunc) fStreamerImpl = &TClass::ConvStreamerInstrumented;; 6223 else if (fStreamerFunc) ",MatchSource.WIKI,doc/v632/TClass_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/TClass_8cxx_source.html
https://root.cern/doc/v632/TClass_8cxx_source.html:242498,Safety,safe,safe,242498,"uTitle = title;; 6272}; 6273 ; 6274////////////////////////////////////////////////////////////////////////////////; 6275/// This function installs a global IsA function for this class.; 6276/// The global IsA function will be used if there is no local IsA function (fIsA); 6277///; 6278/// A global IsA function has the signature:; 6279///; 6280/// ~~~ {.cpp}; 6281/// TClass *func( TClass *cl, const void *obj);; 6282/// ~~~; 6283///; 6284/// 'cl' is a pointer to the TClass object that corresponds to the; 6285/// 'pointer type' used to retrieve the value 'obj'; 6286///; 6287/// For example with:; 6288/// ~~~ {.cpp}; 6289/// TNamed * m = new TNamed(""example"",""test"");; 6290/// TObject* o = m; 6291/// ~~~; 6292/// and; 6293/// the global IsA function would be called with TObject::Class() as; 6294/// the first parameter and the exact numerical value in the pointer; 6295/// 'o'.; 6296///; 6297/// In other word, inside the global IsA function. it is safe to C-style; 6298/// cast the value of 'obj' into a pointer to the class described by 'cl'.; 6299 ; 6300void TClass::SetGlobalIsA(IsAGlobalFunc_t func); 6301{; 6302 fGlobalIsA = func;; 6303}; 6304 ; 6305////////////////////////////////////////////////////////////////////////////////; 6306/// Call this method to indicate that the shared library containing this; 6307/// class's code has been removed (unloaded) from the process's memory; 6308 ; 6309void TClass::SetUnloaded(); 6310{; 6311 if (TestBit(kUnloaded) && !TestBit(kUnloading)) {; 6312 // Don't redo the work.; 6313 return;; 6314 }; 6315 SetBit(kUnloading);; 6316 ; 6317 //R__ASSERT(fState == kLoaded);; 6318 if (fState != kLoaded) {; 6319 Fatal(""SetUnloaded"",""The TClass for %s is being unloaded when in state %d\n"",; 6320 GetName(),(int)fState);; 6321 }; 6322 ; 6323 InsertTClassInRegistryRAII insertRAII(fState, fName, fNoInfoOrEmuOrFwdDeclNameRegistry);; 6324 ; 6325 // Make sure SetClassInfo, re-calculated the state.; 6326 fState = kForwardDeclared;; 6327 ; 6328 delete fIsA",MatchSource.WIKI,doc/v632/TClass_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/TClass_8cxx_source.html
https://root.cern/doc/v632/TClass_8cxx_source.html:281708,Safety,safe,safe,281708,"reamerInfo in the given slot.; 7318/// Update the slot accordingly.; 7319 ; 7320void TClass::RemoveStreamerInfo(Int_t slot); 7321{; 7322 if (fStreamerInfo->GetSize() >= slot) {; 7323 R__LOCKGUARD(gInterpreterMutex);; 7324 TVirtualStreamerInfo *info = (TVirtualStreamerInfo*)fStreamerInfo->At(slot);; 7325 fStreamerInfo->RemoveAt(fClassVersion);; 7326 if (fLastReadInfo.load() == info); 7327 fLastReadInfo = nullptr;; 7328 if (fCurrentInfo.load() == info); 7329 fCurrentInfo = nullptr;; 7330 delete info;; 7331 if (fState == kEmulated && fStreamerInfo->GetEntries() == 0) {; 7332 fState = kForwardDeclared;; 7333 }; 7334 }; 7335}; 7336 ; 7337////////////////////////////////////////////////////////////////////////////////; 7338/// Return true is the Hash/RecursiveRemove setup is consistent, i.e. when all; 7339/// classes in the class hierarchy that overload TObject::Hash do call; 7340/// ROOT::CallRecursiveRemoveIfNeeded in their destructor.; 7341/// i.e. it is safe to call the Hash virtual function during the RecursiveRemove operation.; 7342/// This routines is used for a small subset of the class for which we need; 7343/// the answer before gROOT is properly initialized.; 7344 ; 7345Bool_t ROOT::Internal::HasConsistentHashMember(const char *cname); 7346{; 7347 // Hand selection of correct classes, those classes should be; 7348 // cross-checked in testHashRecursiveRemove.cxx; 7349 static const char *handVerified[] = {; 7350 ""TEnvRec"", ""TDataType"", ""TObjArray"", ""TList"", ""THashList"",; 7351 ""TClass"", ""TCling"", ""TInterpreter"", ""TMethod"", ""ROOT::Internal::TCheckHashRecursiveRemoveConsistency"",; 7352 ""TCheckHashRecursiveRemoveConsistency"", ""TGWindow"",; 7353 ""TDirectory"", ""TDirectoryFile"", ""TObject"", ""TH1"",; 7354 ""TQClass"", ""TGlobal"" };; 7355 ; 7356 if (cname && cname[0]) {; 7357 for (auto cursor : handVerified) {; 7358 if (strcmp(cname, cursor) == 0); 7359 return true;; 7360 }; 7361 }; 7362 return false;; 7363}; 7364 ; 7365///////////////////////////////////////////////////////////",MatchSource.WIKI,doc/v632/TClass_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/TClass_8cxx_source.html
https://root.cern/doc/v632/TClass_8cxx_source.html:283009,Safety,safe,safe,283009," classes, those classes should be; 7348 // cross-checked in testHashRecursiveRemove.cxx; 7349 static const char *handVerified[] = {; 7350 ""TEnvRec"", ""TDataType"", ""TObjArray"", ""TList"", ""THashList"",; 7351 ""TClass"", ""TCling"", ""TInterpreter"", ""TMethod"", ""ROOT::Internal::TCheckHashRecursiveRemoveConsistency"",; 7352 ""TCheckHashRecursiveRemoveConsistency"", ""TGWindow"",; 7353 ""TDirectory"", ""TDirectoryFile"", ""TObject"", ""TH1"",; 7354 ""TQClass"", ""TGlobal"" };; 7355 ; 7356 if (cname && cname[0]) {; 7357 for (auto cursor : handVerified) {; 7358 if (strcmp(cname, cursor) == 0); 7359 return true;; 7360 }; 7361 }; 7362 return false;; 7363}; 7364 ; 7365////////////////////////////////////////////////////////////////////////////////; 7366/// Return true is the Hash/RecursiveRemove setup is consistent, i.e. when all; 7367/// classes in the class hierarchy that overload TObject::Hash do call; 7368/// ROOT::CallRecursiveRemoveIfNeeded in their destructor.; 7369/// i.e. it is safe to call the Hash virtual function during the RecursiveRemove operation.; 7370 ; 7371Bool_t ROOT::Internal::HasConsistentHashMember(TClass &clRef); 7372{; 7373 return clRef.HasConsistentHashMember();; 7374}; 7375 ; 7376////////////////////////////////////////////////////////////////////////////////; 7377/// Return true if we have access to a constructor usable for I/O. This is; 7378/// typically the default constructor but can also be a constructor specifically; 7379/// marked for I/O (for example a constructor taking a TRootIOCtor* as an; 7380/// argument). In other words, if this routine returns true, TClass::New is; 7381/// guarantee to succeed.; 7382/// To know if the class described by this TClass has a default constructor; 7383/// (public or not), use; 7384/// \code{.cpp}; 7385/// cl->GetProperty() & kClassHasDefaultCtor; 7386/// \endcode; 7387/// To know if the class described by this TClass has a public default; 7388/// constructor use:; 7389/// \code{.cpp}; 7390/// gInterpreter->ClassInfo_HasDefaultConstruc",MatchSource.WIKI,doc/v632/TClass_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/TClass_8cxx_source.html
https://root.cern/doc/v632/TClass_8cxx_source.html:2202,Security,access,access,2202,"ethods of the; 21class/struct/namespace it represents. Conversely, if built through 3. or 1., it does not carry the information which is necessary; 22to ROOT to perform I/O of instances of the class/struct it represents.; 23The mechanisms 1., 2. and 3. are not mutually exclusive: it can happen that during the execution of the program, all; 24the three are triggered, modifying the state of the TClass instance.; 25 ; 26In order to retrieve a TClass instance from the type system, a query can be executed as follows through the static; 27TClass::GetClass method:; 28 ; 29~~~ {.cpp}; 30auto myClassTClass_0 = TClass::GetClass(""myClass"");; 31auto myClassTClass_1 = TClass::GetClass<myClass>();; 32auto myClassTClass_2 = TClass::GetClass(myClassTypeInfo);; 33~~~; 34 ; 35The name of classes is crucial for ROOT. A careful procedure of *name normalization* is carried out for; 36each and every class. A *normalized name* is a valid C++ class name.; 37In order to access the name of a class within the ROOT type system, the method TClass::GetName() can be used.; 38*/; 39 ; 40//*-*x7.5 macros/layout_class; 41 ; 42#include ""TClass.h""; 43 ; 44#include ""strlcpy.h""; 45#include ""snprintf.h""; 46#include ""TBaseClass.h""; 47#include ""TBrowser.h""; 48#include ""TBuffer.h""; 49#include ""TClassGenerator.h""; 50#include ""TClassEdit.h""; 51#include ""TClassMenuItem.h""; 52#include ""TClassRef.h""; 53#include ""TClassTable.h""; 54#include ""TDataMember.h""; 55#include ""TDataType.h""; 56#include ""TDatime.h""; 57#include ""TEnum.h""; 58#include ""TError.h""; 59#include ""TExMap.h""; 60#include ""TFunctionTemplate.h""; 61#include ""THashList.h""; 62#include ""TInterpreter.h""; 63#include ""TMemberInspector.h""; 64#include ""TMethod.h""; 65#include ""TMethodArg.h""; 66#include ""TMethodCall.h""; 67#include ""TObjArray.h""; 68#include ""TObjString.h""; 69#include ""TProtoClass.h""; 70#include ""TROOT.h""; 71#include ""TRealData.h""; 72#include ""TCheckHashRecursiveRemoveConsistency.h"" // Private header; 73#include ""TStreamer.h""; 74#include ""TStreamerEl",MatchSource.WIKI,doc/v632/TClass_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/TClass_8cxx_source.html
https://root.cern/doc/v632/TClass_8cxx_source.html:5598,Security,hash,hash,5598,".h""; 125#include ""TRefArray.h""; 126 ; 127using std::multimap, std::make_pair, std::string;; 128 ; 129// Mutex to protect CINT and META operations; 130// (exported to be used for similar cases in related classes); 131 ; 132TVirtualMutex* gInterpreterMutex = nullptr;; 133 ; 134namespace {; 135 ; 136 static constexpr const char kUndeterminedClassInfoName[] = ""<NOT YET DETERMINED FROM fClassInfo>"";; 137 ; 138 class TMmallocDescTemp {; 139 private:; 140 void *fSave;; 141 public:; 142 TMmallocDescTemp(void *value = nullptr) :; 143 fSave(ROOT::Internal::gMmallocDesc) { ROOT::Internal::gMmallocDesc = value; }; 144 ~TMmallocDescTemp() { ROOT::Internal::gMmallocDesc = fSave; }; 145 };; 146 ; 147 // When a new class is created, we need to be able to find; 148 // if there are any existing classes that have the same name; 149 // after any typedefs are expanded. (This only really affects; 150 // template arguments.) To avoid having to search through all classes; 151 // in that case, we keep a hash table mapping from the fully; 152 // typedef-expanded names to the original class names.; 153 // An entry is made in the table only if they are actually different.; 154 //; 155 // In these objects, the TObjString base holds the typedef-expanded; 156 // name (the hash key), and fOrigName holds the original class name; 157 // (the value to which the key maps).; 158 //; 159 class TNameMapNode : public TObjString {; 160 public:; 161 TString fOrigName;; 162 ; 163 TNameMapNode(const char *typedf, const char *orig) :; 164 TObjString (typedf),; 165 fOrigName (orig); 166 {; 167 }; 168 };; 169 ; 170}; 171 ; 172std::atomic<Int_t> TClass::fgClassCount;; 173 ; 174static bool IsFromRootCling() {; 175 // rootcling also uses TCling for generating the dictionary ROOT files.; 176 const static bool foundSymbol = dlsym(RTLD_DEFAULT, ""usedToIdentifyRootClingByDlSym"");; 177 return foundSymbol;; 178}; 179 ; 180// Implementation of the TDeclNameRegistry; 181 ; 182////////////////////////////////////////////////",MatchSource.WIKI,doc/v632/TClass_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/TClass_8cxx_source.html
https://root.cern/doc/v632/TClass_8cxx_source.html:5866,Security,hash,hash,5866,"lptr;; 133 ; 134namespace {; 135 ; 136 static constexpr const char kUndeterminedClassInfoName[] = ""<NOT YET DETERMINED FROM fClassInfo>"";; 137 ; 138 class TMmallocDescTemp {; 139 private:; 140 void *fSave;; 141 public:; 142 TMmallocDescTemp(void *value = nullptr) :; 143 fSave(ROOT::Internal::gMmallocDesc) { ROOT::Internal::gMmallocDesc = value; }; 144 ~TMmallocDescTemp() { ROOT::Internal::gMmallocDesc = fSave; }; 145 };; 146 ; 147 // When a new class is created, we need to be able to find; 148 // if there are any existing classes that have the same name; 149 // after any typedefs are expanded. (This only really affects; 150 // template arguments.) To avoid having to search through all classes; 151 // in that case, we keep a hash table mapping from the fully; 152 // typedef-expanded names to the original class names.; 153 // An entry is made in the table only if they are actually different.; 154 //; 155 // In these objects, the TObjString base holds the typedef-expanded; 156 // name (the hash key), and fOrigName holds the original class name; 157 // (the value to which the key maps).; 158 //; 159 class TNameMapNode : public TObjString {; 160 public:; 161 TString fOrigName;; 162 ; 163 TNameMapNode(const char *typedf, const char *orig) :; 164 TObjString (typedf),; 165 fOrigName (orig); 166 {; 167 }; 168 };; 169 ; 170}; 171 ; 172std::atomic<Int_t> TClass::fgClassCount;; 173 ; 174static bool IsFromRootCling() {; 175 // rootcling also uses TCling for generating the dictionary ROOT files.; 176 const static bool foundSymbol = dlsym(RTLD_DEFAULT, ""usedToIdentifyRootClingByDlSym"");; 177 return foundSymbol;; 178}; 179 ; 180// Implementation of the TDeclNameRegistry; 181 ; 182////////////////////////////////////////////////////////////////////////////////; 183/// TDeclNameRegistry class constructor.; 184 ; 185TClass::TDeclNameRegistry::TDeclNameRegistry(Int_t verbLevel): fVerbLevel(verbLevel); 186{; 187 // MSVC doesn't support fSpinLock=ATOMIC_FLAG_INIT; in the class definition;",MatchSource.WIKI,doc/v632/TClass_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/TClass_8cxx_source.html
https://root.cern/doc/v632/TClass_8cxx_source.html:26816,Security,access,access,26816,"(line)-1);; 743 }; 744 Printf(""%s"", line);; 745}; 746 ; 747THashTable* TClass::fgClassTypedefHash = nullptr;; 748 ; 749//______________________________________________________________________________; 750 ; 751class TBuildRealData : public TMemberInspector {; 752 ; 753private:; 754 void *fRealDataObject;; 755 TClass *fRealDataClass;; 756 ; 757public:; 758 TBuildRealData(void *obj, TClass *cl) {; 759 // Main constructor.; 760 fRealDataObject = obj;; 761 fRealDataClass = cl;; 762 }; 763 using TMemberInspector::Inspect;; 764 void Inspect(TClass *cl, const char *parent, const char *name, const void *addr, Bool_t isTransient) override;; 765 ; 766};; 767 ; 768////////////////////////////////////////////////////////////////////////////////; 769/// This method is called from ShowMembers() via BuildRealdata().; 770 ; 771void TBuildRealData::Inspect(TClass* cl, const char* pname, const char* mname, const void* add, Bool_t isTransient); 772{; 773 TDataMember* dm = cl->GetDataMember(mname);; 774 if (!dm) {; 775 return;; 776 }; 777 ; 778 Bool_t isTransientMember = kFALSE;; 779 ; 780 if (!dm->IsPersistent()) {; 781 // For the DataModelEvolution we need access to the transient member.; 782 // so we now record them in the list of RealData.; 783 isTransientMember = kTRUE;; 784 isTransient = kTRUE;; 785 }; 786 ; 787 TString rname( pname );; 788 // Take into account cases like TPaveStats->TPaveText->TPave->TBox.; 789 // Check that member is in a derived class or an object in the class.; 790 if (cl != fRealDataClass) {; 791 if (!fRealDataClass->InheritsFrom(cl)) {; 792 Ssiz_t dot = rname.Index('.');; 793 if (dot == kNPOS) {; 794 return;; 795 }; 796 rname[dot] = '\0';; 797 if (!fRealDataClass->GetDataMember(rname)) {; 798 //could be a data member in a base class like in this example; 799 // class Event : public Data {; 800 // class Data : public TObject {; 801 // EventHeader fEvtHdr;; 802 // class EventHeader {; 803 // Int_t fEvtNum;; 804 // Int_t fRun;; 805 // Int_t fDate;; 806 // Even",MatchSource.WIKI,doc/v632/TClass_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/TClass_8cxx_source.html
https://root.cern/doc/v632/TClass_8cxx_source.html:36337,Security,access,access,36337,"____________________________________________________________; 1057 ; 1058ClassImp(TClass);; 1059 ; 1060////////////////////////////////////////////////////////////////////////////////; 1061/// Internal, default constructor.; 1062///; 1063/// \note Use `TClass::GetClass(""ClassName"")` to get access to a TClass object for a certain class!; 1064 ; 1065TClass::TClass() :; 1066 TDictionary(),; 1067 fPersistentRef(nullptr),; 1068 fStreamerInfo(nullptr), fConversionStreamerInfo(nullptr), fRealData(nullptr),; 1069 fBase(nullptr), fData(nullptr), fUsingData(nullptr), fEnums(nullptr), fFuncTemplate(nullptr), fMethod(nullptr), fAllPubData(nullptr),; 1070 fAllPubMethod(nullptr), fClassMenuList(nullptr),; 1071 fDeclFileName(""""), fImplFileName(""""), fDeclFileLine(0), fImplFileLine(0),; 1072 fInstanceCount(0), fOnHeap(0),; 1073 fCheckSum(0), fCollectionProxy(nullptr), fClassVersion(0), fClassInfo(nullptr),; 1074 fTypeInfo(nullptr), fShowMembers(nullptr),; 1075 fStreamer(nullptr), fIsA(nullptr), fGlobalIsA(nullptr), fIsAMethod(nullptr),; 1076 fMerge(nullptr), fResetAfterMerge(nullptr), fNew(nullptr), fNewArray(nullptr), fDelete(nullptr), fDeleteArray(nullptr),; 1077 fDestructor(nullptr), fDirAutoAdd(nullptr), fStreamerFunc(nullptr), fConvStreamerFunc(nullptr), fSizeof(-1),; 1078 fCanSplit(-1), fIsSyntheticPair(kFALSE), fHasCustomStreamerMember(kFALSE), fProperty(0), fClassProperty(0), fHasRootPcmInfo(kFALSE), fCanLoadClassInfo(kFALSE),; 1079 fIsOffsetStreamerSet(kFALSE), fVersionUsed(kFALSE), fRuntimeProperties(0), fOffsetStreamer(0), fStreamerType(TClass::kDefault),; 1080 fState(kNoInfo),; 1081 fCurrentInfo(nullptr), fLastReadInfo(nullptr), fRefProxy(nullptr),; 1082 fSchemaRules(nullptr), fStreamerImpl(&TClass::StreamerDefault); 1083 ; 1084{; 1085 // Default ctor.; 1086 ; 1087 R__LOCKGUARD(gInterpreterMutex);; 1088 {; 1089 TMmallocDescTemp setreset;; 1090 fStreamerInfo = new TObjArray(1, -2);; 1091 }; 1092 fDeclFileLine = -2; // -2 for standalone TClass (checked in dtor); 1093}; 109",MatchSource.WIKI,doc/v632/TClass_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/TClass_8cxx_source.html
https://root.cern/doc/v632/TClass_8cxx_source.html:38510,Security,access,access,38510,,MatchSource.WIKI,doc/v632/TClass_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/TClass_8cxx_source.html
https://root.cern/doc/v632/TClass_8cxx_source.html:40991,Security,access,access,40991,"///////////////////; 1147/// Internal constructor.; 1148///; 1149/// \note Use `TClass::GetClass(""ClassName"")` to get access to a TClass object for a certain class!; 1150 ; 1151TClass::TClass(const char *name, Version_t cversion, Bool_t silent) :; 1152 TDictionary(name),; 1153 fPersistentRef(nullptr),; 1154 fStreamerInfo(nullptr), fConversionStreamerInfo(nullptr), fRealData(nullptr),; 1155 fBase(nullptr), fData(nullptr), fUsingData(nullptr), fEnums(nullptr), fFuncTemplate(nullptr), fMethod(nullptr), fAllPubData(nullptr),; 1156 fAllPubMethod(nullptr), fClassMenuList(nullptr),; 1157 fDeclFileName(""""), fImplFileName(""""), fDeclFileLine(0), fImplFileLine(0),; 1158 fInstanceCount(0), fOnHeap(0),; 1159 fCheckSum(0), fCollectionProxy(nullptr), fClassVersion(0), fClassInfo(nullptr),; 1160 fTypeInfo(nullptr), fShowMembers(nullptr),; 1161 fStreamer(nullptr), fIsA(nullptr), fGlobalIsA(nullptr), fIsAMethod(nullptr),; 1162 fMerge(nullptr), fResetAfterMerge(nullptr), fNew(nullptr), fNewArray(nullptr), fDelete(nullptr), fDeleteArray(nullptr),; 1163 fDestructor(nullptr), fDirAutoAdd(nullptr), fStreamerFunc(nullptr), fConvStreamerFunc(nullptr), fSizeof(-1),; 1164 fCanSplit(-1), fIsSyntheticPair(kFALSE), fHasCustomStreamerMember(kFALSE), fProperty(0), fClassProperty(0), fHasRootPcmInfo(kFALSE), fCanLoadClassInfo(kFALSE),; 1165 fIsOffsetStreamerSet(kFALSE), fVersionUsed(kFALSE), fRuntimeProperties(0), fOffsetStreamer(0), fStreamerType(TClass::kDefault),; 1166 fState(kNoInfo),; 1167 fCurrentInfo(nullptr), fLastReadInfo(nullptr), fRefProxy(nullptr),; 1168 fSchemaRules(nullptr), fStreamerImpl(&TClass::StreamerDefault); 1169{; 1170 R__LOCKGUARD(gInterpreterMutex);; 1171 Init(name, cversion, nullptr, nullptr, nullptr, nullptr, -1, -1, nullptr, silent);; 1172}; 1173 ; 1174////////////////////////////////////////////////////////////////////////////////; 1175/// Internal constructor, mimicing the case of a class fwd declared in the interpreter.; 1176///; 1177/// \note Use `TClass::GetClass(""Cl",MatchSource.WIKI,doc/v632/TClass_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/TClass_8cxx_source.html
https://root.cern/doc/v632/TClass_8cxx_source.html:42891,Security,access,access,42891,,MatchSource.WIKI,doc/v632/TClass_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/TClass_8cxx_source.html
https://root.cern/doc/v632/TClass_8cxx_source.html:45589,Security,access,access,45589,,MatchSource.WIKI,doc/v632/TClass_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/TClass_8cxx_source.html
https://root.cern/doc/v632/TClass_8cxx_source.html:48106,Security,access,access,48106,"/////////////////////////; 1271/// Internal constructor.; 1272///; 1273/// \note Use `TClass::GetClass(""class"")` to get access to a TClass object for a certain class!; 1274 ; 1275TClass::TClass(const char *name, Version_t cversion,; 1276 const char *dfil, const char *ifil, Int_t dl, Int_t il, Bool_t silent) :; 1277 TDictionary(name),; 1278 fPersistentRef(nullptr),; 1279 fStreamerInfo(nullptr), fConversionStreamerInfo(nullptr), fRealData(nullptr),; 1280 fBase(nullptr), fData(nullptr), fUsingData(nullptr), fEnums(nullptr), fFuncTemplate(nullptr), fMethod(nullptr), fAllPubData(nullptr),; 1281 fAllPubMethod(nullptr), fClassMenuList(nullptr),; 1282 fDeclFileName(""""), fImplFileName(""""), fDeclFileLine(0), fImplFileLine(0),; 1283 fInstanceCount(0), fOnHeap(0),; 1284 fCheckSum(0), fCollectionProxy(nullptr), fClassVersion(0), fClassInfo(nullptr),; 1285 fTypeInfo(nullptr), fShowMembers(nullptr),; 1286 fStreamer(nullptr), fIsA(nullptr), fGlobalIsA(nullptr), fIsAMethod(nullptr),; 1287 fMerge(nullptr), fResetAfterMerge(nullptr), fNew(nullptr), fNewArray(nullptr), fDelete(nullptr), fDeleteArray(nullptr),; 1288 fDestructor(nullptr), fDirAutoAdd(nullptr), fStreamerFunc(nullptr), fConvStreamerFunc(nullptr), fSizeof(-1),; 1289 fCanSplit(-1), fIsSyntheticPair(kFALSE), fHasCustomStreamerMember(kFALSE), fProperty(0), fClassProperty(0), fHasRootPcmInfo(kFALSE), fCanLoadClassInfo(kFALSE),; 1290 fIsOffsetStreamerSet(kFALSE), fVersionUsed(kFALSE), fRuntimeProperties(0), fOffsetStreamer(0), fStreamerType(TClass::kDefault),; 1291 fState(kNoInfo),; 1292 fCurrentInfo(nullptr), fLastReadInfo(nullptr), fRefProxy(nullptr),; 1293 fSchemaRules(nullptr), fStreamerImpl(&TClass::StreamerDefault); 1294{; 1295 R__LOCKGUARD(gInterpreterMutex);; 1296 Init(name,cversion, nullptr, nullptr, dfil, ifil, dl, il, nullptr, silent);; 1297}; 1298 ; 1299////////////////////////////////////////////////////////////////////////////////; 1300/// Internal constructor.; 1301///; 1302/// \note Use `TClass::GetClass(""class"")`",MatchSource.WIKI,doc/v632/TClass_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/TClass_8cxx_source.html
https://root.cern/doc/v632/TClass_8cxx_source.html:49995,Security,access,access,49995,"ctor.; 1301///; 1302/// \note Use `TClass::GetClass(""class"")` to get access to a TClass object for a certain class!; 1303 ; 1304TClass::TClass(const char *name, Version_t cversion,; 1305 const std::type_info &info, TVirtualIsAProxy *isa,; 1306 const char *dfil, const char *ifil, Int_t dl, Int_t il,; 1307 Bool_t silent) :; 1308 TDictionary(name),; 1309 fPersistentRef(nullptr),; 1310 fStreamerInfo(nullptr), fConversionStreamerInfo(nullptr), fRealData(nullptr),; 1311 fBase(nullptr), fData(nullptr), fUsingData(nullptr), fEnums(nullptr), fFuncTemplate(nullptr), fMethod(nullptr), fAllPubData(nullptr),; 1312 fAllPubMethod(nullptr),; 1313 fClassMenuList(nullptr),; 1314 fDeclFileName(""""), fImplFileName(""""), fDeclFileLine(0), fImplFileLine(0),; 1315 fInstanceCount(0), fOnHeap(0),; 1316 fCheckSum(0), fCollectionProxy(nullptr), fClassVersion(0), fClassInfo(nullptr),; 1317 fTypeInfo(nullptr), fShowMembers(nullptr),; 1318 fStreamer(nullptr), fIsA(nullptr), fGlobalIsA(nullptr), fIsAMethod(nullptr),; 1319 fMerge(nullptr), fResetAfterMerge(nullptr), fNew(nullptr), fNewArray(nullptr), fDelete(nullptr), fDeleteArray(nullptr),; 1320 fDestructor(nullptr), fDirAutoAdd(nullptr), fStreamerFunc(nullptr), fConvStreamerFunc(nullptr), fSizeof(-1),; 1321 fCanSplit(-1), fIsSyntheticPair(kFALSE), fHasCustomStreamerMember(kFALSE), fProperty(0), fClassProperty(0), fHasRootPcmInfo(kFALSE), fCanLoadClassInfo(kFALSE),; 1322 fIsOffsetStreamerSet(kFALSE), fVersionUsed(kFALSE), fRuntimeProperties(0), fOffsetStreamer(0), fStreamerType(TClass::kDefault),; 1323 fState(kHasTClassInit),; 1324 fCurrentInfo(nullptr), fLastReadInfo(nullptr), fRefProxy(nullptr),; 1325 fSchemaRules(nullptr), fStreamerImpl(&TClass::StreamerDefault); 1326{; 1327 R__LOCKGUARD(gInterpreterMutex);; 1328 // use info; 1329 Init(name, cversion, &info, isa, dfil, ifil, dl, il, nullptr, silent);; 1330}; 1331 ; 1332////////////////////////////////////////////////////////////////////////////////; 1333/// we found at least one equivalent.; 133",MatchSource.WIKI,doc/v632/TClass_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/TClass_8cxx_source.html
https://root.cern/doc/v632/TClass_8cxx_source.html:60132,Security,hash,hash,60132,"ss(this);; 1526 return;; 1527 }; 1528 }; 1529 }; 1530 }; 1531 }; 1532 if (!silent && (!fClassInfo && !fCanLoadClassInfo) && !isStl && !TClassEdit::IsArtificial(fName) &&; 1533 !TClassEdit::IsInterpreterDetail(fName.Data()) ) {; 1534 if (fState == kHasTClassInit) {; 1535 if (fImplFileLine == -1 && fClassVersion == 0) {; 1536 // We have a 'transient' class with a ClassDefInline and apparently no interpreter; 1537 // information. Since it is transient, it is more than likely that the lack; 1538 // will be harmles.; 1539 } else {; 1540 ::Error(""TClass::Init"", ""no interpreter information for class %s is available even though it has a TClass ""; 1541 ""initialization routine."",; 1542 fName.Data());; 1543 }; 1544 } else {; 1545 const bool ispairbase = TClassEdit::IsStdPairBase(fName.Data()) && !IsFromRootCling();; 1546 if (!ispairbase); 1547 ::Warning(""TClass::Init"", ""no dictionary for class %s is available"", fName.Data());; 1548 }; 1549 }; 1550 ; 1551 fgClassCount++;; 1552 SetUniqueID(fgClassCount);; 1553 ; 1554 // Make the typedef-expanded -> original hash table entries.; 1555 // There may be several entries for any given key.; 1556 // We only make entries if the typedef-expanded name; 1557 // is different from the original name.; 1558 TString resolvedThis;; 1559 if (!givenInfo && strchr (name, '<')) {; 1560 if ( fName != name) {; 1561 if (!fgClassTypedefHash) {; 1562 fgClassTypedefHash = new THashTable (100, 5);; 1563 fgClassTypedefHash->SetOwner (kTRUE);; 1564 }; 1565 ; 1566 fgClassTypedefHash->Add (new TNameMapNode (name, fName));; 1567 SetBit (kHasNameMapNode);; 1568 ; 1569 }; 1570 resolvedThis = TClassEdit::ResolveTypedef (name, kTRUE);; 1571 if (resolvedThis != name) {; 1572 if (!fgClassTypedefHash) {; 1573 fgClassTypedefHash = new THashTable (100, 5);; 1574 fgClassTypedefHash->SetOwner (kTRUE);; 1575 }; 1576 ; 1577 fgClassTypedefHash->Add (new TNameMapNode (resolvedThis, fName));; 1578 SetBit (kHasNameMapNode);; 1579 }; 1580 ; 1581 }; 1582 ; 1583 //In case a class w",MatchSource.WIKI,doc/v632/TClass_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/TClass_8cxx_source.html
https://root.cern/doc/v632/TClass_8cxx_source.html:64109,Security,hash,hashtables,64109,"sume that; 1634 // there will also be a collection proxy.; 1635 fCollectionProxy = TVirtualStreamerInfo::Factory()->GenEmulatedProxy( GetName(), silent );; 1636 if (fCollectionProxy) {; 1637 fSizeof = fCollectionProxy->Sizeof();; 1638 ; 1639 // Numeric Collections have implicit conversions:; 1640 GetSchemaRules(kTRUE);; 1641 ; 1642 } else if (!silent) {; 1643 Warning(""Init"",""Collection proxy for %s was not properly initialized!"",GetName());; 1644 }; 1645 if (fStreamer==nullptr) {; 1646 fStreamer = TVirtualStreamerInfo::Factory()->GenEmulatedClassStreamer( GetName(), silent );; 1647 }; 1648 }; 1649 } else if (TClassEdit::IsStdPair(GetName())) {; 1650 // std::pairs have implicit conversions; 1651 GetSchemaRules(kTRUE);; 1652 }; 1653 ; 1654 ResetBit(kLoading);; 1655}; 1656 ; 1657////////////////////////////////////////////////////////////////////////////////; 1658/// TClass dtor. Deletes all list that might have been created.; 1659 ; 1660TClass::~TClass(); 1661{; 1662 R__LOCKGUARD(gInterpreterMutex);; 1663 ; 1664 // Remove from the typedef hashtables.; 1665 if (fgClassTypedefHash && TestBit (kHasNameMapNode)) {; 1666 TString resolvedThis = TClassEdit::ResolveTypedef (GetName(), kTRUE);; 1667 TIter next (fgClassTypedefHash->GetListForObject (resolvedThis));; 1668 while ( TNameMapNode* htmp = static_cast<TNameMapNode*> (next()) ) {; 1669 if (resolvedThis == htmp->String() && htmp->fOrigName == GetName()) {; 1670 fgClassTypedefHash->Remove (htmp);; 1671 delete htmp;; 1672 break;; 1673 }; 1674 }; 1675 }; 1676 ; 1677 // Not owning lists, don't call Delete(); 1678 // But this still need to be done first because the TList destructor; 1679 // does access the object contained (via GetObject()->TestBit(kCanDelete)); 1680 delete fStreamer; fStreamer =nullptr;; 1681 delete fAllPubData; fAllPubData =nullptr;; 1682 delete fAllPubMethod; fAllPubMethod=nullptr;; 1683 ; 1684 delete fPersistentRef.load();; 1685 ; 1686 if (fBase.load()); 1687 (*fBase).Delete();; 1688 delete fBase.load();",MatchSource.WIKI,doc/v632/TClass_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/TClass_8cxx_source.html
https://root.cern/doc/v632/TClass_8cxx_source.html:64721,Security,access,access,64721,"646 fStreamer = TVirtualStreamerInfo::Factory()->GenEmulatedClassStreamer( GetName(), silent );; 1647 }; 1648 }; 1649 } else if (TClassEdit::IsStdPair(GetName())) {; 1650 // std::pairs have implicit conversions; 1651 GetSchemaRules(kTRUE);; 1652 }; 1653 ; 1654 ResetBit(kLoading);; 1655}; 1656 ; 1657////////////////////////////////////////////////////////////////////////////////; 1658/// TClass dtor. Deletes all list that might have been created.; 1659 ; 1660TClass::~TClass(); 1661{; 1662 R__LOCKGUARD(gInterpreterMutex);; 1663 ; 1664 // Remove from the typedef hashtables.; 1665 if (fgClassTypedefHash && TestBit (kHasNameMapNode)) {; 1666 TString resolvedThis = TClassEdit::ResolveTypedef (GetName(), kTRUE);; 1667 TIter next (fgClassTypedefHash->GetListForObject (resolvedThis));; 1668 while ( TNameMapNode* htmp = static_cast<TNameMapNode*> (next()) ) {; 1669 if (resolvedThis == htmp->String() && htmp->fOrigName == GetName()) {; 1670 fgClassTypedefHash->Remove (htmp);; 1671 delete htmp;; 1672 break;; 1673 }; 1674 }; 1675 }; 1676 ; 1677 // Not owning lists, don't call Delete(); 1678 // But this still need to be done first because the TList destructor; 1679 // does access the object contained (via GetObject()->TestBit(kCanDelete)); 1680 delete fStreamer; fStreamer =nullptr;; 1681 delete fAllPubData; fAllPubData =nullptr;; 1682 delete fAllPubMethod; fAllPubMethod=nullptr;; 1683 ; 1684 delete fPersistentRef.load();; 1685 ; 1686 if (fBase.load()); 1687 (*fBase).Delete();; 1688 delete fBase.load(); fBase = nullptr;; 1689 ; 1690 if (fData.load()); 1691 (*fData).Delete();; 1692 delete fData.load(); fData = nullptr;; 1693 ; 1694 if (fUsingData.load()); 1695 (*fUsingData).Delete();; 1696 delete fUsingData.load(); fUsingData = nullptr;; 1697 ; 1698 if (fEnums.load()); 1699 (*fEnums).Delete();; 1700 delete fEnums.load(); fEnums = nullptr;; 1701 ; 1702 if (fFuncTemplate); 1703 fFuncTemplate->Delete();; 1704 delete fFuncTemplate; fFuncTemplate = nullptr;; 1705 ; 1706 if (fMethod.load",MatchSource.WIKI,doc/v632/TClass_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/TClass_8cxx_source.html
https://root.cern/doc/v632/TClass_8cxx_source.html:69786,Security,checksum,checksum,69786,"///////////////////////////////////////////; 1839/// Read a class.rules file which contains one rule per line with comment; 1840/// starting with a #; 1841/// - Returns the number of rules loaded.; 1842/// - Returns -1 in case of error.; 1843 ; 1844Int_t TClass::ReadRules( const char *filename ); 1845{; 1846 if (!filename || !filename[0]) {; 1847 ::Error(""TClass::ReadRules"", ""no file name specified"");; 1848 return -1;; 1849 }; 1850 ; 1851 FILE * f = fopen(filename,""r"");; 1852 if (f == nullptr) {; 1853 ::Error(""TClass::ReadRules"",""Failed to open %s\n"",filename);; 1854 return -1;; 1855 }; 1856 Int_t count = ReadRulesContent(f);; 1857 ; 1858 fclose(f);; 1859 return count;; 1860 ; 1861}; 1862 ; 1863////////////////////////////////////////////////////////////////////////////////; 1864/// Add a schema evolution customization rule.; 1865/// The syntax of the rule can be either the short form:; 1866/// ~~~ {.cpp}; 1867/// [type=Read] classname membername [attributes=... ] [version=[...] ] [checksum=[...] ] [oldtype=...] [code={...}]; 1868/// ~~~; 1869/// or the long form; 1870/// ~~~ {.cpp}; 1871/// [type=Read] sourceClass=classname [targetclass=newClassname] [ source=""type membername; [type2 membername2]"" ]; 1872/// [target=""membername3;membername4""] [attributes=... ] [version=...] [checksum=...] [code={...}|functionname]; 1873/// ~~~; 1874///; 1875/// For example to set HepMC::GenVertex::m_event to _not_ owned the object it is pointing to:; 1876/// HepMC::GenVertex m_event attributes=NotOwner; 1877///; 1878/// Semantic of the tags:; 1879/// - type : the type of the rule, valid values: Read, ReadRaw, Write, WriteRaw, the default is 'Read'.; 1880/// - sourceClass : the name of the class as it is on the rule file; 1881/// - targetClass : the name of the class as it is in the current code ; defaults to the value of sourceClass; 1882/// - source : the types and names of the data members from the class on file that are needed, the list is separated by semi-colons ';'; 1883/// -",MatchSource.WIKI,doc/v632/TClass_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/TClass_8cxx_source.html
https://root.cern/doc/v632/TClass_8cxx_source.html:70086,Security,checksum,checksum,70086,"45{; 1846 if (!filename || !filename[0]) {; 1847 ::Error(""TClass::ReadRules"", ""no file name specified"");; 1848 return -1;; 1849 }; 1850 ; 1851 FILE * f = fopen(filename,""r"");; 1852 if (f == nullptr) {; 1853 ::Error(""TClass::ReadRules"",""Failed to open %s\n"",filename);; 1854 return -1;; 1855 }; 1856 Int_t count = ReadRulesContent(f);; 1857 ; 1858 fclose(f);; 1859 return count;; 1860 ; 1861}; 1862 ; 1863////////////////////////////////////////////////////////////////////////////////; 1864/// Add a schema evolution customization rule.; 1865/// The syntax of the rule can be either the short form:; 1866/// ~~~ {.cpp}; 1867/// [type=Read] classname membername [attributes=... ] [version=[...] ] [checksum=[...] ] [oldtype=...] [code={...}]; 1868/// ~~~; 1869/// or the long form; 1870/// ~~~ {.cpp}; 1871/// [type=Read] sourceClass=classname [targetclass=newClassname] [ source=""type membername; [type2 membername2]"" ]; 1872/// [target=""membername3;membername4""] [attributes=... ] [version=...] [checksum=...] [code={...}|functionname]; 1873/// ~~~; 1874///; 1875/// For example to set HepMC::GenVertex::m_event to _not_ owned the object it is pointing to:; 1876/// HepMC::GenVertex m_event attributes=NotOwner; 1877///; 1878/// Semantic of the tags:; 1879/// - type : the type of the rule, valid values: Read, ReadRaw, Write, WriteRaw, the default is 'Read'.; 1880/// - sourceClass : the name of the class as it is on the rule file; 1881/// - targetClass : the name of the class as it is in the current code ; defaults to the value of sourceClass; 1882/// - source : the types and names of the data members from the class on file that are needed, the list is separated by semi-colons ';'; 1883/// - oldtype: in the short form only, indicates the type on disk of the data member.; 1884/// - target : the names of the data members updated by this rule, the list is separated by semi-colons ';'; 1885/// - attributes : list of possible qualifiers among: Owner, NotOwner; 1886/// - version : list of the",MatchSource.WIKI,doc/v632/TClass_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/TClass_8cxx_source.html
https://root.cern/doc/v632/TClass_8cxx_source.html:71208,Security,checksum,checksum,71208,"ect it is pointing to:; 1876/// HepMC::GenVertex m_event attributes=NotOwner; 1877///; 1878/// Semantic of the tags:; 1879/// - type : the type of the rule, valid values: Read, ReadRaw, Write, WriteRaw, the default is 'Read'.; 1880/// - sourceClass : the name of the class as it is on the rule file; 1881/// - targetClass : the name of the class as it is in the current code ; defaults to the value of sourceClass; 1882/// - source : the types and names of the data members from the class on file that are needed, the list is separated by semi-colons ';'; 1883/// - oldtype: in the short form only, indicates the type on disk of the data member.; 1884/// - target : the names of the data members updated by this rule, the list is separated by semi-colons ';'; 1885/// - attributes : list of possible qualifiers among: Owner, NotOwner; 1886/// - version : list of the version of the class layout that this rule applies to. The syntax can be [1,4,5] or [2-] or [1-3] or [-3]; 1887/// - checksum : comma delimited list of the checksums of the class layout that this rule applies to.; 1888/// - code={...} : code to be executed for the rule or name of the function implementing it.; 1889 ; 1890Bool_t TClass::AddRule( const char *rule ); 1891{; 1892 ROOT::TSchemaRule *ruleobj = new ROOT::TSchemaRule();; 1893 if (! ruleobj->SetFromRule( rule ) ) {; 1894 delete ruleobj;; 1895 return kFALSE;; 1896 }; 1897 ; 1898 R__LOCKGUARD(gInterpreterMutex);; 1899 ; 1900 TClass *cl = TClass::GetClass( ruleobj->GetTargetClass() );; 1901 if (!cl) {; 1902 // Create an empty emulated class for now.; 1903 cl = gInterpreter->GenerateTClass(ruleobj->GetTargetClass(), /* emulation = */ kTRUE, /*silent = */ kTRUE);; 1904 }; 1905 ROOT::Detail::TSchemaRuleSet* rset = cl->GetSchemaRules( kTRUE );; 1906 ; 1907 TString errmsg;; 1908 if( !rset->AddRule( ruleobj, ROOT::Detail::TSchemaRuleSet::kCheckConflict, &errmsg ) ) {; 1909 ::Warning( ""TClass::AddRule"", ""The rule for class: \""%s\"": version, \""%s\"" and data members: \""",MatchSource.WIKI,doc/v632/TClass_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/TClass_8cxx_source.html
https://root.cern/doc/v632/TClass_8cxx_source.html:71247,Security,checksum,checksums,71247,"ect it is pointing to:; 1876/// HepMC::GenVertex m_event attributes=NotOwner; 1877///; 1878/// Semantic of the tags:; 1879/// - type : the type of the rule, valid values: Read, ReadRaw, Write, WriteRaw, the default is 'Read'.; 1880/// - sourceClass : the name of the class as it is on the rule file; 1881/// - targetClass : the name of the class as it is in the current code ; defaults to the value of sourceClass; 1882/// - source : the types and names of the data members from the class on file that are needed, the list is separated by semi-colons ';'; 1883/// - oldtype: in the short form only, indicates the type on disk of the data member.; 1884/// - target : the names of the data members updated by this rule, the list is separated by semi-colons ';'; 1885/// - attributes : list of possible qualifiers among: Owner, NotOwner; 1886/// - version : list of the version of the class layout that this rule applies to. The syntax can be [1,4,5] or [2-] or [1-3] or [-3]; 1887/// - checksum : comma delimited list of the checksums of the class layout that this rule applies to.; 1888/// - code={...} : code to be executed for the rule or name of the function implementing it.; 1889 ; 1890Bool_t TClass::AddRule( const char *rule ); 1891{; 1892 ROOT::TSchemaRule *ruleobj = new ROOT::TSchemaRule();; 1893 if (! ruleobj->SetFromRule( rule ) ) {; 1894 delete ruleobj;; 1895 return kFALSE;; 1896 }; 1897 ; 1898 R__LOCKGUARD(gInterpreterMutex);; 1899 ; 1900 TClass *cl = TClass::GetClass( ruleobj->GetTargetClass() );; 1901 if (!cl) {; 1902 // Create an empty emulated class for now.; 1903 cl = gInterpreter->GenerateTClass(ruleobj->GetTargetClass(), /* emulation = */ kTRUE, /*silent = */ kTRUE);; 1904 }; 1905 ROOT::Detail::TSchemaRuleSet* rset = cl->GetSchemaRules( kTRUE );; 1906 ; 1907 TString errmsg;; 1908 if( !rset->AddRule( ruleobj, ROOT::Detail::TSchemaRuleSet::kCheckConflict, &errmsg ) ) {; 1909 ::Warning( ""TClass::AddRule"", ""The rule for class: \""%s\"": version, \""%s\"" and data members: \""",MatchSource.WIKI,doc/v632/TClass_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/TClass_8cxx_source.html
https://root.cern/doc/v632/TClass_8cxx_source.html:78199,Security,access,access,78199,"g(""std::string"");; 2059 if (clRefString == this) {; 2060 return;; 2061 }; 2062 ; 2063 // Complain about stl classes ending up here (unique_ptr etc) - except for; 2064 // pair where we will build .first, .second just fine; 2065 // and those for which the user explicitly requested a dictionary.; 2066 if (!isTransient && GetState() != kHasTClassInit; 2067 && TClassEdit::IsStdClass(GetName()); 2068 && !TClassEdit::IsStdPair(GetName())) {; 2069 Error(""BuildRealData"", ""Inspection for %s not supported!"", GetName());; 2070 }; 2071 ; 2072 // The following statement will recursively call; 2073 // all the subclasses of this class.; 2074 fRealData = new TList;; 2075 TBuildRealData brd(pointer, this);; 2076 ; 2077 // CallShowMember will force a call to InheritsFrom, which indirectly; 2078 // calls TClass::GetClass. It forces the loading of new typedefs in; 2079 // case some of them were not yet loaded.; 2080 if ( ! CallShowMembers(pointer, brd, isTransient) ) {; 2081 if ( isTransient ) {; 2082 // This is a transient data member, so it is probably fine to not have; 2083 // access to its content. However let's no mark it as definitively setup,; 2084 // since another class might use this class for a persistent data member and; 2085 // in this case we really want the error message.; 2086 delete fRealData;; 2087 fRealData = nullptr;; 2088 } else {; 2089 Error(""BuildRealData"", ""Cannot find any ShowMembers function for %s!"", GetName());; 2090 }; 2091 }; 2092 ; 2093 // Take this opportunity to build the real data for base classes.; 2094 // In case one base class is abstract, it would not be possible later; 2095 // to create the list of real data for this abstract class.; 2096 TBaseClass* base = nullptr;; 2097 TIter next(GetListOfBases());; 2098 while ((base = (TBaseClass*) next())) {; 2099 if (base->IsSTLContainer()) {; 2100 continue;; 2101 }; 2102 TClass* c = base->GetClassPointer();; 2103 if (c) {; 2104 c->BuildRealData(nullptr, isTransient);; 2105 }; 2106 }; 2107}; 2108 ; 2109///////",MatchSource.WIKI,doc/v632/TClass_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/TClass_8cxx_source.html
https://root.cern/doc/v632/TClass_8cxx_source.html:82327,Security,access,access,82327,"6 }; 2157 //if (fClassInfo==0 && element->IsBase()) {; 2158 // if (fBase==0) fBase = new TList;; 2159 // TClass *base = element->GetClassPointer();; 2160 // fBase->Add(new TBaseClass(this, cl, eoffset));; 2161 //}; 2162 }; 2163 // The base classes must added last on the list of real data (to help with ambiguous data member names); 2164 next.Reset();; 2165 while ((element = (TStreamerElement*)next())) {; 2166 Int_t etype = element->GetType();; 2167 if (element->IsBase() || etype == TVirtualStreamerInfo::kBase) {; 2168 //base class; 2169 Longptr_t eoffset = element->GetOffset();; 2170 TClass *cle = element->GetClassPointer();; 2171 if (cle) cle->BuildEmulatedRealData(name,offset+eoffset,cl, isTransient);; 2172 }; 2173 }; 2174}; 2175 ; 2176 ; 2177////////////////////////////////////////////////////////////////////////////////; 2178/// Calculate the offset between an object of this class to; 2179/// its base class TObject. The pointer can be adjusted by; 2180/// that offset to access any virtual method of TObject like; 2181/// Streamer() and ShowMembers().; 2182 ; 2183void TClass::CalculateStreamerOffset() const; 2184{; 2185 R__LOCKGUARD(gInterpreterMutex);; 2186 if (!fIsOffsetStreamerSet && HasInterpreterInfo()) {; 2187 // When called via TMapFile (e.g. Update()) make sure that the dictionary; 2188 // gets allocated on the heap and not in the mapped file.; 2189 ; 2190 TMmallocDescTemp setreset;; 2191 fOffsetStreamer = const_cast<TClass*>(this)->GetBaseClassOffsetRecurse(TObject::Class());; 2192 if (fStreamerType == kTObject) {; 2193 fStreamerImpl = &TClass::StreamerTObjectInitialized;; 2194 }; 2195 fIsOffsetStreamerSet = kTRUE;; 2196 }; 2197}; 2198 ; 2199 ; 2200////////////////////////////////////////////////////////////////////////////////; 2201/// Call ShowMembers() on the obj of this class type, passing insp and parent.; 2202/// isATObject is -1 if unknown, 0 if it is not a TObject, and 1 if it is a TObject.; 2203/// The function returns whether it was able to call ",MatchSource.WIKI,doc/v632/TClass_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/TClass_8cxx_source.html
https://root.cern/doc/v632/TClass_8cxx_source.html:90983,Security,access,access,90983,";; 2389 return kTRUE;; 2390}; 2391 ; 2392////////////////////////////////////////////////////////////////////////////////; 2393/// Return the C++ property of this class, eg. is abstract, has virtual base; 2394/// class, see EClassProperty in TDictionary.h; 2395 ; 2396Long_t TClass::ClassProperty() const; 2397{; 2398 if (fProperty == -1) Property();; 2399 return fClassProperty;; 2400}; 2401 ; 2402////////////////////////////////////////////////////////////////////////////////; 2403/// Create a Clone of this TClass object using a different name but using the same 'dictionary'.; 2404/// This effectively creates a hard alias for the class name.; 2405 ; 2406TObject *TClass::Clone(const char *new_name) const; 2407{; 2408 if (new_name == nullptr || new_name[0]=='\0' || fName == new_name) {; 2409 Error(""Clone"",""The name of the class must be changed when cloning a TClass object."");; 2410 return nullptr;; 2411 }; 2412 ; 2413 // Need to lock access to TROOT::GetListOfClasses so the cloning happens atomically; 2414 R__LOCKGUARD(gInterpreterMutex);; 2415 // Temporarily remove the original from the list of classes.; 2416 TClass::RemoveClass(const_cast<TClass*>(this));; 2417 ; 2418 TClass *copy;; 2419 if (fTypeInfo) {; 2420 copy = new TClass(GetName(),; 2421 fClassVersion,; 2422 *fTypeInfo,; 2423 new TIsAProxy(*fTypeInfo),; 2424 GetDeclFileName(),; 2425 GetImplFileName(),; 2426 GetDeclFileLine(),; 2427 GetImplFileLine());; 2428 } else {; 2429 copy = new TClass(GetName(),; 2430 fClassVersion,; 2431 GetDeclFileName(),; 2432 GetImplFileName(),; 2433 GetDeclFileLine(),; 2434 GetImplFileLine());; 2435 }; 2436 copy->fShowMembers = fShowMembers;; 2437 // Remove the copy before renaming it; 2438 TClass::RemoveClass(copy);; 2439 copy->fName = new_name;; 2440 TClass::AddClass(copy);; 2441 ; 2442 copy->SetNew(fNew);; 2443 copy->SetNewArray(fNewArray);; 2444 copy->SetDelete(fDelete);; 2445 copy->SetDeleteArray(fDeleteArray);; 2446 copy->SetDestructor(fDestructor);; 2447 copy->SetDirectoryAuto",MatchSource.WIKI,doc/v632/TClass_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/TClass_8cxx_source.html
https://root.cern/doc/v632/TClass_8cxx_source.html:107098,Security,hash,hash,107098,"= c->GetBaseDataMember(datamember);; 2842 if (cdm) return cdm;; 2843 }; 2844 }; 2845 ; 2846 return nullptr;; 2847}; 2848 ; 2849namespace {; 2850 // A local Helper class used to keep 2 pointer (the collection proxy; 2851 // and the class streamer) in the thread local storage.; 2852 ; 2853 struct TClassLocalStorage {; 2854 TClassLocalStorage() : fCollectionProxy(nullptr), fStreamer(nullptr) {};; 2855 ; 2856 TVirtualCollectionProxy *fCollectionProxy;; 2857 TClassStreamer *fStreamer;; 2858 ; 2859 static TClassLocalStorage *GetStorage(const TClass *cl); 2860 {; 2861 // Return the thread storage for the TClass.; 2862 ; 2863 void **thread_ptr = (*gThreadTsd)(nullptr,ROOT::kClassThreadSlot);; 2864 if (thread_ptr) {; 2865 if (*thread_ptr==nullptr) *thread_ptr = new TExMap();; 2866 TExMap *lmap = (TExMap*)(*thread_ptr);; 2867 ULong_t hash = TString::Hash(&cl, sizeof(void*));; 2868 ULongptr_t local = 0;; 2869 UInt_t slot;; 2870 if ((local = (ULongptr_t)lmap->GetValue(hash, (Longptr_t)cl, slot)) != 0) {; 2871 } else {; 2872 local = (ULongptr_t) new TClassLocalStorage();; 2873 lmap->AddAt(slot, hash, (Longptr_t)cl, local);; 2874 }; 2875 return (TClassLocalStorage*)local;; 2876 }; 2877 return nullptr;; 2878 }; 2879 };; 2880}; 2881 ; 2882////////////////////////////////////////////////////////////////////////////////; 2883/// Return the 'type' of the STL the TClass is representing.; 2884/// and return ROOT::kNotSTL if it is not representing an STL collection.; 2885 ; 2886ROOT::ESTLType TClass::GetCollectionType() const; 2887{; 2888 auto proxy = GetCollectionProxy();; 2889 if (proxy) return (ROOT::ESTLType)proxy->GetCollectionType();; 2890 return ROOT::kNotSTL;; 2891}; 2892 ; 2893 ; 2894////////////////////////////////////////////////////////////////////////////////; 2895/// Return the proxy describing the collection (if any).; 2896 ; 2897TVirtualCollectionProxy *TClass::GetCollectionProxy() const; 2898{; 2899 // Use assert, so that this line (slow because of the TClassEdit) is comp",MatchSource.WIKI,doc/v632/TClass_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/TClass_8cxx_source.html
https://root.cern/doc/v632/TClass_8cxx_source.html:107233,Security,hash,hash,107233,"= c->GetBaseDataMember(datamember);; 2842 if (cdm) return cdm;; 2843 }; 2844 }; 2845 ; 2846 return nullptr;; 2847}; 2848 ; 2849namespace {; 2850 // A local Helper class used to keep 2 pointer (the collection proxy; 2851 // and the class streamer) in the thread local storage.; 2852 ; 2853 struct TClassLocalStorage {; 2854 TClassLocalStorage() : fCollectionProxy(nullptr), fStreamer(nullptr) {};; 2855 ; 2856 TVirtualCollectionProxy *fCollectionProxy;; 2857 TClassStreamer *fStreamer;; 2858 ; 2859 static TClassLocalStorage *GetStorage(const TClass *cl); 2860 {; 2861 // Return the thread storage for the TClass.; 2862 ; 2863 void **thread_ptr = (*gThreadTsd)(nullptr,ROOT::kClassThreadSlot);; 2864 if (thread_ptr) {; 2865 if (*thread_ptr==nullptr) *thread_ptr = new TExMap();; 2866 TExMap *lmap = (TExMap*)(*thread_ptr);; 2867 ULong_t hash = TString::Hash(&cl, sizeof(void*));; 2868 ULongptr_t local = 0;; 2869 UInt_t slot;; 2870 if ((local = (ULongptr_t)lmap->GetValue(hash, (Longptr_t)cl, slot)) != 0) {; 2871 } else {; 2872 local = (ULongptr_t) new TClassLocalStorage();; 2873 lmap->AddAt(slot, hash, (Longptr_t)cl, local);; 2874 }; 2875 return (TClassLocalStorage*)local;; 2876 }; 2877 return nullptr;; 2878 }; 2879 };; 2880}; 2881 ; 2882////////////////////////////////////////////////////////////////////////////////; 2883/// Return the 'type' of the STL the TClass is representing.; 2884/// and return ROOT::kNotSTL if it is not representing an STL collection.; 2885 ; 2886ROOT::ESTLType TClass::GetCollectionType() const; 2887{; 2888 auto proxy = GetCollectionProxy();; 2889 if (proxy) return (ROOT::ESTLType)proxy->GetCollectionType();; 2890 return ROOT::kNotSTL;; 2891}; 2892 ; 2893 ; 2894////////////////////////////////////////////////////////////////////////////////; 2895/// Return the proxy describing the collection (if any).; 2896 ; 2897TVirtualCollectionProxy *TClass::GetCollectionProxy() const; 2898{; 2899 // Use assert, so that this line (slow because of the TClassEdit) is comp",MatchSource.WIKI,doc/v632/TClass_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/TClass_8cxx_source.html
https://root.cern/doc/v632/TClass_8cxx_source.html:107361,Security,hash,hash,107361,"= c->GetBaseDataMember(datamember);; 2842 if (cdm) return cdm;; 2843 }; 2844 }; 2845 ; 2846 return nullptr;; 2847}; 2848 ; 2849namespace {; 2850 // A local Helper class used to keep 2 pointer (the collection proxy; 2851 // and the class streamer) in the thread local storage.; 2852 ; 2853 struct TClassLocalStorage {; 2854 TClassLocalStorage() : fCollectionProxy(nullptr), fStreamer(nullptr) {};; 2855 ; 2856 TVirtualCollectionProxy *fCollectionProxy;; 2857 TClassStreamer *fStreamer;; 2858 ; 2859 static TClassLocalStorage *GetStorage(const TClass *cl); 2860 {; 2861 // Return the thread storage for the TClass.; 2862 ; 2863 void **thread_ptr = (*gThreadTsd)(nullptr,ROOT::kClassThreadSlot);; 2864 if (thread_ptr) {; 2865 if (*thread_ptr==nullptr) *thread_ptr = new TExMap();; 2866 TExMap *lmap = (TExMap*)(*thread_ptr);; 2867 ULong_t hash = TString::Hash(&cl, sizeof(void*));; 2868 ULongptr_t local = 0;; 2869 UInt_t slot;; 2870 if ((local = (ULongptr_t)lmap->GetValue(hash, (Longptr_t)cl, slot)) != 0) {; 2871 } else {; 2872 local = (ULongptr_t) new TClassLocalStorage();; 2873 lmap->AddAt(slot, hash, (Longptr_t)cl, local);; 2874 }; 2875 return (TClassLocalStorage*)local;; 2876 }; 2877 return nullptr;; 2878 }; 2879 };; 2880}; 2881 ; 2882////////////////////////////////////////////////////////////////////////////////; 2883/// Return the 'type' of the STL the TClass is representing.; 2884/// and return ROOT::kNotSTL if it is not representing an STL collection.; 2885 ; 2886ROOT::ESTLType TClass::GetCollectionType() const; 2887{; 2888 auto proxy = GetCollectionProxy();; 2889 if (proxy) return (ROOT::ESTLType)proxy->GetCollectionType();; 2890 return ROOT::kNotSTL;; 2891}; 2892 ; 2893 ; 2894////////////////////////////////////////////////////////////////////////////////; 2895/// Return the proxy describing the collection (if any).; 2896 ; 2897TVirtualCollectionProxy *TClass::GetCollectionProxy() const; 2898{; 2899 // Use assert, so that this line (slow because of the TClassEdit) is comp",MatchSource.WIKI,doc/v632/TClass_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/TClass_8cxx_source.html
https://root.cern/doc/v632/TClass_8cxx_source.html:109986,Security,access,accessor,109986,"912/// Return the Streamer Class allowing streaming (if any).; 2913 ; 2914TClassStreamer *TClass::GetStreamer() const; 2915{; 2916 if (gThreadTsd && fStreamer) {; 2917 TClassLocalStorage *local = TClassLocalStorage::GetStorage(this);; 2918 if (local==nullptr) return fStreamer;; 2919 if (local->fStreamer==nullptr) {; 2920 local->fStreamer = fStreamer->Generate();; 2921 const std::type_info &orig = ( typeid(*fStreamer) );; 2922 if (!local->fStreamer) {; 2923 Warning(""GetStreamer"",""For %s, the TClassStreamer (%s) passed's call to Generate failed!"",GetName(),orig.name());; 2924 } else {; 2925 const std::type_info &copy = ( typeid(*local->fStreamer) );; 2926 if (strcmp(orig.name(),copy.name())!=0) {; 2927 Warning(""GetStreamer"",""For %s, the TClassStreamer passed does not properly implement the Generate method (%s vs %s)\n"",GetName(),orig.name(),copy.name());; 2928 }; 2929 }; 2930 }; 2931 return local->fStreamer;; 2932 }; 2933 return fStreamer;; 2934}; 2935 ; 2936////////////////////////////////////////////////////////////////////////////////; 2937/// Get a wrapper/accessor function around this class custom streamer (member function).; 2938 ; 2939ClassStreamerFunc_t TClass::GetStreamerFunc() const; 2940{; 2941 return fStreamerFunc;; 2942}; 2943 ; 2944////////////////////////////////////////////////////////////////////////////////; 2945/// Get a wrapper/accessor function around this class custom conversion streamer (member function).; 2946 ; 2947ClassConvStreamerFunc_t TClass::GetConvStreamerFunc() const; 2948{; 2949 return fConvStreamerFunc;; 2950}; 2951 ; 2952////////////////////////////////////////////////////////////////////////////////; 2953/// Return the proxy implementing the IsA functionality.; 2954 ; 2955TVirtualIsAProxy* TClass::GetIsAProxy() const; 2956{; 2957 return fIsA;; 2958}; 2959 ; 2960////////////////////////////////////////////////////////////////////////////////; 2961/// Static method returning pointer to TClass of the specified class name.; 2962/// If lo",MatchSource.WIKI,doc/v632/TClass_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/TClass_8cxx_source.html
https://root.cern/doc/v632/TClass_8cxx_source.html:110279,Security,access,accessor,110279,"treamer==nullptr) {; 2920 local->fStreamer = fStreamer->Generate();; 2921 const std::type_info &orig = ( typeid(*fStreamer) );; 2922 if (!local->fStreamer) {; 2923 Warning(""GetStreamer"",""For %s, the TClassStreamer (%s) passed's call to Generate failed!"",GetName(),orig.name());; 2924 } else {; 2925 const std::type_info &copy = ( typeid(*local->fStreamer) );; 2926 if (strcmp(orig.name(),copy.name())!=0) {; 2927 Warning(""GetStreamer"",""For %s, the TClassStreamer passed does not properly implement the Generate method (%s vs %s)\n"",GetName(),orig.name(),copy.name());; 2928 }; 2929 }; 2930 }; 2931 return local->fStreamer;; 2932 }; 2933 return fStreamer;; 2934}; 2935 ; 2936////////////////////////////////////////////////////////////////////////////////; 2937/// Get a wrapper/accessor function around this class custom streamer (member function).; 2938 ; 2939ClassStreamerFunc_t TClass::GetStreamerFunc() const; 2940{; 2941 return fStreamerFunc;; 2942}; 2943 ; 2944////////////////////////////////////////////////////////////////////////////////; 2945/// Get a wrapper/accessor function around this class custom conversion streamer (member function).; 2946 ; 2947ClassConvStreamerFunc_t TClass::GetConvStreamerFunc() const; 2948{; 2949 return fConvStreamerFunc;; 2950}; 2951 ; 2952////////////////////////////////////////////////////////////////////////////////; 2953/// Return the proxy implementing the IsA functionality.; 2954 ; 2955TVirtualIsAProxy* TClass::GetIsAProxy() const; 2956{; 2957 return fIsA;; 2958}; 2959 ; 2960////////////////////////////////////////////////////////////////////////////////; 2961/// Static method returning pointer to TClass of the specified class name.; 2962/// If load is true, an attempt is made to obtain the class by loading; 2963/// the appropriate shared library (directed by the rootmap file).; 2964/// If silent is 'true', do not warn about missing dictionary for the class.; 2965/// (typically used for classes that are used only for transient members); ",MatchSource.WIKI,doc/v632/TClass_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/TClass_8cxx_source.html
https://root.cern/doc/v632/TClass_8cxx_source.html:124421,Security,access,access,124421," name of the class including a possible; 3231 // namespace if there has been a using namespace statement.; 3232 ; 3233 // At least in the case C<string [2]> (normalized) vs C<string[2]> (altname); 3234 // the TClassEdit normalization and the TMetaUtils normalization leads to; 3235 // two different space layout. To avoid an infinite recursion, we also; 3236 // add the test on (altname != name); 3237 ; 3238 return GetClass(altname, load);; 3239 }; 3240 ; 3241 TClass *ncl = gInterpreter->GenerateTClass(normalizedName.c_str(), /* emulation = */ kFALSE, silent);; 3242 if (!ncl->IsZombie()) {; 3243 return ncl;; 3244 }; 3245 delete ncl;; 3246 }; 3247 }; 3248 return nullptr;; 3249}; 3250 ; 3251////////////////////////////////////////////////////////////////////////////////; 3252/// Return pointer to class with name.; 3253 ; 3254TClass *TClass::GetClass(const std::type_info& typeinfo, Bool_t load, Bool_t /* silent */, size_t hint_pair_offset, size_t hint_pair_size); 3255{; 3256 if (!gROOT->GetListOfClasses()); 3257 return nullptr;; 3258 ; 3259 //protect access to TROOT::GetIdMap; 3260 R__READ_LOCKGUARD(ROOT::gCoreMutex);; 3261 ; 3262 TClass* cl = GetIdMap()->Find(typeinfo.name());; 3263 ; 3264 if (cl && cl->IsLoaded()) return cl;; 3265 ; 3266 R__WRITE_LOCKGUARD(ROOT::gCoreMutex);; 3267 ; 3268 // Now that we got the write lock, another thread may have constructed the; 3269 // TClass while we were waiting, so we need to do the checks again.; 3270 ; 3271 cl = GetIdMap()->Find(typeinfo.name());; 3272 ; 3273 if (cl) {; 3274 if (cl->IsLoaded()) return cl;; 3275 //we may pass here in case of a dummy class created by TVirtualStreamerInfo; 3276 load = kTRUE;; 3277 } else {; 3278 // Note we might need support for typedefs and simple types!; 3279 ; 3280 // TDataType *objType = GetType(name, load);; 3281 //if (objType) {; 3282 // const char *typdfName = objType->GetTypeName();; 3283 // if (typdfName && strcmp(typdfName, name)) {; 3284 // cl = GetClass(typdfName, load);; 3285 // return cl",MatchSource.WIKI,doc/v632/TClass_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/TClass_8cxx_source.html
https://root.cern/doc/v632/TClass_8cxx_source.html:139110,Security,access,access,139110,")); 3647 return fBase;; 3648 }; 3649 }; 3650 // We test again on fCanLoadClassInfo has another thread may have executed it.; 3651 if (!fHasRootPcmInfo && fCanLoadClassInfo) {; 3652 LoadClassInfo();; 3653 }; 3654 }; 3655 if (!fClassInfo); 3656 return nullptr;; 3657 ; 3658 if (!gInterpreter); 3659 Fatal(""GetListOfBases"", ""gInterpreter not initialized"");; 3660 ; 3661 R__LOCKGUARD(gInterpreterMutex);; 3662 if (!fBase.load()) {; 3663 gInterpreter->CreateListOfBaseClasses(this);; 3664 }; 3665 }; 3666 return fBase;; 3667}; 3668 ; 3669////////////////////////////////////////////////////////////////////////////////; 3670/// Return a list containing the TEnums of a class.; 3671///; 3672/// The list returned is safe to use from multiple thread without explicitly; 3673/// taking the ROOT global lock.; 3674///; 3675/// In the case the TClass represents a namespace, the returned list will; 3676/// implicit take the ROOT global lock upon any access (see TListOfEnumsWithLock); 3677///; 3678/// In the case the TClass represents a class or struct and requestListLoading; 3679/// is true, the list is immutable (and thus safe to access from multiple thread; 3680/// without taking the global lock at all).; 3681///; 3682/// In the case the TClass represents a class or struct and requestListLoading; 3683/// is false, the list is mutable and thus we return a TListOfEnumsWithLock; 3684/// which will implicit take the ROOT global lock upon any access.; 3685 ; 3686TList *TClass::GetListOfEnums(Bool_t requestListLoading /* = kTRUE */); 3687{; 3688 auto temp = fEnums.load();; 3689 if (temp) {; 3690 if (requestListLoading) {; 3691 if (fProperty == -1) Property();; 3692 if (! ((kIsClass | kIsStruct | kIsUnion) & fProperty) ) {; 3693 R__LOCKGUARD(gROOTMutex);; 3694 temp->Load();; 3695 } else if ( temp->IsA() == TListOfEnumsWithLock::Class() ) {; 3696 // We have a class for which the list was not loaded fully at; 3697 // first use.; 3698 R__LOCKGUARD(gROOTMutex);; 3699 temp->Load();; 3700 }; 3701 }; ",MatchSource.WIKI,doc/v632/TClass_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/TClass_8cxx_source.html
https://root.cern/doc/v632/TClass_8cxx_source.html:139295,Security,access,access,139295,")); 3647 return fBase;; 3648 }; 3649 }; 3650 // We test again on fCanLoadClassInfo has another thread may have executed it.; 3651 if (!fHasRootPcmInfo && fCanLoadClassInfo) {; 3652 LoadClassInfo();; 3653 }; 3654 }; 3655 if (!fClassInfo); 3656 return nullptr;; 3657 ; 3658 if (!gInterpreter); 3659 Fatal(""GetListOfBases"", ""gInterpreter not initialized"");; 3660 ; 3661 R__LOCKGUARD(gInterpreterMutex);; 3662 if (!fBase.load()) {; 3663 gInterpreter->CreateListOfBaseClasses(this);; 3664 }; 3665 }; 3666 return fBase;; 3667}; 3668 ; 3669////////////////////////////////////////////////////////////////////////////////; 3670/// Return a list containing the TEnums of a class.; 3671///; 3672/// The list returned is safe to use from multiple thread without explicitly; 3673/// taking the ROOT global lock.; 3674///; 3675/// In the case the TClass represents a namespace, the returned list will; 3676/// implicit take the ROOT global lock upon any access (see TListOfEnumsWithLock); 3677///; 3678/// In the case the TClass represents a class or struct and requestListLoading; 3679/// is true, the list is immutable (and thus safe to access from multiple thread; 3680/// without taking the global lock at all).; 3681///; 3682/// In the case the TClass represents a class or struct and requestListLoading; 3683/// is false, the list is mutable and thus we return a TListOfEnumsWithLock; 3684/// which will implicit take the ROOT global lock upon any access.; 3685 ; 3686TList *TClass::GetListOfEnums(Bool_t requestListLoading /* = kTRUE */); 3687{; 3688 auto temp = fEnums.load();; 3689 if (temp) {; 3690 if (requestListLoading) {; 3691 if (fProperty == -1) Property();; 3692 if (! ((kIsClass | kIsStruct | kIsUnion) & fProperty) ) {; 3693 R__LOCKGUARD(gROOTMutex);; 3694 temp->Load();; 3695 } else if ( temp->IsA() == TListOfEnumsWithLock::Class() ) {; 3696 // We have a class for which the list was not loaded fully at; 3697 // first use.; 3698 R__LOCKGUARD(gROOTMutex);; 3699 temp->Load();; 3700 }; 3701 }; ",MatchSource.WIKI,doc/v632/TClass_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/TClass_8cxx_source.html
https://root.cern/doc/v632/TClass_8cxx_source.html:139610,Security,access,access,139610,"terpreter not initialized"");; 3660 ; 3661 R__LOCKGUARD(gInterpreterMutex);; 3662 if (!fBase.load()) {; 3663 gInterpreter->CreateListOfBaseClasses(this);; 3664 }; 3665 }; 3666 return fBase;; 3667}; 3668 ; 3669////////////////////////////////////////////////////////////////////////////////; 3670/// Return a list containing the TEnums of a class.; 3671///; 3672/// The list returned is safe to use from multiple thread without explicitly; 3673/// taking the ROOT global lock.; 3674///; 3675/// In the case the TClass represents a namespace, the returned list will; 3676/// implicit take the ROOT global lock upon any access (see TListOfEnumsWithLock); 3677///; 3678/// In the case the TClass represents a class or struct and requestListLoading; 3679/// is true, the list is immutable (and thus safe to access from multiple thread; 3680/// without taking the global lock at all).; 3681///; 3682/// In the case the TClass represents a class or struct and requestListLoading; 3683/// is false, the list is mutable and thus we return a TListOfEnumsWithLock; 3684/// which will implicit take the ROOT global lock upon any access.; 3685 ; 3686TList *TClass::GetListOfEnums(Bool_t requestListLoading /* = kTRUE */); 3687{; 3688 auto temp = fEnums.load();; 3689 if (temp) {; 3690 if (requestListLoading) {; 3691 if (fProperty == -1) Property();; 3692 if (! ((kIsClass | kIsStruct | kIsUnion) & fProperty) ) {; 3693 R__LOCKGUARD(gROOTMutex);; 3694 temp->Load();; 3695 } else if ( temp->IsA() == TListOfEnumsWithLock::Class() ) {; 3696 // We have a class for which the list was not loaded fully at; 3697 // first use.; 3698 R__LOCKGUARD(gROOTMutex);; 3699 temp->Load();; 3700 }; 3701 }; 3702 return temp;; 3703 }; 3704 ; 3705 if (!requestListLoading) {; 3706 if (fProperty == -1) Property();; 3707 R__LOCKGUARD(gInterpreterMutex);; 3708 if (fEnums.load()) {; 3709 return fEnums.load();; 3710 }; 3711 ; 3712 if (IsFromRootCling()) // rootcling is single thread (this save some space in the rootpcm).; 3713 fEnums",MatchSource.WIKI,doc/v632/TClass_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/TClass_8cxx_source.html
https://root.cern/doc/v632/TClass_8cxx_source.html:146731,Security,access,accessible,146731,"rotected methods.; 3844 ; 3845const TList *TClass::GetListOfAllPublicMethods(Bool_t load /* = kTRUE */); 3846{; 3847 R__LOCKGUARD(gInterpreterMutex);; 3848 ; 3849 if (!fAllPubMethod) fAllPubMethod = new TViewPubFunctions(this);; 3850 if (load) {; 3851 if (gDebug>0) Info(""GetListOfAllPublicMethods"",""Header Parsing - Asking for all the methods of class %s: this can involve parsing."",GetName());; 3852 fAllPubMethod->Load();; 3853 }; 3854 return fAllPubMethod;; 3855}; 3856 ; 3857////////////////////////////////////////////////////////////////////////////////; 3858/// Returns a list of all public data members of this class and its base; 3859/// classes. Refers to a subset of the data members in GetListOfDatamembers(); 3860/// so don't do GetListOfAllPublicDataMembers()->Delete().; 3861 ; 3862TList *TClass::GetListOfAllPublicDataMembers(Bool_t load /* = kTRUE */); 3863{; 3864 R__LOCKGUARD(gInterpreterMutex);; 3865 ; 3866 if (!fAllPubData) fAllPubData = new TViewPubDataMembers(this);; 3867 if (load) fAllPubData->Load();; 3868 return fAllPubData;; 3869}; 3870 ; 3871////////////////////////////////////////////////////////////////////////////////; 3872/// Returns list of methods accessible by context menu.; 3873 ; 3874void TClass::GetMenuItems(TList *list); 3875{; 3876 if (!HasInterpreterInfo()) return;; 3877 ; 3878 // get the base class; 3879 TIter nextBase(GetListOfBases(), kIterBackward);; 3880 TBaseClass *baseClass;; 3881 while ((baseClass = (TBaseClass *) nextBase())) {; 3882 TClass *base = baseClass->GetClassPointer();; 3883 if (base) base->GetMenuItems(list);; 3884 }; 3885 ; 3886 // remove methods redefined in this class with no menu; 3887 TMethod *method, *m;; 3888 TIter next(GetListOfMethods(), kIterBackward);; 3889 while ((method = (TMethod*)next())) {; 3890 m = (TMethod*)list->FindObject(method->GetName());; 3891 if (method->IsMenuItem() != kMenuNoMenu) {; 3892 if (!m); 3893 list->AddFirst(method);; 3894 } else {; 3895 if (m && m->GetNargs() == method->GetNargs());",MatchSource.WIKI,doc/v632/TClass_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/TClass_8cxx_source.html
https://root.cern/doc/v632/TClass_8cxx_source.html:161683,Security,access,accessible,161683,"the contents of a class on stdout. Ls output; 4254/// is typically much less verbose then Dump().; 4255/// If options contains 'streamerinfo', run ls on the list of streamerInfos; 4256/// and the list of conversion streamerInfos.; 4257 ; 4258void TClass::ls(Option_t *options) const; 4259{; 4260 TNamed::ls(options);; 4261 if (options==nullptr || options[0]==0) return;; 4262 ; 4263 if (strstr(options,""streamerinfo"")!=nullptr) {; 4264 GetStreamerInfos()->ls(options);; 4265 ; 4266 if (fConversionStreamerInfo.load()) {; 4267 std::map<std::string, TObjArray*>::iterator it;; 4268 std::map<std::string, TObjArray*>::iterator end = (*fConversionStreamerInfo).end();; 4269 for( it = (*fConversionStreamerInfo).begin(); it != end; ++it ) {; 4270 it->second->ls(options);; 4271 }; 4272 }; 4273 }; 4274}; 4275 ; 4276////////////////////////////////////////////////////////////////////////////////; 4277/// Makes a customizable version of the popup menu list, i.e. makes a list; 4278/// of TClassMenuItem objects of methods accessible by context menu.; 4279/// The standard (and different) way consists in having just one element; 4280/// in this list, corresponding to the whole standard list.; 4281/// Once the customizable version is done, one can remove or add elements.; 4282 ; 4283void TClass::MakeCustomMenuList(); 4284{; 4285 R__LOCKGUARD(gInterpreterMutex);; 4286 TClassMenuItem *menuItem;; 4287 ; 4288 // Make sure fClassMenuList is initialized and empty.; 4289 GetMenuList()->Delete();; 4290 ; 4291 TList* methodList = new TList;; 4292 GetMenuItems(methodList);; 4293 ; 4294 TMethod *method;; 4295 TMethodArg *methodArg;; 4296 TClass *classPtr = nullptr;; 4297 TIter next(methodList);; 4298 ; 4299 while ((method = (TMethod*) next())) {; 4300 // if go to a mother class method, add separator; 4301 if (classPtr != method->GetClass()) {; 4302 menuItem = new TClassMenuItem(TClassMenuItem::kPopupSeparator, this);; 4303 fClassMenuList->AddLast(menuItem);; 4304 classPtr = method->GetClass();; 4305 }",MatchSource.WIKI,doc/v632/TClass_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/TClass_8cxx_source.html
https://root.cern/doc/v632/TClass_8cxx_source.html:163643,Security,access,access,163643,"ass();; 4305 }; 4306 // Build the signature of the method; 4307 TString sig;; 4308 TList* margsList = method->GetListOfMethodArgs();; 4309 TIter nextarg(margsList);; 4310 while ((methodArg = (TMethodArg*)nextarg())) {; 4311 sig = sig+"",""+methodArg->GetFullTypeName();; 4312 }; 4313 if (sig.Length()!=0) sig.Remove(0,1); // remove first comma; 4314 menuItem = new TClassMenuItem(TClassMenuItem::kPopupUserFunction, this,; 4315 method->GetName(), method->GetName(),nullptr,; 4316 sig.Data(),-1,TClassMenuItem::kIsSelf);; 4317 if (method->IsMenuItem() == kMenuToggle) menuItem->SetToggle();; 4318 fClassMenuList->Add(menuItem);; 4319 }; 4320 delete methodList;; 4321}; 4322 ; 4323////////////////////////////////////////////////////////////////////////////////; 4324/// Register the fact that an object was moved from the memory location; 4325/// 'arenaFrom' to the memory location 'arenaTo'.; 4326 ; 4327void TClass::Move(void *arenaFrom, void *arenaTo) const; 4328{; 4329 // If/when we have access to a copy constructor (or better to a move; 4330 // constructor), this function should also perform the data move.; 4331 // For now we just information the repository.; 4332 ; 4333 if ((GetState() <= kEmulated) && !fCollectionProxy) {; 4334 MoveAddressInRepository(""TClass::Move"",arenaFrom,arenaTo,this);; 4335 }; 4336}; 4337 ; 4338////////////////////////////////////////////////////////////////////////////////; 4339/// Return the list of menu items associated with the class.; 4340 ; 4341TList *TClass::GetMenuList() const {; 4342 if (!fClassMenuList) {; 4343 fClassMenuList = new TList();; 4344 fClassMenuList->Add(new TClassMenuItem(TClassMenuItem::kPopupStandardList, const_cast<TClass*>(this)));; 4345 }; 4346 return fClassMenuList;; 4347}; 4348 ; 4349////////////////////////////////////////////////////////////////////////////////; 4350/// Return (create an empty one if needed) the list of functions.; 4351/// The major difference with GetListOfMethod is that this returns; 4352/// the interna",MatchSource.WIKI,doc/v632/TClass_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/TClass_8cxx_source.html
https://root.cern/doc/v632/TClass_8cxx_source.html:174312,Security,access,access,174312,"ion from the currently loaded class library.; 4591/// - -1: Assume no class library loaded (emulated class).; 4592///; 4593/// Warning: If we create a new streamer info, whether or not the build; 4594/// optimizes is controlled externally to us by a global variable!; 4595/// Don't call us unless you have set that variable properly; 4596/// with TStreamer::Optimize()!; 4597///; 4598 ; 4599TVirtualStreamerInfo* TClass::GetStreamerInfo(Int_t version /* = 0 */, Bool_t isTransient /* = false */) const; 4600{; 4601 TVirtualStreamerInfo *sinfo = fLastReadInfo;; 4602 ; 4603 // Version 0 is special, it means the currently loaded version.; 4604 // We need to set it at the beginning to be able to guess it correctly.; 4605 ; 4606 if (version == 0); 4607 version = fClassVersion;; 4608 ; 4609 // If the StreamerInfo is assigned to the fLastReadInfo, we are; 4610 // guaranteed it was built and compiled.; 4611 if (sinfo && sinfo->GetClassVersion() == version); 4612 return sinfo;; 4613 ; 4614 // Note that the access to fClassVersion above is technically not thread-safe with a low probably of problems.; 4615 // fClassVersion is not an atomic and is modified TClass::SetClassVersion (called from RootClassVersion via; 4616 // ROOT::ResetClassVersion) and is 'somewhat' protected by the atomic fVersionUsed.; 4617 // However, direct access to fClassVersion should be replaced by calls to GetClassVersion to set fVersionUsed.; 4618 // Even with such a change the code here and in these functions need to be reviewed as a cursory look seem; 4619 // to indicates they are not yet properly protection against mutli-thread access.; 4620 //; 4621 // However, the use of these functions is rare and mostly done at library loading time which should; 4622 // in almost all cases preceeds the possibility of GetStreamerInfo being called from multiple thread; 4623 // on that same TClass object.; 4624 //; 4625 // Summary: need careful review but risk of problem is extremely low.; 4626 ; 4627 R__LOCKGUARD(gInterp",MatchSource.WIKI,doc/v632/TClass_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/TClass_8cxx_source.html
https://root.cern/doc/v632/TClass_8cxx_source.html:174635,Security,access,access,174635,"mize()!; 4597///; 4598 ; 4599TVirtualStreamerInfo* TClass::GetStreamerInfo(Int_t version /* = 0 */, Bool_t isTransient /* = false */) const; 4600{; 4601 TVirtualStreamerInfo *sinfo = fLastReadInfo;; 4602 ; 4603 // Version 0 is special, it means the currently loaded version.; 4604 // We need to set it at the beginning to be able to guess it correctly.; 4605 ; 4606 if (version == 0); 4607 version = fClassVersion;; 4608 ; 4609 // If the StreamerInfo is assigned to the fLastReadInfo, we are; 4610 // guaranteed it was built and compiled.; 4611 if (sinfo && sinfo->GetClassVersion() == version); 4612 return sinfo;; 4613 ; 4614 // Note that the access to fClassVersion above is technically not thread-safe with a low probably of problems.; 4615 // fClassVersion is not an atomic and is modified TClass::SetClassVersion (called from RootClassVersion via; 4616 // ROOT::ResetClassVersion) and is 'somewhat' protected by the atomic fVersionUsed.; 4617 // However, direct access to fClassVersion should be replaced by calls to GetClassVersion to set fVersionUsed.; 4618 // Even with such a change the code here and in these functions need to be reviewed as a cursory look seem; 4619 // to indicates they are not yet properly protection against mutli-thread access.; 4620 //; 4621 // However, the use of these functions is rare and mostly done at library loading time which should; 4622 // in almost all cases preceeds the possibility of GetStreamerInfo being called from multiple thread; 4623 // on that same TClass object.; 4624 //; 4625 // Summary: need careful review but risk of problem is extremely low.; 4626 ; 4627 R__LOCKGUARD(gInterpreterMutex);; 4628 ; 4629 return GetStreamerInfoImpl(version, isTransient);; 4630};; 4631 ; 4632// Implementation of/for TStreamerInfo::GetStreamerInfo.; 4633// This routine assumes the global lock has been taken.; 4634TVirtualStreamerInfo* TClass::GetStreamerInfoImpl(Int_t version, Bool_t silent) const; 4635{; 4636 // Warning: version may be -1 for an emulated",MatchSource.WIKI,doc/v632/TClass_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/TClass_8cxx_source.html
https://root.cern/doc/v632/TClass_8cxx_source.html:174920,Security,access,access,174920,"alStreamerInfo *sinfo = fLastReadInfo;; 4602 ; 4603 // Version 0 is special, it means the currently loaded version.; 4604 // We need to set it at the beginning to be able to guess it correctly.; 4605 ; 4606 if (version == 0); 4607 version = fClassVersion;; 4608 ; 4609 // If the StreamerInfo is assigned to the fLastReadInfo, we are; 4610 // guaranteed it was built and compiled.; 4611 if (sinfo && sinfo->GetClassVersion() == version); 4612 return sinfo;; 4613 ; 4614 // Note that the access to fClassVersion above is technically not thread-safe with a low probably of problems.; 4615 // fClassVersion is not an atomic and is modified TClass::SetClassVersion (called from RootClassVersion via; 4616 // ROOT::ResetClassVersion) and is 'somewhat' protected by the atomic fVersionUsed.; 4617 // However, direct access to fClassVersion should be replaced by calls to GetClassVersion to set fVersionUsed.; 4618 // Even with such a change the code here and in these functions need to be reviewed as a cursory look seem; 4619 // to indicates they are not yet properly protection against mutli-thread access.; 4620 //; 4621 // However, the use of these functions is rare and mostly done at library loading time which should; 4622 // in almost all cases preceeds the possibility of GetStreamerInfo being called from multiple thread; 4623 // on that same TClass object.; 4624 //; 4625 // Summary: need careful review but risk of problem is extremely low.; 4626 ; 4627 R__LOCKGUARD(gInterpreterMutex);; 4628 ; 4629 return GetStreamerInfoImpl(version, isTransient);; 4630};; 4631 ; 4632// Implementation of/for TStreamerInfo::GetStreamerInfo.; 4633// This routine assumes the global lock has been taken.; 4634TVirtualStreamerInfo* TClass::GetStreamerInfoImpl(Int_t version, Bool_t silent) const; 4635{; 4636 // Warning: version may be -1 for an emulated class, or -2 if the; 4637 // user requested the emulated streamerInfo for an abstract; 4638 // base class, even though we have a dictionary for it.; 4639 ; 46",MatchSource.WIKI,doc/v632/TClass_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/TClass_8cxx_source.html
https://root.cern/doc/v632/TClass_8cxx_source.html:175954,Security,access,access,175954,"reamerInfo being called from multiple thread; 4623 // on that same TClass object.; 4624 //; 4625 // Summary: need careful review but risk of problem is extremely low.; 4626 ; 4627 R__LOCKGUARD(gInterpreterMutex);; 4628 ; 4629 return GetStreamerInfoImpl(version, isTransient);; 4630};; 4631 ; 4632// Implementation of/for TStreamerInfo::GetStreamerInfo.; 4633// This routine assumes the global lock has been taken.; 4634TVirtualStreamerInfo* TClass::GetStreamerInfoImpl(Int_t version, Bool_t silent) const; 4635{; 4636 // Warning: version may be -1 for an emulated class, or -2 if the; 4637 // user requested the emulated streamerInfo for an abstract; 4638 // base class, even though we have a dictionary for it.; 4639 ; 4640 if ((version < -1) || (version >= (fStreamerInfo->GetSize()-1))) {; 4641 Error(""GetStreamerInfo"", ""class: %s, attempting to access a wrong version: %d"", GetName(), version);; 4642 // FIXME: Shouldn't we go to -1 here, or better just abort?; 4643 version = fClassVersion;; 4644 }; 4645 ; 4646 TVirtualStreamerInfo *sinfo = (TVirtualStreamerInfo *)fStreamerInfo->At(version);; 4647 ; 4648 if (!sinfo && (version != fClassVersion)) {; 4649 // When the requested version does not exist we return; 4650 // the TVirtualStreamerInfo for the currently loaded class version.; 4651 // FIXME: This arguably makes no sense, we should warn and return nothing instead.; 4652 // Note: This is done for STL collections; 4653 // Note: fClassVersion could be -1 here (for an emulated class).; 4654 // This is also the code path take for unversioned classes.; 4655 sinfo = (TVirtualStreamerInfo*) fStreamerInfo->At(fClassVersion);; 4656 }; 4657 ; 4658 if (!sinfo) {; 4659 // We just were not able to find a streamer info, we have to make a new one.; 4660 TMmallocDescTemp setreset;; 4661 sinfo = TVirtualStreamerInfo::Factory()->NewInfo(const_cast<TClass*>(this));; 4662 fStreamerInfo->AddAtAndExpand(sinfo, fClassVersion);; 4663 if (gDebug > 0) {; 4664 printf(""Creating StreamerInfo for class: ",MatchSource.WIKI,doc/v632/TClass_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/TClass_8cxx_source.html
https://root.cern/doc/v632/TClass_8cxx_source.html:181368,Security,checksum,checksum,181368,"TString::Format(""sourceClass=%s targetClass=%s"",GetName(),newname.Data()));; 4751 } else {; 4752 Error(""GetStreamerInfoAbstractEmulated"", ""could not create TVirtualStreamerInfo"");; 4753 }; 4754 }; 4755 }; 4756 return sinfo;; 4757}; 4758 ; 4759////////////////////////////////////////////////////////////////////////////////; 4760/// For the case where the requestor class is emulated and this class is abstract,; 4761/// returns a pointer to the TVirtualStreamerInfo object for version with an emulated; 4762/// representation whether or not the class is loaded.; 4763///; 4764/// If the object does not exist, it is created; 4765///; 4766/// Warning: If we create a new streamer info, whether or not the build; 4767/// optimizes is controlled externally to us by a global variable!; 4768/// Don't call us unless you have set that variable properly; 4769/// with TStreamer::Optimize()!; 4770///; 4771 ; 4772TVirtualStreamerInfo* TClass::FindStreamerInfoAbstractEmulated(UInt_t checksum) const; 4773{; 4774 TVirtualStreamerInfo *sinfo = nullptr;; 4775 ; 4776 TString newname(GetName());; 4777 newname += ""@@emulated"";; 4778 ; 4779 R__LOCKGUARD(gInterpreterMutex);; 4780 ; 4781 TClass *emulated = TClass::GetClass(newname);; 4782 ; 4783 if (emulated); 4784 sinfo = emulated->FindStreamerInfo(checksum);; 4785 ; 4786 if (!sinfo) {; 4787 // The emulated version of the streamerInfo is explicitly requested and has; 4788 // not been built yet.; 4789 ; 4790 sinfo = (TVirtualStreamerInfo*) FindStreamerInfo(checksum);; 4791 ; 4792 if (!sinfo && (checksum != fCheckSum)) {; 4793 // When the requested version does not exist we return; 4794 // the TVirtualStreamerInfo for the currently loaded class version.; 4795 // FIXME: This arguably makes no sense, we should warn and return nothing instead.; 4796 sinfo = (TVirtualStreamerInfo*) fStreamerInfo->At(fClassVersion);; 4797 }; 4798 ; 4799 if (!sinfo) {; 4800 // Let's take the first available StreamerInfo as a start; 4801 Int_t ninfos = fStreamerInfo->Get",MatchSource.WIKI,doc/v632/TClass_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/TClass_8cxx_source.html
https://root.cern/doc/v632/TClass_8cxx_source.html:181681,Security,checksum,checksum,181681,"TString::Format(""sourceClass=%s targetClass=%s"",GetName(),newname.Data()));; 4751 } else {; 4752 Error(""GetStreamerInfoAbstractEmulated"", ""could not create TVirtualStreamerInfo"");; 4753 }; 4754 }; 4755 }; 4756 return sinfo;; 4757}; 4758 ; 4759////////////////////////////////////////////////////////////////////////////////; 4760/// For the case where the requestor class is emulated and this class is abstract,; 4761/// returns a pointer to the TVirtualStreamerInfo object for version with an emulated; 4762/// representation whether or not the class is loaded.; 4763///; 4764/// If the object does not exist, it is created; 4765///; 4766/// Warning: If we create a new streamer info, whether or not the build; 4767/// optimizes is controlled externally to us by a global variable!; 4768/// Don't call us unless you have set that variable properly; 4769/// with TStreamer::Optimize()!; 4770///; 4771 ; 4772TVirtualStreamerInfo* TClass::FindStreamerInfoAbstractEmulated(UInt_t checksum) const; 4773{; 4774 TVirtualStreamerInfo *sinfo = nullptr;; 4775 ; 4776 TString newname(GetName());; 4777 newname += ""@@emulated"";; 4778 ; 4779 R__LOCKGUARD(gInterpreterMutex);; 4780 ; 4781 TClass *emulated = TClass::GetClass(newname);; 4782 ; 4783 if (emulated); 4784 sinfo = emulated->FindStreamerInfo(checksum);; 4785 ; 4786 if (!sinfo) {; 4787 // The emulated version of the streamerInfo is explicitly requested and has; 4788 // not been built yet.; 4789 ; 4790 sinfo = (TVirtualStreamerInfo*) FindStreamerInfo(checksum);; 4791 ; 4792 if (!sinfo && (checksum != fCheckSum)) {; 4793 // When the requested version does not exist we return; 4794 // the TVirtualStreamerInfo for the currently loaded class version.; 4795 // FIXME: This arguably makes no sense, we should warn and return nothing instead.; 4796 sinfo = (TVirtualStreamerInfo*) fStreamerInfo->At(fClassVersion);; 4797 }; 4798 ; 4799 if (!sinfo) {; 4800 // Let's take the first available StreamerInfo as a start; 4801 Int_t ninfos = fStreamerInfo->Get",MatchSource.WIKI,doc/v632/TClass_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/TClass_8cxx_source.html
https://root.cern/doc/v632/TClass_8cxx_source.html:181892,Security,checksum,checksum,181892,"//; 4764/// If the object does not exist, it is created; 4765///; 4766/// Warning: If we create a new streamer info, whether or not the build; 4767/// optimizes is controlled externally to us by a global variable!; 4768/// Don't call us unless you have set that variable properly; 4769/// with TStreamer::Optimize()!; 4770///; 4771 ; 4772TVirtualStreamerInfo* TClass::FindStreamerInfoAbstractEmulated(UInt_t checksum) const; 4773{; 4774 TVirtualStreamerInfo *sinfo = nullptr;; 4775 ; 4776 TString newname(GetName());; 4777 newname += ""@@emulated"";; 4778 ; 4779 R__LOCKGUARD(gInterpreterMutex);; 4780 ; 4781 TClass *emulated = TClass::GetClass(newname);; 4782 ; 4783 if (emulated); 4784 sinfo = emulated->FindStreamerInfo(checksum);; 4785 ; 4786 if (!sinfo) {; 4787 // The emulated version of the streamerInfo is explicitly requested and has; 4788 // not been built yet.; 4789 ; 4790 sinfo = (TVirtualStreamerInfo*) FindStreamerInfo(checksum);; 4791 ; 4792 if (!sinfo && (checksum != fCheckSum)) {; 4793 // When the requested version does not exist we return; 4794 // the TVirtualStreamerInfo for the currently loaded class version.; 4795 // FIXME: This arguably makes no sense, we should warn and return nothing instead.; 4796 sinfo = (TVirtualStreamerInfo*) fStreamerInfo->At(fClassVersion);; 4797 }; 4798 ; 4799 if (!sinfo) {; 4800 // Let's take the first available StreamerInfo as a start; 4801 Int_t ninfos = fStreamerInfo->GetEntriesFast() - 1;; 4802 for (Int_t i = -1; sinfo == nullptr && i < ninfos; ++i); 4803 sinfo = (TVirtualStreamerInfo *)fStreamerInfo->UncheckedAt(i);; 4804 }; 4805 ; 4806 if (sinfo) {; 4807 sinfo = dynamic_cast<TVirtualStreamerInfo*>( sinfo->Clone() );; 4808 if (sinfo) {; 4809 sinfo->SetClass(nullptr);; 4810 sinfo->SetName( newname );; 4811 sinfo->BuildCheck();; 4812 sinfo->BuildOld();; 4813 sinfo->GetClass()->AddRule(TString::Format(""sourceClass=%s targetClass=%s"",GetName(),newname.Data()));; 4814 } else {; 4815 Error(""GetStreamerInfoAbstractEmulated"", ""could no",MatchSource.WIKI,doc/v632/TClass_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/TClass_8cxx_source.html
https://root.cern/doc/v632/TClass_8cxx_source.html:181931,Security,checksum,checksum,181931,"//; 4764/// If the object does not exist, it is created; 4765///; 4766/// Warning: If we create a new streamer info, whether or not the build; 4767/// optimizes is controlled externally to us by a global variable!; 4768/// Don't call us unless you have set that variable properly; 4769/// with TStreamer::Optimize()!; 4770///; 4771 ; 4772TVirtualStreamerInfo* TClass::FindStreamerInfoAbstractEmulated(UInt_t checksum) const; 4773{; 4774 TVirtualStreamerInfo *sinfo = nullptr;; 4775 ; 4776 TString newname(GetName());; 4777 newname += ""@@emulated"";; 4778 ; 4779 R__LOCKGUARD(gInterpreterMutex);; 4780 ; 4781 TClass *emulated = TClass::GetClass(newname);; 4782 ; 4783 if (emulated); 4784 sinfo = emulated->FindStreamerInfo(checksum);; 4785 ; 4786 if (!sinfo) {; 4787 // The emulated version of the streamerInfo is explicitly requested and has; 4788 // not been built yet.; 4789 ; 4790 sinfo = (TVirtualStreamerInfo*) FindStreamerInfo(checksum);; 4791 ; 4792 if (!sinfo && (checksum != fCheckSum)) {; 4793 // When the requested version does not exist we return; 4794 // the TVirtualStreamerInfo for the currently loaded class version.; 4795 // FIXME: This arguably makes no sense, we should warn and return nothing instead.; 4796 sinfo = (TVirtualStreamerInfo*) fStreamerInfo->At(fClassVersion);; 4797 }; 4798 ; 4799 if (!sinfo) {; 4800 // Let's take the first available StreamerInfo as a start; 4801 Int_t ninfos = fStreamerInfo->GetEntriesFast() - 1;; 4802 for (Int_t i = -1; sinfo == nullptr && i < ninfos; ++i); 4803 sinfo = (TVirtualStreamerInfo *)fStreamerInfo->UncheckedAt(i);; 4804 }; 4805 ; 4806 if (sinfo) {; 4807 sinfo = dynamic_cast<TVirtualStreamerInfo*>( sinfo->Clone() );; 4808 if (sinfo) {; 4809 sinfo->SetClass(nullptr);; 4810 sinfo->SetName( newname );; 4811 sinfo->BuildCheck();; 4812 sinfo->BuildOld();; 4813 sinfo->GetClass()->AddRule(TString::Format(""sourceClass=%s targetClass=%s"",GetName(),newname.Data()));; 4814 } else {; 4815 Error(""GetStreamerInfoAbstractEmulated"", ""could no",MatchSource.WIKI,doc/v632/TClass_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/TClass_8cxx_source.html
https://root.cern/doc/v632/TClass_8cxx_source.html:217481,Security,checksum,checksum,217481,"bility of this class:; 5653/// - -1: Use the default calculation; 5654/// - 0: Disallow splitting; 5655/// - 1: Always allow splitting.; 5656/// - 2: Disallow splitting of the class and splitting of any it's derived classes.; 5657 ; 5658void TClass::SetCanSplit(Int_t splitmode); 5659{; 5660 fCanSplit = splitmode;; 5661}; 5662 ; 5663////////////////////////////////////////////////////////////////////////////////; 5664/// Private function. Set the class version for the 'class' represented by; 5665/// this TClass object. See the public interface:; 5666/// ROOT::ResetClassVersion; 5667/// defined in TClassTable.cxx; 5668///; 5669/// Note on class version numbers:; 5670/// - If no class number has been specified, TClass::GetVersion will return -1; 5671/// - The Class Version 0 request the whole object to be transient; 5672/// - The Class Version 1, unless specified via ClassDef indicates that the; 5673/// I/O should use the TClass checksum to distinguish the layout of the class; 5674 ; 5675void TClass::SetClassVersion(Version_t version); 5676{; 5677 fClassVersion = version;; 5678 fCurrentInfo = nullptr;; 5679}; 5680 ; 5681////////////////////////////////////////////////////////////////////////////////; 5682/// Determine and set pointer to current TVirtualStreamerInfo; 5683 ; 5684TVirtualStreamerInfo* TClass::DetermineCurrentStreamerInfo(); 5685{; 5686 if(!fCurrentInfo.load()) {; 5687 R__READ_LOCKGUARD(ROOT::gCoreMutex);; 5688 fCurrentInfo = (TVirtualStreamerInfo *)(fStreamerInfo->At(fClassVersion));; 5689 }; 5690 return fCurrentInfo;; 5691}; 5692 ; 5693////////////////////////////////////////////////////////////////////////////////; 5694/// Set pointer to current TVirtualStreamerInfo; 5695 ; 5696void TClass::SetCurrentStreamerInfo(TVirtualStreamerInfo *info); 5697{; 5698 fCurrentInfo = info;; 5699}; 5700 ; 5701////////////////////////////////////////////////////////////////////////////////; 5702/// Return size of object of this class.; 5703 ; 5704Int_t TClass::Size() cons",MatchSource.WIKI,doc/v632/TClass_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/TClass_8cxx_source.html
https://root.cern/doc/v632/TClass_8cxx_source.html:231195,Security,checksum,checksum,231195,"BC())); 5991 {if (TClassEdit::IsSTLCont(bc->GetName())) warn = kFALSE;}; 5992 }; 5993 ; 5994 if (warn) {; 5995 if (info->GetOnFileClassVersion()==1 && fClassVersion>1) {; 5996 Warning(""PostLoadCheck"",""\n\; 5997 The class %s transitioned from not having a specified class version\n\; 5998 to having a specified class version (the current class version is %d).\n\; 5999 However too many different non-versioned layouts of the class have\n\; 6000 already been loaded so far. To work around this problem you can\n\; 6001 load fewer 'old' file in the same ROOT session or load the C++ library\n\; 6002 describing the class %s before opening the files or increase the version\n\; 6003 number of the class for example ClassDef(%s,%d).\n\; 6004 Do not try to write objects with the current class definition,\n\; 6005 the files might not be readable.\n"",; 6006 GetName(), fClassVersion, GetName(), GetName(), fStreamerInfo->GetLast()+1);; 6007 } else {; 6008 Warning(""PostLoadCheck"",""\n\; 6009 The StreamerInfo version %d for the class %s which was read\n\; 6010 from a file previously opened has the same version as the active class\n\; 6011 but a different checksum. You should update the version to ClassDef(%s,%d).\n\; 6012 Do not try to write objects with the current class definition,\n\; 6013 the files will not be readable.\n""; 6014 , fClassVersion, GetName(), GetName(), fStreamerInfo->GetLast()+1);; 6015 }; 6016 info->CompareContent(this,nullptr,kTRUE,kTRUE,nullptr);; 6017 SetBit(kWarned);; 6018 }; 6019 }; 6020 }; 6021 if (fCollectionProxy) {; 6022 // Update the related pair's TClass if it has already been created.; 6023 size_t noffset = 0;; 6024 if (strncmp(GetName(), ""map<"", 4) == 0); 6025 noffset = 3;; 6026 else if (strncmp(GetName(), ""multimap<"", 9) == 0); 6027 noffset = 8;; 6028 else if (strncmp(GetName(), ""unordered_map<"", 14) == 0); 6029 noffset = 13;; 6030 else if (strncmp(GetName(), ""unordered_multimap<"", 19) == 0); 6031 noffset = 18;; 6032 if (noffset) {; 6033 std::string pairn",MatchSource.WIKI,doc/v632/TClass_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/TClass_8cxx_source.html
https://root.cern/doc/v632/TClass_8cxx_source.html:249038,Security,checksum,checksum,249038," 6435 }; 6436 }; 6437 update = kFALSE;; 6438 }; 6439 temp = colon+1;; 6440 if (*temp == 0) break;; 6441 }; 6442 //// fStreamerInfo = final;; 6443 delete [] final;; 6444 delete [] save;; 6445 return;; 6446 }; 6447 ; 6448 //info is empty. Let's build the default Streamer descriptor; 6449 ; 6450 char *temp = new char[10000];; 6451 temp[0] = 0;; 6452 char local[100];; 6453 ; 6454 //add list of base classes; 6455 TIter nextb(GetListOfBases());; 6456 TBaseClass *base;; 6457 while ((base = (TBaseClass*) nextb())) {; 6458 snprintf(local,100,""%s;"",base->GetName());; 6459 strlcat(temp,local,10000);; 6460 }; 6461 ; 6462 //add list of data members and types; 6463 TIter nextd(GetListOfDataMembers());; 6464 while ((dm = (TDataMember *) nextd())) {; 6465 if (dm->IsEnum()) continue;; 6466 if (!dm->IsPersistent()) continue;; 6467 Long_t property = dm->Property();; 6468 if (property & kIsStatic) continue;; 6469 TClass *acl = TClass::GetClass(dm->GetTypeName(),update);; 6470 update = kFALSE;; 6471 if (acl) {; 6472 if (acl->GetClassVersion() == 0) continue;; 6473 }; 6474 ; 6475 // dm->GetArrayIndex() returns an empty string if it does not; 6476 // applies; 6477 const char * index = dm->GetArrayIndex();; 6478 if (strlen(index)==0); 6479 snprintf(local,100,""%s %s;"",dm->GetFullTypeName(),dm->GetName());; 6480 else; 6481 snprintf(local,100,""%s %s[%s];"",dm->GetFullTypeName(),dm->GetName(),index);; 6482 strlcat(temp,local,10000);; 6483 }; 6484 //fStreamerInfo = temp;; 6485 delete [] temp;; 6486*/; 6487 return nullptr;; 6488}; 6489 ; 6490////////////////////////////////////////////////////////////////////////////////; 6491/// Return true if the checksum passed as argument is one of the checksum; 6492/// value produced by the older checksum calculation algorithm.; 6493 ; 6494Bool_t TClass::MatchLegacyCheckSum(UInt_t checksum) const; 6495{; 6496 for(UInt_t i = 1; i < kLatestCheckSum; ++i) {; 6497 if ( checksum == GetCheckSum( (ECheckSum) i ) ) return kTRUE;; 6498 }; 6499 return kFALSE;; 6500}; 6",MatchSource.WIKI,doc/v632/TClass_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/TClass_8cxx_source.html
https://root.cern/doc/v632/TClass_8cxx_source.html:249080,Security,checksum,checksum,249080," 6435 }; 6436 }; 6437 update = kFALSE;; 6438 }; 6439 temp = colon+1;; 6440 if (*temp == 0) break;; 6441 }; 6442 //// fStreamerInfo = final;; 6443 delete [] final;; 6444 delete [] save;; 6445 return;; 6446 }; 6447 ; 6448 //info is empty. Let's build the default Streamer descriptor; 6449 ; 6450 char *temp = new char[10000];; 6451 temp[0] = 0;; 6452 char local[100];; 6453 ; 6454 //add list of base classes; 6455 TIter nextb(GetListOfBases());; 6456 TBaseClass *base;; 6457 while ((base = (TBaseClass*) nextb())) {; 6458 snprintf(local,100,""%s;"",base->GetName());; 6459 strlcat(temp,local,10000);; 6460 }; 6461 ; 6462 //add list of data members and types; 6463 TIter nextd(GetListOfDataMembers());; 6464 while ((dm = (TDataMember *) nextd())) {; 6465 if (dm->IsEnum()) continue;; 6466 if (!dm->IsPersistent()) continue;; 6467 Long_t property = dm->Property();; 6468 if (property & kIsStatic) continue;; 6469 TClass *acl = TClass::GetClass(dm->GetTypeName(),update);; 6470 update = kFALSE;; 6471 if (acl) {; 6472 if (acl->GetClassVersion() == 0) continue;; 6473 }; 6474 ; 6475 // dm->GetArrayIndex() returns an empty string if it does not; 6476 // applies; 6477 const char * index = dm->GetArrayIndex();; 6478 if (strlen(index)==0); 6479 snprintf(local,100,""%s %s;"",dm->GetFullTypeName(),dm->GetName());; 6480 else; 6481 snprintf(local,100,""%s %s[%s];"",dm->GetFullTypeName(),dm->GetName(),index);; 6482 strlcat(temp,local,10000);; 6483 }; 6484 //fStreamerInfo = temp;; 6485 delete [] temp;; 6486*/; 6487 return nullptr;; 6488}; 6489 ; 6490////////////////////////////////////////////////////////////////////////////////; 6491/// Return true if the checksum passed as argument is one of the checksum; 6492/// value produced by the older checksum calculation algorithm.; 6493 ; 6494Bool_t TClass::MatchLegacyCheckSum(UInt_t checksum) const; 6495{; 6496 for(UInt_t i = 1; i < kLatestCheckSum; ++i) {; 6497 if ( checksum == GetCheckSum( (ECheckSum) i ) ) return kTRUE;; 6498 }; 6499 return kFALSE;; 6500}; 6",MatchSource.WIKI,doc/v632/TClass_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/TClass_8cxx_source.html
https://root.cern/doc/v632/TClass_8cxx_source.html:249126,Security,checksum,checksum,249126," 6435 }; 6436 }; 6437 update = kFALSE;; 6438 }; 6439 temp = colon+1;; 6440 if (*temp == 0) break;; 6441 }; 6442 //// fStreamerInfo = final;; 6443 delete [] final;; 6444 delete [] save;; 6445 return;; 6446 }; 6447 ; 6448 //info is empty. Let's build the default Streamer descriptor; 6449 ; 6450 char *temp = new char[10000];; 6451 temp[0] = 0;; 6452 char local[100];; 6453 ; 6454 //add list of base classes; 6455 TIter nextb(GetListOfBases());; 6456 TBaseClass *base;; 6457 while ((base = (TBaseClass*) nextb())) {; 6458 snprintf(local,100,""%s;"",base->GetName());; 6459 strlcat(temp,local,10000);; 6460 }; 6461 ; 6462 //add list of data members and types; 6463 TIter nextd(GetListOfDataMembers());; 6464 while ((dm = (TDataMember *) nextd())) {; 6465 if (dm->IsEnum()) continue;; 6466 if (!dm->IsPersistent()) continue;; 6467 Long_t property = dm->Property();; 6468 if (property & kIsStatic) continue;; 6469 TClass *acl = TClass::GetClass(dm->GetTypeName(),update);; 6470 update = kFALSE;; 6471 if (acl) {; 6472 if (acl->GetClassVersion() == 0) continue;; 6473 }; 6474 ; 6475 // dm->GetArrayIndex() returns an empty string if it does not; 6476 // applies; 6477 const char * index = dm->GetArrayIndex();; 6478 if (strlen(index)==0); 6479 snprintf(local,100,""%s %s;"",dm->GetFullTypeName(),dm->GetName());; 6480 else; 6481 snprintf(local,100,""%s %s[%s];"",dm->GetFullTypeName(),dm->GetName(),index);; 6482 strlcat(temp,local,10000);; 6483 }; 6484 //fStreamerInfo = temp;; 6485 delete [] temp;; 6486*/; 6487 return nullptr;; 6488}; 6489 ; 6490////////////////////////////////////////////////////////////////////////////////; 6491/// Return true if the checksum passed as argument is one of the checksum; 6492/// value produced by the older checksum calculation algorithm.; 6493 ; 6494Bool_t TClass::MatchLegacyCheckSum(UInt_t checksum) const; 6495{; 6496 for(UInt_t i = 1; i < kLatestCheckSum; ++i) {; 6497 if ( checksum == GetCheckSum( (ECheckSum) i ) ) return kTRUE;; 6498 }; 6499 return kFALSE;; 6500}; 6",MatchSource.WIKI,doc/v632/TClass_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/TClass_8cxx_source.html
https://root.cern/doc/v632/TClass_8cxx_source.html:249212,Security,checksum,checksum,249212,"me(),update);; 6470 update = kFALSE;; 6471 if (acl) {; 6472 if (acl->GetClassVersion() == 0) continue;; 6473 }; 6474 ; 6475 // dm->GetArrayIndex() returns an empty string if it does not; 6476 // applies; 6477 const char * index = dm->GetArrayIndex();; 6478 if (strlen(index)==0); 6479 snprintf(local,100,""%s %s;"",dm->GetFullTypeName(),dm->GetName());; 6480 else; 6481 snprintf(local,100,""%s %s[%s];"",dm->GetFullTypeName(),dm->GetName(),index);; 6482 strlcat(temp,local,10000);; 6483 }; 6484 //fStreamerInfo = temp;; 6485 delete [] temp;; 6486*/; 6487 return nullptr;; 6488}; 6489 ; 6490////////////////////////////////////////////////////////////////////////////////; 6491/// Return true if the checksum passed as argument is one of the checksum; 6492/// value produced by the older checksum calculation algorithm.; 6493 ; 6494Bool_t TClass::MatchLegacyCheckSum(UInt_t checksum) const; 6495{; 6496 for(UInt_t i = 1; i < kLatestCheckSum; ++i) {; 6497 if ( checksum == GetCheckSum( (ECheckSum) i ) ) return kTRUE;; 6498 }; 6499 return kFALSE;; 6500}; 6501 ; 6502////////////////////////////////////////////////////////////////////////////////; 6503/// Call GetCheckSum with validity check.; 6504 ; 6505UInt_t TClass::GetCheckSum(ECheckSum code) const; 6506{; 6507 bool isvalid;; 6508 return GetCheckSum(code,isvalid);; 6509}; 6510 ; 6511////////////////////////////////////////////////////////////////////////////////; 6512/// Return GetCheckSum(kCurrentCheckSum,isvalid);; 6513 ; 6514UInt_t TClass::GetCheckSum(Bool_t &isvalid) const; 6515{; 6516 return GetCheckSum(kCurrentCheckSum,isvalid);; 6517}; 6518 ; 6519////////////////////////////////////////////////////////////////////////////////; 6520/// Compute and/or return the class check sum.; 6521///; 6522/// isvalid is set to false, if the function is unable to calculate the; 6523/// checksum.; 6524///; 6525/// The class ckecksum is used by the automatic schema evolution algorithm; 6526/// to uniquely identify a class version.; 6527/// The che",MatchSource.WIKI,doc/v632/TClass_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/TClass_8cxx_source.html
https://root.cern/doc/v632/TClass_8cxx_source.html:249298,Security,checksum,checksum,249298,"me(),update);; 6470 update = kFALSE;; 6471 if (acl) {; 6472 if (acl->GetClassVersion() == 0) continue;; 6473 }; 6474 ; 6475 // dm->GetArrayIndex() returns an empty string if it does not; 6476 // applies; 6477 const char * index = dm->GetArrayIndex();; 6478 if (strlen(index)==0); 6479 snprintf(local,100,""%s %s;"",dm->GetFullTypeName(),dm->GetName());; 6480 else; 6481 snprintf(local,100,""%s %s[%s];"",dm->GetFullTypeName(),dm->GetName(),index);; 6482 strlcat(temp,local,10000);; 6483 }; 6484 //fStreamerInfo = temp;; 6485 delete [] temp;; 6486*/; 6487 return nullptr;; 6488}; 6489 ; 6490////////////////////////////////////////////////////////////////////////////////; 6491/// Return true if the checksum passed as argument is one of the checksum; 6492/// value produced by the older checksum calculation algorithm.; 6493 ; 6494Bool_t TClass::MatchLegacyCheckSum(UInt_t checksum) const; 6495{; 6496 for(UInt_t i = 1; i < kLatestCheckSum; ++i) {; 6497 if ( checksum == GetCheckSum( (ECheckSum) i ) ) return kTRUE;; 6498 }; 6499 return kFALSE;; 6500}; 6501 ; 6502////////////////////////////////////////////////////////////////////////////////; 6503/// Call GetCheckSum with validity check.; 6504 ; 6505UInt_t TClass::GetCheckSum(ECheckSum code) const; 6506{; 6507 bool isvalid;; 6508 return GetCheckSum(code,isvalid);; 6509}; 6510 ; 6511////////////////////////////////////////////////////////////////////////////////; 6512/// Return GetCheckSum(kCurrentCheckSum,isvalid);; 6513 ; 6514UInt_t TClass::GetCheckSum(Bool_t &isvalid) const; 6515{; 6516 return GetCheckSum(kCurrentCheckSum,isvalid);; 6517}; 6518 ; 6519////////////////////////////////////////////////////////////////////////////////; 6520/// Compute and/or return the class check sum.; 6521///; 6522/// isvalid is set to false, if the function is unable to calculate the; 6523/// checksum.; 6524///; 6525/// The class ckecksum is used by the automatic schema evolution algorithm; 6526/// to uniquely identify a class version.; 6527/// The che",MatchSource.WIKI,doc/v632/TClass_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/TClass_8cxx_source.html
https://root.cern/doc/v632/TClass_8cxx_source.html:250182,Security,checksum,checksum,250182,"culation algorithm.; 6493 ; 6494Bool_t TClass::MatchLegacyCheckSum(UInt_t checksum) const; 6495{; 6496 for(UInt_t i = 1; i < kLatestCheckSum; ++i) {; 6497 if ( checksum == GetCheckSum( (ECheckSum) i ) ) return kTRUE;; 6498 }; 6499 return kFALSE;; 6500}; 6501 ; 6502////////////////////////////////////////////////////////////////////////////////; 6503/// Call GetCheckSum with validity check.; 6504 ; 6505UInt_t TClass::GetCheckSum(ECheckSum code) const; 6506{; 6507 bool isvalid;; 6508 return GetCheckSum(code,isvalid);; 6509}; 6510 ; 6511////////////////////////////////////////////////////////////////////////////////; 6512/// Return GetCheckSum(kCurrentCheckSum,isvalid);; 6513 ; 6514UInt_t TClass::GetCheckSum(Bool_t &isvalid) const; 6515{; 6516 return GetCheckSum(kCurrentCheckSum,isvalid);; 6517}; 6518 ; 6519////////////////////////////////////////////////////////////////////////////////; 6520/// Compute and/or return the class check sum.; 6521///; 6522/// isvalid is set to false, if the function is unable to calculate the; 6523/// checksum.; 6524///; 6525/// The class ckecksum is used by the automatic schema evolution algorithm; 6526/// to uniquely identify a class version.; 6527/// The check sum is built from the names/types of base classes and; 6528/// data members.; 6529/// Original algorithm from Victor Perevovchikov (perev@bnl.gov).; 6530///; 6531/// The valid range of code is determined by ECheckSum.; 6532///; 6533/// - kNoEnum: data members of type enum are not counted in the checksum; 6534/// - kNoRange: return the checksum of data members and base classes, not including the ranges and array size found in comments.; 6535/// - kWithTypeDef: use the sugared type name in the calculation.; 6536///; 6537/// This is needed for backward compatibility.; 6538///; 6539/// WARNING: this function must be kept in sync with TStreamerInfo::GetCheckSum.; 6540/// They are both used to handle backward compatibility and should both return the same values.; 6541/// TStreamerInfo us",MatchSource.WIKI,doc/v632/TClass_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/TClass_8cxx_source.html
https://root.cern/doc/v632/TClass_8cxx_source.html:250643,Security,checksum,checksum,250643,"6511////////////////////////////////////////////////////////////////////////////////; 6512/// Return GetCheckSum(kCurrentCheckSum,isvalid);; 6513 ; 6514UInt_t TClass::GetCheckSum(Bool_t &isvalid) const; 6515{; 6516 return GetCheckSum(kCurrentCheckSum,isvalid);; 6517}; 6518 ; 6519////////////////////////////////////////////////////////////////////////////////; 6520/// Compute and/or return the class check sum.; 6521///; 6522/// isvalid is set to false, if the function is unable to calculate the; 6523/// checksum.; 6524///; 6525/// The class ckecksum is used by the automatic schema evolution algorithm; 6526/// to uniquely identify a class version.; 6527/// The check sum is built from the names/types of base classes and; 6528/// data members.; 6529/// Original algorithm from Victor Perevovchikov (perev@bnl.gov).; 6530///; 6531/// The valid range of code is determined by ECheckSum.; 6532///; 6533/// - kNoEnum: data members of type enum are not counted in the checksum; 6534/// - kNoRange: return the checksum of data members and base classes, not including the ranges and array size found in comments.; 6535/// - kWithTypeDef: use the sugared type name in the calculation.; 6536///; 6537/// This is needed for backward compatibility.; 6538///; 6539/// WARNING: this function must be kept in sync with TStreamerInfo::GetCheckSum.; 6540/// They are both used to handle backward compatibility and should both return the same values.; 6541/// TStreamerInfo uses the information in TStreamerElement while TClass uses the information; 6542/// from TClass::GetListOfBases and TClass::GetListOfDataMembers.; 6543 ; 6544UInt_t TClass::GetCheckSum(ECheckSum code, Bool_t &isvalid) const; 6545{; 6546 // fCheckSum is an atomic variable. Also once it has; 6547 // transition from a zero Value it never changes. If two; 6548 // thread reach past this if statement and calculated the; 6549 // 'kLastestCheckSum', they will by definition obtain the; 6550 // same value, so technically we could simply have:",MatchSource.WIKI,doc/v632/TClass_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/TClass_8cxx_source.html
https://root.cern/doc/v632/TClass_8cxx_source.html:250684,Security,checksum,checksum,250684,"6511////////////////////////////////////////////////////////////////////////////////; 6512/// Return GetCheckSum(kCurrentCheckSum,isvalid);; 6513 ; 6514UInt_t TClass::GetCheckSum(Bool_t &isvalid) const; 6515{; 6516 return GetCheckSum(kCurrentCheckSum,isvalid);; 6517}; 6518 ; 6519////////////////////////////////////////////////////////////////////////////////; 6520/// Compute and/or return the class check sum.; 6521///; 6522/// isvalid is set to false, if the function is unable to calculate the; 6523/// checksum.; 6524///; 6525/// The class ckecksum is used by the automatic schema evolution algorithm; 6526/// to uniquely identify a class version.; 6527/// The check sum is built from the names/types of base classes and; 6528/// data members.; 6529/// Original algorithm from Victor Perevovchikov (perev@bnl.gov).; 6530///; 6531/// The valid range of code is determined by ECheckSum.; 6532///; 6533/// - kNoEnum: data members of type enum are not counted in the checksum; 6534/// - kNoRange: return the checksum of data members and base classes, not including the ranges and array size found in comments.; 6535/// - kWithTypeDef: use the sugared type name in the calculation.; 6536///; 6537/// This is needed for backward compatibility.; 6538///; 6539/// WARNING: this function must be kept in sync with TStreamerInfo::GetCheckSum.; 6540/// They are both used to handle backward compatibility and should both return the same values.; 6541/// TStreamerInfo uses the information in TStreamerElement while TClass uses the information; 6542/// from TClass::GetListOfBases and TClass::GetListOfDataMembers.; 6543 ; 6544UInt_t TClass::GetCheckSum(ECheckSum code, Bool_t &isvalid) const; 6545{; 6546 // fCheckSum is an atomic variable. Also once it has; 6547 // transition from a zero Value it never changes. If two; 6548 // thread reach past this if statement and calculated the; 6549 // 'kLastestCheckSum', they will by definition obtain the; 6550 // same value, so technically we could simply have:",MatchSource.WIKI,doc/v632/TClass_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/TClass_8cxx_source.html
https://root.cern/doc/v632/TClass_8cxx_source.html:253429,Security,checksum,checksum,253429,"l implementation detail.; 6578 TList *tlb = ((TClass*)this)->GetListOfBases();; 6579 if (tlb && !GetCollectionProxy() && !TClassEdit::IsStdPair(GetName())) {; 6580 // Loop over bases if not a proxied collection or a pair; 6581 ; 6582 TIter nextBase(tlb);; 6583 ; 6584 TBaseClass *tbc=nullptr;; 6585 while((tbc=(TBaseClass*)nextBase())) {; 6586 name = tbc->GetName();; 6587 Bool_t isSTL = TClassEdit::IsSTLCont(name);; 6588 if (isSTL); 6589 name = TClassEdit::ShortType( name, TClassEdit::kDropStlDefault );; 6590 il = name.Length();; 6591 for (int i=0; i<il; i++) id = id*3+name[i];; 6592 if (code > kNoBaseCheckSum && !isSTL) {; 6593 if (tbc->GetClassPointer() == nullptr) {; 6594 Error(""GetCheckSum"",""Calculating the checksum for (%s) requires the base class (%s) meta information to be available!"",; 6595 GetName(),tbc->GetName());; 6596 isvalid = kFALSE;; 6597 return 0;; 6598 } else; 6599 id = id*3 + tbc->GetClassPointer()->GetCheckSum();; 6600 }; 6601 }/*EndBaseLoop*/; 6602 }; 6603 TList *tlm = ((TClass*)this)->GetListOfDataMembers();; 6604 if (tlm) { // Loop over members; 6605 TIter nextMemb(tlm);; 6606 TDataMember *tdm=nullptr;; 6607 Long_t prop = 0;; 6608 while((tdm=(TDataMember*)nextMemb())) {; 6609 if (!tdm->IsPersistent()) continue;; 6610 // combine properties; 6611 prop = (tdm->Property());; 6612 TDataType* tdt = tdm->GetDataType();; 6613 if (tdt) prop |= tdt->Property();; 6614 ; 6615 if ( prop&kIsStatic) continue;; 6616 name = tdm->GetName(); il = name.Length();; 6617 if ( (code > kNoEnum) && code != kReflex && code != kReflexNoComment && prop&kIsEnum); 6618 id = id*3 + 1;; 6619 ; 6620 int i;; 6621 for (i=0; i<il; i++) id = id*3+name[i];; 6622 ; 6623 if (code > kWithTypeDef || code == kReflexNoComment) {; 6624 type = tdm->GetTrueTypeName();; 6625 // GetTrueTypeName uses GetFullyQualifiedName which already drops; 6626 // the default template parameter, so we no longer need to do this.; 6627 //if (TClassEdit::IsSTLCont(type)); 6628 // type = TClassEdit::ShortType( typ",MatchSource.WIKI,doc/v632/TClass_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/TClass_8cxx_source.html
https://root.cern/doc/v632/TClass_8cxx_source.html:265607,Security,access,accessor,265607,"supposed to be set properly (no longer pointing to the default).; 6883 if (pThis->fStreamerImpl.load() == &TClass::StreamerDefault) {; 6884 pThis->Fatal(""StreamerDefault"", ""fStreamerImpl not properly initialized (%d)"", pThis->fStreamerType);; 6885 } else {; 6886 (*pThis->fStreamerImpl)(pThis,object,b,onfile_class);; 6887 }; 6888}; 6889 ; 6890////////////////////////////////////////////////////////////////////////////////; 6891/// Adopt a TClassStreamer object. Ownership is transfered to this TClass; 6892/// object.; 6893 ; 6894void TClass::AdoptStreamer(TClassStreamer *str); 6895{; 6896// // This code can be used to quickly test the STL Emulation layer; 6897// Int_t k = TClassEdit::IsSTLCont(GetName());; 6898// if (k==1||k==-1) { delete str; return; }; 6899 ; 6900 R__LOCKGUARD(gInterpreterMutex);; 6901 ; 6902 if (fStreamer) delete fStreamer;; 6903 if (str) {; 6904 fStreamerType = kExternal | ( fStreamerType&kEmulatedStreamer );; 6905 fStreamer = str;; 6906 fStreamerImpl = &TClass::StreamerExternal;; 6907 } else if (fStreamer) {; 6908 // Case where there was a custom streamer and it is hereby removed,; 6909 // we need to reset fStreamerType; 6910 fStreamer = str;; 6911 fStreamerType = TClass::kDefault;; 6912 if (fProperty != -1) {; 6913 fProperty = -1;; 6914 Property();; 6915 }; 6916 }; 6917}; 6918 ; 6919////////////////////////////////////////////////////////////////////////////////; 6920/// Set a wrapper/accessor function around this class custom streamer.; 6921 ; 6922void TClass::SetStreamerFunc(ClassStreamerFunc_t strm); 6923{; 6924 R__LOCKGUARD(gInterpreterMutex);; 6925 if (fProperty != -1 && !fConvStreamerFunc &&; 6926 ( (fStreamerFunc == nullptr && strm != nullptr) || (fStreamerFunc != nullptr && strm == nullptr) ) ); 6927 {; 6928 fStreamerFunc = strm;; 6929 ; 6930 // Since initialization has already been done, make sure to tweak it; 6931 // for the new state.; 6932 if (HasInterpreterInfo() && fStreamerType != kTObject && !fStreamer) {; 6933 fStreamerType = kIn",MatchSource.WIKI,doc/v632/TClass_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/TClass_8cxx_source.html
https://root.cern/doc/v632/TClass_8cxx_source.html:266448,Security,access,accessor,266448,"d,; 6909 // we need to reset fStreamerType; 6910 fStreamer = str;; 6911 fStreamerType = TClass::kDefault;; 6912 if (fProperty != -1) {; 6913 fProperty = -1;; 6914 Property();; 6915 }; 6916 }; 6917}; 6918 ; 6919////////////////////////////////////////////////////////////////////////////////; 6920/// Set a wrapper/accessor function around this class custom streamer.; 6921 ; 6922void TClass::SetStreamerFunc(ClassStreamerFunc_t strm); 6923{; 6924 R__LOCKGUARD(gInterpreterMutex);; 6925 if (fProperty != -1 && !fConvStreamerFunc &&; 6926 ( (fStreamerFunc == nullptr && strm != nullptr) || (fStreamerFunc != nullptr && strm == nullptr) ) ); 6927 {; 6928 fStreamerFunc = strm;; 6929 ; 6930 // Since initialization has already been done, make sure to tweak it; 6931 // for the new state.; 6932 if (HasInterpreterInfo() && fStreamerType != kTObject && !fStreamer) {; 6933 fStreamerType = kInstrumented;; 6934 fStreamerImpl = &TClass::StreamerInstrumented;; 6935 }; 6936 } else {; 6937 fStreamerFunc = strm;; 6938 }; 6939 fCanSplit = -1;; 6940}; 6941 ; 6942////////////////////////////////////////////////////////////////////////////////; 6943/// Set a wrapper/accessor function around this class custom conversion streamer.; 6944 ; 6945void TClass::SetConvStreamerFunc(ClassConvStreamerFunc_t strm); 6946{; 6947 R__LOCKGUARD(gInterpreterMutex);; 6948 if (fProperty != -1 &&; 6949 ( (fConvStreamerFunc == nullptr && strm != nullptr) || (fConvStreamerFunc != nullptr && strm == nullptr) ) ); 6950 {; 6951 fConvStreamerFunc = strm;; 6952 ; 6953 // Since initialization has already been done, make sure to tweak it; 6954 // for the new state.; 6955 if (HasInterpreterInfo() && fStreamerType != kTObject && !fStreamer) {; 6956 fStreamerType = kInstrumented;; 6957 fStreamerImpl = &TClass::ConvStreamerInstrumented;; 6958 }; 6959 } else {; 6960 fConvStreamerFunc = strm;; 6961 }; 6962 fCanSplit = -1;; 6963}; 6964 ; 6965 ; 6966////////////////////////////////////////////////////////////////////////////////; 696",MatchSource.WIKI,doc/v632/TClass_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/TClass_8cxx_source.html
https://root.cern/doc/v632/TClass_8cxx_source.html:269682,Security,checksum,checksum,269682,,MatchSource.WIKI,doc/v632/TClass_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/TClass_8cxx_source.html
https://root.cern/doc/v632/TClass_8cxx_source.html:269757,Security,checksum,checksum,269757,,MatchSource.WIKI,doc/v632/TClass_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/TClass_8cxx_source.html
https://root.cern/doc/v632/TClass_8cxx_source.html:269894,Security,checksum,checksum,269894,,MatchSource.WIKI,doc/v632/TClass_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/TClass_8cxx_source.html
https://root.cern/doc/v632/TClass_8cxx_source.html:269964,Security,checksum,checksum,269964,,MatchSource.WIKI,doc/v632/TClass_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/TClass_8cxx_source.html
https://root.cern/doc/v632/TClass_8cxx_source.html:270424,Security,checksum,checksum,270424,"oAdd(ROOT::DirAutoAdd_t autoAddFunc); 7029{; 7030 fDirAutoAdd = autoAddFunc;; 7031}; 7032 ; 7033////////////////////////////////////////////////////////////////////////////////; 7034/// Find the TVirtualStreamerInfo in the StreamerInfos corresponding to checksum; 7035 ; 7036TVirtualStreamerInfo *TClass::FindStreamerInfo(UInt_t checksum, Bool_t isTransient) const; 7037{; 7038 TVirtualStreamerInfo *guess = fLastReadInfo;; 7039 if (guess && guess->GetCheckSum() == checksum) {; 7040 return guess;; 7041 } else {; 7042 if (fCheckSum == checksum); 7043 return GetStreamerInfo(0, isTransient);; 7044 ; 7045 R__LOCKGUARD(gInterpreterMutex);; 7046 ; 7047 Int_t ninfos = fStreamerInfo->GetEntriesFast()-1;; 7048 for (Int_t i=-1;i<ninfos;++i) {; 7049 // TClass::fStreamerInfos has a lower bound not equal to 0,; 7050 // so we have to use At and should not use UncheckedAt; 7051 TVirtualStreamerInfo *info = (TVirtualStreamerInfo*)fStreamerInfo->UncheckedAt(i);; 7052 if (info && info->GetCheckSum() == checksum) {; 7053 // R__ASSERT(i==info->GetClassVersion() || (i==-1&&info->GetClassVersion()==1));; 7054 info->BuildOld();; 7055 if (info->IsCompiled()) fLastReadInfo = info;; 7056 return info;; 7057 }; 7058 }; 7059 return nullptr;; 7060 }; 7061}; 7062 ; 7063////////////////////////////////////////////////////////////////////////////////; 7064/// Find the TVirtualStreamerInfo in the StreamerInfos corresponding to checksum; 7065 ; 7066TVirtualStreamerInfo *TClass::FindStreamerInfo(TObjArray* arr, UInt_t checksum) const; 7067{; 7068 R__LOCKGUARD(gInterpreterMutex);; 7069 Int_t ninfos = arr->GetEntriesFast()-1;; 7070 for (Int_t i=-1;i<ninfos;i++) {; 7071 // TClass::fStreamerInfos has a lower bound not equal to 0,; 7072 // so we have to use At and should not use UncheckedAt; 7073 TVirtualStreamerInfo *info = (TVirtualStreamerInfo*)arr->UncheckedAt(i);; 7074 if (!info) continue;; 7075 if (info->GetCheckSum() == checksum) {; 7076 R__ASSERT(i==info->GetClassVersion() || (i==-1&&info->GetClassVersi",MatchSource.WIKI,doc/v632/TClass_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/TClass_8cxx_source.html
https://root.cern/doc/v632/TClass_8cxx_source.html:270841,Security,checksum,checksum,270841,"merInfo *TClass::FindStreamerInfo(UInt_t checksum, Bool_t isTransient) const; 7037{; 7038 TVirtualStreamerInfo *guess = fLastReadInfo;; 7039 if (guess && guess->GetCheckSum() == checksum) {; 7040 return guess;; 7041 } else {; 7042 if (fCheckSum == checksum); 7043 return GetStreamerInfo(0, isTransient);; 7044 ; 7045 R__LOCKGUARD(gInterpreterMutex);; 7046 ; 7047 Int_t ninfos = fStreamerInfo->GetEntriesFast()-1;; 7048 for (Int_t i=-1;i<ninfos;++i) {; 7049 // TClass::fStreamerInfos has a lower bound not equal to 0,; 7050 // so we have to use At and should not use UncheckedAt; 7051 TVirtualStreamerInfo *info = (TVirtualStreamerInfo*)fStreamerInfo->UncheckedAt(i);; 7052 if (info && info->GetCheckSum() == checksum) {; 7053 // R__ASSERT(i==info->GetClassVersion() || (i==-1&&info->GetClassVersion()==1));; 7054 info->BuildOld();; 7055 if (info->IsCompiled()) fLastReadInfo = info;; 7056 return info;; 7057 }; 7058 }; 7059 return nullptr;; 7060 }; 7061}; 7062 ; 7063////////////////////////////////////////////////////////////////////////////////; 7064/// Find the TVirtualStreamerInfo in the StreamerInfos corresponding to checksum; 7065 ; 7066TVirtualStreamerInfo *TClass::FindStreamerInfo(TObjArray* arr, UInt_t checksum) const; 7067{; 7068 R__LOCKGUARD(gInterpreterMutex);; 7069 Int_t ninfos = arr->GetEntriesFast()-1;; 7070 for (Int_t i=-1;i<ninfos;i++) {; 7071 // TClass::fStreamerInfos has a lower bound not equal to 0,; 7072 // so we have to use At and should not use UncheckedAt; 7073 TVirtualStreamerInfo *info = (TVirtualStreamerInfo*)arr->UncheckedAt(i);; 7074 if (!info) continue;; 7075 if (info->GetCheckSum() == checksum) {; 7076 R__ASSERT(i==info->GetClassVersion() || (i==-1&&info->GetClassVersion()==1));; 7077 return info;; 7078 }; 7079 }; 7080 return nullptr;; 7081}; 7082 ; 7083////////////////////////////////////////////////////////////////////////////////; 7084/// Return a Conversion StreamerInfo from the class 'classname' for version number 'version' to this class, if any.",MatchSource.WIKI,doc/v632/TClass_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/TClass_8cxx_source.html
https://root.cern/doc/v632/TClass_8cxx_source.html:270932,Security,checksum,checksum,270932,"merInfo *TClass::FindStreamerInfo(UInt_t checksum, Bool_t isTransient) const; 7037{; 7038 TVirtualStreamerInfo *guess = fLastReadInfo;; 7039 if (guess && guess->GetCheckSum() == checksum) {; 7040 return guess;; 7041 } else {; 7042 if (fCheckSum == checksum); 7043 return GetStreamerInfo(0, isTransient);; 7044 ; 7045 R__LOCKGUARD(gInterpreterMutex);; 7046 ; 7047 Int_t ninfos = fStreamerInfo->GetEntriesFast()-1;; 7048 for (Int_t i=-1;i<ninfos;++i) {; 7049 // TClass::fStreamerInfos has a lower bound not equal to 0,; 7050 // so we have to use At and should not use UncheckedAt; 7051 TVirtualStreamerInfo *info = (TVirtualStreamerInfo*)fStreamerInfo->UncheckedAt(i);; 7052 if (info && info->GetCheckSum() == checksum) {; 7053 // R__ASSERT(i==info->GetClassVersion() || (i==-1&&info->GetClassVersion()==1));; 7054 info->BuildOld();; 7055 if (info->IsCompiled()) fLastReadInfo = info;; 7056 return info;; 7057 }; 7058 }; 7059 return nullptr;; 7060 }; 7061}; 7062 ; 7063////////////////////////////////////////////////////////////////////////////////; 7064/// Find the TVirtualStreamerInfo in the StreamerInfos corresponding to checksum; 7065 ; 7066TVirtualStreamerInfo *TClass::FindStreamerInfo(TObjArray* arr, UInt_t checksum) const; 7067{; 7068 R__LOCKGUARD(gInterpreterMutex);; 7069 Int_t ninfos = arr->GetEntriesFast()-1;; 7070 for (Int_t i=-1;i<ninfos;i++) {; 7071 // TClass::fStreamerInfos has a lower bound not equal to 0,; 7072 // so we have to use At and should not use UncheckedAt; 7073 TVirtualStreamerInfo *info = (TVirtualStreamerInfo*)arr->UncheckedAt(i);; 7074 if (!info) continue;; 7075 if (info->GetCheckSum() == checksum) {; 7076 R__ASSERT(i==info->GetClassVersion() || (i==-1&&info->GetClassVersion()==1));; 7077 return info;; 7078 }; 7079 }; 7080 return nullptr;; 7081}; 7082 ; 7083////////////////////////////////////////////////////////////////////////////////; 7084/// Return a Conversion StreamerInfo from the class 'classname' for version number 'version' to this class, if any.",MatchSource.WIKI,doc/v632/TClass_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/TClass_8cxx_source.html
https://root.cern/doc/v632/TClass_8cxx_source.html:271344,Security,checksum,checksum,271344,"merInfo *TClass::FindStreamerInfo(UInt_t checksum, Bool_t isTransient) const; 7037{; 7038 TVirtualStreamerInfo *guess = fLastReadInfo;; 7039 if (guess && guess->GetCheckSum() == checksum) {; 7040 return guess;; 7041 } else {; 7042 if (fCheckSum == checksum); 7043 return GetStreamerInfo(0, isTransient);; 7044 ; 7045 R__LOCKGUARD(gInterpreterMutex);; 7046 ; 7047 Int_t ninfos = fStreamerInfo->GetEntriesFast()-1;; 7048 for (Int_t i=-1;i<ninfos;++i) {; 7049 // TClass::fStreamerInfos has a lower bound not equal to 0,; 7050 // so we have to use At and should not use UncheckedAt; 7051 TVirtualStreamerInfo *info = (TVirtualStreamerInfo*)fStreamerInfo->UncheckedAt(i);; 7052 if (info && info->GetCheckSum() == checksum) {; 7053 // R__ASSERT(i==info->GetClassVersion() || (i==-1&&info->GetClassVersion()==1));; 7054 info->BuildOld();; 7055 if (info->IsCompiled()) fLastReadInfo = info;; 7056 return info;; 7057 }; 7058 }; 7059 return nullptr;; 7060 }; 7061}; 7062 ; 7063////////////////////////////////////////////////////////////////////////////////; 7064/// Find the TVirtualStreamerInfo in the StreamerInfos corresponding to checksum; 7065 ; 7066TVirtualStreamerInfo *TClass::FindStreamerInfo(TObjArray* arr, UInt_t checksum) const; 7067{; 7068 R__LOCKGUARD(gInterpreterMutex);; 7069 Int_t ninfos = arr->GetEntriesFast()-1;; 7070 for (Int_t i=-1;i<ninfos;i++) {; 7071 // TClass::fStreamerInfos has a lower bound not equal to 0,; 7072 // so we have to use At and should not use UncheckedAt; 7073 TVirtualStreamerInfo *info = (TVirtualStreamerInfo*)arr->UncheckedAt(i);; 7074 if (!info) continue;; 7075 if (info->GetCheckSum() == checksum) {; 7076 R__ASSERT(i==info->GetClassVersion() || (i==-1&&info->GetClassVersion()==1));; 7077 return info;; 7078 }; 7079 }; 7080 return nullptr;; 7081}; 7082 ; 7083////////////////////////////////////////////////////////////////////////////////; 7084/// Return a Conversion StreamerInfo from the class 'classname' for version number 'version' to this class, if any.",MatchSource.WIKI,doc/v632/TClass_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/TClass_8cxx_source.html
https://root.cern/doc/v632/TClass_8cxx_source.html:276072,Security,checksum,checksum,276072,"e info;; 7160 return nullptr;; 7161 }; 7162 ; 7163 if (!info->IsCompiled()) {; 7164 // Streamer info has not been compiled, but exists.; 7165 // Therefore it was read in from a file and we have to do schema evolution?; 7166 // Or it didn't have a dictionary before, but does now?; 7167 info->BuildOld();; 7168 }; 7169 ; 7170 //----------------------------------------------------------------------------; 7171 // Cache this streamer info; 7172 /////////////////////////////////////////////////////////////////////////////; 7173 ; 7174 if (!arr) {; 7175 arr = new TObjArray(version+10, -1);; 7176 if (!fConversionStreamerInfo.load()) {; 7177 fConversionStreamerInfo = new std::map<std::string, TObjArray*>();; 7178 }; 7179 (*fConversionStreamerInfo)[cl->GetName()] = arr;; 7180 }; 7181 if (arr->At(info->GetClassVersion())) {; 7182 Error(""GetConversionStreamerInfo"", ""Conversion StreamerInfo from %s to %s version %d has already been created"",; 7183 this->GetName(), info->GetName(), info->GetClassVersion());; 7184 delete arr->At(info->GetClassVersion());; 7185 }; 7186 arr->AddAtAndExpand( info, info->GetClassVersion() );; 7187 return info;; 7188}; 7189 ; 7190////////////////////////////////////////////////////////////////////////////////; 7191/// Return a Conversion StreamerInfo from the class 'classname' for the layout represented by 'checksum' to this class, if any.; 7192 ; 7193TVirtualStreamerInfo *TClass::FindConversionStreamerInfo( const char* classname, UInt_t checksum ) const; 7194{; 7195 TClass *cl = TClass::GetClass( classname );; 7196 if( !cl ); 7197 return nullptr;; 7198 return FindConversionStreamerInfo( cl, checksum );; 7199}; 7200 ; 7201////////////////////////////////////////////////////////////////////////////////; 7202/// Return a Conversion StreamerInfo from the class represented by cl for the layout represented by 'checksum' to this class, if any.; 7203 ; 7204TVirtualStreamerInfo *TClass::FindConversionStreamerInfo( const TClass* cl, UInt_t checksum ) const; 720",MatchSource.WIKI,doc/v632/TClass_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/TClass_8cxx_source.html
https://root.cern/doc/v632/TClass_8cxx_source.html:276205,Security,checksum,checksum,276205,"()) {; 7177 fConversionStreamerInfo = new std::map<std::string, TObjArray*>();; 7178 }; 7179 (*fConversionStreamerInfo)[cl->GetName()] = arr;; 7180 }; 7181 if (arr->At(info->GetClassVersion())) {; 7182 Error(""GetConversionStreamerInfo"", ""Conversion StreamerInfo from %s to %s version %d has already been created"",; 7183 this->GetName(), info->GetName(), info->GetClassVersion());; 7184 delete arr->At(info->GetClassVersion());; 7185 }; 7186 arr->AddAtAndExpand( info, info->GetClassVersion() );; 7187 return info;; 7188}; 7189 ; 7190////////////////////////////////////////////////////////////////////////////////; 7191/// Return a Conversion StreamerInfo from the class 'classname' for the layout represented by 'checksum' to this class, if any.; 7192 ; 7193TVirtualStreamerInfo *TClass::FindConversionStreamerInfo( const char* classname, UInt_t checksum ) const; 7194{; 7195 TClass *cl = TClass::GetClass( classname );; 7196 if( !cl ); 7197 return nullptr;; 7198 return FindConversionStreamerInfo( cl, checksum );; 7199}; 7200 ; 7201////////////////////////////////////////////////////////////////////////////////; 7202/// Return a Conversion StreamerInfo from the class represented by cl for the layout represented by 'checksum' to this class, if any.; 7203 ; 7204TVirtualStreamerInfo *TClass::FindConversionStreamerInfo( const TClass* cl, UInt_t checksum ) const; 7205{; 7206 //---------------------------------------------------------------------------; 7207 // Check if the classname was specified correctly; 7208 /////////////////////////////////////////////////////////////////////////////; 7209 ; 7210 if( !cl ); 7211 return nullptr;; 7212 ; 7213 if( cl == this ); 7214 return FindStreamerInfo( checksum );; 7215 ; 7216 //----------------------------------------------------------------------------; 7217 // Check if we already have it; 7218 /////////////////////////////////////////////////////////////////////////////; 7219 ; 7220 TObjArray* arr = nullptr;; 7221 TVirtualStreamerInfo* info",MatchSource.WIKI,doc/v632/TClass_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/TClass_8cxx_source.html
https://root.cern/doc/v632/TClass_8cxx_source.html:276362,Security,checksum,checksum,276362,"()) {; 7177 fConversionStreamerInfo = new std::map<std::string, TObjArray*>();; 7178 }; 7179 (*fConversionStreamerInfo)[cl->GetName()] = arr;; 7180 }; 7181 if (arr->At(info->GetClassVersion())) {; 7182 Error(""GetConversionStreamerInfo"", ""Conversion StreamerInfo from %s to %s version %d has already been created"",; 7183 this->GetName(), info->GetName(), info->GetClassVersion());; 7184 delete arr->At(info->GetClassVersion());; 7185 }; 7186 arr->AddAtAndExpand( info, info->GetClassVersion() );; 7187 return info;; 7188}; 7189 ; 7190////////////////////////////////////////////////////////////////////////////////; 7191/// Return a Conversion StreamerInfo from the class 'classname' for the layout represented by 'checksum' to this class, if any.; 7192 ; 7193TVirtualStreamerInfo *TClass::FindConversionStreamerInfo( const char* classname, UInt_t checksum ) const; 7194{; 7195 TClass *cl = TClass::GetClass( classname );; 7196 if( !cl ); 7197 return nullptr;; 7198 return FindConversionStreamerInfo( cl, checksum );; 7199}; 7200 ; 7201////////////////////////////////////////////////////////////////////////////////; 7202/// Return a Conversion StreamerInfo from the class represented by cl for the layout represented by 'checksum' to this class, if any.; 7203 ; 7204TVirtualStreamerInfo *TClass::FindConversionStreamerInfo( const TClass* cl, UInt_t checksum ) const; 7205{; 7206 //---------------------------------------------------------------------------; 7207 // Check if the classname was specified correctly; 7208 /////////////////////////////////////////////////////////////////////////////; 7209 ; 7210 if( !cl ); 7211 return nullptr;; 7212 ; 7213 if( cl == this ); 7214 return FindStreamerInfo( checksum );; 7215 ; 7216 //----------------------------------------------------------------------------; 7217 // Check if we already have it; 7218 /////////////////////////////////////////////////////////////////////////////; 7219 ; 7220 TObjArray* arr = nullptr;; 7221 TVirtualStreamerInfo* info",MatchSource.WIKI,doc/v632/TClass_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/TClass_8cxx_source.html
https://root.cern/doc/v632/TClass_8cxx_source.html:276580,Security,checksum,checksum,276580,"()) {; 7177 fConversionStreamerInfo = new std::map<std::string, TObjArray*>();; 7178 }; 7179 (*fConversionStreamerInfo)[cl->GetName()] = arr;; 7180 }; 7181 if (arr->At(info->GetClassVersion())) {; 7182 Error(""GetConversionStreamerInfo"", ""Conversion StreamerInfo from %s to %s version %d has already been created"",; 7183 this->GetName(), info->GetName(), info->GetClassVersion());; 7184 delete arr->At(info->GetClassVersion());; 7185 }; 7186 arr->AddAtAndExpand( info, info->GetClassVersion() );; 7187 return info;; 7188}; 7189 ; 7190////////////////////////////////////////////////////////////////////////////////; 7191/// Return a Conversion StreamerInfo from the class 'classname' for the layout represented by 'checksum' to this class, if any.; 7192 ; 7193TVirtualStreamerInfo *TClass::FindConversionStreamerInfo( const char* classname, UInt_t checksum ) const; 7194{; 7195 TClass *cl = TClass::GetClass( classname );; 7196 if( !cl ); 7197 return nullptr;; 7198 return FindConversionStreamerInfo( cl, checksum );; 7199}; 7200 ; 7201////////////////////////////////////////////////////////////////////////////////; 7202/// Return a Conversion StreamerInfo from the class represented by cl for the layout represented by 'checksum' to this class, if any.; 7203 ; 7204TVirtualStreamerInfo *TClass::FindConversionStreamerInfo( const TClass* cl, UInt_t checksum ) const; 7205{; 7206 //---------------------------------------------------------------------------; 7207 // Check if the classname was specified correctly; 7208 /////////////////////////////////////////////////////////////////////////////; 7209 ; 7210 if( !cl ); 7211 return nullptr;; 7212 ; 7213 if( cl == this ); 7214 return FindStreamerInfo( checksum );; 7215 ; 7216 //----------------------------------------------------------------------------; 7217 // Check if we already have it; 7218 /////////////////////////////////////////////////////////////////////////////; 7219 ; 7220 TObjArray* arr = nullptr;; 7221 TVirtualStreamerInfo* info",MatchSource.WIKI,doc/v632/TClass_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/TClass_8cxx_source.html
https://root.cern/doc/v632/TClass_8cxx_source.html:276708,Security,checksum,checksum,276708,"rInfo from the class 'classname' for the layout represented by 'checksum' to this class, if any.; 7192 ; 7193TVirtualStreamerInfo *TClass::FindConversionStreamerInfo( const char* classname, UInt_t checksum ) const; 7194{; 7195 TClass *cl = TClass::GetClass( classname );; 7196 if( !cl ); 7197 return nullptr;; 7198 return FindConversionStreamerInfo( cl, checksum );; 7199}; 7200 ; 7201////////////////////////////////////////////////////////////////////////////////; 7202/// Return a Conversion StreamerInfo from the class represented by cl for the layout represented by 'checksum' to this class, if any.; 7203 ; 7204TVirtualStreamerInfo *TClass::FindConversionStreamerInfo( const TClass* cl, UInt_t checksum ) const; 7205{; 7206 //---------------------------------------------------------------------------; 7207 // Check if the classname was specified correctly; 7208 /////////////////////////////////////////////////////////////////////////////; 7209 ; 7210 if( !cl ); 7211 return nullptr;; 7212 ; 7213 if( cl == this ); 7214 return FindStreamerInfo( checksum );; 7215 ; 7216 //----------------------------------------------------------------------------; 7217 // Check if we already have it; 7218 /////////////////////////////////////////////////////////////////////////////; 7219 ; 7220 TObjArray* arr = nullptr;; 7221 TVirtualStreamerInfo* info = nullptr;; 7222 if (fConversionStreamerInfo.load()) {; 7223 std::map<std::string, TObjArray*>::iterator it;; 7224 ; 7225 R__LOCKGUARD(gInterpreterMutex);; 7226 ; 7227 it = (*fConversionStreamerInfo).find( cl->GetName() );; 7228 ; 7229 if( it != (*fConversionStreamerInfo).end() ) {; 7230 arr = it->second;; 7231 }; 7232 if (arr) {; 7233 info = FindStreamerInfo( arr, checksum );; 7234 }; 7235 }; 7236 ; 7237 if( info ); 7238 return info;; 7239 ; 7240 R__LOCKGUARD(gInterpreterMutex);; 7241 ; 7242 //----------------------------------------------------------------------------; 7243 // Get it from the foreign class; 7244 ///////////////////////////",MatchSource.WIKI,doc/v632/TClass_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/TClass_8cxx_source.html
https://root.cern/doc/v632/TClass_8cxx_source.html:277062,Security,checksum,checksum,277062,"rInfo from the class 'classname' for the layout represented by 'checksum' to this class, if any.; 7192 ; 7193TVirtualStreamerInfo *TClass::FindConversionStreamerInfo( const char* classname, UInt_t checksum ) const; 7194{; 7195 TClass *cl = TClass::GetClass( classname );; 7196 if( !cl ); 7197 return nullptr;; 7198 return FindConversionStreamerInfo( cl, checksum );; 7199}; 7200 ; 7201////////////////////////////////////////////////////////////////////////////////; 7202/// Return a Conversion StreamerInfo from the class represented by cl for the layout represented by 'checksum' to this class, if any.; 7203 ; 7204TVirtualStreamerInfo *TClass::FindConversionStreamerInfo( const TClass* cl, UInt_t checksum ) const; 7205{; 7206 //---------------------------------------------------------------------------; 7207 // Check if the classname was specified correctly; 7208 /////////////////////////////////////////////////////////////////////////////; 7209 ; 7210 if( !cl ); 7211 return nullptr;; 7212 ; 7213 if( cl == this ); 7214 return FindStreamerInfo( checksum );; 7215 ; 7216 //----------------------------------------------------------------------------; 7217 // Check if we already have it; 7218 /////////////////////////////////////////////////////////////////////////////; 7219 ; 7220 TObjArray* arr = nullptr;; 7221 TVirtualStreamerInfo* info = nullptr;; 7222 if (fConversionStreamerInfo.load()) {; 7223 std::map<std::string, TObjArray*>::iterator it;; 7224 ; 7225 R__LOCKGUARD(gInterpreterMutex);; 7226 ; 7227 it = (*fConversionStreamerInfo).find( cl->GetName() );; 7228 ; 7229 if( it != (*fConversionStreamerInfo).end() ) {; 7230 arr = it->second;; 7231 }; 7232 if (arr) {; 7233 info = FindStreamerInfo( arr, checksum );; 7234 }; 7235 }; 7236 ; 7237 if( info ); 7238 return info;; 7239 ; 7240 R__LOCKGUARD(gInterpreterMutex);; 7241 ; 7242 //----------------------------------------------------------------------------; 7243 // Get it from the foreign class; 7244 ///////////////////////////",MatchSource.WIKI,doc/v632/TClass_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/TClass_8cxx_source.html
https://root.cern/doc/v632/TClass_8cxx_source.html:277727,Security,checksum,checksum,277727,"lready have it; 7218 /////////////////////////////////////////////////////////////////////////////; 7219 ; 7220 TObjArray* arr = nullptr;; 7221 TVirtualStreamerInfo* info = nullptr;; 7222 if (fConversionStreamerInfo.load()) {; 7223 std::map<std::string, TObjArray*>::iterator it;; 7224 ; 7225 R__LOCKGUARD(gInterpreterMutex);; 7226 ; 7227 it = (*fConversionStreamerInfo).find( cl->GetName() );; 7228 ; 7229 if( it != (*fConversionStreamerInfo).end() ) {; 7230 arr = it->second;; 7231 }; 7232 if (arr) {; 7233 info = FindStreamerInfo( arr, checksum );; 7234 }; 7235 }; 7236 ; 7237 if( info ); 7238 return info;; 7239 ; 7240 R__LOCKGUARD(gInterpreterMutex);; 7241 ; 7242 //----------------------------------------------------------------------------; 7243 // Get it from the foreign class; 7244 /////////////////////////////////////////////////////////////////////////////; 7245 ; 7246 info = cl->FindStreamerInfo( checksum );; 7247 ; 7248 if( !info ); 7249 return nullptr;; 7250 ; 7251 //----------------------------------------------------------------------------; 7252 // We have the right info so we need to clone it to create new object with; 7253 // non artificial streamer elements and we should build it for current class; 7254 /////////////////////////////////////////////////////////////////////////////; 7255 ; 7256 int version = info->GetClassVersion();; 7257 info = (TVirtualStreamerInfo*)info->Clone();; 7258 ; 7259 // When cloning the StreamerInfo we record (and thus restore); 7260 // the absolute value of the version, let's restore the sign.; 7261 if (version == -1); 7262 info->SetClassVersion(-1);; 7263 ; 7264 if( !info->BuildFor( this ) ) {; 7265 delete info;; 7266 return nullptr;; 7267 }; 7268 ; 7269 if (!info->IsCompiled()) {; 7270 // Streamer info has not been compiled, but exists.; 7271 // Therefore it was read in from a file and we have to do schema evolution?; 7272 // Or it didn't have a dictionary before, but does now?; 7273 info->BuildOld();; 7274 }; 7275 ; 7276 //--",MatchSource.WIKI,doc/v632/TClass_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/TClass_8cxx_source.html
https://root.cern/doc/v632/TClass_8cxx_source.html:278101,Security,checksum,checksum,278101,"lready have it; 7218 /////////////////////////////////////////////////////////////////////////////; 7219 ; 7220 TObjArray* arr = nullptr;; 7221 TVirtualStreamerInfo* info = nullptr;; 7222 if (fConversionStreamerInfo.load()) {; 7223 std::map<std::string, TObjArray*>::iterator it;; 7224 ; 7225 R__LOCKGUARD(gInterpreterMutex);; 7226 ; 7227 it = (*fConversionStreamerInfo).find( cl->GetName() );; 7228 ; 7229 if( it != (*fConversionStreamerInfo).end() ) {; 7230 arr = it->second;; 7231 }; 7232 if (arr) {; 7233 info = FindStreamerInfo( arr, checksum );; 7234 }; 7235 }; 7236 ; 7237 if( info ); 7238 return info;; 7239 ; 7240 R__LOCKGUARD(gInterpreterMutex);; 7241 ; 7242 //----------------------------------------------------------------------------; 7243 // Get it from the foreign class; 7244 /////////////////////////////////////////////////////////////////////////////; 7245 ; 7246 info = cl->FindStreamerInfo( checksum );; 7247 ; 7248 if( !info ); 7249 return nullptr;; 7250 ; 7251 //----------------------------------------------------------------------------; 7252 // We have the right info so we need to clone it to create new object with; 7253 // non artificial streamer elements and we should build it for current class; 7254 /////////////////////////////////////////////////////////////////////////////; 7255 ; 7256 int version = info->GetClassVersion();; 7257 info = (TVirtualStreamerInfo*)info->Clone();; 7258 ; 7259 // When cloning the StreamerInfo we record (and thus restore); 7260 // the absolute value of the version, let's restore the sign.; 7261 if (version == -1); 7262 info->SetClassVersion(-1);; 7263 ; 7264 if( !info->BuildFor( this ) ) {; 7265 delete info;; 7266 return nullptr;; 7267 }; 7268 ; 7269 if (!info->IsCompiled()) {; 7270 // Streamer info has not been compiled, but exists.; 7271 // Therefore it was read in from a file and we have to do schema evolution?; 7272 // Or it didn't have a dictionary before, but does now?; 7273 info->BuildOld();; 7274 }; 7275 ; 7276 //--",MatchSource.WIKI,doc/v632/TClass_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/TClass_8cxx_source.html
https://root.cern/doc/v632/TClass_8cxx_source.html:283345,Security,access,access,283345,"ethod"", ""ROOT::Internal::TCheckHashRecursiveRemoveConsistency"",; 7352 ""TCheckHashRecursiveRemoveConsistency"", ""TGWindow"",; 7353 ""TDirectory"", ""TDirectoryFile"", ""TObject"", ""TH1"",; 7354 ""TQClass"", ""TGlobal"" };; 7355 ; 7356 if (cname && cname[0]) {; 7357 for (auto cursor : handVerified) {; 7358 if (strcmp(cname, cursor) == 0); 7359 return true;; 7360 }; 7361 }; 7362 return false;; 7363}; 7364 ; 7365////////////////////////////////////////////////////////////////////////////////; 7366/// Return true is the Hash/RecursiveRemove setup is consistent, i.e. when all; 7367/// classes in the class hierarchy that overload TObject::Hash do call; 7368/// ROOT::CallRecursiveRemoveIfNeeded in their destructor.; 7369/// i.e. it is safe to call the Hash virtual function during the RecursiveRemove operation.; 7370 ; 7371Bool_t ROOT::Internal::HasConsistentHashMember(TClass &clRef); 7372{; 7373 return clRef.HasConsistentHashMember();; 7374}; 7375 ; 7376////////////////////////////////////////////////////////////////////////////////; 7377/// Return true if we have access to a constructor usable for I/O. This is; 7378/// typically the default constructor but can also be a constructor specifically; 7379/// marked for I/O (for example a constructor taking a TRootIOCtor* as an; 7380/// argument). In other words, if this routine returns true, TClass::New is; 7381/// guarantee to succeed.; 7382/// To know if the class described by this TClass has a default constructor; 7383/// (public or not), use; 7384/// \code{.cpp}; 7385/// cl->GetProperty() & kClassHasDefaultCtor; 7386/// \endcode; 7387/// To know if the class described by this TClass has a public default; 7388/// constructor use:; 7389/// \code{.cpp}; 7390/// gInterpreter->ClassInfo_HasDefaultConstructor(aClass->GetClassInfo());; 7391/// \endcode; 7392 ; 7393Bool_t TClass::HasDefaultConstructor(Bool_t testio) const; 7394{; 7395 ; 7396 if (fNew) return kTRUE;; 7397 ; 7398 if (HasInterpreterInfo()) {; 7399 R__LOCKGUARD(gInterpreterMutex);;",MatchSource.WIKI,doc/v632/TClass_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/TClass_8cxx_source.html
https://root.cern/doc/v632/TClass_8cxx_source.html:306176,Security,hash,hash,306176,"ClassMenuItemDescribes one element of the context menu associated to a class The menu item may describe.Definition TClassMenuItem.h:31; TClassMenuItem::SetTogglevirtual void SetToggle(Bool_t toggle=kTRUE)Definition TClassMenuItem.h:75; TClassMenuItem::kIsSelf@ kIsSelfDefinition TClassMenuItem.h:37; TClassMenuItem::kPopupStandardList@ kPopupStandardListDefinition TClassMenuItem.h:35; TClassMenuItem::kPopupSeparator@ kPopupSeparatorDefinition TClassMenuItem.h:35; TClassMenuItem::kPopupUserFunction@ kPopupUserFunctionDefinition TClassMenuItem.h:35; TClassRefTClassRef is used to implement a permanent reference to a TClass object.Definition TClassRef.h:28; TClassStreamerDefinition TClassStreamer.h:26; TClassStreamer::Streamvirtual void Stream(TBuffer &b, void *objp, const TClass *onfileClass)Definition TClassStreamer.h:51; TClassStreamer::Generatevirtual TClassStreamer * Generate() constDefinition TClassStreamer.h:38; TClassTable::GetDictstatic DictFuncPtr_t GetDict(const char *cname)Given the class name returns the Dictionary() function of a class (uses hash of name).Definition TClassTable.cxx:674; TClassTable::GetProtoNormstatic TProtoClass * GetProtoNorm(const char *cname)Given the class normalized name returns the TClassProto object for the class.Definition TClassTable.cxx:770; TClassTable::GetDictNormstatic DictFuncPtr_t GetDictNorm(const char *cname)Given the normalized class name returns the Dictionary() function of a class (uses hash of name).Definition TClassTable.cxx:717; TClass::InsertTClassInRegistryRAIIDefinition TClass.h:173; TClass::InsertTClassInRegistryRAII::~InsertTClassInRegistryRAII~InsertTClassInRegistryRAII()Definition TClass.cxx:254; TClass::InsertTClassInRegistryRAII::InsertTClassInRegistryRAIIInsertTClassInRegistryRAII(TClass::EState &state, const char *name, TDeclNameRegistry &emuRegistry)Definition TClass.cxx:248; TClass::TDeclNameRegistryDefinition TClass.h:158; TClass::TDeclNameRegistry::~TDeclNameRegistry~TDeclNameRegistry()Definition TClass.",MatchSource.WIKI,doc/v632/TClass_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/TClass_8cxx_source.html
https://root.cern/doc/v632/TClass_8cxx_source.html:306566,Security,hash,hash,306566,".h:35; TClassMenuItem::kPopupSeparator@ kPopupSeparatorDefinition TClassMenuItem.h:35; TClassMenuItem::kPopupUserFunction@ kPopupUserFunctionDefinition TClassMenuItem.h:35; TClassRefTClassRef is used to implement a permanent reference to a TClass object.Definition TClassRef.h:28; TClassStreamerDefinition TClassStreamer.h:26; TClassStreamer::Streamvirtual void Stream(TBuffer &b, void *objp, const TClass *onfileClass)Definition TClassStreamer.h:51; TClassStreamer::Generatevirtual TClassStreamer * Generate() constDefinition TClassStreamer.h:38; TClassTable::GetDictstatic DictFuncPtr_t GetDict(const char *cname)Given the class name returns the Dictionary() function of a class (uses hash of name).Definition TClassTable.cxx:674; TClassTable::GetProtoNormstatic TProtoClass * GetProtoNorm(const char *cname)Given the class normalized name returns the TClassProto object for the class.Definition TClassTable.cxx:770; TClassTable::GetDictNormstatic DictFuncPtr_t GetDictNorm(const char *cname)Given the normalized class name returns the Dictionary() function of a class (uses hash of name).Definition TClassTable.cxx:717; TClass::InsertTClassInRegistryRAIIDefinition TClass.h:173; TClass::InsertTClassInRegistryRAII::~InsertTClassInRegistryRAII~InsertTClassInRegistryRAII()Definition TClass.cxx:254; TClass::InsertTClassInRegistryRAII::InsertTClassInRegistryRAIIInsertTClassInRegistryRAII(TClass::EState &state, const char *name, TDeclNameRegistry &emuRegistry)Definition TClass.cxx:248; TClass::TDeclNameRegistryDefinition TClass.h:158; TClass::TDeclNameRegistry::~TDeclNameRegistry~TDeclNameRegistry()Definition TClass.cxx:235; TClass::TDeclNameRegistry::HasDeclNameBool_t HasDeclName(const char *name) constDefinition TClass.cxx:223; TClass::TDeclNameRegistry::AddQualifiedNamevoid AddQualifiedName(const char *name)Extract this part of the name.Definition TClass.cxx:196; TClass::TDeclNameRegistry::TDeclNameRegistryTDeclNameRegistry(Int_t verbLevel=0)TDeclNameRegistry class constructor.Definiti",MatchSource.WIKI,doc/v632/TClass_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/TClass_8cxx_source.html
https://root.cern/doc/v632/TClass_8cxx_source.html:310916,Security,access,accessor,310916,"TClass::DetermineCurrentStreamerInfoTVirtualStreamerInfo * DetermineCurrentStreamerInfo()Determine and set pointer to current TVirtualStreamerInfo.Definition TClass.cxx:5684; TClass::Browsevoid Browse(TBrowser *b) overrideThis method is called by a browser to get the class information.Definition TClass.cxx:2010; TClass::GetStateEState GetState() constDefinition TClass.h:488; TClass::GetCollectionTypeROOT::ESTLType GetCollectionType() constReturn the 'type' of the STL the TClass is representing.Definition TClass.cxx:2886; TClass::Drawvoid Draw(Option_t *option="""") overrideDraw detailed class inheritance structure.Definition TClass.cxx:2487; TClass::AdoptMemberStreamervoid AdoptMemberStreamer(const char *name, TMemberStreamer *strm)Adopt the TMemberStreamer pointer to by p and use it to Stream non basic member name.Definition TClass.cxx:6703; TClass::ResetInstanceCountvoid ResetInstanceCount()Definition TClass.h:547; TClass::GetStreamerFuncClassStreamerFunc_t GetStreamerFunc() constGet a wrapper/accessor function around this class custom streamer (member function).Definition TClass.cxx:2939; TClass::RemoveStreamerInfovoid RemoveStreamerInfo(Int_t slot)Remove and delete the StreamerInfo in the given slot.Definition TClass.cxx:7320; TClass::SetCanSplitvoid SetCanSplit(Int_t splitmode)Set the splitability of this class:Definition TClass.cxx:5658; TClass::CreateListOfDataMembersTList * CreateListOfDataMembers(std::atomic< TListOfDataMembers * > &data, TDictionary::EMemberSelection selection, bool load)Create the list containing the TDataMembers (of actual data members or members pulled in through usin...Definition TClass.cxx:3741; TClass::GetStreamerInfoAbstractEmulatedTVirtualStreamerInfo * GetStreamerInfoAbstractEmulated(Int_t version=0) constFor the case where the requestor class is emulated and this class is abstract, returns a pointer to t...Definition TClass.cxx:4709; TClass::Newvoid * New(ENewType defConstructor=kClassNew, Bool_t quiet=kFALSE) constReturn a pointer ",MatchSource.WIKI,doc/v632/TClass_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/TClass_8cxx_source.html
https://root.cern/doc/v632/TClass_8cxx_source.html:321733,Security,checksum,checksum,321733," TClass.cxx:3477; TClass::GetNdataInt_t GetNdata()Return the number of data members of this class Note that in case the list of data members is not yet...Definition TClass.cxx:4554; TClass::SetDestructorvoid SetDestructor(ROOT::DesFunc_t destructorFunc)Install a new wrapper around the destructor.Definition TClass.cxx:7017; TClass::PostLoadCheckvirtual void PostLoadCheck()Do the initialization that can only be done after the CINT dictionary has been fully populated and ca...Definition TClass.cxx:5959; TClass::LoadClassInfovoid LoadClassInfo() constTry to load the ClassInfo if available.Definition TClass.cxx:5824; TClass::SetResetAfterMergevoid SetResetAfterMerge(ROOT::ResetAfterMergeFunc_t resetFunc)Install a new wrapper around 'ResetAfterMerge'.Definition TClass.cxx:6977; TClass::GetStreamerInfoImplTVirtualStreamerInfo * GetStreamerInfoImpl(Int_t version, Bool_t silent) constDefinition TClass.cxx:4634; TClass::MatchLegacyCheckSumBool_t MatchLegacyCheckSum(UInt_t checksum) constReturn true if the checksum passed as argument is one of the checksum value produced by the older che...Definition TClass.cxx:6494; TClass::fAllPubMethodTViewPubFunctions * fAllPubMethodDefinition TClass.h:210; TClass::ERuntimeProperties::kSet@ kSet; TClass::ERuntimeProperties::kConsistentHash@ kConsistentHash; TClass::HasInterpreterInfoBool_t HasInterpreterInfo() constDefinition TClass.h:410; TClass::AddClassstatic void AddClass(TClass *cl)static: Add a class to the list and map of classes.Definition TClass.cxx:494; TClass::GetMissingDictionariesForBaseClassesvoid GetMissingDictionariesForBaseClasses(TCollection &result, TCollection &visited, bool recurse)Verify the base classes always.Definition TClass.cxx:3927; TClass::fSchemaRulesROOT::Detail::TSchemaRuleSet * fSchemaRulesPointer to reference proxy if this class represents a reference.Definition TClass.h:281; TClass::fPropertystd::atomic< Long_t > fPropertyDefinition TClass.h:255; TClass::StreamerDefaultstatic void StreamerDefault(const TC",MatchSource.WIKI,doc/v632/TClass_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/TClass_8cxx_source.html
https://root.cern/doc/v632/TClass_8cxx_source.html:321767,Security,checksum,checksum,321767," TClass.cxx:3477; TClass::GetNdataInt_t GetNdata()Return the number of data members of this class Note that in case the list of data members is not yet...Definition TClass.cxx:4554; TClass::SetDestructorvoid SetDestructor(ROOT::DesFunc_t destructorFunc)Install a new wrapper around the destructor.Definition TClass.cxx:7017; TClass::PostLoadCheckvirtual void PostLoadCheck()Do the initialization that can only be done after the CINT dictionary has been fully populated and ca...Definition TClass.cxx:5959; TClass::LoadClassInfovoid LoadClassInfo() constTry to load the ClassInfo if available.Definition TClass.cxx:5824; TClass::SetResetAfterMergevoid SetResetAfterMerge(ROOT::ResetAfterMergeFunc_t resetFunc)Install a new wrapper around 'ResetAfterMerge'.Definition TClass.cxx:6977; TClass::GetStreamerInfoImplTVirtualStreamerInfo * GetStreamerInfoImpl(Int_t version, Bool_t silent) constDefinition TClass.cxx:4634; TClass::MatchLegacyCheckSumBool_t MatchLegacyCheckSum(UInt_t checksum) constReturn true if the checksum passed as argument is one of the checksum value produced by the older che...Definition TClass.cxx:6494; TClass::fAllPubMethodTViewPubFunctions * fAllPubMethodDefinition TClass.h:210; TClass::ERuntimeProperties::kSet@ kSet; TClass::ERuntimeProperties::kConsistentHash@ kConsistentHash; TClass::HasInterpreterInfoBool_t HasInterpreterInfo() constDefinition TClass.h:410; TClass::AddClassstatic void AddClass(TClass *cl)static: Add a class to the list and map of classes.Definition TClass.cxx:494; TClass::GetMissingDictionariesForBaseClassesvoid GetMissingDictionariesForBaseClasses(TCollection &result, TCollection &visited, bool recurse)Verify the base classes always.Definition TClass.cxx:3927; TClass::fSchemaRulesROOT::Detail::TSchemaRuleSet * fSchemaRulesPointer to reference proxy if this class represents a reference.Definition TClass.h:281; TClass::fPropertystd::atomic< Long_t > fPropertyDefinition TClass.h:255; TClass::StreamerDefaultstatic void StreamerDefault(const TC",MatchSource.WIKI,doc/v632/TClass_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/TClass_8cxx_source.html
https://root.cern/doc/v632/TClass_8cxx_source.html:321809,Security,checksum,checksum,321809," TClass.cxx:3477; TClass::GetNdataInt_t GetNdata()Return the number of data members of this class Note that in case the list of data members is not yet...Definition TClass.cxx:4554; TClass::SetDestructorvoid SetDestructor(ROOT::DesFunc_t destructorFunc)Install a new wrapper around the destructor.Definition TClass.cxx:7017; TClass::PostLoadCheckvirtual void PostLoadCheck()Do the initialization that can only be done after the CINT dictionary has been fully populated and ca...Definition TClass.cxx:5959; TClass::LoadClassInfovoid LoadClassInfo() constTry to load the ClassInfo if available.Definition TClass.cxx:5824; TClass::SetResetAfterMergevoid SetResetAfterMerge(ROOT::ResetAfterMergeFunc_t resetFunc)Install a new wrapper around 'ResetAfterMerge'.Definition TClass.cxx:6977; TClass::GetStreamerInfoImplTVirtualStreamerInfo * GetStreamerInfoImpl(Int_t version, Bool_t silent) constDefinition TClass.cxx:4634; TClass::MatchLegacyCheckSumBool_t MatchLegacyCheckSum(UInt_t checksum) constReturn true if the checksum passed as argument is one of the checksum value produced by the older che...Definition TClass.cxx:6494; TClass::fAllPubMethodTViewPubFunctions * fAllPubMethodDefinition TClass.h:210; TClass::ERuntimeProperties::kSet@ kSet; TClass::ERuntimeProperties::kConsistentHash@ kConsistentHash; TClass::HasInterpreterInfoBool_t HasInterpreterInfo() constDefinition TClass.h:410; TClass::AddClassstatic void AddClass(TClass *cl)static: Add a class to the list and map of classes.Definition TClass.cxx:494; TClass::GetMissingDictionariesForBaseClassesvoid GetMissingDictionariesForBaseClasses(TCollection &result, TCollection &visited, bool recurse)Verify the base classes always.Definition TClass.cxx:3927; TClass::fSchemaRulesROOT::Detail::TSchemaRuleSet * fSchemaRulesPointer to reference proxy if this class represents a reference.Definition TClass.h:281; TClass::fPropertystd::atomic< Long_t > fPropertyDefinition TClass.h:255; TClass::StreamerDefaultstatic void StreamerDefault(const TC",MatchSource.WIKI,doc/v632/TClass_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/TClass_8cxx_source.html
https://root.cern/doc/v632/TClass_8cxx_source.html:325059,Security,access,accessor,325059,"finition TClass.cxx:2112; TClass::LoadClassstatic TClass * LoadClass(const char *requestedname, Bool_t silent)Helper function used by TClass::GetClass().Definition TClass.cxx:5749; TClass::fSharedLibsTString fSharedLibsDefinition TClass.h:227; TClass::GetTypeInfoconst std::type_info * GetTypeInfo() constDefinition TClass.h:496; TClass::GetListOfDataMembersTList * GetListOfDataMembers(Bool_t load=kTRUE)Return list containing the TDataMembers of a class.Definition TClass.cxx:3770; TClass::ENewTypeENewTypeDefinition TClass.h:107; TClass::kRealNew@ kRealNewDefinition TClass.h:107; TClass::Movevoid Move(void *arenaFrom, void *arenaTo) constRegister the fact that an object was moved from the memory location 'arenaFrom' to the memory locatio...Definition TClass.cxx:4327; TClass::GetDeclIdMapstatic DeclIdMap_t * GetDeclIdMap()Definition TClass.cxx:480; TClass::GetDeclFileLineShort_t GetDeclFileLine() constDefinition TClass.h:429; TClass::SetStreamerFuncvoid SetStreamerFunc(ClassStreamerFunc_t strm)Set a wrapper/accessor function around this class custom streamer.Definition TClass.cxx:6922; TClass::GetImplFileNameconst char * GetImplFileName() constDefinition TClass.h:456; TClass::GetListOfRealDataTList * GetListOfRealData() constDefinition TClass.h:453; TClass::SizeInt_t Size() constReturn size of object of this class.Definition TClass.cxx:5704; TClass::SetCurrentStreamerInfovoid SetCurrentStreamerInfo(TVirtualStreamerInfo *info)Set pointer to current TVirtualStreamerInfo.Definition TClass.cxx:5696; TClass::GetDictstatic DictFuncPtr_t GetDict(const char *cname)Return a pointer to the dictionary loading function generated by rootcint.Definition TClass.cxx:3422; TClass::fOffsetStreamerLongptr_t fOffsetStreamerProperties that can only be evaluated at run-time.Definition TClass.h:275; TClass::fSizeofInt_t fSizeofDefinition TClass.h:243; TClass::GetNewArrayROOT::NewArrFunc_t GetNewArray() constReturn the wrapper around new ThisClass[].Definition TClass.cxx:7455; TClass::Streamer",MatchSource.WIKI,doc/v632/TClass_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/TClass_8cxx_source.html
https://root.cern/doc/v632/TClass_8cxx_source.html:331013,Security,access,accessor,331013,"334; TClass::kExternal@ kExternalDefinition TClass.h:334; TClass::kForeign@ kForeignDefinition TClass.h:334; TClass::kInstrumented@ kInstrumentedDefinition TClass.h:334; TClass::kTObject@ kTObjectDefinition TClass.h:334; TClass::AddRulestatic Bool_t AddRule(const char *rule)Add a schema evolution customization rule.Definition TClass.cxx:1890; TClass::IsTObjectBool_t IsTObject() constReturn kTRUE is the class inherits from TObject.Definition TClass.cxx:5938; TClass::RemoveClassstatic void RemoveClass(TClass *cl)static: Remove a class from the list and map of classesDefinition TClass.cxx:520; TClass::HasLocalHashMemberBool_t HasLocalHashMember() constReturns true if this class has an definition and/or overload of the member function Hash.Definition TClass.cxx:7421; TClass::DeleteArrayvoid DeleteArray(void *ary, Bool_t dtorOnly=kFALSE)Explicitly call operator delete[] for an array.Definition TClass.cxx:5529; TClass::GetConvStreamerFuncClassConvStreamerFunc_t GetConvStreamerFunc() constGet a wrapper/accessor function around this class custom conversion streamer (member function).Definition TClass.cxx:2947; TClass::IsForeignBool_t IsForeign() constReturn kTRUE is the class is Foreign (the class does not have a Streamer method).Definition TClass.cxx:5947; TClass::GetClassInfoClassInfo_t * GetClassInfo() constDefinition TClass.h:433; TClass::fDeleteROOT::DelFunc_t fDeleteDefinition TClass.h:237; TClass::fAllPubDataTViewPubDataMembers * fAllPubDataDefinition TClass.h:209; TClass::fClassInfoClassInfo_t * fClassInfoDefinition TClass.h:222; TClass::GetStreamerInfoTVirtualStreamerInfo * GetStreamerInfo(Int_t version=0, Bool_t isTransient=kFALSE) constreturns a pointer to the TVirtualStreamerInfo object for version If the object does not exist,...Definition TClass.cxx:4599; TClass::HasConsistentHashMemberBool_t HasConsistentHashMember()Return 'true' if we can guarantee that if this class (or any class in this class inheritance hierarch...Definition TClass.h:501; TClass::AdoptStre",MatchSource.WIKI,doc/v632/TClass_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/TClass_8cxx_source.html
https://root.cern/doc/v632/TClass_8cxx_source.html:335095,Security,access,access,335095,"alue of fStreamerType.Definition TClass.cxx:6215; TClass::GetSharedLibsconst char * GetSharedLibs()Get the list of shared libraries containing the code for class cls.Definition TClass.cxx:3623; TClass::CalculateStreamerOffsetvoid CalculateStreamerOffset() constCalculate the offset between an object of this class to its base class TObject.Definition TClass.cxx:2183; TClass::GetMissingDictionariesForPairElementsvoid GetMissingDictionariesForPairElements(TCollection &result, TCollection &visited, bool recurse)Definition TClass.cxx:3973; TClass::ReplaceWithvoid ReplaceWith(TClass *newcl) constDefinition TClass.cxx:4142; TClass::RegisterAddressInRepositoryvoid RegisterAddressInRepository(const char *where, void *location, const TClass *what) constDefinition TClass.cxx:290; TClass::PropertyLong_t Property() const overrideReturns the properties of the TClass as a bit field stored as a Long_t value.Definition TClass.cxx:6086; TClass::HasDefaultConstructorBool_t HasDefaultConstructor(Bool_t testio=kFALSE) constReturn true if we have access to a constructor usable for I/O.Definition TClass.cxx:7393; TClass::GetMenuItemsvoid GetMenuItems(TList *listitems)Returns list of methods accessible by context menu.Definition TClass.cxx:3874; TClass::SetNewvoid SetNew(ROOT::NewFunc_t newFunc)Install a new wrapper around 'new'.Definition TClass.cxx:6985; TClass::fIsAMethodstd::atomic< TMethodCall * > fIsAMethodDefinition TClass.h:231; TClass::ReadRulesstatic Int_t ReadRules()Read the class.rules files from the default location:.Definition TClass.cxx:1820; TClass::CanSplitBaseAllowBool_t CanSplitBaseAllow()Pointer to the function implementing streaming for this class.Definition TClass.cxx:2247; TClass::MoveAddressInRepositoryvoid MoveAddressInRepository(const char *where, void *oldadd, void *newadd, const TClass *what) constDefinition TClass.cxx:337; TClass::fStreamerImplstd::atomic< StreamerImpl_t > fStreamerImplDefinition TClass.h:287; TClass::SetContextMenuTitlevoid SetContextMenuTitle(c",MatchSource.WIKI,doc/v632/TClass_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/TClass_8cxx_source.html
https://root.cern/doc/v632/TClass_8cxx_source.html:335241,Security,access,accessible,335241," class cls.Definition TClass.cxx:3623; TClass::CalculateStreamerOffsetvoid CalculateStreamerOffset() constCalculate the offset between an object of this class to its base class TObject.Definition TClass.cxx:2183; TClass::GetMissingDictionariesForPairElementsvoid GetMissingDictionariesForPairElements(TCollection &result, TCollection &visited, bool recurse)Definition TClass.cxx:3973; TClass::ReplaceWithvoid ReplaceWith(TClass *newcl) constDefinition TClass.cxx:4142; TClass::RegisterAddressInRepositoryvoid RegisterAddressInRepository(const char *where, void *location, const TClass *what) constDefinition TClass.cxx:290; TClass::PropertyLong_t Property() const overrideReturns the properties of the TClass as a bit field stored as a Long_t value.Definition TClass.cxx:6086; TClass::HasDefaultConstructorBool_t HasDefaultConstructor(Bool_t testio=kFALSE) constReturn true if we have access to a constructor usable for I/O.Definition TClass.cxx:7393; TClass::GetMenuItemsvoid GetMenuItems(TList *listitems)Returns list of methods accessible by context menu.Definition TClass.cxx:3874; TClass::SetNewvoid SetNew(ROOT::NewFunc_t newFunc)Install a new wrapper around 'new'.Definition TClass.cxx:6985; TClass::fIsAMethodstd::atomic< TMethodCall * > fIsAMethodDefinition TClass.h:231; TClass::ReadRulesstatic Int_t ReadRules()Read the class.rules files from the default location:.Definition TClass.cxx:1820; TClass::CanSplitBaseAllowBool_t CanSplitBaseAllow()Pointer to the function implementing streaming for this class.Definition TClass.cxx:2247; TClass::MoveAddressInRepositoryvoid MoveAddressInRepository(const char *where, void *oldadd, void *newadd, const TClass *what) constDefinition TClass.cxx:337; TClass::fStreamerImplstd::atomic< StreamerImpl_t > fStreamerImplDefinition TClass.h:287; TClass::SetContextMenuTitlevoid SetContextMenuTitle(const char *title)Change (i.e. set) the title of the TNamed.Definition TClass.cxx:6269; TClass::SetMemberStreamervoid SetMemberStreamer(const char *name, M",MatchSource.WIKI,doc/v632/TClass_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/TClass_8cxx_source.html
https://root.cern/doc/v632/TClass_8cxx_source.html:337661,Security,checksum,checksum,337661,"eamerInfo from the class 'classname' for version number 'version' to this clas...Definition TClass.cxx:7086; TClass::GetImplFileLineShort_t GetImplFileLine() constDefinition TClass.h:457; TClass::GetMethodAllAnyTMethod * GetMethodAllAny(const char *method)Return pointer to method without looking at parameters.Definition TClass.cxx:4384; TClass::fRuntimePropertiesstd::atomic< UChar_t > fRuntimePropertiesDefinition TClass.h:273; TClass::EStateEStateDefinition TClass.h:121; TClass::kInterpreted@ kInterpretedDefinition TClass.h:126; TClass::kHasTClassInit@ kHasTClassInitDefinition TClass.h:127; TClass::kEmulated@ kEmulatedDefinition TClass.h:125; TClass::kNoInfo@ kNoInfoDefinition TClass.h:122; TClass::kLoaded@ kLoadedDefinition TClass.h:130; TClass::kForwardDeclared@ kForwardDeclaredDefinition TClass.h:124; TClass::kNamespaceForMeta@ kNamespaceForMetaDefinition TClass.h:131; TClass::FindConversionStreamerInfoTVirtualStreamerInfo * FindConversionStreamerInfo(const char *onfile_classname, UInt_t checksum) constReturn a Conversion StreamerInfo from the class 'classname' for the layout represented by 'checksum' ...Definition TClass.cxx:7193; TClass::GetBaseClassOffsetRecurseInt_t GetBaseClassOffsetRecurse(const TClass *toBase)Return data member offset to the base class ""cl"".Definition TClass.cxx:2705; TClass::GetDeleteROOT::DelFunc_t GetDelete() constReturn the wrapper around delete ThiObject.Definition TClass.cxx:7463; TClass::LoadClassDefaultstatic TClass * LoadClassDefault(const char *requestedname, Bool_t silent)Helper function used by TClass::GetClass().Definition TClass.cxx:5771; TClass::SetClassSizevoid SetClassSize(Int_t sizof)Definition TClass.h:307; TClass::FindClassOrBaseMethodWithIdTMethod * FindClassOrBaseMethodWithId(DeclId_t faddr)Find a method with decl id in this class or its bases.Definition TClass.cxx:4440; TClass::StreamerExternalstatic void StreamerExternal(const TClass *pThis, void *object, TBuffer &b, const TClass *onfile_class)There is special stream",MatchSource.WIKI,doc/v632/TClass_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/TClass_8cxx_source.html
https://root.cern/doc/v632/TClass_8cxx_source.html:337767,Security,checksum,checksum,337767,"eamerInfo from the class 'classname' for version number 'version' to this clas...Definition TClass.cxx:7086; TClass::GetImplFileLineShort_t GetImplFileLine() constDefinition TClass.h:457; TClass::GetMethodAllAnyTMethod * GetMethodAllAny(const char *method)Return pointer to method without looking at parameters.Definition TClass.cxx:4384; TClass::fRuntimePropertiesstd::atomic< UChar_t > fRuntimePropertiesDefinition TClass.h:273; TClass::EStateEStateDefinition TClass.h:121; TClass::kInterpreted@ kInterpretedDefinition TClass.h:126; TClass::kHasTClassInit@ kHasTClassInitDefinition TClass.h:127; TClass::kEmulated@ kEmulatedDefinition TClass.h:125; TClass::kNoInfo@ kNoInfoDefinition TClass.h:122; TClass::kLoaded@ kLoadedDefinition TClass.h:130; TClass::kForwardDeclared@ kForwardDeclaredDefinition TClass.h:124; TClass::kNamespaceForMeta@ kNamespaceForMetaDefinition TClass.h:131; TClass::FindConversionStreamerInfoTVirtualStreamerInfo * FindConversionStreamerInfo(const char *onfile_classname, UInt_t checksum) constReturn a Conversion StreamerInfo from the class 'classname' for the layout represented by 'checksum' ...Definition TClass.cxx:7193; TClass::GetBaseClassOffsetRecurseInt_t GetBaseClassOffsetRecurse(const TClass *toBase)Return data member offset to the base class ""cl"".Definition TClass.cxx:2705; TClass::GetDeleteROOT::DelFunc_t GetDelete() constReturn the wrapper around delete ThiObject.Definition TClass.cxx:7463; TClass::LoadClassDefaultstatic TClass * LoadClassDefault(const char *requestedname, Bool_t silent)Helper function used by TClass::GetClass().Definition TClass.cxx:5771; TClass::SetClassSizevoid SetClassSize(Int_t sizof)Definition TClass.h:307; TClass::FindClassOrBaseMethodWithIdTMethod * FindClassOrBaseMethodWithId(DeclId_t faddr)Find a method with decl id in this class or its bases.Definition TClass.cxx:4440; TClass::StreamerExternalstatic void StreamerExternal(const TClass *pThis, void *object, TBuffer &b, const TClass *onfile_class)There is special stream",MatchSource.WIKI,doc/v632/TClass_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/TClass_8cxx_source.html
https://root.cern/doc/v632/TClass_8cxx_source.html:339569,Security,access,accessor,339569,"rExternal(const TClass *pThis, void *object, TBuffer &b, const TClass *onfile_class)There is special streamer for the class.Definition TClass.cxx:6788; TClass::fClassPropertyLong_t fClassPropertyProperty See TClass::Property() for details.Definition TClass.h:256; TClass::fContextMenuTitleTString fContextMenuTitleDefinition TClass.h:223; TClass::StreamerTObjectInitializedstatic void StreamerTObjectInitialized(const TClass *pThis, void *object, TBuffer &b, const TClass *onfile_class)Case of TObjects when fIsOffsetStreamerSet is known to have been set.Definition TClass.cxx:6814; TClass::ConvStreamerInstrumentedstatic void ConvStreamerInstrumented(const TClass *pThis, void *object, TBuffer &b, const TClass *onfile_class)Case of instrumented class with a library.Definition TClass.cxx:6845; TClass::fCanLoadClassInfostd::atomic< Bool_t > fCanLoadClassInfoWhether info was loaded from a root pcm.Definition TClass.h:260; TClass::SetConvStreamerFuncvoid SetConvStreamerFunc(ClassConvStreamerFunc_t strm)Set a wrapper/accessor function around this class custom conversion streamer.Definition TClass.cxx:6945; TClass::FindStreamerInfoTVirtualStreamerInfo * FindStreamerInfo(TObjArray *arr, UInt_t checksum) constFind the TVirtualStreamerInfo in the StreamerInfos corresponding to checksum.Definition TClass.cxx:7066; TClass::GetMissingDictionariesvoid GetMissingDictionaries(THashTable &result, bool recurse=false)Get the classes that have a missing dictionary starting from this one.Definition TClass.cxx:4087; TClass::MakeCustomMenuListvoid MakeCustomMenuList()Makes a customizable version of the popup menu list, i.e.Definition TClass.cxx:4283; TClass::FindStreamerInfoAbstractEmulatedTVirtualStreamerInfo * FindStreamerInfoAbstractEmulated(UInt_t checksum) constFor the case where the requestor class is emulated and this class is abstract, returns a pointer to t...Definition TClass.cxx:4772; TClass::GetMethodAnyTMethod * GetMethodAny(const char *method)Return pointer to method without looking",MatchSource.WIKI,doc/v632/TClass_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/TClass_8cxx_source.html
https://root.cern/doc/v632/TClass_8cxx_source.html:339747,Security,checksum,checksum,339747,"Property See TClass::Property() for details.Definition TClass.h:256; TClass::fContextMenuTitleTString fContextMenuTitleDefinition TClass.h:223; TClass::StreamerTObjectInitializedstatic void StreamerTObjectInitialized(const TClass *pThis, void *object, TBuffer &b, const TClass *onfile_class)Case of TObjects when fIsOffsetStreamerSet is known to have been set.Definition TClass.cxx:6814; TClass::ConvStreamerInstrumentedstatic void ConvStreamerInstrumented(const TClass *pThis, void *object, TBuffer &b, const TClass *onfile_class)Case of instrumented class with a library.Definition TClass.cxx:6845; TClass::fCanLoadClassInfostd::atomic< Bool_t > fCanLoadClassInfoWhether info was loaded from a root pcm.Definition TClass.h:260; TClass::SetConvStreamerFuncvoid SetConvStreamerFunc(ClassConvStreamerFunc_t strm)Set a wrapper/accessor function around this class custom conversion streamer.Definition TClass.cxx:6945; TClass::FindStreamerInfoTVirtualStreamerInfo * FindStreamerInfo(TObjArray *arr, UInt_t checksum) constFind the TVirtualStreamerInfo in the StreamerInfos corresponding to checksum.Definition TClass.cxx:7066; TClass::GetMissingDictionariesvoid GetMissingDictionaries(THashTable &result, bool recurse=false)Get the classes that have a missing dictionary starting from this one.Definition TClass.cxx:4087; TClass::MakeCustomMenuListvoid MakeCustomMenuList()Makes a customizable version of the popup menu list, i.e.Definition TClass.cxx:4283; TClass::FindStreamerInfoAbstractEmulatedTVirtualStreamerInfo * FindStreamerInfoAbstractEmulated(UInt_t checksum) constFor the case where the requestor class is emulated and this class is abstract, returns a pointer to t...Definition TClass.cxx:4772; TClass::GetMethodAnyTMethod * GetMethodAny(const char *method)Return pointer to method without looking at parameters.Definition TClass.cxx:4374; TClass::GetIsAProxyTVirtualIsAProxy * GetIsAProxy() constReturn the proxy implementing the IsA functionality.Definition TClass.cxx:2955; TClass::GetMerg",MatchSource.WIKI,doc/v632/TClass_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/TClass_8cxx_source.html
https://root.cern/doc/v632/TClass_8cxx_source.html:339830,Security,checksum,checksum,339830,"Property See TClass::Property() for details.Definition TClass.h:256; TClass::fContextMenuTitleTString fContextMenuTitleDefinition TClass.h:223; TClass::StreamerTObjectInitializedstatic void StreamerTObjectInitialized(const TClass *pThis, void *object, TBuffer &b, const TClass *onfile_class)Case of TObjects when fIsOffsetStreamerSet is known to have been set.Definition TClass.cxx:6814; TClass::ConvStreamerInstrumentedstatic void ConvStreamerInstrumented(const TClass *pThis, void *object, TBuffer &b, const TClass *onfile_class)Case of instrumented class with a library.Definition TClass.cxx:6845; TClass::fCanLoadClassInfostd::atomic< Bool_t > fCanLoadClassInfoWhether info was loaded from a root pcm.Definition TClass.h:260; TClass::SetConvStreamerFuncvoid SetConvStreamerFunc(ClassConvStreamerFunc_t strm)Set a wrapper/accessor function around this class custom conversion streamer.Definition TClass.cxx:6945; TClass::FindStreamerInfoTVirtualStreamerInfo * FindStreamerInfo(TObjArray *arr, UInt_t checksum) constFind the TVirtualStreamerInfo in the StreamerInfos corresponding to checksum.Definition TClass.cxx:7066; TClass::GetMissingDictionariesvoid GetMissingDictionaries(THashTable &result, bool recurse=false)Get the classes that have a missing dictionary starting from this one.Definition TClass.cxx:4087; TClass::MakeCustomMenuListvoid MakeCustomMenuList()Makes a customizable version of the popup menu list, i.e.Definition TClass.cxx:4283; TClass::FindStreamerInfoAbstractEmulatedTVirtualStreamerInfo * FindStreamerInfoAbstractEmulated(UInt_t checksum) constFor the case where the requestor class is emulated and this class is abstract, returns a pointer to t...Definition TClass.cxx:4772; TClass::GetMethodAnyTMethod * GetMethodAny(const char *method)Return pointer to method without looking at parameters.Definition TClass.cxx:4374; TClass::GetIsAProxyTVirtualIsAProxy * GetIsAProxy() constReturn the proxy implementing the IsA functionality.Definition TClass.cxx:2955; TClass::GetMerg",MatchSource.WIKI,doc/v632/TClass_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/TClass_8cxx_source.html
https://root.cern/doc/v632/TClass_8cxx_source.html:340301,Security,checksum,checksum,340301,"ith a library.Definition TClass.cxx:6845; TClass::fCanLoadClassInfostd::atomic< Bool_t > fCanLoadClassInfoWhether info was loaded from a root pcm.Definition TClass.h:260; TClass::SetConvStreamerFuncvoid SetConvStreamerFunc(ClassConvStreamerFunc_t strm)Set a wrapper/accessor function around this class custom conversion streamer.Definition TClass.cxx:6945; TClass::FindStreamerInfoTVirtualStreamerInfo * FindStreamerInfo(TObjArray *arr, UInt_t checksum) constFind the TVirtualStreamerInfo in the StreamerInfos corresponding to checksum.Definition TClass.cxx:7066; TClass::GetMissingDictionariesvoid GetMissingDictionaries(THashTable &result, bool recurse=false)Get the classes that have a missing dictionary starting from this one.Definition TClass.cxx:4087; TClass::MakeCustomMenuListvoid MakeCustomMenuList()Makes a customizable version of the popup menu list, i.e.Definition TClass.cxx:4283; TClass::FindStreamerInfoAbstractEmulatedTVirtualStreamerInfo * FindStreamerInfoAbstractEmulated(UInt_t checksum) constFor the case where the requestor class is emulated and this class is abstract, returns a pointer to t...Definition TClass.cxx:4772; TClass::GetMethodAnyTMethod * GetMethodAny(const char *method)Return pointer to method without looking at parameters.Definition TClass.cxx:4374; TClass::GetIsAProxyTVirtualIsAProxy * GetIsAProxy() constReturn the proxy implementing the IsA functionality.Definition TClass.cxx:2955; TClass::GetMergeROOT::MergeFunc_t GetMerge() constReturn the wrapper around Merge.Definition TClass.cxx:7431; TClass::fResetAfterMergeROOT::ResetAfterMergeFunc_t fResetAfterMergeDefinition TClass.h:234; TClass::IsFolderBool_t IsFolder() const overrideReturns kTRUE in case object contains browsable objects (like containers or lists of other objects).Definition TClass.h:517; TClass::fInstanceCountUInt_t fInstanceCountDefinition TClass.h:217; TClass::fHasRootPcmInfostd::atomic< Bool_t > fHasRootPcmInfoC++ Property of the class (is abstract, has virtual table, etc.)Defin",MatchSource.WIKI,doc/v632/TClass_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/TClass_8cxx_source.html
https://root.cern/doc/v632/TClass_8cxx_source.html:348915,Security,hash,hash,348915,"lass defines an abstract interface that must be implemented by all classes that contain diction...Definition TDictionary.h:168; TDictionary::EMemberSelectionEMemberSelectionKinds of members to include in lists.Definition TDictionary.h:216; TDictionary::EMemberSelection::kNoUsingDecls@ kNoUsingDecls; TDictionary::EMemberSelection::kOnlyUsingDecls@ kOnlyUsingDecls; TDictionary::DeclId_tconst void * DeclId_tDefinition TDictionary.h:224; TDumpMembersDefinition TClass.cxx:554; TDumpMembers::Inspectvoid Inspect(TClass *cl, const char *parent, const char *name, const void *addr, Bool_t isTransient) overridePrint value of member mname.Definition TClass.cxx:574; TDumpMembers::TDumpMembersTDumpMembers(bool noAddr)Definition TClass.cxx:557; TDumpMembers::fNoAddrbool fNoAddrDefinition TClass.cxx:555; TEnum::GetEnumstatic TEnum * GetEnum(const std::type_info &ti, ESearchAction sa=kALoadAndInterpLookup)Definition TEnum.cxx:175; TEnum::kNone@ kNoneDefinition TEnum.h:48; TExMapThis class stores a (key,value) pair using an external hash.Definition TExMap.h:33; TExMap::GetValueLong64_t GetValue(ULong64_t hash, Long64_t key)Return the value belonging to specified key and hash value.Definition TExMap.cxx:174; TExMap::AddAtvoid AddAt(UInt_t slot, ULong64_t hash, Long64_t key, Long64_t value)Add an (key,value) pair to the table.Definition TExMap.cxx:117; TFunctionTemplateDictionary for function template This class describes one single function template.Definition TFunctionTemplate.h:26; TFunctionGlobal functions class (global functions are obtained from CINT).Definition TFunction.h:30; TFunction::GetNargsInt_t GetNargs() constNumber of function arguments.Definition TFunction.cxx:174; THashTableTHashTable implements a hash table to store TObject's.Definition THashTable.h:35; THashTable::Addvoid Add(TObject *obj) overrideAdd object to the hash table.Definition THashTable.cxx:92; THashTable::GetListForObjectconst TList * GetListForObject(const char *name) constReturn the TList corresponding",MatchSource.WIKI,doc/v632/TClass_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/TClass_8cxx_source.html
https://root.cern/doc/v632/TClass_8cxx_source.html:348988,Security,hash,hash,348988,"ry.h:168; TDictionary::EMemberSelectionEMemberSelectionKinds of members to include in lists.Definition TDictionary.h:216; TDictionary::EMemberSelection::kNoUsingDecls@ kNoUsingDecls; TDictionary::EMemberSelection::kOnlyUsingDecls@ kOnlyUsingDecls; TDictionary::DeclId_tconst void * DeclId_tDefinition TDictionary.h:224; TDumpMembersDefinition TClass.cxx:554; TDumpMembers::Inspectvoid Inspect(TClass *cl, const char *parent, const char *name, const void *addr, Bool_t isTransient) overridePrint value of member mname.Definition TClass.cxx:574; TDumpMembers::TDumpMembersTDumpMembers(bool noAddr)Definition TClass.cxx:557; TDumpMembers::fNoAddrbool fNoAddrDefinition TClass.cxx:555; TEnum::GetEnumstatic TEnum * GetEnum(const std::type_info &ti, ESearchAction sa=kALoadAndInterpLookup)Definition TEnum.cxx:175; TEnum::kNone@ kNoneDefinition TEnum.h:48; TExMapThis class stores a (key,value) pair using an external hash.Definition TExMap.h:33; TExMap::GetValueLong64_t GetValue(ULong64_t hash, Long64_t key)Return the value belonging to specified key and hash value.Definition TExMap.cxx:174; TExMap::AddAtvoid AddAt(UInt_t slot, ULong64_t hash, Long64_t key, Long64_t value)Add an (key,value) pair to the table.Definition TExMap.cxx:117; TFunctionTemplateDictionary for function template This class describes one single function template.Definition TFunctionTemplate.h:26; TFunctionGlobal functions class (global functions are obtained from CINT).Definition TFunction.h:30; TFunction::GetNargsInt_t GetNargs() constNumber of function arguments.Definition TFunction.cxx:174; THashTableTHashTable implements a hash table to store TObject's.Definition THashTable.h:35; THashTable::Addvoid Add(TObject *obj) overrideAdd object to the hash table.Definition THashTable.cxx:92; THashTable::GetListForObjectconst TList * GetListForObject(const char *name) constReturn the TList corresponding to object's name based hash value.Definition THashTable.cxx:268; THashTable::RemoveTObject * Remove(TObject *obj) ove",MatchSource.WIKI,doc/v632/TClass_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/TClass_8cxx_source.html
https://root.cern/doc/v632/TClass_8cxx_source.html:349055,Security,hash,hash,349055,"ry.h:168; TDictionary::EMemberSelectionEMemberSelectionKinds of members to include in lists.Definition TDictionary.h:216; TDictionary::EMemberSelection::kNoUsingDecls@ kNoUsingDecls; TDictionary::EMemberSelection::kOnlyUsingDecls@ kOnlyUsingDecls; TDictionary::DeclId_tconst void * DeclId_tDefinition TDictionary.h:224; TDumpMembersDefinition TClass.cxx:554; TDumpMembers::Inspectvoid Inspect(TClass *cl, const char *parent, const char *name, const void *addr, Bool_t isTransient) overridePrint value of member mname.Definition TClass.cxx:574; TDumpMembers::TDumpMembersTDumpMembers(bool noAddr)Definition TClass.cxx:557; TDumpMembers::fNoAddrbool fNoAddrDefinition TClass.cxx:555; TEnum::GetEnumstatic TEnum * GetEnum(const std::type_info &ti, ESearchAction sa=kALoadAndInterpLookup)Definition TEnum.cxx:175; TEnum::kNone@ kNoneDefinition TEnum.h:48; TExMapThis class stores a (key,value) pair using an external hash.Definition TExMap.h:33; TExMap::GetValueLong64_t GetValue(ULong64_t hash, Long64_t key)Return the value belonging to specified key and hash value.Definition TExMap.cxx:174; TExMap::AddAtvoid AddAt(UInt_t slot, ULong64_t hash, Long64_t key, Long64_t value)Add an (key,value) pair to the table.Definition TExMap.cxx:117; TFunctionTemplateDictionary for function template This class describes one single function template.Definition TFunctionTemplate.h:26; TFunctionGlobal functions class (global functions are obtained from CINT).Definition TFunction.h:30; TFunction::GetNargsInt_t GetNargs() constNumber of function arguments.Definition TFunction.cxx:174; THashTableTHashTable implements a hash table to store TObject's.Definition THashTable.h:35; THashTable::Addvoid Add(TObject *obj) overrideAdd object to the hash table.Definition THashTable.cxx:92; THashTable::GetListForObjectconst TList * GetListForObject(const char *name) constReturn the TList corresponding to object's name based hash value.Definition THashTable.cxx:268; THashTable::RemoveTObject * Remove(TObject *obj) ove",MatchSource.WIKI,doc/v632/TClass_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/TClass_8cxx_source.html
https://root.cern/doc/v632/TClass_8cxx_source.html:349140,Security,hash,hash,349140,"ction::kNoUsingDecls@ kNoUsingDecls; TDictionary::EMemberSelection::kOnlyUsingDecls@ kOnlyUsingDecls; TDictionary::DeclId_tconst void * DeclId_tDefinition TDictionary.h:224; TDumpMembersDefinition TClass.cxx:554; TDumpMembers::Inspectvoid Inspect(TClass *cl, const char *parent, const char *name, const void *addr, Bool_t isTransient) overridePrint value of member mname.Definition TClass.cxx:574; TDumpMembers::TDumpMembersTDumpMembers(bool noAddr)Definition TClass.cxx:557; TDumpMembers::fNoAddrbool fNoAddrDefinition TClass.cxx:555; TEnum::GetEnumstatic TEnum * GetEnum(const std::type_info &ti, ESearchAction sa=kALoadAndInterpLookup)Definition TEnum.cxx:175; TEnum::kNone@ kNoneDefinition TEnum.h:48; TExMapThis class stores a (key,value) pair using an external hash.Definition TExMap.h:33; TExMap::GetValueLong64_t GetValue(ULong64_t hash, Long64_t key)Return the value belonging to specified key and hash value.Definition TExMap.cxx:174; TExMap::AddAtvoid AddAt(UInt_t slot, ULong64_t hash, Long64_t key, Long64_t value)Add an (key,value) pair to the table.Definition TExMap.cxx:117; TFunctionTemplateDictionary for function template This class describes one single function template.Definition TFunctionTemplate.h:26; TFunctionGlobal functions class (global functions are obtained from CINT).Definition TFunction.h:30; TFunction::GetNargsInt_t GetNargs() constNumber of function arguments.Definition TFunction.cxx:174; THashTableTHashTable implements a hash table to store TObject's.Definition THashTable.h:35; THashTable::Addvoid Add(TObject *obj) overrideAdd object to the hash table.Definition THashTable.cxx:92; THashTable::GetListForObjectconst TList * GetListForObject(const char *name) constReturn the TList corresponding to object's name based hash value.Definition THashTable.cxx:268; THashTable::RemoveTObject * Remove(TObject *obj) overrideRemove object from the hashtable.Definition THashTable.cxx:417; TInterpreter::SuspendAutoLoadingRAIIDefinition TInterpreter.h:120; TInterpret",MatchSource.WIKI,doc/v632/TClass_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/TClass_8cxx_source.html
https://root.cern/doc/v632/TClass_8cxx_source.html:349609,Security,hash,hash,349609,"ition TClass.cxx:557; TDumpMembers::fNoAddrbool fNoAddrDefinition TClass.cxx:555; TEnum::GetEnumstatic TEnum * GetEnum(const std::type_info &ti, ESearchAction sa=kALoadAndInterpLookup)Definition TEnum.cxx:175; TEnum::kNone@ kNoneDefinition TEnum.h:48; TExMapThis class stores a (key,value) pair using an external hash.Definition TExMap.h:33; TExMap::GetValueLong64_t GetValue(ULong64_t hash, Long64_t key)Return the value belonging to specified key and hash value.Definition TExMap.cxx:174; TExMap::AddAtvoid AddAt(UInt_t slot, ULong64_t hash, Long64_t key, Long64_t value)Add an (key,value) pair to the table.Definition TExMap.cxx:117; TFunctionTemplateDictionary for function template This class describes one single function template.Definition TFunctionTemplate.h:26; TFunctionGlobal functions class (global functions are obtained from CINT).Definition TFunction.h:30; TFunction::GetNargsInt_t GetNargs() constNumber of function arguments.Definition TFunction.cxx:174; THashTableTHashTable implements a hash table to store TObject's.Definition THashTable.h:35; THashTable::Addvoid Add(TObject *obj) overrideAdd object to the hash table.Definition THashTable.cxx:92; THashTable::GetListForObjectconst TList * GetListForObject(const char *name) constReturn the TList corresponding to object's name based hash value.Definition THashTable.cxx:268; THashTable::RemoveTObject * Remove(TObject *obj) overrideRemove object from the hashtable.Definition THashTable.cxx:417; TInterpreter::SuspendAutoLoadingRAIIDefinition TInterpreter.h:120; TInterpreter::SuspendAutoParsingDefinition TInterpreter.h:111; TInterpreter::ClassInfo_HasMethodvirtual Bool_t ClassInfo_HasMethod(ClassInfo_t *, const char *) constDefinition TInterpreter.h:413; TInterpreter::DataMemberInfo_Namevirtual const char * DataMemberInfo_Name(DataMemberInfo_t *) constDefinition TInterpreter.h:469; TInterpreter::DataMemberInfo_TypeNamevirtual const char * DataMemberInfo_TypeName(DataMemberInfo_t *) constDefinition TInterpreter.h:467; T",MatchSource.WIKI,doc/v632/TClass_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/TClass_8cxx_source.html
https://root.cern/doc/v632/TClass_8cxx_source.html:349731,Security,hash,hash,349731,"tic TEnum * GetEnum(const std::type_info &ti, ESearchAction sa=kALoadAndInterpLookup)Definition TEnum.cxx:175; TEnum::kNone@ kNoneDefinition TEnum.h:48; TExMapThis class stores a (key,value) pair using an external hash.Definition TExMap.h:33; TExMap::GetValueLong64_t GetValue(ULong64_t hash, Long64_t key)Return the value belonging to specified key and hash value.Definition TExMap.cxx:174; TExMap::AddAtvoid AddAt(UInt_t slot, ULong64_t hash, Long64_t key, Long64_t value)Add an (key,value) pair to the table.Definition TExMap.cxx:117; TFunctionTemplateDictionary for function template This class describes one single function template.Definition TFunctionTemplate.h:26; TFunctionGlobal functions class (global functions are obtained from CINT).Definition TFunction.h:30; TFunction::GetNargsInt_t GetNargs() constNumber of function arguments.Definition TFunction.cxx:174; THashTableTHashTable implements a hash table to store TObject's.Definition THashTable.h:35; THashTable::Addvoid Add(TObject *obj) overrideAdd object to the hash table.Definition THashTable.cxx:92; THashTable::GetListForObjectconst TList * GetListForObject(const char *name) constReturn the TList corresponding to object's name based hash value.Definition THashTable.cxx:268; THashTable::RemoveTObject * Remove(TObject *obj) overrideRemove object from the hashtable.Definition THashTable.cxx:417; TInterpreter::SuspendAutoLoadingRAIIDefinition TInterpreter.h:120; TInterpreter::SuspendAutoParsingDefinition TInterpreter.h:111; TInterpreter::ClassInfo_HasMethodvirtual Bool_t ClassInfo_HasMethod(ClassInfo_t *, const char *) constDefinition TInterpreter.h:413; TInterpreter::DataMemberInfo_Namevirtual const char * DataMemberInfo_Name(DataMemberInfo_t *) constDefinition TInterpreter.h:469; TInterpreter::DataMemberInfo_TypeNamevirtual const char * DataMemberInfo_TypeName(DataMemberInfo_t *) constDefinition TInterpreter.h:467; TInterpreter::DataMemberInfo_TypeSizevirtual int DataMemberInfo_TypeSize(DataMemberInfo_t *) constDe",MatchSource.WIKI,doc/v632/TClass_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/TClass_8cxx_source.html
https://root.cern/doc/v632/TClass_8cxx_source.html:349908,Security,hash,hash,349908," TEnum.h:48; TExMapThis class stores a (key,value) pair using an external hash.Definition TExMap.h:33; TExMap::GetValueLong64_t GetValue(ULong64_t hash, Long64_t key)Return the value belonging to specified key and hash value.Definition TExMap.cxx:174; TExMap::AddAtvoid AddAt(UInt_t slot, ULong64_t hash, Long64_t key, Long64_t value)Add an (key,value) pair to the table.Definition TExMap.cxx:117; TFunctionTemplateDictionary for function template This class describes one single function template.Definition TFunctionTemplate.h:26; TFunctionGlobal functions class (global functions are obtained from CINT).Definition TFunction.h:30; TFunction::GetNargsInt_t GetNargs() constNumber of function arguments.Definition TFunction.cxx:174; THashTableTHashTable implements a hash table to store TObject's.Definition THashTable.h:35; THashTable::Addvoid Add(TObject *obj) overrideAdd object to the hash table.Definition THashTable.cxx:92; THashTable::GetListForObjectconst TList * GetListForObject(const char *name) constReturn the TList corresponding to object's name based hash value.Definition THashTable.cxx:268; THashTable::RemoveTObject * Remove(TObject *obj) overrideRemove object from the hashtable.Definition THashTable.cxx:417; TInterpreter::SuspendAutoLoadingRAIIDefinition TInterpreter.h:120; TInterpreter::SuspendAutoParsingDefinition TInterpreter.h:111; TInterpreter::ClassInfo_HasMethodvirtual Bool_t ClassInfo_HasMethod(ClassInfo_t *, const char *) constDefinition TInterpreter.h:413; TInterpreter::DataMemberInfo_Namevirtual const char * DataMemberInfo_Name(DataMemberInfo_t *) constDefinition TInterpreter.h:469; TInterpreter::DataMemberInfo_TypeNamevirtual const char * DataMemberInfo_TypeName(DataMemberInfo_t *) constDefinition TInterpreter.h:467; TInterpreter::DataMemberInfo_TypeSizevirtual int DataMemberInfo_TypeSize(DataMemberInfo_t *) constDefinition TInterpreter.h:466; TInterpreter::ClassInfo_Newvirtual void * ClassInfo_New(ClassInfo_t *) constDefinition TInterpreter.h:425; TInt",MatchSource.WIKI,doc/v632/TClass_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/TClass_8cxx_source.html
https://root.cern/doc/v632/TClass_8cxx_source.html:350030,Security,hash,hashtable,350030,"sh, Long64_t key)Return the value belonging to specified key and hash value.Definition TExMap.cxx:174; TExMap::AddAtvoid AddAt(UInt_t slot, ULong64_t hash, Long64_t key, Long64_t value)Add an (key,value) pair to the table.Definition TExMap.cxx:117; TFunctionTemplateDictionary for function template This class describes one single function template.Definition TFunctionTemplate.h:26; TFunctionGlobal functions class (global functions are obtained from CINT).Definition TFunction.h:30; TFunction::GetNargsInt_t GetNargs() constNumber of function arguments.Definition TFunction.cxx:174; THashTableTHashTable implements a hash table to store TObject's.Definition THashTable.h:35; THashTable::Addvoid Add(TObject *obj) overrideAdd object to the hash table.Definition THashTable.cxx:92; THashTable::GetListForObjectconst TList * GetListForObject(const char *name) constReturn the TList corresponding to object's name based hash value.Definition THashTable.cxx:268; THashTable::RemoveTObject * Remove(TObject *obj) overrideRemove object from the hashtable.Definition THashTable.cxx:417; TInterpreter::SuspendAutoLoadingRAIIDefinition TInterpreter.h:120; TInterpreter::SuspendAutoParsingDefinition TInterpreter.h:111; TInterpreter::ClassInfo_HasMethodvirtual Bool_t ClassInfo_HasMethod(ClassInfo_t *, const char *) constDefinition TInterpreter.h:413; TInterpreter::DataMemberInfo_Namevirtual const char * DataMemberInfo_Name(DataMemberInfo_t *) constDefinition TInterpreter.h:469; TInterpreter::DataMemberInfo_TypeNamevirtual const char * DataMemberInfo_TypeName(DataMemberInfo_t *) constDefinition TInterpreter.h:467; TInterpreter::DataMemberInfo_TypeSizevirtual int DataMemberInfo_TypeSize(DataMemberInfo_t *) constDefinition TInterpreter.h:466; TInterpreter::ClassInfo_Newvirtual void * ClassInfo_New(ClassInfo_t *) constDefinition TInterpreter.h:425; TInterpreter::ClassInfo_IsValidvirtual Bool_t ClassInfo_IsValid(ClassInfo_t *) constDefinition TInterpreter.h:421; TInterpreter::AutoParsevirtual Int_t A",MatchSource.WIKI,doc/v632/TClass_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/TClass_8cxx_source.html
https://root.cern/doc/v632/TClass_8cxx_source.html:353763,Security,access,access,353763,"r::DataMemberInfo_MaxIndexvirtual int DataMemberInfo_MaxIndex(DataMemberInfo_t *, Int_t) constDefinition TInterpreter.h:461; TInterpreter::DeclId_tTDictionary::DeclId_t DeclId_tDefinition TInterpreter.h:288; TInterpreter::ClassInfo_HasDefaultConstructorvirtual Bool_t ClassInfo_HasDefaultConstructor(ClassInfo_t *, Bool_t=kFALSE) constDefinition TInterpreter.h:412; TInterpreter::ClassInfo_ClassPropertyvirtual Long_t ClassInfo_ClassProperty(ClassInfo_t *) constDefinition TInterpreter.h:400; TInterpreter::ClassInfo_GetBaseOffsetvirtual Longptr_t ClassInfo_GetBaseOffset(ClassInfo_t *, ClassInfo_t *, void *=nullptr, bool=true) constDefinition TInterpreter.h:409; TInterpreter::ClassInfo_Destructvirtual void ClassInfo_Destruct(ClassInfo_t *, void *) constDefinition TInterpreter.h:404; TIsAProxyTIsAProxy implementation class.Definition TIsAProxy.h:27; TIterDefinition TCollection.h:235; TIter::Resetvoid Reset()Definition TCollection.h:254; TListOfDataMembersA collection of TDataMember objects designed for fast access given a DeclId_t and for keep track of T...Definition TListOfDataMembers.h:33; TListOfEnumsWithLockA collection of TEnum objects designed for fast access given a DeclId_t and for keep track of TEnum t...Definition TListOfEnumsWithLock.h:31; TListOfEnumsWithLock::Classstatic TClass * Class(); TListOfEnumsA collection of TEnum objects designed for fast access given a DeclId_t and for keep track of TEnum t...Definition TListOfEnums.h:33; TListOfFunctionTemplatesA collection of TFunction objects designed for fast access given a DeclId_t and for keep track of TFu...Definition TListOfFunctionTemplates.h:35; TListOfFunctionTemplates::fClassTClass * fClassDefinition TListOfFunctionTemplates.h:40; TListOfFunctionTemplates::FindObjectTObject * FindObject(const char *name) const overrideSpecialize FindObject to do search for the a function just by name or create it if its not already in...Definition TListOfFunctionTemplates.cxx:175; TListOfFunctionTemplates::Loadvoid Load()L",MatchSource.WIKI,doc/v632/TClass_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/TClass_8cxx_source.html
https://root.cern/doc/v632/TClass_8cxx_source.html:353917,Security,access,access,353917,"DeclId_t DeclId_tDefinition TInterpreter.h:288; TInterpreter::ClassInfo_HasDefaultConstructorvirtual Bool_t ClassInfo_HasDefaultConstructor(ClassInfo_t *, Bool_t=kFALSE) constDefinition TInterpreter.h:412; TInterpreter::ClassInfo_ClassPropertyvirtual Long_t ClassInfo_ClassProperty(ClassInfo_t *) constDefinition TInterpreter.h:400; TInterpreter::ClassInfo_GetBaseOffsetvirtual Longptr_t ClassInfo_GetBaseOffset(ClassInfo_t *, ClassInfo_t *, void *=nullptr, bool=true) constDefinition TInterpreter.h:409; TInterpreter::ClassInfo_Destructvirtual void ClassInfo_Destruct(ClassInfo_t *, void *) constDefinition TInterpreter.h:404; TIsAProxyTIsAProxy implementation class.Definition TIsAProxy.h:27; TIterDefinition TCollection.h:235; TIter::Resetvoid Reset()Definition TCollection.h:254; TListOfDataMembersA collection of TDataMember objects designed for fast access given a DeclId_t and for keep track of T...Definition TListOfDataMembers.h:33; TListOfEnumsWithLockA collection of TEnum objects designed for fast access given a DeclId_t and for keep track of TEnum t...Definition TListOfEnumsWithLock.h:31; TListOfEnumsWithLock::Classstatic TClass * Class(); TListOfEnumsA collection of TEnum objects designed for fast access given a DeclId_t and for keep track of TEnum t...Definition TListOfEnums.h:33; TListOfFunctionTemplatesA collection of TFunction objects designed for fast access given a DeclId_t and for keep track of TFu...Definition TListOfFunctionTemplates.h:35; TListOfFunctionTemplates::fClassTClass * fClassDefinition TListOfFunctionTemplates.h:40; TListOfFunctionTemplates::FindObjectTObject * FindObject(const char *name) const overrideSpecialize FindObject to do search for the a function just by name or create it if its not already in...Definition TListOfFunctionTemplates.cxx:175; TListOfFunctionTemplates::Loadvoid Load()Load all the functions known to the interpreter for the scope 'fClass' into this collection.Definition TListOfFunctionTemplates.cxx:356; TListOfFunctionTemplate",MatchSource.WIKI,doc/v632/TClass_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/TClass_8cxx_source.html
https://root.cern/doc/v632/TClass_8cxx_source.html:354123,Security,access,access,354123,"n TInterpreter.h:412; TInterpreter::ClassInfo_ClassPropertyvirtual Long_t ClassInfo_ClassProperty(ClassInfo_t *) constDefinition TInterpreter.h:400; TInterpreter::ClassInfo_GetBaseOffsetvirtual Longptr_t ClassInfo_GetBaseOffset(ClassInfo_t *, ClassInfo_t *, void *=nullptr, bool=true) constDefinition TInterpreter.h:409; TInterpreter::ClassInfo_Destructvirtual void ClassInfo_Destruct(ClassInfo_t *, void *) constDefinition TInterpreter.h:404; TIsAProxyTIsAProxy implementation class.Definition TIsAProxy.h:27; TIterDefinition TCollection.h:235; TIter::Resetvoid Reset()Definition TCollection.h:254; TListOfDataMembersA collection of TDataMember objects designed for fast access given a DeclId_t and for keep track of T...Definition TListOfDataMembers.h:33; TListOfEnumsWithLockA collection of TEnum objects designed for fast access given a DeclId_t and for keep track of TEnum t...Definition TListOfEnumsWithLock.h:31; TListOfEnumsWithLock::Classstatic TClass * Class(); TListOfEnumsA collection of TEnum objects designed for fast access given a DeclId_t and for keep track of TEnum t...Definition TListOfEnums.h:33; TListOfFunctionTemplatesA collection of TFunction objects designed for fast access given a DeclId_t and for keep track of TFu...Definition TListOfFunctionTemplates.h:35; TListOfFunctionTemplates::fClassTClass * fClassDefinition TListOfFunctionTemplates.h:40; TListOfFunctionTemplates::FindObjectTObject * FindObject(const char *name) const overrideSpecialize FindObject to do search for the a function just by name or create it if its not already in...Definition TListOfFunctionTemplates.cxx:175; TListOfFunctionTemplates::Loadvoid Load()Load all the functions known to the interpreter for the scope 'fClass' into this collection.Definition TListOfFunctionTemplates.cxx:356; TListOfFunctionTemplates::Deletevoid Delete(Option_t *option="""") overrideDelete all TFunction object files.Definition TListOfFunctionTemplates.cxx:164; TListOfFunctionsA collection of TFunction objects desig",MatchSource.WIKI,doc/v632/TClass_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/TClass_8cxx_source.html
https://root.cern/doc/v632/TClass_8cxx_source.html:354285,Security,access,access,354285,"seOffsetvirtual Longptr_t ClassInfo_GetBaseOffset(ClassInfo_t *, ClassInfo_t *, void *=nullptr, bool=true) constDefinition TInterpreter.h:409; TInterpreter::ClassInfo_Destructvirtual void ClassInfo_Destruct(ClassInfo_t *, void *) constDefinition TInterpreter.h:404; TIsAProxyTIsAProxy implementation class.Definition TIsAProxy.h:27; TIterDefinition TCollection.h:235; TIter::Resetvoid Reset()Definition TCollection.h:254; TListOfDataMembersA collection of TDataMember objects designed for fast access given a DeclId_t and for keep track of T...Definition TListOfDataMembers.h:33; TListOfEnumsWithLockA collection of TEnum objects designed for fast access given a DeclId_t and for keep track of TEnum t...Definition TListOfEnumsWithLock.h:31; TListOfEnumsWithLock::Classstatic TClass * Class(); TListOfEnumsA collection of TEnum objects designed for fast access given a DeclId_t and for keep track of TEnum t...Definition TListOfEnums.h:33; TListOfFunctionTemplatesA collection of TFunction objects designed for fast access given a DeclId_t and for keep track of TFu...Definition TListOfFunctionTemplates.h:35; TListOfFunctionTemplates::fClassTClass * fClassDefinition TListOfFunctionTemplates.h:40; TListOfFunctionTemplates::FindObjectTObject * FindObject(const char *name) const overrideSpecialize FindObject to do search for the a function just by name or create it if its not already in...Definition TListOfFunctionTemplates.cxx:175; TListOfFunctionTemplates::Loadvoid Load()Load all the functions known to the interpreter for the scope 'fClass' into this collection.Definition TListOfFunctionTemplates.cxx:356; TListOfFunctionTemplates::Deletevoid Delete(Option_t *option="""") overrideDelete all TFunction object files.Definition TListOfFunctionTemplates.cxx:164; TListOfFunctionsA collection of TFunction objects designed for fast access given a DeclId_t and for keep track of TFu...Definition TListOfFunctions.h:35; TListOfFunctions::GetTFunction * Get(DeclId_t id)Return (after creating it if n",MatchSource.WIKI,doc/v632/TClass_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/TClass_8cxx_source.html
https://root.cern/doc/v632/TClass_8cxx_source.html:355104,Security,access,access,355104," TEnum objects designed for fast access given a DeclId_t and for keep track of TEnum t...Definition TListOfEnums.h:33; TListOfFunctionTemplatesA collection of TFunction objects designed for fast access given a DeclId_t and for keep track of TFu...Definition TListOfFunctionTemplates.h:35; TListOfFunctionTemplates::fClassTClass * fClassDefinition TListOfFunctionTemplates.h:40; TListOfFunctionTemplates::FindObjectTObject * FindObject(const char *name) const overrideSpecialize FindObject to do search for the a function just by name or create it if its not already in...Definition TListOfFunctionTemplates.cxx:175; TListOfFunctionTemplates::Loadvoid Load()Load all the functions known to the interpreter for the scope 'fClass' into this collection.Definition TListOfFunctionTemplates.cxx:356; TListOfFunctionTemplates::Deletevoid Delete(Option_t *option="""") overrideDelete all TFunction object files.Definition TListOfFunctionTemplates.cxx:164; TListOfFunctionsA collection of TFunction objects designed for fast access given a DeclId_t and for keep track of TFu...Definition TListOfFunctions.h:35; TListOfFunctions::GetTFunction * Get(DeclId_t id)Return (after creating it if necessary) the TMethod or TFunction describing the function correspondin...Definition TListOfFunctions.cxx:262; TListOfFunctions::GetListForObjectvirtual TList * GetListForObject(const char *name) constReturn the set of overloads for this name, collecting all available ones.Definition TListOfFunctions.cxx:230; TListOfFunctions::FindObjectTObject * FindObject(const TObject *obj) const overrideFind object using its hash value (returned by its Hash() member).Definition TListOfFunctions.cxx:443; TListA doubly linked list.Definition TList.h:38; TList::FindObjectTObject * FindObject(const char *name) const overrideFind an object in this list using its name.Definition TList.cxx:576; TList::Addvoid Add(TObject *obj) overrideDefinition TList.h:83; TList::RemoveTObject * Remove(TObject *obj) overrideRemove object from the",MatchSource.WIKI,doc/v632/TClass_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/TClass_8cxx_source.html
https://root.cern/doc/v632/TClass_8cxx_source.html:355685,Security,hash,hash,355685,"lready in...Definition TListOfFunctionTemplates.cxx:175; TListOfFunctionTemplates::Loadvoid Load()Load all the functions known to the interpreter for the scope 'fClass' into this collection.Definition TListOfFunctionTemplates.cxx:356; TListOfFunctionTemplates::Deletevoid Delete(Option_t *option="""") overrideDelete all TFunction object files.Definition TListOfFunctionTemplates.cxx:164; TListOfFunctionsA collection of TFunction objects designed for fast access given a DeclId_t and for keep track of TFu...Definition TListOfFunctions.h:35; TListOfFunctions::GetTFunction * Get(DeclId_t id)Return (after creating it if necessary) the TMethod or TFunction describing the function correspondin...Definition TListOfFunctions.cxx:262; TListOfFunctions::GetListForObjectvirtual TList * GetListForObject(const char *name) constReturn the set of overloads for this name, collecting all available ones.Definition TListOfFunctions.cxx:230; TListOfFunctions::FindObjectTObject * FindObject(const TObject *obj) const overrideFind object using its hash value (returned by its Hash() member).Definition TListOfFunctions.cxx:443; TListA doubly linked list.Definition TList.h:38; TList::FindObjectTObject * FindObject(const char *name) const overrideFind an object in this list using its name.Definition TList.cxx:576; TList::Addvoid Add(TObject *obj) overrideDefinition TList.h:83; TList::RemoveTObject * Remove(TObject *obj) overrideRemove object from the list.Definition TList.cxx:820; TList::AddLastvoid AddLast(TObject *obj) overrideAdd object at the end of the list.Definition TList.cxx:150; TList::FirstLinkvirtual TObjLink * FirstLink() constDefinition TList.h:104; TList::Deletevoid Delete(Option_t *option="""") overrideRemove all objects from the list AND delete all heap based objects.Definition TList.cxx:468; TList::AddFirstvoid AddFirst(TObject *obj) overrideAdd object at the beginning of the list.Definition TList.cxx:98; TMapTMap implements an associative array of (key,value) pairs using a THashTabl",MatchSource.WIKI,doc/v632/TClass_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/TClass_8cxx_source.html
https://root.cern/doc/v632/TClass_8cxx_source.html:356741,Security,access,accessing,356741,"n TListOfFunctions.cxx:443; TListA doubly linked list.Definition TList.h:38; TList::FindObjectTObject * FindObject(const char *name) const overrideFind an object in this list using its name.Definition TList.cxx:576; TList::Addvoid Add(TObject *obj) overrideDefinition TList.h:83; TList::RemoveTObject * Remove(TObject *obj) overrideRemove object from the list.Definition TList.cxx:820; TList::AddLastvoid AddLast(TObject *obj) overrideAdd object at the end of the list.Definition TList.cxx:150; TList::FirstLinkvirtual TObjLink * FirstLink() constDefinition TList.h:104; TList::Deletevoid Delete(Option_t *option="""") overrideRemove all objects from the list AND delete all heap based objects.Definition TList.cxx:468; TList::AddFirstvoid AddFirst(TObject *obj) overrideAdd object at the beginning of the list.Definition TList.cxx:98; TMapTMap implements an associative array of (key,value) pairs using a THashTable for efficient retrieval ...Definition TMap.h:40; TMemberInspectorAbstract base class for accessing the data-members of a class.Definition TMemberInspector.h:31; TMemberInspector::Inspectvirtual void Inspect(TClass *cl, const char *parent, const char *name, const void *addr)Definition TMemberInspector.cxx:99; TMemberStreamerDefinition TMemberStreamer.h:26; TMethodArgEach ROOT method (see TMethod) has a linked list of its arguments.Definition TMethodArg.h:36; TMethodArg::GetFullTypeNameconst char * GetFullTypeName() constGet full type description of method argument, e.g.: ""class TDirectory*"".Definition TMethodArg.cxx:74; TMethodEach ROOT class (see TClass) has a linked list of methods.Definition TMethod.h:38; TMethod::GetClassTClass * GetClass() constDefinition TMethod.h:55; TMethod::IsMenuItemEMenuItemKind IsMenuItem() constDefinition TMethod.h:56; TMethod::GetListOfMethodArgsvirtual TList * GetListOfMethodArgs()Returns methodarg list and additionally updates fDataMember in TMethod by calling FindDataMember();.Definition TMethod.cxx:307; TNamed::CloneTObject * Clone(con",MatchSource.WIKI,doc/v632/TClass_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/TClass_8cxx_source.html
https://root.cern/doc/v632/TClass_8cxx_source.html:364988,Security,hash,hash,364988,"merElement.h:122; TStreamerElement::IsATClass * IsA() const overrideDefinition TStreamerElement.h:146; TStreamerElement::GetOffsetInt_t GetOffset() constDefinition TStreamerElement.h:119; TStreamerElement::IsBasevirtual Bool_t IsBase() constReturn kTRUE if the element represent a base class.Definition TStreamerElement.cxx:429; TStreamerSTLDefinition TStreamerElement.h:391; TStreamerSTL::Classstatic TClass * Class(); TStringBasic string class.Definition TString.h:139; TString::LengthSsiz_t Length() constDefinition TString.h:417; TString::ReplaceTString & Replace(Ssiz_t pos, Ssiz_t n, const char *s)Definition TString.h:694; TString::Dataconst char * Data() constDefinition TString.h:376; TString::ReplaceAllTString & ReplaceAll(const TString &s1, const TString &s2)Definition TString.h:704; TString::BeginsWithBool_t BeginsWith(const char *s, ECaseCompare cmp=kExact) constDefinition TString.h:623; TString::IsNullBool_t IsNull() constDefinition TString.h:414; TString::HashUInt_t Hash(ECaseCompare cmp=kExact) constReturn hash value.Definition TString.cxx:677; TString::RemoveTString & Remove(Ssiz_t pos)Definition TString.h:685; TString::Formatstatic TString Format(const char *fmt,...)Static method which formats a string using a printf style format descriptor and return a TString.Definition TString.cxx:2378; TString::Formvoid Form(const char *fmt,...)Formats a string using a printf style format descriptor.Definition TString.cxx:2356; TString::Classstatic TClass * Class(); TString::ContainsBool_t Contains(const char *pat, ECaseCompare cmp=kExact) constDefinition TString.h:632; TString::IndexSsiz_t Index(const char *pat, Ssiz_t i=0, ECaseCompare cmp=kExact) constDefinition TString.h:651; TSystem::PrependPathNamevirtual const char * PrependPathName(const char *dir, TString &name)Concatenate a directory and a file name.Definition TSystem.cxx:1081; TViewPubDataMembersView implementing the TList interface and giving access all the TDictionary describing public data me...Definition ",MatchSource.WIKI,doc/v632/TClass_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/TClass_8cxx_source.html
https://root.cern/doc/v632/TClass_8cxx_source.html:365893,Security,access,access,365893,"ool_t IsNull() constDefinition TString.h:414; TString::HashUInt_t Hash(ECaseCompare cmp=kExact) constReturn hash value.Definition TString.cxx:677; TString::RemoveTString & Remove(Ssiz_t pos)Definition TString.h:685; TString::Formatstatic TString Format(const char *fmt,...)Static method which formats a string using a printf style format descriptor and return a TString.Definition TString.cxx:2378; TString::Formvoid Form(const char *fmt,...)Formats a string using a printf style format descriptor.Definition TString.cxx:2356; TString::Classstatic TClass * Class(); TString::ContainsBool_t Contains(const char *pat, ECaseCompare cmp=kExact) constDefinition TString.h:632; TString::IndexSsiz_t Index(const char *pat, Ssiz_t i=0, ECaseCompare cmp=kExact) constDefinition TString.h:651; TSystem::PrependPathNamevirtual const char * PrependPathName(const char *dir, TString &name)Concatenate a directory and a file name.Definition TSystem.cxx:1081; TViewPubDataMembersView implementing the TList interface and giving access all the TDictionary describing public data me...Definition TViewPubDataMembers.h:28; TViewPubDataMembers::Loadvoid Load()Load all the DataMembers known to the interpreter for the scope 'fClass' and all its bases classes.Definition TViewPubDataMembers.cxx:298; TViewPubDataMembers::Deletevoid Delete(Option_t *option="""") overrideDelete is not allowed in this class.Definition TViewPubDataMembers.cxx:78; TViewPubFunctionsView implementing the TList interface and giving access all the TFunction describing public methods i...Definition TViewPubFunctions.h:28; TViewPubFunctions::Loadvoid Load()Load all the functions known to the interpreter for the scope 'fClass' and all its bases classes.Definition TViewPubFunctions.cxx:298; TViewPubFunctions::Deletevoid Delete(Option_t *option="""") overrideDelete is not allowed in this class.Definition TViewPubFunctions.cxx:78; TVirtualCollectionProxy::TPushPopRAII helper class that ensures that PushProxy() / PopProxy() are called when ente",MatchSource.WIKI,doc/v632/TClass_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/TClass_8cxx_source.html
https://root.cern/doc/v632/TClass_8cxx_source.html:366369,Security,access,access,366369,"e format descriptor.Definition TString.cxx:2356; TString::Classstatic TClass * Class(); TString::ContainsBool_t Contains(const char *pat, ECaseCompare cmp=kExact) constDefinition TString.h:632; TString::IndexSsiz_t Index(const char *pat, Ssiz_t i=0, ECaseCompare cmp=kExact) constDefinition TString.h:651; TSystem::PrependPathNamevirtual const char * PrependPathName(const char *dir, TString &name)Concatenate a directory and a file name.Definition TSystem.cxx:1081; TViewPubDataMembersView implementing the TList interface and giving access all the TDictionary describing public data me...Definition TViewPubDataMembers.h:28; TViewPubDataMembers::Loadvoid Load()Load all the DataMembers known to the interpreter for the scope 'fClass' and all its bases classes.Definition TViewPubDataMembers.cxx:298; TViewPubDataMembers::Deletevoid Delete(Option_t *option="""") overrideDelete is not allowed in this class.Definition TViewPubDataMembers.cxx:78; TViewPubFunctionsView implementing the TList interface and giving access all the TFunction describing public methods i...Definition TViewPubFunctions.h:28; TViewPubFunctions::Loadvoid Load()Load all the functions known to the interpreter for the scope 'fClass' and all its bases classes.Definition TViewPubFunctions.cxx:298; TViewPubFunctions::Deletevoid Delete(Option_t *option="""") overrideDelete is not allowed in this class.Definition TViewPubFunctions.cxx:78; TVirtualCollectionProxy::TPushPopRAII helper class that ensures that PushProxy() / PopProxy() are called when entering / leaving a C++...Definition TVirtualCollectionProxy.h:75; TVirtualCollectionProxyDefines a common interface to inspect/change the contents of an object that represents a collection.Definition TVirtualCollectionProxy.h:52; TVirtualCollectionProxy::GetPropertiesvirtual Int_t GetProperties() constReturn miscallenous properties of the proxy (see TVirtualCollectionProxy::EProperty)Definition TVirtualCollectionProxy.h:108; TVirtualCollectionProxy::Sizeofvirtual UInt_t Sizeo",MatchSource.WIKI,doc/v632/TClass_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/TClass_8cxx_source.html
https://root.cern/doc/v632/TClass_8cxx_source.html:25440,Testability,assert,assert,25440,"82 line[kvalue+i] = 0;; 683 } else {; 684 line[kvalue] = 0;; 685 }; 686 } else {; 687 strncpy(&line[kvalue], membertype->AsString(p3pointer), TMath::Min(kline-1-kvalue,(int)strlen(membertype->AsString(p3pointer))));; 688 }; 689 } else if (!strcmp(memberFullTypeName, ""char*"") ||; 690 !strcmp(memberFullTypeName, ""const char*"")) {; 691 i = strlen(*ppointer);; 692 if (kvalue+i >= kline) i=kline-1-kvalue;; 693 Bool_t isPrintable = kTRUE;; 694 for (Int_t j = 0; j < i; j++) {; 695 if (!std::isprint((*ppointer)[j])) {; 696 isPrintable = kFALSE;; 697 break;; 698 }; 699 }; 700 if (isPrintable) {; 701 strncpy(line + kvalue, *ppointer, std::min( i, kline - kvalue));; 702 line[kvalue+i] = 0;; 703 } else {; 704 line[kvalue] = 0;; 705 }; 706 } else {; 707 if (!fNoAddr) {; 708 snprintf(&line[kvalue],kline-kvalue,""->%zx "", (size_t)p3pointer);; 709 }; 710 }; 711 } else if (membertype) {; 712 if (isdate) {; 713 cdatime = (UInt_t*)pointer;; 714 TDatime::GetDateTime(cdatime[0],cdate,ctime);; 715 snprintf(&line[kvalue],kline-kvalue,""%d/%d"",cdate,ctime);; 716 } else if (isbits) {; 717 snprintf(&line[kvalue],kline-kvalue,""0x%08x"", *(UInt_t*)pointer);; 718 } else {; 719 strncpy(&line[kvalue], membertype->AsString(pointer), TMath::Min(kline-1-kvalue,(int)strlen(membertype->AsString(pointer))));; 720 }; 721 } else {; 722 if (isStdString) {; 723 std::string *str = (std::string*)pointer;; 724 snprintf(&line[kvalue],kline-kvalue,""%s"",str->c_str());; 725 } else if (isTString) {; 726 TString *str = (TString*)pointer;; 727 snprintf(&line[kvalue],kline-kvalue,""%s"",str->Data());; 728 } else {; 729 if (!fNoAddr) {; 730 snprintf(&line[kvalue],kline-kvalue,""->%zx "", (size_t)pointer);; 731 }; 732 }; 733 }; 734 // Encode data member title; 735 if (isdate == kFALSE && strcmp(memberFullTypeName, ""char*"") && strcmp(memberFullTypeName, ""const char*"")) {; 736 i = strlen(&line[0]); line[i] = ' ';; 737 assert(250 > ktitle);; 738 strlcpy(&line[ktitle],memberTitle,250-ktitle+1); // strlcpy copy 'size-1' characters.",MatchSource.WIKI,doc/v632/TClass_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/TClass_8cxx_source.html
https://root.cern/doc/v632/TClass_8cxx_source.html:32887,Testability,assert,assert,32887,"//////; 918/// This method is called from ShowMembers() via AutoBrowse().; 919 ; 920void TAutoInspector::Inspect(TClass *cl, const char *tit, const char *name,; 921 const void *addr, Bool_t /* isTransient */); 922{; 923 if(tit && strchr(tit,'.')) return ;; 924 if (fCount && !fBrowser) return;; 925 ; 926 TString ts;; 927 ; 928 if (!cl) return;; 929 //if (*(cl->GetName()) == 'T') return;; 930 if (*name == '*') name++;; 931 int ln = strcspn(name,""[ "");; 932 TString iname(name,ln);; 933 ; 934 ClassInfo_t *classInfo = cl->GetClassInfo();; 935 if (!classInfo) return;; 936 ; 937 // Browse data members; 938 DataMemberInfo_t *m = gCling->DataMemberInfo_Factory(classInfo, TDictionary::EMemberSelection::kNoUsingDecls);; 939 TString mname;; 940 ; 941 int found=0;; 942 while (gCling->DataMemberInfo_Next(m)) { // MemberLoop; 943 mname = gCling->DataMemberInfo_Name(m);; 944 mname.ReplaceAll(""*"","""");; 945 if ((found = (iname==mname))) break;; 946 }; 947 assert(found);; 948 ; 949 // we skip: non static members and non objects; 950 // - the member G__virtualinfo inserted by the CINT RTTI system; 951 ; 952 //Long_t prop = m.Property() | m.Type()->Property();; 953 Long_t prop = gCling->DataMemberInfo_Property(m) | gCling->DataMemberInfo_TypeProperty(m);; 954 if (prop & kIsStatic) return;; 955 if (prop & kIsFundamental) return;; 956 if (prop & kIsEnum) return;; 957 if (mname == ""G__virtualinfo"") return;; 958 ; 959 int size = sizeof(void*);; 960 ; 961 int nmax = 1;; 962 if (prop & kIsArray) {; 963 for (int dim = 0; dim < gCling->DataMemberInfo_ArrayDim(m); dim++) nmax *= gCling->DataMemberInfo_MaxIndex(m,dim);; 964 }; 965 ; 966 std::string clmName(TClassEdit::ShortType(gCling->DataMemberInfo_TypeName(m),; 967 TClassEdit::kDropTrailStar) );; 968 TClass * clm = TClass::GetClass(clmName.c_str());; 969 R__ASSERT(clm);; 970 if (!(prop & kIsPointer)) {; 971 size = clm->Size();; 972 if (size==0) size = gCling->DataMemberInfo_TypeSize(m);; 973 }; 974 ; 975 ; 976 gCling->DataMemberInfo_Delete(m);;",MatchSource.WIKI,doc/v632/TClass_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/TClass_8cxx_source.html
https://root.cern/doc/v632/TClass_8cxx_source.html:93020,Testability,test,test,93020,"rAutoAdd);; 2448 copy->fStreamerFunc = fStreamerFunc;; 2449 copy->fConvStreamerFunc = fConvStreamerFunc;; 2450 if (fStreamer) {; 2451 copy->AdoptStreamer(fStreamer->Generate());; 2452 }; 2453 // If IsZombie is true, something went wrong and we will not be; 2454 // able to properly copy the collection proxy; 2455 if (fCollectionProxy && !copy->IsZombie()) {; 2456 copy->CopyCollectionProxy(*fCollectionProxy);; 2457 }; 2458 copy->SetClassSize(fSizeof);; 2459 if (fRefProxy) {; 2460 copy->AdoptReferenceProxy( fRefProxy->Clone() );; 2461 }; 2462 TClass::AddClass(const_cast<TClass*>(this));; 2463 return copy;; 2464}; 2465 ; 2466////////////////////////////////////////////////////////////////////////////////; 2467/// Replaces the collection proxy for this class. The provided object is cloned; 2468/// and the copy is then owned by `TClass`.; 2469 ; 2470void TClass::CopyCollectionProxy(const TVirtualCollectionProxy &orig); 2471{; 2472// // This code was used too quickly test the STL Emulation layer; 2473// Int_t k = TClassEdit::IsSTLCont(GetName());; 2474// if (k==1||k==-1) return;; 2475 ; 2476 delete fCollectionProxy;; 2477 fCollectionProxy = orig.Generate();; 2478}; 2479 ; 2480////////////////////////////////////////////////////////////////////////////////; 2481/// Draw detailed class inheritance structure.; 2482/// If a class B inherits from a class A, the description of B is drawn; 2483/// on the right side of the description of A.; 2484/// Member functions overridden by B are shown in class A with a blue line; 2485/// erasing the corresponding member function; 2486 ; 2487void TClass::Draw(Option_t *option); 2488{; 2489 if (!HasInterpreterInfo()) return;; 2490 ; 2491 TVirtualPad::TContext ctxt(kTRUE);; 2492 ; 2493 // Should we create a new canvas?; 2494 TString opt = option;; 2495 if (!ctxt.GetSaved() || !opt.Contains(""same"")) {; 2496 TVirtualPad *padclass = (TVirtualPad*)(gROOT->GetListOfCanvases())->FindObject(""R__class"");; 2497 if (!padclass) {; 2498 gROOT->ProcessLine",MatchSource.WIKI,doc/v632/TClass_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/TClass_8cxx_source.html
https://root.cern/doc/v632/TClass_8cxx_source.html:108197,Testability,assert,assert,108197,"= (ULongptr_t)lmap->GetValue(hash, (Longptr_t)cl, slot)) != 0) {; 2871 } else {; 2872 local = (ULongptr_t) new TClassLocalStorage();; 2873 lmap->AddAt(slot, hash, (Longptr_t)cl, local);; 2874 }; 2875 return (TClassLocalStorage*)local;; 2876 }; 2877 return nullptr;; 2878 }; 2879 };; 2880}; 2881 ; 2882////////////////////////////////////////////////////////////////////////////////; 2883/// Return the 'type' of the STL the TClass is representing.; 2884/// and return ROOT::kNotSTL if it is not representing an STL collection.; 2885 ; 2886ROOT::ESTLType TClass::GetCollectionType() const; 2887{; 2888 auto proxy = GetCollectionProxy();; 2889 if (proxy) return (ROOT::ESTLType)proxy->GetCollectionType();; 2890 return ROOT::kNotSTL;; 2891}; 2892 ; 2893 ; 2894////////////////////////////////////////////////////////////////////////////////; 2895/// Return the proxy describing the collection (if any).; 2896 ; 2897TVirtualCollectionProxy *TClass::GetCollectionProxy() const; 2898{; 2899 // Use assert, so that this line (slow because of the TClassEdit) is completely; 2900 // removed in optimized code.; 2901 //assert(TestBit(kLoading) || !TClassEdit::IsSTLCont(fName) || fCollectionProxy || 0 == ""The TClass for the STL collection has no collection proxy!"");; 2902 if (gThreadTsd && fCollectionProxy) {; 2903 TClassLocalStorage *local = TClassLocalStorage::GetStorage(this);; 2904 if (local == nullptr) return fCollectionProxy;; 2905 if (local->fCollectionProxy==nullptr) local->fCollectionProxy = fCollectionProxy->Generate();; 2906 return local->fCollectionProxy;; 2907 }; 2908 return fCollectionProxy;; 2909}; 2910 ; 2911////////////////////////////////////////////////////////////////////////////////; 2912/// Return the Streamer Class allowing streaming (if any).; 2913 ; 2914TClassStreamer *TClass::GetStreamer() const; 2915{; 2916 if (gThreadTsd && fStreamer) {; 2917 TClassLocalStorage *local = TClassLocalStorage::GetStorage(this);; 2918 if (local==nullptr) return fStreamer;; 2919 if (local-",MatchSource.WIKI,doc/v632/TClass_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/TClass_8cxx_source.html
https://root.cern/doc/v632/TClass_8cxx_source.html:108314,Testability,assert,assert,108314,"representing.; 2884/// and return ROOT::kNotSTL if it is not representing an STL collection.; 2885 ; 2886ROOT::ESTLType TClass::GetCollectionType() const; 2887{; 2888 auto proxy = GetCollectionProxy();; 2889 if (proxy) return (ROOT::ESTLType)proxy->GetCollectionType();; 2890 return ROOT::kNotSTL;; 2891}; 2892 ; 2893 ; 2894////////////////////////////////////////////////////////////////////////////////; 2895/// Return the proxy describing the collection (if any).; 2896 ; 2897TVirtualCollectionProxy *TClass::GetCollectionProxy() const; 2898{; 2899 // Use assert, so that this line (slow because of the TClassEdit) is completely; 2900 // removed in optimized code.; 2901 //assert(TestBit(kLoading) || !TClassEdit::IsSTLCont(fName) || fCollectionProxy || 0 == ""The TClass for the STL collection has no collection proxy!"");; 2902 if (gThreadTsd && fCollectionProxy) {; 2903 TClassLocalStorage *local = TClassLocalStorage::GetStorage(this);; 2904 if (local == nullptr) return fCollectionProxy;; 2905 if (local->fCollectionProxy==nullptr) local->fCollectionProxy = fCollectionProxy->Generate();; 2906 return local->fCollectionProxy;; 2907 }; 2908 return fCollectionProxy;; 2909}; 2910 ; 2911////////////////////////////////////////////////////////////////////////////////; 2912/// Return the Streamer Class allowing streaming (if any).; 2913 ; 2914TClassStreamer *TClass::GetStreamer() const; 2915{; 2916 if (gThreadTsd && fStreamer) {; 2917 TClassLocalStorage *local = TClassLocalStorage::GetStorage(this);; 2918 if (local==nullptr) return fStreamer;; 2919 if (local->fStreamer==nullptr) {; 2920 local->fStreamer = fStreamer->Generate();; 2921 const std::type_info &orig = ( typeid(*fStreamer) );; 2922 if (!local->fStreamer) {; 2923 Warning(""GetStreamer"",""For %s, the TClassStreamer (%s) passed's call to Generate failed!"",GetName(),orig.name());; 2924 } else {; 2925 const std::type_info &copy = ( typeid(*local->fStreamer) );; 2926 if (strcmp(orig.name(),copy.name())!=0) {; 2927 Warning(""GetStream",MatchSource.WIKI,doc/v632/TClass_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/TClass_8cxx_source.html
https://root.cern/doc/v632/TClass_8cxx_source.html:115683,Testability,assert,assertion,115683,"but if we do, let's just; 3046 // continue as before ...; 3047 }; 3048 ; 3049 std::string normalizedName;; 3050 Bool_t checkTable = kFALSE;; 3051 ; 3052 if (!cl) {; 3053 {; 3054 TInterpreter::SuspendAutoLoadingRAII autoloadOff(gInterpreter);; 3055 TClassEdit::GetNormalizedName(normalizedName, name);; 3056 }; 3057 // Try the normalized name.; 3058 if (normalizedName != name) {; 3059 cl = (TClass*)gROOT->GetListOfClasses()->FindObject(normalizedName.c_str());; 3060 ; 3061 if (cl) {; 3062 if (cl->IsLoaded() || cl->TestBit(kUnloading)) return cl;; 3063 ; 3064 //we may pass here in case of a dummy class created by TVirtualStreamerInfo; 3065 load = kTRUE;; 3066 }; 3067 checkTable = kTRUE;; 3068 }; 3069 } else {; 3070 normalizedName = cl->GetName(); // Use the fact that all TClass names are normalized.; 3071 checkTable = load && (normalizedName != name);; 3072 }; 3073 ; 3074 if (!load) return nullptr;; 3075 ; 3076// This assertion currently fails because of; 3077// TClass *c1 = TClass::GetClass(""basic_iostream<char,char_traits<char> >"");; 3078// TClass *c2 = TClass::GetClass(""std::iostream"");; 3079// where the TClassEdit normalized name of iostream is basic_iostream<char>; 3080// i.e missing the addition of the default parameter. This is because TClingLookupHelper; 3081// uses only 'part' of TMetaUtils::GetNormalizedName.; 3082 ; 3083// if (!cl) {; 3084// TDataType* dataType = (TDataType*)gROOT->GetListOfTypes()->FindObject(name);; 3085// TClass *altcl = dataType ? (TClass*)gROOT->GetListOfClasses()->FindObject(dataType->GetFullTypeName()) : 0;; 3086// if (altcl && normalizedName != altcl->GetName()); 3087// ::Fatal(""TClass::GetClass"",""The existing name (%s) for %s is different from the normalized name: %s\n"",; 3088// altcl->GetName(), name, normalizedName.c_str());; 3089// }; 3090 ; 3091 // We want to avoid auto-parsing due to intentionally missing dictionary for std::pair.; 3092 // However, we don't need this special treatement in rootcling (there is no auto-parsing); 30",MatchSource.WIKI,doc/v632/TClass_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/TClass_8cxx_source.html
https://root.cern/doc/v632/TClass_8cxx_source.html:123730,Testability,test,test,123730,"e default arguments as requested by the user); 3219 std::string alternative;; 3220 gInterpreter->GetInterpreterTypeName(normalizedName.c_str(), alternative, kTRUE);; 3221 if (alternative.empty()); 3222 return nullptr;; 3223 const char *altname = alternative.c_str();; 3224 if (strncmp(altname, ""std::"", 5) == 0) {; 3225 // For namespace (for example std::__1), GetInterpreterTypeName does; 3226 // not strip std::, so we must do it explicitly here.; 3227 altname += 5;; 3228 }; 3229 if (altname != normalizedName && strcmp(altname, name) != 0) {; 3230 // altname now contains the full name of the class including a possible; 3231 // namespace if there has been a using namespace statement.; 3232 ; 3233 // At least in the case C<string [2]> (normalized) vs C<string[2]> (altname); 3234 // the TClassEdit normalization and the TMetaUtils normalization leads to; 3235 // two different space layout. To avoid an infinite recursion, we also; 3236 // add the test on (altname != name); 3237 ; 3238 return GetClass(altname, load);; 3239 }; 3240 ; 3241 TClass *ncl = gInterpreter->GenerateTClass(normalizedName.c_str(), /* emulation = */ kFALSE, silent);; 3242 if (!ncl->IsZombie()) {; 3243 return ncl;; 3244 }; 3245 delete ncl;; 3246 }; 3247 }; 3248 return nullptr;; 3249}; 3250 ; 3251////////////////////////////////////////////////////////////////////////////////; 3252/// Return pointer to class with name.; 3253 ; 3254TClass *TClass::GetClass(const std::type_info& typeinfo, Bool_t load, Bool_t /* silent */, size_t hint_pair_offset, size_t hint_pair_size); 3255{; 3256 if (!gROOT->GetListOfClasses()); 3257 return nullptr;; 3258 ; 3259 //protect access to TROOT::GetIdMap; 3260 R__READ_LOCKGUARD(ROOT::gCoreMutex);; 3261 ; 3262 TClass* cl = GetIdMap()->Find(typeinfo.name());; 3263 ; 3264 if (cl && cl->IsLoaded()) return cl;; 3265 ; 3266 R__WRITE_LOCKGUARD(ROOT::gCoreMutex);; 3267 ; 3268 // Now that we got the write lock, another thread may have constructed the; 3269 // TClass while we were waitin",MatchSource.WIKI,doc/v632/TClass_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/TClass_8cxx_source.html
https://root.cern/doc/v632/TClass_8cxx_source.html:126046,Testability,test,test,126046,"n.; 3270 ; 3271 cl = GetIdMap()->Find(typeinfo.name());; 3272 ; 3273 if (cl) {; 3274 if (cl->IsLoaded()) return cl;; 3275 //we may pass here in case of a dummy class created by TVirtualStreamerInfo; 3276 load = kTRUE;; 3277 } else {; 3278 // Note we might need support for typedefs and simple types!; 3279 ; 3280 // TDataType *objType = GetType(name, load);; 3281 //if (objType) {; 3282 // const char *typdfName = objType->GetTypeName();; 3283 // if (typdfName && strcmp(typdfName, name)) {; 3284 // cl = GetClass(typdfName, load);; 3285 // return cl;; 3286 // }; 3287 // }; 3288 }; 3289 ; 3290 if (!load) return nullptr;; 3291 ; 3292 DictFuncPtr_t dict = TClassTable::GetDict(typeinfo);; 3293 if (dict) {; 3294 cl = (dict)();; 3295 if (cl) cl->PostLoadCheck();; 3296 return cl;; 3297 }; 3298 if (cl) return cl;; 3299 ; 3300 TIter next(gROOT->GetListOfClassGenerators());; 3301 TClassGenerator *gen;; 3302 while( (gen = (TClassGenerator*) next()) ) {; 3303 cl = gen->GetClass(typeinfo,load);; 3304 if (cl) {; 3305 cl->PostLoadCheck();; 3306 return cl;; 3307 }; 3308 }; 3309 ; 3310 // try AutoLoading the typeinfo; 3311 int autoload_old = gCling->SetClassAutoLoading(1);; 3312 if (!autoload_old) {; 3313 // Re-disable, we just meant to test; 3314 gCling->SetClassAutoLoading(0);; 3315 }; 3316 if (autoload_old && gInterpreter->AutoLoad(typeinfo,kTRUE)) {; 3317 // Disable autoload to avoid potential infinite recursion; 3318 TInterpreter::SuspendAutoLoadingRAII autoloadOff(gInterpreter);; 3319 cl = GetClass(typeinfo, load, hint_pair_offset, hint_pair_size);; 3320 if (cl) {; 3321 return cl;; 3322 }; 3323 }; 3324 ; 3325 if (hint_pair_offset) {; 3326 int err = 0;; 3327 char* demangled_name = TClassEdit::DemangleTypeIdName(typeinfo, err);; 3328 if (!err) {; 3329 cl = TClass::GetClass(demangled_name, load, kTRUE, hint_pair_offset, hint_pair_size);; 3330 free(demangled_name);; 3331 if (cl); 3332 return cl;; 3333 }; 3334 }; 3335 ; 3336 // last attempt. Look in the interpreter list of all (compiled+",MatchSource.WIKI,doc/v632/TClass_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/TClass_8cxx_source.html
https://root.cern/doc/v632/TClass_8cxx_source.html:138220,Testability,test,test,138220,"he list is the one containing the class, the; 3620/// others are the libraries the first one depends on. Returns 0; 3621/// in case the library is not found.; 3622 ; 3623const char *TClass::GetSharedLibs(); 3624{; 3625 if (!gInterpreter) return nullptr;; 3626 ; 3627 if (fSharedLibs.IsNull()); 3628 fSharedLibs = gInterpreter->GetClassSharedLibs(fName);; 3629 ; 3630 return !fSharedLibs.IsNull() ? fSharedLibs.Data() : nullptr;; 3631}; 3632 ; 3633////////////////////////////////////////////////////////////////////////////////; 3634/// Return list containing the TBaseClass(es) of a class.; 3635 ; 3636TList *TClass::GetListOfBases(); 3637{; 3638 if (!fBase.load()) {; 3639 if (fCanLoadClassInfo) {; 3640 if (fState == kHasTClassInit) {; 3641 ; 3642 R__LOCKGUARD(gInterpreterMutex);; 3643 if (!fHasRootPcmInfo) {; 3644 // The bases are in our ProtoClass; we don't need the class info.; 3645 TProtoClass *proto = TClassTable::GetProtoNorm(GetName());; 3646 if (proto && proto->FillTClass(this)); 3647 return fBase;; 3648 }; 3649 }; 3650 // We test again on fCanLoadClassInfo has another thread may have executed it.; 3651 if (!fHasRootPcmInfo && fCanLoadClassInfo) {; 3652 LoadClassInfo();; 3653 }; 3654 }; 3655 if (!fClassInfo); 3656 return nullptr;; 3657 ; 3658 if (!gInterpreter); 3659 Fatal(""GetListOfBases"", ""gInterpreter not initialized"");; 3660 ; 3661 R__LOCKGUARD(gInterpreterMutex);; 3662 if (!fBase.load()) {; 3663 gInterpreter->CreateListOfBaseClasses(this);; 3664 }; 3665 }; 3666 return fBase;; 3667}; 3668 ; 3669////////////////////////////////////////////////////////////////////////////////; 3670/// Return a list containing the TEnums of a class.; 3671///; 3672/// The list returned is safe to use from multiple thread without explicitly; 3673/// taking the ROOT global lock.; 3674///; 3675/// In the case the TClass represents a namespace, the returned list will; 3676/// implicit take the ROOT global lock upon any access (see TListOfEnumsWithLock); 3677///; 3678/// In the case the",MatchSource.WIKI,doc/v632/TClass_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/TClass_8cxx_source.html
https://root.cern/doc/v632/TClass_8cxx_source.html:184140,Testability,test,test,184140,"s kIgnoreTObjectStreamer bit is set, the automatically; 4824/// generated Streamer will not call TObject::Streamer.; 4825/// This option saves the TObject space overhead on the file.; 4826/// However, the information (fBits, fUniqueID) of TObject is lost.; 4827///; 4828/// Note that to be effective for objects streamed object-wise this function; 4829/// must be called for the class deriving directly from TObject, eg, assuming; 4830/// that BigTrack derives from Track and Track derives from TObject, one must do:; 4831/// ~~~ {.cpp}; 4832/// Track::Class()->IgnoreTObjectStreamer();; 4833/// ~~~; 4834/// and not:; 4835/// ~~~ {.cpp}; 4836/// BigTrack::Class()->IgnoreTObjectStreamer();; 4837/// ~~~; 4838/// To be effective for object streamed member-wise or split in a TTree,; 4839/// this function must be called for the most derived class (i.e. BigTrack).; 4840 ; 4841void TClass::IgnoreTObjectStreamer(Bool_t doIgnore); 4842{; 4843 // We need to tak the lock since we are test and then setting fBits; 4844 // and TStreamerInfo::fBits (and the StreamerInfo state in general); 4845 // which can also be modified by another thread.; 4846 R__LOCKGUARD(gInterpreterMutex);; 4847 ; 4848 if ( doIgnore && TestBit(kIgnoreTObjectStreamer)) return;; 4849 if (!doIgnore && !TestBit(kIgnoreTObjectStreamer)) return;; 4850 TVirtualStreamerInfo *sinfo = GetCurrentStreamerInfo();; 4851 if (sinfo) {; 4852 if (sinfo->IsCompiled()) {; 4853 // -- Warn the user that what they are doing cannot work.; 4854 // Note: The reason is that TVirtualStreamerInfo::Build() examines; 4855 // the kIgnoreTObjectStreamer bit and sets the TStreamerElement; 4856 // type for the TObject base class streamer element it creates; 4857 // to -1 as a flag. Later on the TStreamerInfo::Compile(); 4858 // member function sees the flag and does not insert the base; 4859 // class element into the compiled streamer info. None of this; 4860 // machinery works correctly if we are called after the streamer; 4861 // info has already",MatchSource.WIKI,doc/v632/TClass_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/TClass_8cxx_source.html
https://root.cern/doc/v632/TClass_8cxx_source.html:237460,Testability,test,test,237460,"->fStreamerImpl = &TClass::StreamerStreamerInfo;; 6146 }; 6147 }; 6148 ; 6149 if (fStreamer) {; 6150 kl->fStreamerType = kExternal;; 6151 kl->fStreamerImpl = &TClass::StreamerExternal;; 6152 }; 6153 ; 6154 if (const_cast<TClass *>(this)->GetClassMethodWithPrototype(""Hash"", """", kTRUE)) {; 6155 kl->SetBit(kHasLocalHashMember);; 6156 }; 6157 ; 6158 if (GetClassInfo()) {; 6159 // In the case where the TClass for one of ROOT's core class; 6160 // (eg TClonesArray for map<int,TClonesArray*>) is requested; 6161 // during the execution of rootcling, we could end up in a situation; 6162 // where we should have the information (since TClonesArray has; 6163 // a dictionary as part of libCore) but do not because the user; 6164 // only include a forward declaration of TClonesArray and we do not; 6165 // forcefully load the header file either (because the autoparsing; 6166 // is intentionally disabled).; 6167 kl->fClassProperty = gCling->ClassInfo_ClassProperty(fClassInfo);; 6168 // Must set this last since other threads may read fProperty; 6169 // and think all test bits have been properly set.; 6170 kl->fProperty = gCling->ClassInfo_Property(fClassInfo);; 6171 }; 6172 } else {; 6173 ; 6174 if (fStreamer) {; 6175 kl->fStreamerType = kExternal;; 6176 kl->fStreamerImpl = &TClass::StreamerExternal;; 6177 }; 6178 ; 6179 kl->fStreamerType |= kEmulatedStreamer;; 6180 kl->SetStreamerImpl();; 6181 // fProperty was *not* set so that it can be forced to be recalculated; 6182 // next time.; 6183 return 0;; 6184 }; 6185 ; 6186 return fProperty;; 6187}; 6188 ; 6189////////////////////////////////////////////////////////////////////////////////; 6190/// Internal routine to set calculate the class properties that can only be; 6191/// known at run-time, for example whether the Hash member function and the; 6192/// destructor are consistent.; 6193 ; 6194void TClass::SetRuntimeProperties(); 6195{; 6196 // For now, no need to lock this routines as fRuntimeProperties is; 6197 // the only atomic set",MatchSource.WIKI,doc/v632/TClass_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/TClass_8cxx_source.html
https://root.cern/doc/v632/TClass_8cxx_source.html:242207,Testability,test,test,242207,"lit = -1;; 6264}; 6265 ; 6266////////////////////////////////////////////////////////////////////////////////; 6267/// Change (i.e. set) the title of the TNamed.; 6268 ; 6269void TClass::SetContextMenuTitle(const char *title); 6270{; 6271 fContextMenuTitle = title;; 6272}; 6273 ; 6274////////////////////////////////////////////////////////////////////////////////; 6275/// This function installs a global IsA function for this class.; 6276/// The global IsA function will be used if there is no local IsA function (fIsA); 6277///; 6278/// A global IsA function has the signature:; 6279///; 6280/// ~~~ {.cpp}; 6281/// TClass *func( TClass *cl, const void *obj);; 6282/// ~~~; 6283///; 6284/// 'cl' is a pointer to the TClass object that corresponds to the; 6285/// 'pointer type' used to retrieve the value 'obj'; 6286///; 6287/// For example with:; 6288/// ~~~ {.cpp}; 6289/// TNamed * m = new TNamed(""example"",""test"");; 6290/// TObject* o = m; 6291/// ~~~; 6292/// and; 6293/// the global IsA function would be called with TObject::Class() as; 6294/// the first parameter and the exact numerical value in the pointer; 6295/// 'o'.; 6296///; 6297/// In other word, inside the global IsA function. it is safe to C-style; 6298/// cast the value of 'obj' into a pointer to the class described by 'cl'.; 6299 ; 6300void TClass::SetGlobalIsA(IsAGlobalFunc_t func); 6301{; 6302 fGlobalIsA = func;; 6303}; 6304 ; 6305////////////////////////////////////////////////////////////////////////////////; 6306/// Call this method to indicate that the shared library containing this; 6307/// class's code has been removed (unloaded) from the process's memory; 6308 ; 6309void TClass::SetUnloaded(); 6310{; 6311 if (TestBit(kUnloaded) && !TestBit(kUnloading)) {; 6312 // Don't redo the work.; 6313 return;; 6314 }; 6315 SetBit(kUnloading);; 6316 ; 6317 //R__ASSERT(fState == kLoaded);; 6318 if (fState != kLoaded) {; 6319 Fatal(""SetUnloaded"",""The TClass for %s is being unloaded when in state %d\n"",; 6320 GetNam",MatchSource.WIKI,doc/v632/TClass_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/TClass_8cxx_source.html
https://root.cern/doc/v632/TClass_8cxx_source.html:264810,Testability,test,test,264810,"supposed to be set properly (no longer pointing to the default).; 6883 if (pThis->fStreamerImpl.load() == &TClass::StreamerDefault) {; 6884 pThis->Fatal(""StreamerDefault"", ""fStreamerImpl not properly initialized (%d)"", pThis->fStreamerType);; 6885 } else {; 6886 (*pThis->fStreamerImpl)(pThis,object,b,onfile_class);; 6887 }; 6888}; 6889 ; 6890////////////////////////////////////////////////////////////////////////////////; 6891/// Adopt a TClassStreamer object. Ownership is transfered to this TClass; 6892/// object.; 6893 ; 6894void TClass::AdoptStreamer(TClassStreamer *str); 6895{; 6896// // This code can be used to quickly test the STL Emulation layer; 6897// Int_t k = TClassEdit::IsSTLCont(GetName());; 6898// if (k==1||k==-1) { delete str; return; }; 6899 ; 6900 R__LOCKGUARD(gInterpreterMutex);; 6901 ; 6902 if (fStreamer) delete fStreamer;; 6903 if (str) {; 6904 fStreamerType = kExternal | ( fStreamerType&kEmulatedStreamer );; 6905 fStreamer = str;; 6906 fStreamerImpl = &TClass::StreamerExternal;; 6907 } else if (fStreamer) {; 6908 // Case where there was a custom streamer and it is hereby removed,; 6909 // we need to reset fStreamerType; 6910 fStreamer = str;; 6911 fStreamerType = TClass::kDefault;; 6912 if (fProperty != -1) {; 6913 fProperty = -1;; 6914 Property();; 6915 }; 6916 }; 6917}; 6918 ; 6919////////////////////////////////////////////////////////////////////////////////; 6920/// Set a wrapper/accessor function around this class custom streamer.; 6921 ; 6922void TClass::SetStreamerFunc(ClassStreamerFunc_t strm); 6923{; 6924 R__LOCKGUARD(gInterpreterMutex);; 6925 if (fProperty != -1 && !fConvStreamerFunc &&; 6926 ( (fStreamerFunc == nullptr && strm != nullptr) || (fStreamerFunc != nullptr && strm == nullptr) ) ); 6927 {; 6928 fStreamerFunc = strm;; 6929 ; 6930 // Since initialization has already been done, make sure to tweak it; 6931 // for the new state.; 6932 if (HasInterpreterInfo() && fStreamerType != kTObject && !fStreamer) {; 6933 fStreamerType = kIn",MatchSource.WIKI,doc/v632/TClass_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/TClass_8cxx_source.html
https://root.cern/doc/v632/TClass_8cxx_source.html:282103,Testability,test,testHashRecursiveRemove,282103,"Info->At(slot);; 7325 fStreamerInfo->RemoveAt(fClassVersion);; 7326 if (fLastReadInfo.load() == info); 7327 fLastReadInfo = nullptr;; 7328 if (fCurrentInfo.load() == info); 7329 fCurrentInfo = nullptr;; 7330 delete info;; 7331 if (fState == kEmulated && fStreamerInfo->GetEntries() == 0) {; 7332 fState = kForwardDeclared;; 7333 }; 7334 }; 7335}; 7336 ; 7337////////////////////////////////////////////////////////////////////////////////; 7338/// Return true is the Hash/RecursiveRemove setup is consistent, i.e. when all; 7339/// classes in the class hierarchy that overload TObject::Hash do call; 7340/// ROOT::CallRecursiveRemoveIfNeeded in their destructor.; 7341/// i.e. it is safe to call the Hash virtual function during the RecursiveRemove operation.; 7342/// This routines is used for a small subset of the class for which we need; 7343/// the answer before gROOT is properly initialized.; 7344 ; 7345Bool_t ROOT::Internal::HasConsistentHashMember(const char *cname); 7346{; 7347 // Hand selection of correct classes, those classes should be; 7348 // cross-checked in testHashRecursiveRemove.cxx; 7349 static const char *handVerified[] = {; 7350 ""TEnvRec"", ""TDataType"", ""TObjArray"", ""TList"", ""THashList"",; 7351 ""TClass"", ""TCling"", ""TInterpreter"", ""TMethod"", ""ROOT::Internal::TCheckHashRecursiveRemoveConsistency"",; 7352 ""TCheckHashRecursiveRemoveConsistency"", ""TGWindow"",; 7353 ""TDirectory"", ""TDirectoryFile"", ""TObject"", ""TH1"",; 7354 ""TQClass"", ""TGlobal"" };; 7355 ; 7356 if (cname && cname[0]) {; 7357 for (auto cursor : handVerified) {; 7358 if (strcmp(cname, cursor) == 0); 7359 return true;; 7360 }; 7361 }; 7362 return false;; 7363}; 7364 ; 7365////////////////////////////////////////////////////////////////////////////////; 7366/// Return true is the Hash/RecursiveRemove setup is consistent, i.e. when all; 7367/// classes in the class hierarchy that overload TObject::Hash do call; 7368/// ROOT::CallRecursiveRemoveIfNeeded in their destructor.; 7369/// i.e. it is safe to call the",MatchSource.WIKI,doc/v632/TClass_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/TClass_8cxx_source.html
https://root.cern/doc/v632/TClass_8cxx_source.html:284147,Testability,test,testio,284147," 7375 ; 7376////////////////////////////////////////////////////////////////////////////////; 7377/// Return true if we have access to a constructor usable for I/O. This is; 7378/// typically the default constructor but can also be a constructor specifically; 7379/// marked for I/O (for example a constructor taking a TRootIOCtor* as an; 7380/// argument). In other words, if this routine returns true, TClass::New is; 7381/// guarantee to succeed.; 7382/// To know if the class described by this TClass has a default constructor; 7383/// (public or not), use; 7384/// \code{.cpp}; 7385/// cl->GetProperty() & kClassHasDefaultCtor; 7386/// \endcode; 7387/// To know if the class described by this TClass has a public default; 7388/// constructor use:; 7389/// \code{.cpp}; 7390/// gInterpreter->ClassInfo_HasDefaultConstructor(aClass->GetClassInfo());; 7391/// \endcode; 7392 ; 7393Bool_t TClass::HasDefaultConstructor(Bool_t testio) const; 7394{; 7395 ; 7396 if (fNew) return kTRUE;; 7397 ; 7398 if (HasInterpreterInfo()) {; 7399 R__LOCKGUARD(gInterpreterMutex);; 7400 return gCling->ClassInfo_HasDefaultConstructor(GetClassInfo(), testio);; 7401 }; 7402 if (fCollectionProxy) {; 7403 return kTRUE;; 7404 }; 7405 if (fCurrentInfo.load()) {; 7406 // Emulated class, we know how to construct them via the TStreamerInfo; 7407 return kTRUE;; 7408 }; 7409 return kFALSE;; 7410}; 7411 ; 7412////////////////////////////////////////////////////////////////////////////////; 7413/// Returns true if this class has an definition and/or overload of the; 7414/// member function Hash.; 7415///; 7416/// For example to test if the class overload TObject::Hash use; 7417/// ~~~ {.cpp}; 7418/// if (cl->IsTObject() && cl->HasLocalHashMember()); 7419/// ~~~; 7420 ; 7421Bool_t TClass::HasLocalHashMember() const; 7422{; 7423 if (fProperty == (-1)); 7424 Property();; 7425 return TestBit(kHasLocalHashMember);; 7426}; 7427 ; 7428////////////////////////////////////////////////////////////////////////////////; 742",MatchSource.WIKI,doc/v632/TClass_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/TClass_8cxx_source.html
https://root.cern/doc/v632/TClass_8cxx_source.html:284354,Testability,test,testio,284354," 7375 ; 7376////////////////////////////////////////////////////////////////////////////////; 7377/// Return true if we have access to a constructor usable for I/O. This is; 7378/// typically the default constructor but can also be a constructor specifically; 7379/// marked for I/O (for example a constructor taking a TRootIOCtor* as an; 7380/// argument). In other words, if this routine returns true, TClass::New is; 7381/// guarantee to succeed.; 7382/// To know if the class described by this TClass has a default constructor; 7383/// (public or not), use; 7384/// \code{.cpp}; 7385/// cl->GetProperty() & kClassHasDefaultCtor; 7386/// \endcode; 7387/// To know if the class described by this TClass has a public default; 7388/// constructor use:; 7389/// \code{.cpp}; 7390/// gInterpreter->ClassInfo_HasDefaultConstructor(aClass->GetClassInfo());; 7391/// \endcode; 7392 ; 7393Bool_t TClass::HasDefaultConstructor(Bool_t testio) const; 7394{; 7395 ; 7396 if (fNew) return kTRUE;; 7397 ; 7398 if (HasInterpreterInfo()) {; 7399 R__LOCKGUARD(gInterpreterMutex);; 7400 return gCling->ClassInfo_HasDefaultConstructor(GetClassInfo(), testio);; 7401 }; 7402 if (fCollectionProxy) {; 7403 return kTRUE;; 7404 }; 7405 if (fCurrentInfo.load()) {; 7406 // Emulated class, we know how to construct them via the TStreamerInfo; 7407 return kTRUE;; 7408 }; 7409 return kFALSE;; 7410}; 7411 ; 7412////////////////////////////////////////////////////////////////////////////////; 7413/// Returns true if this class has an definition and/or overload of the; 7414/// member function Hash.; 7415///; 7416/// For example to test if the class overload TObject::Hash use; 7417/// ~~~ {.cpp}; 7418/// if (cl->IsTObject() && cl->HasLocalHashMember()); 7419/// ~~~; 7420 ; 7421Bool_t TClass::HasLocalHashMember() const; 7422{; 7423 if (fProperty == (-1)); 7424 Property();; 7425 return TestBit(kHasLocalHashMember);; 7426}; 7427 ; 7428////////////////////////////////////////////////////////////////////////////////; 742",MatchSource.WIKI,doc/v632/TClass_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/TClass_8cxx_source.html
https://root.cern/doc/v632/TClass_8cxx_source.html:284829,Testability,test,test,284829,"faultCtor; 7386/// \endcode; 7387/// To know if the class described by this TClass has a public default; 7388/// constructor use:; 7389/// \code{.cpp}; 7390/// gInterpreter->ClassInfo_HasDefaultConstructor(aClass->GetClassInfo());; 7391/// \endcode; 7392 ; 7393Bool_t TClass::HasDefaultConstructor(Bool_t testio) const; 7394{; 7395 ; 7396 if (fNew) return kTRUE;; 7397 ; 7398 if (HasInterpreterInfo()) {; 7399 R__LOCKGUARD(gInterpreterMutex);; 7400 return gCling->ClassInfo_HasDefaultConstructor(GetClassInfo(), testio);; 7401 }; 7402 if (fCollectionProxy) {; 7403 return kTRUE;; 7404 }; 7405 if (fCurrentInfo.load()) {; 7406 // Emulated class, we know how to construct them via the TStreamerInfo; 7407 return kTRUE;; 7408 }; 7409 return kFALSE;; 7410}; 7411 ; 7412////////////////////////////////////////////////////////////////////////////////; 7413/// Returns true if this class has an definition and/or overload of the; 7414/// member function Hash.; 7415///; 7416/// For example to test if the class overload TObject::Hash use; 7417/// ~~~ {.cpp}; 7418/// if (cl->IsTObject() && cl->HasLocalHashMember()); 7419/// ~~~; 7420 ; 7421Bool_t TClass::HasLocalHashMember() const; 7422{; 7423 if (fProperty == (-1)); 7424 Property();; 7425 return TestBit(kHasLocalHashMember);; 7426}; 7427 ; 7428////////////////////////////////////////////////////////////////////////////////; 7429/// Return the wrapper around Merge.; 7430 ; 7431ROOT::MergeFunc_t TClass::GetMerge() const; 7432{; 7433 return fMerge;; 7434}; 7435 ; 7436////////////////////////////////////////////////////////////////////////////////; 7437/// Return the wrapper around Merge.; 7438 ; 7439ROOT::ResetAfterMergeFunc_t TClass::GetResetAfterMerge() const; 7440{; 7441 return fResetAfterMerge;; 7442}; 7443 ; 7444////////////////////////////////////////////////////////////////////////////////; 7445/// Return the wrapper around new ThisClass().; 7446 ; 7447ROOT::NewFunc_t TClass::GetNew() const; 7448{; 7449 return fNew;; 7450}; 7451 ; 74",MatchSource.WIKI,doc/v632/TClass_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/TClass_8cxx_source.html
https://root.cern/doc/v632/TClass_8cxx_source.html:335052,Testability,test,testio,335052,"alue of fStreamerType.Definition TClass.cxx:6215; TClass::GetSharedLibsconst char * GetSharedLibs()Get the list of shared libraries containing the code for class cls.Definition TClass.cxx:3623; TClass::CalculateStreamerOffsetvoid CalculateStreamerOffset() constCalculate the offset between an object of this class to its base class TObject.Definition TClass.cxx:2183; TClass::GetMissingDictionariesForPairElementsvoid GetMissingDictionariesForPairElements(TCollection &result, TCollection &visited, bool recurse)Definition TClass.cxx:3973; TClass::ReplaceWithvoid ReplaceWith(TClass *newcl) constDefinition TClass.cxx:4142; TClass::RegisterAddressInRepositoryvoid RegisterAddressInRepository(const char *where, void *location, const TClass *what) constDefinition TClass.cxx:290; TClass::PropertyLong_t Property() const overrideReturns the properties of the TClass as a bit field stored as a Long_t value.Definition TClass.cxx:6086; TClass::HasDefaultConstructorBool_t HasDefaultConstructor(Bool_t testio=kFALSE) constReturn true if we have access to a constructor usable for I/O.Definition TClass.cxx:7393; TClass::GetMenuItemsvoid GetMenuItems(TList *listitems)Returns list of methods accessible by context menu.Definition TClass.cxx:3874; TClass::SetNewvoid SetNew(ROOT::NewFunc_t newFunc)Install a new wrapper around 'new'.Definition TClass.cxx:6985; TClass::fIsAMethodstd::atomic< TMethodCall * > fIsAMethodDefinition TClass.h:231; TClass::ReadRulesstatic Int_t ReadRules()Read the class.rules files from the default location:.Definition TClass.cxx:1820; TClass::CanSplitBaseAllowBool_t CanSplitBaseAllow()Pointer to the function implementing streaming for this class.Definition TClass.cxx:2247; TClass::MoveAddressInRepositoryvoid MoveAddressInRepository(const char *where, void *oldadd, void *newadd, const TClass *what) constDefinition TClass.cxx:337; TClass::fStreamerImplstd::atomic< StreamerImpl_t > fStreamerImplDefinition TClass.h:287; TClass::SetContextMenuTitlevoid SetContextMenuTitle(c",MatchSource.WIKI,doc/v632/TClass_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/TClass_8cxx_source.html
https://root.cern/doc/v632/TClass_8cxx_source.html:125097,Usability,simpl,simple,125097,"n.; 3270 ; 3271 cl = GetIdMap()->Find(typeinfo.name());; 3272 ; 3273 if (cl) {; 3274 if (cl->IsLoaded()) return cl;; 3275 //we may pass here in case of a dummy class created by TVirtualStreamerInfo; 3276 load = kTRUE;; 3277 } else {; 3278 // Note we might need support for typedefs and simple types!; 3279 ; 3280 // TDataType *objType = GetType(name, load);; 3281 //if (objType) {; 3282 // const char *typdfName = objType->GetTypeName();; 3283 // if (typdfName && strcmp(typdfName, name)) {; 3284 // cl = GetClass(typdfName, load);; 3285 // return cl;; 3286 // }; 3287 // }; 3288 }; 3289 ; 3290 if (!load) return nullptr;; 3291 ; 3292 DictFuncPtr_t dict = TClassTable::GetDict(typeinfo);; 3293 if (dict) {; 3294 cl = (dict)();; 3295 if (cl) cl->PostLoadCheck();; 3296 return cl;; 3297 }; 3298 if (cl) return cl;; 3299 ; 3300 TIter next(gROOT->GetListOfClassGenerators());; 3301 TClassGenerator *gen;; 3302 while( (gen = (TClassGenerator*) next()) ) {; 3303 cl = gen->GetClass(typeinfo,load);; 3304 if (cl) {; 3305 cl->PostLoadCheck();; 3306 return cl;; 3307 }; 3308 }; 3309 ; 3310 // try AutoLoading the typeinfo; 3311 int autoload_old = gCling->SetClassAutoLoading(1);; 3312 if (!autoload_old) {; 3313 // Re-disable, we just meant to test; 3314 gCling->SetClassAutoLoading(0);; 3315 }; 3316 if (autoload_old && gInterpreter->AutoLoad(typeinfo,kTRUE)) {; 3317 // Disable autoload to avoid potential infinite recursion; 3318 TInterpreter::SuspendAutoLoadingRAII autoloadOff(gInterpreter);; 3319 cl = GetClass(typeinfo, load, hint_pair_offset, hint_pair_size);; 3320 if (cl) {; 3321 return cl;; 3322 }; 3323 }; 3324 ; 3325 if (hint_pair_offset) {; 3326 int err = 0;; 3327 char* demangled_name = TClassEdit::DemangleTypeIdName(typeinfo, err);; 3328 if (!err) {; 3329 cl = TClass::GetClass(demangled_name, load, kTRUE, hint_pair_offset, hint_pair_size);; 3330 free(demangled_name);; 3331 if (cl); 3332 return cl;; 3333 }; 3334 }; 3335 ; 3336 // last attempt. Look in the interpreter list of all (compiled+",MatchSource.WIKI,doc/v632/TClass_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/TClass_8cxx_source.html
https://root.cern/doc/v632/TClass_8cxx_source.html:132531,Usability,simpl,simple,132531,"a());; 3455 } else {; 3456 return (TDataMember *)((TClass*)this)->GetListOfDataMembers(kFALSE)->FindObject(start_name);; 3457 }; 3458}; 3459 ; 3460////////////////////////////////////////////////////////////////////////////////; 3461/// Return name of the file containing the declaration of this class.; 3462 ; 3463const char *TClass::GetDeclFileName() const; 3464{; 3465 if (fDeclFileName == kUndeterminedClassInfoName); 3466 return gInterpreter->ClassInfo_FileName( fClassInfo );; 3467 return fDeclFileName;; 3468}; 3469 ; 3470////////////////////////////////////////////////////////////////////////////////; 3471/// return offset for member name. name can be a data member in; 3472/// the class itself, one of its base classes, or one member in; 3473/// one of the aggregated classes.; 3474///; 3475/// In case of an emulated class, the list of emulated TRealData is built; 3476 ; 3477Longptr_t TClass::GetDataMemberOffset(const char *name) const; 3478{; 3479 TRealData *rd = GetRealData(name);; 3480 if (rd) return rd->GetThisOffset();; 3481 if (strchr(name,'[')==nullptr) {; 3482 // If this is a simple name there is a chance to find it in the; 3483 // StreamerInfo even if we did not find it in the RealData.; 3484 // For example an array name would be fArray[3] in RealData but; 3485 // just fArray in the streamerInfo.; 3486 TVirtualStreamerInfo *info = const_cast<TClass*>(this)->GetCurrentStreamerInfo();; 3487 if (info) {; 3488 return info->GetOffset(name);; 3489 }; 3490 }; 3491 return 0;; 3492}; 3493 ; 3494////////////////////////////////////////////////////////////////////////////////; 3495/// Return pointer to TRealData element with name ""name"".; 3496///; 3497/// Name can be a data member in the class itself,; 3498/// one of its base classes, or a member in; 3499/// one of the aggregated classes.; 3500///; 3501/// In case of an emulated class, the list of emulated TRealData is built.; 3502 ; 3503TRealData* TClass::GetRealData(const char* name) const; 3504{; 3505 if (!fRealData",MatchSource.WIKI,doc/v632/TClass_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/TClass_8cxx_source.html
https://root.cern/doc/v632/TClass_8cxx_source.html:134952,Usability,simpl,simple,134952,";; 3527 if (firstBracket != std::string::npos) {; 3528 // -- We are looking for an array data member.; 3529 std::string nameNoDim(givenName.substr(0, firstBracket));; 3530 TObjLink* lnk = fRealData->FirstLink();; 3531 while (lnk) {; 3532 TObject* obj = lnk->GetObject();; 3533 std::string objName(obj->GetName());; 3534 std::string::size_type pos = objName.find_first_of(""["");; 3535 // Only match arrays to arrays for now.; 3536 if (pos != std::string::npos) {; 3537 objName.erase(pos);; 3538 if (objName == nameNoDim) {; 3539 return static_cast<TRealData*>(obj);; 3540 }; 3541 }; 3542 lnk = lnk->Next();; 3543 }; 3544 }; 3545 ; 3546 // Now try it as a pointer.; 3547 std::ostringstream ptrname;; 3548 ptrname << ""*"" << givenName;; 3549 rd = (TRealData*) fRealData->FindObject(ptrname.str().c_str());; 3550 if (rd) {; 3551 return rd;; 3552 }; 3553 ; 3554 // Check for a dot in the name.; 3555 std::string::size_type firstDot = givenName.find_first_of(""."");; 3556 if (firstDot == std::string::npos) {; 3557 // -- Not found, a simple name, all done.; 3558 return nullptr;; 3559 }; 3560 ; 3561 //; 3562 // At this point the name has a dot in it, so it is the name; 3563 // of some contained sub-object.; 3564 //; 3565 ; 3566 // May be a pointer like in TH1: fXaxis.fLabels (in TRealdata is named fXaxis.*fLabels); 3567 std::string::size_type lastDot = givenName.find_last_of(""."");; 3568 std::ostringstream starname;; 3569 starname << givenName.substr(0, lastDot) << "".*"" << givenName.substr(lastDot + 1);; 3570 rd = (TRealData*) fRealData->FindObject(starname.str().c_str());; 3571 if (rd) {; 3572 return rd;; 3573 }; 3574 ; 3575 // Last attempt in case a member has been changed from; 3576 // a static array to a pointer, for example the member; 3577 // was arr[20] and is now *arr.; 3578 //; 3579 // Note: In principle, one could also take into account; 3580 // the opposite situation where a member like *arr has; 3581 // been converted to arr[20].; 3582 //; 3583 // FIXME: What about checking after ",MatchSource.WIKI,doc/v632/TClass_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/TClass_8cxx_source.html
https://root.cern/doc/v632/TClass_8cxx_source.html:251663,Usability,simpl,simply,251663,"// - kNoRange: return the checksum of data members and base classes, not including the ranges and array size found in comments.; 6535/// - kWithTypeDef: use the sugared type name in the calculation.; 6536///; 6537/// This is needed for backward compatibility.; 6538///; 6539/// WARNING: this function must be kept in sync with TStreamerInfo::GetCheckSum.; 6540/// They are both used to handle backward compatibility and should both return the same values.; 6541/// TStreamerInfo uses the information in TStreamerElement while TClass uses the information; 6542/// from TClass::GetListOfBases and TClass::GetListOfDataMembers.; 6543 ; 6544UInt_t TClass::GetCheckSum(ECheckSum code, Bool_t &isvalid) const; 6545{; 6546 // fCheckSum is an atomic variable. Also once it has; 6547 // transition from a zero Value it never changes. If two; 6548 // thread reach past this if statement and calculated the; 6549 // 'kLastestCheckSum', they will by definition obtain the; 6550 // same value, so technically we could simply have:; 6551 // if (fCheckSum && code == kCurrentCheckSum) return fCheckSum;; 6552 // However save a little bit of barrier time by calling load(); 6553 // only once.; 6554 ; 6555 isvalid = kTRUE;; 6556 ; 6557 UInt_t currentChecksum = fCheckSum.load();; 6558 if (currentChecksum && code == kCurrentCheckSum) return currentChecksum;; 6559 ; 6560 R__LOCKGUARD(gInterpreterMutex);; 6561 ; 6562 // kCurrentCheckSum (0) is the default parameter value and should be kept; 6563 // for backward compatibility, too be able to use the inequality checks,; 6564 // we need to set the code to the largest value.; 6565 if (code == kCurrentCheckSum) code = kLatestCheckSum;; 6566 ; 6567 UInt_t id = 0;; 6568 ; 6569 int il;; 6570 TString name = GetName();; 6571 TString type;; 6572 il = name.Length();; 6573 for (int i=0; i<il; i++) id = id*3+name[i];; 6574 ; 6575 // Here we skip he base classes in case this is a pair or STL collection,; 6576 // otherwise, on some STL implementations, it can happen that",MatchSource.WIKI,doc/v632/TClass_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/TClass_8cxx_source.html
https://root.cern/doc/v632/TClass_8cxx_source.html:283369,Usability,usab,usable,283369,"ethod"", ""ROOT::Internal::TCheckHashRecursiveRemoveConsistency"",; 7352 ""TCheckHashRecursiveRemoveConsistency"", ""TGWindow"",; 7353 ""TDirectory"", ""TDirectoryFile"", ""TObject"", ""TH1"",; 7354 ""TQClass"", ""TGlobal"" };; 7355 ; 7356 if (cname && cname[0]) {; 7357 for (auto cursor : handVerified) {; 7358 if (strcmp(cname, cursor) == 0); 7359 return true;; 7360 }; 7361 }; 7362 return false;; 7363}; 7364 ; 7365////////////////////////////////////////////////////////////////////////////////; 7366/// Return true is the Hash/RecursiveRemove setup is consistent, i.e. when all; 7367/// classes in the class hierarchy that overload TObject::Hash do call; 7368/// ROOT::CallRecursiveRemoveIfNeeded in their destructor.; 7369/// i.e. it is safe to call the Hash virtual function during the RecursiveRemove operation.; 7370 ; 7371Bool_t ROOT::Internal::HasConsistentHashMember(TClass &clRef); 7372{; 7373 return clRef.HasConsistentHashMember();; 7374}; 7375 ; 7376////////////////////////////////////////////////////////////////////////////////; 7377/// Return true if we have access to a constructor usable for I/O. This is; 7378/// typically the default constructor but can also be a constructor specifically; 7379/// marked for I/O (for example a constructor taking a TRootIOCtor* as an; 7380/// argument). In other words, if this routine returns true, TClass::New is; 7381/// guarantee to succeed.; 7382/// To know if the class described by this TClass has a default constructor; 7383/// (public or not), use; 7384/// \code{.cpp}; 7385/// cl->GetProperty() & kClassHasDefaultCtor; 7386/// \endcode; 7387/// To know if the class described by this TClass has a public default; 7388/// constructor use:; 7389/// \code{.cpp}; 7390/// gInterpreter->ClassInfo_HasDefaultConstructor(aClass->GetClassInfo());; 7391/// \endcode; 7392 ; 7393Bool_t TClass::HasDefaultConstructor(Bool_t testio) const; 7394{; 7395 ; 7396 if (fNew) return kTRUE;; 7397 ; 7398 if (HasInterpreterInfo()) {; 7399 R__LOCKGUARD(gInterpreterMutex);;",MatchSource.WIKI,doc/v632/TClass_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/TClass_8cxx_source.html
https://root.cern/doc/v632/TClass_8cxx_source.html:302475,Usability,simpl,simple,302475,"type &key) constDefinition TClass.cxx:390; ROOT::TMapTypeToTClass::size_typeIdMap_t::size_type size_typeDefinition TClass.cxx:373; ROOT::TMapTypeToTClass::mapped_typeIdMap_t::mapped_type mapped_typeDefinition TClass.cxx:378; ROOT::TMapTypeToTClass::const_iteratorIdMap_t::const_iterator const_iteratorDefinition TClass.cxx:372; ROOT::TMapTypeToTClass::IdMap_tstd::map< std::string, TClass * > IdMap_tDefinition TClass.cxx:370; ROOT::TMapTypeToTClass::key_typeIdMap_t::key_type key_typeDefinition TClass.cxx:371; ROOT::TMapTypeToTClass::Removevoid Remove(const key_type &key)Definition TClass.cxx:398; ROOT::TMapTypeToTClass::Addvoid Add(const key_type &key, mapped_type &obj)Definition TClass.cxx:385; ROOT::TSchemaRuleDefinition TSchemaRule.h:20; ROOT::TSchemaRule::SetFromRuleBool_t SetFromRule(const char *rule)Set the content fot this object from the rule See TClass::AddRule for details on the syntax.Definition TSchemaRule.cxx:321; ROOT::TSchemaRule::GetTargetStringconst char * GetTargetString() constGet the target data members of this rule as a simple string (i.e. the in memory data member).Definition TSchemaRule.cxx:512; ROOT::TSchemaRule::GetVersionconst char * GetVersion() constGet the version string.Definition TSchemaRule.cxx:393; ROOT::TSchemaRule::GetTargetClassconst char * GetTargetClass() constGet the targte class of this rule (i.e. the in memory class).Definition TSchemaRule.cxx:484; TArray::Classstatic TClass * Class(); TAutoInspectorDefinition TClass.cxx:901; TAutoInspector::fBrowserTBrowser * fBrowserDefinition TClass.cxx:904; TAutoInspector::IsTreatingNonAccessibleTypesBool_t IsTreatingNonAccessibleTypes() overrideDefinition TClass.cxx:914; TAutoInspector::TAutoInspectorTAutoInspector(TBrowser *b)Definition TClass.cxx:906; TAutoInspector::~TAutoInspectorvirtual ~TAutoInspector()Definition TClass.cxx:911; TAutoInspector::fCountInt_t fCountDefinition TClass.cxx:903; TAutoInspector::Inspectvoid Inspect(TClass *cl, const char *parent, const char *name, const void ",MatchSource.WIKI,doc/v632/TClass_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/TClass_8cxx_source.html
https://root.cern/doc/v632/TClass_8cxx_source.html:335119,Usability,usab,usable,335119,"alue of fStreamerType.Definition TClass.cxx:6215; TClass::GetSharedLibsconst char * GetSharedLibs()Get the list of shared libraries containing the code for class cls.Definition TClass.cxx:3623; TClass::CalculateStreamerOffsetvoid CalculateStreamerOffset() constCalculate the offset between an object of this class to its base class TObject.Definition TClass.cxx:2183; TClass::GetMissingDictionariesForPairElementsvoid GetMissingDictionariesForPairElements(TCollection &result, TCollection &visited, bool recurse)Definition TClass.cxx:3973; TClass::ReplaceWithvoid ReplaceWith(TClass *newcl) constDefinition TClass.cxx:4142; TClass::RegisterAddressInRepositoryvoid RegisterAddressInRepository(const char *where, void *location, const TClass *what) constDefinition TClass.cxx:290; TClass::PropertyLong_t Property() const overrideReturns the properties of the TClass as a bit field stored as a Long_t value.Definition TClass.cxx:6086; TClass::HasDefaultConstructorBool_t HasDefaultConstructor(Bool_t testio=kFALSE) constReturn true if we have access to a constructor usable for I/O.Definition TClass.cxx:7393; TClass::GetMenuItemsvoid GetMenuItems(TList *listitems)Returns list of methods accessible by context menu.Definition TClass.cxx:3874; TClass::SetNewvoid SetNew(ROOT::NewFunc_t newFunc)Install a new wrapper around 'new'.Definition TClass.cxx:6985; TClass::fIsAMethodstd::atomic< TMethodCall * > fIsAMethodDefinition TClass.h:231; TClass::ReadRulesstatic Int_t ReadRules()Read the class.rules files from the default location:.Definition TClass.cxx:1820; TClass::CanSplitBaseAllowBool_t CanSplitBaseAllow()Pointer to the function implementing streaming for this class.Definition TClass.cxx:2247; TClass::MoveAddressInRepositoryvoid MoveAddressInRepository(const char *where, void *oldadd, void *newadd, const TClass *what) constDefinition TClass.cxx:337; TClass::fStreamerImplstd::atomic< StreamerImpl_t > fStreamerImplDefinition TClass.h:287; TClass::SetContextMenuTitlevoid SetContextMenuTitle(c",MatchSource.WIKI,doc/v632/TClass_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/TClass_8cxx_source.html
https://root.cern/doc/v632/TClass_8h_source.html:11798,Availability,avail,available,11798,"_t> fCanSplit; //!Indicates whether this class can be split or not. Values are -1, 0, 1, 2; 246 ; 247 // Bit field; 248 /// Indicates whether this class represents a pair and was not created from a dictionary nor interpreter info but has; 249 /// compiler compatible offset and size (and all the info is in the StreamerInfo per se); 250 Bool_t fIsSyntheticPair : 1; //!; 251 ; 252 /// @brief The class has a Streamer method and it is implemented by the user or an older (not StreamerInfo based) automatic streamer.; 253 Bool_t fHasCustomStreamerMember : 1; //!; 254 ; 255 mutable std::atomic<Long_t> fProperty; //!Property See TClass::Property() for details; 256 mutable Long_t fClassProperty; //!C++ Property of the class (is abstract, has virtual table, etc.); 257 ; 258 // fHasRootPcmInfo needs to be atomic as long as GetListOfBases needs to modify it.; 259 std::atomic<Bool_t> fHasRootPcmInfo; //!Whether info was loaded from a root pcm.; 260 mutable std::atomic<Bool_t> fCanLoadClassInfo; //!Indicates whether the ClassInfo is supposed to be available.; 261 mutable std::atomic<Bool_t> fIsOffsetStreamerSet; //!saved remember if fOffsetStreamer has been set.; 262 mutable std::atomic<Bool_t> fVersionUsed; //!Indicates whether GetClassVersion has been called; 263 ; 264 enum class ERuntimeProperties : UChar_t {; 265 kNotInitialized = 0,; 266 kSet = BIT(0),; 267 // kInconsistent when kSet & !kConsistent.; 268 kConsistentHash = BIT(1); 269 };; 270 friend bool operator&(UChar_t l, ERuntimeProperties r) {; 271 return l & static_cast<UChar_t>(r);; 272 }; 273 mutable std::atomic<UChar_t> fRuntimeProperties; //! Properties that can only be evaluated at run-time; 274 ; 275 mutable Longptr_t fOffsetStreamer; //!saved info to call Streamer; 276 Int_t fStreamerType; //!cached of the streaming method to use; 277 EState fState; //!Current 'state' of the class (Emulated,Interpreted,Loaded); 278 mutable std::atomic<TVirtualStreamerInfo*> fCurrentInfo; //!cached current streamer info.; 279 mutabl",MatchSource.WIKI,doc/v632/TClass_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/TClass_8h_source.html
https://root.cern/doc/v632/TClass_8h_source.html:53738,Availability,avail,available,53738,"Bool_t HasNoInfoOrEmuOrFwdDeclaredDecl(const char *)Definition TClass.cxx:3398; TClass::fOVRMutexTVirtualMutex * fOVRMutexDefinition TClass.h:342; TClass::GetListOfEnumsTList * GetListOfEnums(Bool_t load=kTRUE)Return a list containing the TEnums of a class.Definition TClass.cxx:3686; TClass::IsStartingWithTObjectBool_t IsStartingWithTObject() constReturns true if this class inherits from TObject and if the start of the TObject parts is at the very...Definition TClass.cxx:5929; TClass::GetListOfMethodsTList * GetListOfMethods(Bool_t load=kTRUE)Return list containing the TMethods of a class.Definition TClass.cxx:3812; TClass::TClassTClass()Internal, default constructor.Definition TClass.cxx:1065; TClass::fDeclFileLineShort_t fDeclFileLineDefinition TClass.h:215; TClass::GetNmethodsInt_t GetNmethods()Return the number of methods of this class Note that in case the list of methods is not yet created,...Definition TClass.cxx:4573; TClass::fIsOffsetStreamerSetstd::atomic< Bool_t > fIsOffsetStreamerSetIndicates whether the ClassInfo is supposed to be available.Definition TClass.h:261; TClass::IgnoreTObjectStreamervoid IgnoreTObjectStreamer(Bool_t ignore=kTRUE)When the class kIgnoreTObjectStreamer bit is set, the automatically generated Streamer will not call ...Definition TClass.cxx:4841; TClass::GetStreamerTClassStreamer * GetStreamer() constReturn the Streamer Class allowing streaming (if any).Definition TClass.cxx:2914; TClass::GetIdMapstatic IdMap_t * GetIdMap()Definition TClass.cxx:469; TClass::GetInstanceCountUInt_t GetInstanceCount() constDefinition TClass.h:466; TClass::SetDeletevoid SetDelete(ROOT::DelFunc_t deleteFunc)Install a new wrapper around 'delete'.Definition TClass.cxx:7001; TClass::SetLastReadInfovoid SetLastReadInfo(TVirtualStreamerInfo *info)Definition TClass.h:445; TClass::AutoBrowsestatic Int_t AutoBrowse(TObject *obj, TBrowser *browser)Browse external object inherited from TObject.Definition TClass.cxx:1966; TClass::GetNewROOT::NewFunc_t GetNew() co",MatchSource.WIKI,doc/v632/TClass_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/TClass_8h_source.html
https://root.cern/doc/v632/TClass_8h_source.html:55596,Availability,avail,available,55596,"wser)Browse external object inherited from TObject.Definition TClass.cxx:1966; TClass::GetNewROOT::NewFunc_t GetNew() constReturn the wrapper around new ThisClass().Definition TClass.cxx:7447; TClass::GetBaseClassTClass * GetBaseClass(const char *classname)Return pointer to the base class ""classname"".Definition TClass.cxx:2655; TClass::GetDataMemberOffsetLongptr_t GetDataMemberOffset(const char *membername) constreturn offset for member name.Definition TClass.cxx:3477; TClass::GetNdataInt_t GetNdata()Return the number of data members of this class Note that in case the list of data members is not yet...Definition TClass.cxx:4554; TClass::SetDestructorvoid SetDestructor(ROOT::DesFunc_t destructorFunc)Install a new wrapper around the destructor.Definition TClass.cxx:7017; TClass::PostLoadCheckvirtual void PostLoadCheck()Do the initialization that can only be done after the CINT dictionary has been fully populated and ca...Definition TClass.cxx:5959; TClass::LoadClassInfovoid LoadClassInfo() constTry to load the ClassInfo if available.Definition TClass.cxx:5824; TClass::SetResetAfterMergevoid SetResetAfterMerge(ROOT::ResetAfterMergeFunc_t resetFunc)Install a new wrapper around 'ResetAfterMerge'.Definition TClass.cxx:6977; TClass::GetStreamerInfoImplTVirtualStreamerInfo * GetStreamerInfoImpl(Int_t version, Bool_t silent) constDefinition TClass.cxx:4634; TClass::MatchLegacyCheckSumBool_t MatchLegacyCheckSum(UInt_t checksum) constReturn true if the checksum passed as argument is one of the checksum value produced by the older che...Definition TClass.cxx:6494; TClass::fAllPubMethodTViewPubFunctions * fAllPubMethodDefinition TClass.h:210; TClass::ERuntimePropertiesERuntimePropertiesIndicates whether GetClassVersion has been called.Definition TClass.h:264; TClass::ERuntimeProperties::kSet@ kSet; TClass::ERuntimeProperties::kConsistentHash@ kConsistentHash; TClass::ERuntimeProperties::kNotInitialized@ kNotInitialized; TClass::HasInterpreterInfoBool_t HasInterpreterInfo() cons",MatchSource.WIKI,doc/v632/TClass_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/TClass_8h_source.html
https://root.cern/doc/v632/TClass_8h_source.html:6914,Deployability,update,updated,6914,"mesSet;; 170 mutable std::atomic_flag fSpinLock; // MSVC doesn't support = ATOMIC_FLAG_INIT;; 171 };; 172 ; 173 class InsertTClassInRegistryRAII {; 174 // Trivial RAII used to insert names in the registry; 175 TClass::EState& fState;; 176 const char* fName;; 177 TDeclNameRegistry& fNoInfoOrEmuOrFwdDeclNameRegistry;; 178 public:; 179 InsertTClassInRegistryRAII(TClass::EState &state, const char *name, TDeclNameRegistry &emuRegistry);; 180 ~InsertTClassInRegistryRAII();; 181 };; 182 ; 183 // TClass objects can be created as a result of opening a TFile (in which; 184 // they are in emulated mode) or as a result of loading the dictionary for; 185 // the corresponding class. When a dictionary is loaded any pre-existing; 186 // emulated TClass is replaced by the one created/coming from the dictionary.; 187 // To have a reference that always point to the 'current' TClass object for; 188 // a given class, one should use a TClassRef.; 189 // TClassRef works by holding on to the fPersistentRef which is updated; 190 // atomically whenever a TClass is replaced. During the replacement the; 191 // value of fPersistentRef is set to zero, leading the TClassRef to call; 192 // TClass::GetClass which is also locked by the replacement. At the end; 193 // of the replacement, fPersistentRef points to the new TClass object.; 194 std::atomic<TClass**> fPersistentRef;//!Persistent address of pointer to this TClass object and its successors.; 195 ; 196 typedef std::atomic<std::map<std::string, TObjArray*>*> ConvSIMap_t;; 197 ; 198 mutable TObjArray *fStreamerInfo; //Array of TVirtualStreamerInfo; 199 mutable ConvSIMap_t fConversionStreamerInfo; //Array of the streamer infos derived from another class.; 200 TList *fRealData; //linked list for persistent members including base classes; 201 std::atomic<TList*> fBase; //linked list for base classes; 202 std::atomic<TListOfDataMembers*> fData; //linked list for data members; non-owning.; 203 std::atomic<TListOfDataMembers*> fUsingData;//linked lis",MatchSource.WIKI,doc/v632/TClass_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/TClass_8h_source.html
https://root.cern/doc/v632/TClass_8h_source.html:61708,Deployability,install,installs,61708,"p< void *, Version_t > RepoCont_tDefinition TClass.h:343; TClass::StreamerTObjectEmulatedstatic void StreamerTObjectEmulated(const TClass *pThis, void *object, TBuffer &b, const TClass *onfile_class)Case of TObjects when we do not have the library defining the class.Definition TClass.cxx:6823; TClass::fNewROOT::NewFunc_t fNewDefinition TClass.h:235; TClass::kLoading@ kLoadingDefinition TClass.h:332; TClass::kUnloading@ kUnloadingDefinition TClass.h:332; TClass::GetResetAfterMergeROOT::ResetAfterMergeFunc_t GetResetAfterMerge() constReturn the wrapper around Merge.Definition TClass.cxx:7439; TClass::GetClassMethodWithPrototypeTMethod * GetClassMethodWithPrototype(const char *name, const char *proto, Bool_t objectIsConst=kFALSE, ROOT::EFunctionMatchMode mode=ROOT::kConversionMatch)Find the method with a given prototype.Definition TClass.cxx:4527; TClass::CanIgnoreTObjectStreamerBool_t CanIgnoreTObjectStreamer()Definition TClass.h:393; TClass::SetGlobalIsAvoid SetGlobalIsA(IsAGlobalFunc_t)This function installs a global IsA function for this class.Definition TClass.cxx:6300; TClass::GetMissingDictionariesForMembersvoid GetMissingDictionariesForMembers(TCollection &result, TCollection &visited, bool recurse)Verify the Data Members.Definition TClass.cxx:3944; TClass::fStreamerInfoTObjArray * fStreamerInfoDefinition TClass.h:198; TClass::GetSchemaRulesconst ROOT::Detail::TSchemaRuleSet * GetSchemaRules() constReturn the set of the schema rules if any.Definition TClass.cxx:1932; TClass::CloneTObject * Clone(const char *newname="""") const overrideCreate a Clone of this TClass object using a different name but using the same 'dictionary'.Definition TClass.cxx:2406; TClass::fCollectionProxyTVirtualCollectionProxy * fCollectionProxyDefinition TClass.h:220; TClass::IsCallingNewstatic ENewType IsCallingNew()Static method returning the defConstructor flag passed to TClass::New().Definition TClass.cxx:5902; TClass::GetListOfBasesTList * GetListOfBases()Return list containing the TBa",MatchSource.WIKI,doc/v632/TClass_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/TClass_8h_source.html
https://root.cern/doc/v632/TClass_8h_source.html:85390,Deployability,update,update,85390,"dd_tvoid(* DirAutoAdd_t)(void *, TDirectory *)Definition Rtypes.h:114; ROOT::ResetAfterMergeFunc_tvoid(* ResetAfterMergeFunc_t)(void *, TFileMergeInfo *)Definition Rtypes.h:116; ROOT::DesFunc_tvoid(* DesFunc_t)(void *)Definition Rtypes.h:113; ROOT::GetClassTClass * GetClass(T *)Definition TClass.h:663; ROOT::CreateClassTClass * CreateClass(const char *cname, Version_t id, const std::type_info &info, TVirtualIsAProxy *isa, const char *dfil, const char *ifil, Int_t dl, Int_t il)Global function called by a class' static Dictionary() method (see the ClassDef macro).Definition TClass.cxx:5869; ROOT::DelFunc_tvoid(* DelFunc_t)(void *)Definition Rtypes.h:111; ROOT::ESTLTypeESTLTypeDefinition ESTLType.h:28; ROOT::NewArrFunc_tvoid *(* NewArrFunc_t)(Long_t size, void *arena)Definition Rtypes.h:110; ROOT::EFunctionMatchModeEFunctionMatchModeDefinition TDictionary.h:161; ROOT::kConversionMatch@ kConversionMatchDefinition TDictionary.h:163; ROOT::ResetClassVersionvoid ResetClassVersion(TClass *, const char *, Short_t)Global function to update the version number.Definition TClassTable.cxx:951; ROOT::DelArrFunc_tvoid(* DelArrFunc_t)(void *)Definition Rtypes.h:112; ROOT::NewFunc_tvoid *(* NewFunc_t)(void *)Definition Rtypes.h:109; ROOT::MergeFunc_tLong64_t(* MergeFunc_t)(void *, TCollection *, TFileMergeInfo *)Definition Rtypes.h:115; whatstatic const char * whatDefinition stlLoader.cc:5; ROOT::Internal::TClassGetClassHelperDefinition TClass.h:630; ROOT::Internal::TClassGetClassHelper::GetClassstatic TClass * GetClass(Bool_t load, Bool_t silent)Definition TClass.h:631; TClass::ObjectPtrDefinition TClass.h:140; TClass::ObjectPtr::fPtrvoid * fPtrDefinition TClass.h:141; TClass::ObjectPtr::GetAllocatorTVirtualStreamerInfo * GetAllocator() constDefinition TClass.h:149; TClass::ObjectPtr::GetPtrvoid * GetPtr() constDefinition TClass.h:147; TClass::ObjectPtr::fAllocatorTVirtualStreamerInfo * fAllocatorDefinition TClass.h:143; TClass::ObjectPtr::ObjectPtrObjectPtr(void *ptr=nullptr, TVirt",MatchSource.WIKI,doc/v632/TClass_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/TClass_8h_source.html
https://root.cern/doc/v632/TClass_8h_source.html:4683,Energy Efficiency,allocate,allocated,4683,"5.34.18 (has no typedef at all); 115 kNoRangeCheck = 6, // Up to v5.34.18 and v5.99/06; 116 kNoBaseCheckSum = 7, // Up to v5.34.18 and v5.99/06; 117 kLatestCheckSum = 8; 118 };; 119 ; 120 // Describe the current state of the TClass itself.; 121 enum EState {; 122 kNoInfo, // The state has not yet been initialized, i.e. the TClass; 123 // was just created and/or there is no trace of it in the interpreter.; 124 kForwardDeclared, // The interpreted knows the entity is a class but that's it.; 125 kEmulated, // The information about the class only comes from a TStreamerInfo; 126 kInterpreted, // The class is described completely/only in the interpreter database.; 127 kHasTClassInit, // The class has a TClass proper bootstrap coming from a run; 128 // through rootcling/genreflex/TMetaUtils and the library; 129 // containing this dictionary has been loaded in memory.; 130 kLoaded = kHasTClassInit,; 131 kNamespaceForMeta // Very transient state necessary to bootstrap namespace entries; 132 // in ROOT Meta w/o interpreter information; 133 };; 134 ; 135 // ""Typed"" pointer that recalls how TClass::New allocated the object.; 136 // It is returned by TClass:NewObject and should be passed to TClass::DeleteArray or TClass::Destructor; 137 // to delete the object.; 138 // It is also used in TVirtualCollectionProxy for the same reasons.; 139 struct ObjectPtr; 140 {; 141 void *fPtr = nullptr;; 142 ; 143 TVirtualStreamerInfo *fAllocator = nullptr;; 144 ; 145 ObjectPtr(void *ptr = nullptr, TVirtualStreamerInfo *allocator = nullptr) : fPtr(ptr), fAllocator(allocator) {}; 146 ; 147 void *GetPtr() const { return fPtr; }; 148 ; 149 TVirtualStreamerInfo *GetAllocator() const { return fAllocator; }; 150 ; 151 operator bool() const { return fPtr != nullptr; }; 152 };; 153 ; 154private:; 155 ; 156 ; 157 ; 158 class TDeclNameRegistry {; 159 // A class which is used to collect decl names starting from normalised; 160 // names (typedef resolution is excluded here, just string manipulation; 161 // ",MatchSource.WIKI,doc/v632/TClass_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/TClass_8h_source.html
https://root.cern/doc/v632/TClass_8h_source.html:42832,Energy Efficiency,allocate,allocated,42832,"st char *datamember) constReturn pointer to datamember object with name ""datamember"".Definition TClass.cxx:3439; TClass::fIsATVirtualIsAProxy * fIsADefinition TClass.h:229; TClass::GetListOfUsingDataMembersTList * GetListOfUsingDataMembers(Bool_t load=kTRUE)Return list containing the TDataMembers of using declarations of a class.Definition TClass.cxx:3786; TClass::ForceReloadvoid ForceReload(TClass *oldcl)we found at least one equivalent.Definition TClass.cxx:1336; TClass::fDeleteArrayROOT::DelArrFunc_t fDeleteArrayDefinition TClass.h:238; TClass::CanSplitBool_t CanSplit() constReturn true if the data member of this TClass can be saved separately.Definition TClass.cxx:2319; TClass::fStreamerTClassStreamer * fStreamerDefinition TClass.h:226; TClass::SetDirectoryAutoAddvoid SetDirectoryAutoAdd(ROOT::DirAutoAdd_t dirAutoAddFunc)Install a new wrapper around the directory auto add function.Definition TClass.cxx:7028; TClass::NewArrayvoid * NewArray(Long_t nElements, ENewType defConstructor=kClassNew) constReturn a pointer to a newly allocated array of objects of this class.Definition TClass.cxx:5193; TClass::fNoInfoOrEmuOrFwdDeclNameRegistrystatic TDeclNameRegistry fNoInfoOrEmuOrFwdDeclNameRegistryDefinition TClass.h:328; TClass::TGenericClassInfofriend class ROOT::TGenericClassInfoDefinition TClass.h:85; TClass::fFuncTemplateTListOfFunctionTemplates * fFuncTemplateDefinition TClass.h:206; TClass::fStreamerFuncClassStreamerFunc_t fStreamerFuncDefinition TClass.h:241; TClass::AdoptReferenceProxyvoid AdoptReferenceProxy(TVirtualRefProxy *proxy)Adopt the Reference proxy pointer to indicate that this class represents a reference.Definition TClass.cxx:6685; TClass::GetClassMethodTMethod * GetClassMethod(Longptr_t faddr)Look for a method in this class that has the interface function address faddr.Definition TClass.cxx:4483; TClass::DetermineCurrentStreamerInfoTVirtualStreamerInfo * DetermineCurrentStreamerInfo()Determine and set pointer to current TVirtualStreamerInfo.Definitio",MatchSource.WIKI,doc/v632/TClass_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/TClass_8h_source.html
https://root.cern/doc/v632/TClass_8h_source.html:45604,Energy Efficiency,allocate,allocated,45604,"stom streamer (member function).Definition TClass.cxx:2939; TClass::RemoveStreamerInfovoid RemoveStreamerInfo(Int_t slot)Remove and delete the StreamerInfo in the given slot.Definition TClass.cxx:7320; TClass::SetCanSplitvoid SetCanSplit(Int_t splitmode)Set the splitability of this class:Definition TClass.cxx:5658; TClass::AddInstancevoid AddInstance(Bool_t heap=kFALSE)Definition TClass.h:381; TClass::CreateListOfDataMembersTList * CreateListOfDataMembers(std::atomic< TListOfDataMembers * > &data, TDictionary::EMemberSelection selection, bool load)Create the list containing the TDataMembers (of actual data members or members pulled in through usin...Definition TClass.cxx:3741; TClass::GetStreamerInfoAbstractEmulatedTVirtualStreamerInfo * GetStreamerInfoAbstractEmulated(Int_t version=0) constFor the case where the requestor class is emulated and this class is abstract, returns a pointer to t...Definition TClass.cxx:4709; TClass::Newvoid * New(ENewType defConstructor=kClassNew, Bool_t quiet=kFALSE) constReturn a pointer to a newly allocated object of this class.Definition TClass.cxx:4978; TClass::SetMergevoid SetMerge(ROOT::MergeFunc_t mergeFunc)Install a new wrapper around 'Merge'.Definition TClass.cxx:6969; TClass::fConversionStreamerInfoConvSIMap_t fConversionStreamerInfoDefinition TClass.h:199; TClass::fDirAutoAddROOT::DirAutoAdd_t fDirAutoAddDefinition TClass.h:240; TClass::HasDataMemberInfoBool_t HasDataMemberInfo() constDefinition TClass.h:407; TClass::fRefProxyTVirtualRefProxy * fRefProxycached streamer info used in the last read.Definition TClass.h:280; TClass::GetMenuListTList * GetMenuList() constReturn the list of menu items associated with the class.Definition TClass.cxx:4341; TClass::fMergeROOT::MergeFunc_t fMergesaved info to call a IsA member functionDefinition TClass.h:233; TClass::GetMethodTMethod * GetMethod(const char *method, const char *params, Bool_t objectIsConst=kFALSE)Find the best method (if there is one) matching the parameters.Definition T",MatchSource.WIKI,doc/v632/TClass_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/TClass_8h_source.html
https://root.cern/doc/v632/TClass_8h_source.html:68455,Energy Efficiency,allocate,allocated,68455,"tCheckSumDefinition TClass.h:117; TClass::kNoRange@ kNoRangeDefinition TClass.h:112; TClass::kCurrentCheckSum@ kCurrentCheckSumDefinition TClass.h:109; TClass::kNoBaseCheckSum@ kNoBaseCheckSumDefinition TClass.h:116; TClass::kReflex@ kReflexDefinition TClass.h:114; TClass::kReflexNoComment@ kReflexNoCommentDefinition TClass.h:111; TClass::kWithTypeDef@ kWithTypeDefDefinition TClass.h:113; TClass::kNoRangeCheck@ kNoRangeCheckDefinition TClass.h:115; TClass::kNoEnum@ kNoEnumDefinition TClass.h:110; TClass::Dumpvoid Dump() const overrideDump contents of object on stdout.Definition TClass.h:398; TClass::InheritsFromBool_t InheritsFrom(const char *cl) const overrideReturn kTRUE if this class inherits from a class with name ""classname"".Definition TClass.cxx:4874; TClass::GetBaseClassOffsetInt_t GetBaseClassOffset(const TClass *toBase, void *address=nullptr, bool isDerivedObject=true)Definition TClass.cxx:2791; TClass::NewObjectArrayObjectPtr NewObjectArray(Long_t nElements, ENewType defConstructor=kClassNew) constReturn a pointer to a newly allocated array of objects of this class.Definition TClass.cxx:5209; TClass::GetCollectionProxyTVirtualCollectionProxy * GetCollectionProxy() constReturn the proxy describing the collection (if any).Definition TClass.cxx:2897; TClass::ResetCachesvoid ResetCaches()To clean out all caches.Definition TClass.cxx:4215; TClass::fVersionUsedstd::atomic< Bool_t > fVersionUsedsaved remember if fOffsetStreamer has been set.Definition TClass.h:262; TClass::GetClassSizeInt_t GetClassSize() constDefinition TClass.h:425; TClass::ClassPropertyLong_t ClassProperty() constReturn the C++ property of this class, eg.Definition TClass.cxx:2396; TClass::SetStreamerImplvoid SetStreamerImpl()Internal routine to set fStreamerImpl based on the value of fStreamerType.Definition TClass.cxx:6215; TClass::GetSharedLibsconst char * GetSharedLibs()Get the list of shared libraries containing the code for class cls.Definition TClass.cxx:3623; TClass::CalculateStreamerO",MatchSource.WIKI,doc/v632/TClass_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/TClass_8h_source.html
https://root.cern/doc/v632/TClass_8h_source.html:9003,Integrability,interface,interface,9003,.; 200 TList *fRealData; //linked list for persistent members including base classes; 201 std::atomic<TList*> fBase; //linked list for base classes; 202 std::atomic<TListOfDataMembers*> fData; //linked list for data members; non-owning.; 203 std::atomic<TListOfDataMembers*> fUsingData;//linked list for data members pulled in through using decls.; 204 ; 205 std::atomic<TListOfEnums*> fEnums; //linked list for the enums; 206 TListOfFunctionTemplates *fFuncTemplate; //linked list for function templates [Not public until implemented as active list]; 207 std::atomic<TListOfFunctions*> fMethod; //linked list for methods; 208 ; 209 TViewPubDataMembers*fAllPubData; //all public data members (including from base classes); 210 TViewPubFunctions *fAllPubMethod; //all public methods (including from base classes); 211 mutable TList *fClassMenuList; //list of class menu items; 212 ; 213 const char *fDeclFileName; //name of class declaration file; 214 const char *fImplFileName; //name of class implementation file; 215 Short_t fDeclFileLine; //line of class declaration; 216 Short_t fImplFileLine; //line of class implementation; 217 UInt_t fInstanceCount; //number of instances of this class; 218 UInt_t fOnHeap; //number of instances on heap; 219 mutable std::atomic<UInt_t> fCheckSum; //checksum of data members and base classes; 220 TVirtualCollectionProxy *fCollectionProxy; //Collection interface; 221 Version_t fClassVersion; //Class version Identifier; 222 ClassInfo_t *fClassInfo; //pointer to CINT class info class; 223 TString fContextMenuTitle;//context menu title; 224 const std::type_info *fTypeInfo; //pointer to the C++ type information.; 225 ShowMembersFunc_t fShowMembers; //pointer to the class's ShowMembers function; 226 TClassStreamer *fStreamer; //pointer to streamer function; 227 TString fSharedLibs; //shared libraries containing class code; 228 ; 229 TVirtualIsAProxy *fIsA; //!pointer to the class's IsA proxy.; 230 IsAGlobalFunc_t fGlobalIsA; //pointer to a global IsA fu,MatchSource.WIKI,doc/v632/TClass_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/TClass_8h_source.html
https://root.cern/doc/v632/TClass_8h_source.html:42639,Integrability,wrap,wrapper,42639,"onfile_class=nullptr) constDefinition TClass.h:607; TClass::fShowMembersShowMembersFunc_t fShowMembersDefinition TClass.h:225; TClass::GetDataMemberTDataMember * GetDataMember(const char *datamember) constReturn pointer to datamember object with name ""datamember"".Definition TClass.cxx:3439; TClass::fIsATVirtualIsAProxy * fIsADefinition TClass.h:229; TClass::GetListOfUsingDataMembersTList * GetListOfUsingDataMembers(Bool_t load=kTRUE)Return list containing the TDataMembers of using declarations of a class.Definition TClass.cxx:3786; TClass::ForceReloadvoid ForceReload(TClass *oldcl)we found at least one equivalent.Definition TClass.cxx:1336; TClass::fDeleteArrayROOT::DelArrFunc_t fDeleteArrayDefinition TClass.h:238; TClass::CanSplitBool_t CanSplit() constReturn true if the data member of this TClass can be saved separately.Definition TClass.cxx:2319; TClass::fStreamerTClassStreamer * fStreamerDefinition TClass.h:226; TClass::SetDirectoryAutoAddvoid SetDirectoryAutoAdd(ROOT::DirAutoAdd_t dirAutoAddFunc)Install a new wrapper around the directory auto add function.Definition TClass.cxx:7028; TClass::NewArrayvoid * NewArray(Long_t nElements, ENewType defConstructor=kClassNew) constReturn a pointer to a newly allocated array of objects of this class.Definition TClass.cxx:5193; TClass::fNoInfoOrEmuOrFwdDeclNameRegistrystatic TDeclNameRegistry fNoInfoOrEmuOrFwdDeclNameRegistryDefinition TClass.h:328; TClass::TGenericClassInfofriend class ROOT::TGenericClassInfoDefinition TClass.h:85; TClass::fFuncTemplateTListOfFunctionTemplates * fFuncTemplateDefinition TClass.h:206; TClass::fStreamerFuncClassStreamerFunc_t fStreamerFuncDefinition TClass.h:241; TClass::AdoptReferenceProxyvoid AdoptReferenceProxy(TVirtualRefProxy *proxy)Adopt the Reference proxy pointer to indicate that this class represents a reference.Definition TClass.cxx:6685; TClass::GetClassMethodTMethod * GetClassMethod(Longptr_t faddr)Look for a method in this class that has the interface function address faddr.Defi",MatchSource.WIKI,doc/v632/TClass_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/TClass_8h_source.html
https://root.cern/doc/v632/TClass_8h_source.html:43572,Integrability,interface,interface,43572,"ss.h:226; TClass::SetDirectoryAutoAddvoid SetDirectoryAutoAdd(ROOT::DirAutoAdd_t dirAutoAddFunc)Install a new wrapper around the directory auto add function.Definition TClass.cxx:7028; TClass::NewArrayvoid * NewArray(Long_t nElements, ENewType defConstructor=kClassNew) constReturn a pointer to a newly allocated array of objects of this class.Definition TClass.cxx:5193; TClass::fNoInfoOrEmuOrFwdDeclNameRegistrystatic TDeclNameRegistry fNoInfoOrEmuOrFwdDeclNameRegistryDefinition TClass.h:328; TClass::TGenericClassInfofriend class ROOT::TGenericClassInfoDefinition TClass.h:85; TClass::fFuncTemplateTListOfFunctionTemplates * fFuncTemplateDefinition TClass.h:206; TClass::fStreamerFuncClassStreamerFunc_t fStreamerFuncDefinition TClass.h:241; TClass::AdoptReferenceProxyvoid AdoptReferenceProxy(TVirtualRefProxy *proxy)Adopt the Reference proxy pointer to indicate that this class represents a reference.Definition TClass.cxx:6685; TClass::GetClassMethodTMethod * GetClassMethod(Longptr_t faddr)Look for a method in this class that has the interface function address faddr.Definition TClass.cxx:4483; TClass::DetermineCurrentStreamerInfoTVirtualStreamerInfo * DetermineCurrentStreamerInfo()Determine and set pointer to current TVirtualStreamerInfo.Definition TClass.cxx:5684; TClass::Browsevoid Browse(TBrowser *b) overrideThis method is called by a browser to get the class information.Definition TClass.cxx:2010; TClass::GetStateEState GetState() constDefinition TClass.h:488; TClass::GetCollectionTypeROOT::ESTLType GetCollectionType() constReturn the 'type' of the STL the TClass is representing.Definition TClass.cxx:2886; TClass::AdoptMemberStreamervoid AdoptMemberStreamer(const char *name, TMemberStreamer *strm)Adopt the TMemberStreamer pointer to by p and use it to Stream non basic member name.Definition TClass.cxx:6703; TClass::ResetInstanceCountvoid ResetInstanceCount()Definition TClass.h:547; TClass::GetStreamerFuncClassStreamerFunc_t GetStreamerFunc() constGet a wrapper/accessor ",MatchSource.WIKI,doc/v632/TClass_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/TClass_8h_source.html
https://root.cern/doc/v632/TClass_8h_source.html:44513,Integrability,wrap,wrapper,44513,"ongptr_t faddr)Look for a method in this class that has the interface function address faddr.Definition TClass.cxx:4483; TClass::DetermineCurrentStreamerInfoTVirtualStreamerInfo * DetermineCurrentStreamerInfo()Determine and set pointer to current TVirtualStreamerInfo.Definition TClass.cxx:5684; TClass::Browsevoid Browse(TBrowser *b) overrideThis method is called by a browser to get the class information.Definition TClass.cxx:2010; TClass::GetStateEState GetState() constDefinition TClass.h:488; TClass::GetCollectionTypeROOT::ESTLType GetCollectionType() constReturn the 'type' of the STL the TClass is representing.Definition TClass.cxx:2886; TClass::AdoptMemberStreamervoid AdoptMemberStreamer(const char *name, TMemberStreamer *strm)Adopt the TMemberStreamer pointer to by p and use it to Stream non basic member name.Definition TClass.cxx:6703; TClass::ResetInstanceCountvoid ResetInstanceCount()Definition TClass.h:547; TClass::GetStreamerFuncClassStreamerFunc_t GetStreamerFunc() constGet a wrapper/accessor function around this class custom streamer (member function).Definition TClass.cxx:2939; TClass::RemoveStreamerInfovoid RemoveStreamerInfo(Int_t slot)Remove and delete the StreamerInfo in the given slot.Definition TClass.cxx:7320; TClass::SetCanSplitvoid SetCanSplit(Int_t splitmode)Set the splitability of this class:Definition TClass.cxx:5658; TClass::AddInstancevoid AddInstance(Bool_t heap=kFALSE)Definition TClass.h:381; TClass::CreateListOfDataMembersTList * CreateListOfDataMembers(std::atomic< TListOfDataMembers * > &data, TDictionary::EMemberSelection selection, bool load)Create the list containing the TDataMembers (of actual data members or members pulled in through usin...Definition TClass.cxx:3741; TClass::GetStreamerInfoAbstractEmulatedTVirtualStreamerInfo * GetStreamerInfoAbstractEmulated(Int_t version=0) constFor the case where the requestor class is emulated and this class is abstract, returns a pointer to t...Definition TClass.cxx:4709; TClass::Newvoid * Ne",MatchSource.WIKI,doc/v632/TClass_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/TClass_8h_source.html
https://root.cern/doc/v632/TClass_8h_source.html:45735,Integrability,wrap,wrapper,45735,"eamerInfo in the given slot.Definition TClass.cxx:7320; TClass::SetCanSplitvoid SetCanSplit(Int_t splitmode)Set the splitability of this class:Definition TClass.cxx:5658; TClass::AddInstancevoid AddInstance(Bool_t heap=kFALSE)Definition TClass.h:381; TClass::CreateListOfDataMembersTList * CreateListOfDataMembers(std::atomic< TListOfDataMembers * > &data, TDictionary::EMemberSelection selection, bool load)Create the list containing the TDataMembers (of actual data members or members pulled in through usin...Definition TClass.cxx:3741; TClass::GetStreamerInfoAbstractEmulatedTVirtualStreamerInfo * GetStreamerInfoAbstractEmulated(Int_t version=0) constFor the case where the requestor class is emulated and this class is abstract, returns a pointer to t...Definition TClass.cxx:4709; TClass::Newvoid * New(ENewType defConstructor=kClassNew, Bool_t quiet=kFALSE) constReturn a pointer to a newly allocated object of this class.Definition TClass.cxx:4978; TClass::SetMergevoid SetMerge(ROOT::MergeFunc_t mergeFunc)Install a new wrapper around 'Merge'.Definition TClass.cxx:6969; TClass::fConversionStreamerInfoConvSIMap_t fConversionStreamerInfoDefinition TClass.h:199; TClass::fDirAutoAddROOT::DirAutoAdd_t fDirAutoAddDefinition TClass.h:240; TClass::HasDataMemberInfoBool_t HasDataMemberInfo() constDefinition TClass.h:407; TClass::fRefProxyTVirtualRefProxy * fRefProxycached streamer info used in the last read.Definition TClass.h:280; TClass::GetMenuListTList * GetMenuList() constReturn the list of menu items associated with the class.Definition TClass.cxx:4341; TClass::fMergeROOT::MergeFunc_t fMergesaved info to call a IsA member functionDefinition TClass.h:233; TClass::GetMethodTMethod * GetMethod(const char *method, const char *params, Bool_t objectIsConst=kFALSE)Find the best method (if there is one) matching the parameters.Definition TClass.cxx:4411; TClass::Loadstatic TClass * Load(TBuffer &b)Load class description from I/O buffer and return class object.Definition TClass.cxx:57",MatchSource.WIKI,doc/v632/TClass_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/TClass_8h_source.html
https://root.cern/doc/v632/TClass_8h_source.html:46868,Integrability,wrap,wrapper,46868,"merInfoDefinition TClass.h:199; TClass::fDirAutoAddROOT::DirAutoAdd_t fDirAutoAddDefinition TClass.h:240; TClass::HasDataMemberInfoBool_t HasDataMemberInfo() constDefinition TClass.h:407; TClass::fRefProxyTVirtualRefProxy * fRefProxycached streamer info used in the last read.Definition TClass.h:280; TClass::GetMenuListTList * GetMenuList() constReturn the list of menu items associated with the class.Definition TClass.cxx:4341; TClass::fMergeROOT::MergeFunc_t fMergesaved info to call a IsA member functionDefinition TClass.h:233; TClass::GetMethodTMethod * GetMethod(const char *method, const char *params, Bool_t objectIsConst=kFALSE)Find the best method (if there is one) matching the parameters.Definition TClass.cxx:4411; TClass::Loadstatic TClass * Load(TBuffer &b)Load class description from I/O buffer and return class object.Definition TClass.cxx:5715; TClass::fStateEState fStatecached of the streaming method to useDefinition TClass.h:277; TClass::GetDestructorROOT::DesFunc_t GetDestructor() constReturn the wrapper around the destructor.Definition TClass.cxx:7479; TClass::GetMethodWithPrototypeTMethod * GetMethodWithPrototype(const char *method, const char *proto, Bool_t objectIsConst=kFALSE, ROOT::EFunctionMatchMode mode=ROOT::kConversionMatch)Find the method with a given prototype.Definition TClass.cxx:4456; TClass::CopyCollectionProxyvoid CopyCollectionProxy(const TVirtualCollectionProxy &)Replaces the collection proxy for this class.Definition TClass.cxx:2470; TClass::fStreamerTypeInt_t fStreamerTypesaved info to call StreamerDefinition TClass.h:276; TClass::fRealDataTList * fRealDataDefinition TClass.h:200; TClass::fOnHeapUInt_t fOnHeapDefinition TClass.h:218; TClass::lsvoid ls(Option_t *opt="""") const overrideThe ls function lists the contents of a class on stdout.Definition TClass.cxx:4258; TClass::fBasestd::atomic< TList * > fBaseDefinition TClass.h:201; TClass::fCanSplitstd::atomic< Char_t > fCanSplitDefinition TClass.h:245; TClass::HasDictionaryBool_t HasDi",MatchSource.WIKI,doc/v632/TClass_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/TClass_8h_source.html
https://root.cern/doc/v632/TClass_8h_source.html:50615,Integrability,wrap,wrapper,50615,"finition TClass.cxx:3798; TClass::DynamicCastvoid * DynamicCast(const TClass *base, void *obj, Bool_t up=kTRUE)Cast obj of this class type up to baseclass cl if up is true.Definition TClass.cxx:4915; TClass::fImplFileNameconst char * fImplFileNameDefinition TClass.h:214; TClass::RegisterStreamerInfovoid RegisterStreamerInfo(TVirtualStreamerInfo *info)Register the StreamerInfo in the given slot, change the State of the TClass as appropriate.Definition TClass.cxx:7296; TClass::operator=TClass & operator=(const TClass &)=delete; TClass::fCheckSumstd::atomic< UInt_t > fCheckSumDefinition TClass.h:219; TClass::UnregisterAddressInRepositoryvoid UnregisterAddressInRepository(const char *where, void *location, const TClass *what) constDefinition TClass.cxx:318; TClass::fMethodstd::atomic< TListOfFunctions * > fMethodDefinition TClass.h:207; TClass::RemoveClassDeclIdstatic void RemoveClassDeclId(TDictionary::DeclId_t id)Definition TClass.cxx:536; TClass::SetNewArrayvoid SetNewArray(ROOT::NewArrFunc_t newArrayFunc)Install a new wrapper around 'new []'.Definition TClass.cxx:6993; TClass::CallShowMembersBool_t CallShowMembers(const void *obj, TMemberInspector &insp, Bool_t isTransient=kFALSE) constCall ShowMembers() on the obj of this class type, passing insp and parent.Definition TClass.cxx:2205; TClass::fDeclFileNameconst char * fDeclFileNameDefinition TClass.h:213; TClass::SetCollectionProxyvoid SetCollectionProxy(const ROOT::Detail::TCollectionProxyInfo &)Create the collection proxy object (and the streamer object) from using the information in the TColle...Definition TClass.cxx:6244; TClass::HasDictionarySelectionstatic Bool_t HasDictionarySelection(const char *clname)Check whether a class has a dictionary or ROOT can load one.Definition TClass.cxx:3917; TClass::AdoptSchemaRulesvoid AdoptSchemaRules(ROOT::Detail::TSchemaRuleSet *rules)Adopt a new set of Data Model Evolution rules.Definition TClass.cxx:1920; TClass::StreamerInstrumentedstatic void StreamerInstrumented(const ",MatchSource.WIKI,doc/v632/TClass_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/TClass_8h_source.html
https://root.cern/doc/v632/TClass_8h_source.html:52217,Integrability,wrap,wrapper,52217,"sDictionarySelectionstatic Bool_t HasDictionarySelection(const char *clname)Check whether a class has a dictionary or ROOT can load one.Definition TClass.cxx:3917; TClass::AdoptSchemaRulesvoid AdoptSchemaRules(ROOT::Detail::TSchemaRuleSet *rules)Adopt a new set of Data Model Evolution rules.Definition TClass.cxx:1920; TClass::StreamerInstrumentedstatic void StreamerInstrumented(const TClass *pThis, void *object, TBuffer &b, const TClass *onfile_class)Case of instrumented class with a library.Definition TClass.cxx:6836; TClass::SetStreamerInfoTVirtualStreamerInfo * SetStreamerInfo(Int_t version, const char *info="""")Info is a string describing the names and types of attributes written by the class Streamer function.Definition TClass.cxx:6373; TClass::fgClassCountstatic std::atomic< Int_t > fgClassCountDefinition TClass.h:326; TClass::GetCurrentStreamerInfoTVirtualStreamerInfo * GetCurrentStreamerInfo()Definition TClass.h:439; TClass::GetDirectoryAutoAddROOT::DirAutoAdd_t GetDirectoryAutoAdd() constReturn the wrapper around the directory auto add function.Definition TClass.cxx:7487; TClass::AddImplFilevoid AddImplFile(const char *filename, int line)Definition TClass.cxx:1952; TClass::GetListOfMethodOverloadsTCollection * GetListOfMethodOverloads(const char *name) constReturn the collection of functions named ""name"".Definition TClass.cxx:3827; TClass::fEnumsstd::atomic< TListOfEnums * > fEnumsDefinition TClass.h:205; TClass::HasNoInfoOrEmuOrFwdDeclaredDeclstatic Bool_t HasNoInfoOrEmuOrFwdDeclaredDecl(const char *)Definition TClass.cxx:3398; TClass::fOVRMutexTVirtualMutex * fOVRMutexDefinition TClass.h:342; TClass::GetListOfEnumsTList * GetListOfEnums(Bool_t load=kTRUE)Return a list containing the TEnums of a class.Definition TClass.cxx:3686; TClass::IsStartingWithTObjectBool_t IsStartingWithTObject() constReturns true if this class inherits from TObject and if the start of the TObject parts is at the very...Definition TClass.cxx:5929; TClass::GetListOfMethodsTList * Get",MatchSource.WIKI,doc/v632/TClass_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/TClass_8h_source.html
https://root.cern/doc/v632/TClass_8h_source.html:54341,Integrability,wrap,wrapper,54341,"assTClass()Internal, default constructor.Definition TClass.cxx:1065; TClass::fDeclFileLineShort_t fDeclFileLineDefinition TClass.h:215; TClass::GetNmethodsInt_t GetNmethods()Return the number of methods of this class Note that in case the list of methods is not yet created,...Definition TClass.cxx:4573; TClass::fIsOffsetStreamerSetstd::atomic< Bool_t > fIsOffsetStreamerSetIndicates whether the ClassInfo is supposed to be available.Definition TClass.h:261; TClass::IgnoreTObjectStreamervoid IgnoreTObjectStreamer(Bool_t ignore=kTRUE)When the class kIgnoreTObjectStreamer bit is set, the automatically generated Streamer will not call ...Definition TClass.cxx:4841; TClass::GetStreamerTClassStreamer * GetStreamer() constReturn the Streamer Class allowing streaming (if any).Definition TClass.cxx:2914; TClass::GetIdMapstatic IdMap_t * GetIdMap()Definition TClass.cxx:469; TClass::GetInstanceCountUInt_t GetInstanceCount() constDefinition TClass.h:466; TClass::SetDeletevoid SetDelete(ROOT::DelFunc_t deleteFunc)Install a new wrapper around 'delete'.Definition TClass.cxx:7001; TClass::SetLastReadInfovoid SetLastReadInfo(TVirtualStreamerInfo *info)Definition TClass.h:445; TClass::AutoBrowsestatic Int_t AutoBrowse(TObject *obj, TBrowser *browser)Browse external object inherited from TObject.Definition TClass.cxx:1966; TClass::GetNewROOT::NewFunc_t GetNew() constReturn the wrapper around new ThisClass().Definition TClass.cxx:7447; TClass::GetBaseClassTClass * GetBaseClass(const char *classname)Return pointer to the base class ""classname"".Definition TClass.cxx:2655; TClass::GetDataMemberOffsetLongptr_t GetDataMemberOffset(const char *membername) constreturn offset for member name.Definition TClass.cxx:3477; TClass::GetNdataInt_t GetNdata()Return the number of data members of this class Note that in case the list of data members is not yet...Definition TClass.cxx:4554; TClass::SetDestructorvoid SetDestructor(ROOT::DesFunc_t destructorFunc)Install a new wrapper around the destructor.De",MatchSource.WIKI,doc/v632/TClass_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/TClass_8h_source.html
https://root.cern/doc/v632/TClass_8h_source.html:54692,Integrability,wrap,wrapper,54692,"etStreamerSetIndicates whether the ClassInfo is supposed to be available.Definition TClass.h:261; TClass::IgnoreTObjectStreamervoid IgnoreTObjectStreamer(Bool_t ignore=kTRUE)When the class kIgnoreTObjectStreamer bit is set, the automatically generated Streamer will not call ...Definition TClass.cxx:4841; TClass::GetStreamerTClassStreamer * GetStreamer() constReturn the Streamer Class allowing streaming (if any).Definition TClass.cxx:2914; TClass::GetIdMapstatic IdMap_t * GetIdMap()Definition TClass.cxx:469; TClass::GetInstanceCountUInt_t GetInstanceCount() constDefinition TClass.h:466; TClass::SetDeletevoid SetDelete(ROOT::DelFunc_t deleteFunc)Install a new wrapper around 'delete'.Definition TClass.cxx:7001; TClass::SetLastReadInfovoid SetLastReadInfo(TVirtualStreamerInfo *info)Definition TClass.h:445; TClass::AutoBrowsestatic Int_t AutoBrowse(TObject *obj, TBrowser *browser)Browse external object inherited from TObject.Definition TClass.cxx:1966; TClass::GetNewROOT::NewFunc_t GetNew() constReturn the wrapper around new ThisClass().Definition TClass.cxx:7447; TClass::GetBaseClassTClass * GetBaseClass(const char *classname)Return pointer to the base class ""classname"".Definition TClass.cxx:2655; TClass::GetDataMemberOffsetLongptr_t GetDataMemberOffset(const char *membername) constreturn offset for member name.Definition TClass.cxx:3477; TClass::GetNdataInt_t GetNdata()Return the number of data members of this class Note that in case the list of data members is not yet...Definition TClass.cxx:4554; TClass::SetDestructorvoid SetDestructor(ROOT::DesFunc_t destructorFunc)Install a new wrapper around the destructor.Definition TClass.cxx:7017; TClass::PostLoadCheckvirtual void PostLoadCheck()Do the initialization that can only be done after the CINT dictionary has been fully populated and ca...Definition TClass.cxx:5959; TClass::LoadClassInfovoid LoadClassInfo() constTry to load the ClassInfo if available.Definition TClass.cxx:5824; TClass::SetResetAfterMergevoid SetResetAf",MatchSource.WIKI,doc/v632/TClass_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/TClass_8h_source.html
https://root.cern/doc/v632/TClass_8h_source.html:55281,Integrability,wrap,wrapper,55281,"ition TClass.h:466; TClass::SetDeletevoid SetDelete(ROOT::DelFunc_t deleteFunc)Install a new wrapper around 'delete'.Definition TClass.cxx:7001; TClass::SetLastReadInfovoid SetLastReadInfo(TVirtualStreamerInfo *info)Definition TClass.h:445; TClass::AutoBrowsestatic Int_t AutoBrowse(TObject *obj, TBrowser *browser)Browse external object inherited from TObject.Definition TClass.cxx:1966; TClass::GetNewROOT::NewFunc_t GetNew() constReturn the wrapper around new ThisClass().Definition TClass.cxx:7447; TClass::GetBaseClassTClass * GetBaseClass(const char *classname)Return pointer to the base class ""classname"".Definition TClass.cxx:2655; TClass::GetDataMemberOffsetLongptr_t GetDataMemberOffset(const char *membername) constreturn offset for member name.Definition TClass.cxx:3477; TClass::GetNdataInt_t GetNdata()Return the number of data members of this class Note that in case the list of data members is not yet...Definition TClass.cxx:4554; TClass::SetDestructorvoid SetDestructor(ROOT::DesFunc_t destructorFunc)Install a new wrapper around the destructor.Definition TClass.cxx:7017; TClass::PostLoadCheckvirtual void PostLoadCheck()Do the initialization that can only be done after the CINT dictionary has been fully populated and ca...Definition TClass.cxx:5959; TClass::LoadClassInfovoid LoadClassInfo() constTry to load the ClassInfo if available.Definition TClass.cxx:5824; TClass::SetResetAfterMergevoid SetResetAfterMerge(ROOT::ResetAfterMergeFunc_t resetFunc)Install a new wrapper around 'ResetAfterMerge'.Definition TClass.cxx:6977; TClass::GetStreamerInfoImplTVirtualStreamerInfo * GetStreamerInfoImpl(Int_t version, Bool_t silent) constDefinition TClass.cxx:4634; TClass::MatchLegacyCheckSumBool_t MatchLegacyCheckSum(UInt_t checksum) constReturn true if the checksum passed as argument is one of the checksum value produced by the older che...Definition TClass.cxx:6494; TClass::fAllPubMethodTViewPubFunctions * fAllPubMethodDefinition TClass.h:210; TClass::ERuntimePropertiesERunti",MatchSource.WIKI,doc/v632/TClass_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/TClass_8h_source.html
https://root.cern/doc/v632/TClass_8h_source.html:55736,Integrability,wrap,wrapper,55736,"per around new ThisClass().Definition TClass.cxx:7447; TClass::GetBaseClassTClass * GetBaseClass(const char *classname)Return pointer to the base class ""classname"".Definition TClass.cxx:2655; TClass::GetDataMemberOffsetLongptr_t GetDataMemberOffset(const char *membername) constreturn offset for member name.Definition TClass.cxx:3477; TClass::GetNdataInt_t GetNdata()Return the number of data members of this class Note that in case the list of data members is not yet...Definition TClass.cxx:4554; TClass::SetDestructorvoid SetDestructor(ROOT::DesFunc_t destructorFunc)Install a new wrapper around the destructor.Definition TClass.cxx:7017; TClass::PostLoadCheckvirtual void PostLoadCheck()Do the initialization that can only be done after the CINT dictionary has been fully populated and ca...Definition TClass.cxx:5959; TClass::LoadClassInfovoid LoadClassInfo() constTry to load the ClassInfo if available.Definition TClass.cxx:5824; TClass::SetResetAfterMergevoid SetResetAfterMerge(ROOT::ResetAfterMergeFunc_t resetFunc)Install a new wrapper around 'ResetAfterMerge'.Definition TClass.cxx:6977; TClass::GetStreamerInfoImplTVirtualStreamerInfo * GetStreamerInfoImpl(Int_t version, Bool_t silent) constDefinition TClass.cxx:4634; TClass::MatchLegacyCheckSumBool_t MatchLegacyCheckSum(UInt_t checksum) constReturn true if the checksum passed as argument is one of the checksum value produced by the older che...Definition TClass.cxx:6494; TClass::fAllPubMethodTViewPubFunctions * fAllPubMethodDefinition TClass.h:210; TClass::ERuntimePropertiesERuntimePropertiesIndicates whether GetClassVersion has been called.Definition TClass.h:264; TClass::ERuntimeProperties::kSet@ kSet; TClass::ERuntimeProperties::kConsistentHash@ kConsistentHash; TClass::ERuntimeProperties::kNotInitialized@ kNotInitialized; TClass::HasInterpreterInfoBool_t HasInterpreterInfo() constDefinition TClass.h:410; TClass::AddClassstatic void AddClass(TClass *cl)static: Add a class to the list and map of classes.Definition TCl",MatchSource.WIKI,doc/v632/TClass_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/TClass_8h_source.html
https://root.cern/doc/v632/TClass_8h_source.html:57730,Integrability,wrap,wrapper,57730,"494; TClass::GetMissingDictionariesForBaseClassesvoid GetMissingDictionariesForBaseClasses(TCollection &result, TCollection &visited, bool recurse)Verify the base classes always.Definition TClass.cxx:3927; TClass::fSchemaRulesROOT::Detail::TSchemaRuleSet * fSchemaRulesPointer to reference proxy if this class represents a reference.Definition TClass.h:281; TClass::fPropertystd::atomic< Long_t > fPropertyDefinition TClass.h:255; TClass::GetLastReadInfoTVirtualStreamerInfo * GetLastReadInfo() constDefinition TClass.h:444; TClass::StreamerDefaultstatic void StreamerDefault(const TClass *pThis, void *object, TBuffer &b, const TClass *onfile_class)Default streaming in cases where either we have no way to know what to do or if Property() has not ye...Definition TClass.cxx:6873; TClass::SetUnloadedvoid SetUnloaded()Call this method to indicate that the shared library containing this class's code has been removed (u...Definition TClass.cxx:6309; TClass::GetDeleteArrayROOT::DelArrFunc_t GetDeleteArray() constReturn the wrapper around delete [] ThiObject.Definition TClass.cxx:7471; TClass::HasInterpreterInfoInMemoryBool_t HasInterpreterInfoInMemory() constDefinition TClass.h:409; TClass::fClassMenuListTList * fClassMenuListDefinition TClass.h:211; TClass::fConvStreamerFuncClassConvStreamerFunc_t fConvStreamerFuncDefinition TClass.h:242; TClass::BuildRealDatavoid BuildRealData(void *pointer=nullptr, Bool_t isTransient=kFALSE)Build a full list of persistent data members.Definition TClass.cxx:2031; TClass::SetRuntimePropertiesvoid SetRuntimeProperties()Internal routine to set calculate the class properties that can only be known at run-time,...Definition TClass.cxx:6194; TClass::BuildEmulatedRealDatavoid BuildEmulatedRealData(const char *name, Longptr_t offset, TClass *cl, Bool_t isTransient=kFALSE)Build the list of real data for an emulated class.Definition TClass.cxx:2112; TClass::LoadClassstatic TClass * LoadClass(const char *requestedname, Bool_t silent)Helper function used by",MatchSource.WIKI,doc/v632/TClass_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/TClass_8h_source.html
https://root.cern/doc/v632/TClass_8h_source.html:58279,Integrability,rout,routine,58279,"nst TClass *pThis, void *object, TBuffer &b, const TClass *onfile_class)Default streaming in cases where either we have no way to know what to do or if Property() has not ye...Definition TClass.cxx:6873; TClass::SetUnloadedvoid SetUnloaded()Call this method to indicate that the shared library containing this class's code has been removed (u...Definition TClass.cxx:6309; TClass::GetDeleteArrayROOT::DelArrFunc_t GetDeleteArray() constReturn the wrapper around delete [] ThiObject.Definition TClass.cxx:7471; TClass::HasInterpreterInfoInMemoryBool_t HasInterpreterInfoInMemory() constDefinition TClass.h:409; TClass::fClassMenuListTList * fClassMenuListDefinition TClass.h:211; TClass::fConvStreamerFuncClassConvStreamerFunc_t fConvStreamerFuncDefinition TClass.h:242; TClass::BuildRealDatavoid BuildRealData(void *pointer=nullptr, Bool_t isTransient=kFALSE)Build a full list of persistent data members.Definition TClass.cxx:2031; TClass::SetRuntimePropertiesvoid SetRuntimeProperties()Internal routine to set calculate the class properties that can only be known at run-time,...Definition TClass.cxx:6194; TClass::BuildEmulatedRealDatavoid BuildEmulatedRealData(const char *name, Longptr_t offset, TClass *cl, Bool_t isTransient=kFALSE)Build the list of real data for an emulated class.Definition TClass.cxx:2112; TClass::LoadClassstatic TClass * LoadClass(const char *requestedname, Bool_t silent)Helper function used by TClass::GetClass().Definition TClass.cxx:5749; TClass::fSharedLibsTString fSharedLibsDefinition TClass.h:227; TClass::GetTypeInfoconst std::type_info * GetTypeInfo() constDefinition TClass.h:496; TClass::GetListOfDataMembersTList * GetListOfDataMembers(Bool_t load=kTRUE)Return list containing the TDataMembers of a class.Definition TClass.cxx:3770; TClass::ENewTypeENewTypeDefinition TClass.h:107; TClass::kClassNew@ kClassNewDefinition TClass.h:107; TClass::kRealNew@ kRealNewDefinition TClass.h:107; TClass::kDummyNew@ kDummyNewDefinition TClass.h:107; TClass::Movevoid Mov",MatchSource.WIKI,doc/v632/TClass_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/TClass_8h_source.html
https://root.cern/doc/v632/TClass_8h_source.html:59690,Integrability,wrap,wrapper,59690,"ent)Helper function used by TClass::GetClass().Definition TClass.cxx:5749; TClass::fSharedLibsTString fSharedLibsDefinition TClass.h:227; TClass::GetTypeInfoconst std::type_info * GetTypeInfo() constDefinition TClass.h:496; TClass::GetListOfDataMembersTList * GetListOfDataMembers(Bool_t load=kTRUE)Return list containing the TDataMembers of a class.Definition TClass.cxx:3770; TClass::ENewTypeENewTypeDefinition TClass.h:107; TClass::kClassNew@ kClassNewDefinition TClass.h:107; TClass::kRealNew@ kRealNewDefinition TClass.h:107; TClass::kDummyNew@ kDummyNewDefinition TClass.h:107; TClass::Movevoid Move(void *arenaFrom, void *arenaTo) constRegister the fact that an object was moved from the memory location 'arenaFrom' to the memory locatio...Definition TClass.cxx:4327; TClass::GetDeclIdMapstatic DeclIdMap_t * GetDeclIdMap()Definition TClass.cxx:480; TClass::GetDeclFileLineShort_t GetDeclFileLine() constDefinition TClass.h:429; TClass::SetStreamerFuncvoid SetStreamerFunc(ClassStreamerFunc_t strm)Set a wrapper/accessor function around this class custom streamer.Definition TClass.cxx:6922; TClass::GetImplFileNameconst char * GetImplFileName() constDefinition TClass.h:456; TClass::GetListOfRealDataTList * GetListOfRealData() constDefinition TClass.h:453; TClass::SizeInt_t Size() constReturn size of object of this class.Definition TClass.cxx:5704; TClass::SetCurrentStreamerInfovoid SetCurrentStreamerInfo(TVirtualStreamerInfo *info)Set pointer to current TVirtualStreamerInfo.Definition TClass.cxx:5696; TClass::GetDictstatic DictFuncPtr_t GetDict(const char *cname)Return a pointer to the dictionary loading function generated by rootcint.Definition TClass.cxx:3422; TClass::fOffsetStreamerLongptr_t fOffsetStreamerProperties that can only be evaluated at run-time.Definition TClass.h:275; TClass::fSizeofInt_t fSizeofDefinition TClass.h:243; TClass::GetNewArrayROOT::NewArrFunc_t GetNewArray() constReturn the wrapper around new ThisClass[].Definition TClass.cxx:7455; TClass::RepoCont",MatchSource.WIKI,doc/v632/TClass_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/TClass_8h_source.html
https://root.cern/doc/v632/TClass_8h_source.html:60604,Integrability,wrap,wrapper,60604,"() constDefinition TClass.h:429; TClass::SetStreamerFuncvoid SetStreamerFunc(ClassStreamerFunc_t strm)Set a wrapper/accessor function around this class custom streamer.Definition TClass.cxx:6922; TClass::GetImplFileNameconst char * GetImplFileName() constDefinition TClass.h:456; TClass::GetListOfRealDataTList * GetListOfRealData() constDefinition TClass.h:453; TClass::SizeInt_t Size() constReturn size of object of this class.Definition TClass.cxx:5704; TClass::SetCurrentStreamerInfovoid SetCurrentStreamerInfo(TVirtualStreamerInfo *info)Set pointer to current TVirtualStreamerInfo.Definition TClass.cxx:5696; TClass::GetDictstatic DictFuncPtr_t GetDict(const char *cname)Return a pointer to the dictionary loading function generated by rootcint.Definition TClass.cxx:3422; TClass::fOffsetStreamerLongptr_t fOffsetStreamerProperties that can only be evaluated at run-time.Definition TClass.h:275; TClass::fSizeofInt_t fSizeofDefinition TClass.h:243; TClass::GetNewArrayROOT::NewArrFunc_t GetNewArray() constReturn the wrapper around new ThisClass[].Definition TClass.cxx:7455; TClass::RepoCont_tstd::multimap< void *, Version_t > RepoCont_tDefinition TClass.h:343; TClass::StreamerTObjectEmulatedstatic void StreamerTObjectEmulated(const TClass *pThis, void *object, TBuffer &b, const TClass *onfile_class)Case of TObjects when we do not have the library defining the class.Definition TClass.cxx:6823; TClass::fNewROOT::NewFunc_t fNewDefinition TClass.h:235; TClass::kLoading@ kLoadingDefinition TClass.h:332; TClass::kUnloading@ kUnloadingDefinition TClass.h:332; TClass::GetResetAfterMergeROOT::ResetAfterMergeFunc_t GetResetAfterMerge() constReturn the wrapper around Merge.Definition TClass.cxx:7439; TClass::GetClassMethodWithPrototypeTMethod * GetClassMethodWithPrototype(const char *name, const char *proto, Bool_t objectIsConst=kFALSE, ROOT::EFunctionMatchMode mode=ROOT::kConversionMatch)Find the method with a given prototype.Definition TClass.cxx:4527; TClass::CanIgnoreTObjectStreamer",MatchSource.WIKI,doc/v632/TClass_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/TClass_8h_source.html
https://root.cern/doc/v632/TClass_8h_source.html:61242,Integrability,wrap,wrapper,61242,":GetDictstatic DictFuncPtr_t GetDict(const char *cname)Return a pointer to the dictionary loading function generated by rootcint.Definition TClass.cxx:3422; TClass::fOffsetStreamerLongptr_t fOffsetStreamerProperties that can only be evaluated at run-time.Definition TClass.h:275; TClass::fSizeofInt_t fSizeofDefinition TClass.h:243; TClass::GetNewArrayROOT::NewArrFunc_t GetNewArray() constReturn the wrapper around new ThisClass[].Definition TClass.cxx:7455; TClass::RepoCont_tstd::multimap< void *, Version_t > RepoCont_tDefinition TClass.h:343; TClass::StreamerTObjectEmulatedstatic void StreamerTObjectEmulated(const TClass *pThis, void *object, TBuffer &b, const TClass *onfile_class)Case of TObjects when we do not have the library defining the class.Definition TClass.cxx:6823; TClass::fNewROOT::NewFunc_t fNewDefinition TClass.h:235; TClass::kLoading@ kLoadingDefinition TClass.h:332; TClass::kUnloading@ kUnloadingDefinition TClass.h:332; TClass::GetResetAfterMergeROOT::ResetAfterMergeFunc_t GetResetAfterMerge() constReturn the wrapper around Merge.Definition TClass.cxx:7439; TClass::GetClassMethodWithPrototypeTMethod * GetClassMethodWithPrototype(const char *name, const char *proto, Bool_t objectIsConst=kFALSE, ROOT::EFunctionMatchMode mode=ROOT::kConversionMatch)Find the method with a given prototype.Definition TClass.cxx:4527; TClass::CanIgnoreTObjectStreamerBool_t CanIgnoreTObjectStreamer()Definition TClass.h:393; TClass::SetGlobalIsAvoid SetGlobalIsA(IsAGlobalFunc_t)This function installs a global IsA function for this class.Definition TClass.cxx:6300; TClass::GetMissingDictionariesForMembersvoid GetMissingDictionariesForMembers(TCollection &result, TCollection &visited, bool recurse)Verify the Data Members.Definition TClass.cxx:3944; TClass::fStreamerInfoTObjArray * fStreamerInfoDefinition TClass.h:198; TClass::GetSchemaRulesconst ROOT::Detail::TSchemaRuleSet * GetSchemaRules() constReturn the set of the schema rules if any.Definition TClass.cxx:1932; TClass::CloneT",MatchSource.WIKI,doc/v632/TClass_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/TClass_8h_source.html
https://root.cern/doc/v632/TClass_8h_source.html:66063,Integrability,wrap,wrapper,66063,"on TClass.h:334; TClass::kInstrumented@ kInstrumentedDefinition TClass.h:334; TClass::kTObject@ kTObjectDefinition TClass.h:334; TClass::AddRulestatic Bool_t AddRule(const char *rule)Add a schema evolution customization rule.Definition TClass.cxx:1890; TClass::IsTObjectBool_t IsTObject() constReturn kTRUE is the class inherits from TObject.Definition TClass.cxx:5938; TClass::GetContextMenuTitleconst char * GetContextMenuTitle() constDefinition TClass.h:438; TClass::RemoveClassstatic void RemoveClass(TClass *cl)static: Remove a class from the list and map of classesDefinition TClass.cxx:520; TClass::HasLocalHashMemberBool_t HasLocalHashMember() constReturns true if this class has an definition and/or overload of the member function Hash.Definition TClass.cxx:7421; TClass::DeleteArrayvoid DeleteArray(void *ary, Bool_t dtorOnly=kFALSE)Explicitly call operator delete[] for an array.Definition TClass.cxx:5529; TClass::GetConvStreamerFuncClassConvStreamerFunc_t GetConvStreamerFunc() constGet a wrapper/accessor function around this class custom conversion streamer (member function).Definition TClass.cxx:2947; TClass::IsForeignBool_t IsForeign() constReturn kTRUE is the class is Foreign (the class does not have a Streamer method).Definition TClass.cxx:5947; TClass::GetClassInfoClassInfo_t * GetClassInfo() constDefinition TClass.h:433; TClass::fDeleteROOT::DelFunc_t fDeleteDefinition TClass.h:237; TClass::fAllPubDataTViewPubDataMembers * fAllPubDataDefinition TClass.h:209; TClass::fClassInfoClassInfo_t * fClassInfoDefinition TClass.h:222; TClass::GetStreamerInfoTVirtualStreamerInfo * GetStreamerInfo(Int_t version=0, Bool_t isTransient=kFALSE) constreturns a pointer to the TVirtualStreamerInfo object for version If the object does not exist,...Definition TClass.cxx:4599; TClass::HasConsistentHashMemberBool_t HasConsistentHashMember()Return 'true' if we can guarantee that if this class (or any class in this class inheritance hierarch...Definition TClass.h:501; TClass::AdoptStre",MatchSource.WIKI,doc/v632/TClass_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/TClass_8h_source.html
https://root.cern/doc/v632/TClass_8h_source.html:69141,Integrability,rout,routine,69141,"e"".Definition TClass.cxx:4874; TClass::GetBaseClassOffsetInt_t GetBaseClassOffset(const TClass *toBase, void *address=nullptr, bool isDerivedObject=true)Definition TClass.cxx:2791; TClass::NewObjectArrayObjectPtr NewObjectArray(Long_t nElements, ENewType defConstructor=kClassNew) constReturn a pointer to a newly allocated array of objects of this class.Definition TClass.cxx:5209; TClass::GetCollectionProxyTVirtualCollectionProxy * GetCollectionProxy() constReturn the proxy describing the collection (if any).Definition TClass.cxx:2897; TClass::ResetCachesvoid ResetCaches()To clean out all caches.Definition TClass.cxx:4215; TClass::fVersionUsedstd::atomic< Bool_t > fVersionUsedsaved remember if fOffsetStreamer has been set.Definition TClass.h:262; TClass::GetClassSizeInt_t GetClassSize() constDefinition TClass.h:425; TClass::ClassPropertyLong_t ClassProperty() constReturn the C++ property of this class, eg.Definition TClass.cxx:2396; TClass::SetStreamerImplvoid SetStreamerImpl()Internal routine to set fStreamerImpl based on the value of fStreamerType.Definition TClass.cxx:6215; TClass::GetSharedLibsconst char * GetSharedLibs()Get the list of shared libraries containing the code for class cls.Definition TClass.cxx:3623; TClass::CalculateStreamerOffsetvoid CalculateStreamerOffset() constCalculate the offset between an object of this class to its base class TObject.Definition TClass.cxx:2183; TClass::GetMissingDictionariesForPairElementsvoid GetMissingDictionariesForPairElements(TCollection &result, TCollection &visited, bool recurse)Definition TClass.cxx:3973; TClass::ReplaceWithvoid ReplaceWith(TClass *newcl) constDefinition TClass.cxx:4142; TClass::RegisterAddressInRepositoryvoid RegisterAddressInRepository(const char *where, void *location, const TClass *what) constDefinition TClass.cxx:290; TClass::PropertyLong_t Property() const overrideReturns the properties of the TClass as a bit field stored as a Long_t value.Definition TClass.cxx:6086; TClass::HasDefaultConstruc",MatchSource.WIKI,doc/v632/TClass_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/TClass_8h_source.html
https://root.cern/doc/v632/TClass_8h_source.html:70489,Integrability,wrap,wrapper,70489,"set between an object of this class to its base class TObject.Definition TClass.cxx:2183; TClass::GetMissingDictionariesForPairElementsvoid GetMissingDictionariesForPairElements(TCollection &result, TCollection &visited, bool recurse)Definition TClass.cxx:3973; TClass::ReplaceWithvoid ReplaceWith(TClass *newcl) constDefinition TClass.cxx:4142; TClass::RegisterAddressInRepositoryvoid RegisterAddressInRepository(const char *where, void *location, const TClass *what) constDefinition TClass.cxx:290; TClass::PropertyLong_t Property() const overrideReturns the properties of the TClass as a bit field stored as a Long_t value.Definition TClass.cxx:6086; TClass::HasDefaultConstructorBool_t HasDefaultConstructor(Bool_t testio=kFALSE) constReturn true if we have access to a constructor usable for I/O.Definition TClass.cxx:7393; TClass::GetMenuItemsvoid GetMenuItems(TList *listitems)Returns list of methods accessible by context menu.Definition TClass.cxx:3874; TClass::SetNewvoid SetNew(ROOT::NewFunc_t newFunc)Install a new wrapper around 'new'.Definition TClass.cxx:6985; TClass::fIsAMethodstd::atomic< TMethodCall * > fIsAMethodDefinition TClass.h:231; TClass::ReadRulesstatic Int_t ReadRules()Read the class.rules files from the default location:.Definition TClass.cxx:1820; TClass::CanSplitBaseAllowBool_t CanSplitBaseAllow()Pointer to the function implementing streaming for this class.Definition TClass.cxx:2247; TClass::MoveAddressInRepositoryvoid MoveAddressInRepository(const char *where, void *oldadd, void *newadd, const TClass *what) constDefinition TClass.cxx:337; TClass::fStreamerImplstd::atomic< StreamerImpl_t > fStreamerImplDefinition TClass.h:287; TClass::SetContextMenuTitlevoid SetContextMenuTitle(const char *title)Change (i.e. set) the title of the TNamed.Definition TClass.cxx:6269; TClass::GetShowMembersWrapperShowMembersFunc_t GetShowMembersWrapper() constDefinition TClass.h:487; TClass::SetMemberStreamervoid SetMemberStreamer(const char *name, MemberStreamerFunc_t str",MatchSource.WIKI,doc/v632/TClass_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/TClass_8h_source.html
https://root.cern/doc/v632/TClass_8h_source.html:73426,Integrability,wrap,wrapper,73426,"opertiesstd::atomic< UChar_t > fRuntimePropertiesDefinition TClass.h:273; TClass::EStateEStateDefinition TClass.h:121; TClass::kInterpreted@ kInterpretedDefinition TClass.h:126; TClass::kHasTClassInit@ kHasTClassInitDefinition TClass.h:127; TClass::kEmulated@ kEmulatedDefinition TClass.h:125; TClass::kNoInfo@ kNoInfoDefinition TClass.h:122; TClass::kLoaded@ kLoadedDefinition TClass.h:130; TClass::kForwardDeclared@ kForwardDeclaredDefinition TClass.h:124; TClass::kNamespaceForMeta@ kNamespaceForMetaDefinition TClass.h:131; TClass::FindConversionStreamerInfoTVirtualStreamerInfo * FindConversionStreamerInfo(const char *onfile_classname, UInt_t checksum) constReturn a Conversion StreamerInfo from the class 'classname' for the layout represented by 'checksum' ...Definition TClass.cxx:7193; TClass::GetBaseClassOffsetRecurseInt_t GetBaseClassOffsetRecurse(const TClass *toBase)Return data member offset to the base class ""cl"".Definition TClass.cxx:2705; TClass::GetDeleteROOT::DelFunc_t GetDelete() constReturn the wrapper around delete ThiObject.Definition TClass.cxx:7463; TClass::LoadClassDefaultstatic TClass * LoadClassDefault(const char *requestedname, Bool_t silent)Helper function used by TClass::GetClass().Definition TClass.cxx:5771; TClass::IsVersionedBool_t IsVersioned() constDefinition TClass.h:522; TClass::SetClassSizevoid SetClassSize(Int_t sizof)Definition TClass.h:307; TClass::FindClassOrBaseMethodWithIdTMethod * FindClassOrBaseMethodWithId(DeclId_t faddr)Find a method with decl id in this class or its bases.Definition TClass.cxx:4440; TClass::StreamerExternalstatic void StreamerExternal(const TClass *pThis, void *object, TBuffer &b, const TClass *onfile_class)There is special streamer for the class.Definition TClass.cxx:6788; TClass::operator&friend bool operator&(UChar_t l, ERuntimeProperties r)Definition TClass.h:270; TClass::fClassPropertyLong_t fClassPropertyProperty See TClass::Property() for details.Definition TClass.h:256; TClass::fContextMenuTitleTString f",MatchSource.WIKI,doc/v632/TClass_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/TClass_8h_source.html
https://root.cern/doc/v632/TClass_8h_source.html:75121,Integrability,wrap,wrapper,75121,"cial streamer for the class.Definition TClass.cxx:6788; TClass::operator&friend bool operator&(UChar_t l, ERuntimeProperties r)Definition TClass.h:270; TClass::fClassPropertyLong_t fClassPropertyProperty See TClass::Property() for details.Definition TClass.h:256; TClass::fContextMenuTitleTString fContextMenuTitleDefinition TClass.h:223; TClass::StreamerTObjectInitializedstatic void StreamerTObjectInitialized(const TClass *pThis, void *object, TBuffer &b, const TClass *onfile_class)Case of TObjects when fIsOffsetStreamerSet is known to have been set.Definition TClass.cxx:6814; TClass::ConvStreamerInstrumentedstatic void ConvStreamerInstrumented(const TClass *pThis, void *object, TBuffer &b, const TClass *onfile_class)Case of instrumented class with a library.Definition TClass.cxx:6845; TClass::fCanLoadClassInfostd::atomic< Bool_t > fCanLoadClassInfoWhether info was loaded from a root pcm.Definition TClass.h:260; TClass::SetConvStreamerFuncvoid SetConvStreamerFunc(ClassConvStreamerFunc_t strm)Set a wrapper/accessor function around this class custom conversion streamer.Definition TClass.cxx:6945; TClass::FindStreamerInfoTVirtualStreamerInfo * FindStreamerInfo(TObjArray *arr, UInt_t checksum) constFind the TVirtualStreamerInfo in the StreamerInfos corresponding to checksum.Definition TClass.cxx:7066; TClass::GetMissingDictionariesvoid GetMissingDictionaries(THashTable &result, bool recurse=false)Get the classes that have a missing dictionary starting from this one.Definition TClass.cxx:4087; TClass::MakeCustomMenuListvoid MakeCustomMenuList()Makes a customizable version of the popup menu list, i.e.Definition TClass.cxx:4283; TClass::FindStreamerInfoAbstractEmulatedTVirtualStreamerInfo * FindStreamerInfoAbstractEmulated(UInt_t checksum) constFor the case where the requestor class is emulated and this class is abstract, returns a pointer to t...Definition TClass.cxx:4772; TClass::GetMethodAnyTMethod * GetMethodAny(const char *method)Return pointer to method without looking",MatchSource.WIKI,doc/v632/TClass_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/TClass_8h_source.html
https://root.cern/doc/v632/TClass_8h_source.html:76432,Integrability,wrap,wrapper,76432,"n TClass.cxx:7066; TClass::GetMissingDictionariesvoid GetMissingDictionaries(THashTable &result, bool recurse=false)Get the classes that have a missing dictionary starting from this one.Definition TClass.cxx:4087; TClass::MakeCustomMenuListvoid MakeCustomMenuList()Makes a customizable version of the popup menu list, i.e.Definition TClass.cxx:4283; TClass::FindStreamerInfoAbstractEmulatedTVirtualStreamerInfo * FindStreamerInfoAbstractEmulated(UInt_t checksum) constFor the case where the requestor class is emulated and this class is abstract, returns a pointer to t...Definition TClass.cxx:4772; TClass::GetMethodAnyTMethod * GetMethodAny(const char *method)Return pointer to method without looking at parameters.Definition TClass.cxx:4374; TClass::GetIsAProxyTVirtualIsAProxy * GetIsAProxy() constReturn the proxy implementing the IsA functionality.Definition TClass.cxx:2955; TClass::GetClassVersionVersion_t GetClassVersion() constDefinition TClass.h:420; TClass::GetMergeROOT::MergeFunc_t GetMerge() constReturn the wrapper around Merge.Definition TClass.cxx:7431; TClass::fResetAfterMergeROOT::ResetAfterMergeFunc_t fResetAfterMergeDefinition TClass.h:234; TClass::IsFolderBool_t IsFolder() const overrideReturns kTRUE in case object contains browsable objects (like containers or lists of other objects).Definition TClass.h:517; TClass::fInstanceCountUInt_t fInstanceCountDefinition TClass.h:217; TClass::fHasRootPcmInfostd::atomic< Bool_t > fHasRootPcmInfoC++ Property of the class (is abstract, has virtual table, etc.)Definition TClass.h:259; TClass::GetActualClassTClass * GetActualClass(const void *object) constReturn a pointer to the real class of the object.Definition TClass.cxx:2607; TClass::fDestructorROOT::DesFunc_t fDestructorDefinition TClass.h:239; TClass::GetDeclFileNameconst char * GetDeclFileName() constReturn name of the file containing the declaration of this class.Definition TClass.cxx:3463; TClass::NewObjectObjectPtr NewObject(ENewType defConstructor=kClassNew, Bo",MatchSource.WIKI,doc/v632/TClass_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/TClass_8h_source.html
https://root.cern/doc/v632/TClass_8h_source.html:77699,Integrability,wrap,wrapper,77699,"owsable objects (like containers or lists of other objects).Definition TClass.h:517; TClass::fInstanceCountUInt_t fInstanceCountDefinition TClass.h:217; TClass::fHasRootPcmInfostd::atomic< Bool_t > fHasRootPcmInfoC++ Property of the class (is abstract, has virtual table, etc.)Definition TClass.h:259; TClass::GetActualClassTClass * GetActualClass(const void *object) constReturn a pointer to the real class of the object.Definition TClass.cxx:2607; TClass::fDestructorROOT::DesFunc_t fDestructorDefinition TClass.h:239; TClass::GetDeclFileNameconst char * GetDeclFileName() constReturn name of the file containing the declaration of this class.Definition TClass.cxx:3463; TClass::NewObjectObjectPtr NewObject(ENewType defConstructor=kClassNew, Bool_t quiet=kFALSE) constDefinition TClass.cxx:4992; TClass::GetRealDataTRealData * GetRealData(const char *name) constReturn pointer to TRealData element with name ""name"".Definition TClass.cxx:3503; TClass::SetDeleteArrayvoid SetDeleteArray(ROOT::DelArrFunc_t deleteArrayFunc)Install a new wrapper around 'delete []'.Definition TClass.cxx:7009; TClass::fHasCustomStreamerMemberBool_t fHasCustomStreamerMemberThe class has a Streamer method and it is implemented by the user or an older (not StreamerInfo based...Definition TClass.h:253; TClass::GetFunctionTemplateTFunctionTemplate * GetFunctionTemplate(const char *name)Definition TClass.cxx:3607; TClass::ResetClassInfovoid ResetClassInfo()Make sure that the current ClassInfo is up to date.Definition TClass.cxx:4180; TClass::fNewArrayROOT::NewArrFunc_t fNewArrayDefinition TClass.h:236; TClass::ReadBufferInt_t ReadBuffer(TBuffer &b, void *pointer, Int_t version, UInt_t start, UInt_t count)Function called by the Streamer functions to deserialize information from buffer b into object at p.Definition TClass.cxx:6758; TClass::SetImplFileNamevoid SetImplFileName(const char *implFileName)Definition TClass.h:560; TClass::GetMissingDictionariesWithRecursionCheckvoid GetMissingDictionariesWithRecursi",MatchSource.WIKI,doc/v632/TClass_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/TClass_8h_source.html
https://root.cern/doc/v632/TClass_8h_source.html:80704,Integrability,interface,interface,80704,"d) the list of functions.Definition TClass.cxx:4355; TClass::GetReferenceProxyTVirtualRefProxy * GetReferenceProxy() constDefinition TClass.h:483; TClass::ResetMenuListvoid ResetMenuList()Resets the menu list to it's standard value.Definition TClass.cxx:4243; TClass::GetClassstatic TClass * GetClass(const char *name, Bool_t load=kTRUE, Bool_t silent=kFALSE)Static method returning pointer to TClass of the specified class name.Definition TClass.cxx:2968; TClass::WriteBufferInt_t WriteBuffer(TBuffer &b, void *pointer, const char *info="""")Function called by the Streamer functions to serialize object at p to buffer b.Definition TClass.cxx:6779; TClass::LoadClassCustomstatic TClass * LoadClassCustom(const char *requestedname, Bool_t silent)Helper function used by TClass::GetClass().Definition TClass.cxx:5801; TClass::GetHeapInstanceCountUInt_t GetHeapInstanceCount() constDefinition TClass.h:467; TClass::fImplFileLineShort_t fImplFileLineDefinition TClass.h:216; TClingThis class defines an interface to the cling C++ interpreter.Definition TCling.h:102; TCollectionCollection abstract base class.Definition TCollection.h:65; TDataMemberAll ROOT classes may have RTTI (run time type identification) support added.Definition TDataMember.h:31; TDictionaryThis class defines an abstract interface that must be implemented by all classes that contain diction...Definition TDictionary.h:168; TDictionary::EMemberSelectionEMemberSelectionKinds of members to include in lists.Definition TDictionary.h:216; TDictionary::DeclId_tconst void * DeclId_tDefinition TDictionary.h:224; TFunctionTemplateDictionary for function template This class describes one single function template.Definition TFunctionTemplate.h:26; THashTableTHashTable implements a hash table to store TObject's.Definition THashTable.h:35; TListOfDataMembersA collection of TDataMember objects designed for fast access given a DeclId_t and for keep track of T...Definition TListOfDataMembers.h:33; TListOfEnumsA collection of TEnum obj",MatchSource.WIKI,doc/v632/TClass_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/TClass_8h_source.html
https://root.cern/doc/v632/TClass_8h_source.html:80997,Integrability,interface,interface,80997,"onst char *name, Bool_t load=kTRUE, Bool_t silent=kFALSE)Static method returning pointer to TClass of the specified class name.Definition TClass.cxx:2968; TClass::WriteBufferInt_t WriteBuffer(TBuffer &b, void *pointer, const char *info="""")Function called by the Streamer functions to serialize object at p to buffer b.Definition TClass.cxx:6779; TClass::LoadClassCustomstatic TClass * LoadClassCustom(const char *requestedname, Bool_t silent)Helper function used by TClass::GetClass().Definition TClass.cxx:5801; TClass::GetHeapInstanceCountUInt_t GetHeapInstanceCount() constDefinition TClass.h:467; TClass::fImplFileLineShort_t fImplFileLineDefinition TClass.h:216; TClingThis class defines an interface to the cling C++ interpreter.Definition TCling.h:102; TCollectionCollection abstract base class.Definition TCollection.h:65; TDataMemberAll ROOT classes may have RTTI (run time type identification) support added.Definition TDataMember.h:31; TDictionaryThis class defines an abstract interface that must be implemented by all classes that contain diction...Definition TDictionary.h:168; TDictionary::EMemberSelectionEMemberSelectionKinds of members to include in lists.Definition TDictionary.h:216; TDictionary::DeclId_tconst void * DeclId_tDefinition TDictionary.h:224; TFunctionTemplateDictionary for function template This class describes one single function template.Definition TFunctionTemplate.h:26; THashTableTHashTable implements a hash table to store TObject's.Definition THashTable.h:35; TListOfDataMembersA collection of TDataMember objects designed for fast access given a DeclId_t and for keep track of T...Definition TListOfDataMembers.h:33; TListOfEnumsA collection of TEnum objects designed for fast access given a DeclId_t and for keep track of TEnum t...Definition TListOfEnums.h:33; TListOfFunctionTemplatesA collection of TFunction objects designed for fast access given a DeclId_t and for keep track of TFu...Definition TListOfFunctionTemplates.h:35; TListOfFunctionsA collec",MatchSource.WIKI,doc/v632/TClass_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/TClass_8h_source.html
https://root.cern/doc/v632/TClass_8h_source.html:82386,Integrability,interface,interface,82386,ction template.Definition TFunctionTemplate.h:26; THashTableTHashTable implements a hash table to store TObject's.Definition THashTable.h:35; TListOfDataMembersA collection of TDataMember objects designed for fast access given a DeclId_t and for keep track of T...Definition TListOfDataMembers.h:33; TListOfEnumsA collection of TEnum objects designed for fast access given a DeclId_t and for keep track of TEnum t...Definition TListOfEnums.h:33; TListOfFunctionTemplatesA collection of TFunction objects designed for fast access given a DeclId_t and for keep track of TFu...Definition TListOfFunctionTemplates.h:35; TListOfFunctionsA collection of TFunction objects designed for fast access given a DeclId_t and for keep track of TFu...Definition TListOfFunctions.h:35; TListA doubly linked list.Definition TList.h:38; TMemberInspectorAbstract base class for accessing the data-members of a class.Definition TMemberInspector.h:31; TMemberStreamerDefinition TMemberStreamer.h:26; TMethodCallMethod or function calling interface.Definition TMethodCall.h:37; TMethodEach ROOT class (see TClass) has a linked list of methods.Definition TMethod.h:38; TObjArrayAn array of TObjects.Definition TObjArray.h:31; TObjectMother of all ROOT objects.Definition TObject.h:41; TObject::Dumpvirtual void Dump() constDump contents of object on stdout.Definition TObject.cxx:348; TObject::TestBitR__ALWAYS_INLINE Bool_t TestBit(UInt_t f) constDefinition TObject.h:199; TProtoClassPersistent version of a TClass.Definition TProtoClass.h:38; TRealDataThe TRealData class manages the effective list of all data members for a given class.Definition TRealData.h:30; TStreamerInfoDescribes a persistent version of a class.Definition TStreamerInfo.h:39; TStringBasic string class.Definition TString.h:139; TViewPubDataMembersView implementing the TList interface and giving access all the TDictionary describing public data me...Definition TViewPubDataMembers.h:28; TViewPubFunctionsView implementing the TList interface and ,MatchSource.WIKI,doc/v632/TClass_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/TClass_8h_source.html
https://root.cern/doc/v632/TClass_8h_source.html:83197,Integrability,interface,interface,83197,"tract base class for accessing the data-members of a class.Definition TMemberInspector.h:31; TMemberStreamerDefinition TMemberStreamer.h:26; TMethodCallMethod or function calling interface.Definition TMethodCall.h:37; TMethodEach ROOT class (see TClass) has a linked list of methods.Definition TMethod.h:38; TObjArrayAn array of TObjects.Definition TObjArray.h:31; TObjectMother of all ROOT objects.Definition TObject.h:41; TObject::Dumpvirtual void Dump() constDump contents of object on stdout.Definition TObject.cxx:348; TObject::TestBitR__ALWAYS_INLINE Bool_t TestBit(UInt_t f) constDefinition TObject.h:199; TProtoClassPersistent version of a TClass.Definition TProtoClass.h:38; TRealDataThe TRealData class manages the effective list of all data members for a given class.Definition TRealData.h:30; TStreamerInfoDescribes a persistent version of a class.Definition TStreamerInfo.h:39; TStringBasic string class.Definition TString.h:139; TViewPubDataMembersView implementing the TList interface and giving access all the TDictionary describing public data me...Definition TViewPubDataMembers.h:28; TViewPubFunctionsView implementing the TList interface and giving access all the TFunction describing public methods i...Definition TViewPubFunctions.h:28; TVirtualCollectionProxyDefines a common interface to inspect/change the contents of an object that represents a collection.Definition TVirtualCollectionProxy.h:52; TVirtualIsAProxyDefinition TVirtualIsAProxy.h:27; TVirtualMutexThis class implements a mutex interface.Definition TVirtualMutex.h:32; TVirtualRefProxyDefinition TVirtualRefProxy.h:81; TVirtualStreamerInfoAbstract Interface class describing Streamer information for one class.Definition TVirtualStreamerInfo.h:44; bool; int; unsigned int; lineTLine * lineDefinition entrylistblock_figure1.C:235; ROOT::Internal::GetClassHelperTClass * GetClassHelper(Bool_t, Bool_t, std::true_type)Definition TClass.h:624; ROOT::Minuit2::GradientParameterSpace::Internal@ Internal; ROOTtbb::task",MatchSource.WIKI,doc/v632/TClass_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/TClass_8h_source.html
https://root.cern/doc/v632/TClass_8h_source.html:83355,Integrability,interface,interface,83355,"or function calling interface.Definition TMethodCall.h:37; TMethodEach ROOT class (see TClass) has a linked list of methods.Definition TMethod.h:38; TObjArrayAn array of TObjects.Definition TObjArray.h:31; TObjectMother of all ROOT objects.Definition TObject.h:41; TObject::Dumpvirtual void Dump() constDump contents of object on stdout.Definition TObject.cxx:348; TObject::TestBitR__ALWAYS_INLINE Bool_t TestBit(UInt_t f) constDefinition TObject.h:199; TProtoClassPersistent version of a TClass.Definition TProtoClass.h:38; TRealDataThe TRealData class manages the effective list of all data members for a given class.Definition TRealData.h:30; TStreamerInfoDescribes a persistent version of a class.Definition TStreamerInfo.h:39; TStringBasic string class.Definition TString.h:139; TViewPubDataMembersView implementing the TList interface and giving access all the TDictionary describing public data me...Definition TViewPubDataMembers.h:28; TViewPubFunctionsView implementing the TList interface and giving access all the TFunction describing public methods i...Definition TViewPubFunctions.h:28; TVirtualCollectionProxyDefines a common interface to inspect/change the contents of an object that represents a collection.Definition TVirtualCollectionProxy.h:52; TVirtualIsAProxyDefinition TVirtualIsAProxy.h:27; TVirtualMutexThis class implements a mutex interface.Definition TVirtualMutex.h:32; TVirtualRefProxyDefinition TVirtualRefProxy.h:81; TVirtualStreamerInfoAbstract Interface class describing Streamer information for one class.Definition TVirtualStreamerInfo.h:44; bool; int; unsigned int; lineTLine * lineDefinition entrylistblock_figure1.C:235; ROOT::Internal::GetClassHelperTClass * GetClassHelper(Bool_t, Bool_t, std::true_type)Definition TClass.h:624; ROOT::Minuit2::GradientParameterSpace::Internal@ Internal; ROOTtbb::task_arena is an alias of tbb::interface7::task_arena, which doesn't allow to forward declare tb...Definition EExecutionPolicy.hxx:4; ROOT::DirAutoAdd_tvoid(* DirAu",MatchSource.WIKI,doc/v632/TClass_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/TClass_8h_source.html
https://root.cern/doc/v632/TClass_8h_source.html:83506,Integrability,interface,interface,83506,"An array of TObjects.Definition TObjArray.h:31; TObjectMother of all ROOT objects.Definition TObject.h:41; TObject::Dumpvirtual void Dump() constDump contents of object on stdout.Definition TObject.cxx:348; TObject::TestBitR__ALWAYS_INLINE Bool_t TestBit(UInt_t f) constDefinition TObject.h:199; TProtoClassPersistent version of a TClass.Definition TProtoClass.h:38; TRealDataThe TRealData class manages the effective list of all data members for a given class.Definition TRealData.h:30; TStreamerInfoDescribes a persistent version of a class.Definition TStreamerInfo.h:39; TStringBasic string class.Definition TString.h:139; TViewPubDataMembersView implementing the TList interface and giving access all the TDictionary describing public data me...Definition TViewPubDataMembers.h:28; TViewPubFunctionsView implementing the TList interface and giving access all the TFunction describing public methods i...Definition TViewPubFunctions.h:28; TVirtualCollectionProxyDefines a common interface to inspect/change the contents of an object that represents a collection.Definition TVirtualCollectionProxy.h:52; TVirtualIsAProxyDefinition TVirtualIsAProxy.h:27; TVirtualMutexThis class implements a mutex interface.Definition TVirtualMutex.h:32; TVirtualRefProxyDefinition TVirtualRefProxy.h:81; TVirtualStreamerInfoAbstract Interface class describing Streamer information for one class.Definition TVirtualStreamerInfo.h:44; bool; int; unsigned int; lineTLine * lineDefinition entrylistblock_figure1.C:235; ROOT::Internal::GetClassHelperTClass * GetClassHelper(Bool_t, Bool_t, std::true_type)Definition TClass.h:624; ROOT::Minuit2::GradientParameterSpace::Internal@ Internal; ROOTtbb::task_arena is an alias of tbb::interface7::task_arena, which doesn't allow to forward declare tb...Definition EExecutionPolicy.hxx:4; ROOT::DirAutoAdd_tvoid(* DirAutoAdd_t)(void *, TDirectory *)Definition Rtypes.h:114; ROOT::ResetAfterMergeFunc_tvoid(* ResetAfterMergeFunc_t)(void *, TFileMergeInfo *)Definition Rtypes.h:1",MatchSource.WIKI,doc/v632/TClass_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/TClass_8h_source.html
https://root.cern/doc/v632/TClass_8h_source.html:83723,Integrability,interface,interface,83723,"Definition TObject.cxx:348; TObject::TestBitR__ALWAYS_INLINE Bool_t TestBit(UInt_t f) constDefinition TObject.h:199; TProtoClassPersistent version of a TClass.Definition TProtoClass.h:38; TRealDataThe TRealData class manages the effective list of all data members for a given class.Definition TRealData.h:30; TStreamerInfoDescribes a persistent version of a class.Definition TStreamerInfo.h:39; TStringBasic string class.Definition TString.h:139; TViewPubDataMembersView implementing the TList interface and giving access all the TDictionary describing public data me...Definition TViewPubDataMembers.h:28; TViewPubFunctionsView implementing the TList interface and giving access all the TFunction describing public methods i...Definition TViewPubFunctions.h:28; TVirtualCollectionProxyDefines a common interface to inspect/change the contents of an object that represents a collection.Definition TVirtualCollectionProxy.h:52; TVirtualIsAProxyDefinition TVirtualIsAProxy.h:27; TVirtualMutexThis class implements a mutex interface.Definition TVirtualMutex.h:32; TVirtualRefProxyDefinition TVirtualRefProxy.h:81; TVirtualStreamerInfoAbstract Interface class describing Streamer information for one class.Definition TVirtualStreamerInfo.h:44; bool; int; unsigned int; lineTLine * lineDefinition entrylistblock_figure1.C:235; ROOT::Internal::GetClassHelperTClass * GetClassHelper(Bool_t, Bool_t, std::true_type)Definition TClass.h:624; ROOT::Minuit2::GradientParameterSpace::Internal@ Internal; ROOTtbb::task_arena is an alias of tbb::interface7::task_arena, which doesn't allow to forward declare tb...Definition EExecutionPolicy.hxx:4; ROOT::DirAutoAdd_tvoid(* DirAutoAdd_t)(void *, TDirectory *)Definition Rtypes.h:114; ROOT::ResetAfterMergeFunc_tvoid(* ResetAfterMergeFunc_t)(void *, TFileMergeInfo *)Definition Rtypes.h:116; ROOT::DesFunc_tvoid(* DesFunc_t)(void *)Definition Rtypes.h:113; ROOT::GetClassTClass * GetClass(T *)Definition TClass.h:663; ROOT::CreateClassTClass * CreateClass(const char ",MatchSource.WIKI,doc/v632/TClass_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/TClass_8h_source.html
https://root.cern/doc/v632/TClass_8h_source.html:25440,Modifiability,inherit,inheritance,25440,"apInstanceCount() const { return fOnHeap; }; 468 void GetMenuItems(TList *listitems);; 469 TList *GetMenuList() const;; 470 TMethod *GetMethod(const char *method, const char *params, Bool_t objectIsConst = kFALSE);; 471 TMethod *GetMethodWithPrototype(const char *method, const char *proto, Bool_t objectIsConst = kFALSE,; 472 ROOT::EFunctionMatchMode mode = ROOT::kConversionMatch);; 473 TMethod *GetMethodAny(const char *method);; 474 TMethod *GetMethodAllAny(const char *method);; 475 Int_t GetNdata();; 476 ROOT::MergeFunc_t GetMerge() const;; 477 ROOT::ResetAfterMergeFunc_t GetResetAfterMerge() const;; 478 ROOT::NewFunc_t GetNew() const;; 479 ROOT::NewArrFunc_t GetNewArray() const;; 480 Int_t GetNmethods();; 481 TClass *const*GetPersistentRef() const { return fPersistentRef; }; 482 TRealData *GetRealData(const char *name) const;; 483 TVirtualRefProxy *GetReferenceProxy() const { return fRefProxy; }; 484 const ROOT::Detail::TSchemaRuleSet *GetSchemaRules() const;; 485 ROOT::Detail::TSchemaRuleSet *GetSchemaRules(Bool_t create = kFALSE);; 486 const char *GetSharedLibs();; 487 ShowMembersFunc_t GetShowMembersWrapper() const { return fShowMembers; }; 488 EState GetState() const { return fState; }; 489 TClassStreamer *GetStreamer() const;; 490 ClassStreamerFunc_t GetStreamerFunc() const;; 491 ClassConvStreamerFunc_t GetConvStreamerFunc() const;; 492 const TObjArray *GetStreamerInfos() const { return fStreamerInfo; }; 493 TVirtualStreamerInfo *GetStreamerInfo(Int_t version=0, Bool_t isTransient = kFALSE) const;; 494 TVirtualStreamerInfo *GetStreamerInfoAbstractEmulated(Int_t version=0) const;; 495 TVirtualStreamerInfo *FindStreamerInfoAbstractEmulated(UInt_t checksum) const;; 496 const std::type_info *GetTypeInfo() const { return fTypeInfo; };; 497 ; 498 /// @brief Return 'true' if we can guarantee that if this class (or any class in; 499 /// this class inheritance hierarchy) overload TObject::Hash it also starts; 500 /// the RecursiveRemove process from its own destructor.",MatchSource.WIKI,doc/v632/TClass_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/TClass_8h_source.html
https://root.cern/doc/v632/TClass_8h_source.html:53055,Modifiability,inherit,inherits,53055,"tCurrentStreamerInfoTVirtualStreamerInfo * GetCurrentStreamerInfo()Definition TClass.h:439; TClass::GetDirectoryAutoAddROOT::DirAutoAdd_t GetDirectoryAutoAdd() constReturn the wrapper around the directory auto add function.Definition TClass.cxx:7487; TClass::AddImplFilevoid AddImplFile(const char *filename, int line)Definition TClass.cxx:1952; TClass::GetListOfMethodOverloadsTCollection * GetListOfMethodOverloads(const char *name) constReturn the collection of functions named ""name"".Definition TClass.cxx:3827; TClass::fEnumsstd::atomic< TListOfEnums * > fEnumsDefinition TClass.h:205; TClass::HasNoInfoOrEmuOrFwdDeclaredDeclstatic Bool_t HasNoInfoOrEmuOrFwdDeclaredDecl(const char *)Definition TClass.cxx:3398; TClass::fOVRMutexTVirtualMutex * fOVRMutexDefinition TClass.h:342; TClass::GetListOfEnumsTList * GetListOfEnums(Bool_t load=kTRUE)Return a list containing the TEnums of a class.Definition TClass.cxx:3686; TClass::IsStartingWithTObjectBool_t IsStartingWithTObject() constReturns true if this class inherits from TObject and if the start of the TObject parts is at the very...Definition TClass.cxx:5929; TClass::GetListOfMethodsTList * GetListOfMethods(Bool_t load=kTRUE)Return list containing the TMethods of a class.Definition TClass.cxx:3812; TClass::TClassTClass()Internal, default constructor.Definition TClass.cxx:1065; TClass::fDeclFileLineShort_t fDeclFileLineDefinition TClass.h:215; TClass::GetNmethodsInt_t GetNmethods()Return the number of methods of this class Note that in case the list of methods is not yet created,...Definition TClass.cxx:4573; TClass::fIsOffsetStreamerSetstd::atomic< Bool_t > fIsOffsetStreamerSetIndicates whether the ClassInfo is supposed to be available.Definition TClass.h:261; TClass::IgnoreTObjectStreamervoid IgnoreTObjectStreamer(Bool_t ignore=kTRUE)When the class kIgnoreTObjectStreamer bit is set, the automatically generated Streamer will not call ...Definition TClass.cxx:4841; TClass::GetStreamerTClassStreamer * GetStreamer() constReturn",MatchSource.WIKI,doc/v632/TClass_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/TClass_8h_source.html
https://root.cern/doc/v632/TClass_8h_source.html:54586,Modifiability,inherit,inherited,54586,"se the list of methods is not yet created,...Definition TClass.cxx:4573; TClass::fIsOffsetStreamerSetstd::atomic< Bool_t > fIsOffsetStreamerSetIndicates whether the ClassInfo is supposed to be available.Definition TClass.h:261; TClass::IgnoreTObjectStreamervoid IgnoreTObjectStreamer(Bool_t ignore=kTRUE)When the class kIgnoreTObjectStreamer bit is set, the automatically generated Streamer will not call ...Definition TClass.cxx:4841; TClass::GetStreamerTClassStreamer * GetStreamer() constReturn the Streamer Class allowing streaming (if any).Definition TClass.cxx:2914; TClass::GetIdMapstatic IdMap_t * GetIdMap()Definition TClass.cxx:469; TClass::GetInstanceCountUInt_t GetInstanceCount() constDefinition TClass.h:466; TClass::SetDeletevoid SetDelete(ROOT::DelFunc_t deleteFunc)Install a new wrapper around 'delete'.Definition TClass.cxx:7001; TClass::SetLastReadInfovoid SetLastReadInfo(TVirtualStreamerInfo *info)Definition TClass.h:445; TClass::AutoBrowsestatic Int_t AutoBrowse(TObject *obj, TBrowser *browser)Browse external object inherited from TObject.Definition TClass.cxx:1966; TClass::GetNewROOT::NewFunc_t GetNew() constReturn the wrapper around new ThisClass().Definition TClass.cxx:7447; TClass::GetBaseClassTClass * GetBaseClass(const char *classname)Return pointer to the base class ""classname"".Definition TClass.cxx:2655; TClass::GetDataMemberOffsetLongptr_t GetDataMemberOffset(const char *membername) constreturn offset for member name.Definition TClass.cxx:3477; TClass::GetNdataInt_t GetNdata()Return the number of data members of this class Note that in case the list of data members is not yet...Definition TClass.cxx:4554; TClass::SetDestructorvoid SetDestructor(ROOT::DesFunc_t destructorFunc)Install a new wrapper around the destructor.Definition TClass.cxx:7017; TClass::PostLoadCheckvirtual void PostLoadCheck()Do the initialization that can only be done after the CINT dictionary has been fully populated and ca...Definition TClass.cxx:5959; TClass::LoadClassInfovoid ",MatchSource.WIKI,doc/v632/TClass_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/TClass_8h_source.html
https://root.cern/doc/v632/TClass_8h_source.html:65380,Modifiability,inherit,inherits,65380,"ay * > * > ConvSIMap_tPersistent address of pointer to this TClass object and its successors.Definition TClass.h:196; TClass::StreamerTObjectstatic void StreamerTObject(const TClass *pThis, void *object, TBuffer &b, const TClass *onfile_class)Case of TObjects.Definition TClass.cxx:6800; TClass::IsLoadedBool_t IsLoaded() constReturn true if the shared library of this class is currently in the a process's memory.Definition TClass.cxx:5912; TClass::EStreamerTypeEStreamerTypeDefinition TClass.h:334; TClass::kDefault@ kDefaultDefinition TClass.h:334; TClass::kEmulatedStreamer@ kEmulatedStreamerDefinition TClass.h:334; TClass::kExternal@ kExternalDefinition TClass.h:334; TClass::kForeign@ kForeignDefinition TClass.h:334; TClass::kInstrumented@ kInstrumentedDefinition TClass.h:334; TClass::kTObject@ kTObjectDefinition TClass.h:334; TClass::AddRulestatic Bool_t AddRule(const char *rule)Add a schema evolution customization rule.Definition TClass.cxx:1890; TClass::IsTObjectBool_t IsTObject() constReturn kTRUE is the class inherits from TObject.Definition TClass.cxx:5938; TClass::GetContextMenuTitleconst char * GetContextMenuTitle() constDefinition TClass.h:438; TClass::RemoveClassstatic void RemoveClass(TClass *cl)static: Remove a class from the list and map of classesDefinition TClass.cxx:520; TClass::HasLocalHashMemberBool_t HasLocalHashMember() constReturns true if this class has an definition and/or overload of the member function Hash.Definition TClass.cxx:7421; TClass::DeleteArrayvoid DeleteArray(void *ary, Bool_t dtorOnly=kFALSE)Explicitly call operator delete[] for an array.Definition TClass.cxx:5529; TClass::GetConvStreamerFuncClassConvStreamerFunc_t GetConvStreamerFunc() constGet a wrapper/accessor function around this class custom conversion streamer (member function).Definition TClass.cxx:2947; TClass::IsForeignBool_t IsForeign() constReturn kTRUE is the class is Foreign (the class does not have a Streamer method).Definition TClass.cxx:5947; TClass::GetClassInfoCla",MatchSource.WIKI,doc/v632/TClass_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/TClass_8h_source.html
https://root.cern/doc/v632/TClass_8h_source.html:66996,Modifiability,inherit,inheritance,66996,"delete[] for an array.Definition TClass.cxx:5529; TClass::GetConvStreamerFuncClassConvStreamerFunc_t GetConvStreamerFunc() constGet a wrapper/accessor function around this class custom conversion streamer (member function).Definition TClass.cxx:2947; TClass::IsForeignBool_t IsForeign() constReturn kTRUE is the class is Foreign (the class does not have a Streamer method).Definition TClass.cxx:5947; TClass::GetClassInfoClassInfo_t * GetClassInfo() constDefinition TClass.h:433; TClass::fDeleteROOT::DelFunc_t fDeleteDefinition TClass.h:237; TClass::fAllPubDataTViewPubDataMembers * fAllPubDataDefinition TClass.h:209; TClass::fClassInfoClassInfo_t * fClassInfoDefinition TClass.h:222; TClass::GetStreamerInfoTVirtualStreamerInfo * GetStreamerInfo(Int_t version=0, Bool_t isTransient=kFALSE) constreturns a pointer to the TVirtualStreamerInfo object for version If the object does not exist,...Definition TClass.cxx:4599; TClass::HasConsistentHashMemberBool_t HasConsistentHashMember()Return 'true' if we can guarantee that if this class (or any class in this class inheritance hierarch...Definition TClass.h:501; TClass::AdoptStreamervoid AdoptStreamer(TClassStreamer *strm)Adopt a TClassStreamer object.Definition TClass.cxx:6894; TClass::GetBaseDataMemberTClass * GetBaseDataMember(const char *datamember)Return pointer to (base) class that contains datamember.Definition TClass.cxx:2827; TClass::ECheckSumECheckSumDefinition TClass.h:108; TClass::kLatestCheckSum@ kLatestCheckSumDefinition TClass.h:117; TClass::kNoRange@ kNoRangeDefinition TClass.h:112; TClass::kCurrentCheckSum@ kCurrentCheckSumDefinition TClass.h:109; TClass::kNoBaseCheckSum@ kNoBaseCheckSumDefinition TClass.h:116; TClass::kReflex@ kReflexDefinition TClass.h:114; TClass::kReflexNoComment@ kReflexNoCommentDefinition TClass.h:111; TClass::kWithTypeDef@ kWithTypeDefDefinition TClass.h:113; TClass::kNoRangeCheck@ kNoRangeCheckDefinition TClass.h:115; TClass::kNoEnum@ kNoEnumDefinition TClass.h:110; TClass::Dumpvoid Dump() ",MatchSource.WIKI,doc/v632/TClass_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/TClass_8h_source.html
https://root.cern/doc/v632/TClass_8h_source.html:68100,Modifiability,inherit,inherits,68100,"AdoptStreamer(TClassStreamer *strm)Adopt a TClassStreamer object.Definition TClass.cxx:6894; TClass::GetBaseDataMemberTClass * GetBaseDataMember(const char *datamember)Return pointer to (base) class that contains datamember.Definition TClass.cxx:2827; TClass::ECheckSumECheckSumDefinition TClass.h:108; TClass::kLatestCheckSum@ kLatestCheckSumDefinition TClass.h:117; TClass::kNoRange@ kNoRangeDefinition TClass.h:112; TClass::kCurrentCheckSum@ kCurrentCheckSumDefinition TClass.h:109; TClass::kNoBaseCheckSum@ kNoBaseCheckSumDefinition TClass.h:116; TClass::kReflex@ kReflexDefinition TClass.h:114; TClass::kReflexNoComment@ kReflexNoCommentDefinition TClass.h:111; TClass::kWithTypeDef@ kWithTypeDefDefinition TClass.h:113; TClass::kNoRangeCheck@ kNoRangeCheckDefinition TClass.h:115; TClass::kNoEnum@ kNoEnumDefinition TClass.h:110; TClass::Dumpvoid Dump() const overrideDump contents of object on stdout.Definition TClass.h:398; TClass::InheritsFromBool_t InheritsFrom(const char *cl) const overrideReturn kTRUE if this class inherits from a class with name ""classname"".Definition TClass.cxx:4874; TClass::GetBaseClassOffsetInt_t GetBaseClassOffset(const TClass *toBase, void *address=nullptr, bool isDerivedObject=true)Definition TClass.cxx:2791; TClass::NewObjectArrayObjectPtr NewObjectArray(Long_t nElements, ENewType defConstructor=kClassNew) constReturn a pointer to a newly allocated array of objects of this class.Definition TClass.cxx:5209; TClass::GetCollectionProxyTVirtualCollectionProxy * GetCollectionProxy() constReturn the proxy describing the collection (if any).Definition TClass.cxx:2897; TClass::ResetCachesvoid ResetCaches()To clean out all caches.Definition TClass.cxx:4215; TClass::fVersionUsedstd::atomic< Bool_t > fVersionUsedsaved remember if fOffsetStreamer has been set.Definition TClass.h:262; TClass::GetClassSizeInt_t GetClassSize() constDefinition TClass.h:425; TClass::ClassPropertyLong_t ClassProperty() constReturn the C++ property of this class, eg.Definition ",MatchSource.WIKI,doc/v632/TClass_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/TClass_8h_source.html
https://root.cern/doc/v632/TClass_8h_source.html:2934,Performance,load,loaded,2934,"code should #include this directly.; 31// #include ""TObjString.h""; 32// #include ""ThreadLocalStorage.h""; 33// #include <set>; 34#endif; 35 ; 36#include <cstddef>; 37#include <map>; 38#include <string>; 39#include <unordered_set>; 40#include <vector>; 41#include <atomic>; 42 ; 43class TBaseClass;; 44class TBrowser;; 45class TDataMember;; 46class TCling;; 47class TMethod;; 48class TRealData;; 49class TBuffer;; 50class TVirtualStreamerInfo;; 51class TVirtualCollectionProxy;; 52class TMethodCall;; 53class TVirtualIsAProxy;; 54class TVirtualRefProxy;; 55class THashTable;; 56class TListOfFunctions;; 57class TListOfFunctionTemplates;; 58class TListOfDataMembers;; 59class TListOfEnums;; 60class TViewPubFunctions;; 61class TViewPubDataMembers;; 62class TFunctionTemplate;; 63class TProtoClass;; 64 ; 65namespace ROOT {; 66 class TGenericClassInfo;; 67 class TMapTypeToTClass;; 68 class TMapDeclIdToTClass;; 69 namespace Detail {; 70 class TSchemaRuleSet;; 71 class TCollectionProxyInfo;; 72 }; 73 namespace Internal {; 74 class TCheckHashRecursiveRemoveConsistency;; 75 }; 76}; 77 ; 78typedef ROOT::TMapTypeToTClass IdMap_t;; 79typedef ROOT::TMapDeclIdToTClass DeclIdMap_t;; 80 ; 81class TClass : public TDictionary {; 82 ; 83friend class TCling;; 84friend void ROOT::ResetClassVersion(TClass*, const char*, Short_t);; 85friend class ROOT::TGenericClassInfo;; 86friend class TProtoClass;; 87friend class ROOT::Internal::TCheckHashRecursiveRemoveConsistency;; 88friend class TStreamerInfo;; 89 ; 90public:; 91 // TClass status bits; 92 enum EStatusBits {; 93 kReservedLoading = BIT(7), // Internal status bits, set and reset only during initialization; 94 ; 95 /* had kClassSaved = BIT(12), */; 96 kHasLocalHashMember = BIT(14),; 97 kIgnoreTObjectStreamer = BIT(15),; 98 kUnloaded = BIT(16), // The library containing the dictionary for this class was; 99 // loaded and has been unloaded from memory.; 100 kIsTObject = BIT(17),; 101 kIsForeign = BIT(18),; 102 /* had kIsEmulation = BIT(19), // Depreca",MatchSource.WIKI,doc/v632/TClass_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/TClass_8h_source.html
https://root.cern/doc/v632/TClass_8h_source.html:4430,Performance,load,loaded,4430,"m = 1, // Used since v3.3; 111 kReflexNoComment = 2, // Up to v5.34.18 (has no range/comment and no typedef at all); 112 kNoRange = 3, // Up to v5.17; 113 kWithTypeDef = 4, // Up to v5.34.18 and v5.99/06; 114 kReflex = 5, // Up to v5.34.18 (has no typedef at all); 115 kNoRangeCheck = 6, // Up to v5.34.18 and v5.99/06; 116 kNoBaseCheckSum = 7, // Up to v5.34.18 and v5.99/06; 117 kLatestCheckSum = 8; 118 };; 119 ; 120 // Describe the current state of the TClass itself.; 121 enum EState {; 122 kNoInfo, // The state has not yet been initialized, i.e. the TClass; 123 // was just created and/or there is no trace of it in the interpreter.; 124 kForwardDeclared, // The interpreted knows the entity is a class but that's it.; 125 kEmulated, // The information about the class only comes from a TStreamerInfo; 126 kInterpreted, // The class is described completely/only in the interpreter database.; 127 kHasTClassInit, // The class has a TClass proper bootstrap coming from a run; 128 // through rootcling/genreflex/TMetaUtils and the library; 129 // containing this dictionary has been loaded in memory.; 130 kLoaded = kHasTClassInit,; 131 kNamespaceForMeta // Very transient state necessary to bootstrap namespace entries; 132 // in ROOT Meta w/o interpreter information; 133 };; 134 ; 135 // ""Typed"" pointer that recalls how TClass::New allocated the object.; 136 // It is returned by TClass:NewObject and should be passed to TClass::DeleteArray or TClass::Destructor; 137 // to delete the object.; 138 // It is also used in TVirtualCollectionProxy for the same reasons.; 139 struct ObjectPtr; 140 {; 141 void *fPtr = nullptr;; 142 ; 143 TVirtualStreamerInfo *fAllocator = nullptr;; 144 ; 145 ObjectPtr(void *ptr = nullptr, TVirtualStreamerInfo *allocator = nullptr) : fPtr(ptr), fAllocator(allocator) {}; 146 ; 147 void *GetPtr() const { return fPtr; }; 148 ; 149 TVirtualStreamerInfo *GetAllocator() const { return fAllocator; }; 150 ; 151 operator bool() const { return fPtr != nullptr; }; 152 }",MatchSource.WIKI,doc/v632/TClass_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/TClass_8h_source.html
https://root.cern/doc/v632/TClass_8h_source.html:5579,Performance,perform,performed,5579,"assInit, // The class has a TClass proper bootstrap coming from a run; 128 // through rootcling/genreflex/TMetaUtils and the library; 129 // containing this dictionary has been loaded in memory.; 130 kLoaded = kHasTClassInit,; 131 kNamespaceForMeta // Very transient state necessary to bootstrap namespace entries; 132 // in ROOT Meta w/o interpreter information; 133 };; 134 ; 135 // ""Typed"" pointer that recalls how TClass::New allocated the object.; 136 // It is returned by TClass:NewObject and should be passed to TClass::DeleteArray or TClass::Destructor; 137 // to delete the object.; 138 // It is also used in TVirtualCollectionProxy for the same reasons.; 139 struct ObjectPtr; 140 {; 141 void *fPtr = nullptr;; 142 ; 143 TVirtualStreamerInfo *fAllocator = nullptr;; 144 ; 145 ObjectPtr(void *ptr = nullptr, TVirtualStreamerInfo *allocator = nullptr) : fPtr(ptr), fAllocator(allocator) {}; 146 ; 147 void *GetPtr() const { return fPtr; }; 148 ; 149 TVirtualStreamerInfo *GetAllocator() const { return fAllocator; }; 150 ; 151 operator bool() const { return fPtr != nullptr; }; 152 };; 153 ; 154private:; 155 ; 156 ; 157 ; 158 class TDeclNameRegistry {; 159 // A class which is used to collect decl names starting from normalised; 160 // names (typedef resolution is excluded here, just string manipulation; 161 // is performed). At the heart of the implementation, an unordered set.; 162 public:; 163 TDeclNameRegistry(Int_t verbLevel=0);; 164 void AddQualifiedName(const char *name);; 165 Bool_t HasDeclName(const char *name) const;; 166 ~TDeclNameRegistry();; 167 private:; 168 Int_t fVerbLevel=0;; 169 std::unordered_set<std::string> fClassNamesSet;; 170 mutable std::atomic_flag fSpinLock; // MSVC doesn't support = ATOMIC_FLAG_INIT;; 171 };; 172 ; 173 class InsertTClassInRegistryRAII {; 174 // Trivial RAII used to insert names in the registry; 175 TClass::EState& fState;; 176 const char* fName;; 177 TDeclNameRegistry& fNoInfoOrEmuOrFwdDeclNameRegistry;; 178 public:; 179 InsertTClas",MatchSource.WIKI,doc/v632/TClass_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/TClass_8h_source.html
https://root.cern/doc/v632/TClass_8h_source.html:6525,Performance,load,loading,6525," fPtr(ptr), fAllocator(allocator) {}; 146 ; 147 void *GetPtr() const { return fPtr; }; 148 ; 149 TVirtualStreamerInfo *GetAllocator() const { return fAllocator; }; 150 ; 151 operator bool() const { return fPtr != nullptr; }; 152 };; 153 ; 154private:; 155 ; 156 ; 157 ; 158 class TDeclNameRegistry {; 159 // A class which is used to collect decl names starting from normalised; 160 // names (typedef resolution is excluded here, just string manipulation; 161 // is performed). At the heart of the implementation, an unordered set.; 162 public:; 163 TDeclNameRegistry(Int_t verbLevel=0);; 164 void AddQualifiedName(const char *name);; 165 Bool_t HasDeclName(const char *name) const;; 166 ~TDeclNameRegistry();; 167 private:; 168 Int_t fVerbLevel=0;; 169 std::unordered_set<std::string> fClassNamesSet;; 170 mutable std::atomic_flag fSpinLock; // MSVC doesn't support = ATOMIC_FLAG_INIT;; 171 };; 172 ; 173 class InsertTClassInRegistryRAII {; 174 // Trivial RAII used to insert names in the registry; 175 TClass::EState& fState;; 176 const char* fName;; 177 TDeclNameRegistry& fNoInfoOrEmuOrFwdDeclNameRegistry;; 178 public:; 179 InsertTClassInRegistryRAII(TClass::EState &state, const char *name, TDeclNameRegistry &emuRegistry);; 180 ~InsertTClassInRegistryRAII();; 181 };; 182 ; 183 // TClass objects can be created as a result of opening a TFile (in which; 184 // they are in emulated mode) or as a result of loading the dictionary for; 185 // the corresponding class. When a dictionary is loaded any pre-existing; 186 // emulated TClass is replaced by the one created/coming from the dictionary.; 187 // To have a reference that always point to the 'current' TClass object for; 188 // a given class, one should use a TClassRef.; 189 // TClassRef works by holding on to the fPersistentRef which is updated; 190 // atomically whenever a TClass is replaced. During the replacement the; 191 // value of fPersistentRef is set to zero, leading the TClassRef to call; 192 // TClass::GetClass which is als",MatchSource.WIKI,doc/v632/TClass_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/TClass_8h_source.html
https://root.cern/doc/v632/TClass_8h_source.html:6606,Performance,load,loaded,6606,"2 public:; 163 TDeclNameRegistry(Int_t verbLevel=0);; 164 void AddQualifiedName(const char *name);; 165 Bool_t HasDeclName(const char *name) const;; 166 ~TDeclNameRegistry();; 167 private:; 168 Int_t fVerbLevel=0;; 169 std::unordered_set<std::string> fClassNamesSet;; 170 mutable std::atomic_flag fSpinLock; // MSVC doesn't support = ATOMIC_FLAG_INIT;; 171 };; 172 ; 173 class InsertTClassInRegistryRAII {; 174 // Trivial RAII used to insert names in the registry; 175 TClass::EState& fState;; 176 const char* fName;; 177 TDeclNameRegistry& fNoInfoOrEmuOrFwdDeclNameRegistry;; 178 public:; 179 InsertTClassInRegistryRAII(TClass::EState &state, const char *name, TDeclNameRegistry &emuRegistry);; 180 ~InsertTClassInRegistryRAII();; 181 };; 182 ; 183 // TClass objects can be created as a result of opening a TFile (in which; 184 // they are in emulated mode) or as a result of loading the dictionary for; 185 // the corresponding class. When a dictionary is loaded any pre-existing; 186 // emulated TClass is replaced by the one created/coming from the dictionary.; 187 // To have a reference that always point to the 'current' TClass object for; 188 // a given class, one should use a TClassRef.; 189 // TClassRef works by holding on to the fPersistentRef which is updated; 190 // atomically whenever a TClass is replaced. During the replacement the; 191 // value of fPersistentRef is set to zero, leading the TClassRef to call; 192 // TClass::GetClass which is also locked by the replacement. At the end; 193 // of the replacement, fPersistentRef points to the new TClass object.; 194 std::atomic<TClass**> fPersistentRef;//!Persistent address of pointer to this TClass object and its successors.; 195 ; 196 typedef std::atomic<std::map<std::string, TObjArray*>*> ConvSIMap_t;; 197 ; 198 mutable TObjArray *fStreamerInfo; //Array of TVirtualStreamerInfo; 199 mutable ConvSIMap_t fConversionStreamerInfo; //Array of the streamer infos derived from another class.; 200 TList *fRealData; //linked list",MatchSource.WIKI,doc/v632/TClass_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/TClass_8h_source.html
https://root.cern/doc/v632/TClass_8h_source.html:11669,Performance,load,loaded,11669,"version Streamer member function.; 243 Int_t fSizeof; //Sizeof the class.; 244 ; 245 std::atomic<Char_t> fCanSplit; //!Indicates whether this class can be split or not. Values are -1, 0, 1, 2; 246 ; 247 // Bit field; 248 /// Indicates whether this class represents a pair and was not created from a dictionary nor interpreter info but has; 249 /// compiler compatible offset and size (and all the info is in the StreamerInfo per se); 250 Bool_t fIsSyntheticPair : 1; //!; 251 ; 252 /// @brief The class has a Streamer method and it is implemented by the user or an older (not StreamerInfo based) automatic streamer.; 253 Bool_t fHasCustomStreamerMember : 1; //!; 254 ; 255 mutable std::atomic<Long_t> fProperty; //!Property See TClass::Property() for details; 256 mutable Long_t fClassProperty; //!C++ Property of the class (is abstract, has virtual table, etc.); 257 ; 258 // fHasRootPcmInfo needs to be atomic as long as GetListOfBases needs to modify it.; 259 std::atomic<Bool_t> fHasRootPcmInfo; //!Whether info was loaded from a root pcm.; 260 mutable std::atomic<Bool_t> fCanLoadClassInfo; //!Indicates whether the ClassInfo is supposed to be available.; 261 mutable std::atomic<Bool_t> fIsOffsetStreamerSet; //!saved remember if fOffsetStreamer has been set.; 262 mutable std::atomic<Bool_t> fVersionUsed; //!Indicates whether GetClassVersion has been called; 263 ; 264 enum class ERuntimeProperties : UChar_t {; 265 kNotInitialized = 0,; 266 kSet = BIT(0),; 267 // kInconsistent when kSet & !kConsistent.; 268 kConsistentHash = BIT(1); 269 };; 270 friend bool operator&(UChar_t l, ERuntimeProperties r) {; 271 return l & static_cast<UChar_t>(r);; 272 }; 273 mutable std::atomic<UChar_t> fRuntimeProperties; //! Properties that can only be evaluated at run-time; 274 ; 275 mutable Longptr_t fOffsetStreamer; //!saved info to call Streamer; 276 Int_t fStreamerType; //!cached of the streaming method to use; 277 EState fState; //!Current 'state' of the class (Emulated,Interpreted,Loaded); 278 ",MatchSource.WIKI,doc/v632/TClass_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/TClass_8h_source.html
https://root.cern/doc/v632/TClass_8h_source.html:12524,Performance,cache,cached,12524,"+ Property of the class (is abstract, has virtual table, etc.); 257 ; 258 // fHasRootPcmInfo needs to be atomic as long as GetListOfBases needs to modify it.; 259 std::atomic<Bool_t> fHasRootPcmInfo; //!Whether info was loaded from a root pcm.; 260 mutable std::atomic<Bool_t> fCanLoadClassInfo; //!Indicates whether the ClassInfo is supposed to be available.; 261 mutable std::atomic<Bool_t> fIsOffsetStreamerSet; //!saved remember if fOffsetStreamer has been set.; 262 mutable std::atomic<Bool_t> fVersionUsed; //!Indicates whether GetClassVersion has been called; 263 ; 264 enum class ERuntimeProperties : UChar_t {; 265 kNotInitialized = 0,; 266 kSet = BIT(0),; 267 // kInconsistent when kSet & !kConsistent.; 268 kConsistentHash = BIT(1); 269 };; 270 friend bool operator&(UChar_t l, ERuntimeProperties r) {; 271 return l & static_cast<UChar_t>(r);; 272 }; 273 mutable std::atomic<UChar_t> fRuntimeProperties; //! Properties that can only be evaluated at run-time; 274 ; 275 mutable Longptr_t fOffsetStreamer; //!saved info to call Streamer; 276 Int_t fStreamerType; //!cached of the streaming method to use; 277 EState fState; //!Current 'state' of the class (Emulated,Interpreted,Loaded); 278 mutable std::atomic<TVirtualStreamerInfo*> fCurrentInfo; //!cached current streamer info.; 279 mutable std::atomic<TVirtualStreamerInfo*> fLastReadInfo; //!cached streamer info used in the last read.; 280 TVirtualRefProxy *fRefProxy; //!Pointer to reference proxy if this class represents a reference; 281 ROOT::Detail::TSchemaRuleSet *fSchemaRules; //! Schema evolution rules; 282 ; 283 typedef void (*StreamerImpl_t)(const TClass* pThis, void *obj, TBuffer &b, const TClass *onfile_class);; 284#ifdef R__NO_ATOMIC_FUNCTION_POINTER; 285 mutable StreamerImpl_t fStreamerImpl; //! Pointer to the function implementing streaming for this class; 286#else; 287 mutable std::atomic<StreamerImpl_t> fStreamerImpl; //! Pointer to the function implementing streaming for this class; 288#endif; 289 ; 290 Bool_",MatchSource.WIKI,doc/v632/TClass_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/TClass_8h_source.html
https://root.cern/doc/v632/TClass_8h_source.html:12709,Performance,cache,cached,12709,"+ Property of the class (is abstract, has virtual table, etc.); 257 ; 258 // fHasRootPcmInfo needs to be atomic as long as GetListOfBases needs to modify it.; 259 std::atomic<Bool_t> fHasRootPcmInfo; //!Whether info was loaded from a root pcm.; 260 mutable std::atomic<Bool_t> fCanLoadClassInfo; //!Indicates whether the ClassInfo is supposed to be available.; 261 mutable std::atomic<Bool_t> fIsOffsetStreamerSet; //!saved remember if fOffsetStreamer has been set.; 262 mutable std::atomic<Bool_t> fVersionUsed; //!Indicates whether GetClassVersion has been called; 263 ; 264 enum class ERuntimeProperties : UChar_t {; 265 kNotInitialized = 0,; 266 kSet = BIT(0),; 267 // kInconsistent when kSet & !kConsistent.; 268 kConsistentHash = BIT(1); 269 };; 270 friend bool operator&(UChar_t l, ERuntimeProperties r) {; 271 return l & static_cast<UChar_t>(r);; 272 }; 273 mutable std::atomic<UChar_t> fRuntimeProperties; //! Properties that can only be evaluated at run-time; 274 ; 275 mutable Longptr_t fOffsetStreamer; //!saved info to call Streamer; 276 Int_t fStreamerType; //!cached of the streaming method to use; 277 EState fState; //!Current 'state' of the class (Emulated,Interpreted,Loaded); 278 mutable std::atomic<TVirtualStreamerInfo*> fCurrentInfo; //!cached current streamer info.; 279 mutable std::atomic<TVirtualStreamerInfo*> fLastReadInfo; //!cached streamer info used in the last read.; 280 TVirtualRefProxy *fRefProxy; //!Pointer to reference proxy if this class represents a reference; 281 ROOT::Detail::TSchemaRuleSet *fSchemaRules; //! Schema evolution rules; 282 ; 283 typedef void (*StreamerImpl_t)(const TClass* pThis, void *obj, TBuffer &b, const TClass *onfile_class);; 284#ifdef R__NO_ATOMIC_FUNCTION_POINTER; 285 mutable StreamerImpl_t fStreamerImpl; //! Pointer to the function implementing streaming for this class; 286#else; 287 mutable std::atomic<StreamerImpl_t> fStreamerImpl; //! Pointer to the function implementing streaming for this class; 288#endif; 289 ; 290 Bool_",MatchSource.WIKI,doc/v632/TClass_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/TClass_8h_source.html
https://root.cern/doc/v632/TClass_8h_source.html:12805,Performance,cache,cached,12805,"o be available.; 261 mutable std::atomic<Bool_t> fIsOffsetStreamerSet; //!saved remember if fOffsetStreamer has been set.; 262 mutable std::atomic<Bool_t> fVersionUsed; //!Indicates whether GetClassVersion has been called; 263 ; 264 enum class ERuntimeProperties : UChar_t {; 265 kNotInitialized = 0,; 266 kSet = BIT(0),; 267 // kInconsistent when kSet & !kConsistent.; 268 kConsistentHash = BIT(1); 269 };; 270 friend bool operator&(UChar_t l, ERuntimeProperties r) {; 271 return l & static_cast<UChar_t>(r);; 272 }; 273 mutable std::atomic<UChar_t> fRuntimeProperties; //! Properties that can only be evaluated at run-time; 274 ; 275 mutable Longptr_t fOffsetStreamer; //!saved info to call Streamer; 276 Int_t fStreamerType; //!cached of the streaming method to use; 277 EState fState; //!Current 'state' of the class (Emulated,Interpreted,Loaded); 278 mutable std::atomic<TVirtualStreamerInfo*> fCurrentInfo; //!cached current streamer info.; 279 mutable std::atomic<TVirtualStreamerInfo*> fLastReadInfo; //!cached streamer info used in the last read.; 280 TVirtualRefProxy *fRefProxy; //!Pointer to reference proxy if this class represents a reference; 281 ROOT::Detail::TSchemaRuleSet *fSchemaRules; //! Schema evolution rules; 282 ; 283 typedef void (*StreamerImpl_t)(const TClass* pThis, void *obj, TBuffer &b, const TClass *onfile_class);; 284#ifdef R__NO_ATOMIC_FUNCTION_POINTER; 285 mutable StreamerImpl_t fStreamerImpl; //! Pointer to the function implementing streaming for this class; 286#else; 287 mutable std::atomic<StreamerImpl_t> fStreamerImpl; //! Pointer to the function implementing streaming for this class; 288#endif; 289 ; 290 Bool_t CanSplitBaseAllow();; 291 TListOfFunctions *GetMethodList();; 292 TMethod *GetClassMethod(Longptr_t faddr);; 293 TMethod *FindClassOrBaseMethodWithId(DeclId_t faddr);; 294 Int_t GetBaseClassOffsetRecurse(const TClass *toBase);; 295 void Init(const char *name, Version_t cversion, const std::type_info *info,; 296 TVirtualIsAProxy *isa,; 297 ",MatchSource.WIKI,doc/v632/TClass_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/TClass_8h_source.html
https://root.cern/doc/v632/TClass_8h_source.html:17182,Performance,load,load,17182,,MatchSource.WIKI,doc/v632/TClass_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/TClass_8h_source.html
https://root.cern/doc/v632/TClass_8h_source.html:21233,Performance,load,load,21233,"eckSum(ECheckSum code = kCurrentCheckSum) const;; 412 UInt_t GetCheckSum(Bool_t &isvalid) const;; 413 UInt_t GetCheckSum(ECheckSum code, Bool_t &isvalid) const;; 414 TVirtualCollectionProxy *GetCollectionProxy() const;; 415 TVirtualIsAProxy *GetIsAProxy() const;; 416 TMethod *GetClassMethod(const char *name, const char *params, Bool_t objectIsConst = kFALSE);; 417 TMethod *GetClassMethodWithPrototype(const char *name, const char *proto,; 418 Bool_t objectIsConst = kFALSE,; 419 ROOT::EFunctionMatchMode mode = ROOT::kConversionMatch);; 420 Version_t GetClassVersion() const {; 421 if (!fVersionUsed.load(std::memory_order_relaxed)); 422 fVersionUsed = kTRUE;; 423 return fClassVersion;; 424 }; 425 Int_t GetClassSize() const { return Size(); }; 426 TDataMember *GetDataMember(const char *datamember) const;; 427 Longptr_t GetDataMemberOffset(const char *membername) const;; 428 const char *GetDeclFileName() const;; 429 Short_t GetDeclFileLine() const { return fDeclFileLine; }; 430 ROOT::DelFunc_t GetDelete() const;; 431 ROOT::DesFunc_t GetDestructor() const;; 432 ROOT::DelArrFunc_t GetDeleteArray() const;; 433 ClassInfo_t *GetClassInfo() const {; 434 if (fCanLoadClassInfo); 435 LoadClassInfo();; 436 return fClassInfo;; 437 }; 438 const char *GetContextMenuTitle() const { return fContextMenuTitle; }; 439 TVirtualStreamerInfo *GetCurrentStreamerInfo() {; 440 auto current = fCurrentInfo.load(std::memory_order_relaxed);; 441 if (current) return current;; 442 else return DetermineCurrentStreamerInfo();; 443 }; 444 TVirtualStreamerInfo *GetLastReadInfo() const { return fLastReadInfo; }; 445 void SetLastReadInfo(TVirtualStreamerInfo *info) { fLastReadInfo = info; }; 446 TList *GetListOfDataMembers(Bool_t load = kTRUE);; 447 TList *GetListOfUsingDataMembers(Bool_t load = kTRUE);; 448 TList *GetListOfEnums(Bool_t load = kTRUE);; 449 TList *GetListOfFunctionTemplates(Bool_t load = kTRUE);; 450 TList *GetListOfBases();; 451 TList *GetListOfMethods(Bool_t load = kTRUE);; 452 TCollection ",MatchSource.WIKI,doc/v632/TClass_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/TClass_8h_source.html
https://root.cern/doc/v632/TClass_8h_source.html:22028,Performance,load,load,22028,,MatchSource.WIKI,doc/v632/TClass_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/TClass_8h_source.html
https://root.cern/doc/v632/TClass_8h_source.html:22348,Performance,load,load,22348,,MatchSource.WIKI,doc/v632/TClass_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/TClass_8h_source.html
https://root.cern/doc/v632/TClass_8h_source.html:22408,Performance,load,load,22408,,MatchSource.WIKI,doc/v632/TClass_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/TClass_8h_source.html
https://root.cern/doc/v632/TClass_8h_source.html:22457,Performance,load,load,22457,,MatchSource.WIKI,doc/v632/TClass_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/TClass_8h_source.html
https://root.cern/doc/v632/TClass_8h_source.html:22518,Performance,load,load,22518,,MatchSource.WIKI,doc/v632/TClass_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/TClass_8h_source.html
https://root.cern/doc/v632/TClass_8h_source.html:22599,Performance,load,load,22599,,MatchSource.WIKI,doc/v632/TClass_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/TClass_8h_source.html
https://root.cern/doc/v632/TClass_8h_source.html:22793,Performance,load,load,22793,,MatchSource.WIKI,doc/v632/TClass_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/TClass_8h_source.html
https://root.cern/doc/v632/TClass_8h_source.html:22857,Performance,load,load,22857,,MatchSource.WIKI,doc/v632/TClass_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/TClass_8h_source.html
https://root.cern/doc/v632/TClass_8h_source.html:25698,Performance,load,load,25698,"GetStreamer() const;; 490 ClassStreamerFunc_t GetStreamerFunc() const;; 491 ClassConvStreamerFunc_t GetConvStreamerFunc() const;; 492 const TObjArray *GetStreamerInfos() const { return fStreamerInfo; }; 493 TVirtualStreamerInfo *GetStreamerInfo(Int_t version=0, Bool_t isTransient = kFALSE) const;; 494 TVirtualStreamerInfo *GetStreamerInfoAbstractEmulated(Int_t version=0) const;; 495 TVirtualStreamerInfo *FindStreamerInfoAbstractEmulated(UInt_t checksum) const;; 496 const std::type_info *GetTypeInfo() const { return fTypeInfo; };; 497 ; 498 /// @brief Return 'true' if we can guarantee that if this class (or any class in; 499 /// this class inheritance hierarchy) overload TObject::Hash it also starts; 500 /// the RecursiveRemove process from its own destructor.; 501 Bool_t HasConsistentHashMember(); 502 {; 503 if (!fRuntimeProperties); 504 SetRuntimeProperties();; 505 return fRuntimeProperties.load() & ERuntimeProperties::kConsistentHash;; 506 }; 507 /// @brief The class has a Streamer method and it is implemented by the user or an older (not StreamerInfo based) automatic streamer.; 508 Bool_t HasCustomStreamerMember() const { return fHasCustomStreamerMember; }; 509 Bool_t HasDictionary() const;; 510 static Bool_t HasDictionarySelection(const char* clname);; 511 Bool_t HasLocalHashMember() const;; 512 void GetMissingDictionaries(THashTable& result, bool recurse = false);; 513 void IgnoreTObjectStreamer(Bool_t ignore=kTRUE);; 514 Bool_t InheritsFrom(const char *cl) const override;; 515 Bool_t InheritsFrom(const TClass *cl) const override;; 516 void InterpretedShowMembers(void* obj, TMemberInspector &insp, Bool_t isTransient);; 517 Bool_t IsFolder() const override { return kTRUE; }; 518 Bool_t IsLoaded() const;; 519 Bool_t IsForeign() const;; 520 Bool_t IsStartingWithTObject() const;; 521 Bool_t IsSyntheticPair() const { return fIsSyntheticPair; }; 522 Bool_t IsVersioned() const { return !( GetClassVersion()<=1 && IsForeign() ); }; 523 Bool_t IsTObject() const;; 524 stat",MatchSource.WIKI,doc/v632/TClass_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/TClass_8h_source.html
https://root.cern/doc/v632/TClass_8h_source.html:30124,Performance,load,load,30124,"62 void SetResetAfterMerge(ROOT::ResetAfterMergeFunc_t resetFunc);; 563 void SetNew(ROOT::NewFunc_t newFunc);; 564 void SetNewArray(ROOT::NewArrFunc_t newArrayFunc);; 565 TVirtualStreamerInfo *SetStreamerInfo(Int_t version, const char *info="""");; 566 void SetUnloaded();; 567 Int_t WriteBuffer(TBuffer &b, void *pointer, const char *info="""");; 568 ; 569 void AdoptReferenceProxy(TVirtualRefProxy* proxy);; 570 void AdoptStreamer(TClassStreamer *strm);; 571 void AdoptMemberStreamer(const char *name, TMemberStreamer *strm);; 572 void SetMemberStreamer(const char *name, MemberStreamerFunc_t strm);; 573 void SetStreamerFunc(ClassStreamerFunc_t strm);; 574 void SetConvStreamerFunc(ClassConvStreamerFunc_t strm);; 575 ; 576 // Function to retrieve the TClass object and dictionary function; 577 static void AddClass(TClass *cl);; 578 static void AddClassToDeclIdMap(TDictionary::DeclId_t id, TClass* cl);; 579 static void RemoveClass(TClass *cl);; 580 static void RemoveClassDeclId(TDictionary::DeclId_t id);; 581 static TClass *GetClass(const char *name, Bool_t load = kTRUE, Bool_t silent = kFALSE);; 582 static TClass *GetClass(const char *name, Bool_t load, Bool_t silent, size_t hint_pair_offset, size_t hint_pair_size);; 583 static TClass *GetClass(const std::type_info &typeinfo, Bool_t load = kTRUE, Bool_t silent = kFALSE, size_t hint_pair_offset = 0, size_t hint_pair_size = 0);; 584 static TClass *GetClass(ClassInfo_t *info, Bool_t load = kTRUE, Bool_t silent = kFALSE);; 585 template<typename T>; 586 static TClass *GetClass(Bool_t load = kTRUE, Bool_t silent = kFALSE);; 587 static Bool_t GetClass(DeclId_t id, std::vector<TClass*> &classes);; 588 static DictFuncPtr_t GetDict (const char *cname);; 589 static DictFuncPtr_t GetDict (const std::type_info &info);; 590 ; 591 static Int_t AutoBrowse(TObject *obj, TBrowser *browser);; 592 static ENewType IsCallingNew();; 593 static TClass *Load(TBuffer &b);; 594 void Store(TBuffer &b) const;; 595 ; 596 // Pseudo-method apply to the 'obj'.",MatchSource.WIKI,doc/v632/TClass_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/TClass_8h_source.html
https://root.cern/doc/v632/TClass_8h_source.html:30217,Performance,load,load,30217,"62 void SetResetAfterMerge(ROOT::ResetAfterMergeFunc_t resetFunc);; 563 void SetNew(ROOT::NewFunc_t newFunc);; 564 void SetNewArray(ROOT::NewArrFunc_t newArrayFunc);; 565 TVirtualStreamerInfo *SetStreamerInfo(Int_t version, const char *info="""");; 566 void SetUnloaded();; 567 Int_t WriteBuffer(TBuffer &b, void *pointer, const char *info="""");; 568 ; 569 void AdoptReferenceProxy(TVirtualRefProxy* proxy);; 570 void AdoptStreamer(TClassStreamer *strm);; 571 void AdoptMemberStreamer(const char *name, TMemberStreamer *strm);; 572 void SetMemberStreamer(const char *name, MemberStreamerFunc_t strm);; 573 void SetStreamerFunc(ClassStreamerFunc_t strm);; 574 void SetConvStreamerFunc(ClassConvStreamerFunc_t strm);; 575 ; 576 // Function to retrieve the TClass object and dictionary function; 577 static void AddClass(TClass *cl);; 578 static void AddClassToDeclIdMap(TDictionary::DeclId_t id, TClass* cl);; 579 static void RemoveClass(TClass *cl);; 580 static void RemoveClassDeclId(TDictionary::DeclId_t id);; 581 static TClass *GetClass(const char *name, Bool_t load = kTRUE, Bool_t silent = kFALSE);; 582 static TClass *GetClass(const char *name, Bool_t load, Bool_t silent, size_t hint_pair_offset, size_t hint_pair_size);; 583 static TClass *GetClass(const std::type_info &typeinfo, Bool_t load = kTRUE, Bool_t silent = kFALSE, size_t hint_pair_offset = 0, size_t hint_pair_size = 0);; 584 static TClass *GetClass(ClassInfo_t *info, Bool_t load = kTRUE, Bool_t silent = kFALSE);; 585 template<typename T>; 586 static TClass *GetClass(Bool_t load = kTRUE, Bool_t silent = kFALSE);; 587 static Bool_t GetClass(DeclId_t id, std::vector<TClass*> &classes);; 588 static DictFuncPtr_t GetDict (const char *cname);; 589 static DictFuncPtr_t GetDict (const std::type_info &info);; 590 ; 591 static Int_t AutoBrowse(TObject *obj, TBrowser *browser);; 592 static ENewType IsCallingNew();; 593 static TClass *Load(TBuffer &b);; 594 void Store(TBuffer &b) const;; 595 ; 596 // Pseudo-method apply to the 'obj'.",MatchSource.WIKI,doc/v632/TClass_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/TClass_8h_source.html
https://root.cern/doc/v632/TClass_8h_source.html:30355,Performance,load,load,30355,"62 void SetResetAfterMerge(ROOT::ResetAfterMergeFunc_t resetFunc);; 563 void SetNew(ROOT::NewFunc_t newFunc);; 564 void SetNewArray(ROOT::NewArrFunc_t newArrayFunc);; 565 TVirtualStreamerInfo *SetStreamerInfo(Int_t version, const char *info="""");; 566 void SetUnloaded();; 567 Int_t WriteBuffer(TBuffer &b, void *pointer, const char *info="""");; 568 ; 569 void AdoptReferenceProxy(TVirtualRefProxy* proxy);; 570 void AdoptStreamer(TClassStreamer *strm);; 571 void AdoptMemberStreamer(const char *name, TMemberStreamer *strm);; 572 void SetMemberStreamer(const char *name, MemberStreamerFunc_t strm);; 573 void SetStreamerFunc(ClassStreamerFunc_t strm);; 574 void SetConvStreamerFunc(ClassConvStreamerFunc_t strm);; 575 ; 576 // Function to retrieve the TClass object and dictionary function; 577 static void AddClass(TClass *cl);; 578 static void AddClassToDeclIdMap(TDictionary::DeclId_t id, TClass* cl);; 579 static void RemoveClass(TClass *cl);; 580 static void RemoveClassDeclId(TDictionary::DeclId_t id);; 581 static TClass *GetClass(const char *name, Bool_t load = kTRUE, Bool_t silent = kFALSE);; 582 static TClass *GetClass(const char *name, Bool_t load, Bool_t silent, size_t hint_pair_offset, size_t hint_pair_size);; 583 static TClass *GetClass(const std::type_info &typeinfo, Bool_t load = kTRUE, Bool_t silent = kFALSE, size_t hint_pair_offset = 0, size_t hint_pair_size = 0);; 584 static TClass *GetClass(ClassInfo_t *info, Bool_t load = kTRUE, Bool_t silent = kFALSE);; 585 template<typename T>; 586 static TClass *GetClass(Bool_t load = kTRUE, Bool_t silent = kFALSE);; 587 static Bool_t GetClass(DeclId_t id, std::vector<TClass*> &classes);; 588 static DictFuncPtr_t GetDict (const char *cname);; 589 static DictFuncPtr_t GetDict (const std::type_info &info);; 590 ; 591 static Int_t AutoBrowse(TObject *obj, TBrowser *browser);; 592 static ENewType IsCallingNew();; 593 static TClass *Load(TBuffer &b);; 594 void Store(TBuffer &b) const;; 595 ; 596 // Pseudo-method apply to the 'obj'.",MatchSource.WIKI,doc/v632/TClass_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/TClass_8h_source.html
https://root.cern/doc/v632/TClass_8h_source.html:30505,Performance,load,load,30505,"62 void SetResetAfterMerge(ROOT::ResetAfterMergeFunc_t resetFunc);; 563 void SetNew(ROOT::NewFunc_t newFunc);; 564 void SetNewArray(ROOT::NewArrFunc_t newArrayFunc);; 565 TVirtualStreamerInfo *SetStreamerInfo(Int_t version, const char *info="""");; 566 void SetUnloaded();; 567 Int_t WriteBuffer(TBuffer &b, void *pointer, const char *info="""");; 568 ; 569 void AdoptReferenceProxy(TVirtualRefProxy* proxy);; 570 void AdoptStreamer(TClassStreamer *strm);; 571 void AdoptMemberStreamer(const char *name, TMemberStreamer *strm);; 572 void SetMemberStreamer(const char *name, MemberStreamerFunc_t strm);; 573 void SetStreamerFunc(ClassStreamerFunc_t strm);; 574 void SetConvStreamerFunc(ClassConvStreamerFunc_t strm);; 575 ; 576 // Function to retrieve the TClass object and dictionary function; 577 static void AddClass(TClass *cl);; 578 static void AddClassToDeclIdMap(TDictionary::DeclId_t id, TClass* cl);; 579 static void RemoveClass(TClass *cl);; 580 static void RemoveClassDeclId(TDictionary::DeclId_t id);; 581 static TClass *GetClass(const char *name, Bool_t load = kTRUE, Bool_t silent = kFALSE);; 582 static TClass *GetClass(const char *name, Bool_t load, Bool_t silent, size_t hint_pair_offset, size_t hint_pair_size);; 583 static TClass *GetClass(const std::type_info &typeinfo, Bool_t load = kTRUE, Bool_t silent = kFALSE, size_t hint_pair_offset = 0, size_t hint_pair_size = 0);; 584 static TClass *GetClass(ClassInfo_t *info, Bool_t load = kTRUE, Bool_t silent = kFALSE);; 585 template<typename T>; 586 static TClass *GetClass(Bool_t load = kTRUE, Bool_t silent = kFALSE);; 587 static Bool_t GetClass(DeclId_t id, std::vector<TClass*> &classes);; 588 static DictFuncPtr_t GetDict (const char *cname);; 589 static DictFuncPtr_t GetDict (const std::type_info &info);; 590 ; 591 static Int_t AutoBrowse(TObject *obj, TBrowser *browser);; 592 static ENewType IsCallingNew();; 593 static TClass *Load(TBuffer &b);; 594 void Store(TBuffer &b) const;; 595 ; 596 // Pseudo-method apply to the 'obj'.",MatchSource.WIKI,doc/v632/TClass_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/TClass_8h_source.html
https://root.cern/doc/v632/TClass_8h_source.html:30606,Performance,load,load,30606,"62 void SetResetAfterMerge(ROOT::ResetAfterMergeFunc_t resetFunc);; 563 void SetNew(ROOT::NewFunc_t newFunc);; 564 void SetNewArray(ROOT::NewArrFunc_t newArrayFunc);; 565 TVirtualStreamerInfo *SetStreamerInfo(Int_t version, const char *info="""");; 566 void SetUnloaded();; 567 Int_t WriteBuffer(TBuffer &b, void *pointer, const char *info="""");; 568 ; 569 void AdoptReferenceProxy(TVirtualRefProxy* proxy);; 570 void AdoptStreamer(TClassStreamer *strm);; 571 void AdoptMemberStreamer(const char *name, TMemberStreamer *strm);; 572 void SetMemberStreamer(const char *name, MemberStreamerFunc_t strm);; 573 void SetStreamerFunc(ClassStreamerFunc_t strm);; 574 void SetConvStreamerFunc(ClassConvStreamerFunc_t strm);; 575 ; 576 // Function to retrieve the TClass object and dictionary function; 577 static void AddClass(TClass *cl);; 578 static void AddClassToDeclIdMap(TDictionary::DeclId_t id, TClass* cl);; 579 static void RemoveClass(TClass *cl);; 580 static void RemoveClassDeclId(TDictionary::DeclId_t id);; 581 static TClass *GetClass(const char *name, Bool_t load = kTRUE, Bool_t silent = kFALSE);; 582 static TClass *GetClass(const char *name, Bool_t load, Bool_t silent, size_t hint_pair_offset, size_t hint_pair_size);; 583 static TClass *GetClass(const std::type_info &typeinfo, Bool_t load = kTRUE, Bool_t silent = kFALSE, size_t hint_pair_offset = 0, size_t hint_pair_size = 0);; 584 static TClass *GetClass(ClassInfo_t *info, Bool_t load = kTRUE, Bool_t silent = kFALSE);; 585 template<typename T>; 586 static TClass *GetClass(Bool_t load = kTRUE, Bool_t silent = kFALSE);; 587 static Bool_t GetClass(DeclId_t id, std::vector<TClass*> &classes);; 588 static DictFuncPtr_t GetDict (const char *cname);; 589 static DictFuncPtr_t GetDict (const std::type_info &info);; 590 ; 591 static Int_t AutoBrowse(TObject *obj, TBrowser *browser);; 592 static ENewType IsCallingNew();; 593 static TClass *Load(TBuffer &b);; 594 void Store(TBuffer &b) const;; 595 ; 596 // Pseudo-method apply to the 'obj'.",MatchSource.WIKI,doc/v632/TClass_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/TClass_8h_source.html
https://root.cern/doc/v632/TClass_8h_source.html:31779,Performance,perform,performance,31779,"t *info, Bool_t load = kTRUE, Bool_t silent = kFALSE);; 585 template<typename T>; 586 static TClass *GetClass(Bool_t load = kTRUE, Bool_t silent = kFALSE);; 587 static Bool_t GetClass(DeclId_t id, std::vector<TClass*> &classes);; 588 static DictFuncPtr_t GetDict (const char *cname);; 589 static DictFuncPtr_t GetDict (const std::type_info &info);; 590 ; 591 static Int_t AutoBrowse(TObject *obj, TBrowser *browser);; 592 static ENewType IsCallingNew();; 593 static TClass *Load(TBuffer &b);; 594 void Store(TBuffer &b) const;; 595 ; 596 // Pseudo-method apply to the 'obj'. In particular those are used to; 597 // implement TObject like methods for non-TObject classes.; 598 Int_t Browse(void *obj, TBrowser *b) const;; 599 void DeleteArray(void *ary, Bool_t dtorOnly = kFALSE);; 600 void DeleteArray(ObjectPtr ary, Bool_t dtorOnly = kFALSE);; 601 void Destructor(void *obj, Bool_t dtorOnly = kFALSE);; 602 void Destructor(ObjectPtr obj, Bool_t dtorOnly = kFALSE);; 603 void *DynamicCast(const TClass *base, void *obj, Bool_t up = kTRUE);; 604 const void *DynamicCast(const TClass *base, const void *obj, Bool_t up = kTRUE);; 605 Bool_t IsFolder(void *obj) const;; 606 ; 607 inline void Streamer(void *obj, TBuffer &b, const TClass *onfile_class = nullptr) const; 608 {; 609 // Inline for performance, skipping one function call.; 610#ifdef R__NO_ATOMIC_FUNCTION_POINTER; 611 fStreamerImpl(this,obj,b,onfile_class);; 612#else; 613 auto t = fStreamerImpl.load();; 614 t(this,obj,b,onfile_class);; 615#endif; 616 }; 617 ; 618 ClassDefOverride(TClass,0) //Dictionary containing class information; 619};; 620 ; 621namespace ROOT {; 622namespace Internal {; 623template <typename T>; 624TClass *GetClassHelper(Bool_t, Bool_t, std::true_type); 625{; 626 return T::Class();; 627}; 628 ; 629template <typename T>; 630struct TClassGetClassHelper {; 631 static TClass *GetClass(Bool_t load, Bool_t silent) {; 632 return TClass::GetClass(typeid(T), load, silent);; 633 }; 634};; 635 ; 636template <typename F, ",MatchSource.WIKI,doc/v632/TClass_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/TClass_8h_source.html
https://root.cern/doc/v632/TClass_8h_source.html:31944,Performance,load,load,31944,,MatchSource.WIKI,doc/v632/TClass_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/TClass_8h_source.html
https://root.cern/doc/v632/TClass_8h_source.html:32365,Performance,load,load,32365,,MatchSource.WIKI,doc/v632/TClass_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/TClass_8h_source.html
https://root.cern/doc/v632/TClass_8h_source.html:32428,Performance,load,load,32428,,MatchSource.WIKI,doc/v632/TClass_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/TClass_8h_source.html
https://root.cern/doc/v632/TClass_8h_source.html:32589,Performance,load,load,32589,,MatchSource.WIKI,doc/v632/TClass_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/TClass_8h_source.html
https://root.cern/doc/v632/TClass_8h_source.html:32754,Performance,load,load,32754,,MatchSource.WIKI,doc/v632/TClass_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/TClass_8h_source.html
https://root.cern/doc/v632/TClass_8h_source.html:32886,Performance,load,load,32886,,MatchSource.WIKI,doc/v632/TClass_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/TClass_8h_source.html
https://root.cern/doc/v632/TClass_8h_source.html:32976,Performance,load,load,32976,"lass);; 615#endif; 616 }; 617 ; 618 ClassDefOverride(TClass,0) //Dictionary containing class information; 619};; 620 ; 621namespace ROOT {; 622namespace Internal {; 623template <typename T>; 624TClass *GetClassHelper(Bool_t, Bool_t, std::true_type); 625{; 626 return T::Class();; 627}; 628 ; 629template <typename T>; 630struct TClassGetClassHelper {; 631 static TClass *GetClass(Bool_t load, Bool_t silent) {; 632 return TClass::GetClass(typeid(T), load, silent);; 633 }; 634};; 635 ; 636template <typename F, typename S>; 637struct TClassGetClassHelper<std::pair<F, S> > {; 638 static TClass *GetClass(Bool_t load, Bool_t silent) {; 639 using pair_t = std::pair<F,S>;; 640 size_t hint_offset = offsetof(pair_t, second);; 641 return TClass::GetClass(typeid(std::pair<F, S>), load, silent, hint_offset, sizeof(std::pair<F,S>));; 642 }; 643};; 644 ; 645template <typename T>; 646TClass *GetClassHelper(Bool_t load, Bool_t silent, std::false_type); 647{; 648 return TClassGetClassHelper<T>::GetClass(load, silent);; 649}; 650 ; 651} // namespace Internal; 652} // namespace ROOT; 653 ; 654template <typename T>; 655TClass *TClass::GetClass(Bool_t load, Bool_t silent); 656{; 657 typename std::is_base_of<TObject, T>::type tag;; 658 return ROOT::Internal::GetClassHelper<T>(load, silent, tag);; 659}; 660 ; 661namespace ROOT {; 662 ; 663template <typename T> TClass *GetClass(T * /* dummy */) { return TClass::GetClass<T>(); }; 664template <typename T> TClass *GetClass(const T * /* dummy */) { return TClass::GetClass<T>(); }; 665 ; 666#ifndef R__NO_CLASS_TEMPLATE_SPECIALIZATION; 667 // This can only be used when the template overload resolution can distinguish between T* and T**; 668 template <typename T> TClass* GetClass( T** /* dummy */) { return TClass::GetClass<T>(); }; 669 template <typename T> TClass* GetClass(const T** /* dummy */) { return TClass::GetClass<T>(); }; 670 template <typename T> TClass* GetClass( T* const* /* dummy */) { return TClass::GetClass<T>(); }; 671 template <typena",MatchSource.WIKI,doc/v632/TClass_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/TClass_8h_source.html
https://root.cern/doc/v632/TClass_8h_source.html:33123,Performance,load,load,33123,"space Internal {; 623template <typename T>; 624TClass *GetClassHelper(Bool_t, Bool_t, std::true_type); 625{; 626 return T::Class();; 627}; 628 ; 629template <typename T>; 630struct TClassGetClassHelper {; 631 static TClass *GetClass(Bool_t load, Bool_t silent) {; 632 return TClass::GetClass(typeid(T), load, silent);; 633 }; 634};; 635 ; 636template <typename F, typename S>; 637struct TClassGetClassHelper<std::pair<F, S> > {; 638 static TClass *GetClass(Bool_t load, Bool_t silent) {; 639 using pair_t = std::pair<F,S>;; 640 size_t hint_offset = offsetof(pair_t, second);; 641 return TClass::GetClass(typeid(std::pair<F, S>), load, silent, hint_offset, sizeof(std::pair<F,S>));; 642 }; 643};; 644 ; 645template <typename T>; 646TClass *GetClassHelper(Bool_t load, Bool_t silent, std::false_type); 647{; 648 return TClassGetClassHelper<T>::GetClass(load, silent);; 649}; 650 ; 651} // namespace Internal; 652} // namespace ROOT; 653 ; 654template <typename T>; 655TClass *TClass::GetClass(Bool_t load, Bool_t silent); 656{; 657 typename std::is_base_of<TObject, T>::type tag;; 658 return ROOT::Internal::GetClassHelper<T>(load, silent, tag);; 659}; 660 ; 661namespace ROOT {; 662 ; 663template <typename T> TClass *GetClass(T * /* dummy */) { return TClass::GetClass<T>(); }; 664template <typename T> TClass *GetClass(const T * /* dummy */) { return TClass::GetClass<T>(); }; 665 ; 666#ifndef R__NO_CLASS_TEMPLATE_SPECIALIZATION; 667 // This can only be used when the template overload resolution can distinguish between T* and T**; 668 template <typename T> TClass* GetClass( T** /* dummy */) { return TClass::GetClass<T>(); }; 669 template <typename T> TClass* GetClass(const T** /* dummy */) { return TClass::GetClass<T>(); }; 670 template <typename T> TClass* GetClass( T* const* /* dummy */) { return TClass::GetClass<T>(); }; 671 template <typename T> TClass* GetClass(const T* const* /* dummy */) { return TClass::GetClass<T>(); }; 672#endif; 673 ; 674 extern TClass *CreateClass(const char *",MatchSource.WIKI,doc/v632/TClass_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/TClass_8h_source.html
https://root.cern/doc/v632/TClass_8h_source.html:33249,Performance,load,load,33249,"ss();; 627}; 628 ; 629template <typename T>; 630struct TClassGetClassHelper {; 631 static TClass *GetClass(Bool_t load, Bool_t silent) {; 632 return TClass::GetClass(typeid(T), load, silent);; 633 }; 634};; 635 ; 636template <typename F, typename S>; 637struct TClassGetClassHelper<std::pair<F, S> > {; 638 static TClass *GetClass(Bool_t load, Bool_t silent) {; 639 using pair_t = std::pair<F,S>;; 640 size_t hint_offset = offsetof(pair_t, second);; 641 return TClass::GetClass(typeid(std::pair<F, S>), load, silent, hint_offset, sizeof(std::pair<F,S>));; 642 }; 643};; 644 ; 645template <typename T>; 646TClass *GetClassHelper(Bool_t load, Bool_t silent, std::false_type); 647{; 648 return TClassGetClassHelper<T>::GetClass(load, silent);; 649}; 650 ; 651} // namespace Internal; 652} // namespace ROOT; 653 ; 654template <typename T>; 655TClass *TClass::GetClass(Bool_t load, Bool_t silent); 656{; 657 typename std::is_base_of<TObject, T>::type tag;; 658 return ROOT::Internal::GetClassHelper<T>(load, silent, tag);; 659}; 660 ; 661namespace ROOT {; 662 ; 663template <typename T> TClass *GetClass(T * /* dummy */) { return TClass::GetClass<T>(); }; 664template <typename T> TClass *GetClass(const T * /* dummy */) { return TClass::GetClass<T>(); }; 665 ; 666#ifndef R__NO_CLASS_TEMPLATE_SPECIALIZATION; 667 // This can only be used when the template overload resolution can distinguish between T* and T**; 668 template <typename T> TClass* GetClass( T** /* dummy */) { return TClass::GetClass<T>(); }; 669 template <typename T> TClass* GetClass(const T** /* dummy */) { return TClass::GetClass<T>(); }; 670 template <typename T> TClass* GetClass( T* const* /* dummy */) { return TClass::GetClass<T>(); }; 671 template <typename T> TClass* GetClass(const T* const* /* dummy */) { return TClass::GetClass<T>(); }; 672#endif; 673 ; 674 extern TClass *CreateClass(const char *cname, Version_t id,; 675 const char *dfil, const char *ifil,; 676 Int_t dl, Int_t il);; 677}; 678 ; 679#endif // ROOT_TClass;",MatchSource.WIKI,doc/v632/TClass_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/TClass_8h_source.html
https://root.cern/doc/v632/TClass_8h_source.html:42035,Performance,load,load,42035,"Class instances represent classes, structs and namespaces in the ROOT type system.Definition TClass.h:81; TClass::GetPersistentRefTClass *const * GetPersistentRef() constDefinition TClass.h:481; TClass::GetCheckSumUInt_t GetCheckSum(ECheckSum code=kCurrentCheckSum) constCall GetCheckSum with validity check.Definition TClass.cxx:6505; TClass::IsSyntheticPairBool_t IsSyntheticPair() constDefinition TClass.h:521; TClass::fObjectVersionRepositoryRepoCont_t fObjectVersionRepositoryDefinition TClass.h:344; TClass::Streamervoid Streamer(void *obj, TBuffer &b, const TClass *onfile_class=nullptr) constDefinition TClass.h:607; TClass::fShowMembersShowMembersFunc_t fShowMembersDefinition TClass.h:225; TClass::GetDataMemberTDataMember * GetDataMember(const char *datamember) constReturn pointer to datamember object with name ""datamember"".Definition TClass.cxx:3439; TClass::fIsATVirtualIsAProxy * fIsADefinition TClass.h:229; TClass::GetListOfUsingDataMembersTList * GetListOfUsingDataMembers(Bool_t load=kTRUE)Return list containing the TDataMembers of using declarations of a class.Definition TClass.cxx:3786; TClass::ForceReloadvoid ForceReload(TClass *oldcl)we found at least one equivalent.Definition TClass.cxx:1336; TClass::fDeleteArrayROOT::DelArrFunc_t fDeleteArrayDefinition TClass.h:238; TClass::CanSplitBool_t CanSplit() constReturn true if the data member of this TClass can be saved separately.Definition TClass.cxx:2319; TClass::fStreamerTClassStreamer * fStreamerDefinition TClass.h:226; TClass::SetDirectoryAutoAddvoid SetDirectoryAutoAdd(ROOT::DirAutoAdd_t dirAutoAddFunc)Install a new wrapper around the directory auto add function.Definition TClass.cxx:7028; TClass::NewArrayvoid * NewArray(Long_t nElements, ENewType defConstructor=kClassNew) constReturn a pointer to a newly allocated array of objects of this class.Definition TClass.cxx:5193; TClass::fNoInfoOrEmuOrFwdDeclNameRegistrystatic TDeclNameRegistry fNoInfoOrEmuOrFwdDeclNameRegistryDefinition TClass.h:328; TClass::TGen",MatchSource.WIKI,doc/v632/TClass_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/TClass_8h_source.html
https://root.cern/doc/v632/TClass_8h_source.html:45108,Performance,load,load,45108," the 'type' of the STL the TClass is representing.Definition TClass.cxx:2886; TClass::AdoptMemberStreamervoid AdoptMemberStreamer(const char *name, TMemberStreamer *strm)Adopt the TMemberStreamer pointer to by p and use it to Stream non basic member name.Definition TClass.cxx:6703; TClass::ResetInstanceCountvoid ResetInstanceCount()Definition TClass.h:547; TClass::GetStreamerFuncClassStreamerFunc_t GetStreamerFunc() constGet a wrapper/accessor function around this class custom streamer (member function).Definition TClass.cxx:2939; TClass::RemoveStreamerInfovoid RemoveStreamerInfo(Int_t slot)Remove and delete the StreamerInfo in the given slot.Definition TClass.cxx:7320; TClass::SetCanSplitvoid SetCanSplit(Int_t splitmode)Set the splitability of this class:Definition TClass.cxx:5658; TClass::AddInstancevoid AddInstance(Bool_t heap=kFALSE)Definition TClass.h:381; TClass::CreateListOfDataMembersTList * CreateListOfDataMembers(std::atomic< TListOfDataMembers * > &data, TDictionary::EMemberSelection selection, bool load)Create the list containing the TDataMembers (of actual data members or members pulled in through usin...Definition TClass.cxx:3741; TClass::GetStreamerInfoAbstractEmulatedTVirtualStreamerInfo * GetStreamerInfoAbstractEmulated(Int_t version=0) constFor the case where the requestor class is emulated and this class is abstract, returns a pointer to t...Definition TClass.cxx:4709; TClass::Newvoid * New(ENewType defConstructor=kClassNew, Bool_t quiet=kFALSE) constReturn a pointer to a newly allocated object of this class.Definition TClass.cxx:4978; TClass::SetMergevoid SetMerge(ROOT::MergeFunc_t mergeFunc)Install a new wrapper around 'Merge'.Definition TClass.cxx:6969; TClass::fConversionStreamerInfoConvSIMap_t fConversionStreamerInfoDefinition TClass.h:199; TClass::fDirAutoAddROOT::DirAutoAdd_t fDirAutoAddDefinition TClass.h:240; TClass::HasDataMemberInfoBool_t HasDataMemberInfo() constDefinition TClass.h:407; TClass::fRefProxyTVirtualRefProxy * fRefProxycach",MatchSource.WIKI,doc/v632/TClass_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/TClass_8h_source.html
https://root.cern/doc/v632/TClass_8h_source.html:48015,Performance,load,load,48015,"nst char *proto, Bool_t objectIsConst=kFALSE, ROOT::EFunctionMatchMode mode=ROOT::kConversionMatch)Find the method with a given prototype.Definition TClass.cxx:4456; TClass::CopyCollectionProxyvoid CopyCollectionProxy(const TVirtualCollectionProxy &)Replaces the collection proxy for this class.Definition TClass.cxx:2470; TClass::fStreamerTypeInt_t fStreamerTypesaved info to call StreamerDefinition TClass.h:276; TClass::fRealDataTList * fRealDataDefinition TClass.h:200; TClass::fOnHeapUInt_t fOnHeapDefinition TClass.h:218; TClass::lsvoid ls(Option_t *opt="""") const overrideThe ls function lists the contents of a class on stdout.Definition TClass.cxx:4258; TClass::fBasestd::atomic< TList * > fBaseDefinition TClass.h:201; TClass::fCanSplitstd::atomic< Char_t > fCanSplitDefinition TClass.h:245; TClass::HasDictionaryBool_t HasDictionary() constCheck whether a class has a dictionary or not.Definition TClass.cxx:3906; TClass::GetListOfAllPublicMethodsconst TList * GetListOfAllPublicMethods(Bool_t load=kTRUE)Returns a list of all public methods of this class and its base classes.Definition TClass.cxx:3845; TClass::HasCustomStreamerMemberBool_t HasCustomStreamerMember() constThe class has a Streamer method and it is implemented by the user or an older (not StreamerInfo based...Definition TClass.h:508; TClass::SetDeclFilevoid SetDeclFile(const char *name, Short_t line)Definition TClass.h:555; TClass::GetListOfAllPublicDataMembersTList * GetListOfAllPublicDataMembers(Bool_t load=kTRUE)Returns a list of all public data members of this class and its base classes.Definition TClass.cxx:3862; TClass::TClassTClass(const TClass &tc)=delete; TClass::AddClassToDeclIdMapstatic void AddClassToDeclIdMap(TDictionary::DeclId_t id, TClass *cl)static: Add a TClass* to the map of classes.Definition TClass.cxx:511; TClass::~TClassvirtual ~TClass()TClass dtor. Deletes all list that might have been created.Definition TClass.cxx:1660; TClass::fIsSyntheticPairBool_t fIsSyntheticPairIndicates whether ",MatchSource.WIKI,doc/v632/TClass_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/TClass_8h_source.html
https://root.cern/doc/v632/TClass_8h_source.html:48498,Performance,load,load,48498,"eapUInt_t fOnHeapDefinition TClass.h:218; TClass::lsvoid ls(Option_t *opt="""") const overrideThe ls function lists the contents of a class on stdout.Definition TClass.cxx:4258; TClass::fBasestd::atomic< TList * > fBaseDefinition TClass.h:201; TClass::fCanSplitstd::atomic< Char_t > fCanSplitDefinition TClass.h:245; TClass::HasDictionaryBool_t HasDictionary() constCheck whether a class has a dictionary or not.Definition TClass.cxx:3906; TClass::GetListOfAllPublicMethodsconst TList * GetListOfAllPublicMethods(Bool_t load=kTRUE)Returns a list of all public methods of this class and its base classes.Definition TClass.cxx:3845; TClass::HasCustomStreamerMemberBool_t HasCustomStreamerMember() constThe class has a Streamer method and it is implemented by the user or an older (not StreamerInfo based...Definition TClass.h:508; TClass::SetDeclFilevoid SetDeclFile(const char *name, Short_t line)Definition TClass.h:555; TClass::GetListOfAllPublicDataMembersTList * GetListOfAllPublicDataMembers(Bool_t load=kTRUE)Returns a list of all public data members of this class and its base classes.Definition TClass.cxx:3862; TClass::TClassTClass(const TClass &tc)=delete; TClass::AddClassToDeclIdMapstatic void AddClassToDeclIdMap(TDictionary::DeclId_t id, TClass *cl)static: Add a TClass* to the map of classes.Definition TClass.cxx:511; TClass::~TClassvirtual ~TClass()TClass dtor. Deletes all list that might have been created.Definition TClass.cxx:1660; TClass::fIsSyntheticPairBool_t fIsSyntheticPairIndicates whether this class can be split or not. Values are -1, 0, 1, 2.Definition TClass.h:250; TClass::Destructorvoid Destructor(void *obj, Bool_t dtorOnly=kFALSE)Explicitly call destructor for object.Definition TClass.cxx:5400; TClass::fClassVersionVersion_t fClassVersionDefinition TClass.h:221; TClass::fCurrentInfostd::atomic< TVirtualStreamerInfo * > fCurrentInfoCurrent 'state' of the class (Emulated,Interpreted,Loaded)Definition TClass.h:278; TClass::GetListOfFunctionTemplatesTList * GetListO",MatchSource.WIKI,doc/v632/TClass_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/TClass_8h_source.html
https://root.cern/doc/v632/TClass_8h_source.html:49524,Performance,load,load,49524,"eturns a list of all public data members of this class and its base classes.Definition TClass.cxx:3862; TClass::TClassTClass(const TClass &tc)=delete; TClass::AddClassToDeclIdMapstatic void AddClassToDeclIdMap(TDictionary::DeclId_t id, TClass *cl)static: Add a TClass* to the map of classes.Definition TClass.cxx:511; TClass::~TClassvirtual ~TClass()TClass dtor. Deletes all list that might have been created.Definition TClass.cxx:1660; TClass::fIsSyntheticPairBool_t fIsSyntheticPairIndicates whether this class can be split or not. Values are -1, 0, 1, 2.Definition TClass.h:250; TClass::Destructorvoid Destructor(void *obj, Bool_t dtorOnly=kFALSE)Explicitly call destructor for object.Definition TClass.cxx:5400; TClass::fClassVersionVersion_t fClassVersionDefinition TClass.h:221; TClass::fCurrentInfostd::atomic< TVirtualStreamerInfo * > fCurrentInfoCurrent 'state' of the class (Emulated,Interpreted,Loaded)Definition TClass.h:278; TClass::GetListOfFunctionTemplatesTList * GetListOfFunctionTemplates(Bool_t load=kTRUE)Return TListOfFunctionTemplates for a class.Definition TClass.cxx:3798; TClass::DynamicCastvoid * DynamicCast(const TClass *base, void *obj, Bool_t up=kTRUE)Cast obj of this class type up to baseclass cl if up is true.Definition TClass.cxx:4915; TClass::fImplFileNameconst char * fImplFileNameDefinition TClass.h:214; TClass::RegisterStreamerInfovoid RegisterStreamerInfo(TVirtualStreamerInfo *info)Register the StreamerInfo in the given slot, change the State of the TClass as appropriate.Definition TClass.cxx:7296; TClass::operator=TClass & operator=(const TClass &)=delete; TClass::fCheckSumstd::atomic< UInt_t > fCheckSumDefinition TClass.h:219; TClass::UnregisterAddressInRepositoryvoid UnregisterAddressInRepository(const char *where, void *location, const TClass *what) constDefinition TClass.cxx:318; TClass::fMethodstd::atomic< TListOfFunctions * > fMethodDefinition TClass.h:207; TClass::RemoveClassDeclIdstatic void RemoveClassDeclId(TDictionary::DeclId_t id)Defi",MatchSource.WIKI,doc/v632/TClass_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/TClass_8h_source.html
https://root.cern/doc/v632/TClass_8h_source.html:51322,Performance,load,load,51322,"tory(const char *where, void *location, const TClass *what) constDefinition TClass.cxx:318; TClass::fMethodstd::atomic< TListOfFunctions * > fMethodDefinition TClass.h:207; TClass::RemoveClassDeclIdstatic void RemoveClassDeclId(TDictionary::DeclId_t id)Definition TClass.cxx:536; TClass::SetNewArrayvoid SetNewArray(ROOT::NewArrFunc_t newArrayFunc)Install a new wrapper around 'new []'.Definition TClass.cxx:6993; TClass::CallShowMembersBool_t CallShowMembers(const void *obj, TMemberInspector &insp, Bool_t isTransient=kFALSE) constCall ShowMembers() on the obj of this class type, passing insp and parent.Definition TClass.cxx:2205; TClass::fDeclFileNameconst char * fDeclFileNameDefinition TClass.h:213; TClass::SetCollectionProxyvoid SetCollectionProxy(const ROOT::Detail::TCollectionProxyInfo &)Create the collection proxy object (and the streamer object) from using the information in the TColle...Definition TClass.cxx:6244; TClass::HasDictionarySelectionstatic Bool_t HasDictionarySelection(const char *clname)Check whether a class has a dictionary or ROOT can load one.Definition TClass.cxx:3917; TClass::AdoptSchemaRulesvoid AdoptSchemaRules(ROOT::Detail::TSchemaRuleSet *rules)Adopt a new set of Data Model Evolution rules.Definition TClass.cxx:1920; TClass::StreamerInstrumentedstatic void StreamerInstrumented(const TClass *pThis, void *object, TBuffer &b, const TClass *onfile_class)Case of instrumented class with a library.Definition TClass.cxx:6836; TClass::SetStreamerInfoTVirtualStreamerInfo * SetStreamerInfo(Int_t version, const char *info="""")Info is a string describing the names and types of attributes written by the class Streamer function.Definition TClass.cxx:6373; TClass::fgClassCountstatic std::atomic< Int_t > fgClassCountDefinition TClass.h:326; TClass::GetCurrentStreamerInfoTVirtualStreamerInfo * GetCurrentStreamerInfo()Definition TClass.h:439; TClass::GetDirectoryAutoAddROOT::DirAutoAdd_t GetDirectoryAutoAdd() constReturn the wrapper around the directory auto ad",MatchSource.WIKI,doc/v632/TClass_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/TClass_8h_source.html
https://root.cern/doc/v632/TClass_8h_source.html:52877,Performance,load,load,52877,"es written by the class Streamer function.Definition TClass.cxx:6373; TClass::fgClassCountstatic std::atomic< Int_t > fgClassCountDefinition TClass.h:326; TClass::GetCurrentStreamerInfoTVirtualStreamerInfo * GetCurrentStreamerInfo()Definition TClass.h:439; TClass::GetDirectoryAutoAddROOT::DirAutoAdd_t GetDirectoryAutoAdd() constReturn the wrapper around the directory auto add function.Definition TClass.cxx:7487; TClass::AddImplFilevoid AddImplFile(const char *filename, int line)Definition TClass.cxx:1952; TClass::GetListOfMethodOverloadsTCollection * GetListOfMethodOverloads(const char *name) constReturn the collection of functions named ""name"".Definition TClass.cxx:3827; TClass::fEnumsstd::atomic< TListOfEnums * > fEnumsDefinition TClass.h:205; TClass::HasNoInfoOrEmuOrFwdDeclaredDeclstatic Bool_t HasNoInfoOrEmuOrFwdDeclaredDecl(const char *)Definition TClass.cxx:3398; TClass::fOVRMutexTVirtualMutex * fOVRMutexDefinition TClass.h:342; TClass::GetListOfEnumsTList * GetListOfEnums(Bool_t load=kTRUE)Return a list containing the TEnums of a class.Definition TClass.cxx:3686; TClass::IsStartingWithTObjectBool_t IsStartingWithTObject() constReturns true if this class inherits from TObject and if the start of the TObject parts is at the very...Definition TClass.cxx:5929; TClass::GetListOfMethodsTList * GetListOfMethods(Bool_t load=kTRUE)Return list containing the TMethods of a class.Definition TClass.cxx:3812; TClass::TClassTClass()Internal, default constructor.Definition TClass.cxx:1065; TClass::fDeclFileLineShort_t fDeclFileLineDefinition TClass.h:215; TClass::GetNmethodsInt_t GetNmethods()Return the number of methods of this class Note that in case the list of methods is not yet created,...Definition TClass.cxx:4573; TClass::fIsOffsetStreamerSetstd::atomic< Bool_t > fIsOffsetStreamerSetIndicates whether the ClassInfo is supposed to be available.Definition TClass.h:261; TClass::IgnoreTObjectStreamervoid IgnoreTObjectStreamer(Bool_t ignore=kTRUE)When the class kIgnoreTObjec",MatchSource.WIKI,doc/v632/TClass_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/TClass_8h_source.html
https://root.cern/doc/v632/TClass_8h_source.html:53216,Performance,load,load,53216," the wrapper around the directory auto add function.Definition TClass.cxx:7487; TClass::AddImplFilevoid AddImplFile(const char *filename, int line)Definition TClass.cxx:1952; TClass::GetListOfMethodOverloadsTCollection * GetListOfMethodOverloads(const char *name) constReturn the collection of functions named ""name"".Definition TClass.cxx:3827; TClass::fEnumsstd::atomic< TListOfEnums * > fEnumsDefinition TClass.h:205; TClass::HasNoInfoOrEmuOrFwdDeclaredDeclstatic Bool_t HasNoInfoOrEmuOrFwdDeclaredDecl(const char *)Definition TClass.cxx:3398; TClass::fOVRMutexTVirtualMutex * fOVRMutexDefinition TClass.h:342; TClass::GetListOfEnumsTList * GetListOfEnums(Bool_t load=kTRUE)Return a list containing the TEnums of a class.Definition TClass.cxx:3686; TClass::IsStartingWithTObjectBool_t IsStartingWithTObject() constReturns true if this class inherits from TObject and if the start of the TObject parts is at the very...Definition TClass.cxx:5929; TClass::GetListOfMethodsTList * GetListOfMethods(Bool_t load=kTRUE)Return list containing the TMethods of a class.Definition TClass.cxx:3812; TClass::TClassTClass()Internal, default constructor.Definition TClass.cxx:1065; TClass::fDeclFileLineShort_t fDeclFileLineDefinition TClass.h:215; TClass::GetNmethodsInt_t GetNmethods()Return the number of methods of this class Note that in case the list of methods is not yet created,...Definition TClass.cxx:4573; TClass::fIsOffsetStreamerSetstd::atomic< Bool_t > fIsOffsetStreamerSetIndicates whether the ClassInfo is supposed to be available.Definition TClass.h:261; TClass::IgnoreTObjectStreamervoid IgnoreTObjectStreamer(Bool_t ignore=kTRUE)When the class kIgnoreTObjectStreamer bit is set, the automatically generated Streamer will not call ...Definition TClass.cxx:4841; TClass::GetStreamerTClassStreamer * GetStreamer() constReturn the Streamer Class allowing streaming (if any).Definition TClass.cxx:2914; TClass::GetIdMapstatic IdMap_t * GetIdMap()Definition TClass.cxx:469; TClass::GetInstanceCount",MatchSource.WIKI,doc/v632/TClass_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/TClass_8h_source.html
https://root.cern/doc/v632/TClass_8h_source.html:55574,Performance,load,load,55574,"wser)Browse external object inherited from TObject.Definition TClass.cxx:1966; TClass::GetNewROOT::NewFunc_t GetNew() constReturn the wrapper around new ThisClass().Definition TClass.cxx:7447; TClass::GetBaseClassTClass * GetBaseClass(const char *classname)Return pointer to the base class ""classname"".Definition TClass.cxx:2655; TClass::GetDataMemberOffsetLongptr_t GetDataMemberOffset(const char *membername) constreturn offset for member name.Definition TClass.cxx:3477; TClass::GetNdataInt_t GetNdata()Return the number of data members of this class Note that in case the list of data members is not yet...Definition TClass.cxx:4554; TClass::SetDestructorvoid SetDestructor(ROOT::DesFunc_t destructorFunc)Install a new wrapper around the destructor.Definition TClass.cxx:7017; TClass::PostLoadCheckvirtual void PostLoadCheck()Do the initialization that can only be done after the CINT dictionary has been fully populated and ca...Definition TClass.cxx:5959; TClass::LoadClassInfovoid LoadClassInfo() constTry to load the ClassInfo if available.Definition TClass.cxx:5824; TClass::SetResetAfterMergevoid SetResetAfterMerge(ROOT::ResetAfterMergeFunc_t resetFunc)Install a new wrapper around 'ResetAfterMerge'.Definition TClass.cxx:6977; TClass::GetStreamerInfoImplTVirtualStreamerInfo * GetStreamerInfoImpl(Int_t version, Bool_t silent) constDefinition TClass.cxx:4634; TClass::MatchLegacyCheckSumBool_t MatchLegacyCheckSum(UInt_t checksum) constReturn true if the checksum passed as argument is one of the checksum value produced by the older che...Definition TClass.cxx:6494; TClass::fAllPubMethodTViewPubFunctions * fAllPubMethodDefinition TClass.h:210; TClass::ERuntimePropertiesERuntimePropertiesIndicates whether GetClassVersion has been called.Definition TClass.h:264; TClass::ERuntimeProperties::kSet@ kSet; TClass::ERuntimeProperties::kConsistentHash@ kConsistentHash; TClass::ERuntimeProperties::kNotInitialized@ kNotInitialized; TClass::HasInterpreterInfoBool_t HasInterpreterInfo() cons",MatchSource.WIKI,doc/v632/TClass_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/TClass_8h_source.html
https://root.cern/doc/v632/TClass_8h_source.html:58967,Performance,load,load,58967,"TClass::fConvStreamerFuncClassConvStreamerFunc_t fConvStreamerFuncDefinition TClass.h:242; TClass::BuildRealDatavoid BuildRealData(void *pointer=nullptr, Bool_t isTransient=kFALSE)Build a full list of persistent data members.Definition TClass.cxx:2031; TClass::SetRuntimePropertiesvoid SetRuntimeProperties()Internal routine to set calculate the class properties that can only be known at run-time,...Definition TClass.cxx:6194; TClass::BuildEmulatedRealDatavoid BuildEmulatedRealData(const char *name, Longptr_t offset, TClass *cl, Bool_t isTransient=kFALSE)Build the list of real data for an emulated class.Definition TClass.cxx:2112; TClass::LoadClassstatic TClass * LoadClass(const char *requestedname, Bool_t silent)Helper function used by TClass::GetClass().Definition TClass.cxx:5749; TClass::fSharedLibsTString fSharedLibsDefinition TClass.h:227; TClass::GetTypeInfoconst std::type_info * GetTypeInfo() constDefinition TClass.h:496; TClass::GetListOfDataMembersTList * GetListOfDataMembers(Bool_t load=kTRUE)Return list containing the TDataMembers of a class.Definition TClass.cxx:3770; TClass::ENewTypeENewTypeDefinition TClass.h:107; TClass::kClassNew@ kClassNewDefinition TClass.h:107; TClass::kRealNew@ kRealNewDefinition TClass.h:107; TClass::kDummyNew@ kDummyNewDefinition TClass.h:107; TClass::Movevoid Move(void *arenaFrom, void *arenaTo) constRegister the fact that an object was moved from the memory location 'arenaFrom' to the memory locatio...Definition TClass.cxx:4327; TClass::GetDeclIdMapstatic DeclIdMap_t * GetDeclIdMap()Definition TClass.cxx:480; TClass::GetDeclFileLineShort_t GetDeclFileLine() constDefinition TClass.h:429; TClass::SetStreamerFuncvoid SetStreamerFunc(ClassStreamerFunc_t strm)Set a wrapper/accessor function around this class custom streamer.Definition TClass.cxx:6922; TClass::GetImplFileNameconst char * GetImplFileName() constDefinition TClass.h:456; TClass::GetListOfRealDataTList * GetListOfRealData() constDefinition TClass.h:453; TClass::SizeInt_t ",MatchSource.WIKI,doc/v632/TClass_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/TClass_8h_source.html
https://root.cern/doc/v632/TClass_8h_source.html:60293,Performance,load,loading,60293,"07; TClass::Movevoid Move(void *arenaFrom, void *arenaTo) constRegister the fact that an object was moved from the memory location 'arenaFrom' to the memory locatio...Definition TClass.cxx:4327; TClass::GetDeclIdMapstatic DeclIdMap_t * GetDeclIdMap()Definition TClass.cxx:480; TClass::GetDeclFileLineShort_t GetDeclFileLine() constDefinition TClass.h:429; TClass::SetStreamerFuncvoid SetStreamerFunc(ClassStreamerFunc_t strm)Set a wrapper/accessor function around this class custom streamer.Definition TClass.cxx:6922; TClass::GetImplFileNameconst char * GetImplFileName() constDefinition TClass.h:456; TClass::GetListOfRealDataTList * GetListOfRealData() constDefinition TClass.h:453; TClass::SizeInt_t Size() constReturn size of object of this class.Definition TClass.cxx:5704; TClass::SetCurrentStreamerInfovoid SetCurrentStreamerInfo(TVirtualStreamerInfo *info)Set pointer to current TVirtualStreamerInfo.Definition TClass.cxx:5696; TClass::GetDictstatic DictFuncPtr_t GetDict(const char *cname)Return a pointer to the dictionary loading function generated by rootcint.Definition TClass.cxx:3422; TClass::fOffsetStreamerLongptr_t fOffsetStreamerProperties that can only be evaluated at run-time.Definition TClass.h:275; TClass::fSizeofInt_t fSizeofDefinition TClass.h:243; TClass::GetNewArrayROOT::NewArrFunc_t GetNewArray() constReturn the wrapper around new ThisClass[].Definition TClass.cxx:7455; TClass::RepoCont_tstd::multimap< void *, Version_t > RepoCont_tDefinition TClass.h:343; TClass::StreamerTObjectEmulatedstatic void StreamerTObjectEmulated(const TClass *pThis, void *object, TBuffer &b, const TClass *onfile_class)Case of TObjects when we do not have the library defining the class.Definition TClass.cxx:6823; TClass::fNewROOT::NewFunc_t fNewDefinition TClass.h:235; TClass::kLoading@ kLoadingDefinition TClass.h:332; TClass::kUnloading@ kUnloadingDefinition TClass.h:332; TClass::GetResetAfterMergeROOT::ResetAfterMergeFunc_t GetResetAfterMerge() constReturn the wrapper around Me",MatchSource.WIKI,doc/v632/TClass_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/TClass_8h_source.html
https://root.cern/doc/v632/TClass_8h_source.html:68736,Performance,cache,caches,68736,"mmentDefinition TClass.h:111; TClass::kWithTypeDef@ kWithTypeDefDefinition TClass.h:113; TClass::kNoRangeCheck@ kNoRangeCheckDefinition TClass.h:115; TClass::kNoEnum@ kNoEnumDefinition TClass.h:110; TClass::Dumpvoid Dump() const overrideDump contents of object on stdout.Definition TClass.h:398; TClass::InheritsFromBool_t InheritsFrom(const char *cl) const overrideReturn kTRUE if this class inherits from a class with name ""classname"".Definition TClass.cxx:4874; TClass::GetBaseClassOffsetInt_t GetBaseClassOffset(const TClass *toBase, void *address=nullptr, bool isDerivedObject=true)Definition TClass.cxx:2791; TClass::NewObjectArrayObjectPtr NewObjectArray(Long_t nElements, ENewType defConstructor=kClassNew) constReturn a pointer to a newly allocated array of objects of this class.Definition TClass.cxx:5209; TClass::GetCollectionProxyTVirtualCollectionProxy * GetCollectionProxy() constReturn the proxy describing the collection (if any).Definition TClass.cxx:2897; TClass::ResetCachesvoid ResetCaches()To clean out all caches.Definition TClass.cxx:4215; TClass::fVersionUsedstd::atomic< Bool_t > fVersionUsedsaved remember if fOffsetStreamer has been set.Definition TClass.h:262; TClass::GetClassSizeInt_t GetClassSize() constDefinition TClass.h:425; TClass::ClassPropertyLong_t ClassProperty() constReturn the C++ property of this class, eg.Definition TClass.cxx:2396; TClass::SetStreamerImplvoid SetStreamerImpl()Internal routine to set fStreamerImpl based on the value of fStreamerType.Definition TClass.cxx:6215; TClass::GetSharedLibsconst char * GetSharedLibs()Get the list of shared libraries containing the code for class cls.Definition TClass.cxx:3623; TClass::CalculateStreamerOffsetvoid CalculateStreamerOffset() constCalculate the offset between an object of this class to its base class TObject.Definition TClass.cxx:2183; TClass::GetMissingDictionariesForPairElementsvoid GetMissingDictionariesForPairElements(TCollection &result, TCollection &visited, bool recurse)Definition T",MatchSource.WIKI,doc/v632/TClass_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/TClass_8h_source.html
https://root.cern/doc/v632/TClass_8h_source.html:74986,Performance,load,loaded,74986," TClass.cxx:4440; TClass::StreamerExternalstatic void StreamerExternal(const TClass *pThis, void *object, TBuffer &b, const TClass *onfile_class)There is special streamer for the class.Definition TClass.cxx:6788; TClass::operator&friend bool operator&(UChar_t l, ERuntimeProperties r)Definition TClass.h:270; TClass::fClassPropertyLong_t fClassPropertyProperty See TClass::Property() for details.Definition TClass.h:256; TClass::fContextMenuTitleTString fContextMenuTitleDefinition TClass.h:223; TClass::StreamerTObjectInitializedstatic void StreamerTObjectInitialized(const TClass *pThis, void *object, TBuffer &b, const TClass *onfile_class)Case of TObjects when fIsOffsetStreamerSet is known to have been set.Definition TClass.cxx:6814; TClass::ConvStreamerInstrumentedstatic void ConvStreamerInstrumented(const TClass *pThis, void *object, TBuffer &b, const TClass *onfile_class)Case of instrumented class with a library.Definition TClass.cxx:6845; TClass::fCanLoadClassInfostd::atomic< Bool_t > fCanLoadClassInfoWhether info was loaded from a root pcm.Definition TClass.h:260; TClass::SetConvStreamerFuncvoid SetConvStreamerFunc(ClassConvStreamerFunc_t strm)Set a wrapper/accessor function around this class custom conversion streamer.Definition TClass.cxx:6945; TClass::FindStreamerInfoTVirtualStreamerInfo * FindStreamerInfo(TObjArray *arr, UInt_t checksum) constFind the TVirtualStreamerInfo in the StreamerInfos corresponding to checksum.Definition TClass.cxx:7066; TClass::GetMissingDictionariesvoid GetMissingDictionaries(THashTable &result, bool recurse=false)Get the classes that have a missing dictionary starting from this one.Definition TClass.cxx:4087; TClass::MakeCustomMenuListvoid MakeCustomMenuList()Makes a customizable version of the popup menu list, i.e.Definition TClass.cxx:4283; TClass::FindStreamerInfoAbstractEmulatedTVirtualStreamerInfo * FindStreamerInfoAbstractEmulated(UInt_t checksum) constFor the case where the requestor class is emulated and this class is abstrac",MatchSource.WIKI,doc/v632/TClass_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/TClass_8h_source.html
https://root.cern/doc/v632/TClass_8h_source.html:80032,Performance,load,load,80032,"kHasNameMapNode@ kHasNameMapNodeDefinition TClass.h:105; TClass::kIgnoreTObjectStreamer@ kIgnoreTObjectStreamerDefinition TClass.h:97; TClass::kUnloaded@ kUnloadedDefinition TClass.h:98; TClass::kWarned@ kWarnedDefinition TClass.h:104; TClass::kStartWithTObject@ kStartWithTObjectDefinition TClass.h:103; TClass::kIsTObject@ kIsTObjectDefinition TClass.h:100; TClass::kIsForeign@ kIsForeignDefinition TClass.h:101; TClass::kReservedLoading@ kReservedLoadingDefinition TClass.h:93; TClass::fUsingDatastd::atomic< TListOfDataMembers * > fUsingDataDefinition TClass.h:203; TClass::GetMethodListTListOfFunctions * GetMethodList()Return (create an empty one if needed) the list of functions.Definition TClass.cxx:4355; TClass::GetReferenceProxyTVirtualRefProxy * GetReferenceProxy() constDefinition TClass.h:483; TClass::ResetMenuListvoid ResetMenuList()Resets the menu list to it's standard value.Definition TClass.cxx:4243; TClass::GetClassstatic TClass * GetClass(const char *name, Bool_t load=kTRUE, Bool_t silent=kFALSE)Static method returning pointer to TClass of the specified class name.Definition TClass.cxx:2968; TClass::WriteBufferInt_t WriteBuffer(TBuffer &b, void *pointer, const char *info="""")Function called by the Streamer functions to serialize object at p to buffer b.Definition TClass.cxx:6779; TClass::LoadClassCustomstatic TClass * LoadClassCustom(const char *requestedname, Bool_t silent)Helper function used by TClass::GetClass().Definition TClass.cxx:5801; TClass::GetHeapInstanceCountUInt_t GetHeapInstanceCount() constDefinition TClass.h:467; TClass::fImplFileLineShort_t fImplFileLineDefinition TClass.h:216; TClingThis class defines an interface to the cling C++ interpreter.Definition TCling.h:102; TCollectionCollection abstract base class.Definition TCollection.h:65; TDataMemberAll ROOT classes may have RTTI (run time type identification) support added.Definition TDataMember.h:31; TDictionaryThis class defines an abstract interface that must be implemented by all classes",MatchSource.WIKI,doc/v632/TClass_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/TClass_8h_source.html
https://root.cern/doc/v632/TClass_8h_source.html:85886,Performance,load,load,85886,"s.h:113; ROOT::GetClassTClass * GetClass(T *)Definition TClass.h:663; ROOT::CreateClassTClass * CreateClass(const char *cname, Version_t id, const std::type_info &info, TVirtualIsAProxy *isa, const char *dfil, const char *ifil, Int_t dl, Int_t il)Global function called by a class' static Dictionary() method (see the ClassDef macro).Definition TClass.cxx:5869; ROOT::DelFunc_tvoid(* DelFunc_t)(void *)Definition Rtypes.h:111; ROOT::ESTLTypeESTLTypeDefinition ESTLType.h:28; ROOT::NewArrFunc_tvoid *(* NewArrFunc_t)(Long_t size, void *arena)Definition Rtypes.h:110; ROOT::EFunctionMatchModeEFunctionMatchModeDefinition TDictionary.h:161; ROOT::kConversionMatch@ kConversionMatchDefinition TDictionary.h:163; ROOT::ResetClassVersionvoid ResetClassVersion(TClass *, const char *, Short_t)Global function to update the version number.Definition TClassTable.cxx:951; ROOT::DelArrFunc_tvoid(* DelArrFunc_t)(void *)Definition Rtypes.h:112; ROOT::NewFunc_tvoid *(* NewFunc_t)(void *)Definition Rtypes.h:109; ROOT::MergeFunc_tLong64_t(* MergeFunc_t)(void *, TCollection *, TFileMergeInfo *)Definition Rtypes.h:115; whatstatic const char * whatDefinition stlLoader.cc:5; ROOT::Internal::TClassGetClassHelperDefinition TClass.h:630; ROOT::Internal::TClassGetClassHelper::GetClassstatic TClass * GetClass(Bool_t load, Bool_t silent)Definition TClass.h:631; TClass::ObjectPtrDefinition TClass.h:140; TClass::ObjectPtr::fPtrvoid * fPtrDefinition TClass.h:141; TClass::ObjectPtr::GetAllocatorTVirtualStreamerInfo * GetAllocator() constDefinition TClass.h:149; TClass::ObjectPtr::GetPtrvoid * GetPtr() constDefinition TClass.h:147; TClass::ObjectPtr::fAllocatorTVirtualStreamerInfo * fAllocatorDefinition TClass.h:143; TClass::ObjectPtr::ObjectPtrObjectPtr(void *ptr=nullptr, TVirtualStreamerInfo *allocator=nullptr)Definition TClass.h:145; Drawth1 Draw(); lTLine lDefinition textangle.C:4. coremetaincTClass.h. ROOT v6-32 - Reference Guide Generated on Fri Nov 1 2024 15:07:01 (GVA Time) using Doxygen 1.9.8 ; . ",MatchSource.WIKI,doc/v632/TClass_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/TClass_8h_source.html
https://root.cern/doc/v632/TClass_8h_source.html:8900,Security,checksum,checksum,8900,.; 200 TList *fRealData; //linked list for persistent members including base classes; 201 std::atomic<TList*> fBase; //linked list for base classes; 202 std::atomic<TListOfDataMembers*> fData; //linked list for data members; non-owning.; 203 std::atomic<TListOfDataMembers*> fUsingData;//linked list for data members pulled in through using decls.; 204 ; 205 std::atomic<TListOfEnums*> fEnums; //linked list for the enums; 206 TListOfFunctionTemplates *fFuncTemplate; //linked list for function templates [Not public until implemented as active list]; 207 std::atomic<TListOfFunctions*> fMethod; //linked list for methods; 208 ; 209 TViewPubDataMembers*fAllPubData; //all public data members (including from base classes); 210 TViewPubFunctions *fAllPubMethod; //all public methods (including from base classes); 211 mutable TList *fClassMenuList; //list of class menu items; 212 ; 213 const char *fDeclFileName; //name of class declaration file; 214 const char *fImplFileName; //name of class implementation file; 215 Short_t fDeclFileLine; //line of class declaration; 216 Short_t fImplFileLine; //line of class implementation; 217 UInt_t fInstanceCount; //number of instances of this class; 218 UInt_t fOnHeap; //number of instances on heap; 219 mutable std::atomic<UInt_t> fCheckSum; //checksum of data members and base classes; 220 TVirtualCollectionProxy *fCollectionProxy; //Collection interface; 221 Version_t fClassVersion; //Class version Identifier; 222 ClassInfo_t *fClassInfo; //pointer to CINT class info class; 223 TString fContextMenuTitle;//context menu title; 224 const std::type_info *fTypeInfo; //pointer to the C++ type information.; 225 ShowMembersFunc_t fShowMembers; //pointer to the class's ShowMembers function; 226 TClassStreamer *fStreamer; //pointer to streamer function; 227 TString fSharedLibs; //shared libraries containing class code; 228 ; 229 TVirtualIsAProxy *fIsA; //!pointer to the class's IsA proxy.; 230 IsAGlobalFunc_t fGlobalIsA; //pointer to a global IsA fu,MatchSource.WIKI,doc/v632/TClass_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/TClass_8h_source.html
https://root.cern/doc/v632/TClass_8h_source.html:16166,Security,hash,hash,16166,"21 static void StreamerStreamerInfo(const TClass* pThis, void *object, TBuffer &b, const TClass *onfile_class);; 322 static void StreamerDefault(const TClass* pThis, void *object, TBuffer &b, const TClass *onfile_class);; 323 ; 324 static IdMap_t *GetIdMap(); //Map from typeid to TClass pointer; 325 static DeclIdMap_t *GetDeclIdMap(); //Map from DeclId_t to TClass pointer; 326 static std::atomic<Int_t> fgClassCount; //provides unique id for a each class; 327 //stored in TObject::fUniqueID; 328 static TDeclNameRegistry fNoInfoOrEmuOrFwdDeclNameRegistry; // Store decl names of the forwardd and no info instances; 329 static Bool_t HasNoInfoOrEmuOrFwdDeclaredDecl(const char*);; 330 ; 331 // Internal status bits, set and reset only during initialization and thus under the protection of the global lock.; 332 enum { kLoading = kReservedLoading, kUnloading = kReservedLoading };; 333 // Internal streamer type.; 334 enum EStreamerType {kDefault=0, kEmulatedStreamer=1, kTObject=2, kInstrumented=4, kForeign=8, kExternal=16};; 335 ; 336 // These are the above-referenced hash tables. (The pointers are null; 337 // if no entries have been made.); 338 static THashTable* fgClassTypedefHash;; 339 ; 340 TVirtualStreamerInfo *GetStreamerInfoImpl(Int_t version, Bool_t silent) const;; 341 ; 342 mutable TVirtualMutex *fOVRMutex = nullptr;; 343 typedef std::multimap<void*, Version_t> RepoCont_t;; 344 mutable RepoCont_t fObjectVersionRepository;; 345 ; 346 void UnregisterAddressInRepository(const char *where, void *location, const TClass *what) const;; 347 void MoveAddressInRepository(const char *where, void *oldadd, void *newadd, const TClass *what) const;; 348 void RegisterAddressInRepository(const char *where, void *location, const TClass *what) const;; 349 ; 350private:; 351 TClass(const TClass& tc) = delete;; 352 TClass& operator=(const TClass&) = delete;; 353 ; 354 bool IsClassStructOrUnion() const { return Property() & (kIsClass|kIsStruct|kIsUnion); }; 355 TList *CreateListOfDataMemb",MatchSource.WIKI,doc/v632/TClass_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/TClass_8h_source.html
https://root.cern/doc/v632/TClass_8h_source.html:17277,Security,checksum,checksum,17277,"sh;; 339 ; 340 TVirtualStreamerInfo *GetStreamerInfoImpl(Int_t version, Bool_t silent) const;; 341 ; 342 mutable TVirtualMutex *fOVRMutex = nullptr;; 343 typedef std::multimap<void*, Version_t> RepoCont_t;; 344 mutable RepoCont_t fObjectVersionRepository;; 345 ; 346 void UnregisterAddressInRepository(const char *where, void *location, const TClass *what) const;; 347 void MoveAddressInRepository(const char *where, void *oldadd, void *newadd, const TClass *what) const;; 348 void RegisterAddressInRepository(const char *where, void *location, const TClass *what) const;; 349 ; 350private:; 351 TClass(const TClass& tc) = delete;; 352 TClass& operator=(const TClass&) = delete;; 353 ; 354 bool IsClassStructOrUnion() const { return Property() & (kIsClass|kIsStruct|kIsUnion); }; 355 TList *CreateListOfDataMembers(std::atomic<TListOfDataMembers*> &data, TDictionary::EMemberSelection selection, bool load);; 356 ; 357protected:; 358 TVirtualStreamerInfo *FindStreamerInfo(TObjArray *arr, UInt_t checksum) const;; 359 void GetMissingDictionariesForBaseClasses(TCollection &result, TCollection &visited, bool recurse);; 360 void GetMissingDictionariesForMembers(TCollection &result, TCollection &visited, bool recurse);; 361 void GetMissingDictionariesWithRecursionCheck(TCollection &result, TCollection &visited, bool recurse);; 362 void GetMissingDictionariesForPairElements(TCollection &result, TCollection &visited, bool recurse);; 363 ; 364public:; 365 TClass();; 366 TClass(const char *name, Bool_t silent = kFALSE);; 367 TClass(const char *name, Version_t cversion, Bool_t silent = kFALSE);; 368 TClass(const char *name, Version_t cversion, EState theState, Bool_t silent = kFALSE);; 369 TClass(ClassInfo_t *info, Version_t cversion,; 370 const char *dfil, const char *ifil = nullptr,; 371 Int_t dl = 0, Int_t il = 0, Bool_t silent = kFALSE);; 372 TClass(const char *name, Version_t cversion,; 373 const char *dfil, const char *ifil = nullptr,; 374 Int_t dl = 0, Int_t il = 0, Bool_t silent = kF",MatchSource.WIKI,doc/v632/TClass_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/TClass_8h_source.html
https://root.cern/doc/v632/TClass_8h_source.html:19765,Security,checksum,checksum,19765,"t_t ReadRules();; 386 void AdoptSchemaRules( ROOT::Detail::TSchemaRuleSet *rules );; 387 void Browse(TBrowser *b) override;; 388 void BuildRealData(void *pointer = nullptr, Bool_t isTransient = kFALSE);; 389 void BuildEmulatedRealData(const char *name, Longptr_t offset, TClass *cl, Bool_t isTransient = kFALSE);; 390 void CalculateStreamerOffset() const;; 391 Bool_t CallShowMembers(const void* obj, TMemberInspector &insp, Bool_t isTransient = kFALSE) const;; 392 Bool_t CanSplit() const;; 393 Bool_t CanIgnoreTObjectStreamer() { return TestBit(kIgnoreTObjectStreamer);}; 394 Long_t ClassProperty() const;; 395 TObject *Clone(const char *newname="""") const override;; 396 void CopyCollectionProxy(const TVirtualCollectionProxy&);; 397 void Draw(Option_t *option="""") override;; 398 void Dump() const override { TDictionary::Dump(); }; 399 void Dump(const void *obj, Bool_t noAddr = kFALSE) const;; 400 char *EscapeChars(const char *text) const;; 401 TVirtualStreamerInfo *FindStreamerInfo(UInt_t checksum, Bool_t isTransient = kFALSE) const;; 402 TVirtualStreamerInfo *GetConversionStreamerInfo( const char* onfile_classname, Int_t version ) const;; 403 TVirtualStreamerInfo *FindConversionStreamerInfo( const char* onfile_classname, UInt_t checksum ) const;; 404 TVirtualStreamerInfo *GetConversionStreamerInfo( const TClass* onfile_cl, Int_t version ) const;; 405 TVirtualStreamerInfo *FindConversionStreamerInfo( const TClass* onfile_cl, UInt_t checksum ) const;; 406 void ForceReload (TClass* oldcl);; 407 Bool_t HasDataMemberInfo() const { return fIsSyntheticPair || fHasRootPcmInfo || HasInterpreterInfo(); }; 408 Bool_t HasDefaultConstructor(Bool_t testio = kFALSE) const;; 409 Bool_t HasInterpreterInfoInMemory() const { return nullptr != fClassInfo; }; 410 Bool_t HasInterpreterInfo() const { return fCanLoadClassInfo || fClassInfo; }; 411 UInt_t GetCheckSum(ECheckSum code = kCurrentCheckSum) const;; 412 UInt_t GetCheckSum(Bool_t &isvalid) const;; 413 UInt_t GetCheckSum(ECheckSum code, Boo",MatchSource.WIKI,doc/v632/TClass_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/TClass_8h_source.html
https://root.cern/doc/v632/TClass_8h_source.html:20010,Security,checksum,checksum,20010," *name, Longptr_t offset, TClass *cl, Bool_t isTransient = kFALSE);; 390 void CalculateStreamerOffset() const;; 391 Bool_t CallShowMembers(const void* obj, TMemberInspector &insp, Bool_t isTransient = kFALSE) const;; 392 Bool_t CanSplit() const;; 393 Bool_t CanIgnoreTObjectStreamer() { return TestBit(kIgnoreTObjectStreamer);}; 394 Long_t ClassProperty() const;; 395 TObject *Clone(const char *newname="""") const override;; 396 void CopyCollectionProxy(const TVirtualCollectionProxy&);; 397 void Draw(Option_t *option="""") override;; 398 void Dump() const override { TDictionary::Dump(); }; 399 void Dump(const void *obj, Bool_t noAddr = kFALSE) const;; 400 char *EscapeChars(const char *text) const;; 401 TVirtualStreamerInfo *FindStreamerInfo(UInt_t checksum, Bool_t isTransient = kFALSE) const;; 402 TVirtualStreamerInfo *GetConversionStreamerInfo( const char* onfile_classname, Int_t version ) const;; 403 TVirtualStreamerInfo *FindConversionStreamerInfo( const char* onfile_classname, UInt_t checksum ) const;; 404 TVirtualStreamerInfo *GetConversionStreamerInfo( const TClass* onfile_cl, Int_t version ) const;; 405 TVirtualStreamerInfo *FindConversionStreamerInfo( const TClass* onfile_cl, UInt_t checksum ) const;; 406 void ForceReload (TClass* oldcl);; 407 Bool_t HasDataMemberInfo() const { return fIsSyntheticPair || fHasRootPcmInfo || HasInterpreterInfo(); }; 408 Bool_t HasDefaultConstructor(Bool_t testio = kFALSE) const;; 409 Bool_t HasInterpreterInfoInMemory() const { return nullptr != fClassInfo; }; 410 Bool_t HasInterpreterInfo() const { return fCanLoadClassInfo || fClassInfo; }; 411 UInt_t GetCheckSum(ECheckSum code = kCurrentCheckSum) const;; 412 UInt_t GetCheckSum(Bool_t &isvalid) const;; 413 UInt_t GetCheckSum(ECheckSum code, Bool_t &isvalid) const;; 414 TVirtualCollectionProxy *GetCollectionProxy() const;; 415 TVirtualIsAProxy *GetIsAProxy() const;; 416 TMethod *GetClassMethod(const char *name, const char *params, Bool_t objectIsConst = kFALSE);; 417 TMethod *GetClassM",MatchSource.WIKI,doc/v632/TClass_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/TClass_8h_source.html
https://root.cern/doc/v632/TClass_8h_source.html:20217,Security,checksum,checksum,20217,") const;; 392 Bool_t CanSplit() const;; 393 Bool_t CanIgnoreTObjectStreamer() { return TestBit(kIgnoreTObjectStreamer);}; 394 Long_t ClassProperty() const;; 395 TObject *Clone(const char *newname="""") const override;; 396 void CopyCollectionProxy(const TVirtualCollectionProxy&);; 397 void Draw(Option_t *option="""") override;; 398 void Dump() const override { TDictionary::Dump(); }; 399 void Dump(const void *obj, Bool_t noAddr = kFALSE) const;; 400 char *EscapeChars(const char *text) const;; 401 TVirtualStreamerInfo *FindStreamerInfo(UInt_t checksum, Bool_t isTransient = kFALSE) const;; 402 TVirtualStreamerInfo *GetConversionStreamerInfo( const char* onfile_classname, Int_t version ) const;; 403 TVirtualStreamerInfo *FindConversionStreamerInfo( const char* onfile_classname, UInt_t checksum ) const;; 404 TVirtualStreamerInfo *GetConversionStreamerInfo( const TClass* onfile_cl, Int_t version ) const;; 405 TVirtualStreamerInfo *FindConversionStreamerInfo( const TClass* onfile_cl, UInt_t checksum ) const;; 406 void ForceReload (TClass* oldcl);; 407 Bool_t HasDataMemberInfo() const { return fIsSyntheticPair || fHasRootPcmInfo || HasInterpreterInfo(); }; 408 Bool_t HasDefaultConstructor(Bool_t testio = kFALSE) const;; 409 Bool_t HasInterpreterInfoInMemory() const { return nullptr != fClassInfo; }; 410 Bool_t HasInterpreterInfo() const { return fCanLoadClassInfo || fClassInfo; }; 411 UInt_t GetCheckSum(ECheckSum code = kCurrentCheckSum) const;; 412 UInt_t GetCheckSum(Bool_t &isvalid) const;; 413 UInt_t GetCheckSum(ECheckSum code, Bool_t &isvalid) const;; 414 TVirtualCollectionProxy *GetCollectionProxy() const;; 415 TVirtualIsAProxy *GetIsAProxy() const;; 416 TMethod *GetClassMethod(const char *name, const char *params, Bool_t objectIsConst = kFALSE);; 417 TMethod *GetClassMethodWithPrototype(const char *name, const char *proto,; 418 Bool_t objectIsConst = kFALSE,; 419 ROOT::EFunctionMatchMode mode = ROOT::kConversionMatch);; 420 Version_t GetClassVersion() const {; 421 if (!fV",MatchSource.WIKI,doc/v632/TClass_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/TClass_8h_source.html
https://root.cern/doc/v632/TClass_8h_source.html:25241,Security,checksum,checksum,25241,"apInstanceCount() const { return fOnHeap; }; 468 void GetMenuItems(TList *listitems);; 469 TList *GetMenuList() const;; 470 TMethod *GetMethod(const char *method, const char *params, Bool_t objectIsConst = kFALSE);; 471 TMethod *GetMethodWithPrototype(const char *method, const char *proto, Bool_t objectIsConst = kFALSE,; 472 ROOT::EFunctionMatchMode mode = ROOT::kConversionMatch);; 473 TMethod *GetMethodAny(const char *method);; 474 TMethod *GetMethodAllAny(const char *method);; 475 Int_t GetNdata();; 476 ROOT::MergeFunc_t GetMerge() const;; 477 ROOT::ResetAfterMergeFunc_t GetResetAfterMerge() const;; 478 ROOT::NewFunc_t GetNew() const;; 479 ROOT::NewArrFunc_t GetNewArray() const;; 480 Int_t GetNmethods();; 481 TClass *const*GetPersistentRef() const { return fPersistentRef; }; 482 TRealData *GetRealData(const char *name) const;; 483 TVirtualRefProxy *GetReferenceProxy() const { return fRefProxy; }; 484 const ROOT::Detail::TSchemaRuleSet *GetSchemaRules() const;; 485 ROOT::Detail::TSchemaRuleSet *GetSchemaRules(Bool_t create = kFALSE);; 486 const char *GetSharedLibs();; 487 ShowMembersFunc_t GetShowMembersWrapper() const { return fShowMembers; }; 488 EState GetState() const { return fState; }; 489 TClassStreamer *GetStreamer() const;; 490 ClassStreamerFunc_t GetStreamerFunc() const;; 491 ClassConvStreamerFunc_t GetConvStreamerFunc() const;; 492 const TObjArray *GetStreamerInfos() const { return fStreamerInfo; }; 493 TVirtualStreamerInfo *GetStreamerInfo(Int_t version=0, Bool_t isTransient = kFALSE) const;; 494 TVirtualStreamerInfo *GetStreamerInfoAbstractEmulated(Int_t version=0) const;; 495 TVirtualStreamerInfo *FindStreamerInfoAbstractEmulated(UInt_t checksum) const;; 496 const std::type_info *GetTypeInfo() const { return fTypeInfo; };; 497 ; 498 /// @brief Return 'true' if we can guarantee that if this class (or any class in; 499 /// this class inheritance hierarchy) overload TObject::Hash it also starts; 500 /// the RecursiveRemove process from its own destructor.",MatchSource.WIKI,doc/v632/TClass_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/TClass_8h_source.html
https://root.cern/doc/v632/TClass_8h_source.html:26976,Security,checksum,checksum,26976,"_t HasDictionary() const;; 510 static Bool_t HasDictionarySelection(const char* clname);; 511 Bool_t HasLocalHashMember() const;; 512 void GetMissingDictionaries(THashTable& result, bool recurse = false);; 513 void IgnoreTObjectStreamer(Bool_t ignore=kTRUE);; 514 Bool_t InheritsFrom(const char *cl) const override;; 515 Bool_t InheritsFrom(const TClass *cl) const override;; 516 void InterpretedShowMembers(void* obj, TMemberInspector &insp, Bool_t isTransient);; 517 Bool_t IsFolder() const override { return kTRUE; }; 518 Bool_t IsLoaded() const;; 519 Bool_t IsForeign() const;; 520 Bool_t IsStartingWithTObject() const;; 521 Bool_t IsSyntheticPair() const { return fIsSyntheticPair; }; 522 Bool_t IsVersioned() const { return !( GetClassVersion()<=1 && IsForeign() ); }; 523 Bool_t IsTObject() const;; 524 static TClass *LoadClass(const char *requestedname, Bool_t silent);; 525 void ls(Option_t *opt="""") const override;; 526 void MakeCustomMenuList();; 527 Bool_t MatchLegacyCheckSum(UInt_t checksum) const;; 528 void Move(void *arenaFrom, void *arenaTo) const;; 529 void *New(ENewType defConstructor = kClassNew, Bool_t quiet = kFALSE) const;; 530 void *New(void *arena, ENewType defConstructor = kClassNew) const;; 531 void *NewArray(Long_t nElements, ENewType defConstructor = kClassNew) const;; 532 void *NewArray(Long_t nElements, void *arena, ENewType defConstructor = kClassNew) const;; 533 ObjectPtr NewObject(ENewType defConstructor = kClassNew, Bool_t quiet = kFALSE) const;; 534 ObjectPtr NewObject(void *arena, ENewType defConstructor = kClassNew) const;; 535 ObjectPtr NewObjectArray(Long_t nElements, ENewType defConstructor = kClassNew) const;; 536 ObjectPtr NewObjectArray(Long_t nElements, void *arena, ENewType defConstructor = kClassNew) const;; 537 virtual void PostLoadCheck();; 538 Long_t Property() const override;; 539 Int_t ReadBuffer(TBuffer &b, void *pointer, Int_t version, UInt_t start, UInt_t count);; 540 Int_t ReadBuffer(TBuffer &b, void *pointer);; 541 void Regis",MatchSource.WIKI,doc/v632/TClass_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/TClass_8h_source.html
https://root.cern/doc/v632/TClass_8h_source.html:44521,Security,access,accessor,44521,"ongptr_t faddr)Look for a method in this class that has the interface function address faddr.Definition TClass.cxx:4483; TClass::DetermineCurrentStreamerInfoTVirtualStreamerInfo * DetermineCurrentStreamerInfo()Determine and set pointer to current TVirtualStreamerInfo.Definition TClass.cxx:5684; TClass::Browsevoid Browse(TBrowser *b) overrideThis method is called by a browser to get the class information.Definition TClass.cxx:2010; TClass::GetStateEState GetState() constDefinition TClass.h:488; TClass::GetCollectionTypeROOT::ESTLType GetCollectionType() constReturn the 'type' of the STL the TClass is representing.Definition TClass.cxx:2886; TClass::AdoptMemberStreamervoid AdoptMemberStreamer(const char *name, TMemberStreamer *strm)Adopt the TMemberStreamer pointer to by p and use it to Stream non basic member name.Definition TClass.cxx:6703; TClass::ResetInstanceCountvoid ResetInstanceCount()Definition TClass.h:547; TClass::GetStreamerFuncClassStreamerFunc_t GetStreamerFunc() constGet a wrapper/accessor function around this class custom streamer (member function).Definition TClass.cxx:2939; TClass::RemoveStreamerInfovoid RemoveStreamerInfo(Int_t slot)Remove and delete the StreamerInfo in the given slot.Definition TClass.cxx:7320; TClass::SetCanSplitvoid SetCanSplit(Int_t splitmode)Set the splitability of this class:Definition TClass.cxx:5658; TClass::AddInstancevoid AddInstance(Bool_t heap=kFALSE)Definition TClass.h:381; TClass::CreateListOfDataMembersTList * CreateListOfDataMembers(std::atomic< TListOfDataMembers * > &data, TDictionary::EMemberSelection selection, bool load)Create the list containing the TDataMembers (of actual data members or members pulled in through usin...Definition TClass.cxx:3741; TClass::GetStreamerInfoAbstractEmulatedTVirtualStreamerInfo * GetStreamerInfoAbstractEmulated(Int_t version=0) constFor the case where the requestor class is emulated and this class is abstract, returns a pointer to t...Definition TClass.cxx:4709; TClass::Newvoid * Ne",MatchSource.WIKI,doc/v632/TClass_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/TClass_8h_source.html
https://root.cern/doc/v632/TClass_8h_source.html:55991,Security,checksum,checksum,55991," TClass.cxx:3477; TClass::GetNdataInt_t GetNdata()Return the number of data members of this class Note that in case the list of data members is not yet...Definition TClass.cxx:4554; TClass::SetDestructorvoid SetDestructor(ROOT::DesFunc_t destructorFunc)Install a new wrapper around the destructor.Definition TClass.cxx:7017; TClass::PostLoadCheckvirtual void PostLoadCheck()Do the initialization that can only be done after the CINT dictionary has been fully populated and ca...Definition TClass.cxx:5959; TClass::LoadClassInfovoid LoadClassInfo() constTry to load the ClassInfo if available.Definition TClass.cxx:5824; TClass::SetResetAfterMergevoid SetResetAfterMerge(ROOT::ResetAfterMergeFunc_t resetFunc)Install a new wrapper around 'ResetAfterMerge'.Definition TClass.cxx:6977; TClass::GetStreamerInfoImplTVirtualStreamerInfo * GetStreamerInfoImpl(Int_t version, Bool_t silent) constDefinition TClass.cxx:4634; TClass::MatchLegacyCheckSumBool_t MatchLegacyCheckSum(UInt_t checksum) constReturn true if the checksum passed as argument is one of the checksum value produced by the older che...Definition TClass.cxx:6494; TClass::fAllPubMethodTViewPubFunctions * fAllPubMethodDefinition TClass.h:210; TClass::ERuntimePropertiesERuntimePropertiesIndicates whether GetClassVersion has been called.Definition TClass.h:264; TClass::ERuntimeProperties::kSet@ kSet; TClass::ERuntimeProperties::kConsistentHash@ kConsistentHash; TClass::ERuntimeProperties::kNotInitialized@ kNotInitialized; TClass::HasInterpreterInfoBool_t HasInterpreterInfo() constDefinition TClass.h:410; TClass::AddClassstatic void AddClass(TClass *cl)static: Add a class to the list and map of classes.Definition TClass.cxx:494; TClass::GetMissingDictionariesForBaseClassesvoid GetMissingDictionariesForBaseClasses(TCollection &result, TCollection &visited, bool recurse)Verify the base classes always.Definition TClass.cxx:3927; TClass::fSchemaRulesROOT::Detail::TSchemaRuleSet * fSchemaRulesPointer to reference proxy if this class",MatchSource.WIKI,doc/v632/TClass_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/TClass_8h_source.html
https://root.cern/doc/v632/TClass_8h_source.html:56025,Security,checksum,checksum,56025," TClass.cxx:3477; TClass::GetNdataInt_t GetNdata()Return the number of data members of this class Note that in case the list of data members is not yet...Definition TClass.cxx:4554; TClass::SetDestructorvoid SetDestructor(ROOT::DesFunc_t destructorFunc)Install a new wrapper around the destructor.Definition TClass.cxx:7017; TClass::PostLoadCheckvirtual void PostLoadCheck()Do the initialization that can only be done after the CINT dictionary has been fully populated and ca...Definition TClass.cxx:5959; TClass::LoadClassInfovoid LoadClassInfo() constTry to load the ClassInfo if available.Definition TClass.cxx:5824; TClass::SetResetAfterMergevoid SetResetAfterMerge(ROOT::ResetAfterMergeFunc_t resetFunc)Install a new wrapper around 'ResetAfterMerge'.Definition TClass.cxx:6977; TClass::GetStreamerInfoImplTVirtualStreamerInfo * GetStreamerInfoImpl(Int_t version, Bool_t silent) constDefinition TClass.cxx:4634; TClass::MatchLegacyCheckSumBool_t MatchLegacyCheckSum(UInt_t checksum) constReturn true if the checksum passed as argument is one of the checksum value produced by the older che...Definition TClass.cxx:6494; TClass::fAllPubMethodTViewPubFunctions * fAllPubMethodDefinition TClass.h:210; TClass::ERuntimePropertiesERuntimePropertiesIndicates whether GetClassVersion has been called.Definition TClass.h:264; TClass::ERuntimeProperties::kSet@ kSet; TClass::ERuntimeProperties::kConsistentHash@ kConsistentHash; TClass::ERuntimeProperties::kNotInitialized@ kNotInitialized; TClass::HasInterpreterInfoBool_t HasInterpreterInfo() constDefinition TClass.h:410; TClass::AddClassstatic void AddClass(TClass *cl)static: Add a class to the list and map of classes.Definition TClass.cxx:494; TClass::GetMissingDictionariesForBaseClassesvoid GetMissingDictionariesForBaseClasses(TCollection &result, TCollection &visited, bool recurse)Verify the base classes always.Definition TClass.cxx:3927; TClass::fSchemaRulesROOT::Detail::TSchemaRuleSet * fSchemaRulesPointer to reference proxy if this class",MatchSource.WIKI,doc/v632/TClass_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/TClass_8h_source.html
https://root.cern/doc/v632/TClass_8h_source.html:56067,Security,checksum,checksum,56067," TClass.cxx:3477; TClass::GetNdataInt_t GetNdata()Return the number of data members of this class Note that in case the list of data members is not yet...Definition TClass.cxx:4554; TClass::SetDestructorvoid SetDestructor(ROOT::DesFunc_t destructorFunc)Install a new wrapper around the destructor.Definition TClass.cxx:7017; TClass::PostLoadCheckvirtual void PostLoadCheck()Do the initialization that can only be done after the CINT dictionary has been fully populated and ca...Definition TClass.cxx:5959; TClass::LoadClassInfovoid LoadClassInfo() constTry to load the ClassInfo if available.Definition TClass.cxx:5824; TClass::SetResetAfterMergevoid SetResetAfterMerge(ROOT::ResetAfterMergeFunc_t resetFunc)Install a new wrapper around 'ResetAfterMerge'.Definition TClass.cxx:6977; TClass::GetStreamerInfoImplTVirtualStreamerInfo * GetStreamerInfoImpl(Int_t version, Bool_t silent) constDefinition TClass.cxx:4634; TClass::MatchLegacyCheckSumBool_t MatchLegacyCheckSum(UInt_t checksum) constReturn true if the checksum passed as argument is one of the checksum value produced by the older che...Definition TClass.cxx:6494; TClass::fAllPubMethodTViewPubFunctions * fAllPubMethodDefinition TClass.h:210; TClass::ERuntimePropertiesERuntimePropertiesIndicates whether GetClassVersion has been called.Definition TClass.h:264; TClass::ERuntimeProperties::kSet@ kSet; TClass::ERuntimeProperties::kConsistentHash@ kConsistentHash; TClass::ERuntimeProperties::kNotInitialized@ kNotInitialized; TClass::HasInterpreterInfoBool_t HasInterpreterInfo() constDefinition TClass.h:410; TClass::AddClassstatic void AddClass(TClass *cl)static: Add a class to the list and map of classes.Definition TClass.cxx:494; TClass::GetMissingDictionariesForBaseClassesvoid GetMissingDictionariesForBaseClasses(TCollection &result, TCollection &visited, bool recurse)Verify the base classes always.Definition TClass.cxx:3927; TClass::fSchemaRulesROOT::Detail::TSchemaRuleSet * fSchemaRulesPointer to reference proxy if this class",MatchSource.WIKI,doc/v632/TClass_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/TClass_8h_source.html
https://root.cern/doc/v632/TClass_8h_source.html:59698,Security,access,accessor,59698,"ent)Helper function used by TClass::GetClass().Definition TClass.cxx:5749; TClass::fSharedLibsTString fSharedLibsDefinition TClass.h:227; TClass::GetTypeInfoconst std::type_info * GetTypeInfo() constDefinition TClass.h:496; TClass::GetListOfDataMembersTList * GetListOfDataMembers(Bool_t load=kTRUE)Return list containing the TDataMembers of a class.Definition TClass.cxx:3770; TClass::ENewTypeENewTypeDefinition TClass.h:107; TClass::kClassNew@ kClassNewDefinition TClass.h:107; TClass::kRealNew@ kRealNewDefinition TClass.h:107; TClass::kDummyNew@ kDummyNewDefinition TClass.h:107; TClass::Movevoid Move(void *arenaFrom, void *arenaTo) constRegister the fact that an object was moved from the memory location 'arenaFrom' to the memory locatio...Definition TClass.cxx:4327; TClass::GetDeclIdMapstatic DeclIdMap_t * GetDeclIdMap()Definition TClass.cxx:480; TClass::GetDeclFileLineShort_t GetDeclFileLine() constDefinition TClass.h:429; TClass::SetStreamerFuncvoid SetStreamerFunc(ClassStreamerFunc_t strm)Set a wrapper/accessor function around this class custom streamer.Definition TClass.cxx:6922; TClass::GetImplFileNameconst char * GetImplFileName() constDefinition TClass.h:456; TClass::GetListOfRealDataTList * GetListOfRealData() constDefinition TClass.h:453; TClass::SizeInt_t Size() constReturn size of object of this class.Definition TClass.cxx:5704; TClass::SetCurrentStreamerInfovoid SetCurrentStreamerInfo(TVirtualStreamerInfo *info)Set pointer to current TVirtualStreamerInfo.Definition TClass.cxx:5696; TClass::GetDictstatic DictFuncPtr_t GetDict(const char *cname)Return a pointer to the dictionary loading function generated by rootcint.Definition TClass.cxx:3422; TClass::fOffsetStreamerLongptr_t fOffsetStreamerProperties that can only be evaluated at run-time.Definition TClass.h:275; TClass::fSizeofInt_t fSizeofDefinition TClass.h:243; TClass::GetNewArrayROOT::NewArrFunc_t GetNewArray() constReturn the wrapper around new ThisClass[].Definition TClass.cxx:7455; TClass::RepoCont",MatchSource.WIKI,doc/v632/TClass_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/TClass_8h_source.html
https://root.cern/doc/v632/TClass_8h_source.html:66071,Security,access,accessor,66071,"on TClass.h:334; TClass::kInstrumented@ kInstrumentedDefinition TClass.h:334; TClass::kTObject@ kTObjectDefinition TClass.h:334; TClass::AddRulestatic Bool_t AddRule(const char *rule)Add a schema evolution customization rule.Definition TClass.cxx:1890; TClass::IsTObjectBool_t IsTObject() constReturn kTRUE is the class inherits from TObject.Definition TClass.cxx:5938; TClass::GetContextMenuTitleconst char * GetContextMenuTitle() constDefinition TClass.h:438; TClass::RemoveClassstatic void RemoveClass(TClass *cl)static: Remove a class from the list and map of classesDefinition TClass.cxx:520; TClass::HasLocalHashMemberBool_t HasLocalHashMember() constReturns true if this class has an definition and/or overload of the member function Hash.Definition TClass.cxx:7421; TClass::DeleteArrayvoid DeleteArray(void *ary, Bool_t dtorOnly=kFALSE)Explicitly call operator delete[] for an array.Definition TClass.cxx:5529; TClass::GetConvStreamerFuncClassConvStreamerFunc_t GetConvStreamerFunc() constGet a wrapper/accessor function around this class custom conversion streamer (member function).Definition TClass.cxx:2947; TClass::IsForeignBool_t IsForeign() constReturn kTRUE is the class is Foreign (the class does not have a Streamer method).Definition TClass.cxx:5947; TClass::GetClassInfoClassInfo_t * GetClassInfo() constDefinition TClass.h:433; TClass::fDeleteROOT::DelFunc_t fDeleteDefinition TClass.h:237; TClass::fAllPubDataTViewPubDataMembers * fAllPubDataDefinition TClass.h:209; TClass::fClassInfoClassInfo_t * fClassInfoDefinition TClass.h:222; TClass::GetStreamerInfoTVirtualStreamerInfo * GetStreamerInfo(Int_t version=0, Bool_t isTransient=kFALSE) constreturns a pointer to the TVirtualStreamerInfo object for version If the object does not exist,...Definition TClass.cxx:4599; TClass::HasConsistentHashMemberBool_t HasConsistentHashMember()Return 'true' if we can guarantee that if this class (or any class in this class inheritance hierarch...Definition TClass.h:501; TClass::AdoptStre",MatchSource.WIKI,doc/v632/TClass_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/TClass_8h_source.html
https://root.cern/doc/v632/TClass_8h_source.html:70224,Security,access,access,70224,"alue of fStreamerType.Definition TClass.cxx:6215; TClass::GetSharedLibsconst char * GetSharedLibs()Get the list of shared libraries containing the code for class cls.Definition TClass.cxx:3623; TClass::CalculateStreamerOffsetvoid CalculateStreamerOffset() constCalculate the offset between an object of this class to its base class TObject.Definition TClass.cxx:2183; TClass::GetMissingDictionariesForPairElementsvoid GetMissingDictionariesForPairElements(TCollection &result, TCollection &visited, bool recurse)Definition TClass.cxx:3973; TClass::ReplaceWithvoid ReplaceWith(TClass *newcl) constDefinition TClass.cxx:4142; TClass::RegisterAddressInRepositoryvoid RegisterAddressInRepository(const char *where, void *location, const TClass *what) constDefinition TClass.cxx:290; TClass::PropertyLong_t Property() const overrideReturns the properties of the TClass as a bit field stored as a Long_t value.Definition TClass.cxx:6086; TClass::HasDefaultConstructorBool_t HasDefaultConstructor(Bool_t testio=kFALSE) constReturn true if we have access to a constructor usable for I/O.Definition TClass.cxx:7393; TClass::GetMenuItemsvoid GetMenuItems(TList *listitems)Returns list of methods accessible by context menu.Definition TClass.cxx:3874; TClass::SetNewvoid SetNew(ROOT::NewFunc_t newFunc)Install a new wrapper around 'new'.Definition TClass.cxx:6985; TClass::fIsAMethodstd::atomic< TMethodCall * > fIsAMethodDefinition TClass.h:231; TClass::ReadRulesstatic Int_t ReadRules()Read the class.rules files from the default location:.Definition TClass.cxx:1820; TClass::CanSplitBaseAllowBool_t CanSplitBaseAllow()Pointer to the function implementing streaming for this class.Definition TClass.cxx:2247; TClass::MoveAddressInRepositoryvoid MoveAddressInRepository(const char *where, void *oldadd, void *newadd, const TClass *what) constDefinition TClass.cxx:337; TClass::fStreamerImplstd::atomic< StreamerImpl_t > fStreamerImplDefinition TClass.h:287; TClass::SetContextMenuTitlevoid SetContextMenuTitle(c",MatchSource.WIKI,doc/v632/TClass_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/TClass_8h_source.html
https://root.cern/doc/v632/TClass_8h_source.html:70370,Security,access,accessible,70370," class cls.Definition TClass.cxx:3623; TClass::CalculateStreamerOffsetvoid CalculateStreamerOffset() constCalculate the offset between an object of this class to its base class TObject.Definition TClass.cxx:2183; TClass::GetMissingDictionariesForPairElementsvoid GetMissingDictionariesForPairElements(TCollection &result, TCollection &visited, bool recurse)Definition TClass.cxx:3973; TClass::ReplaceWithvoid ReplaceWith(TClass *newcl) constDefinition TClass.cxx:4142; TClass::RegisterAddressInRepositoryvoid RegisterAddressInRepository(const char *where, void *location, const TClass *what) constDefinition TClass.cxx:290; TClass::PropertyLong_t Property() const overrideReturns the properties of the TClass as a bit field stored as a Long_t value.Definition TClass.cxx:6086; TClass::HasDefaultConstructorBool_t HasDefaultConstructor(Bool_t testio=kFALSE) constReturn true if we have access to a constructor usable for I/O.Definition TClass.cxx:7393; TClass::GetMenuItemsvoid GetMenuItems(TList *listitems)Returns list of methods accessible by context menu.Definition TClass.cxx:3874; TClass::SetNewvoid SetNew(ROOT::NewFunc_t newFunc)Install a new wrapper around 'new'.Definition TClass.cxx:6985; TClass::fIsAMethodstd::atomic< TMethodCall * > fIsAMethodDefinition TClass.h:231; TClass::ReadRulesstatic Int_t ReadRules()Read the class.rules files from the default location:.Definition TClass.cxx:1820; TClass::CanSplitBaseAllowBool_t CanSplitBaseAllow()Pointer to the function implementing streaming for this class.Definition TClass.cxx:2247; TClass::MoveAddressInRepositoryvoid MoveAddressInRepository(const char *where, void *oldadd, void *newadd, const TClass *what) constDefinition TClass.cxx:337; TClass::fStreamerImplstd::atomic< StreamerImpl_t > fStreamerImplDefinition TClass.h:287; TClass::SetContextMenuTitlevoid SetContextMenuTitle(const char *title)Change (i.e. set) the title of the TNamed.Definition TClass.cxx:6269; TClass::GetShowMembersWrapperShowMembersFunc_t GetShowMembersWrappe",MatchSource.WIKI,doc/v632/TClass_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/TClass_8h_source.html
https://root.cern/doc/v632/TClass_8h_source.html:73055,Security,checksum,checksum,73055,"ss *pThis, void *obj, TBuffer &b, const TClass *onfile_class)Schema evolution rules.Definition TClass.h:283; TClass::GetImplFileLineShort_t GetImplFileLine() constDefinition TClass.h:457; TClass::GetMethodAllAnyTMethod * GetMethodAllAny(const char *method)Return pointer to method without looking at parameters.Definition TClass.cxx:4384; TClass::fRuntimePropertiesstd::atomic< UChar_t > fRuntimePropertiesDefinition TClass.h:273; TClass::EStateEStateDefinition TClass.h:121; TClass::kInterpreted@ kInterpretedDefinition TClass.h:126; TClass::kHasTClassInit@ kHasTClassInitDefinition TClass.h:127; TClass::kEmulated@ kEmulatedDefinition TClass.h:125; TClass::kNoInfo@ kNoInfoDefinition TClass.h:122; TClass::kLoaded@ kLoadedDefinition TClass.h:130; TClass::kForwardDeclared@ kForwardDeclaredDefinition TClass.h:124; TClass::kNamespaceForMeta@ kNamespaceForMetaDefinition TClass.h:131; TClass::FindConversionStreamerInfoTVirtualStreamerInfo * FindConversionStreamerInfo(const char *onfile_classname, UInt_t checksum) constReturn a Conversion StreamerInfo from the class 'classname' for the layout represented by 'checksum' ...Definition TClass.cxx:7193; TClass::GetBaseClassOffsetRecurseInt_t GetBaseClassOffsetRecurse(const TClass *toBase)Return data member offset to the base class ""cl"".Definition TClass.cxx:2705; TClass::GetDeleteROOT::DelFunc_t GetDelete() constReturn the wrapper around delete ThiObject.Definition TClass.cxx:7463; TClass::LoadClassDefaultstatic TClass * LoadClassDefault(const char *requestedname, Bool_t silent)Helper function used by TClass::GetClass().Definition TClass.cxx:5771; TClass::IsVersionedBool_t IsVersioned() constDefinition TClass.h:522; TClass::SetClassSizevoid SetClassSize(Int_t sizof)Definition TClass.h:307; TClass::FindClassOrBaseMethodWithIdTMethod * FindClassOrBaseMethodWithId(DeclId_t faddr)Find a method with decl id in this class or its bases.Definition TClass.cxx:4440; TClass::StreamerExternalstatic void StreamerExternal(const TClass *pThis, void *",MatchSource.WIKI,doc/v632/TClass_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/TClass_8h_source.html
https://root.cern/doc/v632/TClass_8h_source.html:73161,Security,checksum,checksum,73161,"ss *pThis, void *obj, TBuffer &b, const TClass *onfile_class)Schema evolution rules.Definition TClass.h:283; TClass::GetImplFileLineShort_t GetImplFileLine() constDefinition TClass.h:457; TClass::GetMethodAllAnyTMethod * GetMethodAllAny(const char *method)Return pointer to method without looking at parameters.Definition TClass.cxx:4384; TClass::fRuntimePropertiesstd::atomic< UChar_t > fRuntimePropertiesDefinition TClass.h:273; TClass::EStateEStateDefinition TClass.h:121; TClass::kInterpreted@ kInterpretedDefinition TClass.h:126; TClass::kHasTClassInit@ kHasTClassInitDefinition TClass.h:127; TClass::kEmulated@ kEmulatedDefinition TClass.h:125; TClass::kNoInfo@ kNoInfoDefinition TClass.h:122; TClass::kLoaded@ kLoadedDefinition TClass.h:130; TClass::kForwardDeclared@ kForwardDeclaredDefinition TClass.h:124; TClass::kNamespaceForMeta@ kNamespaceForMetaDefinition TClass.h:131; TClass::FindConversionStreamerInfoTVirtualStreamerInfo * FindConversionStreamerInfo(const char *onfile_classname, UInt_t checksum) constReturn a Conversion StreamerInfo from the class 'classname' for the layout represented by 'checksum' ...Definition TClass.cxx:7193; TClass::GetBaseClassOffsetRecurseInt_t GetBaseClassOffsetRecurse(const TClass *toBase)Return data member offset to the base class ""cl"".Definition TClass.cxx:2705; TClass::GetDeleteROOT::DelFunc_t GetDelete() constReturn the wrapper around delete ThiObject.Definition TClass.cxx:7463; TClass::LoadClassDefaultstatic TClass * LoadClassDefault(const char *requestedname, Bool_t silent)Helper function used by TClass::GetClass().Definition TClass.cxx:5771; TClass::IsVersionedBool_t IsVersioned() constDefinition TClass.h:522; TClass::SetClassSizevoid SetClassSize(Int_t sizof)Definition TClass.h:307; TClass::FindClassOrBaseMethodWithIdTMethod * FindClassOrBaseMethodWithId(DeclId_t faddr)Find a method with decl id in this class or its bases.Definition TClass.cxx:4440; TClass::StreamerExternalstatic void StreamerExternal(const TClass *pThis, void *",MatchSource.WIKI,doc/v632/TClass_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/TClass_8h_source.html
https://root.cern/doc/v632/TClass_8h_source.html:75129,Security,access,accessor,75129,"cial streamer for the class.Definition TClass.cxx:6788; TClass::operator&friend bool operator&(UChar_t l, ERuntimeProperties r)Definition TClass.h:270; TClass::fClassPropertyLong_t fClassPropertyProperty See TClass::Property() for details.Definition TClass.h:256; TClass::fContextMenuTitleTString fContextMenuTitleDefinition TClass.h:223; TClass::StreamerTObjectInitializedstatic void StreamerTObjectInitialized(const TClass *pThis, void *object, TBuffer &b, const TClass *onfile_class)Case of TObjects when fIsOffsetStreamerSet is known to have been set.Definition TClass.cxx:6814; TClass::ConvStreamerInstrumentedstatic void ConvStreamerInstrumented(const TClass *pThis, void *object, TBuffer &b, const TClass *onfile_class)Case of instrumented class with a library.Definition TClass.cxx:6845; TClass::fCanLoadClassInfostd::atomic< Bool_t > fCanLoadClassInfoWhether info was loaded from a root pcm.Definition TClass.h:260; TClass::SetConvStreamerFuncvoid SetConvStreamerFunc(ClassConvStreamerFunc_t strm)Set a wrapper/accessor function around this class custom conversion streamer.Definition TClass.cxx:6945; TClass::FindStreamerInfoTVirtualStreamerInfo * FindStreamerInfo(TObjArray *arr, UInt_t checksum) constFind the TVirtualStreamerInfo in the StreamerInfos corresponding to checksum.Definition TClass.cxx:7066; TClass::GetMissingDictionariesvoid GetMissingDictionaries(THashTable &result, bool recurse=false)Get the classes that have a missing dictionary starting from this one.Definition TClass.cxx:4087; TClass::MakeCustomMenuListvoid MakeCustomMenuList()Makes a customizable version of the popup menu list, i.e.Definition TClass.cxx:4283; TClass::FindStreamerInfoAbstractEmulatedTVirtualStreamerInfo * FindStreamerInfoAbstractEmulated(UInt_t checksum) constFor the case where the requestor class is emulated and this class is abstract, returns a pointer to t...Definition TClass.cxx:4772; TClass::GetMethodAnyTMethod * GetMethodAny(const char *method)Return pointer to method without looking",MatchSource.WIKI,doc/v632/TClass_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/TClass_8h_source.html
https://root.cern/doc/v632/TClass_8h_source.html:75307,Security,checksum,checksum,75307,"Property See TClass::Property() for details.Definition TClass.h:256; TClass::fContextMenuTitleTString fContextMenuTitleDefinition TClass.h:223; TClass::StreamerTObjectInitializedstatic void StreamerTObjectInitialized(const TClass *pThis, void *object, TBuffer &b, const TClass *onfile_class)Case of TObjects when fIsOffsetStreamerSet is known to have been set.Definition TClass.cxx:6814; TClass::ConvStreamerInstrumentedstatic void ConvStreamerInstrumented(const TClass *pThis, void *object, TBuffer &b, const TClass *onfile_class)Case of instrumented class with a library.Definition TClass.cxx:6845; TClass::fCanLoadClassInfostd::atomic< Bool_t > fCanLoadClassInfoWhether info was loaded from a root pcm.Definition TClass.h:260; TClass::SetConvStreamerFuncvoid SetConvStreamerFunc(ClassConvStreamerFunc_t strm)Set a wrapper/accessor function around this class custom conversion streamer.Definition TClass.cxx:6945; TClass::FindStreamerInfoTVirtualStreamerInfo * FindStreamerInfo(TObjArray *arr, UInt_t checksum) constFind the TVirtualStreamerInfo in the StreamerInfos corresponding to checksum.Definition TClass.cxx:7066; TClass::GetMissingDictionariesvoid GetMissingDictionaries(THashTable &result, bool recurse=false)Get the classes that have a missing dictionary starting from this one.Definition TClass.cxx:4087; TClass::MakeCustomMenuListvoid MakeCustomMenuList()Makes a customizable version of the popup menu list, i.e.Definition TClass.cxx:4283; TClass::FindStreamerInfoAbstractEmulatedTVirtualStreamerInfo * FindStreamerInfoAbstractEmulated(UInt_t checksum) constFor the case where the requestor class is emulated and this class is abstract, returns a pointer to t...Definition TClass.cxx:4772; TClass::GetMethodAnyTMethod * GetMethodAny(const char *method)Return pointer to method without looking at parameters.Definition TClass.cxx:4374; TClass::GetIsAProxyTVirtualIsAProxy * GetIsAProxy() constReturn the proxy implementing the IsA functionality.Definition TClass.cxx:2955; TClass::GetClas",MatchSource.WIKI,doc/v632/TClass_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/TClass_8h_source.html
https://root.cern/doc/v632/TClass_8h_source.html:75390,Security,checksum,checksum,75390,"Property See TClass::Property() for details.Definition TClass.h:256; TClass::fContextMenuTitleTString fContextMenuTitleDefinition TClass.h:223; TClass::StreamerTObjectInitializedstatic void StreamerTObjectInitialized(const TClass *pThis, void *object, TBuffer &b, const TClass *onfile_class)Case of TObjects when fIsOffsetStreamerSet is known to have been set.Definition TClass.cxx:6814; TClass::ConvStreamerInstrumentedstatic void ConvStreamerInstrumented(const TClass *pThis, void *object, TBuffer &b, const TClass *onfile_class)Case of instrumented class with a library.Definition TClass.cxx:6845; TClass::fCanLoadClassInfostd::atomic< Bool_t > fCanLoadClassInfoWhether info was loaded from a root pcm.Definition TClass.h:260; TClass::SetConvStreamerFuncvoid SetConvStreamerFunc(ClassConvStreamerFunc_t strm)Set a wrapper/accessor function around this class custom conversion streamer.Definition TClass.cxx:6945; TClass::FindStreamerInfoTVirtualStreamerInfo * FindStreamerInfo(TObjArray *arr, UInt_t checksum) constFind the TVirtualStreamerInfo in the StreamerInfos corresponding to checksum.Definition TClass.cxx:7066; TClass::GetMissingDictionariesvoid GetMissingDictionaries(THashTable &result, bool recurse=false)Get the classes that have a missing dictionary starting from this one.Definition TClass.cxx:4087; TClass::MakeCustomMenuListvoid MakeCustomMenuList()Makes a customizable version of the popup menu list, i.e.Definition TClass.cxx:4283; TClass::FindStreamerInfoAbstractEmulatedTVirtualStreamerInfo * FindStreamerInfoAbstractEmulated(UInt_t checksum) constFor the case where the requestor class is emulated and this class is abstract, returns a pointer to t...Definition TClass.cxx:4772; TClass::GetMethodAnyTMethod * GetMethodAny(const char *method)Return pointer to method without looking at parameters.Definition TClass.cxx:4374; TClass::GetIsAProxyTVirtualIsAProxy * GetIsAProxy() constReturn the proxy implementing the IsA functionality.Definition TClass.cxx:2955; TClass::GetClas",MatchSource.WIKI,doc/v632/TClass_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/TClass_8h_source.html
https://root.cern/doc/v632/TClass_8h_source.html:75861,Security,checksum,checksum,75861,"ith a library.Definition TClass.cxx:6845; TClass::fCanLoadClassInfostd::atomic< Bool_t > fCanLoadClassInfoWhether info was loaded from a root pcm.Definition TClass.h:260; TClass::SetConvStreamerFuncvoid SetConvStreamerFunc(ClassConvStreamerFunc_t strm)Set a wrapper/accessor function around this class custom conversion streamer.Definition TClass.cxx:6945; TClass::FindStreamerInfoTVirtualStreamerInfo * FindStreamerInfo(TObjArray *arr, UInt_t checksum) constFind the TVirtualStreamerInfo in the StreamerInfos corresponding to checksum.Definition TClass.cxx:7066; TClass::GetMissingDictionariesvoid GetMissingDictionaries(THashTable &result, bool recurse=false)Get the classes that have a missing dictionary starting from this one.Definition TClass.cxx:4087; TClass::MakeCustomMenuListvoid MakeCustomMenuList()Makes a customizable version of the popup menu list, i.e.Definition TClass.cxx:4283; TClass::FindStreamerInfoAbstractEmulatedTVirtualStreamerInfo * FindStreamerInfoAbstractEmulated(UInt_t checksum) constFor the case where the requestor class is emulated and this class is abstract, returns a pointer to t...Definition TClass.cxx:4772; TClass::GetMethodAnyTMethod * GetMethodAny(const char *method)Return pointer to method without looking at parameters.Definition TClass.cxx:4374; TClass::GetIsAProxyTVirtualIsAProxy * GetIsAProxy() constReturn the proxy implementing the IsA functionality.Definition TClass.cxx:2955; TClass::GetClassVersionVersion_t GetClassVersion() constDefinition TClass.h:420; TClass::GetMergeROOT::MergeFunc_t GetMerge() constReturn the wrapper around Merge.Definition TClass.cxx:7431; TClass::fResetAfterMergeROOT::ResetAfterMergeFunc_t fResetAfterMergeDefinition TClass.h:234; TClass::IsFolderBool_t IsFolder() const overrideReturns kTRUE in case object contains browsable objects (like containers or lists of other objects).Definition TClass.h:517; TClass::fInstanceCountUInt_t fInstanceCountDefinition TClass.h:217; TClass::fHasRootPcmInfostd::atomic< Bool_t > fHa",MatchSource.WIKI,doc/v632/TClass_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/TClass_8h_source.html
https://root.cern/doc/v632/TClass_8h_source.html:81453,Security,hash,hash,81453,t)Helper function used by TClass::GetClass().Definition TClass.cxx:5801; TClass::GetHeapInstanceCountUInt_t GetHeapInstanceCount() constDefinition TClass.h:467; TClass::fImplFileLineShort_t fImplFileLineDefinition TClass.h:216; TClingThis class defines an interface to the cling C++ interpreter.Definition TCling.h:102; TCollectionCollection abstract base class.Definition TCollection.h:65; TDataMemberAll ROOT classes may have RTTI (run time type identification) support added.Definition TDataMember.h:31; TDictionaryThis class defines an abstract interface that must be implemented by all classes that contain diction...Definition TDictionary.h:168; TDictionary::EMemberSelectionEMemberSelectionKinds of members to include in lists.Definition TDictionary.h:216; TDictionary::DeclId_tconst void * DeclId_tDefinition TDictionary.h:224; TFunctionTemplateDictionary for function template This class describes one single function template.Definition TFunctionTemplate.h:26; THashTableTHashTable implements a hash table to store TObject's.Definition THashTable.h:35; TListOfDataMembersA collection of TDataMember objects designed for fast access given a DeclId_t and for keep track of T...Definition TListOfDataMembers.h:33; TListOfEnumsA collection of TEnum objects designed for fast access given a DeclId_t and for keep track of TEnum t...Definition TListOfEnums.h:33; TListOfFunctionTemplatesA collection of TFunction objects designed for fast access given a DeclId_t and for keep track of TFu...Definition TListOfFunctionTemplates.h:35; TListOfFunctionsA collection of TFunction objects designed for fast access given a DeclId_t and for keep track of TFu...Definition TListOfFunctions.h:35; TListA doubly linked list.Definition TList.h:38; TMemberInspectorAbstract base class for accessing the data-members of a class.Definition TMemberInspector.h:31; TMemberStreamerDefinition TMemberStreamer.h:26; TMethodCallMethod or function calling interface.Definition TMethodCall.h:37; TMethodEach ROOT class ,MatchSource.WIKI,doc/v632/TClass_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/TClass_8h_source.html
https://root.cern/doc/v632/TClass_8h_source.html:81583,Security,access,access,81583,nceCount() constDefinition TClass.h:467; TClass::fImplFileLineShort_t fImplFileLineDefinition TClass.h:216; TClingThis class defines an interface to the cling C++ interpreter.Definition TCling.h:102; TCollectionCollection abstract base class.Definition TCollection.h:65; TDataMemberAll ROOT classes may have RTTI (run time type identification) support added.Definition TDataMember.h:31; TDictionaryThis class defines an abstract interface that must be implemented by all classes that contain diction...Definition TDictionary.h:168; TDictionary::EMemberSelectionEMemberSelectionKinds of members to include in lists.Definition TDictionary.h:216; TDictionary::DeclId_tconst void * DeclId_tDefinition TDictionary.h:224; TFunctionTemplateDictionary for function template This class describes one single function template.Definition TFunctionTemplate.h:26; THashTableTHashTable implements a hash table to store TObject's.Definition THashTable.h:35; TListOfDataMembersA collection of TDataMember objects designed for fast access given a DeclId_t and for keep track of T...Definition TListOfDataMembers.h:33; TListOfEnumsA collection of TEnum objects designed for fast access given a DeclId_t and for keep track of TEnum t...Definition TListOfEnums.h:33; TListOfFunctionTemplatesA collection of TFunction objects designed for fast access given a DeclId_t and for keep track of TFu...Definition TListOfFunctionTemplates.h:35; TListOfFunctionsA collection of TFunction objects designed for fast access given a DeclId_t and for keep track of TFu...Definition TListOfFunctions.h:35; TListA doubly linked list.Definition TList.h:38; TMemberInspectorAbstract base class for accessing the data-members of a class.Definition TMemberInspector.h:31; TMemberStreamerDefinition TMemberStreamer.h:26; TMethodCallMethod or function calling interface.Definition TMethodCall.h:37; TMethodEach ROOT class (see TClass) has a linked list of methods.Definition TMethod.h:38; TObjArrayAn array of TObjects.Definition TObjArray.h:,MatchSource.WIKI,doc/v632/TClass_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/TClass_8h_source.html
https://root.cern/doc/v632/TClass_8h_source.html:81729,Security,access,access,81729,ing C++ interpreter.Definition TCling.h:102; TCollectionCollection abstract base class.Definition TCollection.h:65; TDataMemberAll ROOT classes may have RTTI (run time type identification) support added.Definition TDataMember.h:31; TDictionaryThis class defines an abstract interface that must be implemented by all classes that contain diction...Definition TDictionary.h:168; TDictionary::EMemberSelectionEMemberSelectionKinds of members to include in lists.Definition TDictionary.h:216; TDictionary::DeclId_tconst void * DeclId_tDefinition TDictionary.h:224; TFunctionTemplateDictionary for function template This class describes one single function template.Definition TFunctionTemplate.h:26; THashTableTHashTable implements a hash table to store TObject's.Definition THashTable.h:35; TListOfDataMembersA collection of TDataMember objects designed for fast access given a DeclId_t and for keep track of T...Definition TListOfDataMembers.h:33; TListOfEnumsA collection of TEnum objects designed for fast access given a DeclId_t and for keep track of TEnum t...Definition TListOfEnums.h:33; TListOfFunctionTemplatesA collection of TFunction objects designed for fast access given a DeclId_t and for keep track of TFu...Definition TListOfFunctionTemplates.h:35; TListOfFunctionsA collection of TFunction objects designed for fast access given a DeclId_t and for keep track of TFu...Definition TListOfFunctions.h:35; TListA doubly linked list.Definition TList.h:38; TMemberInspectorAbstract base class for accessing the data-members of a class.Definition TMemberInspector.h:31; TMemberStreamerDefinition TMemberStreamer.h:26; TMethodCallMethod or function calling interface.Definition TMethodCall.h:37; TMethodEach ROOT class (see TClass) has a linked list of methods.Definition TMethod.h:38; TObjArrayAn array of TObjects.Definition TObjArray.h:31; TObjectMother of all ROOT objects.Definition TObject.h:41; TObject::Dumpvirtual void Dump() constDump contents of object on stdout.Definition TObject.c,MatchSource.WIKI,doc/v632/TClass_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/TClass_8h_source.html
https://root.cern/doc/v632/TClass_8h_source.html:81891,Security,access,access,81891, RTTI (run time type identification) support added.Definition TDataMember.h:31; TDictionaryThis class defines an abstract interface that must be implemented by all classes that contain diction...Definition TDictionary.h:168; TDictionary::EMemberSelectionEMemberSelectionKinds of members to include in lists.Definition TDictionary.h:216; TDictionary::DeclId_tconst void * DeclId_tDefinition TDictionary.h:224; TFunctionTemplateDictionary for function template This class describes one single function template.Definition TFunctionTemplate.h:26; THashTableTHashTable implements a hash table to store TObject's.Definition THashTable.h:35; TListOfDataMembersA collection of TDataMember objects designed for fast access given a DeclId_t and for keep track of T...Definition TListOfDataMembers.h:33; TListOfEnumsA collection of TEnum objects designed for fast access given a DeclId_t and for keep track of TEnum t...Definition TListOfEnums.h:33; TListOfFunctionTemplatesA collection of TFunction objects designed for fast access given a DeclId_t and for keep track of TFu...Definition TListOfFunctionTemplates.h:35; TListOfFunctionsA collection of TFunction objects designed for fast access given a DeclId_t and for keep track of TFu...Definition TListOfFunctions.h:35; TListA doubly linked list.Definition TList.h:38; TMemberInspectorAbstract base class for accessing the data-members of a class.Definition TMemberInspector.h:31; TMemberStreamerDefinition TMemberStreamer.h:26; TMethodCallMethod or function calling interface.Definition TMethodCall.h:37; TMethodEach ROOT class (see TClass) has a linked list of methods.Definition TMethod.h:38; TObjArrayAn array of TObjects.Definition TObjArray.h:31; TObjectMother of all ROOT objects.Definition TObject.h:41; TObject::Dumpvirtual void Dump() constDump contents of object on stdout.Definition TObject.cxx:348; TObject::TestBitR__ALWAYS_INLINE Bool_t TestBit(UInt_t f) constDefinition TObject.h:199; TProtoClassPersistent version of a TClass.Definition TP,MatchSource.WIKI,doc/v632/TClass_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/TClass_8h_source.html
https://root.cern/doc/v632/TClass_8h_source.html:82053,Security,access,access,82053,asses that contain diction...Definition TDictionary.h:168; TDictionary::EMemberSelectionEMemberSelectionKinds of members to include in lists.Definition TDictionary.h:216; TDictionary::DeclId_tconst void * DeclId_tDefinition TDictionary.h:224; TFunctionTemplateDictionary for function template This class describes one single function template.Definition TFunctionTemplate.h:26; THashTableTHashTable implements a hash table to store TObject's.Definition THashTable.h:35; TListOfDataMembersA collection of TDataMember objects designed for fast access given a DeclId_t and for keep track of T...Definition TListOfDataMembers.h:33; TListOfEnumsA collection of TEnum objects designed for fast access given a DeclId_t and for keep track of TEnum t...Definition TListOfEnums.h:33; TListOfFunctionTemplatesA collection of TFunction objects designed for fast access given a DeclId_t and for keep track of TFu...Definition TListOfFunctionTemplates.h:35; TListOfFunctionsA collection of TFunction objects designed for fast access given a DeclId_t and for keep track of TFu...Definition TListOfFunctions.h:35; TListA doubly linked list.Definition TList.h:38; TMemberInspectorAbstract base class for accessing the data-members of a class.Definition TMemberInspector.h:31; TMemberStreamerDefinition TMemberStreamer.h:26; TMethodCallMethod or function calling interface.Definition TMethodCall.h:37; TMethodEach ROOT class (see TClass) has a linked list of methods.Definition TMethod.h:38; TObjArrayAn array of TObjects.Definition TObjArray.h:31; TObjectMother of all ROOT objects.Definition TObject.h:41; TObject::Dumpvirtual void Dump() constDump contents of object on stdout.Definition TObject.cxx:348; TObject::TestBitR__ALWAYS_INLINE Bool_t TestBit(UInt_t f) constDefinition TObject.h:199; TProtoClassPersistent version of a TClass.Definition TProtoClass.h:38; TRealDataThe TRealData class manages the effective list of all data members for a given class.Definition TRealData.h:30; TStreamerInfoDescribes a pers,MatchSource.WIKI,doc/v632/TClass_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/TClass_8h_source.html
https://root.cern/doc/v632/TClass_8h_source.html:82228,Security,access,accessing,82228,:DeclId_tconst void * DeclId_tDefinition TDictionary.h:224; TFunctionTemplateDictionary for function template This class describes one single function template.Definition TFunctionTemplate.h:26; THashTableTHashTable implements a hash table to store TObject's.Definition THashTable.h:35; TListOfDataMembersA collection of TDataMember objects designed for fast access given a DeclId_t and for keep track of T...Definition TListOfDataMembers.h:33; TListOfEnumsA collection of TEnum objects designed for fast access given a DeclId_t and for keep track of TEnum t...Definition TListOfEnums.h:33; TListOfFunctionTemplatesA collection of TFunction objects designed for fast access given a DeclId_t and for keep track of TFu...Definition TListOfFunctionTemplates.h:35; TListOfFunctionsA collection of TFunction objects designed for fast access given a DeclId_t and for keep track of TFu...Definition TListOfFunctions.h:35; TListA doubly linked list.Definition TList.h:38; TMemberInspectorAbstract base class for accessing the data-members of a class.Definition TMemberInspector.h:31; TMemberStreamerDefinition TMemberStreamer.h:26; TMethodCallMethod or function calling interface.Definition TMethodCall.h:37; TMethodEach ROOT class (see TClass) has a linked list of methods.Definition TMethod.h:38; TObjArrayAn array of TObjects.Definition TObjArray.h:31; TObjectMother of all ROOT objects.Definition TObject.h:41; TObject::Dumpvirtual void Dump() constDump contents of object on stdout.Definition TObject.cxx:348; TObject::TestBitR__ALWAYS_INLINE Bool_t TestBit(UInt_t f) constDefinition TObject.h:199; TProtoClassPersistent version of a TClass.Definition TProtoClass.h:38; TRealDataThe TRealData class manages the effective list of all data members for a given class.Definition TRealData.h:30; TStreamerInfoDescribes a persistent version of a class.Definition TStreamerInfo.h:39; TStringBasic string class.Definition TString.h:139; TViewPubDataMembersView implementing the TList interface and giving access,MatchSource.WIKI,doc/v632/TClass_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/TClass_8h_source.html
https://root.cern/doc/v632/TClass_8h_source.html:83218,Security,access,access,83218,"tract base class for accessing the data-members of a class.Definition TMemberInspector.h:31; TMemberStreamerDefinition TMemberStreamer.h:26; TMethodCallMethod or function calling interface.Definition TMethodCall.h:37; TMethodEach ROOT class (see TClass) has a linked list of methods.Definition TMethod.h:38; TObjArrayAn array of TObjects.Definition TObjArray.h:31; TObjectMother of all ROOT objects.Definition TObject.h:41; TObject::Dumpvirtual void Dump() constDump contents of object on stdout.Definition TObject.cxx:348; TObject::TestBitR__ALWAYS_INLINE Bool_t TestBit(UInt_t f) constDefinition TObject.h:199; TProtoClassPersistent version of a TClass.Definition TProtoClass.h:38; TRealDataThe TRealData class manages the effective list of all data members for a given class.Definition TRealData.h:30; TStreamerInfoDescribes a persistent version of a class.Definition TStreamerInfo.h:39; TStringBasic string class.Definition TString.h:139; TViewPubDataMembersView implementing the TList interface and giving access all the TDictionary describing public data me...Definition TViewPubDataMembers.h:28; TViewPubFunctionsView implementing the TList interface and giving access all the TFunction describing public methods i...Definition TViewPubFunctions.h:28; TVirtualCollectionProxyDefines a common interface to inspect/change the contents of an object that represents a collection.Definition TVirtualCollectionProxy.h:52; TVirtualIsAProxyDefinition TVirtualIsAProxy.h:27; TVirtualMutexThis class implements a mutex interface.Definition TVirtualMutex.h:32; TVirtualRefProxyDefinition TVirtualRefProxy.h:81; TVirtualStreamerInfoAbstract Interface class describing Streamer information for one class.Definition TVirtualStreamerInfo.h:44; bool; int; unsigned int; lineTLine * lineDefinition entrylistblock_figure1.C:235; ROOT::Internal::GetClassHelperTClass * GetClassHelper(Bool_t, Bool_t, std::true_type)Definition TClass.h:624; ROOT::Minuit2::GradientParameterSpace::Internal@ Internal; ROOTtbb::task",MatchSource.WIKI,doc/v632/TClass_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/TClass_8h_source.html
https://root.cern/doc/v632/TClass_8h_source.html:83376,Security,access,access,83376,"or function calling interface.Definition TMethodCall.h:37; TMethodEach ROOT class (see TClass) has a linked list of methods.Definition TMethod.h:38; TObjArrayAn array of TObjects.Definition TObjArray.h:31; TObjectMother of all ROOT objects.Definition TObject.h:41; TObject::Dumpvirtual void Dump() constDump contents of object on stdout.Definition TObject.cxx:348; TObject::TestBitR__ALWAYS_INLINE Bool_t TestBit(UInt_t f) constDefinition TObject.h:199; TProtoClassPersistent version of a TClass.Definition TProtoClass.h:38; TRealDataThe TRealData class manages the effective list of all data members for a given class.Definition TRealData.h:30; TStreamerInfoDescribes a persistent version of a class.Definition TStreamerInfo.h:39; TStringBasic string class.Definition TString.h:139; TViewPubDataMembersView implementing the TList interface and giving access all the TDictionary describing public data me...Definition TViewPubDataMembers.h:28; TViewPubFunctionsView implementing the TList interface and giving access all the TFunction describing public methods i...Definition TViewPubFunctions.h:28; TVirtualCollectionProxyDefines a common interface to inspect/change the contents of an object that represents a collection.Definition TVirtualCollectionProxy.h:52; TVirtualIsAProxyDefinition TVirtualIsAProxy.h:27; TVirtualMutexThis class implements a mutex interface.Definition TVirtualMutex.h:32; TVirtualRefProxyDefinition TVirtualRefProxy.h:81; TVirtualStreamerInfoAbstract Interface class describing Streamer information for one class.Definition TVirtualStreamerInfo.h:44; bool; int; unsigned int; lineTLine * lineDefinition entrylistblock_figure1.C:235; ROOT::Internal::GetClassHelperTClass * GetClassHelper(Bool_t, Bool_t, std::true_type)Definition TClass.h:624; ROOT::Minuit2::GradientParameterSpace::Internal@ Internal; ROOTtbb::task_arena is an alias of tbb::interface7::task_arena, which doesn't allow to forward declare tb...Definition EExecutionPolicy.hxx:4; ROOT::DirAutoAdd_tvoid(* DirAu",MatchSource.WIKI,doc/v632/TClass_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/TClass_8h_source.html
https://root.cern/doc/v632/TClass_8h_source.html:20425,Testability,test,testio,20425,"92 Bool_t CanSplit() const;; 393 Bool_t CanIgnoreTObjectStreamer() { return TestBit(kIgnoreTObjectStreamer);}; 394 Long_t ClassProperty() const;; 395 TObject *Clone(const char *newname="""") const override;; 396 void CopyCollectionProxy(const TVirtualCollectionProxy&);; 397 void Draw(Option_t *option="""") override;; 398 void Dump() const override { TDictionary::Dump(); }; 399 void Dump(const void *obj, Bool_t noAddr = kFALSE) const;; 400 char *EscapeChars(const char *text) const;; 401 TVirtualStreamerInfo *FindStreamerInfo(UInt_t checksum, Bool_t isTransient = kFALSE) const;; 402 TVirtualStreamerInfo *GetConversionStreamerInfo( const char* onfile_classname, Int_t version ) const;; 403 TVirtualStreamerInfo *FindConversionStreamerInfo( const char* onfile_classname, UInt_t checksum ) const;; 404 TVirtualStreamerInfo *GetConversionStreamerInfo( const TClass* onfile_cl, Int_t version ) const;; 405 TVirtualStreamerInfo *FindConversionStreamerInfo( const TClass* onfile_cl, UInt_t checksum ) const;; 406 void ForceReload (TClass* oldcl);; 407 Bool_t HasDataMemberInfo() const { return fIsSyntheticPair || fHasRootPcmInfo || HasInterpreterInfo(); }; 408 Bool_t HasDefaultConstructor(Bool_t testio = kFALSE) const;; 409 Bool_t HasInterpreterInfoInMemory() const { return nullptr != fClassInfo; }; 410 Bool_t HasInterpreterInfo() const { return fCanLoadClassInfo || fClassInfo; }; 411 UInt_t GetCheckSum(ECheckSum code = kCurrentCheckSum) const;; 412 UInt_t GetCheckSum(Bool_t &isvalid) const;; 413 UInt_t GetCheckSum(ECheckSum code, Bool_t &isvalid) const;; 414 TVirtualCollectionProxy *GetCollectionProxy() const;; 415 TVirtualIsAProxy *GetIsAProxy() const;; 416 TMethod *GetClassMethod(const char *name, const char *params, Bool_t objectIsConst = kFALSE);; 417 TMethod *GetClassMethodWithPrototype(const char *name, const char *proto,; 418 Bool_t objectIsConst = kFALSE,; 419 ROOT::EFunctionMatchMode mode = ROOT::kConversionMatch);; 420 Version_t GetClassVersion() const {; 421 if (!fVersionUsed.",MatchSource.WIKI,doc/v632/TClass_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/TClass_8h_source.html
https://root.cern/doc/v632/TClass_8h_source.html:70181,Testability,test,testio,70181,"alue of fStreamerType.Definition TClass.cxx:6215; TClass::GetSharedLibsconst char * GetSharedLibs()Get the list of shared libraries containing the code for class cls.Definition TClass.cxx:3623; TClass::CalculateStreamerOffsetvoid CalculateStreamerOffset() constCalculate the offset between an object of this class to its base class TObject.Definition TClass.cxx:2183; TClass::GetMissingDictionariesForPairElementsvoid GetMissingDictionariesForPairElements(TCollection &result, TCollection &visited, bool recurse)Definition TClass.cxx:3973; TClass::ReplaceWithvoid ReplaceWith(TClass *newcl) constDefinition TClass.cxx:4142; TClass::RegisterAddressInRepositoryvoid RegisterAddressInRepository(const char *where, void *location, const TClass *what) constDefinition TClass.cxx:290; TClass::PropertyLong_t Property() const overrideReturns the properties of the TClass as a bit field stored as a Long_t value.Definition TClass.cxx:6086; TClass::HasDefaultConstructorBool_t HasDefaultConstructor(Bool_t testio=kFALSE) constReturn true if we have access to a constructor usable for I/O.Definition TClass.cxx:7393; TClass::GetMenuItemsvoid GetMenuItems(TList *listitems)Returns list of methods accessible by context menu.Definition TClass.cxx:3874; TClass::SetNewvoid SetNew(ROOT::NewFunc_t newFunc)Install a new wrapper around 'new'.Definition TClass.cxx:6985; TClass::fIsAMethodstd::atomic< TMethodCall * > fIsAMethodDefinition TClass.h:231; TClass::ReadRulesstatic Int_t ReadRules()Read the class.rules files from the default location:.Definition TClass.cxx:1820; TClass::CanSplitBaseAllowBool_t CanSplitBaseAllow()Pointer to the function implementing streaming for this class.Definition TClass.cxx:2247; TClass::MoveAddressInRepositoryvoid MoveAddressInRepository(const char *where, void *oldadd, void *newadd, const TClass *what) constDefinition TClass.cxx:337; TClass::fStreamerImplstd::atomic< StreamerImpl_t > fStreamerImplDefinition TClass.h:287; TClass::SetContextMenuTitlevoid SetContextMenuTitle(c",MatchSource.WIKI,doc/v632/TClass_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/TClass_8h_source.html
https://root.cern/doc/v632/TClass_8h_source.html:70248,Usability,usab,usable,70248,"alue of fStreamerType.Definition TClass.cxx:6215; TClass::GetSharedLibsconst char * GetSharedLibs()Get the list of shared libraries containing the code for class cls.Definition TClass.cxx:3623; TClass::CalculateStreamerOffsetvoid CalculateStreamerOffset() constCalculate the offset between an object of this class to its base class TObject.Definition TClass.cxx:2183; TClass::GetMissingDictionariesForPairElementsvoid GetMissingDictionariesForPairElements(TCollection &result, TCollection &visited, bool recurse)Definition TClass.cxx:3973; TClass::ReplaceWithvoid ReplaceWith(TClass *newcl) constDefinition TClass.cxx:4142; TClass::RegisterAddressInRepositoryvoid RegisterAddressInRepository(const char *where, void *location, const TClass *what) constDefinition TClass.cxx:290; TClass::PropertyLong_t Property() const overrideReturns the properties of the TClass as a bit field stored as a Long_t value.Definition TClass.cxx:6086; TClass::HasDefaultConstructorBool_t HasDefaultConstructor(Bool_t testio=kFALSE) constReturn true if we have access to a constructor usable for I/O.Definition TClass.cxx:7393; TClass::GetMenuItemsvoid GetMenuItems(TList *listitems)Returns list of methods accessible by context menu.Definition TClass.cxx:3874; TClass::SetNewvoid SetNew(ROOT::NewFunc_t newFunc)Install a new wrapper around 'new'.Definition TClass.cxx:6985; TClass::fIsAMethodstd::atomic< TMethodCall * > fIsAMethodDefinition TClass.h:231; TClass::ReadRulesstatic Int_t ReadRules()Read the class.rules files from the default location:.Definition TClass.cxx:1820; TClass::CanSplitBaseAllowBool_t CanSplitBaseAllow()Pointer to the function implementing streaming for this class.Definition TClass.cxx:2247; TClass::MoveAddressInRepositoryvoid MoveAddressInRepository(const char *where, void *oldadd, void *newadd, const TClass *what) constDefinition TClass.cxx:337; TClass::fStreamerImplstd::atomic< StreamerImpl_t > fStreamerImplDefinition TClass.h:287; TClass::SetContextMenuTitlevoid SetContextMenuTitle(c",MatchSource.WIKI,doc/v632/TClass_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/TClass_8h_source.html
https://root.cern/doc/v632/TDataFrame_8hxx_source.html:975,Integrability,interface,interface,975,". ROOT: tree/dataframe/inc/ROOT/TDataFrame.hxx Source File. ; ROOT ; . v6-32. Reference Guide ; . . Loading...; Searching...; No Matches. TDataFrame.hxx. Go to the documentation of this file. 1// Author: Enrico Guiraud, Danilo Piparo CERN 05/2018; 2 ; 3/*************************************************************************; 4 * Copyright (C) 1995-2018, Rene Brun and Fons Rademakers. *; 5 * All rights reserved. *; 6 * *; 7 * For the licensing terms see $ROOTSYS/LICENSE. *; 8 * For the list of contributors see $ROOTSYS/README/CREDITS. *; 9 *************************************************************************/; 10 ; 11#ifndef ROOT_TDATAFRAME; 12#define ROOT_TDATAFRAME; 13#include ""RDataFrame.hxx""; 14namespace ROOT {; 15 ; 16using TDataFrame = ROOT::RDataFrame;; 17 ; 18} // End NS ROOT; 19 ; 20#warning The TDataFrame.hxx header has been replaced by RDataFrame.hxx; 21 ; 22#endif; RDataFrame.hxx; ROOT::RDataFrameROOT's RDataFrame offers a modern, high-level interface for analysis of data stored in TTree ,...Definition RDataFrame.hxx:41; ROOTtbb::task_arena is an alias of tbb::interface7::task_arena, which doesn't allow to forward declare tb...Definition EExecutionPolicy.hxx:4. treedataframeincROOTTDataFrame.hxx. ROOT v6-32 - Reference Guide Generated on Fri Nov 1 2024 15:09:29 (GVA Time) using Doxygen 1.9.8 ; . ",MatchSource.WIKI,doc/v632/TDataFrame_8hxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/TDataFrame_8hxx_source.html
https://root.cern/doc/v632/TDictionary_8h_source.html:3341,Availability,avail,available,3341,"t;; 61class TypedefInfo_t;; 62class TDictAttributeMap;; 63 ; 64enum EProperty {; 65 kIsClass = 0x00000001,; 66 kIsStruct = 0x00000002,; 67 kIsUnion = 0x00000004,; 68 kIsEnum = 0x00000008,; 69 kIsTypedef = 0x00000010,; 70 kIsFundamental = 0x00000020,; 71 kIsAbstract = 0x00000040,; 72 kIsVirtual = 0x00000080,; 73 kIsPureVirtual = 0x00000100,; 74 kIsUnionMember = 0x00000100,; 75 kIsPublic = 0x00000200,; 76 kIsProtected = 0x00000400,; 77 kIsPrivate = 0x00000800,; 78 kIsPointer = 0x00001000,; 79 kIsArray = 0x00002000,; 80 kIsStatic = 0x00004000,; 81 kIsDefault = 0x00008000,; 82 kIsReference = 0x00010000,; 83 kIsDirectInherit = 0x00020000,; 84 kIsCCompiled = 0x00040000,; 85 kIsCPPCompiled = kIsCCompiled,; 86 kIsCompiled = kIsCCompiled,; 87 kIsNotReacheable = 0x00080000, // Indicate that the entity can not be used from the Global Namespace; 88 kIsConstant = 0x00100000,; 89 kIsVirtualBase = 0x00200000,; 90 kIsConstPointer = 0x00400000,; 91 kIsScopedEnum = 0x00800000,; 92 // 0x01000000 is available; 93 kIsConstexpr = 0x02000000,; 94 kIsExplicit = 0x04000000,; 95 kIsNamespace = 0x08000000,; 96 kIsConstMethod = 0x10000000,; 97 kIsUsing = 0x20000000,; 98 kIsDefinedInStd = 0x40000000; 99 // 0x80000000 is available; 100};; 101 ; 102enum EFunctionProperty {; 103/* The following are already defined; 104 in EProperty and 'could' be part of this enums */; 105/*; 106 kIsAbstract = 0x00000040,; 107 kIsVirtual = 0x00000080,; 108 kIsPureVirtual = 0x00000100,; 109 kIsPublic = 0x00000200,; 110 kIsProtected = 0x00000400,; 111 kIsPrivate = 0x00000800,; 112 kIsStatic = 0x00004000,; 113 kIsDefault = 0x00008000,; 114 kIsConstexpr = 0x02000000; 115 kIsExplicit = 0x04000000,; 116 kIsConstMethod = 0x10000000,; 117*/; 118/* The following are already defined; 119 in EProperty and related to the type of the return value */; 120/*; 121 kIsConstant = 0x00100000,; 122 kIsPointer = 0x00001000,; 123 kIsArray = 0x00002000,; 124 kIsReference = 0x00010000,; 125 kIsConstPointer = 0x00400000,; 126*/; 127 kIsCo",MatchSource.WIKI,doc/v632/TDictionary_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/TDictionary_8h_source.html
https://root.cern/doc/v632/TDictionary_8h_source.html:3557,Availability,avail,available,3557,"; 70 kIsFundamental = 0x00000020,; 71 kIsAbstract = 0x00000040,; 72 kIsVirtual = 0x00000080,; 73 kIsPureVirtual = 0x00000100,; 74 kIsUnionMember = 0x00000100,; 75 kIsPublic = 0x00000200,; 76 kIsProtected = 0x00000400,; 77 kIsPrivate = 0x00000800,; 78 kIsPointer = 0x00001000,; 79 kIsArray = 0x00002000,; 80 kIsStatic = 0x00004000,; 81 kIsDefault = 0x00008000,; 82 kIsReference = 0x00010000,; 83 kIsDirectInherit = 0x00020000,; 84 kIsCCompiled = 0x00040000,; 85 kIsCPPCompiled = kIsCCompiled,; 86 kIsCompiled = kIsCCompiled,; 87 kIsNotReacheable = 0x00080000, // Indicate that the entity can not be used from the Global Namespace; 88 kIsConstant = 0x00100000,; 89 kIsVirtualBase = 0x00200000,; 90 kIsConstPointer = 0x00400000,; 91 kIsScopedEnum = 0x00800000,; 92 // 0x01000000 is available; 93 kIsConstexpr = 0x02000000,; 94 kIsExplicit = 0x04000000,; 95 kIsNamespace = 0x08000000,; 96 kIsConstMethod = 0x10000000,; 97 kIsUsing = 0x20000000,; 98 kIsDefinedInStd = 0x40000000; 99 // 0x80000000 is available; 100};; 101 ; 102enum EFunctionProperty {; 103/* The following are already defined; 104 in EProperty and 'could' be part of this enums */; 105/*; 106 kIsAbstract = 0x00000040,; 107 kIsVirtual = 0x00000080,; 108 kIsPureVirtual = 0x00000100,; 109 kIsPublic = 0x00000200,; 110 kIsProtected = 0x00000400,; 111 kIsPrivate = 0x00000800,; 112 kIsStatic = 0x00004000,; 113 kIsDefault = 0x00008000,; 114 kIsConstexpr = 0x02000000; 115 kIsExplicit = 0x04000000,; 116 kIsConstMethod = 0x10000000,; 117*/; 118/* The following are already defined; 119 in EProperty and related to the type of the return value */; 120/*; 121 kIsConstant = 0x00100000,; 122 kIsPointer = 0x00001000,; 123 kIsArray = 0x00002000,; 124 kIsReference = 0x00010000,; 125 kIsConstPointer = 0x00400000,; 126*/; 127 kIsConstructor = 0x00000001,; 128 kIsConversion = 0x00000002,; 129 kIsDestructor = 0x00000004,; 130 kIsOperator = 0x00000008,; 131 kIsInlined = 0x00000010,; 132 kIsTemplateSpec= 0x00000020; 133};; 134 ; 135enum EClassProp",MatchSource.WIKI,doc/v632/TDictionary_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/TDictionary_8h_source.html
https://root.cern/doc/v632/TDictionary_8h_source.html:5645,Deployability,update,updated,5645," kIsReference = 0x00010000,; 125 kIsConstPointer = 0x00400000,; 126*/; 127 kIsConstructor = 0x00000001,; 128 kIsConversion = 0x00000002,; 129 kIsDestructor = 0x00000004,; 130 kIsOperator = 0x00000008,; 131 kIsInlined = 0x00000010,; 132 kIsTemplateSpec= 0x00000020; 133};; 134 ; 135enum EClassProperty {; 136 kClassIsValid = 0x00000001,; 137 kClassHasExplicitCtor = 0x00000010,; 138 kClassHasImplicitCtor = 0x00000020,; 139 kClassHasCtor = 0x00000030,; 140 kClassHasDefaultCtor = 0x00000040,; 141 kClassHasAssignOpr = 0x00000080,; 142 kClassHasExplicitDtor = 0x00000100,; 143 kClassHasImplicitDtor = 0x00000200,; 144 kClassHasDtor = 0x00000300,; 145 kClassHasVirtual = 0x00001000,; 146 kClassIsAbstract = 0x00002000,; 147 kClassIsAggregate = 0x00004000; 148};; 149 ; 150enum ERefTypeValues {; 151 kParaNormal = 0, // not used; 152 kParaReference = 1,; 153 kParaP2P = 2, // not used; 154 kParaP2P2P = 3, // not used; 155 kParaRef = 100,; 156 kParaRefP2P = 102, // not used; 157 kParaRefP2P2P = 103 // not used; 158};; 159 ; 160namespace ROOT {; 161 enum EFunctionMatchMode {; 162 kExactMatch = 0,; 163 kConversionMatch = 1; 164 };; 165}; 166 ; 167 ; 168class TDictionary : public TNamed {; 169 ; 170private:; 171 TDictAttributeMap *fAttributeMap{nullptr}; //pointer to a class attribute map; 172 ULong64_t fUpdatingTransactionCount{0}; //!the Cling ID of the transaction that last updated the object; 173 ; 174protected:; 175 Bool_t UpdateInterpreterStateMarker();; 176 ; 177public:; 178 TDictionary(): fAttributeMap(nullptr), fUpdatingTransactionCount(0) { }; 179 TDictionary(const char* name): TNamed(name, """"), fAttributeMap(nullptr), fUpdatingTransactionCount(0) { }; 180 TDictionary(const TDictionary& dict);; 181 virtual ~TDictionary();; 182 ; 183 TDictionary& operator=(const TDictionary& other);; 184 ; 185 void CreateAttributeMap();; 186 TDictAttributeMap *GetAttributeMap() const; 187 {; 188 //Get the TDictAttributeMap pointer to be able to add attribute; 189 //pairs key-value to the TClass.",MatchSource.WIKI,doc/v632/TDictionary_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/TDictionary_8h_source.html
https://root.cern/doc/v632/TDictionary_8h_source.html:13198,Deployability,update,updated,13198,GWin32VirtualXProxy.cxx:247; namechar name[80]Definition TGX11.cxx:110; TNamed.h; TDictAttributeMapThe ROOT object has a list of properties which are stored and retrieved using TDictAttributeMap.Definition TDictAttributeMap.h:30; TDictionaryThis class defines an abstract interface that must be implemented by all classes that contain diction...Definition TDictionary.h:168; TDictionary::Propertyvirtual Long_t Property() const =0; TDictionary::fAttributeMapTDictAttributeMap * fAttributeMapDefinition TDictionary.h:171; TDictionary::WantsRegularMembersstatic bool WantsRegularMembers(EMemberSelection sel)Definition TDictionary.h:221; TDictionary::GetAttributeMapTDictAttributeMap * GetAttributeMap() constDefinition TDictionary.h:186; TDictionary::TDictionaryTDictionary(const char *name)Definition TDictionary.h:179; TDictionary::fUpdatingTransactionCountULong64_t fUpdatingTransactionCountDefinition TDictionary.h:172; TDictionary::UpdateInterpreterStateMarkerBool_t UpdateInterpreterStateMarker()the Cling ID of the transaction that last updated the objectDefinition TDictionary.cxx:124; TDictionary::ESTLTypeESTLTypeDefinition TDictionary.h:198; TDictionary::kForwardlist@ kForwardlistDefinition TDictionary.h:202; TDictionary::kMultimap@ kMultimapDefinition TDictionary.h:205; TDictionary::kDeque@ kDequeDefinition TDictionary.h:203; TDictionary::kMap@ kMapDefinition TDictionary.h:204; TDictionary::kUnorderedSet@ kUnorderedSetDefinition TDictionary.h:208; TDictionary::kUnorderedMultimap@ kUnorderedMultimapDefinition TDictionary.h:211; TDictionary::kBitset@ kBitsetDefinition TDictionary.h:212; TDictionary::kVector@ kVectorDefinition TDictionary.h:200; TDictionary::kMultiset@ kMultisetDefinition TDictionary.h:207; TDictionary::kNone@ kNoneDefinition TDictionary.h:199; TDictionary::kUnorderedMap@ kUnorderedMapDefinition TDictionary.h:210; TDictionary::kUnorderedMultiset@ kUnorderedMultisetDefinition TDictionary.h:209; TDictionary::kList@ kListDefinition TDictionary.h:201; TDictionary,MatchSource.WIKI,doc/v632/TDictionary_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/TDictionary_8h_source.html
https://root.cern/doc/v632/TDictionary_8h_source.html:844,Integrability,interface,interface,844,". ROOT: core/meta/inc/TDictionary.h Source File. ; ROOT ; . v6-32. Reference Guide ; . . Loading...; Searching...; No Matches. TDictionary.h. Go to the documentation of this file. 1// @(#)root/meta:$Id$; 2// Author: Fons Rademakers 20/06/96; 3 ; 4/*************************************************************************; 5 * Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; 6 * All rights reserved. *; 7 * *; 8 * For the licensing terms see $ROOTSYS/LICENSE. *; 9 * For the list of contributors see $ROOTSYS/README/CREDITS. *; 10 *************************************************************************/; 11 ; 12 ; 13#ifndef ROOT_TDictionary; 14#define ROOT_TDictionary; 15 ; 16//////////////////////////////////////////////////////////////////////////; 17// //; 18// TDictionary //; 19// //; 20// This class defines an abstract interface that must be implemented //; 21// by all classes that contain dictionary information. //; 22// //; 23// The dictionary is defined by the followling classes: //; 24// TDataType (typedef definitions) //; 25// TGlobal (global variables) //; 26// TFunction (global functions) //; 27// TClass (classes) //; 28// TBaseClass (base classes) //; 29// TDataMember (class datamembers) //; 30// TMethod (class methods) //; 31// TMethodArg (method arguments) //; 32// //; 33// All the above classes implement the TDictionary abstract interface //; 34// (note: the indentation shows aggregation not inheritance). //; 35// The ROOT dictionary system provides a very extensive RTTI //; 36// environment that facilitates a.o. object inspectors, object I/O, //; 37// ROOT Trees, etc. Most of the type information is provided by the //; 38// CINT C++ interpreter. //; 39// //; 40// TMethodCall (method call environment) //; 41// //; 42//////////////////////////////////////////////////////////////////////////; 43 ; 44#include ""TNamed.h""; 45 ; 46#include ""ESTLType.h""; 47 ; 48// The following are opaque type and are never really declared; 49// The specific implemen",MatchSource.WIKI,doc/v632/TDictionary_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/TDictionary_8h_source.html
https://root.cern/doc/v632/TDictionary_8h_source.html:1375,Integrability,interface,interface,1375,"meta:$Id$; 2// Author: Fons Rademakers 20/06/96; 3 ; 4/*************************************************************************; 5 * Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; 6 * All rights reserved. *; 7 * *; 8 * For the licensing terms see $ROOTSYS/LICENSE. *; 9 * For the list of contributors see $ROOTSYS/README/CREDITS. *; 10 *************************************************************************/; 11 ; 12 ; 13#ifndef ROOT_TDictionary; 14#define ROOT_TDictionary; 15 ; 16//////////////////////////////////////////////////////////////////////////; 17// //; 18// TDictionary //; 19// //; 20// This class defines an abstract interface that must be implemented //; 21// by all classes that contain dictionary information. //; 22// //; 23// The dictionary is defined by the followling classes: //; 24// TDataType (typedef definitions) //; 25// TGlobal (global variables) //; 26// TFunction (global functions) //; 27// TClass (classes) //; 28// TBaseClass (base classes) //; 29// TDataMember (class datamembers) //; 30// TMethod (class methods) //; 31// TMethodArg (method arguments) //; 32// //; 33// All the above classes implement the TDictionary abstract interface //; 34// (note: the indentation shows aggregation not inheritance). //; 35// The ROOT dictionary system provides a very extensive RTTI //; 36// environment that facilitates a.o. object inspectors, object I/O, //; 37// ROOT Trees, etc. Most of the type information is provided by the //; 38// CINT C++ interpreter. //; 39// //; 40// TMethodCall (method call environment) //; 41// //; 42//////////////////////////////////////////////////////////////////////////; 43 ; 44#include ""TNamed.h""; 45 ; 46#include ""ESTLType.h""; 47 ; 48// The following are opaque type and are never really declared; 49// The specific implementation of TInterpreter will cast the; 50// value of pointer to this types to the correct type (possibly; 51// distinct from these); 52class CallFunc_t;; 53class ClassInfo_t;; 54class BaseClassInf",MatchSource.WIKI,doc/v632/TDictionary_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/TDictionary_8h_source.html
https://root.cern/doc/v632/TDictionary_8h_source.html:12427,Integrability,interface,interface,12427,e GetFillStyle GetLineColor GetLineWidth GetMarkerStyle GetTextAlign GetTextColor GetTextSize void char Point_t Rectangle_t WindowAttributes_t Float_t Float_t Float_t Int_t Int_t UInt_t UInt_t Rectangle_t Int_t Int_t Window_t TString Int_t GCValues_t GetPrimarySelectionOwner GetDisplay GetScreen GetColormap GetNativeEvent const char const char dpyName wid window const char font_name cursor keysym reg const char only_if_exist regb h Point_t winding char text const char depth char const char Int_t count const char ColorStruct_t color const char Pixmap_t Pixmap_t PictureAttributes_t attr const char char ret_data h unsigned char height h Atom_t Int_t ULong_t ULong_t unsigned char prop_list Atom_t selDefinition TGWin32VirtualXProxy.cxx:247; namechar name[80]Definition TGX11.cxx:110; TNamed.h; TDictAttributeMapThe ROOT object has a list of properties which are stored and retrieved using TDictAttributeMap.Definition TDictAttributeMap.h:30; TDictionaryThis class defines an abstract interface that must be implemented by all classes that contain diction...Definition TDictionary.h:168; TDictionary::Propertyvirtual Long_t Property() const =0; TDictionary::fAttributeMapTDictAttributeMap * fAttributeMapDefinition TDictionary.h:171; TDictionary::WantsRegularMembersstatic bool WantsRegularMembers(EMemberSelection sel)Definition TDictionary.h:221; TDictionary::GetAttributeMapTDictAttributeMap * GetAttributeMap() constDefinition TDictionary.h:186; TDictionary::TDictionaryTDictionary(const char *name)Definition TDictionary.h:179; TDictionary::fUpdatingTransactionCountULong64_t fUpdatingTransactionCountDefinition TDictionary.h:172; TDictionary::UpdateInterpreterStateMarkerBool_t UpdateInterpreterStateMarker()the Cling ID of the transaction that last updated the objectDefinition TDictionary.cxx:124; TDictionary::ESTLTypeESTLTypeDefinition TDictionary.h:198; TDictionary::kForwardlist@ kForwardlistDefinition TDictionary.h:202; TDictionary::kMultimap@ kMultimapDefinition TDictionary.h:205; ,MatchSource.WIKI,doc/v632/TDictionary_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/TDictionary_8h_source.html
https://root.cern/doc/v632/TDictionary_8h_source.html:1077,Modifiability,variab,variables,1077,"meta:$Id$; 2// Author: Fons Rademakers 20/06/96; 3 ; 4/*************************************************************************; 5 * Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; 6 * All rights reserved. *; 7 * *; 8 * For the licensing terms see $ROOTSYS/LICENSE. *; 9 * For the list of contributors see $ROOTSYS/README/CREDITS. *; 10 *************************************************************************/; 11 ; 12 ; 13#ifndef ROOT_TDictionary; 14#define ROOT_TDictionary; 15 ; 16//////////////////////////////////////////////////////////////////////////; 17// //; 18// TDictionary //; 19// //; 20// This class defines an abstract interface that must be implemented //; 21// by all classes that contain dictionary information. //; 22// //; 23// The dictionary is defined by the followling classes: //; 24// TDataType (typedef definitions) //; 25// TGlobal (global variables) //; 26// TFunction (global functions) //; 27// TClass (classes) //; 28// TBaseClass (base classes) //; 29// TDataMember (class datamembers) //; 30// TMethod (class methods) //; 31// TMethodArg (method arguments) //; 32// //; 33// All the above classes implement the TDictionary abstract interface //; 34// (note: the indentation shows aggregation not inheritance). //; 35// The ROOT dictionary system provides a very extensive RTTI //; 36// environment that facilitates a.o. object inspectors, object I/O, //; 37// ROOT Trees, etc. Most of the type information is provided by the //; 38// CINT C++ interpreter. //; 39// //; 40// TMethodCall (method call environment) //; 41// //; 42//////////////////////////////////////////////////////////////////////////; 43 ; 44#include ""TNamed.h""; 45 ; 46#include ""ESTLType.h""; 47 ; 48// The following are opaque type and are never really declared; 49// The specific implementation of TInterpreter will cast the; 50// value of pointer to this types to the correct type (possibly; 51// distinct from these); 52class CallFunc_t;; 53class ClassInfo_t;; 54class BaseClassInf",MatchSource.WIKI,doc/v632/TDictionary_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/TDictionary_8h_source.html
https://root.cern/doc/v632/TDictionary_8h_source.html:1439,Modifiability,inherit,inheritance,1439,"meta:$Id$; 2// Author: Fons Rademakers 20/06/96; 3 ; 4/*************************************************************************; 5 * Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; 6 * All rights reserved. *; 7 * *; 8 * For the licensing terms see $ROOTSYS/LICENSE. *; 9 * For the list of contributors see $ROOTSYS/README/CREDITS. *; 10 *************************************************************************/; 11 ; 12 ; 13#ifndef ROOT_TDictionary; 14#define ROOT_TDictionary; 15 ; 16//////////////////////////////////////////////////////////////////////////; 17// //; 18// TDictionary //; 19// //; 20// This class defines an abstract interface that must be implemented //; 21// by all classes that contain dictionary information. //; 22// //; 23// The dictionary is defined by the followling classes: //; 24// TDataType (typedef definitions) //; 25// TGlobal (global variables) //; 26// TFunction (global functions) //; 27// TClass (classes) //; 28// TBaseClass (base classes) //; 29// TDataMember (class datamembers) //; 30// TMethod (class methods) //; 31// TMethodArg (method arguments) //; 32// //; 33// All the above classes implement the TDictionary abstract interface //; 34// (note: the indentation shows aggregation not inheritance). //; 35// The ROOT dictionary system provides a very extensive RTTI //; 36// environment that facilitates a.o. object inspectors, object I/O, //; 37// ROOT Trees, etc. Most of the type information is provided by the //; 38// CINT C++ interpreter. //; 39// //; 40// TMethodCall (method call environment) //; 41// //; 42//////////////////////////////////////////////////////////////////////////; 43 ; 44#include ""TNamed.h""; 45 ; 46#include ""ESTLType.h""; 47 ; 48// The following are opaque type and are never really declared; 49// The specific implementation of TInterpreter will cast the; 50// value of pointer to this types to the correct type (possibly; 51// distinct from these); 52class CallFunc_t;; 53class ClassInfo_t;; 54class BaseClassInf",MatchSource.WIKI,doc/v632/TDictionary_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/TDictionary_8h_source.html
https://root.cern/doc/v632/TGHtmlTable_8cxx.html:306,Integrability,depend,dependency,306,". ROOT: gui/guihtml/src/TGHtmlTable.cxx File Reference. ; ROOT ; . v6-32. Reference Guide ; . . Loading...; Searching...; No Matches. Macros ; TGHtmlTable.cxx File Reference. #include <cstdlib>; #include <cstring>; #include <cctype>; #include <cmath>; #include ""TGHtml.h""; #include ""snprintf.h"". Include dependency graph for TGHtmlTable.cxx:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead. Macros; #defineColMin(A, B)colMin[(A)-1][(B)-1]; ; #defineColReq(A, B)colMin[(B)-1][(A)-1]; ; #defineDFLT_BORDER0; ; #defineDFLT_CELLPADDING2; ; #defineDFLT_CELLSPACING_3D5; ; #defineDFLT_CELLSPACING_FLAT0; ; #defineDFLT_HSPACE0; ; #defineDFLT_VSPACE0; ; #defineMAX(A, B)((A) < (B) ? (B) : (A)); ; #defineN(HTML_MAX_COLUMNS+1); ; #defineSETMAX(A, B)if ((A) < (B)) { (A) = (B); }; ; #defineVAlign_Baseline4; ; #defineVAlign_Bottom2; ; #defineVAlign_Center3; ; #defineVAlign_Top1; ; #defineVAlign_Unknown0; . Macro Definition Documentation. ColMin. #define ColMin; (; ; A, . ; B. ); colMin[(A)-1][(B)-1]. ColReq. #define ColReq; (; ; A, . ; B. ); colMin[(B)-1][(A)-1]. DFLT_BORDER. #define DFLT_BORDER0. Definition at line 38 of file TGHtmlTable.cxx. DFLT_CELLPADDING. #define DFLT_CELLPADDING2. Definition at line 41 of file TGHtmlTable.cxx. DFLT_CELLSPACING_3D. #define DFLT_CELLSPACING_3D5. Definition at line 39 of file TGHtmlTable.cxx. DFLT_CELLSPACING_FLAT. #define DFLT_CELLSPACING_FLAT0. Definition at line 40 of file TGHtmlTable.cxx. DFLT_HSPACE. #define DFLT_HSPACE0. Definition at line 42 of file TGHtmlTable.cxx. DFLT_VSPACE. #define DFLT_VSPACE0. Definition at line 43 of file TGHtmlTable.cxx. MAX. #define MAX; (; ; A, . ; B. ); ((A) < (B) ? (B) : (A)). Definition at line 47 of file TGHtmlTable.cxx. N. #define N(HTML_MAX_COLUMNS+1). SETMAX. #define SETMAX; (; ; A, . ; B. ); if ((A) < (B)) { (A) = (B); }. Defi",MatchSource.WIKI,doc/v632/TGHtmlTable_8cxx.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/TGHtmlTable_8cxx.html
https://root.cern/doc/v632/TGWin32VirtualXProxy_8cxx.html:31707,Availability,mask,mask,31707,"h GetMarkerStyle GetTextAlign GetTextColor GetTextSize voidVOID_METHOD_ARG2 (VirtualX, SetWMState, Window_t, id, EInitialState, state, 1) VOID_METHOD_ARG3(VirtualX; ; Option_t Option_t TPoint TPoint const char GetTextMagnitude GetFillStyle GetLineColor GetLineWidth GetMarkerStyle GetTextAlign GetTextColor GetTextSize void char Point_t Rectangle_t WindowAttributes_t Float_t Float_t Float_t Int_t Int_t UInt_t UInt_t Rectangle_t Int_t Int_t Window_t TString Int_t GCValues_t GetPrimarySelectionOwner GetDisplay GetScreen GetColormap GetNativeEvent const char const char dpyName wid window const char font_name cursor keysym reg const char only_if_exist regb h Point_t winding char text const char depth char const char Int_t count const char ColorStruct_t color const char Pixmap_t Pixmap_t PictureAttributes_t attr const char char ret_data h unsigned char height h Atom_t Int_t ULong_t ULong_t unsigned char prop_listVOID_METHOD_ARG3 (VirtualX, ChangeActivePointerGrab, Window_t, win, UInt_t, mask, Cursor_t, cur, 1) VOID_METHOD_ARG5(VirtualX; ; Option_t Option_t TPoint TPoint const char GetTextMagnitude GetFillStyle GetLineColor GetLineWidth GetMarkerStyle GetTextAlign GetTextColor GetTextSize void char Point_t Rectangle_t WindowAttributes_t Float_t Float_t Float_tVOID_METHOD_ARG3 (VirtualX, GetFontProperties, FontStruct_t, font, Int_t &, max_ascent, Int_t &, max_descent, 1) VOID_METHOD_ARG5(VirtualX; ; Option_t Option_t TPoint TPoint const char GetTextMagnitude GetFillStyle GetLineColor GetLineWidth GetMarkerStyle GetTextAlign GetTextColor GetTextSize void char Point_t Rectangle_t WindowAttributes_t Float_t Float_t Float_t Int_t Int_t UInt_t UInt_tVOID_METHOD_ARG3 (VirtualX, GetImageSize, Drawable_t, id, UInt_t &, width, UInt_t &, height, 1) VOID_METHOD_ARG3(VirtualX; ; Option_t Option_t TPoint TPoint const char GetTextMagnitude GetFillStyle GetLineColor GetLineWidth GetMarkerStyle GetTextAlign GetTextColor GetTextSize void char Point_t Rectangle_t WindowAttributes_t Flo",MatchSource.WIKI,doc/v632/TGWin32VirtualXProxy_8cxx.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/TGWin32VirtualXProxy_8cxx.html
https://root.cern/doc/v632/TGWin32VirtualXProxy_8cxx.html:39419,Availability,mask,mask,39419,"e, Drawable_t, id, GContext_t, gc, Int_t, x, Int_t, y, UInt_t, w, UInt_t, h, 1) VOID_METHOD_ARG7(VirtualX; ; Option_t Option_t TPoint TPoint const char GetTextMagnitude GetFillStyle GetLineColor GetLineWidth GetMarkerStyle GetTextAlign GetTextColor GetTextSize void char Point_t Rectangle_tVOID_METHOD_ARG6 (VirtualX, DrawString, Drawable_t, id, GContext_t, gc, Int_t, x, Int_t, y, const char *, s, Int_t, len, 1) VOID_METHOD_ARG6(VirtualX; ; Option_t Option_t TPoint TPoint const char GetTextMagnitude GetFillStyle GetLineColor GetLineWidth GetMarkerStyle GetTextAlign GetTextColor GetTextSize void char Point_t Rectangle_tVOID_METHOD_ARG6 (VirtualX, GrabPointer, Window_t, id, UInt_t, evmask, Window_t, confine, Cursor_t, cursor, Bool_t, grab, Bool_t, owner_events, 1) VOID_METHOD_ARG6(VirtualX; ; Option_t Option_t TPoint TPoint const char GetTextMagnitude GetFillStyle GetLineColor GetLineWidth GetMarkerStyle GetTextAlign GetTextColor GetTextSize void char Point_t Rectangle_tVOID_METHOD_ARG7 (VirtualX, DrawCellArray, Int_t, x1, Int_t, y1, Int_t, x2, Int_t, y2, Int_t, nx, Int_t, ny, Int_t *, ic, 1) VOID_METHOD_ARG7(VirtualX; ; Option_t Option_t TPoint TPoint const char GetTextMagnitude GetFillStyle GetLineColor GetLineWidth GetMarkerStyle GetTextAlign GetTextColor GetTextSize void char Point_t Rectangle_t WindowAttributes_t Float_t Float_t Float_t Int_t Int_t UInt_t UInt_t Rectangle_t Int_t Int_t Window_tVOID_METHOD_ARG8 (VirtualX, QueryPointer, Window_t, id, Window_t &, rootw, Window_t &, childw, Int_t &, root_x, Int_t &, root_y, Int_t &, win_x, Int_t &, win_y, UInt_t &, mask, 1) VOID_METHOD_ARG0(VirtualX; ; Option_t Option_t TPoint TPoint const char GetTextMagnitude GetFillStyle GetLineColor GetLineWidth GetMarkerStyle GetTextAlign GetTextColor GetTextSize void char Point_t Rectangle_tVOID_METHOD_ARG9 (VirtualX, PutImage, Drawable_t, id, GContext_t, gc, Drawable_t, img, Int_t, dx, Int_t, dy, Int_t, x, Int_t, y, UInt_t, w, UInt_t, h, 1) VOID_METHOD_ARG9(VirtualX; .",MatchSource.WIKI,doc/v632/TGWin32VirtualXProxy_8cxx.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/TGWin32VirtualXProxy_8cxx.html
https://root.cern/doc/v632/TGWin32VirtualXProxy_8cxx.html:73088,Availability,mask,mask,73088,xt const char depth char const char Int_t count const char ColorStruct_t color const char Pixmap_t Pixmap_t PictureAttributes_t attr const char char ret_data h unsigned char height hLong_t; ; Option_t Option_t TPoint TPoint const char GetTextMagnitude GetFillStyle GetLineColor GetLineWidth GetMarkerStyle GetTextAlign GetTextColor GetTextSizeLowerWindow; ; Option_t Option_t TPoint TPoint const char GetTextMagnitude GetFillStyle GetLineColor GetLineWidth GetMarkerStyle GetTextAlign GetTextColor GetTextSize voidmain_id; ; Option_t Option_t TPoint TPoint const char GetTextMagnitude GetFillStyle GetLineColor GetLineWidth GetMarkerStyle GetTextAlign GetTextColor GetTextSizeMapSubwindows; ; Option_t Option_tmarkerstyle; ; Option_t Option_t TPoint TPoint const char GetTextMagnitude GetFillStyle GetLineColor GetLineWidth GetMarkerStyle GetTextAlign GetTextColor GetTextSize void char Point_t Rectangle_t WindowAttributes_t Float_t Float_t Float_t Int_t Int_t UInt_t UInt_t Rectangle_tmask; ; Option_t Option_t TPoint TPoint const char GetTextMagnitude GetFillStyle GetLineColor GetLineWidth GetMarkerStyle GetTextAlign GetTextColor GetTextSize void char Point_t Rectangle_t WindowAttributes_t Float_t Float_t Float_t Int_t Int_t UInt_t UInt_t Rectangle_tMask_t; ; Option_t Option_tmgn; ; Option_t Option_t TPoint TPoint const charmode; ; Option_t Option_t TPoint TPoint const char GetTextMagnitude GetFillStyle GetLineColor GetLineWidth GetMarkerStyle GetTextAlign GetTextColor GetTextSize void char Point_t Rectangle_tmodifier; ; Option_t Option_t TPoint TPoint const char GetTextMagnitude GetFillStyle GetLineColor GetLineWidth GetMarkerStyle GetTextAlign GetTextColor GetTextSize void char Point_tMoveResizeWindow; ; Option_t Option_t TPoint TPoint const char GetTextMagnitude GetFillStyle GetLineColor GetLineWidth GetMarkerStyle GetTextAlign GetTextColor GetTextSize void char Point_t Rectangle_t WindowAttributes_t Float_t Float_t Float_t Int_t Int_t UInt_t UInt_t Recta,MatchSource.WIKI,doc/v632/TGWin32VirtualXProxy_8cxx.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/TGWin32VirtualXProxy_8cxx.html
https://root.cern/doc/v632/TGWin32VirtualXProxy_8cxx.html:136502,Availability,mask,mask,136502,"_ARG2 ; (; VirtualX; , . SetWMState; , . Window_t; , . id; , . EInitialState; , . state; , . 1; . ). VOID_METHOD_ARG3() [1/11]. Option_t Option_t TPoint TPoint const char GetTextMagnitude GetFillStyle GetLineColor GetLineWidth GetMarkerStyle GetTextAlign GetTextColor GetTextSize void char Point_t Rectangle_t WindowAttributes_t Float_t Float_t Float_t Int_t Int_t UInt_t UInt_t Rectangle_t Int_t Int_t Window_t TString Int_t GCValues_t GetPrimarySelectionOwner GetDisplay GetScreen GetColormap GetNativeEvent const char const char dpyName wid window const char font_name cursor keysym reg const char only_if_exist regb h Point_t winding char text const char depth char const char Int_t count const char ColorStruct_t color const char Pixmap_t Pixmap_t PictureAttributes_t attr const char char ret_data h unsigned char height h Atom_t Int_t ULong_t ULong_t unsigned char prop_list VOID_METHOD_ARG3 ; (; VirtualX; , . ChangeActivePointerGrab; , . Window_t; , . win; , . UInt_t; , . mask; , . Cursor_t; , . cur; , . 1; . ). VOID_METHOD_ARG3() [2/11]. Option_t Option_t TPoint TPoint const char GetTextMagnitude GetFillStyle GetLineColor GetLineWidth GetMarkerStyle GetTextAlign GetTextColor GetTextSize void char Point_t Rectangle_t WindowAttributes_t Float_t Float_t Float_t VOID_METHOD_ARG3 ; (; VirtualX; , . GetFontProperties; , . FontStruct_t; , . font; , . Int_t &; , . max_ascent; , . Int_t &; , . max_descent; , . 1; . ). VOID_METHOD_ARG3() [3/11]. Option_t Option_t TPoint TPoint const char GetTextMagnitude GetFillStyle GetLineColor GetLineWidth GetMarkerStyle GetTextAlign GetTextColor GetTextSize void char Point_t Rectangle_t WindowAttributes_t Float_t Float_t Float_t Int_t Int_t UInt_t UInt_t VOID_METHOD_ARG3 ; (; VirtualX; , . GetImageSize; , . Drawable_t; , . id; , . UInt_t &; , . width; , . UInt_t &; , . height; , . 1; . ). VOID_METHOD_ARG3() [4/11]. Option_t Option_t TPoint TPoint const char GetTextMagnitude GetFillStyle GetLineColor",MatchSource.WIKI,doc/v632/TGWin32VirtualXProxy_8cxx.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/TGWin32VirtualXProxy_8cxx.html
https://root.cern/doc/v632/TGWin32VirtualXProxy_8cxx.html:145710,Availability,mask,mask,145710,"1; . ). VOID_METHOD_ARG7(). Option_t Option_t TPoint TPoint const char GetTextMagnitude GetFillStyle GetLineColor GetLineWidth GetMarkerStyle GetTextAlign GetTextColor GetTextSize void char Point_t Rectangle_t VOID_METHOD_ARG7 ; (; VirtualX; , . DrawCellArray; , . Int_t; , . x1; , . Int_t; , . y1; , . Int_t; , . x2; , . Int_t; , . y2; , . Int_t; , . nx; , . Int_t; , . ny; , . Int_t *; , . ic; , . 1; . ). VOID_METHOD_ARG8(). Option_t Option_t TPoint TPoint const char GetTextMagnitude GetFillStyle GetLineColor GetLineWidth GetMarkerStyle GetTextAlign GetTextColor GetTextSize void char Point_t Rectangle_t WindowAttributes_t Float_t Float_t Float_t Int_t Int_t UInt_t UInt_t Rectangle_t Int_t Int_t Window_t VOID_METHOD_ARG8 ; (; VirtualX; , . QueryPointer; , . Window_t; , . id; , . Window_t &; , . rootw; , . Window_t &; , . childw; , . Int_t &; , . root_x; , . Int_t &; , . root_y; , . Int_t &; , . win_x; , . Int_t &; , . win_y; , . UInt_t &; , . mask; , . 1; . ). VOID_METHOD_ARG9(). Option_t Option_t TPoint TPoint const char GetTextMagnitude GetFillStyle GetLineColor GetLineWidth GetMarkerStyle GetTextAlign GetTextColor GetTextSize void char Point_t Rectangle_t VOID_METHOD_ARG9 ; (; VirtualX; , . PutImage; , . Drawable_t; , . id; , . GContext_t; , . gc; , . Drawable_t; , . img; , . Int_t; , . dx; , . Int_t; , . dy; , . Int_t; , . x; , . Int_t; , . y; , . UInt_t; , . w; , . UInt_t; , . h; , . 1; . ). Variable Documentation. act_format. Option_t Option_t TPoint TPoint const char GetTextMagnitude GetFillStyle GetLineColor GetLineWidth GetMarkerStyle GetTextAlign GetTextColor GetTextSize void char Point_t Rectangle_t WindowAttributes_t Float_t Float_t Float_t Int_t Int_t UInt_t UInt_t Rectangle_t Int_t Int_t Window_t TString Int_t GCValues_t GetPrimarySelectionOwner GetDisplay GetScreen GetColormap GetNativeEvent const char const char dpyName wid window const char font_name cursor keysym reg const char only",MatchSource.WIKI,doc/v632/TGWin32VirtualXProxy_8cxx.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/TGWin32VirtualXProxy_8cxx.html
https://root.cern/doc/v632/TGWin32VirtualXProxy_8cxx.html:193173,Availability,mask,mask,193173,Struct_t color const char Pixmap_t Pixmap_t PictureAttributes_t attr const char char ret_data h unsigned char height h Long_t. Definition at line 245 of file TGWin32VirtualXProxy.cxx. LowerWindow. Option_t Option_t TPoint TPoint const char GetTextMagnitude GetFillStyle GetLineColor GetLineWidth GetMarkerStyle GetTextAlign GetTextColor GetTextSize LowerWindow. Definition at line 100 of file TGWin32VirtualXProxy.cxx. main_id. Option_t Option_t TPoint TPoint const char GetTextMagnitude GetFillStyle GetLineColor GetLineWidth GetMarkerStyle GetTextAlign GetTextColor GetTextSize void main_id. Definition at line 126 of file TGWin32VirtualXProxy.cxx. MapSubwindows. Option_t Option_t TPoint TPoint const char GetTextMagnitude GetFillStyle GetLineColor GetLineWidth GetMarkerStyle GetTextAlign GetTextColor GetTextSize MapSubwindows. Definition at line 94 of file TGWin32VirtualXProxy.cxx. markerstyle. Option_t Option_t markerstyle. Definition at line 52 of file TGWin32VirtualXProxy.cxx. mask. Option_t Option_t TPoint TPoint const char GetTextMagnitude GetFillStyle GetLineColor GetLineWidth GetMarkerStyle GetTextAlign GetTextColor GetTextSize void char Point_t Rectangle_t WindowAttributes_t Float_t Float_t Float_t Int_t Int_t UInt_t UInt_t Rectangle_t Int_t Int_t Window_t TString Int_t GCValues_t GetPrimarySelectionOwner GetDisplay GetScreen GetColormap GetNativeEvent const char const char dpyName wid window const char font_name cursor keysym reg const char only_if_exist regb h Point_t winding char text const char depth char const char Int_t count const char ColorStruct_t color const char Pixmap_t Pixmap_t PictureAttributes_t attr const char char ret_data h unsigned char height h mask. Definition at line 178 of file TGWin32VirtualXProxy.cxx. Mask_t. Option_t Option_t TPoint TPoint const char GetTextMagnitude GetFillStyle GetLineColor GetLineWidth GetMarkerStyle GetTextAlign GetTextColor GetTextSize void char Point_t Rectangle_t WindowAttributes_t Float_t Float_t Float,MatchSource.WIKI,doc/v632/TGWin32VirtualXProxy_8cxx.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/TGWin32VirtualXProxy_8cxx.html
https://root.cern/doc/v632/TGWin32VirtualXProxy_8cxx.html:193879,Availability,mask,mask,193879,indow. Definition at line 100 of file TGWin32VirtualXProxy.cxx. main_id. Option_t Option_t TPoint TPoint const char GetTextMagnitude GetFillStyle GetLineColor GetLineWidth GetMarkerStyle GetTextAlign GetTextColor GetTextSize void main_id. Definition at line 126 of file TGWin32VirtualXProxy.cxx. MapSubwindows. Option_t Option_t TPoint TPoint const char GetTextMagnitude GetFillStyle GetLineColor GetLineWidth GetMarkerStyle GetTextAlign GetTextColor GetTextSize MapSubwindows. Definition at line 94 of file TGWin32VirtualXProxy.cxx. markerstyle. Option_t Option_t markerstyle. Definition at line 52 of file TGWin32VirtualXProxy.cxx. mask. Option_t Option_t TPoint TPoint const char GetTextMagnitude GetFillStyle GetLineColor GetLineWidth GetMarkerStyle GetTextAlign GetTextColor GetTextSize void char Point_t Rectangle_t WindowAttributes_t Float_t Float_t Float_t Int_t Int_t UInt_t UInt_t Rectangle_t Int_t Int_t Window_t TString Int_t GCValues_t GetPrimarySelectionOwner GetDisplay GetScreen GetColormap GetNativeEvent const char const char dpyName wid window const char font_name cursor keysym reg const char only_if_exist regb h Point_t winding char text const char depth char const char Int_t count const char ColorStruct_t color const char Pixmap_t Pixmap_t PictureAttributes_t attr const char char ret_data h unsigned char height h mask. Definition at line 178 of file TGWin32VirtualXProxy.cxx. Mask_t. Option_t Option_t TPoint TPoint const char GetTextMagnitude GetFillStyle GetLineColor GetLineWidth GetMarkerStyle GetTextAlign GetTextColor GetTextSize void char Point_t Rectangle_t WindowAttributes_t Float_t Float_t Float_t Int_t Int_t UInt_t UInt_t Rectangle_t Mask_t. Definition at line 178 of file TGWin32VirtualXProxy.cxx. mgn. Option_t Option_t TPoint TPoint mgn. Definition at line 48 of file TGWin32VirtualXProxy.cxx. mode. Option_t Option_t TPoint TPoint const char GetTextMagnitude GetFillStyle GetLineColor GetLineWidth GetMarkerStyle GetTextAlign GetTextColor Get,MatchSource.WIKI,doc/v632/TGWin32VirtualXProxy_8cxx.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/TGWin32VirtualXProxy_8cxx.html
https://root.cern/doc/v632/TGWin32VirtualXProxy_8cxx.html:331,Integrability,depend,dependency,331,". ROOT: graf2d/win32gdk/src/TGWin32VirtualXProxy.cxx File Reference. ; ROOT ; . v6-32. Reference Guide ; . . Loading...; Searching...; No Matches. Functions |; Variables ; TGWin32VirtualXProxy.cxx File Reference. #include ""TGWin32ProxyDefs.h""; #include ""TGWin32VirtualXProxy.h""; #include ""TGWin32.h""; #include ""TList.h"". Include dependency graph for TGWin32VirtualXProxy.cxx:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead. Functions; Option_t Option_t TPoint TPoint const char GetTextMagnitude GetFillStyle GetLineColor GetLineWidth GetMarkerStyle GetTextAlign GetTextColor GetTextSize void char Point_t Rectangle_t WindowAttributes_t Float_t Float_t Float_t Int_t Int_t UInt_t UInt_t Rectangle_t Int_t Int_t Window_t TString Int_t GCValues_t GetPrimarySelectionOwnerRETURN_METHOD_ARG0 (VirtualX, Region_t, CreateRegion) RETURN_METHOD_ARG0_CONST(VirtualX; ; Option_t Option_t TPoint TPoint const char GetTextMagnitude GetFillStyle GetLineColor GetLineWidth GetMarkerStyle GetTextAlign GetTextColor GetTextSize void char Point_t Rectangle_t WindowAttributes_t Float_t Float_t Float_t Int_t Int_t UInt_t UInt_t Rectangle_t Int_t Int_t Window_t TString Int_t GCValues_tRETURN_METHOD_ARG0 (VirtualX, Window_t, GetInputFocus) RETURN_METHOD_ARG0(VirtualX; ; Option_t Option_t TPoint TPoint const char GetTextMagnitude GetFillStyle GetLineColor GetLineWidth GetMarkerStyle GetTextAlign GetTextColor GetTextSize void char Point_t Rectangle_t WindowAttributes_t Float_t Float_t Float_t Int_t Int_t UInt_t UInt_t Rectangle_t Int_t Int_t Window_t TString Int_t GCValues_t GetPrimarySelectionOwner GetDisplay GetScreen GetColormapRETURN_METHOD_ARG0_CONST (VirtualX, Bool_t, HasTTFonts) RETURN_METHOD_ARG0_CONST(VirtualX; ; Option_t Option_t TPoint TPoint const char GetTextMagnitude GetFillStyleRETURN_METHOD_ARG0_CONST (VirtualX, Bool_t, IsTransparent) RETURN_METHOD_ARG0_CONST(VirtualX; ; Option_t Option_t TPoint TPoint const char GetTextMagnitudeRETURN_METHOD",MatchSource.WIKI,doc/v632/TGWin32VirtualXProxy_8cxx.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/TGWin32VirtualXProxy_8cxx.html
https://root.cern/doc/v632/TGX11_8cxx.html:1289,Availability,error,error,1289,"11.h""; #include ""TPoint.h""; #include ""TMath.h""; #include ""TStorage.h""; #include ""TStyle.h""; #include ""TExMap.h""; #include ""TEnv.h""; #include ""TString.h""; #include ""TObjString.h""; #include ""TObjArray.h""; #include ""RStipples.h""; #include ""strlcpy.h""; #include <X11/Xlib.h>; #include <X11/Xutil.h>; #include <X11/Xatom.h>; #include <X11/cursorfont.h>; #include <X11/keysym.h>; #include <X11/xpm.h>; #include <cstdio>; #include <cstring>; #include <cstdlib>; #include <cctype>; #include <unistd.h>. Include dependency graph for TGX11.cxx:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead. Classes; struct RVisual; ; struct RXColor; ; struct RXGCValues; ; struct RXImage; ; struct RXPoint; ; struct RXVisualInfo; . Namespaces; namespace ROOT; tbb::task_arena is an alias of tbb::interface7::task_arena, which doesn't allow to forward declare tbb::task_arena without forward declaring tbb::interface7 ; . Functions; static Int_tDummyX11ErrorHandler (Display *, XErrorEvent *); Dummy error handler for X11. Used by FindUsableVisual(). ; ; static voidGetPixel (int y, int width, Byte_t *scline); Get pixels in line y and put in array scline. ; ; intGIFdecode (Byte_t *gifArr, Byte_t *pixArr, int *Width, int *Height, int *Ncols, Byte_t *R, Byte_t *G, Byte_t *B); ; longGIFencode (int Width, int Height, Int_t Ncol, Byte_t R[], Byte_t G[], Byte_t B[], Byte_t ScLine[], void(*get_scline)(int, int, Byte_t *), void(*pb)(Byte_t)); ; intGIFinfo (Byte_t *gifArr, int *Width, int *Height, int *Ncols); ; intGIFquantize (UInt_t width, UInt_t height, Int_t *ncol, Byte_t *red, Byte_t *green, Byte_t *blue, Byte_t *outputBuf, Byte_t *outputCmap); ; static voidPutByte (Byte_t b); Put byte b in output stream. ; ; intXRotDrawAlignedImageString (Display *, XFontStruct *, float, Drawable, GC, int, int, char *, int); A front end to XRotPaintAlignedString: -does alignment, paints background. ; ; intXRotDrawAlignedString (Display *, XFontStruct *, f",MatchSource.WIKI,doc/v632/TGX11_8cxx.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/TGX11_8cxx.html
https://root.cern/doc/v632/TGX11_8cxx.html:4734,Availability,error,error,4734,"GC *gGCmark = &gGClist[1]; ; static GC *gGCpxmp = &gGClist[6]; ; static GC *gGCtext = &gGClist[3]; ; static intgJoinStyle = JoinMiter; ; static ULong_tgKeybdMask; ; static intgLineStyle = LineSolid; ; static intgLineWidth = 0; ; struct {; ; intn; ; inttype; ; XPointxy [kMAXMK]; ; }gMarker; ; static intgMarkerCapStyle = CapRound; ; static intgMarkerJoinStyle = JoinRound; ; static intgMarkerLineStyle = LineSolid; ; static intgMarkerLineWidth = 0; ; static ULong_tgMouseMask; ; static CursorgNullCursor = 0; ; static FILE *gOut; ; static XFontStruct *gTextFont; ; static XWindow_t *gTws; ; static XImage *gXimage = nullptr; ; const Int_tkBIGGEST_RGB_VALUE = 65535; ; const Int_tkMAXFONT = 4; ; const intkMAXGC = 7; ; const Int_tkMAXMK = 100; ; const charnull_cursor_bits []; . Function Documentation. DummyX11ErrorHandler(). static Int_t DummyX11ErrorHandler ; (; Display *; , . XErrorEvent *; . ). static . Dummy error handler for X11. Used by FindUsableVisual(). ; Definition at line 839 of file TGX11.cxx. GetPixel(). static void GetPixel ; (; int; y, . int; width, . Byte_t *; scline. ). static . Get pixels in line y and put in array scline. ; Definition at line 3308 of file TGX11.cxx. GIFdecode(). int GIFdecode ; (; Byte_t *; gifArr, . Byte_t *; pixArr, . int *; Width, . int *; Height, . int *; Ncols, . Byte_t *; R, . Byte_t *; G, . Byte_t *; B. ). Definition at line 149 of file gifdecode.c. GIFencode(). long GIFencode ; (; int; Width, . int; Height, . Int_t; Ncol, . Byte_t; R[], . Byte_t; G[], . Byte_t; B[], . Byte_t; ScLine[], . void(*)(int, int, Byte_t *); get_scline, . void(*)(Byte_t); pb. ). GIFinfo(). int GIFinfo ; (; Byte_t *; gifArr, . int *; Width, . int *; Height, . int *; Ncols. ). Definition at line 80 of file gifdecode.c. GIFquantize(). int GIFquantize ; (; UInt_t; width, . UInt_t; height, . Int_t *; ncol, . Byte_t *; red, . Byte_t *; green, . By",MatchSource.WIKI,doc/v632/TGX11_8cxx.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/TGX11_8cxx.html
https://root.cern/doc/v632/TGX11_8cxx.html:1891,Energy Efficiency,green,green,1891," #include <unistd.h>. Include dependency graph for TGX11.cxx:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead. Classes; struct RVisual; ; struct RXColor; ; struct RXGCValues; ; struct RXImage; ; struct RXPoint; ; struct RXVisualInfo; . Namespaces; namespace ROOT; tbb::task_arena is an alias of tbb::interface7::task_arena, which doesn't allow to forward declare tbb::task_arena without forward declaring tbb::interface7 ; . Functions; static Int_tDummyX11ErrorHandler (Display *, XErrorEvent *); Dummy error handler for X11. Used by FindUsableVisual(). ; ; static voidGetPixel (int y, int width, Byte_t *scline); Get pixels in line y and put in array scline. ; ; intGIFdecode (Byte_t *gifArr, Byte_t *pixArr, int *Width, int *Height, int *Ncols, Byte_t *R, Byte_t *G, Byte_t *B); ; longGIFencode (int Width, int Height, Int_t Ncol, Byte_t R[], Byte_t G[], Byte_t B[], Byte_t ScLine[], void(*get_scline)(int, int, Byte_t *), void(*pb)(Byte_t)); ; intGIFinfo (Byte_t *gifArr, int *Width, int *Height, int *Ncols); ; intGIFquantize (UInt_t width, UInt_t height, Int_t *ncol, Byte_t *red, Byte_t *green, Byte_t *blue, Byte_t *outputBuf, Byte_t *outputCmap); ; static voidPutByte (Byte_t b); Put byte b in output stream. ; ; intXRotDrawAlignedImageString (Display *, XFontStruct *, float, Drawable, GC, int, int, char *, int); A front end to XRotPaintAlignedString: -does alignment, paints background. ; ; intXRotDrawAlignedString (Display *, XFontStruct *, float, Drawable, GC, int, int, char *, int); A front end to XRotPaintAlignedString: -does alignment, no background. ; ; intXRotDrawImageString (Display *, XFontStruct *, float, Drawable, GC, int, int, char *); A front end to XRotPaintAlignedString: -no alignment, paints background. ; ; intXRotDrawString (Display *, XFontStruct *, float, Drawable, GC, int, int, char *); A front end to XRotPaintAlignedString: -no alignment, no background. ; ; voidXRotSetBounding",MatchSource.WIKI,doc/v632/TGX11_8cxx.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/TGX11_8cxx.html
https://root.cern/doc/v632/TGX11_8cxx.html:5731,Energy Efficiency,green,green,5731,"ummy error handler for X11. Used by FindUsableVisual(). ; Definition at line 839 of file TGX11.cxx. GetPixel(). static void GetPixel ; (; int; y, . int; width, . Byte_t *; scline. ). static . Get pixels in line y and put in array scline. ; Definition at line 3308 of file TGX11.cxx. GIFdecode(). int GIFdecode ; (; Byte_t *; gifArr, . Byte_t *; pixArr, . int *; Width, . int *; Height, . int *; Ncols, . Byte_t *; R, . Byte_t *; G, . Byte_t *; B. ). Definition at line 149 of file gifdecode.c. GIFencode(). long GIFencode ; (; int; Width, . int; Height, . Int_t; Ncol, . Byte_t; R[], . Byte_t; G[], . Byte_t; B[], . Byte_t; ScLine[], . void(*)(int, int, Byte_t *); get_scline, . void(*)(Byte_t); pb. ). GIFinfo(). int GIFinfo ; (; Byte_t *; gifArr, . int *; Width, . int *; Height, . int *; Ncols. ). Definition at line 80 of file gifdecode.c. GIFquantize(). int GIFquantize ; (; UInt_t; width, . UInt_t; height, . Int_t *; ncol, . Byte_t *; red, . Byte_t *; green, . Byte_t *; blue, . Byte_t *; outputBuf, . Byte_t *; outputCmap. ). PutByte(). static void PutByte ; (; Byte_t; b). static . Put byte b in output stream. ; Definition at line 3317 of file TGX11.cxx. XRotDrawAlignedImageString(). int XRotDrawAlignedImageString ; (; Display *; dpy, . XFontStruct *; font, . float; angle, . Drawable; drawable, . GC; gc, . int; x, . int; y, . char *; text, . int; align. ). A front end to XRotPaintAlignedString: -does alignment, paints background. ; Definition at line 316 of file Rotated.cxx. XRotDrawAlignedString(). int XRotDrawAlignedString ; (; Display *; dpy, . XFontStruct *; font, . float; angle, . Drawable; drawable, . GC; gc, . int; x, . int; y, . char *; text, . int; align. ). A front end to XRotPaintAlignedString: -does alignment, no background. ; Definition at line 305 of file Rotated.cxx. XRotDrawImageString(). int XRotDrawImageString ; (; Display *; dpy, . XFontStruct *; font, . float; angle, . Drawabl",MatchSource.WIKI,doc/v632/TGX11_8cxx.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/TGX11_8cxx.html
https://root.cern/doc/v632/TGX11_8cxx.html:762,Integrability,depend,dependency,762,". ROOT: graf2d/x11/src/TGX11.cxx File Reference. ; ROOT ; . v6-32. Reference Guide ; . . Loading...; Searching...; No Matches. Classes |; Namespaces |; Functions |; Variables ; TGX11.cxx File Reference. #include ""TROOT.h""; #include ""TColor.h""; #include ""TGX11.h""; #include ""TPoint.h""; #include ""TMath.h""; #include ""TStorage.h""; #include ""TStyle.h""; #include ""TExMap.h""; #include ""TEnv.h""; #include ""TString.h""; #include ""TObjString.h""; #include ""TObjArray.h""; #include ""RStipples.h""; #include ""strlcpy.h""; #include <X11/Xlib.h>; #include <X11/Xutil.h>; #include <X11/Xatom.h>; #include <X11/cursorfont.h>; #include <X11/keysym.h>; #include <X11/xpm.h>; #include <cstdio>; #include <cstring>; #include <cstdlib>; #include <cctype>; #include <unistd.h>. Include dependency graph for TGX11.cxx:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead. Classes; struct RVisual; ; struct RXColor; ; struct RXGCValues; ; struct RXImage; ; struct RXPoint; ; struct RXVisualInfo; . Namespaces; namespace ROOT; tbb::task_arena is an alias of tbb::interface7::task_arena, which doesn't allow to forward declare tbb::task_arena without forward declaring tbb::interface7 ; . Functions; static Int_tDummyX11ErrorHandler (Display *, XErrorEvent *); Dummy error handler for X11. Used by FindUsableVisual(). ; ; static voidGetPixel (int y, int width, Byte_t *scline); Get pixels in line y and put in array scline. ; ; intGIFdecode (Byte_t *gifArr, Byte_t *pixArr, int *Width, int *Height, int *Ncols, Byte_t *R, Byte_t *G, Byte_t *B); ; longGIFencode (int Width, int Height, Int_t Ncol, Byte_t R[], Byte_t G[], Byte_t B[], Byte_t ScLine[], void(*get_scline)(int, int, Byte_t *), void(*pb)(Byte_t)); ; intGIFinfo (Byte_t *gifArr, int *Width, int *Height, int *Ncols); ; intGIFquantize (UInt_t width, UInt_t height, Int_t *ncol, Byte_t *red, Byte_t *green, Byte_t *blue, Byte_t *outputBuf, Byte_t *outputCmap); ; static voidPutByte (Byte_t b); Put byte b in",MatchSource.WIKI,doc/v632/TGX11_8cxx.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/TGX11_8cxx.html
https://root.cern/doc/v632/TIOFeatures_8hxx_source.html:3385,Energy Efficiency,efficient,efficient,3385,"features in this enum.; 63};; 64 ; 65 ; 66} // namespace Experimental; 67 ; 68 ; 69class TIOFeatures {; 70friend class ::TTree;; 71friend class ::TBranch;; 72friend class ::TBasket;; 73 ; 74public:; 75 TIOFeatures() {}; 76 ; 77 void Clear(EIOFeatures bits);; 78 void Clear(Experimental::EIOUnsupportedFeatures bits);; 79 void Clear(Experimental::EIOFeatures bits);; 80 bool Set(EIOFeatures bits);; 81 bool Set(Experimental::EIOFeatures bits);; 82 bool Set(const std::string &);; 83 bool Test(EIOFeatures bits) const;; 84 bool Test(Experimental::EIOFeatures bits) const;; 85 bool Test(Experimental::EIOUnsupportedFeatures bits) const;; 86 void Print() const;; 87 ; 88 // The number of known, defined IO features (supported / unsupported / experimental).; 89 static constexpr int kIOFeatureCount = 1;; 90 ; 91private:; 92 // These methods allow access to the raw bitset underlying; 93 // this object, breaking type safety. They are necessary for; 94 // efficient interaction with TTree / TBranch / TBasket, but left; 95 // private to prevent users from interacting with the raw bits.; 96 TIOFeatures(UChar_t IOBits) : fIOBits(IOBits) {}; 97 UChar_t GetFeatures() const;; 98 void Set(UChar_t newBits) {fIOBits = newBits;}; 99 ; 100 UChar_t fIOBits{0};; 101};; 102 ; 103} // namespace ROOT; 104 ; 105#endif // ROOT_TIO_FEATURES; UChar_tunsigned char UChar_tDefinition RtypesCore.h:38; Rtypes.h; BIT#define BIT(n)Definition Rtypes.h:85; ROOT::TIOFeaturesTIOFeatures provides the end-user with the ability to change the IO behavior of data written via a TT...Definition TIOFeatures.hxx:69; ROOT::TIOFeatures::GetFeaturesUChar_t GetFeatures() constDefinition TIOFeatures.cxx:250; ROOT::TIOFeatures::TIOFeaturesTIOFeatures(UChar_t IOBits)Definition TIOFeatures.hxx:96; ROOT::TIOFeatures::Testbool Test(Experimental::EIOUnsupportedFeatures bits) const; ROOT::TIOFeatures::Printvoid Print() constPrint a human-readable representation of the TIOFeatures to stdout.Definition TIOFeatures.cxx:197; ROOT::TIOFeature",MatchSource.WIKI,doc/v632/TIOFeatures_8hxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/TIOFeatures_8hxx_source.html
https://root.cern/doc/v632/TIOFeatures_8hxx_source.html:3347,Safety,safe,safety,3347,"re is never an IO feature that goes into the ROOT:: namespace; 60// but is unsupported.; 61enum class EIOUnsupportedFeatures {; 62 kUnsupported = 0 // Union of all features in this enum.; 63};; 64 ; 65 ; 66} // namespace Experimental; 67 ; 68 ; 69class TIOFeatures {; 70friend class ::TTree;; 71friend class ::TBranch;; 72friend class ::TBasket;; 73 ; 74public:; 75 TIOFeatures() {}; 76 ; 77 void Clear(EIOFeatures bits);; 78 void Clear(Experimental::EIOUnsupportedFeatures bits);; 79 void Clear(Experimental::EIOFeatures bits);; 80 bool Set(EIOFeatures bits);; 81 bool Set(Experimental::EIOFeatures bits);; 82 bool Set(const std::string &);; 83 bool Test(EIOFeatures bits) const;; 84 bool Test(Experimental::EIOFeatures bits) const;; 85 bool Test(Experimental::EIOUnsupportedFeatures bits) const;; 86 void Print() const;; 87 ; 88 // The number of known, defined IO features (supported / unsupported / experimental).; 89 static constexpr int kIOFeatureCount = 1;; 90 ; 91private:; 92 // These methods allow access to the raw bitset underlying; 93 // this object, breaking type safety. They are necessary for; 94 // efficient interaction with TTree / TBranch / TBasket, but left; 95 // private to prevent users from interacting with the raw bits.; 96 TIOFeatures(UChar_t IOBits) : fIOBits(IOBits) {}; 97 UChar_t GetFeatures() const;; 98 void Set(UChar_t newBits) {fIOBits = newBits;}; 99 ; 100 UChar_t fIOBits{0};; 101};; 102 ; 103} // namespace ROOT; 104 ; 105#endif // ROOT_TIO_FEATURES; UChar_tunsigned char UChar_tDefinition RtypesCore.h:38; Rtypes.h; BIT#define BIT(n)Definition Rtypes.h:85; ROOT::TIOFeaturesTIOFeatures provides the end-user with the ability to change the IO behavior of data written via a TT...Definition TIOFeatures.hxx:69; ROOT::TIOFeatures::GetFeaturesUChar_t GetFeatures() constDefinition TIOFeatures.cxx:250; ROOT::TIOFeatures::TIOFeaturesTIOFeatures(UChar_t IOBits)Definition TIOFeatures.hxx:96; ROOT::TIOFeatures::Testbool Test(Experimental::EIOUnsupportedFeatures bits)",MatchSource.WIKI,doc/v632/TIOFeatures_8hxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/TIOFeatures_8hxx_source.html
https://root.cern/doc/v632/TIOFeatures_8hxx_source.html:3277,Security,access,access,3277,"re is never an IO feature that goes into the ROOT:: namespace; 60// but is unsupported.; 61enum class EIOUnsupportedFeatures {; 62 kUnsupported = 0 // Union of all features in this enum.; 63};; 64 ; 65 ; 66} // namespace Experimental; 67 ; 68 ; 69class TIOFeatures {; 70friend class ::TTree;; 71friend class ::TBranch;; 72friend class ::TBasket;; 73 ; 74public:; 75 TIOFeatures() {}; 76 ; 77 void Clear(EIOFeatures bits);; 78 void Clear(Experimental::EIOUnsupportedFeatures bits);; 79 void Clear(Experimental::EIOFeatures bits);; 80 bool Set(EIOFeatures bits);; 81 bool Set(Experimental::EIOFeatures bits);; 82 bool Set(const std::string &);; 83 bool Test(EIOFeatures bits) const;; 84 bool Test(Experimental::EIOFeatures bits) const;; 85 bool Test(Experimental::EIOUnsupportedFeatures bits) const;; 86 void Print() const;; 87 ; 88 // The number of known, defined IO features (supported / unsupported / experimental).; 89 static constexpr int kIOFeatureCount = 1;; 90 ; 91private:; 92 // These methods allow access to the raw bitset underlying; 93 // this object, breaking type safety. They are necessary for; 94 // efficient interaction with TTree / TBranch / TBasket, but left; 95 // private to prevent users from interacting with the raw bits.; 96 TIOFeatures(UChar_t IOBits) : fIOBits(IOBits) {}; 97 UChar_t GetFeatures() const;; 98 void Set(UChar_t newBits) {fIOBits = newBits;}; 99 ; 100 UChar_t fIOBits{0};; 101};; 102 ; 103} // namespace ROOT; 104 ; 105#endif // ROOT_TIO_FEATURES; UChar_tunsigned char UChar_tDefinition RtypesCore.h:38; Rtypes.h; BIT#define BIT(n)Definition Rtypes.h:85; ROOT::TIOFeaturesTIOFeatures provides the end-user with the ability to change the IO behavior of data written via a TT...Definition TIOFeatures.hxx:69; ROOT::TIOFeatures::GetFeaturesUChar_t GetFeatures() constDefinition TIOFeatures.cxx:250; ROOT::TIOFeatures::TIOFeaturesTIOFeatures(UChar_t IOBits)Definition TIOFeatures.hxx:96; ROOT::TIOFeatures::Testbool Test(Experimental::EIOUnsupportedFeatures bits)",MatchSource.WIKI,doc/v632/TIOFeatures_8hxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/TIOFeatures_8hxx_source.html
https://root.cern/doc/v632/TROOT_8cxx_source.html:18764,Availability,avail,available,18764,"ad default to nullptr, as it is for single-thread programs.; 495 ///; 496 /// The ROOT graphics subsystem is not made thread-safe by this method. In particular drawing or printing different; 497 /// canvases from different threads (and analogous operations such as invoking `Draw` on a `TObject`) is not thread-safe.; 498 ///; 499 /// Note that there is no `DisableThreadSafety()`. ROOT's thread-safety features cannot be disabled once activated.; 500 // clang-format on; 501 void EnableThreadSafety(); 502 {; 503 static void (*sym)() = (void(*)())Internal::GetSymInLibImt(""ROOT_TThread_Initialize"");; 504 if (sym); 505 sym();; 506 }; 507 ; 508 ////////////////////////////////////////////////////////////////////////////////; 509 /// @param[in] numthreads Number of threads to use. If not specified or; 510 /// set to zero, the number of threads is automatically; 511 /// decided by the implementation. Any other value is; 512 /// used as a hint.; 513 ///; 514 /// ROOT must be built with the compilation flag `imt=ON` for this feature to be available.; 515 /// The following objects and methods automatically take advantage of; 516 /// multi-threading if a call to `EnableImplicitMT` has been made before usage:; 517 ///; 518 /// - RDataFrame internally runs the event-loop by parallelizing over clusters of entries; 519 /// - TTree::GetEntry reads multiple branches in parallel; 520 /// - TTree::FlushBaskets writes multiple baskets to disk in parallel; 521 /// - TTreeCacheUnzip decompresses the baskets contained in a TTreeCache in parallel; 522 /// - THx::Fit performs in parallel the evaluation of the objective function over the data; 523 /// - TMVA::DNN trains the deep neural networks in parallel; 524 /// - TMVA::BDT trains the classifier in parallel and multiclass BDTs are evaluated in parallel; 525 ///; 526 /// EnableImplicitMT calls in turn EnableThreadSafety.; 527 /// The 'numthreads' parameter allows to control the number of threads to; 528 /// be used by the implicit multi-threa",MatchSource.WIKI,doc/v632/TROOT_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/TROOT_8cxx_source.html
https://root.cern/doc/v632/TROOT_8cxx_source.html:28210,Availability,avail,available,28210,"reate already here, but only initialize it after gEnv has been created; 671 gPluginMgr = fPluginManager = new TPluginManager;; 672 ; 673 // Initialize Operating System interface; 674 InitSystem();; 675 ; 676 // Initialize static directory functions; 677 GetRootSys();; 678 GetBinDir();; 679 GetLibDir();; 680 GetIncludeDir();; 681 GetEtcDir();; 682 GetDataDir();; 683 GetDocDir();; 684 GetMacroDir();; 685 GetTutorialDir();; 686 GetSourceDir();; 687 GetIconPath();; 688 GetTTFFontDir();; 689 ; 690 gRootDir = GetRootSys().Data();; 691 ; 692 TDirectory::BuildDirectory(nullptr, nullptr);; 693 ; 694 // Initialize interface to CINT C++ interpreter; 695 fVersionInt = 0; // check in TROOT dtor in case TCling fails; 696 fClasses = nullptr; // might be checked via TCling ctor; 697 fEnums = nullptr;; 698 ; 699 fConfigOptions = R__CONFIGUREOPTIONS;; 700 fConfigFeatures = R__CONFIGUREFEATURES;; 701 fVersion = ROOT_RELEASE;; 702 fVersionCode = ROOT_VERSION_CODE;; 703 fVersionInt = IVERSQ();; 704 fVersionDate = IDATQQ(ROOT_RELEASE_DATE);; 705 fVersionTime = ITIMQQ(ROOT_RELEASE_TIME);; 706 fBuiltDate = IDATQQ(__DATE__);; 707 fBuiltTime = ITIMQQ(__TIME__);; 708 ; 709 ReadGitInfo();; 710 ; 711 fClasses = new THashTable(800,3); fClasses->UseRWLock();; 712 //fIdMap = new IdMap_t;; 713 fStreamerInfo = new TObjArray(100); fStreamerInfo->UseRWLock();; 714 fClassGenerators = new TList;; 715 ; 716 // usedToIdentifyRootClingByDlSym is available when TROOT is part of; 717 // rootcling.; 718 if (!dlsym(RTLD_DEFAULT, ""usedToIdentifyRootClingByDlSym"")) {; 719 // initialize plugin manager early; 720 fPluginManager->LoadHandlersFromEnv(gEnv);; 721 }; 722 ; 723 TSystemDirectory *workdir = new TSystemDirectory(""workdir"", gSystem->WorkingDirectory());; 724 ; 725 auto setNameLocked = [](TSeqCollection *l, const char *collection_name) {; 726 l->SetName(collection_name);; 727 l->UseRWLock();; 728 return l;; 729 };; 730 ; 731 fTimer = 0;; 732 fApplication = nullptr;; 733 fColors = setNameLocked(new TObjArray(",MatchSource.WIKI,doc/v632/TROOT_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/TROOT_8cxx_source.html
https://root.cern/doc/v632/TROOT_8cxx_source.html:35599,Availability,error,error,35599,"ources used by ROOT (files, network sockets,; 865/// shared memory segments, etc.).; 866 ; 867TROOT::~TROOT(); 868{; 869 using namespace ROOT::Internal;; 870 ; 871 if (gROOTLocal == this) {; 872 ; 873 // TMapFile must be closed before they are deleted, so run CloseFiles; 874 // (possibly a second time if the application has an explicit TApplication; 875 // object, but in that this is a no-op). TMapFile needs the slow close; 876 // so that the custome operator delete can properly find out whether the; 877 // memory being 'freed' is part of a memory mapped file or not.; 878 CloseFiles();; 879 ; 880 // If the interpreter has not yet been initialized, don't bother; 881 gGetROOT = &GetROOT1;; 882 ; 883 // Mark the object as invalid, so that we can veto some actions; 884 // (like autoloading) while we are in the destructor.; 885 SetBit(TObject::kInvalidObject);; 886 ; 887 // Turn-off the global mutex to avoid recreating mutexes that have; 888 // already been deleted during the destruction phase; 889 if (gGlobalMutex) {; 890 TVirtualMutex *m = gGlobalMutex;; 891 gGlobalMutex = nullptr;; 892 delete m;; 893 }; 894 ; 895 // Return when error occurred in TCling, i.e. when setup file(s) are; 896 // out of date; 897 if (!fVersionInt) return;; 898 ; 899 // ATTENTION!!! Order is important!; 900 ; 901 SafeDelete(fBrowsables);; 902 ; 903 // FIXME: Causes rootcling to deadlock, debug and uncomment; 904 // SafeDelete(fRootFolder);; 905 ; 906#ifdef R__COMPLETE_MEM_TERMINATION; 907 fSpecials->Delete(); SafeDelete(fSpecials); // delete special objects : PostScript, Minuit, Html; 908#endif; 909 ; 910 fClosedObjects->Delete(""slow""); // and closed files; 911 fFiles->Delete(""slow""); // and files; 912 SafeDelete(fFiles);; 913 fSecContexts->Delete(""slow""); SafeDelete(fSecContexts); // and security contexts; 914 fSockets->Delete(); SafeDelete(fSockets); // and sockets; 915 fMappedFiles->Delete(""slow""); // and mapped files; 916 TSeqCollection *tl = fMappedFiles; fMappedFiles = nullptr; delete tl;",MatchSource.WIKI,doc/v632/TROOT_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/TROOT_8cxx_source.html
https://root.cern/doc/v632/TROOT_8cxx_source.html:39812,Availability,avail,available,39812,"2 // On the link line, we must list the most dependent .o file; 983 // and end with the least dependent (LLVM libraries), unfortunately,; 984 // Fedora Core 17+ or Ubuntu 12 will also execute the initialization; 985 // in the same order (hence doing libCore's before LLVM's and; 986 // vice et versa for both the destructor. We worked around the; 987 // initialization order by delay the TROOT creation until first use.; 988 // We can not do the same for destruction as we have no way of knowing; 989 // the last access ...; 990 // So for now, let's avoid delete TCling except in the special build; 991 // checking the completeness of the termination deletion.; 992 ; 993 // TODO: Should we do more cleanup here than just call delete?; 994 // Segfaults rootcling in some cases, debug and uncomment:; 995 //; 996 // delete fInterpreter;; 997 ; 998 // We cannot delete fCleanups because of the logic in atexit which needs it.; 999 SafeDelete(fCleanups);; 1000#endif; 1001 ; 1002#ifdef _MSC_VER; 1003 // usedToIdentifyRootClingByDlSym is available when TROOT is part of rootcling.; 1004 if (dlsym(RTLD_DEFAULT, ""usedToIdentifyRootClingByDlSym"")) {; 1005 // deleting the interpreter makes things crash at exit in some cases; 1006 delete fInterpreter;; 1007 }; 1008#else; 1009 // deleting the interpreter makes things crash at exit in some cases; 1010 delete fInterpreter;; 1011#endif; 1012 ; 1013 // Prints memory stats; 1014 TStorage::PrintStatistics();; 1015 ; 1016 gROOTLocal = nullptr;; 1017 fgRootInit = kFALSE;; 1018 }; 1019}; 1020 ; 1021////////////////////////////////////////////////////////////////////////////////; 1022/// Add a class to the list and map of classes.; 1023/// This routine is deprecated, use TClass::AddClass directly.; 1024 ; 1025void TROOT::AddClass(TClass *cl); 1026{; 1027 TClass::AddClass(cl);; 1028}; 1029 ; 1030////////////////////////////////////////////////////////////////////////////////; 1031/// Add a class generator. This generator will be called by TClass::GetCl",MatchSource.WIKI,doc/v632/TROOT_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/TROOT_8cxx_source.html
https://root.cern/doc/v632/TROOT_8cxx_source.html:49603,Availability,down,down,49603,"; 1230 cursor = notclosed.FirstLink();; 1231 while (cursor) {; 1232 static_cast<TList*>(fSockets)->AddLast(cursor->GetObject());; 1233 cursor = cursor->Next();; 1234 }; 1235 }; 1236 gInterpreter->CallFunc_Delete(socketCloser);; 1237 }; 1238 if (fMappedFiles && fMappedFiles->First()) {; 1239 R__ListSlowClose<TVirtualMapFile>(static_cast<TList*>(fMappedFiles));; 1240 }; 1241 ; 1242}; 1243 ; 1244////////////////////////////////////////////////////////////////////////////////; 1245/// Execute the cleanups necessary at the end of the process, in particular; 1246/// those that must be executed before the library start being unloaded.; 1247 ; 1248void TROOT::EndOfProcessCleanups(); 1249{; 1250 // This will not delete the objects 'held' by the TFiles so that; 1251 // they can still be 'reacheable' when ResetGlobals is run.; 1252 CloseFiles();; 1253 ; 1254 if (gInterpreter) {; 1255 // This might delete some of the objects 'held' by the TFiles (hence; 1256 // `CloseFiles` must not delete them); 1257 gInterpreter->ResetGlobals();; 1258 }; 1259 ; 1260 // Now delete the objects still 'held' by the TFiles so that it; 1261 // is done before the tear down of the libraries.; 1262 if (fClosedObjects && fClosedObjects->First()) {; 1263 R__ListSlowDeleteContent(static_cast<TList*>(fClosedObjects));; 1264 }; 1265 fList->Delete(""slow"");; 1266 ; 1267 // Now a set of simpler things to delete. See the same ordering in; 1268 // TROOT::~TROOT; 1269 fFunctions->Delete();; 1270 fGeometries->Delete();; 1271 fBrowsers->Delete();; 1272 fCanvases->Delete(""slow"");; 1273 fColors->Delete();; 1274 fStyles->Delete();; 1275 ; 1276 TQObject::BlockAllSignals(kTRUE);; 1277 ; 1278 if (gInterpreter) {; 1279 gInterpreter->ShutDown();; 1280 }; 1281}; 1282 ; 1283 ; 1284////////////////////////////////////////////////////////////////////////////////; 1285/// Find an object in one Root folder; 1286 ; 1287TObject *TROOT::FindObject(const TObject *) const; 1288{; 1289 Error(""FindObject"",""Not yet implemented"");; 1290 ",MatchSource.WIKI,doc/v632/TROOT_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/TROOT_8cxx_source.html
https://root.cern/doc/v632/TROOT_8cxx_source.html:73350,Availability,avail,available,73350,"///////; 1882/// Get number of types.; 1883 ; 1884Int_t TROOT::GetNtypes() const; 1885{; 1886 return fTypes->GetSize();; 1887}; 1888 ; 1889////////////////////////////////////////////////////////////////////////////////; 1890/// Execute command when system has been idle for idleTimeInSec seconds.; 1891 ; 1892void TROOT::Idle(UInt_t idleTimeInSec, const char *command); 1893{; 1894 if (!fApplication.load()); 1895 TApplication::CreateApplication();; 1896 ; 1897 if (idleTimeInSec <= 0); 1898 (*fApplication).RemoveIdleTimer();; 1899 else; 1900 (*fApplication).SetIdleTimer(idleTimeInSec, command);; 1901}; 1902 ; 1903////////////////////////////////////////////////////////////////////////////////; 1904/// Check whether className is a known class, and only autoload; 1905/// if we can. Helper function for TROOT::IgnoreInclude().; 1906 ; 1907static TClass* R__GetClassIfKnown(const char* className); 1908{; 1909 // Check whether the class is available for auto-loading first:; 1910 const char* libsToLoad = gInterpreter->GetClassSharedLibs(className);; 1911 TClass* cla = nullptr;; 1912 if (libsToLoad) {; 1913 // trigger autoload, and only create TClass in this case.; 1914 return TClass::GetClass(className);; 1915 } else if (gROOT->GetListOfClasses(); 1916 && (cla = (TClass*)gROOT->GetListOfClasses()->FindObject(className))) {; 1917 // cla assigned in if statement; 1918 } else if (gClassTable->FindObject(className)) {; 1919 return TClass::GetClass(className);; 1920 }; 1921 return cla;; 1922}; 1923 ; 1924////////////////////////////////////////////////////////////////////////////////; 1925/// Return 1 if the name of the given include file corresponds to a class that; 1926/// is known to ROOT, e.g. ""TLorentzVector.h"" versus TLorentzVector.; 1927 ; 1928Int_t TROOT::IgnoreInclude(const char *fname, const char * /*expandedfname*/); 1929{; 1930 if (fname == nullptr) return 0;; 1931 ; 1932 TString stem(fname);; 1933 // Remove extension if any, ignore files with extension not being .h*; 19",MatchSource.WIKI,doc/v632/TROOT_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/TROOT_8cxx_source.html
https://root.cern/doc/v632/TROOT_8cxx_source.html:75642,Availability,error,error,75642,"where);; 1941 }; 1942 ; 1943 TString className = gSystem->BaseName(stem);; 1944 TClass* cla = R__GetClassIfKnown(className);; 1945 if (!cla) {; 1946 // Try again with modifications to the file name:; 1947 className = stem;; 1948 className.ReplaceAll(""/"", ""::"");; 1949 className.ReplaceAll(""\\"", ""::"");; 1950 if (className.Contains("":::"")) {; 1951 // ""C:\dir"" becomes ""C:::dir"".; 1952 // fname corresponds to whatever is stated after #include and; 1953 // a full path name usually means that it's not a regular #include; 1954 // but e.g. a "".L"", so we can assume that this is not a header of; 1955 // a class in a namespace (a global-namespace class would have been; 1956 // detected already before).; 1957 return 0;; 1958 }; 1959 cla = R__GetClassIfKnown(className);; 1960 }; 1961 ; 1962 if (!cla) {; 1963 return 0;; 1964 }; 1965 ; 1966 // cla is valid, check wether it's actually in the header of the same name:; 1967 if (cla->GetDeclFileLine() <= 0) return 0; // to a void an error with VisualC++; 1968 TString decfile = gSystem->BaseName(cla->GetDeclFileName());; 1969 if (decfile != gSystem->BaseName(fname)) {; 1970 return 0;; 1971 }; 1972 return 1;; 1973}; 1974 ; 1975////////////////////////////////////////////////////////////////////////////////; 1976/// Initialize operating system interface.; 1977 ; 1978void TROOT::InitSystem(); 1979{; 1980 if (gSystem == nullptr) {; 1981#if defined(R__UNIX); 1982#if defined(R__HAS_COCOA); 1983 gSystem = new TMacOSXSystem;; 1984#else; 1985 gSystem = new TUnixSystem;; 1986#endif; 1987#elif defined(R__WIN32); 1988 gSystem = new TWinNTSystem;; 1989#else; 1990 gSystem = new TSystem;; 1991#endif; 1992 ; 1993 if (gSystem->Init()); 1994 fprintf(stderr, ""Fatal in <TROOT::InitSystem>: can't init operating system layer\n"");; 1995 ; 1996 if (!gSystem->HomeDirectory()) {; 1997 fprintf(stderr, ""Fatal in <TROOT::InitSystem>: HOME directory not set\n"");; 1998 fprintf(stderr, ""Fix this by defining the HOME shell variable\n"");; 1999 }; 2000 ; 2001 // read defa",MatchSource.WIKI,doc/v632/TROOT_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/TROOT_8cxx_source.html
https://root.cern/doc/v632/TROOT_8cxx_source.html:77145,Availability,avail,available,77145,"MacOSXSystem;; 1984#else; 1985 gSystem = new TUnixSystem;; 1986#endif; 1987#elif defined(R__WIN32); 1988 gSystem = new TWinNTSystem;; 1989#else; 1990 gSystem = new TSystem;; 1991#endif; 1992 ; 1993 if (gSystem->Init()); 1994 fprintf(stderr, ""Fatal in <TROOT::InitSystem>: can't init operating system layer\n"");; 1995 ; 1996 if (!gSystem->HomeDirectory()) {; 1997 fprintf(stderr, ""Fatal in <TROOT::InitSystem>: HOME directory not set\n"");; 1998 fprintf(stderr, ""Fix this by defining the HOME shell variable\n"");; 1999 }; 2000 ; 2001 // read default files; 2002 gEnv = new TEnv("".rootrc"");; 2003 ; 2004 ROOT::Internal::SetErrorSystemMsgHandler([](){ return gSystem->GetError(); });; 2005 SetErrorHandler(DefaultErrorHandler);; 2006 ; 2007 gDebug = gEnv->GetValue(""Root.Debug"", 0);; 2008 ; 2009 if (!gEnv->GetValue(""Root.ErrorHandlers"", 1)); 2010 gSystem->ResetSignals();; 2011 ; 2012 // The old ""Root.ZipMode"" had a discrepancy between documentation vs actual meaning.; 2013 // Also, a value with the meaning ""default"" wasn't available. To solved this,; 2014 // ""Root.ZipMode"" was replaced by ""Root.CompressionAlgorithm"". Warn about usage of; 2015 // the old value, if it's set to 0, but silently translate the setting to; 2016 // ""Root.CompressionAlgorithm"" for values > 1.; 2017 Int_t oldzipmode = gEnv->GetValue(""Root.ZipMode"", -1);; 2018 if (oldzipmode == 0) {; 2019 fprintf(stderr, ""Warning in <TROOT::InitSystem>: ignoring old rootrc entry \""Root.ZipMode = 0\""!\n"");; 2020 } else {; 2021 if (oldzipmode == -1 || oldzipmode == 1) {; 2022 // Not set or default value, use ""default"" for ""Root.CompressionAlgorithm"":; 2023 oldzipmode = 0;; 2024 }; 2025 // else keep the old zipmode (e.g. ""3"") as ""Root.CompressionAlgorithm""; 2026 // if ""Root.CompressionAlgorithm"" isn't set; see below.; 2027 }; 2028 ; 2029 Int_t zipmode = gEnv->GetValue(""Root.CompressionAlgorithm"", oldzipmode);; 2030 if (zipmode != 0) R__SetZipMode(zipmode);; 2031 ; 2032 const char *sdeb;; 2033 if ((sdeb = gSystem->Getenv(""ROOTDE",MatchSource.WIKI,doc/v632/TROOT_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/TROOT_8cxx_source.html
https://root.cern/doc/v632/TROOT_8cxx_source.html:79369,Availability,avail,available,79369,"lete a dummy TUrl so that TObjectStat table does not contain; 2041 // objects that are deleted after recording is turned-off (in next line),; 2042 // like the TUrl::fgSpecialProtocols list entries which are created in the; 2043 // TMacOSXSystem ctor.; 2044 { TUrl dummy(""/dummy""); }; 2045#endif; 2046 TObject::SetObjectStat(gEnv->GetValue(""Root.ObjectStat"", 0));; 2047 }; 2048}; 2049 ; 2050////////////////////////////////////////////////////////////////////////////////; 2051/// Load and initialize thread library.; 2052 ; 2053void TROOT::InitThreads(); 2054{; 2055 if (gEnv->GetValue(""Root.UseThreads"", 0) || gEnv->GetValue(""Root.EnableThreadSafety"", 0)) {; 2056 ROOT::EnableThreadSafety();; 2057 }; 2058}; 2059 ; 2060////////////////////////////////////////////////////////////////////////////////; 2061/// Initialize the interpreter. Should be called only after main(),; 2062/// to make sure LLVM/Clang is fully initialized.; 2063 ; 2064void TROOT::InitInterpreter(); 2065{; 2066 // usedToIdentifyRootClingByDlSym is available when TROOT is part of; 2067 // rootcling.; 2068 if (!dlsym(RTLD_DEFAULT, ""usedToIdentifyRootClingByDlSym""); 2069 && !dlsym(RTLD_DEFAULT, ""usedToIdentifyStaticRoot"")) {; 2070 char *libRIO = gSystem->DynamicPathName(""libRIO"");; 2071 void *libRIOHandle = dlopen(libRIO, RTLD_NOW|RTLD_GLOBAL);; 2072 delete [] libRIO;; 2073 if (!libRIOHandle) {; 2074 TString err = dlerror();; 2075 fprintf(stderr, ""Fatal in <TROOT::InitInterpreter>: cannot load library %s\n"", err.Data());; 2076 exit(1);; 2077 }; 2078 ; 2079 char *libcling = gSystem->DynamicPathName(""libCling"");; 2080 gInterpreterLib = dlopen(libcling, RTLD_LAZY|RTLD_LOCAL);; 2081 delete [] libcling;; 2082 ; 2083 if (!gInterpreterLib) {; 2084 TString err = dlerror();; 2085 fprintf(stderr, ""Fatal in <TROOT::InitInterpreter>: cannot load library %s\n"", err.Data());; 2086 exit(1);; 2087 }; 2088 dlerror(); // reset error message; 2089 } else {; 2090 gInterpreterLib = RTLD_DEFAULT;; 2091 }; 2092 CreateInterpreter_t *C",MatchSource.WIKI,doc/v632/TROOT_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/TROOT_8cxx_source.html
https://root.cern/doc/v632/TROOT_8cxx_source.html:80245,Availability,error,error,80245,"OOT is part of; 2067 // rootcling.; 2068 if (!dlsym(RTLD_DEFAULT, ""usedToIdentifyRootClingByDlSym""); 2069 && !dlsym(RTLD_DEFAULT, ""usedToIdentifyStaticRoot"")) {; 2070 char *libRIO = gSystem->DynamicPathName(""libRIO"");; 2071 void *libRIOHandle = dlopen(libRIO, RTLD_NOW|RTLD_GLOBAL);; 2072 delete [] libRIO;; 2073 if (!libRIOHandle) {; 2074 TString err = dlerror();; 2075 fprintf(stderr, ""Fatal in <TROOT::InitInterpreter>: cannot load library %s\n"", err.Data());; 2076 exit(1);; 2077 }; 2078 ; 2079 char *libcling = gSystem->DynamicPathName(""libCling"");; 2080 gInterpreterLib = dlopen(libcling, RTLD_LAZY|RTLD_LOCAL);; 2081 delete [] libcling;; 2082 ; 2083 if (!gInterpreterLib) {; 2084 TString err = dlerror();; 2085 fprintf(stderr, ""Fatal in <TROOT::InitInterpreter>: cannot load library %s\n"", err.Data());; 2086 exit(1);; 2087 }; 2088 dlerror(); // reset error message; 2089 } else {; 2090 gInterpreterLib = RTLD_DEFAULT;; 2091 }; 2092 CreateInterpreter_t *CreateInterpreter = (CreateInterpreter_t*) dlsym(gInterpreterLib, ""CreateInterpreter"");; 2093 if (!CreateInterpreter) {; 2094 TString err = dlerror();; 2095 fprintf(stderr, ""Fatal in <TROOT::InitInterpreter>: cannot load symbol %s\n"", err.Data());; 2096 exit(1);; 2097 }; 2098 // Schedule the destruction of TROOT.; 2099 atexit(at_exit_of_TROOT);; 2100 ; 2101 gDestroyInterpreter = (DestroyInterpreter_t*) dlsym(gInterpreterLib, ""DestroyInterpreter"");; 2102 if (!gDestroyInterpreter) {; 2103 TString err = dlerror();; 2104 fprintf(stderr, ""Fatal in <TROOT::InitInterpreter>: cannot load symbol %s\n"", err.Data());; 2105 exit(1);; 2106 }; 2107 ; 2108 const char *interpArgs[] = {; 2109#ifdef NDEBUG; 2110 ""-DNDEBUG"",; 2111#else; 2112 ""-UNDEBUG"",; 2113#endif; 2114#ifdef DEBUG; 2115 ""-DDEBUG"",; 2116#else; 2117 ""-UDEBUG"",; 2118#endif; 2119#ifdef _DEBUG; 2120 ""-D_DEBUG"",; 2121#else; 2122 ""-U_DEBUG"",; 2123#endif; 2124 nullptr};; 2125 ; 2126 fInterpreter = CreateInterpreter(gInterpreterLib, interpArgs);; 2127 ; 2128 fCleanups->Add(fInterpret",MatchSource.WIKI,doc/v632/TROOT_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/TROOT_8cxx_source.html
https://root.cern/doc/v632/TROOT_8cxx_source.html:83601,Availability,error,error,83601,"ng dictionary for the class.; 2163/// (typically used for class that are used only for transient members); 2164///; 2165/// The 'requestedname' is expected to be already normalized.; 2166 ; 2167TClass *TROOT::LoadClass(const char *requestedname, Bool_t silent) const; 2168{; 2169 return TClass::LoadClass(requestedname, silent);; 2170}; 2171 ; 2172////////////////////////////////////////////////////////////////////////////////; 2173/// Check if class ""classname"" is known to the interpreter (in fact,; 2174/// this check is not needed anymore, so classname is ignored). If; 2175/// not it will load library ""libname"". If the library couldn't be found with original; 2176/// libname and if the name was not prefixed with lib, try to prefix with ""lib"" and search again.; 2177/// If DynamicPathName still couldn't find the library, return -1.; 2178/// If check is true it will only check if libname exists and is; 2179/// readable.; 2180/// Returns 0 on successful loading, -1 in case libname does not; 2181/// exist or in case of error and -2 in case of version mismatch.; 2182 ; 2183Int_t TROOT::LoadClass(const char * /*classname*/, const char *libname,; 2184 Bool_t check); 2185{; 2186 TString lib(libname);; 2187 ; 2188 // Check if libname exists in path or not; 2189 if (char *path = gSystem->DynamicPathName(lib, kTRUE)) {; 2190 // If check == true, only check if it exists and if it's readable; 2191 if (check) {; 2192 delete [] path;; 2193 return 0;; 2194 }; 2195 ; 2196 // If check == false, try to load the library; 2197 else {; 2198 int err = gSystem->Load(path, nullptr, kTRUE);; 2199 delete [] path;; 2200 ; 2201 // TSystem::Load returns 1 when the library was already loaded, return success in this case.; 2202 if (err == 1); 2203 err = 0;; 2204 return err;; 2205 }; 2206 } else {; 2207 // This is the branch where libname didn't exist; 2208 if (check) {; 2209 FileStat_t stat;; 2210 if (!gSystem->GetPathInfo(libname, stat) && (R_ISREG(stat.fMode) &&; 2211 !gSystem->AccessPathName(libn",MatchSource.WIKI,doc/v632/TROOT_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/TROOT_8cxx_source.html
https://root.cern/doc/v632/TROOT_8cxx_source.html:86384,Availability,error,error,86384,"trncmp(header,""root"",4)==0;; 2238 }; 2239 fclose(mayberootfile);; 2240 }; 2241 return result;; 2242}; 2243 ; 2244////////////////////////////////////////////////////////////////////////////////; 2245/// To list all objects of the application.; 2246/// Loop on all objects created in the ROOT linked lists.; 2247/// Objects may be files and windows or any other object directly; 2248/// attached to the ROOT linked list.; 2249 ; 2250void TROOT::ls(Option_t *option) const; 2251{; 2252// TObject::SetDirLevel();; 2253// GetList()->R__FOR_EACH(TObject,ls)(option);; 2254 TDirectory::ls(option);; 2255}; 2256 ; 2257////////////////////////////////////////////////////////////////////////////////; 2258/// Load a macro in the interpreter's memory. Equivalent to the command line; 2259/// command "".L filename"". If the filename has ""+"" or ""++"" appended; 2260/// the macro will be compiled by ACLiC. The filename must have the format:; 2261/// [path/]macro.C[+|++[g|O]].; 2262/// The possible error codes are defined by TInterpreter::EErrorCode.; 2263/// If check is true it will only check if filename exists and is; 2264/// readable.; 2265/// Returns 0 on successful loading and -1 in case filename does not; 2266/// exist or in case of error.; 2267 ; 2268Int_t TROOT::LoadMacro(const char *filename, int *error, Bool_t check); 2269{; 2270 Int_t err = -1;; 2271 Int_t lerr, *terr;; 2272 if (error); 2273 terr = error;; 2274 else; 2275 terr = &lerr;; 2276 ; 2277 if (fInterpreter) {; 2278 TString aclicMode;; 2279 TString arguments;; 2280 TString io;; 2281 TString fname = gSystem->SplitAclicMode(filename, aclicMode, arguments, io);; 2282 ; 2283 if (arguments.Length()) {; 2284 Warning(""LoadMacro"", ""argument(%s) ignored in %s"", arguments.Data(), GetMacroPath());; 2285 }; 2286 char *mac = gSystem->Which(GetMacroPath(), fname, kReadPermission);; 2287 if (!mac) {; 2288 if (!check); 2289 Error(""LoadMacro"", ""macro %s not found in path %s"", fname.Data(), GetMacroPath());; 2290 *terr = TInterpreter::kFatal;",MatchSource.WIKI,doc/v632/TROOT_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/TROOT_8cxx_source.html
https://root.cern/doc/v632/TROOT_8cxx_source.html:86630,Availability,error,error,86630,"//////////; 2245/// To list all objects of the application.; 2246/// Loop on all objects created in the ROOT linked lists.; 2247/// Objects may be files and windows or any other object directly; 2248/// attached to the ROOT linked list.; 2249 ; 2250void TROOT::ls(Option_t *option) const; 2251{; 2252// TObject::SetDirLevel();; 2253// GetList()->R__FOR_EACH(TObject,ls)(option);; 2254 TDirectory::ls(option);; 2255}; 2256 ; 2257////////////////////////////////////////////////////////////////////////////////; 2258/// Load a macro in the interpreter's memory. Equivalent to the command line; 2259/// command "".L filename"". If the filename has ""+"" or ""++"" appended; 2260/// the macro will be compiled by ACLiC. The filename must have the format:; 2261/// [path/]macro.C[+|++[g|O]].; 2262/// The possible error codes are defined by TInterpreter::EErrorCode.; 2263/// If check is true it will only check if filename exists and is; 2264/// readable.; 2265/// Returns 0 on successful loading and -1 in case filename does not; 2266/// exist or in case of error.; 2267 ; 2268Int_t TROOT::LoadMacro(const char *filename, int *error, Bool_t check); 2269{; 2270 Int_t err = -1;; 2271 Int_t lerr, *terr;; 2272 if (error); 2273 terr = error;; 2274 else; 2275 terr = &lerr;; 2276 ; 2277 if (fInterpreter) {; 2278 TString aclicMode;; 2279 TString arguments;; 2280 TString io;; 2281 TString fname = gSystem->SplitAclicMode(filename, aclicMode, arguments, io);; 2282 ; 2283 if (arguments.Length()) {; 2284 Warning(""LoadMacro"", ""argument(%s) ignored in %s"", arguments.Data(), GetMacroPath());; 2285 }; 2286 char *mac = gSystem->Which(GetMacroPath(), fname, kReadPermission);; 2287 if (!mac) {; 2288 if (!check); 2289 Error(""LoadMacro"", ""macro %s not found in path %s"", fname.Data(), GetMacroPath());; 2290 *terr = TInterpreter::kFatal;; 2291 } else {; 2292 err = 0;; 2293 if (!check) {; 2294 fname = mac;; 2295 fname += aclicMode;; 2296 fname += io;; 2297 gInterpreter->LoadMacro(fname.Data(), (TInterpreter::EErrorCo",MatchSource.WIKI,doc/v632/TROOT_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/TROOT_8cxx_source.html
https://root.cern/doc/v632/TROOT_8cxx_source.html:86699,Availability,error,error,86699,"(Option_t *option) const; 2251{; 2252// TObject::SetDirLevel();; 2253// GetList()->R__FOR_EACH(TObject,ls)(option);; 2254 TDirectory::ls(option);; 2255}; 2256 ; 2257////////////////////////////////////////////////////////////////////////////////; 2258/// Load a macro in the interpreter's memory. Equivalent to the command line; 2259/// command "".L filename"". If the filename has ""+"" or ""++"" appended; 2260/// the macro will be compiled by ACLiC. The filename must have the format:; 2261/// [path/]macro.C[+|++[g|O]].; 2262/// The possible error codes are defined by TInterpreter::EErrorCode.; 2263/// If check is true it will only check if filename exists and is; 2264/// readable.; 2265/// Returns 0 on successful loading and -1 in case filename does not; 2266/// exist or in case of error.; 2267 ; 2268Int_t TROOT::LoadMacro(const char *filename, int *error, Bool_t check); 2269{; 2270 Int_t err = -1;; 2271 Int_t lerr, *terr;; 2272 if (error); 2273 terr = error;; 2274 else; 2275 terr = &lerr;; 2276 ; 2277 if (fInterpreter) {; 2278 TString aclicMode;; 2279 TString arguments;; 2280 TString io;; 2281 TString fname = gSystem->SplitAclicMode(filename, aclicMode, arguments, io);; 2282 ; 2283 if (arguments.Length()) {; 2284 Warning(""LoadMacro"", ""argument(%s) ignored in %s"", arguments.Data(), GetMacroPath());; 2285 }; 2286 char *mac = gSystem->Which(GetMacroPath(), fname, kReadPermission);; 2287 if (!mac) {; 2288 if (!check); 2289 Error(""LoadMacro"", ""macro %s not found in path %s"", fname.Data(), GetMacroPath());; 2290 *terr = TInterpreter::kFatal;; 2291 } else {; 2292 err = 0;; 2293 if (!check) {; 2294 fname = mac;; 2295 fname += aclicMode;; 2296 fname += io;; 2297 gInterpreter->LoadMacro(fname.Data(), (TInterpreter::EErrorCode*)terr);; 2298 if (*terr); 2299 err = -1;; 2300 }; 2301 }; 2302 delete [] mac;; 2303 }; 2304 return err;; 2305}; 2306 ; 2307////////////////////////////////////////////////////////////////////////////////; 2308/// Execute a macro in the interpreter. Equivalent t",MatchSource.WIKI,doc/v632/TROOT_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/TROOT_8cxx_source.html
https://root.cern/doc/v632/TROOT_8cxx_source.html:86784,Availability,error,error,86784,"(Option_t *option) const; 2251{; 2252// TObject::SetDirLevel();; 2253// GetList()->R__FOR_EACH(TObject,ls)(option);; 2254 TDirectory::ls(option);; 2255}; 2256 ; 2257////////////////////////////////////////////////////////////////////////////////; 2258/// Load a macro in the interpreter's memory. Equivalent to the command line; 2259/// command "".L filename"". If the filename has ""+"" or ""++"" appended; 2260/// the macro will be compiled by ACLiC. The filename must have the format:; 2261/// [path/]macro.C[+|++[g|O]].; 2262/// The possible error codes are defined by TInterpreter::EErrorCode.; 2263/// If check is true it will only check if filename exists and is; 2264/// readable.; 2265/// Returns 0 on successful loading and -1 in case filename does not; 2266/// exist or in case of error.; 2267 ; 2268Int_t TROOT::LoadMacro(const char *filename, int *error, Bool_t check); 2269{; 2270 Int_t err = -1;; 2271 Int_t lerr, *terr;; 2272 if (error); 2273 terr = error;; 2274 else; 2275 terr = &lerr;; 2276 ; 2277 if (fInterpreter) {; 2278 TString aclicMode;; 2279 TString arguments;; 2280 TString io;; 2281 TString fname = gSystem->SplitAclicMode(filename, aclicMode, arguments, io);; 2282 ; 2283 if (arguments.Length()) {; 2284 Warning(""LoadMacro"", ""argument(%s) ignored in %s"", arguments.Data(), GetMacroPath());; 2285 }; 2286 char *mac = gSystem->Which(GetMacroPath(), fname, kReadPermission);; 2287 if (!mac) {; 2288 if (!check); 2289 Error(""LoadMacro"", ""macro %s not found in path %s"", fname.Data(), GetMacroPath());; 2290 *terr = TInterpreter::kFatal;; 2291 } else {; 2292 err = 0;; 2293 if (!check) {; 2294 fname = mac;; 2295 fname += aclicMode;; 2296 fname += io;; 2297 gInterpreter->LoadMacro(fname.Data(), (TInterpreter::EErrorCode*)terr);; 2298 if (*terr); 2299 err = -1;; 2300 }; 2301 }; 2302 delete [] mac;; 2303 }; 2304 return err;; 2305}; 2306 ; 2307////////////////////////////////////////////////////////////////////////////////; 2308/// Execute a macro in the interpreter. Equivalent t",MatchSource.WIKI,doc/v632/TROOT_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/TROOT_8cxx_source.html
https://root.cern/doc/v632/TROOT_8cxx_source.html:86804,Availability,error,error,86804,"(Option_t *option) const; 2251{; 2252// TObject::SetDirLevel();; 2253// GetList()->R__FOR_EACH(TObject,ls)(option);; 2254 TDirectory::ls(option);; 2255}; 2256 ; 2257////////////////////////////////////////////////////////////////////////////////; 2258/// Load a macro in the interpreter's memory. Equivalent to the command line; 2259/// command "".L filename"". If the filename has ""+"" or ""++"" appended; 2260/// the macro will be compiled by ACLiC. The filename must have the format:; 2261/// [path/]macro.C[+|++[g|O]].; 2262/// The possible error codes are defined by TInterpreter::EErrorCode.; 2263/// If check is true it will only check if filename exists and is; 2264/// readable.; 2265/// Returns 0 on successful loading and -1 in case filename does not; 2266/// exist or in case of error.; 2267 ; 2268Int_t TROOT::LoadMacro(const char *filename, int *error, Bool_t check); 2269{; 2270 Int_t err = -1;; 2271 Int_t lerr, *terr;; 2272 if (error); 2273 terr = error;; 2274 else; 2275 terr = &lerr;; 2276 ; 2277 if (fInterpreter) {; 2278 TString aclicMode;; 2279 TString arguments;; 2280 TString io;; 2281 TString fname = gSystem->SplitAclicMode(filename, aclicMode, arguments, io);; 2282 ; 2283 if (arguments.Length()) {; 2284 Warning(""LoadMacro"", ""argument(%s) ignored in %s"", arguments.Data(), GetMacroPath());; 2285 }; 2286 char *mac = gSystem->Which(GetMacroPath(), fname, kReadPermission);; 2287 if (!mac) {; 2288 if (!check); 2289 Error(""LoadMacro"", ""macro %s not found in path %s"", fname.Data(), GetMacroPath());; 2290 *terr = TInterpreter::kFatal;; 2291 } else {; 2292 err = 0;; 2293 if (!check) {; 2294 fname = mac;; 2295 fname += aclicMode;; 2296 fname += io;; 2297 gInterpreter->LoadMacro(fname.Data(), (TInterpreter::EErrorCode*)terr);; 2298 if (*terr); 2299 err = -1;; 2300 }; 2301 }; 2302 delete [] mac;; 2303 }; 2304 return err;; 2305}; 2306 ; 2307////////////////////////////////////////////////////////////////////////////////; 2308/// Execute a macro in the interpreter. Equivalent t",MatchSource.WIKI,doc/v632/TROOT_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/TROOT_8cxx_source.html
https://root.cern/doc/v632/TROOT_8cxx_source.html:88084,Availability,error,error,88084,"ent(%s) ignored in %s"", arguments.Data(), GetMacroPath());; 2285 }; 2286 char *mac = gSystem->Which(GetMacroPath(), fname, kReadPermission);; 2287 if (!mac) {; 2288 if (!check); 2289 Error(""LoadMacro"", ""macro %s not found in path %s"", fname.Data(), GetMacroPath());; 2290 *terr = TInterpreter::kFatal;; 2291 } else {; 2292 err = 0;; 2293 if (!check) {; 2294 fname = mac;; 2295 fname += aclicMode;; 2296 fname += io;; 2297 gInterpreter->LoadMacro(fname.Data(), (TInterpreter::EErrorCode*)terr);; 2298 if (*terr); 2299 err = -1;; 2300 }; 2301 }; 2302 delete [] mac;; 2303 }; 2304 return err;; 2305}; 2306 ; 2307////////////////////////////////////////////////////////////////////////////////; 2308/// Execute a macro in the interpreter. Equivalent to the command line; 2309/// command "".x filename"". If the filename has ""+"" or ""++"" appended; 2310/// the macro will be compiled by ACLiC. The filename must have the format:; 2311/// [path/]macro.C[+|++[g|O]][(args)].; 2312/// The possible error codes are defined by TInterpreter::EErrorCode.; 2313/// If padUpdate is true (default) update the current pad.; 2314/// Returns the macro return value.; 2315 ; 2316Longptr_t TROOT::Macro(const char *filename, Int_t *error, Bool_t padUpdate); 2317{; 2318 Longptr_t result = 0;; 2319 ; 2320 if (fInterpreter) {; 2321 TString aclicMode;; 2322 TString arguments;; 2323 TString io;; 2324 TString fname = gSystem->SplitAclicMode(filename, aclicMode, arguments, io);; 2325 ; 2326 char *mac = gSystem->Which(GetMacroPath(), fname, kReadPermission);; 2327 if (!mac) {; 2328 Error(""Macro"", ""macro %s not found in path %s"", fname.Data(), GetMacroPath());; 2329 if (error); 2330 *error = TInterpreter::kFatal;; 2331 } else {; 2332 fname = mac;; 2333 fname += aclicMode;; 2334 fname += arguments;; 2335 fname += io;; 2336 result = gInterpreter->ExecuteMacro(fname, (TInterpreter::EErrorCode*)error);; 2337 }; 2338 delete [] mac;; 2339 ; 2340 if (padUpdate && gPad); 2341 gPad->Update();; 2342 }; 2343 ; 2344 return result;",MatchSource.WIKI,doc/v632/TROOT_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/TROOT_8cxx_source.html
https://root.cern/doc/v632/TROOT_8cxx_source.html:88306,Availability,error,error,88306,"fname += aclicMode;; 2296 fname += io;; 2297 gInterpreter->LoadMacro(fname.Data(), (TInterpreter::EErrorCode*)terr);; 2298 if (*terr); 2299 err = -1;; 2300 }; 2301 }; 2302 delete [] mac;; 2303 }; 2304 return err;; 2305}; 2306 ; 2307////////////////////////////////////////////////////////////////////////////////; 2308/// Execute a macro in the interpreter. Equivalent to the command line; 2309/// command "".x filename"". If the filename has ""+"" or ""++"" appended; 2310/// the macro will be compiled by ACLiC. The filename must have the format:; 2311/// [path/]macro.C[+|++[g|O]][(args)].; 2312/// The possible error codes are defined by TInterpreter::EErrorCode.; 2313/// If padUpdate is true (default) update the current pad.; 2314/// Returns the macro return value.; 2315 ; 2316Longptr_t TROOT::Macro(const char *filename, Int_t *error, Bool_t padUpdate); 2317{; 2318 Longptr_t result = 0;; 2319 ; 2320 if (fInterpreter) {; 2321 TString aclicMode;; 2322 TString arguments;; 2323 TString io;; 2324 TString fname = gSystem->SplitAclicMode(filename, aclicMode, arguments, io);; 2325 ; 2326 char *mac = gSystem->Which(GetMacroPath(), fname, kReadPermission);; 2327 if (!mac) {; 2328 Error(""Macro"", ""macro %s not found in path %s"", fname.Data(), GetMacroPath());; 2329 if (error); 2330 *error = TInterpreter::kFatal;; 2331 } else {; 2332 fname = mac;; 2333 fname += aclicMode;; 2334 fname += arguments;; 2335 fname += io;; 2336 result = gInterpreter->ExecuteMacro(fname, (TInterpreter::EErrorCode*)error);; 2337 }; 2338 delete [] mac;; 2339 ; 2340 if (padUpdate && gPad); 2341 gPad->Update();; 2342 }; 2343 ; 2344 return result;; 2345}; 2346 ; 2347////////////////////////////////////////////////////////////////////////////////; 2348/// Process message id called by obj.; 2349 ; 2350void TROOT::Message(Int_t id, const TObject *obj); 2351{; 2352 TIter next(fMessageHandlers);; 2353 TMessageHandler *mh;; 2354 while ((mh = (TMessageHandler*)next())) {; 2355 mh->HandleMessage(id,obj);; 2356 }; 2357}; 235",MatchSource.WIKI,doc/v632/TROOT_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/TROOT_8cxx_source.html
https://root.cern/doc/v632/TROOT_8cxx_source.html:88744,Availability,error,error,88744," ACLiC. The filename must have the format:; 2311/// [path/]macro.C[+|++[g|O]][(args)].; 2312/// The possible error codes are defined by TInterpreter::EErrorCode.; 2313/// If padUpdate is true (default) update the current pad.; 2314/// Returns the macro return value.; 2315 ; 2316Longptr_t TROOT::Macro(const char *filename, Int_t *error, Bool_t padUpdate); 2317{; 2318 Longptr_t result = 0;; 2319 ; 2320 if (fInterpreter) {; 2321 TString aclicMode;; 2322 TString arguments;; 2323 TString io;; 2324 TString fname = gSystem->SplitAclicMode(filename, aclicMode, arguments, io);; 2325 ; 2326 char *mac = gSystem->Which(GetMacroPath(), fname, kReadPermission);; 2327 if (!mac) {; 2328 Error(""Macro"", ""macro %s not found in path %s"", fname.Data(), GetMacroPath());; 2329 if (error); 2330 *error = TInterpreter::kFatal;; 2331 } else {; 2332 fname = mac;; 2333 fname += aclicMode;; 2334 fname += arguments;; 2335 fname += io;; 2336 result = gInterpreter->ExecuteMacro(fname, (TInterpreter::EErrorCode*)error);; 2337 }; 2338 delete [] mac;; 2339 ; 2340 if (padUpdate && gPad); 2341 gPad->Update();; 2342 }; 2343 ; 2344 return result;; 2345}; 2346 ; 2347////////////////////////////////////////////////////////////////////////////////; 2348/// Process message id called by obj.; 2349 ; 2350void TROOT::Message(Int_t id, const TObject *obj); 2351{; 2352 TIter next(fMessageHandlers);; 2353 TMessageHandler *mh;; 2354 while ((mh = (TMessageHandler*)next())) {; 2355 mh->HandleMessage(id,obj);; 2356 }; 2357}; 2358 ; 2359////////////////////////////////////////////////////////////////////////////////; 2360/// Process interpreter command via TApplication::ProcessLine().; 2361/// On Win32 the line will be processed asynchronously by sending; 2362/// it to the CINT interpreter thread. For explicit synchronous processing; 2363/// use ProcessLineSync(). On non-Win32 platforms there is no difference; 2364/// between ProcessLine() and ProcessLineSync().; 2365/// The possible error codes are defined by TInterpret",MatchSource.WIKI,doc/v632/TROOT_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/TROOT_8cxx_source.html
https://root.cern/doc/v632/TROOT_8cxx_source.html:88758,Availability,error,error,88758," ACLiC. The filename must have the format:; 2311/// [path/]macro.C[+|++[g|O]][(args)].; 2312/// The possible error codes are defined by TInterpreter::EErrorCode.; 2313/// If padUpdate is true (default) update the current pad.; 2314/// Returns the macro return value.; 2315 ; 2316Longptr_t TROOT::Macro(const char *filename, Int_t *error, Bool_t padUpdate); 2317{; 2318 Longptr_t result = 0;; 2319 ; 2320 if (fInterpreter) {; 2321 TString aclicMode;; 2322 TString arguments;; 2323 TString io;; 2324 TString fname = gSystem->SplitAclicMode(filename, aclicMode, arguments, io);; 2325 ; 2326 char *mac = gSystem->Which(GetMacroPath(), fname, kReadPermission);; 2327 if (!mac) {; 2328 Error(""Macro"", ""macro %s not found in path %s"", fname.Data(), GetMacroPath());; 2329 if (error); 2330 *error = TInterpreter::kFatal;; 2331 } else {; 2332 fname = mac;; 2333 fname += aclicMode;; 2334 fname += arguments;; 2335 fname += io;; 2336 result = gInterpreter->ExecuteMacro(fname, (TInterpreter::EErrorCode*)error);; 2337 }; 2338 delete [] mac;; 2339 ; 2340 if (padUpdate && gPad); 2341 gPad->Update();; 2342 }; 2343 ; 2344 return result;; 2345}; 2346 ; 2347////////////////////////////////////////////////////////////////////////////////; 2348/// Process message id called by obj.; 2349 ; 2350void TROOT::Message(Int_t id, const TObject *obj); 2351{; 2352 TIter next(fMessageHandlers);; 2353 TMessageHandler *mh;; 2354 while ((mh = (TMessageHandler*)next())) {; 2355 mh->HandleMessage(id,obj);; 2356 }; 2357}; 2358 ; 2359////////////////////////////////////////////////////////////////////////////////; 2360/// Process interpreter command via TApplication::ProcessLine().; 2361/// On Win32 the line will be processed asynchronously by sending; 2362/// it to the CINT interpreter thread. For explicit synchronous processing; 2363/// use ProcessLineSync(). On non-Win32 platforms there is no difference; 2364/// between ProcessLine() and ProcessLineSync().; 2365/// The possible error codes are defined by TInterpret",MatchSource.WIKI,doc/v632/TROOT_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/TROOT_8cxx_source.html
https://root.cern/doc/v632/TROOT_8cxx_source.html:88969,Availability,error,error,88969," ACLiC. The filename must have the format:; 2311/// [path/]macro.C[+|++[g|O]][(args)].; 2312/// The possible error codes are defined by TInterpreter::EErrorCode.; 2313/// If padUpdate is true (default) update the current pad.; 2314/// Returns the macro return value.; 2315 ; 2316Longptr_t TROOT::Macro(const char *filename, Int_t *error, Bool_t padUpdate); 2317{; 2318 Longptr_t result = 0;; 2319 ; 2320 if (fInterpreter) {; 2321 TString aclicMode;; 2322 TString arguments;; 2323 TString io;; 2324 TString fname = gSystem->SplitAclicMode(filename, aclicMode, arguments, io);; 2325 ; 2326 char *mac = gSystem->Which(GetMacroPath(), fname, kReadPermission);; 2327 if (!mac) {; 2328 Error(""Macro"", ""macro %s not found in path %s"", fname.Data(), GetMacroPath());; 2329 if (error); 2330 *error = TInterpreter::kFatal;; 2331 } else {; 2332 fname = mac;; 2333 fname += aclicMode;; 2334 fname += arguments;; 2335 fname += io;; 2336 result = gInterpreter->ExecuteMacro(fname, (TInterpreter::EErrorCode*)error);; 2337 }; 2338 delete [] mac;; 2339 ; 2340 if (padUpdate && gPad); 2341 gPad->Update();; 2342 }; 2343 ; 2344 return result;; 2345}; 2346 ; 2347////////////////////////////////////////////////////////////////////////////////; 2348/// Process message id called by obj.; 2349 ; 2350void TROOT::Message(Int_t id, const TObject *obj); 2351{; 2352 TIter next(fMessageHandlers);; 2353 TMessageHandler *mh;; 2354 while ((mh = (TMessageHandler*)next())) {; 2355 mh->HandleMessage(id,obj);; 2356 }; 2357}; 2358 ; 2359////////////////////////////////////////////////////////////////////////////////; 2360/// Process interpreter command via TApplication::ProcessLine().; 2361/// On Win32 the line will be processed asynchronously by sending; 2362/// it to the CINT interpreter thread. For explicit synchronous processing; 2363/// use ProcessLineSync(). On non-Win32 platforms there is no difference; 2364/// between ProcessLine() and ProcessLineSync().; 2365/// The possible error codes are defined by TInterpret",MatchSource.WIKI,doc/v632/TROOT_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/TROOT_8cxx_source.html
https://root.cern/doc/v632/TROOT_8cxx_source.html:89939,Availability,error,error,89939,"er::EErrorCode*)error);; 2337 }; 2338 delete [] mac;; 2339 ; 2340 if (padUpdate && gPad); 2341 gPad->Update();; 2342 }; 2343 ; 2344 return result;; 2345}; 2346 ; 2347////////////////////////////////////////////////////////////////////////////////; 2348/// Process message id called by obj.; 2349 ; 2350void TROOT::Message(Int_t id, const TObject *obj); 2351{; 2352 TIter next(fMessageHandlers);; 2353 TMessageHandler *mh;; 2354 while ((mh = (TMessageHandler*)next())) {; 2355 mh->HandleMessage(id,obj);; 2356 }; 2357}; 2358 ; 2359////////////////////////////////////////////////////////////////////////////////; 2360/// Process interpreter command via TApplication::ProcessLine().; 2361/// On Win32 the line will be processed asynchronously by sending; 2362/// it to the CINT interpreter thread. For explicit synchronous processing; 2363/// use ProcessLineSync(). On non-Win32 platforms there is no difference; 2364/// between ProcessLine() and ProcessLineSync().; 2365/// The possible error codes are defined by TInterpreter::EErrorCode. In; 2366/// particular, error will equal to TInterpreter::kProcessing until the; 2367/// CINT interpreted thread has finished executing the line.; 2368/// Returns the result of the command, cast to a Longptr_t.; 2369 ; 2370Longptr_t TROOT::ProcessLine(const char *line, Int_t *error); 2371{; 2372 TString sline = line;; 2373 sline = sline.Strip(TString::kBoth);; 2374 ; 2375 if (!fApplication.load()); 2376 TApplication::CreateApplication();; 2377 ; 2378 return (*fApplication).ProcessLine(sline, kFALSE, error);; 2379}; 2380 ; 2381////////////////////////////////////////////////////////////////////////////////; 2382/// Process interpreter command via TApplication::ProcessLine().; 2383/// On Win32 the line will be processed synchronously (i.e. it will; 2384/// only return when the CINT interpreter thread has finished executing; 2385/// the line). On non-Win32 platforms there is no difference between; 2386/// ProcessLine() and ProcessLineSync().; 2387/// ",MatchSource.WIKI,doc/v632/TROOT_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/TROOT_8cxx_source.html
https://root.cern/doc/v632/TROOT_8cxx_source.html:90016,Availability,error,error,90016," 2342 }; 2343 ; 2344 return result;; 2345}; 2346 ; 2347////////////////////////////////////////////////////////////////////////////////; 2348/// Process message id called by obj.; 2349 ; 2350void TROOT::Message(Int_t id, const TObject *obj); 2351{; 2352 TIter next(fMessageHandlers);; 2353 TMessageHandler *mh;; 2354 while ((mh = (TMessageHandler*)next())) {; 2355 mh->HandleMessage(id,obj);; 2356 }; 2357}; 2358 ; 2359////////////////////////////////////////////////////////////////////////////////; 2360/// Process interpreter command via TApplication::ProcessLine().; 2361/// On Win32 the line will be processed asynchronously by sending; 2362/// it to the CINT interpreter thread. For explicit synchronous processing; 2363/// use ProcessLineSync(). On non-Win32 platforms there is no difference; 2364/// between ProcessLine() and ProcessLineSync().; 2365/// The possible error codes are defined by TInterpreter::EErrorCode. In; 2366/// particular, error will equal to TInterpreter::kProcessing until the; 2367/// CINT interpreted thread has finished executing the line.; 2368/// Returns the result of the command, cast to a Longptr_t.; 2369 ; 2370Longptr_t TROOT::ProcessLine(const char *line, Int_t *error); 2371{; 2372 TString sline = line;; 2373 sline = sline.Strip(TString::kBoth);; 2374 ; 2375 if (!fApplication.load()); 2376 TApplication::CreateApplication();; 2377 ; 2378 return (*fApplication).ProcessLine(sline, kFALSE, error);; 2379}; 2380 ; 2381////////////////////////////////////////////////////////////////////////////////; 2382/// Process interpreter command via TApplication::ProcessLine().; 2383/// On Win32 the line will be processed synchronously (i.e. it will; 2384/// only return when the CINT interpreter thread has finished executing; 2385/// the line). On non-Win32 platforms there is no difference between; 2386/// ProcessLine() and ProcessLineSync().; 2387/// The possible error codes are defined by TInterpreter::EErrorCode.; 2388/// Returns the result of the command, ",MatchSource.WIKI,doc/v632/TROOT_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/TROOT_8cxx_source.html
https://root.cern/doc/v632/TROOT_8cxx_source.html:90269,Availability,error,error,90269,":Message(Int_t id, const TObject *obj); 2351{; 2352 TIter next(fMessageHandlers);; 2353 TMessageHandler *mh;; 2354 while ((mh = (TMessageHandler*)next())) {; 2355 mh->HandleMessage(id,obj);; 2356 }; 2357}; 2358 ; 2359////////////////////////////////////////////////////////////////////////////////; 2360/// Process interpreter command via TApplication::ProcessLine().; 2361/// On Win32 the line will be processed asynchronously by sending; 2362/// it to the CINT interpreter thread. For explicit synchronous processing; 2363/// use ProcessLineSync(). On non-Win32 platforms there is no difference; 2364/// between ProcessLine() and ProcessLineSync().; 2365/// The possible error codes are defined by TInterpreter::EErrorCode. In; 2366/// particular, error will equal to TInterpreter::kProcessing until the; 2367/// CINT interpreted thread has finished executing the line.; 2368/// Returns the result of the command, cast to a Longptr_t.; 2369 ; 2370Longptr_t TROOT::ProcessLine(const char *line, Int_t *error); 2371{; 2372 TString sline = line;; 2373 sline = sline.Strip(TString::kBoth);; 2374 ; 2375 if (!fApplication.load()); 2376 TApplication::CreateApplication();; 2377 ; 2378 return (*fApplication).ProcessLine(sline, kFALSE, error);; 2379}; 2380 ; 2381////////////////////////////////////////////////////////////////////////////////; 2382/// Process interpreter command via TApplication::ProcessLine().; 2383/// On Win32 the line will be processed synchronously (i.e. it will; 2384/// only return when the CINT interpreter thread has finished executing; 2385/// the line). On non-Win32 platforms there is no difference between; 2386/// ProcessLine() and ProcessLineSync().; 2387/// The possible error codes are defined by TInterpreter::EErrorCode.; 2388/// Returns the result of the command, cast to a Longptr_t.; 2389 ; 2390Longptr_t TROOT::ProcessLineSync(const char *line, Int_t *error); 2391{; 2392 TString sline = line;; 2393 sline = sline.Strip(TString::kBoth);; 2394 ; 2395 if (!fApplicat",MatchSource.WIKI,doc/v632/TROOT_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/TROOT_8cxx_source.html
https://root.cern/doc/v632/TROOT_8cxx_source.html:90497,Availability,error,error,90497," Process interpreter command via TApplication::ProcessLine().; 2361/// On Win32 the line will be processed asynchronously by sending; 2362/// it to the CINT interpreter thread. For explicit synchronous processing; 2363/// use ProcessLineSync(). On non-Win32 platforms there is no difference; 2364/// between ProcessLine() and ProcessLineSync().; 2365/// The possible error codes are defined by TInterpreter::EErrorCode. In; 2366/// particular, error will equal to TInterpreter::kProcessing until the; 2367/// CINT interpreted thread has finished executing the line.; 2368/// Returns the result of the command, cast to a Longptr_t.; 2369 ; 2370Longptr_t TROOT::ProcessLine(const char *line, Int_t *error); 2371{; 2372 TString sline = line;; 2373 sline = sline.Strip(TString::kBoth);; 2374 ; 2375 if (!fApplication.load()); 2376 TApplication::CreateApplication();; 2377 ; 2378 return (*fApplication).ProcessLine(sline, kFALSE, error);; 2379}; 2380 ; 2381////////////////////////////////////////////////////////////////////////////////; 2382/// Process interpreter command via TApplication::ProcessLine().; 2383/// On Win32 the line will be processed synchronously (i.e. it will; 2384/// only return when the CINT interpreter thread has finished executing; 2385/// the line). On non-Win32 platforms there is no difference between; 2386/// ProcessLine() and ProcessLineSync().; 2387/// The possible error codes are defined by TInterpreter::EErrorCode.; 2388/// Returns the result of the command, cast to a Longptr_t.; 2389 ; 2390Longptr_t TROOT::ProcessLineSync(const char *line, Int_t *error); 2391{; 2392 TString sline = line;; 2393 sline = sline.Strip(TString::kBoth);; 2394 ; 2395 if (!fApplication.load()); 2396 TApplication::CreateApplication();; 2397 ; 2398 return (*fApplication).ProcessLine(sline, kTRUE, error);; 2399}; 2400 ; 2401////////////////////////////////////////////////////////////////////////////////; 2402/// Process interpreter command directly via CINT interpreter.; 2403/// Only ",MatchSource.WIKI,doc/v632/TROOT_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/TROOT_8cxx_source.html
https://root.cern/doc/v632/TROOT_8cxx_source.html:90967,Availability,error,error,90967,"ErrorCode. In; 2366/// particular, error will equal to TInterpreter::kProcessing until the; 2367/// CINT interpreted thread has finished executing the line.; 2368/// Returns the result of the command, cast to a Longptr_t.; 2369 ; 2370Longptr_t TROOT::ProcessLine(const char *line, Int_t *error); 2371{; 2372 TString sline = line;; 2373 sline = sline.Strip(TString::kBoth);; 2374 ; 2375 if (!fApplication.load()); 2376 TApplication::CreateApplication();; 2377 ; 2378 return (*fApplication).ProcessLine(sline, kFALSE, error);; 2379}; 2380 ; 2381////////////////////////////////////////////////////////////////////////////////; 2382/// Process interpreter command via TApplication::ProcessLine().; 2383/// On Win32 the line will be processed synchronously (i.e. it will; 2384/// only return when the CINT interpreter thread has finished executing; 2385/// the line). On non-Win32 platforms there is no difference between; 2386/// ProcessLine() and ProcessLineSync().; 2387/// The possible error codes are defined by TInterpreter::EErrorCode.; 2388/// Returns the result of the command, cast to a Longptr_t.; 2389 ; 2390Longptr_t TROOT::ProcessLineSync(const char *line, Int_t *error); 2391{; 2392 TString sline = line;; 2393 sline = sline.Strip(TString::kBoth);; 2394 ; 2395 if (!fApplication.load()); 2396 TApplication::CreateApplication();; 2397 ; 2398 return (*fApplication).ProcessLine(sline, kTRUE, error);; 2399}; 2400 ; 2401////////////////////////////////////////////////////////////////////////////////; 2402/// Process interpreter command directly via CINT interpreter.; 2403/// Only executable statements are allowed (no variable declarations),; 2404/// In all other cases use TROOT::ProcessLine().; 2405/// The possible error codes are defined by TInterpreter::EErrorCode.; 2406 ; 2407Longptr_t TROOT::ProcessLineFast(const char *line, Int_t *error); 2408{; 2409 TString sline = line;; 2410 sline = sline.Strip(TString::kBoth);; 2411 ; 2412 if (!fApplication.load()); 2413 TApplication::Creat",MatchSource.WIKI,doc/v632/TROOT_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/TROOT_8cxx_source.html
https://root.cern/doc/v632/TROOT_8cxx_source.html:91155,Availability,error,error,91155,"urns the result of the command, cast to a Longptr_t.; 2369 ; 2370Longptr_t TROOT::ProcessLine(const char *line, Int_t *error); 2371{; 2372 TString sline = line;; 2373 sline = sline.Strip(TString::kBoth);; 2374 ; 2375 if (!fApplication.load()); 2376 TApplication::CreateApplication();; 2377 ; 2378 return (*fApplication).ProcessLine(sline, kFALSE, error);; 2379}; 2380 ; 2381////////////////////////////////////////////////////////////////////////////////; 2382/// Process interpreter command via TApplication::ProcessLine().; 2383/// On Win32 the line will be processed synchronously (i.e. it will; 2384/// only return when the CINT interpreter thread has finished executing; 2385/// the line). On non-Win32 platforms there is no difference between; 2386/// ProcessLine() and ProcessLineSync().; 2387/// The possible error codes are defined by TInterpreter::EErrorCode.; 2388/// Returns the result of the command, cast to a Longptr_t.; 2389 ; 2390Longptr_t TROOT::ProcessLineSync(const char *line, Int_t *error); 2391{; 2392 TString sline = line;; 2393 sline = sline.Strip(TString::kBoth);; 2394 ; 2395 if (!fApplication.load()); 2396 TApplication::CreateApplication();; 2397 ; 2398 return (*fApplication).ProcessLine(sline, kTRUE, error);; 2399}; 2400 ; 2401////////////////////////////////////////////////////////////////////////////////; 2402/// Process interpreter command directly via CINT interpreter.; 2403/// Only executable statements are allowed (no variable declarations),; 2404/// In all other cases use TROOT::ProcessLine().; 2405/// The possible error codes are defined by TInterpreter::EErrorCode.; 2406 ; 2407Longptr_t TROOT::ProcessLineFast(const char *line, Int_t *error); 2408{; 2409 TString sline = line;; 2410 sline = sline.Strip(TString::kBoth);; 2411 ; 2412 if (!fApplication.load()); 2413 TApplication::CreateApplication();; 2414 ; 2415 Longptr_t result = 0;; 2416 ; 2417 if (fInterpreter) {; 2418 TInterpreter::EErrorCode *code = (TInterpreter::EErrorCode*)error;; 2419 result",MatchSource.WIKI,doc/v632/TROOT_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/TROOT_8cxx_source.html
https://root.cern/doc/v632/TROOT_8cxx_source.html:91382,Availability,error,error,91382,"fApplication).ProcessLine(sline, kFALSE, error);; 2379}; 2380 ; 2381////////////////////////////////////////////////////////////////////////////////; 2382/// Process interpreter command via TApplication::ProcessLine().; 2383/// On Win32 the line will be processed synchronously (i.e. it will; 2384/// only return when the CINT interpreter thread has finished executing; 2385/// the line). On non-Win32 platforms there is no difference between; 2386/// ProcessLine() and ProcessLineSync().; 2387/// The possible error codes are defined by TInterpreter::EErrorCode.; 2388/// Returns the result of the command, cast to a Longptr_t.; 2389 ; 2390Longptr_t TROOT::ProcessLineSync(const char *line, Int_t *error); 2391{; 2392 TString sline = line;; 2393 sline = sline.Strip(TString::kBoth);; 2394 ; 2395 if (!fApplication.load()); 2396 TApplication::CreateApplication();; 2397 ; 2398 return (*fApplication).ProcessLine(sline, kTRUE, error);; 2399}; 2400 ; 2401////////////////////////////////////////////////////////////////////////////////; 2402/// Process interpreter command directly via CINT interpreter.; 2403/// Only executable statements are allowed (no variable declarations),; 2404/// In all other cases use TROOT::ProcessLine().; 2405/// The possible error codes are defined by TInterpreter::EErrorCode.; 2406 ; 2407Longptr_t TROOT::ProcessLineFast(const char *line, Int_t *error); 2408{; 2409 TString sline = line;; 2410 sline = sline.Strip(TString::kBoth);; 2411 ; 2412 if (!fApplication.load()); 2413 TApplication::CreateApplication();; 2414 ; 2415 Longptr_t result = 0;; 2416 ; 2417 if (fInterpreter) {; 2418 TInterpreter::EErrorCode *code = (TInterpreter::EErrorCode*)error;; 2419 result = gInterpreter->Calc(sline, code);; 2420 }; 2421 ; 2422 return result;; 2423}; 2424 ; 2425////////////////////////////////////////////////////////////////////////////////; 2426/// Read Git commit information and branch name from the; 2427/// etc/gitinfo.txt file.; 2428 ; 2429void TROOT::ReadGitInfo(); 24",MatchSource.WIKI,doc/v632/TROOT_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/TROOT_8cxx_source.html
https://root.cern/doc/v632/TROOT_8cxx_source.html:91710,Availability,error,error,91710,"hronously (i.e. it will; 2384/// only return when the CINT interpreter thread has finished executing; 2385/// the line). On non-Win32 platforms there is no difference between; 2386/// ProcessLine() and ProcessLineSync().; 2387/// The possible error codes are defined by TInterpreter::EErrorCode.; 2388/// Returns the result of the command, cast to a Longptr_t.; 2389 ; 2390Longptr_t TROOT::ProcessLineSync(const char *line, Int_t *error); 2391{; 2392 TString sline = line;; 2393 sline = sline.Strip(TString::kBoth);; 2394 ; 2395 if (!fApplication.load()); 2396 TApplication::CreateApplication();; 2397 ; 2398 return (*fApplication).ProcessLine(sline, kTRUE, error);; 2399}; 2400 ; 2401////////////////////////////////////////////////////////////////////////////////; 2402/// Process interpreter command directly via CINT interpreter.; 2403/// Only executable statements are allowed (no variable declarations),; 2404/// In all other cases use TROOT::ProcessLine().; 2405/// The possible error codes are defined by TInterpreter::EErrorCode.; 2406 ; 2407Longptr_t TROOT::ProcessLineFast(const char *line, Int_t *error); 2408{; 2409 TString sline = line;; 2410 sline = sline.Strip(TString::kBoth);; 2411 ; 2412 if (!fApplication.load()); 2413 TApplication::CreateApplication();; 2414 ; 2415 Longptr_t result = 0;; 2416 ; 2417 if (fInterpreter) {; 2418 TInterpreter::EErrorCode *code = (TInterpreter::EErrorCode*)error;; 2419 result = gInterpreter->Calc(sline, code);; 2420 }; 2421 ; 2422 return result;; 2423}; 2424 ; 2425////////////////////////////////////////////////////////////////////////////////; 2426/// Read Git commit information and branch name from the; 2427/// etc/gitinfo.txt file.; 2428 ; 2429void TROOT::ReadGitInfo(); 2430{; 2431 TString filename = ""gitinfo.txt"";; 2432 gSystem->PrependPathName(TROOT::GetEtcDir(), filename);; 2433 ; 2434 FILE *fp = fopen(filename, ""r"");; 2435 if (fp) {; 2436 TString s;; 2437 // read branch name; 2438 s.Gets(fp);; 2439 fGitBranch = s;; 2440 // read com",MatchSource.WIKI,doc/v632/TROOT_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/TROOT_8cxx_source.html
https://root.cern/doc/v632/TROOT_8cxx_source.html:91833,Availability,error,error,91833,"85/// the line). On non-Win32 platforms there is no difference between; 2386/// ProcessLine() and ProcessLineSync().; 2387/// The possible error codes are defined by TInterpreter::EErrorCode.; 2388/// Returns the result of the command, cast to a Longptr_t.; 2389 ; 2390Longptr_t TROOT::ProcessLineSync(const char *line, Int_t *error); 2391{; 2392 TString sline = line;; 2393 sline = sline.Strip(TString::kBoth);; 2394 ; 2395 if (!fApplication.load()); 2396 TApplication::CreateApplication();; 2397 ; 2398 return (*fApplication).ProcessLine(sline, kTRUE, error);; 2399}; 2400 ; 2401////////////////////////////////////////////////////////////////////////////////; 2402/// Process interpreter command directly via CINT interpreter.; 2403/// Only executable statements are allowed (no variable declarations),; 2404/// In all other cases use TROOT::ProcessLine().; 2405/// The possible error codes are defined by TInterpreter::EErrorCode.; 2406 ; 2407Longptr_t TROOT::ProcessLineFast(const char *line, Int_t *error); 2408{; 2409 TString sline = line;; 2410 sline = sline.Strip(TString::kBoth);; 2411 ; 2412 if (!fApplication.load()); 2413 TApplication::CreateApplication();; 2414 ; 2415 Longptr_t result = 0;; 2416 ; 2417 if (fInterpreter) {; 2418 TInterpreter::EErrorCode *code = (TInterpreter::EErrorCode*)error;; 2419 result = gInterpreter->Calc(sline, code);; 2420 }; 2421 ; 2422 return result;; 2423}; 2424 ; 2425////////////////////////////////////////////////////////////////////////////////; 2426/// Read Git commit information and branch name from the; 2427/// etc/gitinfo.txt file.; 2428 ; 2429void TROOT::ReadGitInfo(); 2430{; 2431 TString filename = ""gitinfo.txt"";; 2432 gSystem->PrependPathName(TROOT::GetEtcDir(), filename);; 2433 ; 2434 FILE *fp = fopen(filename, ""r"");; 2435 if (fp) {; 2436 TString s;; 2437 // read branch name; 2438 s.Gets(fp);; 2439 fGitBranch = s;; 2440 // read commit hash; 2441 s.Gets(fp);; 2442 fGitCommit = s;; 2443 // read date/time make was run; 2444 s.Gets(fp);;",MatchSource.WIKI,doc/v632/TROOT_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/TROOT_8cxx_source.html
https://root.cern/doc/v632/TROOT_8cxx_source.html:92132,Availability,error,error,92132,"tring sline = line;; 2393 sline = sline.Strip(TString::kBoth);; 2394 ; 2395 if (!fApplication.load()); 2396 TApplication::CreateApplication();; 2397 ; 2398 return (*fApplication).ProcessLine(sline, kTRUE, error);; 2399}; 2400 ; 2401////////////////////////////////////////////////////////////////////////////////; 2402/// Process interpreter command directly via CINT interpreter.; 2403/// Only executable statements are allowed (no variable declarations),; 2404/// In all other cases use TROOT::ProcessLine().; 2405/// The possible error codes are defined by TInterpreter::EErrorCode.; 2406 ; 2407Longptr_t TROOT::ProcessLineFast(const char *line, Int_t *error); 2408{; 2409 TString sline = line;; 2410 sline = sline.Strip(TString::kBoth);; 2411 ; 2412 if (!fApplication.load()); 2413 TApplication::CreateApplication();; 2414 ; 2415 Longptr_t result = 0;; 2416 ; 2417 if (fInterpreter) {; 2418 TInterpreter::EErrorCode *code = (TInterpreter::EErrorCode*)error;; 2419 result = gInterpreter->Calc(sline, code);; 2420 }; 2421 ; 2422 return result;; 2423}; 2424 ; 2425////////////////////////////////////////////////////////////////////////////////; 2426/// Read Git commit information and branch name from the; 2427/// etc/gitinfo.txt file.; 2428 ; 2429void TROOT::ReadGitInfo(); 2430{; 2431 TString filename = ""gitinfo.txt"";; 2432 gSystem->PrependPathName(TROOT::GetEtcDir(), filename);; 2433 ; 2434 FILE *fp = fopen(filename, ""r"");; 2435 if (fp) {; 2436 TString s;; 2437 // read branch name; 2438 s.Gets(fp);; 2439 fGitBranch = s;; 2440 // read commit hash; 2441 s.Gets(fp);; 2442 fGitCommit = s;; 2443 // read date/time make was run; 2444 s.Gets(fp);; 2445 fGitDate = s;; 2446 fclose(fp);; 2447 } else {; 2448 Error(""ReadGitInfo()"", ""Cannot determine git info: etc/gitinfo.txt not found!"");; 2449 }; 2450}; 2451 ; 2452Bool_t &GetReadingObject() {; 2453 TTHREAD_TLS(Bool_t) fgReadingObject = false;; 2454 return fgReadingObject;; 2455}; 2456 ; 2457/////////////////////////////////////////////////////",MatchSource.WIKI,doc/v632/TROOT_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/TROOT_8cxx_source.html
https://root.cern/doc/v632/TROOT_8cxx_source.html:98405,Availability,down,down,98405,"Cleanups is called. When; 2564 // EndOfProcessCleanups is executed it indirectly needs the TClass; 2565 // for TSocket and its search will use resources that have already; 2566 // been unloaded (technically the function static in TUnixSystem's; 2567 // DynamicPath and the dictionary from libNet).; 2568 ; 2569 // Similarly, the ordering (before this commit) was broken in the; 2570 // following case:; 2571 ; 2572 // TApplication creation (EndOfProcessCleanups registration); 2573 // load UserLibrary; 2574 // create TFile; 2575 // Append UserObject to TFile; 2576 ; 2577 // and after the end of main the order of execution was; 2578 ; 2579 // unload UserLibrary; 2580 // call EndOfProcessCleanups; 2581 // Write the TFile; 2582 // attempt to write the user object.; 2583 // ....; 2584 ; 2585 // where what we need is to have the files closen/written before; 2586 // the unloading of the library.; 2587 ; 2588 // To solve the problem we now register an atexit function for; 2589 // every dictionary thus making sure there is at least one executed; 2590 // before the first library tear down after main.; 2591 ; 2592 // If atexit is called directly within a library's code, the; 2593 // function will called *either* when the library is 'dlclose'd or; 2594 // after then end of main (whichever comes first). We do *not*; 2595 // want the files to be closed whenever a library is unloaded via; 2596 // dlclose. To avoid this, we add the function (CallCloseFiles); 2597 // from the dictionary indirectly (via ROOT::RegisterModule). In; 2598 // this case the function will only only be called either when; 2599 // libCore is 'dlclose'd or right after the end of main.; 2600 ; 2601 atexit(CallCloseFiles);; 2602 ; 2603 // Now register with TCling.; 2604 if (TROOT::Initialized()) {; 2605 gCling->RegisterModule(modulename, headers, includePaths, payloadCode, fwdDeclCode, triggerFunc,; 2606 fwdDeclsArgToSkip, classesHeaders, false, hasCxxModule);; 2607 } else {; 2608 GetModuleHeaderInfoBuffer().push_ba",MatchSource.WIKI,doc/v632/TROOT_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/TROOT_8cxx_source.html
https://root.cern/doc/v632/TROOT_8cxx_source.html:106373,Availability,avail,available,106373," 2778#endif; 2779 }; 2780 ; 2781 return macroPath;; 2782}; 2783 ; 2784////////////////////////////////////////////////////////////////////////////////; 2785/// Set or extend the macro search path. Static utility function.; 2786/// If newpath=0 or """" reset to value specified in the rootrc file.; 2787 ; 2788void TROOT::SetMacroPath(const char *newpath); 2789{; 2790 TString &macroPath = ROOT::GetMacroPath();; 2791 ; 2792 if (!newpath || !*newpath); 2793 macroPath = """";; 2794 else; 2795 macroPath = newpath;; 2796}; 2797 ; 2798////////////////////////////////////////////////////////////////////////////////; 2799/// Set batch mode for ROOT; 2800/// If the argument evaluates to `true`, the session does not use interactive graphics.; 2801/// If web graphics runs in server mode, the web widgets are still available via URL; 2802 ; 2803void TROOT::SetBatch(Bool_t batch); 2804{; 2805 fIsWebDisplayBatch = fBatch = batch;; 2806 if (fIsWebDisplayBatch && (fWebDisplay == ""server"")); 2807 fIsWebDisplayBatch = kFALSE;; 2808}; 2809 ; 2810////////////////////////////////////////////////////////////////////////////////; 2811/// \brief Specify where web graphics shall be rendered; 2812///; 2813/// The input parameter `webdisplay` defines where web graphics is rendered.; 2814/// `webdisplay` parameter may contain:; 2815///; 2816/// - ""firefox"": select Mozilla Firefox browser for interactive web display; 2817/// - ""chrome"": select Google Chrome browser for interactive web display; 2818/// - ""edge"": select Microsoft Edge browser for interactive web display; 2819/// - ""native"": select one of the natively-supported web browsers firefox/chrome/edge for interactive web display; 2820/// - ""qt5"": uses QWebEngine from Qt5, no real http server started (requires `qt5web` component build for ROOT); 2821/// - ""qt6"": uses QWebEngine from Qt6, no real http server started (requires `qt6web` component build for ROOT); 2822/// - ""cef"": uses Chromium Embeded Framework, no real http server started (requires `",MatchSource.WIKI,doc/v632/TROOT_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/TROOT_8cxx_source.html
https://root.cern/doc/v632/TROOT_8cxx_source.html:107634,Availability,avail,available,107634,"T::SetBatch(Bool_t batch); 2804{; 2805 fIsWebDisplayBatch = fBatch = batch;; 2806 if (fIsWebDisplayBatch && (fWebDisplay == ""server"")); 2807 fIsWebDisplayBatch = kFALSE;; 2808}; 2809 ; 2810////////////////////////////////////////////////////////////////////////////////; 2811/// \brief Specify where web graphics shall be rendered; 2812///; 2813/// The input parameter `webdisplay` defines where web graphics is rendered.; 2814/// `webdisplay` parameter may contain:; 2815///; 2816/// - ""firefox"": select Mozilla Firefox browser for interactive web display; 2817/// - ""chrome"": select Google Chrome browser for interactive web display; 2818/// - ""edge"": select Microsoft Edge browser for interactive web display; 2819/// - ""native"": select one of the natively-supported web browsers firefox/chrome/edge for interactive web display; 2820/// - ""qt5"": uses QWebEngine from Qt5, no real http server started (requires `qt5web` component build for ROOT); 2821/// - ""qt6"": uses QWebEngine from Qt6, no real http server started (requires `qt6web` component build for ROOT); 2822/// - ""cef"": uses Chromium Embeded Framework, no real http server started (requires `cefweb` component build for ROOT); 2823/// - ""local"": select on of available local (without http server) engines like qt5/qt6/cef; 2824/// - ""default"": system default web browser, invoked with `xdg-open` on Linux, `start` on Mac or `open` on Windows; 2825/// - ""on"": try ""local"", then ""native"", then ""default"" option; 2826/// - ""off"": turns off the web display and comes back to normal graphics in; 2827/// interactive mode.; 2828/// - ""server:port"": turns the web display into server mode with specified port. Web widgets will not be displayed,; 2829/// only text message with window URL will be printed on standard output; 2830 ; 2831void TROOT::SetWebDisplay(const char *webdisplay); 2832{; 2833 const char *wd = webdisplay ? webdisplay : """";; 2834 ; 2835 // store default values to set them back when needed; 2836 static TString brName = gEn",MatchSource.WIKI,doc/v632/TROOT_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/TROOT_8cxx_source.html
https://root.cern/doc/v632/TROOT_8cxx_source.html:118400,Availability,down,down,118400,"3 ; 3094const TString& TROOT::GetMacroDir() {; 3095#ifdef ROOTMACRODIR; 3096 if (IgnorePrefix()) {; 3097#endif; 3098 static TString rootmacrodir;; 3099 if (rootmacrodir.IsNull()) {; 3100 rootmacrodir = ""macros"";; 3101 gSystem->PrependPathName(GetRootSys(), rootmacrodir);; 3102 }; 3103 return rootmacrodir;; 3104#ifdef ROOTMACRODIR; 3105 } else {; 3106 const static TString rootmacrodir = ROOTMACRODIR;; 3107 return rootmacrodir;; 3108 }; 3109#endif; 3110}; 3111 ; 3112////////////////////////////////////////////////////////////////////////////////; 3113/// Get the tutorials directory in the installation. Static utility function.; 3114 ; 3115const TString& TROOT::GetTutorialDir() {; 3116#ifdef ROOTTUTDIR; 3117 if (IgnorePrefix()) {; 3118#endif; 3119 static TString roottutdir;; 3120 if (roottutdir.IsNull()) {; 3121 roottutdir = ""tutorials"";; 3122 gSystem->PrependPathName(GetRootSys(), roottutdir);; 3123 }; 3124 return roottutdir;; 3125#ifdef ROOTTUTDIR; 3126 } else {; 3127 const static TString roottutdir = ROOTTUTDIR;; 3128 return roottutdir;; 3129 }; 3130#endif; 3131}; 3132 ; 3133////////////////////////////////////////////////////////////////////////////////; 3134/// Shut down ROOT.; 3135 ; 3136void TROOT::ShutDown(); 3137{; 3138 if (gROOT); 3139 gROOT->EndOfProcessCleanups();; 3140 else if (gInterpreter); 3141 gInterpreter->ShutDown();; 3142}; 3143 ; 3144////////////////////////////////////////////////////////////////////////////////; 3145/// Get the source directory in the installation. Static utility function.; 3146 ; 3147const TString& TROOT::GetSourceDir() {; 3148#ifdef ROOTSRCDIR; 3149 if (IgnorePrefix()) {; 3150#endif; 3151 static TString rootsrcdir;; 3152 if (rootsrcdir.IsNull()) {; 3153 rootsrcdir = ""src"";; 3154 gSystem->PrependPathName(GetRootSys(), rootsrcdir);; 3155 }; 3156 return rootsrcdir;; 3157#ifdef ROOTSRCDIR; 3158 } else {; 3159 const static TString rootsrcdir = ROOTSRCDIR;; 3160 return rootsrcdir;; 3161 }; 3162#endif; 3163}; 3164 ; 3165//////////////",MatchSource.WIKI,doc/v632/TROOT_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/TROOT_8cxx_source.html
https://root.cern/doc/v632/TROOT_8cxx_source.html:123327,Availability,error,error,123327,"efinition RtypesCore.h:63; Int_tint Int_tDefinition RtypesCore.h:45; Longptr_tlong Longptr_tDefinition RtypesCore.h:82; UInt_tunsigned int UInt_tDefinition RtypesCore.h:46; kFALSEconstexpr Bool_t kFALSEDefinition RtypesCore.h:101; kNPOSconstexpr Ssiz_t kNPOSDefinition RtypesCore.h:124; kTRUEconstexpr Bool_t kTRUEDefinition RtypesCore.h:100; Option_tconst char Option_tDefinition RtypesCore.h:66; ClassImp#define ClassImp(name)Definition Rtypes.h:377; VoidFuncPtr_tvoid(* VoidFuncPtr_t)()Definition Rtypes.h:79; TApplication.h; TBrowser.h; TClassEdit.h; TClassGenerator.h; TClassTable.h; gClassTableR__EXTERN TClassTable * gClassTableDefinition TClassTable.h:97; TClass.h; CreateInterpreterTInterpreter * CreateInterpreter(void *interpLibHandle, const char *argv[])Definition TCling.cxx:608; TColor.h; TDataType.h; gDirectory#define gDirectoryDefinition TDirectory.h:384; TEnv.h; gEnvR__EXTERN TEnv * gEnvDefinition TEnv.h:170; DefaultErrorHandlervoid DefaultErrorHandler(Int_t level, Bool_t abort_bool, const char *location, const char *msg)The default error handler function.Definition TErrorDefaultHandler.cxx:102; TErrorDefaultHandler.hxx; TError.h; Errorvoid Error(const char *location, const char *msgfmt,...)Use this function in case an error occurred.Definition TError.cxx:185; Warningvoid Warning(const char *location, const char *msgfmt,...)Use this function in warning situations.Definition TError.cxx:229; SetErrorHandlerErrorHandlerFunc_t SetErrorHandler(ErrorHandlerFunc_t newhandler)Set an errorhandler function. Returns the old handler.Definition TError.cxx:90; TFolder.h; TFunctionTemplate.h; TFunction.h; optionOption_t Option_t optionDefinition TGWin32VirtualXProxy.cxx:44; cursorOption_t Option_t TPoint TPoint const char GetTextMagnitude GetFillStyle GetLineColor GetLineWidth GetMarkerStyle GetTextAlign GetTextColor GetTextSize void char Point_t Rectangle_t cursorDefinition TGWin32VirtualXProxy.cxx:160; filenameOption_t Option_t TPoint TPoint const char GetTextMagnitude Get",MatchSource.WIKI,doc/v632/TROOT_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/TROOT_8cxx_source.html
https://root.cern/doc/v632/TROOT_8cxx_source.html:123517,Availability,error,error,123517,"onstexpr Ssiz_t kNPOSDefinition RtypesCore.h:124; kTRUEconstexpr Bool_t kTRUEDefinition RtypesCore.h:100; Option_tconst char Option_tDefinition RtypesCore.h:66; ClassImp#define ClassImp(name)Definition Rtypes.h:377; VoidFuncPtr_tvoid(* VoidFuncPtr_t)()Definition Rtypes.h:79; TApplication.h; TBrowser.h; TClassEdit.h; TClassGenerator.h; TClassTable.h; gClassTableR__EXTERN TClassTable * gClassTableDefinition TClassTable.h:97; TClass.h; CreateInterpreterTInterpreter * CreateInterpreter(void *interpLibHandle, const char *argv[])Definition TCling.cxx:608; TColor.h; TDataType.h; gDirectory#define gDirectoryDefinition TDirectory.h:384; TEnv.h; gEnvR__EXTERN TEnv * gEnvDefinition TEnv.h:170; DefaultErrorHandlervoid DefaultErrorHandler(Int_t level, Bool_t abort_bool, const char *location, const char *msg)The default error handler function.Definition TErrorDefaultHandler.cxx:102; TErrorDefaultHandler.hxx; TError.h; Errorvoid Error(const char *location, const char *msgfmt,...)Use this function in case an error occurred.Definition TError.cxx:185; Warningvoid Warning(const char *location, const char *msgfmt,...)Use this function in warning situations.Definition TError.cxx:229; SetErrorHandlerErrorHandlerFunc_t SetErrorHandler(ErrorHandlerFunc_t newhandler)Set an errorhandler function. Returns the old handler.Definition TError.cxx:90; TFolder.h; TFunctionTemplate.h; TFunction.h; optionOption_t Option_t optionDefinition TGWin32VirtualXProxy.cxx:44; cursorOption_t Option_t TPoint TPoint const char GetTextMagnitude GetFillStyle GetLineColor GetLineWidth GetMarkerStyle GetTextAlign GetTextColor GetTextSize void char Point_t Rectangle_t cursorDefinition TGWin32VirtualXProxy.cxx:160; filenameOption_t Option_t TPoint TPoint const char GetTextMagnitude GetFillStyle GetLineColor GetLineWidth GetMarkerStyle GetTextAlign GetTextColor GetTextSize void char Point_t Rectangle_t WindowAttributes_t Float_t Float_t Float_t Int_t Int_t UInt_t UInt_t Rectangle_t Int_t Int_t Window_t TString Int_t GCV",MatchSource.WIKI,doc/v632/TROOT_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/TROOT_8cxx_source.html
https://root.cern/doc/v632/TROOT_8cxx_source.html:123778,Availability,error,errorhandler,123778,"d(* VoidFuncPtr_t)()Definition Rtypes.h:79; TApplication.h; TBrowser.h; TClassEdit.h; TClassGenerator.h; TClassTable.h; gClassTableR__EXTERN TClassTable * gClassTableDefinition TClassTable.h:97; TClass.h; CreateInterpreterTInterpreter * CreateInterpreter(void *interpLibHandle, const char *argv[])Definition TCling.cxx:608; TColor.h; TDataType.h; gDirectory#define gDirectoryDefinition TDirectory.h:384; TEnv.h; gEnvR__EXTERN TEnv * gEnvDefinition TEnv.h:170; DefaultErrorHandlervoid DefaultErrorHandler(Int_t level, Bool_t abort_bool, const char *location, const char *msg)The default error handler function.Definition TErrorDefaultHandler.cxx:102; TErrorDefaultHandler.hxx; TError.h; Errorvoid Error(const char *location, const char *msgfmt,...)Use this function in case an error occurred.Definition TError.cxx:185; Warningvoid Warning(const char *location, const char *msgfmt,...)Use this function in warning situations.Definition TError.cxx:229; SetErrorHandlerErrorHandlerFunc_t SetErrorHandler(ErrorHandlerFunc_t newhandler)Set an errorhandler function. Returns the old handler.Definition TError.cxx:90; TFolder.h; TFunctionTemplate.h; TFunction.h; optionOption_t Option_t optionDefinition TGWin32VirtualXProxy.cxx:44; cursorOption_t Option_t TPoint TPoint const char GetTextMagnitude GetFillStyle GetLineColor GetLineWidth GetMarkerStyle GetTextAlign GetTextColor GetTextSize void char Point_t Rectangle_t cursorDefinition TGWin32VirtualXProxy.cxx:160; filenameOption_t Option_t TPoint TPoint const char GetTextMagnitude GetFillStyle GetLineColor GetLineWidth GetMarkerStyle GetTextAlign GetTextColor GetTextSize void char Point_t Rectangle_t WindowAttributes_t Float_t Float_t Float_t Int_t Int_t UInt_t UInt_t Rectangle_t Int_t Int_t Window_t TString Int_t GCValues_t GetPrimarySelectionOwner GetDisplay GetScreen GetColormap GetNativeEvent const char const char dpyName wid window const char font_name cursor keysym reg const char only_if_exist regb h Point_t winding char text const char d",MatchSource.WIKI,doc/v632/TROOT_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/TROOT_8cxx_source.html
https://root.cern/doc/v632/TROOT_8cxx_source.html:142208,Availability,error,error,142208,"er around a TObject so it can be stored in a TList.Definition TList.h:123; TObjectMother of all ROOT objects.Definition TObject.h:41; TObject::SetObjectStatstatic void SetObjectStat(Bool_t stat)Turn on/off tracking of objects in the TObjectTable.Definition TObject.cxx:1068; TObject::GetNamevirtual const char * GetName() constReturns name of object.Definition TObject.cxx:439; TObject::ClassNamevirtual const char * ClassName() constReturns name of class to which the object belongs.Definition TObject.cxx:207; TObject::Warningvirtual void Warning(const char *method, const char *msgfmt,...) constIssue warning message.Definition TObject.cxx:973; TObject::FindObjectvirtual TObject * FindObject(const char *name) constMust be redefined in derived classes.Definition TObject.cxx:403; TObject::SetBitvoid SetBit(UInt_t f, Bool_t set)Set or unset the user status bits as specified in f.Definition TObject.cxx:780; TObject::Errorvirtual void Error(const char *method, const char *msgfmt,...) constIssue error message.Definition TObject.cxx:987; TObject::Fatalvirtual void Fatal(const char *method, const char *msgfmt,...) constIssue fatal error message.Definition TObject.cxx:1015; TObject::kInvalidObject@ kInvalidObjectif object ctor succeeded but object should not be usedDefinition TObject.h:72; TObject::kMustCleanup@ kMustCleanupif object destructor must call RecursiveRemove()Definition TObject.h:64; TPluginManagerThis class implements a plugin library manager.Definition TPluginManager.h:258; TPluginManager::LoadHandlersFromEnvvoid LoadHandlersFromEnv(TEnv *env)Load plugin handlers specified in config file, like:Definition TPluginManager.cxx:391; TProcessID::Cleanupstatic void Cleanup()static function (called by TROOT destructor) to delete all TProcessIDsDefinition TProcessID.cxx:204; TProcessID::AddProcessIDstatic TProcessID * AddProcessID()Static function to add a new TProcessID to the list of PIDs.Definition TProcessID.cxx:116; TProcessUUIDThis class is a specialized TProcessID mana",MatchSource.WIKI,doc/v632/TROOT_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/TROOT_8cxx_source.html
https://root.cern/doc/v632/TROOT_8cxx_source.html:142344,Availability,error,error,142344," TObject::SetObjectStatstatic void SetObjectStat(Bool_t stat)Turn on/off tracking of objects in the TObjectTable.Definition TObject.cxx:1068; TObject::GetNamevirtual const char * GetName() constReturns name of object.Definition TObject.cxx:439; TObject::ClassNamevirtual const char * ClassName() constReturns name of class to which the object belongs.Definition TObject.cxx:207; TObject::Warningvirtual void Warning(const char *method, const char *msgfmt,...) constIssue warning message.Definition TObject.cxx:973; TObject::FindObjectvirtual TObject * FindObject(const char *name) constMust be redefined in derived classes.Definition TObject.cxx:403; TObject::SetBitvoid SetBit(UInt_t f, Bool_t set)Set or unset the user status bits as specified in f.Definition TObject.cxx:780; TObject::Errorvirtual void Error(const char *method, const char *msgfmt,...) constIssue error message.Definition TObject.cxx:987; TObject::Fatalvirtual void Fatal(const char *method, const char *msgfmt,...) constIssue fatal error message.Definition TObject.cxx:1015; TObject::kInvalidObject@ kInvalidObjectif object ctor succeeded but object should not be usedDefinition TObject.h:72; TObject::kMustCleanup@ kMustCleanupif object destructor must call RecursiveRemove()Definition TObject.h:64; TPluginManagerThis class implements a plugin library manager.Definition TPluginManager.h:258; TPluginManager::LoadHandlersFromEnvvoid LoadHandlersFromEnv(TEnv *env)Load plugin handlers specified in config file, like:Definition TPluginManager.cxx:391; TProcessID::Cleanupstatic void Cleanup()static function (called by TROOT destructor) to delete all TProcessIDsDefinition TProcessID.cxx:204; TProcessID::AddProcessIDstatic TProcessID * AddProcessID()Static function to add a new TProcessID to the list of PIDs.Definition TProcessID.cxx:116; TProcessUUIDThis class is a specialized TProcessID managing the list of UUIDs.Definition TProcessUUID.h:32; TQObject::BlockAllSignalsstatic Bool_t BlockAllSignals(Bool_t b)Block or unblock",MatchSource.WIKI,doc/v632/TROOT_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/TROOT_8cxx_source.html
https://root.cern/doc/v632/TROOT_8cxx_source.html:147891,Availability,down,down,147891,"Int_t idleTimeInSec, const char *command=nullptr)Execute command when system has been idle for idleTimeInSec seconds.Definition TROOT.cxx:1892; TROOT::fSocketsTSeqCollection * fSocketsList of network sockets.Definition TROOT.h:148; TROOT::lsvoid ls(Option_t *option="""") const overrideTo list all objects of the application.Definition TROOT.cxx:2250; TROOT::GetMacroPathstatic const char * GetMacroPath()Get macro search path. Static utility function.Definition TROOT.cxx:2762; TROOT::fFunctionsTCollection * fFunctionsList of analytic functions.Definition TROOT.h:151; TROOT::SaveContextvoid SaveContext()Save the current interpreter context.Definition TROOT.cxx:2671; TROOT::IsExecutingMacroBool_t IsExecutingMacro() constDefinition TROOT.h:280; TROOT::GetTypeTDataType * GetType(const char *name, Bool_t load=kFALSE) constReturn pointer to type with name.Definition TROOT.cxx:1562; TROOT::Initializestatic void Initialize()Initialize ROOT explicitly.Definition TROOT.cxx:2899; TROOT::ShutDownstatic void ShutDown()Shut down ROOT.Definition TROOT.cxx:3136; TROOT::GetFunctionTObject * GetFunction(const char *name) constReturn pointer to function with name.Definition TROOT.cxx:1587; TROOT::ConvertVersionCode2Intstatic Int_t ConvertVersionCode2Int(Int_t code)Convert version code to an integer, i.e. 331527 -> 51507.Definition TROOT.cxx:2922; TROOT::fMessageHandlersTSeqCollection * fMessageHandlersList of message handlers.Definition TROOT.h:158; TROOT::SetStylevoid SetStyle(const char *stylename=""Default"")Change current style to style with name stylename.Definition TROOT.cxx:2730; TROOT::fEnumsAListOfEnums_t fEnumsList of enum types.Definition TROOT.h:165; TROOT::ReadGitInfovoid ReadGitInfo()Read Git commit SHA1 and branch name.Definition TROOT.cxx:2429; TROOT::fgRootInitstatic Bool_t fgRootInitSingleton initialization flag.Definition TROOT.h:103; TROOT::RefreshBrowsersvoid RefreshBrowsers()Refresh all browsers.Definition TROOT.cxx:2512; TROOT::CloseFilesvoid CloseFiles()Close any file",MatchSource.WIKI,doc/v632/TROOT_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/TROOT_8cxx_source.html
https://root.cern/doc/v632/TROOT_8cxx_source.html:152776,Availability,error,error,152776," if it exists.Definition TROOT.cxx:1313; TROOT::fClassesTCollection * fClassesList of classes definition.Definition TROOT.h:140; TROOT::fEditHistogramsBool_t fEditHistogramsTrue if histograms can be edited with the mouse.Definition TROOT.h:130; TROOT::fGlobalsTListOfDataMembers * fGlobalsList of global variables.Definition TROOT.h:143; TROOT::fFuncTemplateTListOfFunctionTemplates * fFuncTemplateList of global function templates.Definition TROOT.h:142; TROOT::fTimerInt_t fTimerTimer flag.Definition TROOT.h:123; TROOT::fDataSetsTSeqCollection * fDataSetsList of data sets (TDSet or TChain)Definition TROOT.h:164; TROOT::fConfigOptionsTString fConfigOptionsROOT ./configure set build options.Definition TROOT.h:111; TROOT::GetStyleTStyle * GetStyle(const char *name) constReturn pointer to style with name.Definition TROOT.cxx:1579; TROOT::GetListOfEnumsTCollection * GetListOfEnums(Bool_t load=kFALSE)Definition TROOT.cxx:1754; TROOT::ProcessLineSyncLongptr_t ProcessLineSync(const char *line, Int_t *error=nullptr)Process interpreter command via TApplication::ProcessLine().Definition TROOT.cxx:2390; TROOT::InitInterpretervoid InitInterpreter()Initialize interpreter (cling)Definition TROOT.cxx:2064; TROOT::GetListOfGlobalsTCollection * GetListOfGlobals(Bool_t load=kFALSE)Return list containing the TGlobals currently defined.Definition TROOT.cxx:1788; TROOT::SetDirLevelstatic void SetDirLevel(Int_t level=0)Return Indentation level for ls().Definition TROOT.cxx:2914; TROOT::fSecContextsTSeqCollection * fSecContextsList of security contexts (TSecContext)Definition TROOT.h:161; TROOT::fWebDisplayTString fWebDisplayIf not empty it defines where web graphics should be rendered (cef, qt5, browser.....Definition TROOT.h:127; TROOT::GetTutorialsDirstatic const char * GetTutorialsDir()Get the tutorials directory in the installation.Definition TROOT.cxx:3211; TROOT::GetListOfFunctionOverloadsTCollection * GetListOfFunctionOverloads(const char *name) constReturn the collection of functions ",MatchSource.WIKI,doc/v632/TROOT_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/TROOT_8cxx_source.html
https://root.cern/doc/v632/TROOT_8cxx_source.html:154771,Availability,error,error,154771,"named ""name"".Definition TROOT.cxx:1672; TROOT::fCleanupsTSeqCollection * fCleanupsList of recursiveRemove collections.Definition TROOT.h:157; TROOT::Initializedstatic Bool_t Initialized()Return kTRUE if the TROOT object has been initialized.Definition TROOT.cxx:2906; TROOT::SetBatchvoid SetBatch(Bool_t batch=kTRUE)Set batch mode for ROOT If the argument evaluates to true, the session does not use interactive graph...Definition TROOT.cxx:2803; TROOT::fLineIsProcessingInt_t fLineIsProcessingTo synchronize multi-threads.Definition TROOT.h:100; TROOT::GetSourceDirstatic const TString & GetSourceDir()Get the source directory in the installation. Static utility function.Definition TROOT.cxx:3147; TROOT::GetMacroDirstatic const TString & GetMacroDir()Get the macro directory in the installation. Static utility function.Definition TROOT.cxx:3094; TROOT::fGitCommitTString fGitCommitGit commit SHA1 of built.Definition TROOT.h:120; TROOT::ProcessLineLongptr_t ProcessLine(const char *line, Int_t *error=nullptr)Process interpreter command via TApplication::ProcessLine().Definition TROOT.cxx:2370; TROOT::fClosedObjectsTSeqCollection * fClosedObjectsList of closed objects from the list of files and sockets, so we can delete them if neededCl.Definition TROOT.h:145; TROOT::fTasksTSeqCollection * fTasksList of tasks.Definition TROOT.h:152; TROOT::fClipboardTSeqCollection * fClipboardList of clipboard objects.Definition TROOT.h:163; TROOT::GetGitDateconst char * GetGitDate()Return date/time make was run.Definition TROOT.cxx:2474; TROOT::SetEditorModevoid SetEditorMode(const char *mode="""")Set editor mode.Definition TROOT.cxx:2704; TROOT::GetTutorialDirstatic const TString & GetTutorialDir()Get the tutorials directory in the installation. Static utility function.Definition TROOT.cxx:3115; TROOT::~TROOTvirtual ~TROOT()Clean up and free resources used by ROOT (files, network sockets, shared memory segments,...Definition TROOT.cxx:867; TROOT::fColorsTSeqCollection * fColorsList of colors.De",MatchSource.WIKI,doc/v632/TROOT_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/TROOT_8cxx_source.html
https://root.cern/doc/v632/TROOT_8cxx_source.html:156530,Availability,error,error,156530,"function.Definition TROOT.cxx:3115; TROOT::~TROOTvirtual ~TROOT()Clean up and free resources used by ROOT (files, network sockets, shared memory segments,...Definition TROOT.cxx:867; TROOT::fColorsTSeqCollection * fColorsList of colors.Definition TROOT.h:153; TROOT::GetGlobalFunctionWithPrototypeTFunction * GetGlobalFunctionWithPrototype(const char *name, const char *proto=nullptr, Bool_t load=kFALSE)Return pointer to global function by name.Definition TROOT.cxx:1718; TROOT::GetListOfBrowsersTSeqCollection * GetListOfBrowsers() constDefinition TROOT.h:245; TROOT::ReadingObjectBool_t ReadingObject() constDeprecated (will be removed in next release).Definition TROOT.cxx:2460; TROOT::fStylesTSeqCollection * fStylesList of styles.Definition TROOT.h:150; TROOT::fVersionDateInt_t fVersionDateDate of ROOT version (ex 951226)Definition TROOT.h:116; TROOT::GetListOfColorsTSeqCollection * GetListOfColors() constDefinition TROOT.h:232; TROOT::MacroLongptr_t Macro(const char *filename, Int_t *error=nullptr, Bool_t padUpdate=kTRUE)Execute a macro in the interpreter.Definition TROOT.cxx:2316; TROOT::fBuiltTimeInt_t fBuiltTimeTime of ROOT built.Definition TROOT.h:119; TROOT::AddExtraInterpreterArgsstatic const std::vector< std::string > & AddExtraInterpreterArgs(const std::vector< std::string > &args)Provide command line arguments to the interpreter construction.Definition TROOT.cxx:2952; TROOT::GetClassTClass * GetClass(const char *name, Bool_t load=kTRUE, Bool_t silent=kFALSE) constReturn pointer to class with name. Obsolete, use TClass::GetClass directly.Definition TROOT.cxx:1518; TROOT::fSelectPadTVirtualPad * fSelectPadCurrently selected pad.Definition TROOT.h:139; TROOT::fFilesTSeqCollection * fFilesList of files.Definition TROOT.h:146; TROOT::Browsevoid Browse(TBrowser *b) overrideAdd browsable objects to TBrowser.Definition TROOT.cxx:1056; TROOT::GetRootSysstatic const TString & GetRootSys()Get the rootsys directory in the installation. Static utility function.Definition TR",MatchSource.WIKI,doc/v632/TROOT_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/TROOT_8cxx_source.html
https://root.cern/doc/v632/TROOT_8cxx_source.html:159012,Availability,error,error,159012,"FALSE)Check if class ""classname"" is known to the interpreter (in fact, this check is not needed anymore,...Definition TROOT.cxx:2183; TROOT::GetGlobalFunctionTFunction * GetGlobalFunction(const char *name, const char *params=nullptr, Bool_t load=kFALSE)Return pointer to global function by name.Definition TROOT.cxx:1685; TROOT::AddClassvoid AddClass(TClass *cl)Add a class to the list and map of classes.Definition TROOT.cxx:1025; TROOT::RootVersionCodestatic Int_t RootVersionCode()Return ROOT version code as defined in RVersion.h.Definition TROOT.cxx:2941; TROOT::FindSpecialObjectTObject * FindSpecialObject(const char *name, void *&where)Returns address and folder of a ROOT object if it exists.Definition TROOT.cxx:1367; TROOT::RemoveTObject * Remove(TObject *) overrideRemove an object from the in-memory list.Definition TROOT.cxx:2618; TROOT::InitSystemvoid InitSystem()Operating System interface.Definition TROOT.cxx:1978; TROOT::ProcessLineFastLongptr_t ProcessLineFast(const char *line, Int_t *error=nullptr)Process interpreter command directly via CINT interpreter.Definition TROOT.cxx:2407; TROOT::ClassSavedBool_t ClassSaved(TClass *cl)return class status 'ClassSaved' for class cl This function is called by the SavePrimitive functions ...Definition TROOT.cxx:1083; TROOT::fGitBranchTString fGitBranchGit branch.Definition TROOT.h:121; TROOT::GetListOfTypesTCollection * GetListOfTypes(Bool_t load=kFALSE)Return a dynamic list giving access to all TDataTypes (typedefs) currently defined.Definition TROOT.cxx:1865; TROOT::fgDirLevelstatic Int_t fgDirLevelIndentation level for ls()Definition TROOT.h:102; TROOT::IsRootFileBool_t IsRootFile(const char *filename) constReturn true if the file is local and is (likely) to be a ROOT file.Definition TROOT.cxx:2230; TROOT::IndentLevelstatic void IndentLevel()Functions used by ls() to indent an object hierarchy.Definition TROOT.cxx:2891; TROOT::GetDocDirstatic const TString & GetDocDir()Get the documentation directory in the installation",MatchSource.WIKI,doc/v632/TROOT_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/TROOT_8cxx_source.html
https://root.cern/doc/v632/TROOT_8cxx_source.html:162129,Availability,error,error,162129,"nition TROOT.h:169; TROOT::GetGeometryTObject * GetGeometry(const char *name) constReturn pointer to Geometry with name.Definition TROOT.cxx:1747; TROOT::RecursiveRemovevoid RecursiveRemove(TObject *obj) overrideRecursively remove this object from the list of Cleanups.Definition TROOT.cxx:2498; TROOT::fExecutingMacroBool_t fExecutingMacroTrue while executing a TMacro.Definition TROOT.h:136; TROOT::fBuiltDateInt_t fBuiltDateDate of ROOT built.Definition TROOT.h:118; TROOT::fIsWebDisplayBatchBool_t fIsWebDisplayBatchTrue if web widgets are not displayed.Definition TROOT.h:129; TROOT::GetSharedLibDirstatic const TString & GetSharedLibDir()Get the shared libraries directory in the installation. Static utility function.Definition TROOT.cxx:3031; TROOT::fMappedFilesTSeqCollection * fMappedFilesList of memory mapped files.Definition TROOT.h:147; TROOT::GetNtypesInt_t GetNtypes() constGet number of types.Definition TROOT.cxx:1884; TROOT::LoadMacroInt_t LoadMacro(const char *filename, Int_t *error=nullptr, Bool_t check=kFALSE)Load a macro in the interpreter's memory.Definition TROOT.cxx:2268; TROOT::GetFileTFile * GetFile() const overrideDefinition TROOT.h:260; TROOT::GetLibDirstatic const TString & GetLibDir()Get the library directory in the installation. Static utility function.Definition TROOT.cxx:3010; TROOT::fBrowsersTSeqCollection * fBrowsersList of browsers.Definition TROOT.h:155; TROOT::fDefCanvasNameTString fDefCanvasNameName of default canvas.Definition TROOT.h:171; TROOT::fGlobalFunctionsTListOfFunctions * fGlobalFunctionsList of global functions.Definition TROOT.h:144; TROOT::fBrowsablesTList * fBrowsablesList of browsables.Definition TROOT.h:168; TROOT::FindObjectAnyTObject * FindObjectAny(const char *name) const overrideReturn a pointer to the first object with name starting at //root.Definition TROOT.cxx:1426; TROOT::DecreaseDirLevelstatic Int_t DecreaseDirLevel()Decrease the indentation level for ls().Definition TROOT.cxx:2746; TROOT::Resetvoid Reset(Option_t ",MatchSource.WIKI,doc/v632/TROOT_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/TROOT_8cxx_source.html
https://root.cern/doc/v632/TROOT_8cxx_source.html:168588,Availability,error,error,168588,"*dir, TString &name)Concatenate a directory and a file name.Definition TSystem.cxx:1081; TSystem::AccessPathNamevirtual Bool_t AccessPathName(const char *path, EAccessMode mode=kFileExists)Returns FALSE if one can access a file using the specified access mode.Definition TSystem.cxx:1296; TSystem::Initvirtual Bool_t Init()Initialize the OS interface.Definition TSystem.cxx:183; TSystem::BaseNamevirtual const char * BaseName(const char *pathname)Base name of a file name. Base name of /user/root is root.Definition TSystem.cxx:934; TSystem::WorkingDirectoryvirtual const char * WorkingDirectory()Return working directory.Definition TSystem.cxx:871; TSystem::Whichvirtual char * Which(const char *search, const char *file, EAccessMode mode=kFileExists)Find location of file in a search path.Definition TSystem.cxx:1548; TSystem::HomeDirectoryvirtual const char * HomeDirectory(const char *userName=nullptr)Return the user's home directory.Definition TSystem.cxx:887; TSystem::GetErrorvirtual const char * GetError()Return system error string.Definition TSystem.cxx:254; TSystem::ResetSignalsvirtual void ResetSignals()Reset signals handlers to previous behaviour.Definition TSystem.cxx:584; TSystem::DynamicPathNamechar * DynamicPathName(const char *lib, Bool_t quiet=kFALSE)Find a dynamic library called lib using the system search paths.Definition TSystem.cxx:2020; TUnixSystemDefinition TUnixSystem.h:32; TUrlThis class represents a WWW compatible URL.Definition TUrl.h:33; TVirtualMutexThis class implements a mutex interface.Definition TVirtualMutex.h:32; TVirtualPadTVirtualPad is an abstract base class for the Pad and Canvas classes.Definition TVirtualPad.h:51; TVirtualPad::Padstatic TVirtualPad *& Pad()Return the current pad for the current thread.Definition TVirtualPad.cxx:82; TVirtualPad::GetVirtCanvasvirtual TVirtualPad * GetVirtCanvas() const =0; TVirtualXSemi-Abstract base class defining a generic interface to the underlying, low level,...Definition TVirtualX.h:46; TVirtualX::Ins",MatchSource.WIKI,doc/v632/TROOT_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/TROOT_8cxx_source.html
https://root.cern/doc/v632/TROOT_8cxx_source.html:171025,Availability,error,error,171025,"etIncludeDirconst std::string & GetIncludeDir()\ returns the include directory in the installation.Definition FoundationUtils.cxx:180; ROOT::FoundationUtils::GetRootSysconst std::string & GetRootSys()Definition FoundationUtils.cxx:158; ROOT::FoundationUtils::GetEtcDirconst std::string & GetEtcDir()Definition FoundationUtils.cxx:195; ROOT::Internal::VecOps::voidvoid(off) SmallVectorTemplateBase< T; ROOT::InternalDefinition TErrorDefaultHandler.hxx:16; ROOT::Internal::GetSymInLibImtstatic Func_t GetSymInLibImt(const char *funcname)Definition TROOT.cxx:401; ROOT::Internal::gGetROOTstatic GetROOTFun_t gGetROOTDefinition TROOT.cxx:399; ROOT::Internal::gROOTLocalR__EXTERN TROOT * gROOTLocalDefinition TROOT.h:379; ROOT::Internal::DisableParBranchProcessingvoid DisableParBranchProcessing()Globally disables the IMT use case of parallel branch processing, deactivating the corresponding lock...Definition TROOT.cxx:434; ROOT::Internal::ErrorSystemMsgHandlerFunc_tstd::function< const char *()> ErrorSystemMsgHandlerFunc_tRetrieves the error string associated with the last system error.Definition TError.h:59; ROOT::Internal::IsImplicitMTEnabledImplstatic Bool_t & IsImplicitMTEnabledImpl()Keeps track of the status of ImplicitMT w/o resorting to the load of libImt.Definition TROOT.cxx:463; ROOT::Internal::MinimalErrorHandlervoid MinimalErrorHandler(int level, Bool_t abort, const char *location, const char *msg)A very simple error handler that is usually replaced by the TROOT default error handler.Definition TError.cxx:67; ROOT::Internal::GetROOTFun_tTROOT *(* GetROOTFun_t)()Definition TROOT.cxx:397; ROOT::Internal::SetErrorSystemMsgHandlerErrorSystemMsgHandlerFunc_t SetErrorSystemMsgHandler(ErrorSystemMsgHandlerFunc_t h)Returns the previous system error message handler.Definition TError.cxx:56; ROOT::Internal::EnableParBranchProcessingvoid EnableParBranchProcessing()Globally enables the parallel branch processing, which is a case of implicit multi-threading (IMT) in...Definition TROO",MatchSource.WIKI,doc/v632/TROOT_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/TROOT_8cxx_source.html
https://root.cern/doc/v632/TROOT_8cxx_source.html:171070,Availability,error,error,171070,"etIncludeDirconst std::string & GetIncludeDir()\ returns the include directory in the installation.Definition FoundationUtils.cxx:180; ROOT::FoundationUtils::GetRootSysconst std::string & GetRootSys()Definition FoundationUtils.cxx:158; ROOT::FoundationUtils::GetEtcDirconst std::string & GetEtcDir()Definition FoundationUtils.cxx:195; ROOT::Internal::VecOps::voidvoid(off) SmallVectorTemplateBase< T; ROOT::InternalDefinition TErrorDefaultHandler.hxx:16; ROOT::Internal::GetSymInLibImtstatic Func_t GetSymInLibImt(const char *funcname)Definition TROOT.cxx:401; ROOT::Internal::gGetROOTstatic GetROOTFun_t gGetROOTDefinition TROOT.cxx:399; ROOT::Internal::gROOTLocalR__EXTERN TROOT * gROOTLocalDefinition TROOT.h:379; ROOT::Internal::DisableParBranchProcessingvoid DisableParBranchProcessing()Globally disables the IMT use case of parallel branch processing, deactivating the corresponding lock...Definition TROOT.cxx:434; ROOT::Internal::ErrorSystemMsgHandlerFunc_tstd::function< const char *()> ErrorSystemMsgHandlerFunc_tRetrieves the error string associated with the last system error.Definition TError.h:59; ROOT::Internal::IsImplicitMTEnabledImplstatic Bool_t & IsImplicitMTEnabledImpl()Keeps track of the status of ImplicitMT w/o resorting to the load of libImt.Definition TROOT.cxx:463; ROOT::Internal::MinimalErrorHandlervoid MinimalErrorHandler(int level, Bool_t abort, const char *location, const char *msg)A very simple error handler that is usually replaced by the TROOT default error handler.Definition TError.cxx:67; ROOT::Internal::GetROOTFun_tTROOT *(* GetROOTFun_t)()Definition TROOT.cxx:397; ROOT::Internal::SetErrorSystemMsgHandlerErrorSystemMsgHandlerFunc_t SetErrorSystemMsgHandler(ErrorSystemMsgHandlerFunc_t h)Returns the previous system error message handler.Definition TError.cxx:56; ROOT::Internal::EnableParBranchProcessingvoid EnableParBranchProcessing()Globally enables the parallel branch processing, which is a case of implicit multi-threading (IMT) in...Definition TROO",MatchSource.WIKI,doc/v632/TROOT_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/TROOT_8cxx_source.html
https://root.cern/doc/v632/TROOT_8cxx_source.html:171419,Availability,error,error,171419,"e< T; ROOT::InternalDefinition TErrorDefaultHandler.hxx:16; ROOT::Internal::GetSymInLibImtstatic Func_t GetSymInLibImt(const char *funcname)Definition TROOT.cxx:401; ROOT::Internal::gGetROOTstatic GetROOTFun_t gGetROOTDefinition TROOT.cxx:399; ROOT::Internal::gROOTLocalR__EXTERN TROOT * gROOTLocalDefinition TROOT.h:379; ROOT::Internal::DisableParBranchProcessingvoid DisableParBranchProcessing()Globally disables the IMT use case of parallel branch processing, deactivating the corresponding lock...Definition TROOT.cxx:434; ROOT::Internal::ErrorSystemMsgHandlerFunc_tstd::function< const char *()> ErrorSystemMsgHandlerFunc_tRetrieves the error string associated with the last system error.Definition TError.h:59; ROOT::Internal::IsImplicitMTEnabledImplstatic Bool_t & IsImplicitMTEnabledImpl()Keeps track of the status of ImplicitMT w/o resorting to the load of libImt.Definition TROOT.cxx:463; ROOT::Internal::MinimalErrorHandlervoid MinimalErrorHandler(int level, Bool_t abort, const char *location, const char *msg)A very simple error handler that is usually replaced by the TROOT default error handler.Definition TError.cxx:67; ROOT::Internal::GetROOTFun_tTROOT *(* GetROOTFun_t)()Definition TROOT.cxx:397; ROOT::Internal::SetErrorSystemMsgHandlerErrorSystemMsgHandlerFunc_t SetErrorSystemMsgHandler(ErrorSystemMsgHandlerFunc_t h)Returns the previous system error message handler.Definition TError.cxx:56; ROOT::Internal::EnableParBranchProcessingvoid EnableParBranchProcessing()Globally enables the parallel branch processing, which is a case of implicit multi-threading (IMT) in...Definition TROOT.cxx:420; ROOT::Internal::IsParBranchProcessingEnabledBool_t IsParBranchProcessingEnabled()Returns true if parallel branch processing is enabled.Definition TROOT.cxx:447; ROOT::Internal::GetROOT2TROOT * GetROOT2()Definition TROOT.cxx:387; ROOT::Internal::GetROOT1TROOT * GetROOT1()Definition TROOT.cxx:380; ROOT::Internal::ReleaseDefaultErrorHandlervoid ReleaseDefaultErrorHandler()Destructs r",MatchSource.WIKI,doc/v632/TROOT_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/TROOT_8cxx_source.html
https://root.cern/doc/v632/TROOT_8cxx_source.html:171479,Availability,error,error,171479,"e< T; ROOT::InternalDefinition TErrorDefaultHandler.hxx:16; ROOT::Internal::GetSymInLibImtstatic Func_t GetSymInLibImt(const char *funcname)Definition TROOT.cxx:401; ROOT::Internal::gGetROOTstatic GetROOTFun_t gGetROOTDefinition TROOT.cxx:399; ROOT::Internal::gROOTLocalR__EXTERN TROOT * gROOTLocalDefinition TROOT.h:379; ROOT::Internal::DisableParBranchProcessingvoid DisableParBranchProcessing()Globally disables the IMT use case of parallel branch processing, deactivating the corresponding lock...Definition TROOT.cxx:434; ROOT::Internal::ErrorSystemMsgHandlerFunc_tstd::function< const char *()> ErrorSystemMsgHandlerFunc_tRetrieves the error string associated with the last system error.Definition TError.h:59; ROOT::Internal::IsImplicitMTEnabledImplstatic Bool_t & IsImplicitMTEnabledImpl()Keeps track of the status of ImplicitMT w/o resorting to the load of libImt.Definition TROOT.cxx:463; ROOT::Internal::MinimalErrorHandlervoid MinimalErrorHandler(int level, Bool_t abort, const char *location, const char *msg)A very simple error handler that is usually replaced by the TROOT default error handler.Definition TError.cxx:67; ROOT::Internal::GetROOTFun_tTROOT *(* GetROOTFun_t)()Definition TROOT.cxx:397; ROOT::Internal::SetErrorSystemMsgHandlerErrorSystemMsgHandlerFunc_t SetErrorSystemMsgHandler(ErrorSystemMsgHandlerFunc_t h)Returns the previous system error message handler.Definition TError.cxx:56; ROOT::Internal::EnableParBranchProcessingvoid EnableParBranchProcessing()Globally enables the parallel branch processing, which is a case of implicit multi-threading (IMT) in...Definition TROOT.cxx:420; ROOT::Internal::IsParBranchProcessingEnabledBool_t IsParBranchProcessingEnabled()Returns true if parallel branch processing is enabled.Definition TROOT.cxx:447; ROOT::Internal::GetROOT2TROOT * GetROOT2()Definition TROOT.cxx:387; ROOT::Internal::GetROOT1TROOT * GetROOT1()Definition TROOT.cxx:380; ROOT::Internal::ReleaseDefaultErrorHandlervoid ReleaseDefaultErrorHandler()Destructs r",MatchSource.WIKI,doc/v632/TROOT_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/TROOT_8cxx_source.html
https://root.cern/doc/v632/TROOT_8cxx_source.html:171749,Availability,error,error,171749,"lDefinition TROOT.h:379; ROOT::Internal::DisableParBranchProcessingvoid DisableParBranchProcessing()Globally disables the IMT use case of parallel branch processing, deactivating the corresponding lock...Definition TROOT.cxx:434; ROOT::Internal::ErrorSystemMsgHandlerFunc_tstd::function< const char *()> ErrorSystemMsgHandlerFunc_tRetrieves the error string associated with the last system error.Definition TError.h:59; ROOT::Internal::IsImplicitMTEnabledImplstatic Bool_t & IsImplicitMTEnabledImpl()Keeps track of the status of ImplicitMT w/o resorting to the load of libImt.Definition TROOT.cxx:463; ROOT::Internal::MinimalErrorHandlervoid MinimalErrorHandler(int level, Bool_t abort, const char *location, const char *msg)A very simple error handler that is usually replaced by the TROOT default error handler.Definition TError.cxx:67; ROOT::Internal::GetROOTFun_tTROOT *(* GetROOTFun_t)()Definition TROOT.cxx:397; ROOT::Internal::SetErrorSystemMsgHandlerErrorSystemMsgHandlerFunc_t SetErrorSystemMsgHandler(ErrorSystemMsgHandlerFunc_t h)Returns the previous system error message handler.Definition TError.cxx:56; ROOT::Internal::EnableParBranchProcessingvoid EnableParBranchProcessing()Globally enables the parallel branch processing, which is a case of implicit multi-threading (IMT) in...Definition TROOT.cxx:420; ROOT::Internal::IsParBranchProcessingEnabledBool_t IsParBranchProcessingEnabled()Returns true if parallel branch processing is enabled.Definition TROOT.cxx:447; ROOT::Internal::GetROOT2TROOT * GetROOT2()Definition TROOT.cxx:387; ROOT::Internal::GetROOT1TROOT * GetROOT1()Definition TROOT.cxx:380; ROOT::Internal::ReleaseDefaultErrorHandlervoid ReleaseDefaultErrorHandler()Destructs resources that are taken by using the default error handler.Definition TErrorDefaultHandler.cxx:47; ROOT::Minuit2::GradientParameterSpace::Internal@ Internal; ROOTtbb::task_arena is an alias of tbb::interface7::task_arena, which doesn't allow to forward declare tb...Definition EExecutionPolicy.hxx",MatchSource.WIKI,doc/v632/TROOT_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/TROOT_8cxx_source.html
https://root.cern/doc/v632/TROOT_8cxx_source.html:172428,Availability,error,error,172428,", const char *location, const char *msg)A very simple error handler that is usually replaced by the TROOT default error handler.Definition TError.cxx:67; ROOT::Internal::GetROOTFun_tTROOT *(* GetROOTFun_t)()Definition TROOT.cxx:397; ROOT::Internal::SetErrorSystemMsgHandlerErrorSystemMsgHandlerFunc_t SetErrorSystemMsgHandler(ErrorSystemMsgHandlerFunc_t h)Returns the previous system error message handler.Definition TError.cxx:56; ROOT::Internal::EnableParBranchProcessingvoid EnableParBranchProcessing()Globally enables the parallel branch processing, which is a case of implicit multi-threading (IMT) in...Definition TROOT.cxx:420; ROOT::Internal::IsParBranchProcessingEnabledBool_t IsParBranchProcessingEnabled()Returns true if parallel branch processing is enabled.Definition TROOT.cxx:447; ROOT::Internal::GetROOT2TROOT * GetROOT2()Definition TROOT.cxx:387; ROOT::Internal::GetROOT1TROOT * GetROOT1()Definition TROOT.cxx:380; ROOT::Internal::ReleaseDefaultErrorHandlervoid ReleaseDefaultErrorHandler()Destructs resources that are taken by using the default error handler.Definition TErrorDefaultHandler.cxx:47; ROOT::Minuit2::GradientParameterSpace::Internal@ Internal; ROOTtbb::task_arena is an alias of tbb::interface7::task_arena, which doesn't allow to forward declare tb...Definition EExecutionPolicy.hxx:4; ROOT::GetMacroPathTString & GetMacroPath()Definition TROOT.cxx:476; ROOT::EnableImplicitMTvoid EnableImplicitMT(UInt_t numthreads=0)Enable ROOT's implicit multi-threading for all objects and methods that provide an internal paralleli...Definition TROOT.cxx:539; ROOT::IsImplicitMTEnabledBool_t IsImplicitMTEnabled()Returns true if the implicit multi-threading in ROOT is enabled.Definition TROOT.cxx:570; ROOT::GetThreadPoolSizeUInt_t GetThreadPoolSize()Returns the size of ROOT's thread pool.Definition TROOT.cxx:577; ROOT::gCoreMutexR__EXTERN TVirtualRWMutex * gCoreMutexDefinition TVirtualRWMutex.h:37; ROOT::EnableThreadSafetyvoid EnableThreadSafety()Enable support for multi-t",MatchSource.WIKI,doc/v632/TROOT_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/TROOT_8cxx_source.html
https://root.cern/doc/v632/TROOT_8cxx_source.html:43050,Deployability,update,update,43050," std::set<TClass *> &GetClassSavedSet(); 1072 {; 1073 static thread_local std::set<TClass*> gClassSaved;; 1074 return gClassSaved;; 1075 }; 1076}; 1077 ; 1078////////////////////////////////////////////////////////////////////////////////; 1079/// return class status 'ClassSaved' for class cl; 1080/// This function is called by the SavePrimitive functions writing; 1081/// the C++ code for an object.; 1082 ; 1083Bool_t TROOT::ClassSaved(TClass *cl); 1084{; 1085 if (cl == nullptr); 1086 return kFALSE;; 1087 ; 1088 auto result = GetClassSavedSet().insert(cl);; 1089 ; 1090 // Return false on the first insertion only.; 1091 return !result.second;; 1092}; 1093 ; 1094////////////////////////////////////////////////////////////////////////////////; 1095/// Reset the ClassSaved status of all classes; 1096void TROOT::ResetClassSaved(); 1097{; 1098 GetClassSavedSet().clear();; 1099}; 1100 ; 1101namespace {; 1102 template <typename Content>; 1103 static void R__ListSlowClose(TList *files); 1104 {; 1105 // Routine to close a list of files using the 'slow' techniques; 1106 // that also for the deletion ot update the list itself.; 1107 ; 1108 static TObject harmless;; 1109 TObjLink *cursor = files->FirstLink();; 1110 while (cursor) {; 1111 Content *dir = static_cast<Content*>( cursor->GetObject() );; 1112 if (dir) {; 1113 // In order for the iterator to stay valid, we must; 1114 // prevent the removal of the object (dir) from the list; 1115 // (which is done in TFile::Close). We can also can not; 1116 // just move to the next iterator since the Close might; 1117 // also (indirectly) remove that file.; 1118 // So we SetObject to a harmless value, so that 'dir'; 1119 // is not seen as part of the list.; 1120 // We will later, remove all the object (see files->Clear(); 1121 cursor->SetObject(&harmless); // this must not be zero otherwise things go wrong.; 1122 // See related comment at the files->Clear(""nodelete"");; 1123 dir->Close(""nodelete"");; 1124 // Put it back; 1125 cursor->SetOb",MatchSource.WIKI,doc/v632/TROOT_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/TROOT_8cxx_source.html
https://root.cern/doc/v632/TROOT_8cxx_source.html:68431,Deployability,update,update,68431,"*TROOT::GetListOfEnums(Bool_t load /* = kTRUE */); 1755{; 1756 if(!fEnums.load()) {; 1757 R__LOCKGUARD(gROOTMutex);; 1758 // Test again just in case, another thread did the work while we were; 1759 // waiting.; 1760 if (!fEnums.load()) fEnums = new TListOfEnumsWithLock(nullptr);; 1761 }; 1762 if (load) {; 1763 R__LOCKGUARD(gROOTMutex);; 1764 (*fEnums).Load(); // Refresh the list of enums.; 1765 }; 1766 return fEnums.load();; 1767}; 1768 ; 1769////////////////////////////////////////////////////////////////////////////////; 1770 ; 1771TCollection *TROOT::GetListOfFunctionTemplates(); 1772{; 1773 R__LOCKGUARD(gROOTMutex);; 1774 if(!fFuncTemplate) {; 1775 fFuncTemplate = new TListOfFunctionTemplates(nullptr);; 1776 }; 1777 return fFuncTemplate;; 1778}; 1779 ; 1780////////////////////////////////////////////////////////////////////////////////; 1781/// Return list containing the TGlobals currently defined.; 1782/// Since globals are created and deleted during execution of the; 1783/// program, we need to update the list of globals every time we; 1784/// execute this method. However, when calling this function in; 1785/// a (tight) loop where no interpreter symbols will be created; 1786/// you can set load=kFALSE (default).; 1787 ; 1788TCollection *TROOT::GetListOfGlobals(Bool_t load); 1789{; 1790 if (!fGlobals) {; 1791 fGlobals = new TListOfDataMembers(nullptr, TDictionary::EMemberSelection::kAlsoUsingDecls);; 1792 // We add to the list the ""funcky-fake"" globals.; 1793 ; 1794 // provide special functor for gROOT, while ROOT::GetROOT() does not return reference; 1795 TGlobalMappedFunction::MakeFunctor(""gROOT"", ""TROOT*"", ROOT::GetROOT, [] {; 1796 ROOT::GetROOT();; 1797 return (void *)&ROOT::Internal::gROOTLocal;; 1798 });; 1799 ; 1800 TGlobalMappedFunction::MakeFunctor(""gPad"", ""TVirtualPad*"", TVirtualPad::Pad);; 1801 TGlobalMappedFunction::MakeFunctor(""gVirtualX"", ""TVirtualX*"", TVirtualX::Instance);; 1802 TGlobalMappedFunction::MakeFunctor(""gDirectory"", ""TDirectory*"", TDir",MatchSource.WIKI,doc/v632/TROOT_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/TROOT_8cxx_source.html
https://root.cern/doc/v632/TROOT_8cxx_source.html:70196,Deployability,update,update,70196,"lMappedFunction::MakeFunctor(""gPad"", ""TVirtualPad*"", TVirtualPad::Pad);; 1801 TGlobalMappedFunction::MakeFunctor(""gVirtualX"", ""TVirtualX*"", TVirtualX::Instance);; 1802 TGlobalMappedFunction::MakeFunctor(""gDirectory"", ""TDirectory*"", TDirectory::CurrentDirectory);; 1803 ; 1804 // Don't let TGlobalMappedFunction delete our globals, now that we take them.; 1805 fGlobals->AddAll(&TGlobalMappedFunction::GetEarlyRegisteredGlobals());; 1806 TGlobalMappedFunction::GetEarlyRegisteredGlobals().SetOwner(kFALSE);; 1807 TGlobalMappedFunction::GetEarlyRegisteredGlobals().Clear();; 1808 }; 1809 ; 1810 if (!fInterpreter); 1811 Fatal(""GetListOfGlobals"", ""fInterpreter not initialized"");; 1812 ; 1813 if (load) fGlobals->Load();; 1814 ; 1815 return fGlobals;; 1816}; 1817 ; 1818////////////////////////////////////////////////////////////////////////////////; 1819/// Return list containing the TFunctions currently defined.; 1820/// Since functions are created and deleted during execution of the; 1821/// program, we need to update the list of functions every time we; 1822/// execute this method. However, when calling this function in; 1823/// a (tight) loop where no interpreter symbols will be created; 1824/// you can set load=kFALSE (default).; 1825 ; 1826TCollection *TROOT::GetListOfGlobalFunctions(Bool_t load); 1827{; 1828 R__LOCKGUARD(gROOTMutex);; 1829 ; 1830 if (!fGlobalFunctions) {; 1831 fGlobalFunctions = new TListOfFunctions(nullptr);; 1832 }; 1833 ; 1834 if (!fInterpreter); 1835 Fatal(""GetListOfGlobalFunctions"", ""fInterpreter not initialized"");; 1836 ; 1837 // A thread that calls with load==true and a thread that calls with load==false; 1838 // will conflict here (the load==true will be updating the list while the; 1839 // other is reading it). To solve the problem, we could use a read-write lock; 1840 // inside the list itself.; 1841 if (load) fGlobalFunctions->Load();; 1842 ; 1843 return fGlobalFunctions;; 1844}; 1845 ; 1846///////////////////////////////////////////////////////",MatchSource.WIKI,doc/v632/TROOT_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/TROOT_8cxx_source.html
https://root.cern/doc/v632/TROOT_8cxx_source.html:88177,Deployability,update,update,88177,"86 char *mac = gSystem->Which(GetMacroPath(), fname, kReadPermission);; 2287 if (!mac) {; 2288 if (!check); 2289 Error(""LoadMacro"", ""macro %s not found in path %s"", fname.Data(), GetMacroPath());; 2290 *terr = TInterpreter::kFatal;; 2291 } else {; 2292 err = 0;; 2293 if (!check) {; 2294 fname = mac;; 2295 fname += aclicMode;; 2296 fname += io;; 2297 gInterpreter->LoadMacro(fname.Data(), (TInterpreter::EErrorCode*)terr);; 2298 if (*terr); 2299 err = -1;; 2300 }; 2301 }; 2302 delete [] mac;; 2303 }; 2304 return err;; 2305}; 2306 ; 2307////////////////////////////////////////////////////////////////////////////////; 2308/// Execute a macro in the interpreter. Equivalent to the command line; 2309/// command "".x filename"". If the filename has ""+"" or ""++"" appended; 2310/// the macro will be compiled by ACLiC. The filename must have the format:; 2311/// [path/]macro.C[+|++[g|O]][(args)].; 2312/// The possible error codes are defined by TInterpreter::EErrorCode.; 2313/// If padUpdate is true (default) update the current pad.; 2314/// Returns the macro return value.; 2315 ; 2316Longptr_t TROOT::Macro(const char *filename, Int_t *error, Bool_t padUpdate); 2317{; 2318 Longptr_t result = 0;; 2319 ; 2320 if (fInterpreter) {; 2321 TString aclicMode;; 2322 TString arguments;; 2323 TString io;; 2324 TString fname = gSystem->SplitAclicMode(filename, aclicMode, arguments, io);; 2325 ; 2326 char *mac = gSystem->Which(GetMacroPath(), fname, kReadPermission);; 2327 if (!mac) {; 2328 Error(""Macro"", ""macro %s not found in path %s"", fname.Data(), GetMacroPath());; 2329 if (error); 2330 *error = TInterpreter::kFatal;; 2331 } else {; 2332 fname = mac;; 2333 fname += aclicMode;; 2334 fname += arguments;; 2335 fname += io;; 2336 result = gInterpreter->ExecuteMacro(fname, (TInterpreter::EErrorCode*)error);; 2337 }; 2338 delete [] mac;; 2339 ; 2340 if (padUpdate && gPad); 2341 gPad->Update();; 2342 }; 2343 ; 2344 return result;; 2345}; 2346 ; 2347/////////////////////////////////////////////////",MatchSource.WIKI,doc/v632/TROOT_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/TROOT_8cxx_source.html
https://root.cern/doc/v632/TROOT_8cxx_source.html:93251,Deployability,release,release,93251,"(TInterpreter::EErrorCode*)error;; 2419 result = gInterpreter->Calc(sline, code);; 2420 }; 2421 ; 2422 return result;; 2423}; 2424 ; 2425////////////////////////////////////////////////////////////////////////////////; 2426/// Read Git commit information and branch name from the; 2427/// etc/gitinfo.txt file.; 2428 ; 2429void TROOT::ReadGitInfo(); 2430{; 2431 TString filename = ""gitinfo.txt"";; 2432 gSystem->PrependPathName(TROOT::GetEtcDir(), filename);; 2433 ; 2434 FILE *fp = fopen(filename, ""r"");; 2435 if (fp) {; 2436 TString s;; 2437 // read branch name; 2438 s.Gets(fp);; 2439 fGitBranch = s;; 2440 // read commit hash; 2441 s.Gets(fp);; 2442 fGitCommit = s;; 2443 // read date/time make was run; 2444 s.Gets(fp);; 2445 fGitDate = s;; 2446 fclose(fp);; 2447 } else {; 2448 Error(""ReadGitInfo()"", ""Cannot determine git info: etc/gitinfo.txt not found!"");; 2449 }; 2450}; 2451 ; 2452Bool_t &GetReadingObject() {; 2453 TTHREAD_TLS(Bool_t) fgReadingObject = false;; 2454 return fgReadingObject;; 2455}; 2456 ; 2457////////////////////////////////////////////////////////////////////////////////; 2458/// Deprecated (will be removed in next release).; 2459 ; 2460Bool_t TROOT::ReadingObject() const; 2461{; 2462 return GetReadingObject();; 2463}; 2464 ; 2465void TROOT::SetReadingObject(Bool_t flag); 2466{; 2467 GetReadingObject() = flag;; 2468}; 2469 ; 2470 ; 2471////////////////////////////////////////////////////////////////////////////////; 2472/// Return date/time make was run.; 2473 ; 2474const char *TROOT::GetGitDate(); 2475{; 2476 if (fGitDate == """") {; 2477 Int_t iday,imonth,iyear, ihour, imin;; 2478 static const char *months[] = { ""Jan"", ""Feb"", ""Mar"", ""Apr"", ""May"", ""Jun"",; 2479 ""Jul"", ""Aug"", ""Sep"", ""Oct"", ""Nov"", ""Dec"" };; 2480 Int_t idate = gROOT->GetBuiltDate();; 2481 Int_t itime = gROOT->GetBuiltTime();; 2482 iday = idate%100;; 2483 imonth = (idate/100)%100;; 2484 iyear = idate/10000;; 2485 ihour = itime/100;; 2486 imin = itime%100;; 2487 fGitDate.Form(""%s %02d %4d, %02d",MatchSource.WIKI,doc/v632/TROOT_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/TROOT_8cxx_source.html
https://root.cern/doc/v632/TROOT_8cxx_source.html:95014,Deployability,update,update,95014," = itime%100;; 2487 fGitDate.Form(""%s %02d %4d, %02d:%02d:00"", months[imonth-1], iday, iyear, ihour, imin);; 2488 }; 2489 return fGitDate;; 2490}; 2491 ; 2492////////////////////////////////////////////////////////////////////////////////; 2493/// Recursively remove this object from the list of Cleanups.; 2494/// Typically RecursiveRemove is implemented by classes that can contain; 2495/// mulitple references to a same object or shared ownership of the object; 2496/// with others.; 2497 ; 2498void TROOT::RecursiveRemove(TObject *obj); 2499{; 2500 R__READ_LOCKGUARD(ROOT::gCoreMutex);; 2501 ; 2502 fCleanups->RecursiveRemove(obj);; 2503}; 2504 ; 2505////////////////////////////////////////////////////////////////////////////////; 2506/// Refresh all browsers. Call this method when some command line; 2507/// command or script has changed the browser contents. Not needed; 2508/// for objects that have the kMustCleanup bit set. Most useful to; 2509/// update browsers that show the file system or other objects external; 2510/// to the running ROOT session.; 2511 ; 2512void TROOT::RefreshBrowsers(); 2513{; 2514 TIter next(GetListOfBrowsers());; 2515 TBrowser *b;; 2516 while ((b = (TBrowser*) next())); 2517 b->SetRefreshFlag(kTRUE);; 2518}; 2519////////////////////////////////////////////////////////////////////////////////; 2520/// Insure that the files, canvases and sockets are closed.; 2521 ; 2522static void CallCloseFiles(); 2523{; 2524 if (TROOT::Initialized() && ROOT::Internal::gROOTLocal) {; 2525 gROOT->CloseFiles();; 2526 }; 2527}; 2528 ; 2529////////////////////////////////////////////////////////////////////////////////; 2530/// Called by static dictionary initialization to register clang modules; 2531/// for headers. Calls TCling::RegisterModule() unless gCling; 2532/// is NULL, i.e. during startup, where the information is buffered in; 2533/// the static GetModuleHeaderInfoBuffer().; 2534 ; 2535void TROOT::RegisterModule(const char* modulename,; 2536 const char**",MatchSource.WIKI,doc/v632/TROOT_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/TROOT_8cxx_source.html
https://root.cern/doc/v632/TROOT_8cxx_source.html:113328,Deployability,install,installation,113328,"terpreter construction.; 2947/// These arguments are added to the existing flags (e.g. `-DNDEBUG`).; 2948/// They are evaluated once per process, at the time where TROOT (and thus; 2949/// TInterpreter) is constructed.; 2950/// Returns the new flags.; 2951 ; 2952const std::vector<std::string> &TROOT::AddExtraInterpreterArgs(const std::vector<std::string> &args) {; 2953 static std::vector<std::string> sArgs = {};; 2954 sArgs.insert(sArgs.begin(), args.begin(), args.end());; 2955 return sArgs;; 2956}; 2957 ; 2958////////////////////////////////////////////////////////////////////////////////; 2959/// INTERNAL function!; 2960/// Used by rootcling to inject interpreter arguments through a C-interface layer.; 2961 ; 2962const char**& TROOT::GetExtraInterpreterArgs() {; 2963 static const char** extraInterpArgs = nullptr;; 2964 return extraInterpArgs;; 2965}; 2966 ; 2967////////////////////////////////////////////////////////////////////////////////; 2968 ; 2969#ifdef ROOTPREFIX; 2970static Bool_t IgnorePrefix() {; 2971 static Bool_t ignorePrefix = gSystem->Getenv(""ROOTIGNOREPREFIX"");; 2972 return ignorePrefix;; 2973}; 2974#endif; 2975 ; 2976////////////////////////////////////////////////////////////////////////////////; 2977/// Get the rootsys directory in the installation. Static utility function.; 2978 ; 2979const TString& TROOT::GetRootSys() {; 2980 // Avoid returning a reference to a temporary because of the conversion; 2981 // between std::string and TString.; 2982 const static TString rootsys = ROOT::FoundationUtils::GetRootSys();; 2983 return rootsys;; 2984}; 2985 ; 2986////////////////////////////////////////////////////////////////////////////////; 2987/// Get the binary directory in the installation. Static utility function.; 2988 ; 2989const TString& TROOT::GetBinDir() {; 2990#ifdef ROOTBINDIR; 2991 if (IgnorePrefix()) {; 2992#endif; 2993 static TString rootbindir;; 2994 if (rootbindir.IsNull()) {; 2995 rootbindir = ""bin"";; 2996 gSystem->PrependPathName(GetRoot",MatchSource.WIKI,doc/v632/TROOT_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/TROOT_8cxx_source.html
https://root.cern/doc/v632/TROOT_8cxx_source.html:113773,Deployability,install,installation,113773,"TERNAL function!; 2960/// Used by rootcling to inject interpreter arguments through a C-interface layer.; 2961 ; 2962const char**& TROOT::GetExtraInterpreterArgs() {; 2963 static const char** extraInterpArgs = nullptr;; 2964 return extraInterpArgs;; 2965}; 2966 ; 2967////////////////////////////////////////////////////////////////////////////////; 2968 ; 2969#ifdef ROOTPREFIX; 2970static Bool_t IgnorePrefix() {; 2971 static Bool_t ignorePrefix = gSystem->Getenv(""ROOTIGNOREPREFIX"");; 2972 return ignorePrefix;; 2973}; 2974#endif; 2975 ; 2976////////////////////////////////////////////////////////////////////////////////; 2977/// Get the rootsys directory in the installation. Static utility function.; 2978 ; 2979const TString& TROOT::GetRootSys() {; 2980 // Avoid returning a reference to a temporary because of the conversion; 2981 // between std::string and TString.; 2982 const static TString rootsys = ROOT::FoundationUtils::GetRootSys();; 2983 return rootsys;; 2984}; 2985 ; 2986////////////////////////////////////////////////////////////////////////////////; 2987/// Get the binary directory in the installation. Static utility function.; 2988 ; 2989const TString& TROOT::GetBinDir() {; 2990#ifdef ROOTBINDIR; 2991 if (IgnorePrefix()) {; 2992#endif; 2993 static TString rootbindir;; 2994 if (rootbindir.IsNull()) {; 2995 rootbindir = ""bin"";; 2996 gSystem->PrependPathName(GetRootSys(), rootbindir);; 2997 }; 2998 return rootbindir;; 2999#ifdef ROOTBINDIR; 3000 } else {; 3001 const static TString rootbindir = ROOTBINDIR;; 3002 return rootbindir;; 3003 }; 3004#endif; 3005}; 3006 ; 3007////////////////////////////////////////////////////////////////////////////////; 3008/// Get the library directory in the installation. Static utility function.; 3009 ; 3010const TString& TROOT::GetLibDir() {; 3011#ifdef ROOTLIBDIR; 3012 if (IgnorePrefix()) {; 3013#endif; 3014 static TString rootlibdir;; 3015 if (rootlibdir.IsNull()) {; 3016 rootlibdir = ""lib"";; 3017 gSystem->PrependPathName(GetRo",MatchSource.WIKI,doc/v632/TROOT_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/TROOT_8cxx_source.html
https://root.cern/doc/v632/TROOT_8cxx_source.html:114383,Deployability,install,installation,114383,"#endif; 2975 ; 2976////////////////////////////////////////////////////////////////////////////////; 2977/// Get the rootsys directory in the installation. Static utility function.; 2978 ; 2979const TString& TROOT::GetRootSys() {; 2980 // Avoid returning a reference to a temporary because of the conversion; 2981 // between std::string and TString.; 2982 const static TString rootsys = ROOT::FoundationUtils::GetRootSys();; 2983 return rootsys;; 2984}; 2985 ; 2986////////////////////////////////////////////////////////////////////////////////; 2987/// Get the binary directory in the installation. Static utility function.; 2988 ; 2989const TString& TROOT::GetBinDir() {; 2990#ifdef ROOTBINDIR; 2991 if (IgnorePrefix()) {; 2992#endif; 2993 static TString rootbindir;; 2994 if (rootbindir.IsNull()) {; 2995 rootbindir = ""bin"";; 2996 gSystem->PrependPathName(GetRootSys(), rootbindir);; 2997 }; 2998 return rootbindir;; 2999#ifdef ROOTBINDIR; 3000 } else {; 3001 const static TString rootbindir = ROOTBINDIR;; 3002 return rootbindir;; 3003 }; 3004#endif; 3005}; 3006 ; 3007////////////////////////////////////////////////////////////////////////////////; 3008/// Get the library directory in the installation. Static utility function.; 3009 ; 3010const TString& TROOT::GetLibDir() {; 3011#ifdef ROOTLIBDIR; 3012 if (IgnorePrefix()) {; 3013#endif; 3014 static TString rootlibdir;; 3015 if (rootlibdir.IsNull()) {; 3016 rootlibdir = ""lib"";; 3017 gSystem->PrependPathName(GetRootSys(), rootlibdir);; 3018 }; 3019 return rootlibdir;; 3020#ifdef ROOTLIBDIR; 3021 } else {; 3022 const static TString rootlibdir = ROOTLIBDIR;; 3023 return rootlibdir;; 3024 }; 3025#endif; 3026}; 3027 ; 3028////////////////////////////////////////////////////////////////////////////////; 3029/// Get the shared libraries directory in the installation. Static utility function.; 3030 ; 3031const TString& TROOT::GetSharedLibDir() {; 3032#if defined(R__WIN32); 3033 return TROOT::GetBinDir();; 3034#else; 3035 return TROOT::G",MatchSource.WIKI,doc/v632/TROOT_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/TROOT_8cxx_source.html
https://root.cern/doc/v632/TROOT_8cxx_source.html:115002,Deployability,install,installation,115002," function.; 2988 ; 2989const TString& TROOT::GetBinDir() {; 2990#ifdef ROOTBINDIR; 2991 if (IgnorePrefix()) {; 2992#endif; 2993 static TString rootbindir;; 2994 if (rootbindir.IsNull()) {; 2995 rootbindir = ""bin"";; 2996 gSystem->PrependPathName(GetRootSys(), rootbindir);; 2997 }; 2998 return rootbindir;; 2999#ifdef ROOTBINDIR; 3000 } else {; 3001 const static TString rootbindir = ROOTBINDIR;; 3002 return rootbindir;; 3003 }; 3004#endif; 3005}; 3006 ; 3007////////////////////////////////////////////////////////////////////////////////; 3008/// Get the library directory in the installation. Static utility function.; 3009 ; 3010const TString& TROOT::GetLibDir() {; 3011#ifdef ROOTLIBDIR; 3012 if (IgnorePrefix()) {; 3013#endif; 3014 static TString rootlibdir;; 3015 if (rootlibdir.IsNull()) {; 3016 rootlibdir = ""lib"";; 3017 gSystem->PrependPathName(GetRootSys(), rootlibdir);; 3018 }; 3019 return rootlibdir;; 3020#ifdef ROOTLIBDIR; 3021 } else {; 3022 const static TString rootlibdir = ROOTLIBDIR;; 3023 return rootlibdir;; 3024 }; 3025#endif; 3026}; 3027 ; 3028////////////////////////////////////////////////////////////////////////////////; 3029/// Get the shared libraries directory in the installation. Static utility function.; 3030 ; 3031const TString& TROOT::GetSharedLibDir() {; 3032#if defined(R__WIN32); 3033 return TROOT::GetBinDir();; 3034#else; 3035 return TROOT::GetLibDir();; 3036#endif; 3037}; 3038 ; 3039////////////////////////////////////////////////////////////////////////////////; 3040/// Get the include directory in the installation. Static utility function.; 3041 ; 3042const TString& TROOT::GetIncludeDir() {; 3043 // Avoid returning a reference to a temporary because of the conversion; 3044 // between std::string and TString.; 3045 const static TString includedir = ROOT::FoundationUtils::GetIncludeDir();; 3046 return includedir;; 3047}; 3048 ; 3049////////////////////////////////////////////////////////////////////////////////; 3050/// Get the sysconfig direc",MatchSource.WIKI,doc/v632/TROOT_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/TROOT_8cxx_source.html
https://root.cern/doc/v632/TROOT_8cxx_source.html:115353,Deployability,install,installation,115353,"eturn rootbindir;; 3003 }; 3004#endif; 3005}; 3006 ; 3007////////////////////////////////////////////////////////////////////////////////; 3008/// Get the library directory in the installation. Static utility function.; 3009 ; 3010const TString& TROOT::GetLibDir() {; 3011#ifdef ROOTLIBDIR; 3012 if (IgnorePrefix()) {; 3013#endif; 3014 static TString rootlibdir;; 3015 if (rootlibdir.IsNull()) {; 3016 rootlibdir = ""lib"";; 3017 gSystem->PrependPathName(GetRootSys(), rootlibdir);; 3018 }; 3019 return rootlibdir;; 3020#ifdef ROOTLIBDIR; 3021 } else {; 3022 const static TString rootlibdir = ROOTLIBDIR;; 3023 return rootlibdir;; 3024 }; 3025#endif; 3026}; 3027 ; 3028////////////////////////////////////////////////////////////////////////////////; 3029/// Get the shared libraries directory in the installation. Static utility function.; 3030 ; 3031const TString& TROOT::GetSharedLibDir() {; 3032#if defined(R__WIN32); 3033 return TROOT::GetBinDir();; 3034#else; 3035 return TROOT::GetLibDir();; 3036#endif; 3037}; 3038 ; 3039////////////////////////////////////////////////////////////////////////////////; 3040/// Get the include directory in the installation. Static utility function.; 3041 ; 3042const TString& TROOT::GetIncludeDir() {; 3043 // Avoid returning a reference to a temporary because of the conversion; 3044 // between std::string and TString.; 3045 const static TString includedir = ROOT::FoundationUtils::GetIncludeDir();; 3046 return includedir;; 3047}; 3048 ; 3049////////////////////////////////////////////////////////////////////////////////; 3050/// Get the sysconfig directory in the installation. Static utility function.; 3051 ; 3052const TString& TROOT::GetEtcDir() {; 3053 // Avoid returning a reference to a temporary because of the conversion; 3054 // between std::string and TString.; 3055 const static TString etcdir = ROOT::FoundationUtils::GetEtcDir();; 3056 return etcdir;; 3057}; 3058 ; 3059///////////////////////////////////////////////////////////////////////",MatchSource.WIKI,doc/v632/TROOT_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/TROOT_8cxx_source.html
https://root.cern/doc/v632/TROOT_8cxx_source.html:115813,Deployability,install,installation,115813,19 return rootlibdir;; 3020#ifdef ROOTLIBDIR; 3021 } else {; 3022 const static TString rootlibdir = ROOTLIBDIR;; 3023 return rootlibdir;; 3024 }; 3025#endif; 3026}; 3027 ; 3028////////////////////////////////////////////////////////////////////////////////; 3029/// Get the shared libraries directory in the installation. Static utility function.; 3030 ; 3031const TString& TROOT::GetSharedLibDir() {; 3032#if defined(R__WIN32); 3033 return TROOT::GetBinDir();; 3034#else; 3035 return TROOT::GetLibDir();; 3036#endif; 3037}; 3038 ; 3039////////////////////////////////////////////////////////////////////////////////; 3040/// Get the include directory in the installation. Static utility function.; 3041 ; 3042const TString& TROOT::GetIncludeDir() {; 3043 // Avoid returning a reference to a temporary because of the conversion; 3044 // between std::string and TString.; 3045 const static TString includedir = ROOT::FoundationUtils::GetIncludeDir();; 3046 return includedir;; 3047}; 3048 ; 3049////////////////////////////////////////////////////////////////////////////////; 3050/// Get the sysconfig directory in the installation. Static utility function.; 3051 ; 3052const TString& TROOT::GetEtcDir() {; 3053 // Avoid returning a reference to a temporary because of the conversion; 3054 // between std::string and TString.; 3055 const static TString etcdir = ROOT::FoundationUtils::GetEtcDir();; 3056 return etcdir;; 3057}; 3058 ; 3059////////////////////////////////////////////////////////////////////////////////; 3060/// Get the data directory in the installation. Static utility function.; 3061 ; 3062const TString& TROOT::GetDataDir() {; 3063#ifdef ROOTDATADIR; 3064 if (IgnorePrefix()) {; 3065#endif; 3066 return GetRootSys();; 3067#ifdef ROOTDATADIR; 3068 } else {; 3069 const static TString rootdatadir = ROOTDATADIR;; 3070 return rootdatadir;; 3071 }; 3072#endif; 3073}; 3074 ; 3075////////////////////////////////////////////////////////////////////////////////; 3076/// Get the document,MatchSource.WIKI,doc/v632/TROOT_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/TROOT_8cxx_source.html
https://root.cern/doc/v632/TROOT_8cxx_source.html:116252,Deployability,install,installation,116252,GetBinDir();; 3034#else; 3035 return TROOT::GetLibDir();; 3036#endif; 3037}; 3038 ; 3039////////////////////////////////////////////////////////////////////////////////; 3040/// Get the include directory in the installation. Static utility function.; 3041 ; 3042const TString& TROOT::GetIncludeDir() {; 3043 // Avoid returning a reference to a temporary because of the conversion; 3044 // between std::string and TString.; 3045 const static TString includedir = ROOT::FoundationUtils::GetIncludeDir();; 3046 return includedir;; 3047}; 3048 ; 3049////////////////////////////////////////////////////////////////////////////////; 3050/// Get the sysconfig directory in the installation. Static utility function.; 3051 ; 3052const TString& TROOT::GetEtcDir() {; 3053 // Avoid returning a reference to a temporary because of the conversion; 3054 // between std::string and TString.; 3055 const static TString etcdir = ROOT::FoundationUtils::GetEtcDir();; 3056 return etcdir;; 3057}; 3058 ; 3059////////////////////////////////////////////////////////////////////////////////; 3060/// Get the data directory in the installation. Static utility function.; 3061 ; 3062const TString& TROOT::GetDataDir() {; 3063#ifdef ROOTDATADIR; 3064 if (IgnorePrefix()) {; 3065#endif; 3066 return GetRootSys();; 3067#ifdef ROOTDATADIR; 3068 } else {; 3069 const static TString rootdatadir = ROOTDATADIR;; 3070 return rootdatadir;; 3071 }; 3072#endif; 3073}; 3074 ; 3075////////////////////////////////////////////////////////////////////////////////; 3076/// Get the documentation directory in the installation. Static utility function.; 3077 ; 3078const TString& TROOT::GetDocDir() {; 3079#ifdef ROOTDOCDIR; 3080 if (IgnorePrefix()) {; 3081#endif; 3082 return GetRootSys();; 3083#ifdef ROOTDOCDIR; 3084 } else {; 3085 const static TString rootdocdir = ROOTDOCDIR;; 3086 return rootdocdir;; 3087 }; 3088#endif; 3089}; 3090 ; 3091////////////////////////////////////////////////////////////////////////////////; 3092/// Get,MatchSource.WIKI,doc/v632/TROOT_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/TROOT_8cxx_source.html
https://root.cern/doc/v632/TROOT_8cxx_source.html:116718,Deployability,install,installation,116718," conversion; 3044 // between std::string and TString.; 3045 const static TString includedir = ROOT::FoundationUtils::GetIncludeDir();; 3046 return includedir;; 3047}; 3048 ; 3049////////////////////////////////////////////////////////////////////////////////; 3050/// Get the sysconfig directory in the installation. Static utility function.; 3051 ; 3052const TString& TROOT::GetEtcDir() {; 3053 // Avoid returning a reference to a temporary because of the conversion; 3054 // between std::string and TString.; 3055 const static TString etcdir = ROOT::FoundationUtils::GetEtcDir();; 3056 return etcdir;; 3057}; 3058 ; 3059////////////////////////////////////////////////////////////////////////////////; 3060/// Get the data directory in the installation. Static utility function.; 3061 ; 3062const TString& TROOT::GetDataDir() {; 3063#ifdef ROOTDATADIR; 3064 if (IgnorePrefix()) {; 3065#endif; 3066 return GetRootSys();; 3067#ifdef ROOTDATADIR; 3068 } else {; 3069 const static TString rootdatadir = ROOTDATADIR;; 3070 return rootdatadir;; 3071 }; 3072#endif; 3073}; 3074 ; 3075////////////////////////////////////////////////////////////////////////////////; 3076/// Get the documentation directory in the installation. Static utility function.; 3077 ; 3078const TString& TROOT::GetDocDir() {; 3079#ifdef ROOTDOCDIR; 3080 if (IgnorePrefix()) {; 3081#endif; 3082 return GetRootSys();; 3083#ifdef ROOTDOCDIR; 3084 } else {; 3085 const static TString rootdocdir = ROOTDOCDIR;; 3086 return rootdocdir;; 3087 }; 3088#endif; 3089}; 3090 ; 3091////////////////////////////////////////////////////////////////////////////////; 3092/// Get the macro directory in the installation. Static utility function.; 3093 ; 3094const TString& TROOT::GetMacroDir() {; 3095#ifdef ROOTMACRODIR; 3096 if (IgnorePrefix()) {; 3097#endif; 3098 static TString rootmacrodir;; 3099 if (rootmacrodir.IsNull()) {; 3100 rootmacrodir = ""macros"";; 3101 gSystem->PrependPathName(GetRootSys(), rootmacrodir);; 3102 }; 3103 return rootm",MatchSource.WIKI,doc/v632/TROOT_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/TROOT_8cxx_source.html
https://root.cern/doc/v632/TROOT_8cxx_source.html:117170,Deployability,install,installation,117170,"nversion; 3054 // between std::string and TString.; 3055 const static TString etcdir = ROOT::FoundationUtils::GetEtcDir();; 3056 return etcdir;; 3057}; 3058 ; 3059////////////////////////////////////////////////////////////////////////////////; 3060/// Get the data directory in the installation. Static utility function.; 3061 ; 3062const TString& TROOT::GetDataDir() {; 3063#ifdef ROOTDATADIR; 3064 if (IgnorePrefix()) {; 3065#endif; 3066 return GetRootSys();; 3067#ifdef ROOTDATADIR; 3068 } else {; 3069 const static TString rootdatadir = ROOTDATADIR;; 3070 return rootdatadir;; 3071 }; 3072#endif; 3073}; 3074 ; 3075////////////////////////////////////////////////////////////////////////////////; 3076/// Get the documentation directory in the installation. Static utility function.; 3077 ; 3078const TString& TROOT::GetDocDir() {; 3079#ifdef ROOTDOCDIR; 3080 if (IgnorePrefix()) {; 3081#endif; 3082 return GetRootSys();; 3083#ifdef ROOTDOCDIR; 3084 } else {; 3085 const static TString rootdocdir = ROOTDOCDIR;; 3086 return rootdocdir;; 3087 }; 3088#endif; 3089}; 3090 ; 3091////////////////////////////////////////////////////////////////////////////////; 3092/// Get the macro directory in the installation. Static utility function.; 3093 ; 3094const TString& TROOT::GetMacroDir() {; 3095#ifdef ROOTMACRODIR; 3096 if (IgnorePrefix()) {; 3097#endif; 3098 static TString rootmacrodir;; 3099 if (rootmacrodir.IsNull()) {; 3100 rootmacrodir = ""macros"";; 3101 gSystem->PrependPathName(GetRootSys(), rootmacrodir);; 3102 }; 3103 return rootmacrodir;; 3104#ifdef ROOTMACRODIR; 3105 } else {; 3106 const static TString rootmacrodir = ROOTMACRODIR;; 3107 return rootmacrodir;; 3108 }; 3109#endif; 3110}; 3111 ; 3112////////////////////////////////////////////////////////////////////////////////; 3113/// Get the tutorials directory in the installation. Static utility function.; 3114 ; 3115const TString& TROOT::GetTutorialDir() {; 3116#ifdef ROOTTUTDIR; 3117 if (IgnorePrefix()) {; 3118#endif; 3119 st",MatchSource.WIKI,doc/v632/TROOT_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/TROOT_8cxx_source.html
https://root.cern/doc/v632/TROOT_8cxx_source.html:117807,Deployability,install,installation,117807,"////////////////////////////////////////////////////////////////////; 3076/// Get the documentation directory in the installation. Static utility function.; 3077 ; 3078const TString& TROOT::GetDocDir() {; 3079#ifdef ROOTDOCDIR; 3080 if (IgnorePrefix()) {; 3081#endif; 3082 return GetRootSys();; 3083#ifdef ROOTDOCDIR; 3084 } else {; 3085 const static TString rootdocdir = ROOTDOCDIR;; 3086 return rootdocdir;; 3087 }; 3088#endif; 3089}; 3090 ; 3091////////////////////////////////////////////////////////////////////////////////; 3092/// Get the macro directory in the installation. Static utility function.; 3093 ; 3094const TString& TROOT::GetMacroDir() {; 3095#ifdef ROOTMACRODIR; 3096 if (IgnorePrefix()) {; 3097#endif; 3098 static TString rootmacrodir;; 3099 if (rootmacrodir.IsNull()) {; 3100 rootmacrodir = ""macros"";; 3101 gSystem->PrependPathName(GetRootSys(), rootmacrodir);; 3102 }; 3103 return rootmacrodir;; 3104#ifdef ROOTMACRODIR; 3105 } else {; 3106 const static TString rootmacrodir = ROOTMACRODIR;; 3107 return rootmacrodir;; 3108 }; 3109#endif; 3110}; 3111 ; 3112////////////////////////////////////////////////////////////////////////////////; 3113/// Get the tutorials directory in the installation. Static utility function.; 3114 ; 3115const TString& TROOT::GetTutorialDir() {; 3116#ifdef ROOTTUTDIR; 3117 if (IgnorePrefix()) {; 3118#endif; 3119 static TString roottutdir;; 3120 if (roottutdir.IsNull()) {; 3121 roottutdir = ""tutorials"";; 3122 gSystem->PrependPathName(GetRootSys(), roottutdir);; 3123 }; 3124 return roottutdir;; 3125#ifdef ROOTTUTDIR; 3126 } else {; 3127 const static TString roottutdir = ROOTTUTDIR;; 3128 return roottutdir;; 3129 }; 3130#endif; 3131}; 3132 ; 3133////////////////////////////////////////////////////////////////////////////////; 3134/// Shut down ROOT.; 3135 ; 3136void TROOT::ShutDown(); 3137{; 3138 if (gROOT); 3139 gROOT->EndOfProcessCleanups();; 3140 else if (gInterpreter); 3141 gInterpreter->ShutDown();; 3142}; 3143 ; 3144//////////////",MatchSource.WIKI,doc/v632/TROOT_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/TROOT_8cxx_source.html
https://root.cern/doc/v632/TROOT_8cxx_source.html:118709,Deployability,install,installation,118709,"const static TString rootmacrodir = ROOTMACRODIR;; 3107 return rootmacrodir;; 3108 }; 3109#endif; 3110}; 3111 ; 3112////////////////////////////////////////////////////////////////////////////////; 3113/// Get the tutorials directory in the installation. Static utility function.; 3114 ; 3115const TString& TROOT::GetTutorialDir() {; 3116#ifdef ROOTTUTDIR; 3117 if (IgnorePrefix()) {; 3118#endif; 3119 static TString roottutdir;; 3120 if (roottutdir.IsNull()) {; 3121 roottutdir = ""tutorials"";; 3122 gSystem->PrependPathName(GetRootSys(), roottutdir);; 3123 }; 3124 return roottutdir;; 3125#ifdef ROOTTUTDIR; 3126 } else {; 3127 const static TString roottutdir = ROOTTUTDIR;; 3128 return roottutdir;; 3129 }; 3130#endif; 3131}; 3132 ; 3133////////////////////////////////////////////////////////////////////////////////; 3134/// Shut down ROOT.; 3135 ; 3136void TROOT::ShutDown(); 3137{; 3138 if (gROOT); 3139 gROOT->EndOfProcessCleanups();; 3140 else if (gInterpreter); 3141 gInterpreter->ShutDown();; 3142}; 3143 ; 3144////////////////////////////////////////////////////////////////////////////////; 3145/// Get the source directory in the installation. Static utility function.; 3146 ; 3147const TString& TROOT::GetSourceDir() {; 3148#ifdef ROOTSRCDIR; 3149 if (IgnorePrefix()) {; 3150#endif; 3151 static TString rootsrcdir;; 3152 if (rootsrcdir.IsNull()) {; 3153 rootsrcdir = ""src"";; 3154 gSystem->PrependPathName(GetRootSys(), rootsrcdir);; 3155 }; 3156 return rootsrcdir;; 3157#ifdef ROOTSRCDIR; 3158 } else {; 3159 const static TString rootsrcdir = ROOTSRCDIR;; 3160 return rootsrcdir;; 3161 }; 3162#endif; 3163}; 3164 ; 3165////////////////////////////////////////////////////////////////////////////////; 3166/// Get the icon path in the installation. Static utility function.; 3167 ; 3168const TString& TROOT::GetIconPath() {; 3169#ifdef ROOTICONPATH; 3170 if (IgnorePrefix()) {; 3171#endif; 3172 static TString rooticonpath;; 3173 if (rooticonpath.IsNull()) {; 3174 rooticonpath = ""icons""",MatchSource.WIKI,doc/v632/TROOT_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/TROOT_8cxx_source.html
https://root.cern/doc/v632/TROOT_8cxx_source.html:119314,Deployability,install,installation,119314,"23 }; 3124 return roottutdir;; 3125#ifdef ROOTTUTDIR; 3126 } else {; 3127 const static TString roottutdir = ROOTTUTDIR;; 3128 return roottutdir;; 3129 }; 3130#endif; 3131}; 3132 ; 3133////////////////////////////////////////////////////////////////////////////////; 3134/// Shut down ROOT.; 3135 ; 3136void TROOT::ShutDown(); 3137{; 3138 if (gROOT); 3139 gROOT->EndOfProcessCleanups();; 3140 else if (gInterpreter); 3141 gInterpreter->ShutDown();; 3142}; 3143 ; 3144////////////////////////////////////////////////////////////////////////////////; 3145/// Get the source directory in the installation. Static utility function.; 3146 ; 3147const TString& TROOT::GetSourceDir() {; 3148#ifdef ROOTSRCDIR; 3149 if (IgnorePrefix()) {; 3150#endif; 3151 static TString rootsrcdir;; 3152 if (rootsrcdir.IsNull()) {; 3153 rootsrcdir = ""src"";; 3154 gSystem->PrependPathName(GetRootSys(), rootsrcdir);; 3155 }; 3156 return rootsrcdir;; 3157#ifdef ROOTSRCDIR; 3158 } else {; 3159 const static TString rootsrcdir = ROOTSRCDIR;; 3160 return rootsrcdir;; 3161 }; 3162#endif; 3163}; 3164 ; 3165////////////////////////////////////////////////////////////////////////////////; 3166/// Get the icon path in the installation. Static utility function.; 3167 ; 3168const TString& TROOT::GetIconPath() {; 3169#ifdef ROOTICONPATH; 3170 if (IgnorePrefix()) {; 3171#endif; 3172 static TString rooticonpath;; 3173 if (rooticonpath.IsNull()) {; 3174 rooticonpath = ""icons"";; 3175 gSystem->PrependPathName(GetRootSys(), rooticonpath);; 3176 }; 3177 return rooticonpath;; 3178#ifdef ROOTICONPATH; 3179 } else {; 3180 const static TString rooticonpath = ROOTICONPATH;; 3181 return rooticonpath;; 3182 }; 3183#endif; 3184}; 3185 ; 3186////////////////////////////////////////////////////////////////////////////////; 3187/// Get the fonts directory in the installation. Static utility function.; 3188 ; 3189const TString& TROOT::GetTTFFontDir() {; 3190#ifdef TTFFONTDIR; 3191 if (IgnorePrefix()) {; 3192#endif; 3193 static TString t",MatchSource.WIKI,doc/v632/TROOT_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/TROOT_8cxx_source.html
https://root.cern/doc/v632/TROOT_8cxx_source.html:119946,Deployability,install,installation,119946,"tion.; 3146 ; 3147const TString& TROOT::GetSourceDir() {; 3148#ifdef ROOTSRCDIR; 3149 if (IgnorePrefix()) {; 3150#endif; 3151 static TString rootsrcdir;; 3152 if (rootsrcdir.IsNull()) {; 3153 rootsrcdir = ""src"";; 3154 gSystem->PrependPathName(GetRootSys(), rootsrcdir);; 3155 }; 3156 return rootsrcdir;; 3157#ifdef ROOTSRCDIR; 3158 } else {; 3159 const static TString rootsrcdir = ROOTSRCDIR;; 3160 return rootsrcdir;; 3161 }; 3162#endif; 3163}; 3164 ; 3165////////////////////////////////////////////////////////////////////////////////; 3166/// Get the icon path in the installation. Static utility function.; 3167 ; 3168const TString& TROOT::GetIconPath() {; 3169#ifdef ROOTICONPATH; 3170 if (IgnorePrefix()) {; 3171#endif; 3172 static TString rooticonpath;; 3173 if (rooticonpath.IsNull()) {; 3174 rooticonpath = ""icons"";; 3175 gSystem->PrependPathName(GetRootSys(), rooticonpath);; 3176 }; 3177 return rooticonpath;; 3178#ifdef ROOTICONPATH; 3179 } else {; 3180 const static TString rooticonpath = ROOTICONPATH;; 3181 return rooticonpath;; 3182 }; 3183#endif; 3184}; 3185 ; 3186////////////////////////////////////////////////////////////////////////////////; 3187/// Get the fonts directory in the installation. Static utility function.; 3188 ; 3189const TString& TROOT::GetTTFFontDir() {; 3190#ifdef TTFFONTDIR; 3191 if (IgnorePrefix()) {; 3192#endif; 3193 static TString ttffontdir;; 3194 if (ttffontdir.IsNull()) {; 3195 ttffontdir = ""fonts"";; 3196 gSystem->PrependPathName(GetRootSys(), ttffontdir);; 3197 }; 3198 return ttffontdir;; 3199#ifdef TTFFONTDIR; 3200 } else {; 3201 const static TString ttffontdir = TTFFONTDIR;; 3202 return ttffontdir;; 3203 }; 3204#endif; 3205}; 3206 ; 3207////////////////////////////////////////////////////////////////////////////////; 3208/// Get the tutorials directory in the installation. Static utility function.; 3209/// Backward compatibility function - do not use for new code; 3210 ; 3211const char *TROOT::GetTutorialsDir() {; 3212 return GetTutori",MatchSource.WIKI,doc/v632/TROOT_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/TROOT_8cxx_source.html
https://root.cern/doc/v632/TROOT_8cxx_source.html:120564,Deployability,install,installation,120564,"const TString& TROOT::GetIconPath() {; 3169#ifdef ROOTICONPATH; 3170 if (IgnorePrefix()) {; 3171#endif; 3172 static TString rooticonpath;; 3173 if (rooticonpath.IsNull()) {; 3174 rooticonpath = ""icons"";; 3175 gSystem->PrependPathName(GetRootSys(), rooticonpath);; 3176 }; 3177 return rooticonpath;; 3178#ifdef ROOTICONPATH; 3179 } else {; 3180 const static TString rooticonpath = ROOTICONPATH;; 3181 return rooticonpath;; 3182 }; 3183#endif; 3184}; 3185 ; 3186////////////////////////////////////////////////////////////////////////////////; 3187/// Get the fonts directory in the installation. Static utility function.; 3188 ; 3189const TString& TROOT::GetTTFFontDir() {; 3190#ifdef TTFFONTDIR; 3191 if (IgnorePrefix()) {; 3192#endif; 3193 static TString ttffontdir;; 3194 if (ttffontdir.IsNull()) {; 3195 ttffontdir = ""fonts"";; 3196 gSystem->PrependPathName(GetRootSys(), ttffontdir);; 3197 }; 3198 return ttffontdir;; 3199#ifdef TTFFONTDIR; 3200 } else {; 3201 const static TString ttffontdir = TTFFONTDIR;; 3202 return ttffontdir;; 3203 }; 3204#endif; 3205}; 3206 ; 3207////////////////////////////////////////////////////////////////////////////////; 3208/// Get the tutorials directory in the installation. Static utility function.; 3209/// Backward compatibility function - do not use for new code; 3210 ; 3211const char *TROOT::GetTutorialsDir() {; 3212 return GetTutorialDir();; 3213}; kMarker@ kMarkerDefinition Buttons.h:34; kCurlyArc@ kCurlyArcDefinition Buttons.h:38; kPad@ kPadDefinition Buttons.h:30; kPolyLine@ kPolyLineDefinition Buttons.h:28; kDiamond@ kDiamondDefinition Buttons.h:37; kPave@ kPaveDefinition Buttons.h:31; kArrow@ kArrowDefinition Buttons.h:33; kPaveText@ kPaveTextDefinition Buttons.h:32; kCutG@ kCutGDefinition Buttons.h:38; kLine@ kLineDefinition Buttons.h:33; kPavesText@ kPavesTextDefinition Buttons.h:32; kCurlyLine@ kCurlyLineDefinition Buttons.h:38; kPaveLabel@ kPaveLabelDefinition Buttons.h:31; kButton@ kButtonDefinition Buttons.h:37; kEllipse@ kEllipseDe",MatchSource.WIKI,doc/v632/TROOT_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/TROOT_8cxx_source.html
https://root.cern/doc/v632/TROOT_8cxx_source.html:146431,Deployability,install,installation,146431,"x:1035; TROOT::fGeometriesTSeqCollection * fGeometriesList of geometries.Definition TROOT.h:154; TROOT::fCutClassNameTString fCutClassNameName of default CutG class in graphics editor.Definition TROOT.h:170; TROOT::fInterpreterTInterpreter * fInterpreterCommand interpreter.Definition TROOT.h:125; TROOT::FwdDeclArgsToKeepCollection_tstd::vector< std::pair< std::string, int > > FwdDeclArgsToKeepCollection_tDefinition TROOT.h:187; TROOT::fVersionTimeInt_t fVersionTimeTime of ROOT version (ex 1152)Definition TROOT.h:117; TROOT::EndOfProcessCleanupsvoid EndOfProcessCleanups()Execute the cleanups necessary at the end of the process, in particular those that must be executed b...Definition TROOT.cxx:1248; TROOT::fBatchBool_t fBatchTrue if session without graphics.Definition TROOT.h:126; TROOT::GetListOfFilesTSeqCollection * GetListOfFiles() constDefinition TROOT.h:237; TROOT::fEscapeBool_t fEscapeTrue if ESC has been pressed.Definition TROOT.h:135; TROOT::GetBinDirstatic const TString & GetBinDir()Get the binary directory in the installation. Static utility function.Definition TROOT.cxx:2989; TROOT::fVersionIntInt_t fVersionIntROOT version in integer format (501)Definition TROOT.h:114; TROOT::GetIncludeDirstatic const TString & GetIncludeDir()Get the include directory in the installation. Static utility function.Definition TROOT.cxx:3042; TROOT::fFromPopUpBool_t fFromPopUpTrue if command executed from a popup menu.Definition TROOT.h:131; TROOT::Idlevoid Idle(UInt_t idleTimeInSec, const char *command=nullptr)Execute command when system has been idle for idleTimeInSec seconds.Definition TROOT.cxx:1892; TROOT::fSocketsTSeqCollection * fSocketsList of network sockets.Definition TROOT.h:148; TROOT::lsvoid ls(Option_t *option="""") const overrideTo list all objects of the application.Definition TROOT.cxx:2250; TROOT::GetMacroPathstatic const char * GetMacroPath()Get macro search path. Static utility function.Definition TROOT.cxx:2762; TROOT::fFunctionsTCollection * fFunctionsList ",MatchSource.WIKI,doc/v632/TROOT_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/TROOT_8cxx_source.html
https://root.cern/doc/v632/TROOT_8cxx_source.html:146682,Deployability,install,installation,146682,"erpreterCommand interpreter.Definition TROOT.h:125; TROOT::FwdDeclArgsToKeepCollection_tstd::vector< std::pair< std::string, int > > FwdDeclArgsToKeepCollection_tDefinition TROOT.h:187; TROOT::fVersionTimeInt_t fVersionTimeTime of ROOT version (ex 1152)Definition TROOT.h:117; TROOT::EndOfProcessCleanupsvoid EndOfProcessCleanups()Execute the cleanups necessary at the end of the process, in particular those that must be executed b...Definition TROOT.cxx:1248; TROOT::fBatchBool_t fBatchTrue if session without graphics.Definition TROOT.h:126; TROOT::GetListOfFilesTSeqCollection * GetListOfFiles() constDefinition TROOT.h:237; TROOT::fEscapeBool_t fEscapeTrue if ESC has been pressed.Definition TROOT.h:135; TROOT::GetBinDirstatic const TString & GetBinDir()Get the binary directory in the installation. Static utility function.Definition TROOT.cxx:2989; TROOT::fVersionIntInt_t fVersionIntROOT version in integer format (501)Definition TROOT.h:114; TROOT::GetIncludeDirstatic const TString & GetIncludeDir()Get the include directory in the installation. Static utility function.Definition TROOT.cxx:3042; TROOT::fFromPopUpBool_t fFromPopUpTrue if command executed from a popup menu.Definition TROOT.h:131; TROOT::Idlevoid Idle(UInt_t idleTimeInSec, const char *command=nullptr)Execute command when system has been idle for idleTimeInSec seconds.Definition TROOT.cxx:1892; TROOT::fSocketsTSeqCollection * fSocketsList of network sockets.Definition TROOT.h:148; TROOT::lsvoid ls(Option_t *option="""") const overrideTo list all objects of the application.Definition TROOT.cxx:2250; TROOT::GetMacroPathstatic const char * GetMacroPath()Get macro search path. Static utility function.Definition TROOT.cxx:2762; TROOT::fFunctionsTCollection * fFunctionsList of analytic functions.Definition TROOT.h:151; TROOT::SaveContextvoid SaveContext()Save the current interpreter context.Definition TROOT.cxx:2671; TROOT::IsExecutingMacroBool_t IsExecutingMacro() constDefinition TROOT.h:280; TROOT::GetTypeTDataType",MatchSource.WIKI,doc/v632/TROOT_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/TROOT_8cxx_source.html
https://root.cern/doc/v632/TROOT_8cxx_source.html:149587,Deployability,install,installation,149587,"adGitInfovoid ReadGitInfo()Read Git commit SHA1 and branch name.Definition TROOT.cxx:2429; TROOT::fgRootInitstatic Bool_t fgRootInitSingleton initialization flag.Definition TROOT.h:103; TROOT::RefreshBrowsersvoid RefreshBrowsers()Refresh all browsers.Definition TROOT.cxx:2512; TROOT::CloseFilesvoid CloseFiles()Close any files and sockets that gROOT knows about.Definition TROOT.cxx:1168; TROOT::fApplicationstd::atomic< TApplication * > fApplicationPointer to current application.Definition TROOT.h:124; TROOT::FindObjectPathNameconst char * FindObjectPathName(const TObject *obj) constReturn path name of obj somewhere in the //root/... path.Definition TROOT.cxx:1473; TROOT::ConvertVersionInt2Codestatic Int_t ConvertVersionInt2Code(Int_t v)Convert version as an integer to version code as used in RVersion.h.Definition TROOT.cxx:2930; TROOT::ResetClassSavedvoid ResetClassSaved()Reset the ClassSaved status of all classes.Definition TROOT.cxx:1096; TROOT::GetTTFFontDirstatic const TString & GetTTFFontDir()Get the fonts directory in the installation. Static utility function.Definition TROOT.cxx:3189; TROOT::fForceStyleBool_t fForceStyleForce setting of current style when reading objects.Definition TROOT.h:133; TROOT::MakeDefCanvasTCanvas * MakeDefCanvas() constReturn a default canvas.Definition TROOT.cxx:1554; TROOT::fTypesTCollection * fTypesList of data types definition.Definition TROOT.h:141; TROOT::GetColorTColor * GetColor(Int_t color) constReturn address of color with index color.Definition TROOT.cxx:1536; TROOT::GetGlobalTGlobal * GetGlobal(const char *name, Bool_t load=kFALSE) constReturn pointer to global variable by name.Definition TROOT.cxx:1631; TROOT::FindSTLClassTClass * FindSTLClass(const char *name, Bool_t load, Bool_t silent=kFALSE) constreturn a TClass object corresponding to 'name' assuming it is an STL container.Definition TROOT.cxx:1484; TROOT::fStreamerInfoTSeqCollection * fStreamerInfoList of active StreamerInfo classes.Definition TROOT.h:159; TROOT::Ap",MatchSource.WIKI,doc/v632/TROOT_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/TROOT_8cxx_source.html
https://root.cern/doc/v632/TROOT_8cxx_source.html:150743,Deployability,install,installation,150743,"current style when reading objects.Definition TROOT.h:133; TROOT::MakeDefCanvasTCanvas * MakeDefCanvas() constReturn a default canvas.Definition TROOT.cxx:1554; TROOT::fTypesTCollection * fTypesList of data types definition.Definition TROOT.h:141; TROOT::GetColorTColor * GetColor(Int_t color) constReturn address of color with index color.Definition TROOT.cxx:1536; TROOT::GetGlobalTGlobal * GetGlobal(const char *name, Bool_t load=kFALSE) constReturn pointer to global variable by name.Definition TROOT.cxx:1631; TROOT::FindSTLClassTClass * FindSTLClass(const char *name, Bool_t load, Bool_t silent=kFALSE) constreturn a TClass object corresponding to 'name' assuming it is an STL container.Definition TROOT.cxx:1484; TROOT::fStreamerInfoTSeqCollection * fStreamerInfoList of active StreamerInfo classes.Definition TROOT.h:159; TROOT::Appendvoid Append(TObject *obj, Bool_t replace=kFALSE) overrideAppend object to this directory.Definition TROOT.cxx:1047; TROOT::GetIconPathstatic const TString & GetIconPath()Get the icon path in the installation. Static utility function.Definition TROOT.cxx:3168; TROOT::GetListOfGlobalFunctionsTCollection * GetListOfGlobalFunctions(Bool_t load=kFALSE)Return list containing the TFunctions currently defined.Definition TROOT.cxx:1826; TROOT::fGitDateTString fGitDateDate and time when make was run.Definition TROOT.h:122; TROOT::fSpecialsTSeqCollection * fSpecialsList of special objects.Definition TROOT.h:156; TROOT::GetListOfFunctionTemplatesTCollection * GetListOfFunctionTemplates()Definition TROOT.cxx:1771; TROOT::RegisterModulestatic void RegisterModule(const char *modulename, const char **headers, const char **includePaths, const char *payLoadCode, const char *fwdDeclCode, void(*triggerFunc)(), const FwdDeclArgsToKeepCollection_t &fwdDeclsArgToSkip, const char **classesHeaders, bool hasCxxModule=false)Called by static dictionary initialization to register clang modules for headers.Definition TROOT.cxx:2535; TROOT::FindObjectTObject * FindObjec",MatchSource.WIKI,doc/v632/TROOT_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/TROOT_8cxx_source.html
https://root.cern/doc/v632/TROOT_8cxx_source.html:153600,Deployability,install,installation,153600,"nter to style with name.Definition TROOT.cxx:1579; TROOT::GetListOfEnumsTCollection * GetListOfEnums(Bool_t load=kFALSE)Definition TROOT.cxx:1754; TROOT::ProcessLineSyncLongptr_t ProcessLineSync(const char *line, Int_t *error=nullptr)Process interpreter command via TApplication::ProcessLine().Definition TROOT.cxx:2390; TROOT::InitInterpretervoid InitInterpreter()Initialize interpreter (cling)Definition TROOT.cxx:2064; TROOT::GetListOfGlobalsTCollection * GetListOfGlobals(Bool_t load=kFALSE)Return list containing the TGlobals currently defined.Definition TROOT.cxx:1788; TROOT::SetDirLevelstatic void SetDirLevel(Int_t level=0)Return Indentation level for ls().Definition TROOT.cxx:2914; TROOT::fSecContextsTSeqCollection * fSecContextsList of security contexts (TSecContext)Definition TROOT.h:161; TROOT::fWebDisplayTString fWebDisplayIf not empty it defines where web graphics should be rendered (cef, qt5, browser.....Definition TROOT.h:127; TROOT::GetTutorialsDirstatic const char * GetTutorialsDir()Get the tutorials directory in the installation.Definition TROOT.cxx:3211; TROOT::GetListOfFunctionOverloadsTCollection * GetListOfFunctionOverloads(const char *name) constReturn the collection of functions named ""name"".Definition TROOT.cxx:1672; TROOT::fCleanupsTSeqCollection * fCleanupsList of recursiveRemove collections.Definition TROOT.h:157; TROOT::Initializedstatic Bool_t Initialized()Return kTRUE if the TROOT object has been initialized.Definition TROOT.cxx:2906; TROOT::SetBatchvoid SetBatch(Bool_t batch=kTRUE)Set batch mode for ROOT If the argument evaluates to true, the session does not use interactive graph...Definition TROOT.cxx:2803; TROOT::fLineIsProcessingInt_t fLineIsProcessingTo synchronize multi-threads.Definition TROOT.h:100; TROOT::GetSourceDirstatic const TString & GetSourceDir()Get the source directory in the installation. Static utility function.Definition TROOT.cxx:3147; TROOT::GetMacroDirstatic const TString & GetMacroDir()Get the macro directory in the",MatchSource.WIKI,doc/v632/TROOT_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/TROOT_8cxx_source.html
https://root.cern/doc/v632/TROOT_8cxx_source.html:154407,Deployability,install,installation,154407,":fWebDisplayTString fWebDisplayIf not empty it defines where web graphics should be rendered (cef, qt5, browser.....Definition TROOT.h:127; TROOT::GetTutorialsDirstatic const char * GetTutorialsDir()Get the tutorials directory in the installation.Definition TROOT.cxx:3211; TROOT::GetListOfFunctionOverloadsTCollection * GetListOfFunctionOverloads(const char *name) constReturn the collection of functions named ""name"".Definition TROOT.cxx:1672; TROOT::fCleanupsTSeqCollection * fCleanupsList of recursiveRemove collections.Definition TROOT.h:157; TROOT::Initializedstatic Bool_t Initialized()Return kTRUE if the TROOT object has been initialized.Definition TROOT.cxx:2906; TROOT::SetBatchvoid SetBatch(Bool_t batch=kTRUE)Set batch mode for ROOT If the argument evaluates to true, the session does not use interactive graph...Definition TROOT.cxx:2803; TROOT::fLineIsProcessingInt_t fLineIsProcessingTo synchronize multi-threads.Definition TROOT.h:100; TROOT::GetSourceDirstatic const TString & GetSourceDir()Get the source directory in the installation. Static utility function.Definition TROOT.cxx:3147; TROOT::GetMacroDirstatic const TString & GetMacroDir()Get the macro directory in the installation. Static utility function.Definition TROOT.cxx:3094; TROOT::fGitCommitTString fGitCommitGit commit SHA1 of built.Definition TROOT.h:120; TROOT::ProcessLineLongptr_t ProcessLine(const char *line, Int_t *error=nullptr)Process interpreter command via TApplication::ProcessLine().Definition TROOT.cxx:2370; TROOT::fClosedObjectsTSeqCollection * fClosedObjectsList of closed objects from the list of files and sockets, so we can delete them if neededCl.Definition TROOT.h:145; TROOT::fTasksTSeqCollection * fTasksList of tasks.Definition TROOT.h:152; TROOT::fClipboardTSeqCollection * fClipboardList of clipboard objects.Definition TROOT.h:163; TROOT::GetGitDateconst char * GetGitDate()Return date/time make was run.Definition TROOT.cxx:2474; TROOT::SetEditorModevoid SetEditorMode(const char *mode=""""",MatchSource.WIKI,doc/v632/TROOT_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/TROOT_8cxx_source.html
https://root.cern/doc/v632/TROOT_8cxx_source.html:154557,Deployability,install,installation,154557,"TutorialsDirstatic const char * GetTutorialsDir()Get the tutorials directory in the installation.Definition TROOT.cxx:3211; TROOT::GetListOfFunctionOverloadsTCollection * GetListOfFunctionOverloads(const char *name) constReturn the collection of functions named ""name"".Definition TROOT.cxx:1672; TROOT::fCleanupsTSeqCollection * fCleanupsList of recursiveRemove collections.Definition TROOT.h:157; TROOT::Initializedstatic Bool_t Initialized()Return kTRUE if the TROOT object has been initialized.Definition TROOT.cxx:2906; TROOT::SetBatchvoid SetBatch(Bool_t batch=kTRUE)Set batch mode for ROOT If the argument evaluates to true, the session does not use interactive graph...Definition TROOT.cxx:2803; TROOT::fLineIsProcessingInt_t fLineIsProcessingTo synchronize multi-threads.Definition TROOT.h:100; TROOT::GetSourceDirstatic const TString & GetSourceDir()Get the source directory in the installation. Static utility function.Definition TROOT.cxx:3147; TROOT::GetMacroDirstatic const TString & GetMacroDir()Get the macro directory in the installation. Static utility function.Definition TROOT.cxx:3094; TROOT::fGitCommitTString fGitCommitGit commit SHA1 of built.Definition TROOT.h:120; TROOT::ProcessLineLongptr_t ProcessLine(const char *line, Int_t *error=nullptr)Process interpreter command via TApplication::ProcessLine().Definition TROOT.cxx:2370; TROOT::fClosedObjectsTSeqCollection * fClosedObjectsList of closed objects from the list of files and sockets, so we can delete them if neededCl.Definition TROOT.h:145; TROOT::fTasksTSeqCollection * fTasksList of tasks.Definition TROOT.h:152; TROOT::fClipboardTSeqCollection * fClipboardList of clipboard objects.Definition TROOT.h:163; TROOT::GetGitDateconst char * GetGitDate()Return date/time make was run.Definition TROOT.cxx:2474; TROOT::SetEditorModevoid SetEditorMode(const char *mode="""")Set editor mode.Definition TROOT.cxx:2704; TROOT::GetTutorialDirstatic const TString & GetTutorialDir()Get the tutorials directory in the installatio",MatchSource.WIKI,doc/v632/TROOT_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/TROOT_8cxx_source.html
https://root.cern/doc/v632/TROOT_8cxx_source.html:155505,Deployability,install,installation,155505,"OT.cxx:3147; TROOT::GetMacroDirstatic const TString & GetMacroDir()Get the macro directory in the installation. Static utility function.Definition TROOT.cxx:3094; TROOT::fGitCommitTString fGitCommitGit commit SHA1 of built.Definition TROOT.h:120; TROOT::ProcessLineLongptr_t ProcessLine(const char *line, Int_t *error=nullptr)Process interpreter command via TApplication::ProcessLine().Definition TROOT.cxx:2370; TROOT::fClosedObjectsTSeqCollection * fClosedObjectsList of closed objects from the list of files and sockets, so we can delete them if neededCl.Definition TROOT.h:145; TROOT::fTasksTSeqCollection * fTasksList of tasks.Definition TROOT.h:152; TROOT::fClipboardTSeqCollection * fClipboardList of clipboard objects.Definition TROOT.h:163; TROOT::GetGitDateconst char * GetGitDate()Return date/time make was run.Definition TROOT.cxx:2474; TROOT::SetEditorModevoid SetEditorMode(const char *mode="""")Set editor mode.Definition TROOT.cxx:2704; TROOT::GetTutorialDirstatic const TString & GetTutorialDir()Get the tutorials directory in the installation. Static utility function.Definition TROOT.cxx:3115; TROOT::~TROOTvirtual ~TROOT()Clean up and free resources used by ROOT (files, network sockets, shared memory segments,...Definition TROOT.cxx:867; TROOT::fColorsTSeqCollection * fColorsList of colors.Definition TROOT.h:153; TROOT::GetGlobalFunctionWithPrototypeTFunction * GetGlobalFunctionWithPrototype(const char *name, const char *proto=nullptr, Bool_t load=kFALSE)Return pointer to global function by name.Definition TROOT.cxx:1718; TROOT::GetListOfBrowsersTSeqCollection * GetListOfBrowsers() constDefinition TROOT.h:245; TROOT::ReadingObjectBool_t ReadingObject() constDeprecated (will be removed in next release).Definition TROOT.cxx:2460; TROOT::fStylesTSeqCollection * fStylesList of styles.Definition TROOT.h:150; TROOT::fVersionDateInt_t fVersionDateDate of ROOT version (ex 951226)Definition TROOT.h:116; TROOT::GetListOfColorsTSeqCollection * GetListOfColors() constDefinition",MatchSource.WIKI,doc/v632/TROOT_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/TROOT_8cxx_source.html
https://root.cern/doc/v632/TROOT_8cxx_source.html:156181,Deployability,release,release,156181,"ection * fClipboardList of clipboard objects.Definition TROOT.h:163; TROOT::GetGitDateconst char * GetGitDate()Return date/time make was run.Definition TROOT.cxx:2474; TROOT::SetEditorModevoid SetEditorMode(const char *mode="""")Set editor mode.Definition TROOT.cxx:2704; TROOT::GetTutorialDirstatic const TString & GetTutorialDir()Get the tutorials directory in the installation. Static utility function.Definition TROOT.cxx:3115; TROOT::~TROOTvirtual ~TROOT()Clean up and free resources used by ROOT (files, network sockets, shared memory segments,...Definition TROOT.cxx:867; TROOT::fColorsTSeqCollection * fColorsList of colors.Definition TROOT.h:153; TROOT::GetGlobalFunctionWithPrototypeTFunction * GetGlobalFunctionWithPrototype(const char *name, const char *proto=nullptr, Bool_t load=kFALSE)Return pointer to global function by name.Definition TROOT.cxx:1718; TROOT::GetListOfBrowsersTSeqCollection * GetListOfBrowsers() constDefinition TROOT.h:245; TROOT::ReadingObjectBool_t ReadingObject() constDeprecated (will be removed in next release).Definition TROOT.cxx:2460; TROOT::fStylesTSeqCollection * fStylesList of styles.Definition TROOT.h:150; TROOT::fVersionDateInt_t fVersionDateDate of ROOT version (ex 951226)Definition TROOT.h:116; TROOT::GetListOfColorsTSeqCollection * GetListOfColors() constDefinition TROOT.h:232; TROOT::MacroLongptr_t Macro(const char *filename, Int_t *error=nullptr, Bool_t padUpdate=kTRUE)Execute a macro in the interpreter.Definition TROOT.cxx:2316; TROOT::fBuiltTimeInt_t fBuiltTimeTime of ROOT built.Definition TROOT.h:119; TROOT::AddExtraInterpreterArgsstatic const std::vector< std::string > & AddExtraInterpreterArgs(const std::vector< std::string > &args)Provide command line arguments to the interpreter construction.Definition TROOT.cxx:2952; TROOT::GetClassTClass * GetClass(const char *name, Bool_t load=kTRUE, Bool_t silent=kFALSE) constReturn pointer to class with name. Obsolete, use TClass::GetClass directly.Definition TROOT.cxx:1518; TROOT::fSe",MatchSource.WIKI,doc/v632/TROOT_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/TROOT_8cxx_source.html
https://root.cern/doc/v632/TROOT_8cxx_source.html:157484,Deployability,install,installation,157484," constDefinition TROOT.h:232; TROOT::MacroLongptr_t Macro(const char *filename, Int_t *error=nullptr, Bool_t padUpdate=kTRUE)Execute a macro in the interpreter.Definition TROOT.cxx:2316; TROOT::fBuiltTimeInt_t fBuiltTimeTime of ROOT built.Definition TROOT.h:119; TROOT::AddExtraInterpreterArgsstatic const std::vector< std::string > & AddExtraInterpreterArgs(const std::vector< std::string > &args)Provide command line arguments to the interpreter construction.Definition TROOT.cxx:2952; TROOT::GetClassTClass * GetClass(const char *name, Bool_t load=kTRUE, Bool_t silent=kFALSE) constReturn pointer to class with name. Obsolete, use TClass::GetClass directly.Definition TROOT.cxx:1518; TROOT::fSelectPadTVirtualPad * fSelectPadCurrently selected pad.Definition TROOT.h:139; TROOT::fFilesTSeqCollection * fFilesList of files.Definition TROOT.h:146; TROOT::Browsevoid Browse(TBrowser *b) overrideAdd browsable objects to TBrowser.Definition TROOT.cxx:1056; TROOT::GetRootSysstatic const TString & GetRootSys()Get the rootsys directory in the installation. Static utility function.Definition TROOT.cxx:2979; TROOT::GetGlobalFunctionsTListOfFunctions * GetGlobalFunctions()Internal routine returning, and creating if necessary, the list of global function.Definition TROOT.cxx:1663; TROOT::fInterruptBool_t fInterruptTrue if macro should be interrupted.Definition TROOT.h:134; TROOT::fMustCleanBool_t fMustCleanTrue if object destructor scans canvases.Definition TROOT.h:132; TROOT::LoadClassInt_t LoadClass(const char *classname, const char *libname, Bool_t check=kFALSE)Check if class ""classname"" is known to the interpreter (in fact, this check is not needed anymore,...Definition TROOT.cxx:2183; TROOT::GetGlobalFunctionTFunction * GetGlobalFunction(const char *name, const char *params=nullptr, Bool_t load=kFALSE)Return pointer to global function by name.Definition TROOT.cxx:1685; TROOT::AddClassvoid AddClass(TClass *cl)Add a class to the list and map of classes.Definition TROOT.cxx:1025; TROOT",MatchSource.WIKI,doc/v632/TROOT_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/TROOT_8cxx_source.html
https://root.cern/doc/v632/TROOT_8cxx_source.html:159995,Deployability,install,installation,159995,"sLineFastLongptr_t ProcessLineFast(const char *line, Int_t *error=nullptr)Process interpreter command directly via CINT interpreter.Definition TROOT.cxx:2407; TROOT::ClassSavedBool_t ClassSaved(TClass *cl)return class status 'ClassSaved' for class cl This function is called by the SavePrimitive functions ...Definition TROOT.cxx:1083; TROOT::fGitBranchTString fGitBranchGit branch.Definition TROOT.h:121; TROOT::GetListOfTypesTCollection * GetListOfTypes(Bool_t load=kFALSE)Return a dynamic list giving access to all TDataTypes (typedefs) currently defined.Definition TROOT.cxx:1865; TROOT::fgDirLevelstatic Int_t fgDirLevelIndentation level for ls()Definition TROOT.h:102; TROOT::IsRootFileBool_t IsRootFile(const char *filename) constReturn true if the file is local and is (likely) to be a ROOT file.Definition TROOT.cxx:2230; TROOT::IndentLevelstatic void IndentLevel()Functions used by ls() to indent an object hierarchy.Definition TROOT.cxx:2891; TROOT::GetDocDirstatic const TString & GetDocDir()Get the documentation directory in the installation. Static utility function.Definition TROOT.cxx:3078; TROOT::GetEtcDirstatic const TString & GetEtcDir()Get the sysconfig directory in the installation. Static utility function.Definition TROOT.cxx:3052; TROOT::GetNclassesInt_t GetNclasses() constGet number of classes.Definition TROOT.cxx:1876; TROOT::GetExtraInterpreterArgsstatic const char **& GetExtraInterpreterArgs()INTERNAL function! Used by rootcling to inject interpreter arguments through a C-interface layer.Definition TROOT.cxx:2962; TROOT::SetMacroPathstatic void SetMacroPath(const char *newpath)Set or extend the macro search path.Definition TROOT.cxx:2788; TROOT::InitThreadsvoid InitThreads()Initialize threads library.Definition TROOT.cxx:2053; TROOT::fUUIDsTProcessUUID * fUUIDsPointer to TProcessID managing TUUIDs.Definition TROOT.h:166; TROOT::fConfigFeaturesTString fConfigFeaturesROOT ./configure detected build features.Definition TROOT.h:112; TROOT::GetFunctionTemplate",MatchSource.WIKI,doc/v632/TROOT_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/TROOT_8cxx_source.html
https://root.cern/doc/v632/TROOT_8cxx_source.html:160145,Deployability,install,installation,160145,:2407; TROOT::ClassSavedBool_t ClassSaved(TClass *cl)return class status 'ClassSaved' for class cl This function is called by the SavePrimitive functions ...Definition TROOT.cxx:1083; TROOT::fGitBranchTString fGitBranchGit branch.Definition TROOT.h:121; TROOT::GetListOfTypesTCollection * GetListOfTypes(Bool_t load=kFALSE)Return a dynamic list giving access to all TDataTypes (typedefs) currently defined.Definition TROOT.cxx:1865; TROOT::fgDirLevelstatic Int_t fgDirLevelIndentation level for ls()Definition TROOT.h:102; TROOT::IsRootFileBool_t IsRootFile(const char *filename) constReturn true if the file is local and is (likely) to be a ROOT file.Definition TROOT.cxx:2230; TROOT::IndentLevelstatic void IndentLevel()Functions used by ls() to indent an object hierarchy.Definition TROOT.cxx:2891; TROOT::GetDocDirstatic const TString & GetDocDir()Get the documentation directory in the installation. Static utility function.Definition TROOT.cxx:3078; TROOT::GetEtcDirstatic const TString & GetEtcDir()Get the sysconfig directory in the installation. Static utility function.Definition TROOT.cxx:3052; TROOT::GetNclassesInt_t GetNclasses() constGet number of classes.Definition TROOT.cxx:1876; TROOT::GetExtraInterpreterArgsstatic const char **& GetExtraInterpreterArgs()INTERNAL function! Used by rootcling to inject interpreter arguments through a C-interface layer.Definition TROOT.cxx:2962; TROOT::SetMacroPathstatic void SetMacroPath(const char *newpath)Set or extend the macro search path.Definition TROOT.cxx:2788; TROOT::InitThreadsvoid InitThreads()Initialize threads library.Definition TROOT.cxx:2053; TROOT::fUUIDsTProcessUUID * fUUIDsPointer to TProcessID managing TUUIDs.Definition TROOT.h:166; TROOT::fConfigFeaturesTString fConfigFeaturesROOT ./configure detected build features.Definition TROOT.h:112; TROOT::GetFunctionTemplateTFunctionTemplate * GetFunctionTemplate(const char *name)Definition TROOT.cxx:1618; TROOT::fPluginManagerTPluginManager * fPluginManagerKeeps track of p,MatchSource.WIKI,doc/v632/TROOT_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/TROOT_8cxx_source.html
https://root.cern/doc/v632/TROOT_8cxx_source.html:161817,Deployability,install,installation,161817,"ocessID managing TUUIDs.Definition TROOT.h:166; TROOT::fConfigFeaturesTString fConfigFeaturesROOT ./configure detected build features.Definition TROOT.h:112; TROOT::GetFunctionTemplateTFunctionTemplate * GetFunctionTemplate(const char *name)Definition TROOT.cxx:1618; TROOT::fPluginManagerTPluginManager * fPluginManagerKeeps track of plugin library handlers.Definition TROOT.h:169; TROOT::GetGeometryTObject * GetGeometry(const char *name) constReturn pointer to Geometry with name.Definition TROOT.cxx:1747; TROOT::RecursiveRemovevoid RecursiveRemove(TObject *obj) overrideRecursively remove this object from the list of Cleanups.Definition TROOT.cxx:2498; TROOT::fExecutingMacroBool_t fExecutingMacroTrue while executing a TMacro.Definition TROOT.h:136; TROOT::fBuiltDateInt_t fBuiltDateDate of ROOT built.Definition TROOT.h:118; TROOT::fIsWebDisplayBatchBool_t fIsWebDisplayBatchTrue if web widgets are not displayed.Definition TROOT.h:129; TROOT::GetSharedLibDirstatic const TString & GetSharedLibDir()Get the shared libraries directory in the installation. Static utility function.Definition TROOT.cxx:3031; TROOT::fMappedFilesTSeqCollection * fMappedFilesList of memory mapped files.Definition TROOT.h:147; TROOT::GetNtypesInt_t GetNtypes() constGet number of types.Definition TROOT.cxx:1884; TROOT::LoadMacroInt_t LoadMacro(const char *filename, Int_t *error=nullptr, Bool_t check=kFALSE)Load a macro in the interpreter's memory.Definition TROOT.cxx:2268; TROOT::GetFileTFile * GetFile() const overrideDefinition TROOT.h:260; TROOT::GetLibDirstatic const TString & GetLibDir()Get the library directory in the installation. Static utility function.Definition TROOT.cxx:3010; TROOT::fBrowsersTSeqCollection * fBrowsersList of browsers.Definition TROOT.h:155; TROOT::fDefCanvasNameTString fDefCanvasNameName of default canvas.Definition TROOT.h:171; TROOT::fGlobalFunctionsTListOfFunctions * fGlobalFunctionsList of global functions.Definition TROOT.h:144; TROOT::fBrowsablesTList * fBrowsablesL",MatchSource.WIKI,doc/v632/TROOT_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/TROOT_8cxx_source.html
https://root.cern/doc/v632/TROOT_8cxx_source.html:162385,Deployability,install,installation,162385,"ursively remove this object from the list of Cleanups.Definition TROOT.cxx:2498; TROOT::fExecutingMacroBool_t fExecutingMacroTrue while executing a TMacro.Definition TROOT.h:136; TROOT::fBuiltDateInt_t fBuiltDateDate of ROOT built.Definition TROOT.h:118; TROOT::fIsWebDisplayBatchBool_t fIsWebDisplayBatchTrue if web widgets are not displayed.Definition TROOT.h:129; TROOT::GetSharedLibDirstatic const TString & GetSharedLibDir()Get the shared libraries directory in the installation. Static utility function.Definition TROOT.cxx:3031; TROOT::fMappedFilesTSeqCollection * fMappedFilesList of memory mapped files.Definition TROOT.h:147; TROOT::GetNtypesInt_t GetNtypes() constGet number of types.Definition TROOT.cxx:1884; TROOT::LoadMacroInt_t LoadMacro(const char *filename, Int_t *error=nullptr, Bool_t check=kFALSE)Load a macro in the interpreter's memory.Definition TROOT.cxx:2268; TROOT::GetFileTFile * GetFile() const overrideDefinition TROOT.h:260; TROOT::GetLibDirstatic const TString & GetLibDir()Get the library directory in the installation. Static utility function.Definition TROOT.cxx:3010; TROOT::fBrowsersTSeqCollection * fBrowsersList of browsers.Definition TROOT.h:155; TROOT::fDefCanvasNameTString fDefCanvasNameName of default canvas.Definition TROOT.h:171; TROOT::fGlobalFunctionsTListOfFunctions * fGlobalFunctionsList of global functions.Definition TROOT.h:144; TROOT::fBrowsablesTList * fBrowsablesList of browsables.Definition TROOT.h:168; TROOT::FindObjectAnyTObject * FindObjectAny(const char *name) const overrideReturn a pointer to the first object with name starting at //root.Definition TROOT.cxx:1426; TROOT::DecreaseDirLevelstatic Int_t DecreaseDirLevel()Decrease the indentation level for ls().Definition TROOT.cxx:2746; TROOT::Resetvoid Reset(Option_t *option="""")Delete all global interpreter objects created since the last call to Reset.Definition TROOT.cxx:2651; TROOT::fEditorModeInt_t fEditorModeCurrent Editor mode.Definition TROOT.h:137; TROOT::FindObjectClassN",MatchSource.WIKI,doc/v632/TROOT_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/TROOT_8cxx_source.html
https://root.cern/doc/v632/TROOT_8cxx_source.html:163574,Deployability,install,installation,163574,"ROOT::fDefCanvasNameTString fDefCanvasNameName of default canvas.Definition TROOT.h:171; TROOT::fGlobalFunctionsTListOfFunctions * fGlobalFunctionsList of global functions.Definition TROOT.h:144; TROOT::fBrowsablesTList * fBrowsablesList of browsables.Definition TROOT.h:168; TROOT::FindObjectAnyTObject * FindObjectAny(const char *name) const overrideReturn a pointer to the first object with name starting at //root.Definition TROOT.cxx:1426; TROOT::DecreaseDirLevelstatic Int_t DecreaseDirLevel()Decrease the indentation level for ls().Definition TROOT.cxx:2746; TROOT::Resetvoid Reset(Option_t *option="""")Delete all global interpreter objects created since the last call to Reset.Definition TROOT.cxx:2651; TROOT::fEditorModeInt_t fEditorModeCurrent Editor mode.Definition TROOT.h:137; TROOT::FindObjectClassNameconst char * FindObjectClassName(const char *name) constReturns class name of a ROOT object including CINT globals.Definition TROOT.cxx:1453; TROOT::GetDataDirstatic const TString & GetDataDir()Get the data directory in the installation. Static utility function.Definition TROOT.cxx:3062; TROOT::GetListOfGeometriesTSeqCollection * GetListOfGeometries() constDefinition TROOT.h:244; TROOT::GetListOfStylesTSeqCollection * GetListOfStyles() constDefinition TROOT.h:241; TROOT::fVersionTString fVersionROOT version (from CMZ VERSQQ) ex 0.05/01.Definition TROOT.h:113; TROOT::GetDirLevelstatic Int_t GetDirLevel()return directory levelDefinition TROOT.cxx:2754; TROOT::SetReadingObjectvoid SetReadingObject(Bool_t flag=kTRUE)Definition TROOT.cxx:2465; TSeqCollectionSequenceable collection abstract base class.Definition TSeqCollection.h:28; TSeqCollection::AddLastvirtual void AddLast(TObject *obj)=0; TSeqCollection::Lastvirtual TObject * Last() const =0; TSeqCollection::Firstvirtual TObject * First() const =0; TSeqCollection::Addvoid Add(TObject *obj) overrideDefinition TSeqCollection.h:38; TStorage::PrintStatisticsstatic void PrintStatistics()Print memory usage statistics.Definit",MatchSource.WIKI,doc/v632/TROOT_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/TROOT_8cxx_source.html
https://root.cern/doc/v632/TROOT_8cxx_source.html:170074,Deployability,install,installation,170074,"on TUrl.h:33; TVirtualMutexThis class implements a mutex interface.Definition TVirtualMutex.h:32; TVirtualPadTVirtualPad is an abstract base class for the Pad and Canvas classes.Definition TVirtualPad.h:51; TVirtualPad::Padstatic TVirtualPad *& Pad()Return the current pad for the current thread.Definition TVirtualPad.cxx:82; TVirtualPad::GetVirtCanvasvirtual TVirtualPad * GetVirtCanvas() const =0; TVirtualXSemi-Abstract base class defining a generic interface to the underlying, low level,...Definition TVirtualX.h:46; TVirtualX::Instancestatic TVirtualX *& Instance()Returns gVirtualX global.Definition TVirtualX.cxx:57; TWinNTSystemDefinition TWinNTSystem.h:58; bool; int; unsigned int; lineTLine * lineDefinition entrylistblock_figure1.C:235; f1TF1 * f1Definition legend1.C:11; ROOT::Detail::HasBeenDeletedR__ALWAYS_INLINE bool HasBeenDeleted(const TObject *obj)Check if the TObject's memory has been deleted.Definition TObject.h:402; ROOT::FoundationUtils::GetIncludeDirconst std::string & GetIncludeDir()\ returns the include directory in the installation.Definition FoundationUtils.cxx:180; ROOT::FoundationUtils::GetRootSysconst std::string & GetRootSys()Definition FoundationUtils.cxx:158; ROOT::FoundationUtils::GetEtcDirconst std::string & GetEtcDir()Definition FoundationUtils.cxx:195; ROOT::Internal::VecOps::voidvoid(off) SmallVectorTemplateBase< T; ROOT::InternalDefinition TErrorDefaultHandler.hxx:16; ROOT::Internal::GetSymInLibImtstatic Func_t GetSymInLibImt(const char *funcname)Definition TROOT.cxx:401; ROOT::Internal::gGetROOTstatic GetROOTFun_t gGetROOTDefinition TROOT.cxx:399; ROOT::Internal::gROOTLocalR__EXTERN TROOT * gROOTLocalDefinition TROOT.h:379; ROOT::Internal::DisableParBranchProcessingvoid DisableParBranchProcessing()Globally disables the IMT use case of parallel branch processing, deactivating the corresponding lock...Definition TROOT.cxx:434; ROOT::Internal::ErrorSystemMsgHandlerFunc_tstd::function< const char *()> ErrorSystemMsgHandlerFunc_tRetrieves t",MatchSource.WIKI,doc/v632/TROOT_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/TROOT_8cxx_source.html
https://root.cern/doc/v632/TROOT_8cxx_source.html:10383,Energy Efficiency,schedul,scheduled,10383,"ngside it.; 285 };; 286 ; 287 std::vector<ModuleHeaderInfo_t>& GetModuleHeaderInfoBuffer() {; 288 static std::vector<ModuleHeaderInfo_t> moduleHeaderInfoBuffer;; 289 return moduleHeaderInfoBuffer;; 290 }; 291}; 292 ; 293Int_t TROOT::fgDirLevel = 0;; 294Bool_t TROOT::fgRootInit = kFALSE;; 295 ; 296static void at_exit_of_TROOT() {; 297 if (ROOT::Internal::gROOTLocal); 298 ROOT::Internal::gROOTLocal->~TROOT();; 299}; 300 ; 301// This local static object initializes the ROOT system; 302namespace ROOT {; 303namespace Internal {; 304 class TROOTAllocator {; 305 // Simple wrapper to separate, time-wise, the call to the; 306 // TROOT destructor and the actual free-ing of the memory.; 307 //; 308 // Since the interpreter implementation (currently TCling) is; 309 // loaded via dlopen by libCore, the destruction of its global; 310 // variable (i.e. in particular clang's) is scheduled before; 311 // those in libCore so we need to schedule the call to the TROOT; 312 // destructor before that *but* we want to make sure the memory; 313 // stay around until libCore itself is unloaded so that code; 314 // using gROOT can 'properly' check for validity.; 315 //; 316 // The order of loading for is:; 317 // libCore.so; 318 // libRint.so; 319 // ... anything other library hard linked to the executable ...; 320 // ... for example libEvent; 321 // libCling.so; 322 // ... other libraries like libTree for example ....; 323 // and the destruction order is (of course) the reverse.; 324 // By default the unloading of the dictionary, does use; 325 // the service of the interpreter ... which of course; 326 // fails if libCling is already unloaded by that information; 327 // has not been registered per se.; 328 //; 329 // To solve this problem, we now schedule the destruction; 330 // of the TROOT object to happen _just_ before the; 331 // unloading/destruction of libCling so that we can; 332 // maximize the amount of clean-up we can do correctly; 333 // and we can still allocate the TROOT object's ",MatchSource.WIKI,doc/v632/TROOT_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/TROOT_8cxx_source.html
https://root.cern/doc/v632/TROOT_8cxx_source.html:10439,Energy Efficiency,schedul,schedule,10439,"ngside it.; 285 };; 286 ; 287 std::vector<ModuleHeaderInfo_t>& GetModuleHeaderInfoBuffer() {; 288 static std::vector<ModuleHeaderInfo_t> moduleHeaderInfoBuffer;; 289 return moduleHeaderInfoBuffer;; 290 }; 291}; 292 ; 293Int_t TROOT::fgDirLevel = 0;; 294Bool_t TROOT::fgRootInit = kFALSE;; 295 ; 296static void at_exit_of_TROOT() {; 297 if (ROOT::Internal::gROOTLocal); 298 ROOT::Internal::gROOTLocal->~TROOT();; 299}; 300 ; 301// This local static object initializes the ROOT system; 302namespace ROOT {; 303namespace Internal {; 304 class TROOTAllocator {; 305 // Simple wrapper to separate, time-wise, the call to the; 306 // TROOT destructor and the actual free-ing of the memory.; 307 //; 308 // Since the interpreter implementation (currently TCling) is; 309 // loaded via dlopen by libCore, the destruction of its global; 310 // variable (i.e. in particular clang's) is scheduled before; 311 // those in libCore so we need to schedule the call to the TROOT; 312 // destructor before that *but* we want to make sure the memory; 313 // stay around until libCore itself is unloaded so that code; 314 // using gROOT can 'properly' check for validity.; 315 //; 316 // The order of loading for is:; 317 // libCore.so; 318 // libRint.so; 319 // ... anything other library hard linked to the executable ...; 320 // ... for example libEvent; 321 // libCling.so; 322 // ... other libraries like libTree for example ....; 323 // and the destruction order is (of course) the reverse.; 324 // By default the unloading of the dictionary, does use; 325 // the service of the interpreter ... which of course; 326 // fails if libCling is already unloaded by that information; 327 // has not been registered per se.; 328 //; 329 // To solve this problem, we now schedule the destruction; 330 // of the TROOT object to happen _just_ before the; 331 // unloading/destruction of libCling so that we can; 332 // maximize the amount of clean-up we can do correctly; 333 // and we can still allocate the TROOT object's ",MatchSource.WIKI,doc/v632/TROOT_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/TROOT_8cxx_source.html
https://root.cern/doc/v632/TROOT_8cxx_source.html:11257,Energy Efficiency,schedul,schedule,11257,"lang's) is scheduled before; 311 // those in libCore so we need to schedule the call to the TROOT; 312 // destructor before that *but* we want to make sure the memory; 313 // stay around until libCore itself is unloaded so that code; 314 // using gROOT can 'properly' check for validity.; 315 //; 316 // The order of loading for is:; 317 // libCore.so; 318 // libRint.so; 319 // ... anything other library hard linked to the executable ...; 320 // ... for example libEvent; 321 // libCling.so; 322 // ... other libraries like libTree for example ....; 323 // and the destruction order is (of course) the reverse.; 324 // By default the unloading of the dictionary, does use; 325 // the service of the interpreter ... which of course; 326 // fails if libCling is already unloaded by that information; 327 // has not been registered per se.; 328 //; 329 // To solve this problem, we now schedule the destruction; 330 // of the TROOT object to happen _just_ before the; 331 // unloading/destruction of libCling so that we can; 332 // maximize the amount of clean-up we can do correctly; 333 // and we can still allocate the TROOT object's memory; 334 // statically.; 335 //; 336 union {; 337 TROOT fObj;; 338 char fHolder[sizeof(TROOT)];; 339 };; 340 public:; 341 TROOTAllocator(): fObj(""root"", ""The ROOT of EVERYTHING""); 342 {}; 343 ; 344 ~TROOTAllocator() {; 345 if (gROOTLocal) {; 346 gROOTLocal->~TROOT();; 347 }; 348 }; 349 };; 350 ; 351 // The global gROOT is defined to be a function (ROOT::GetROOT()); 352 // which itself is dereferencing a function pointer.; 353 ; 354 // Initially this function pointer's value is & GetROOT1 whose role is to; 355 // create and initialize the TROOT object itself.; 356 // At the very end of the TROOT constructor the value of the function pointer; 357 // is switch to & GetROOT2 whose role is to initialize the interpreter.; 358 ; 359 // This mechanism was primarily intended to fix the issues with order in which; 360 // global TROOT and LLVM globals are init",MatchSource.WIKI,doc/v632/TROOT_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/TROOT_8cxx_source.html
https://root.cern/doc/v632/TROOT_8cxx_source.html:11480,Energy Efficiency,allocate,allocate,11480,"lang's) is scheduled before; 311 // those in libCore so we need to schedule the call to the TROOT; 312 // destructor before that *but* we want to make sure the memory; 313 // stay around until libCore itself is unloaded so that code; 314 // using gROOT can 'properly' check for validity.; 315 //; 316 // The order of loading for is:; 317 // libCore.so; 318 // libRint.so; 319 // ... anything other library hard linked to the executable ...; 320 // ... for example libEvent; 321 // libCling.so; 322 // ... other libraries like libTree for example ....; 323 // and the destruction order is (of course) the reverse.; 324 // By default the unloading of the dictionary, does use; 325 // the service of the interpreter ... which of course; 326 // fails if libCling is already unloaded by that information; 327 // has not been registered per se.; 328 //; 329 // To solve this problem, we now schedule the destruction; 330 // of the TROOT object to happen _just_ before the; 331 // unloading/destruction of libCling so that we can; 332 // maximize the amount of clean-up we can do correctly; 333 // and we can still allocate the TROOT object's memory; 334 // statically.; 335 //; 336 union {; 337 TROOT fObj;; 338 char fHolder[sizeof(TROOT)];; 339 };; 340 public:; 341 TROOTAllocator(): fObj(""root"", ""The ROOT of EVERYTHING""); 342 {}; 343 ; 344 ~TROOTAllocator() {; 345 if (gROOTLocal) {; 346 gROOTLocal->~TROOT();; 347 }; 348 }; 349 };; 350 ; 351 // The global gROOT is defined to be a function (ROOT::GetROOT()); 352 // which itself is dereferencing a function pointer.; 353 ; 354 // Initially this function pointer's value is & GetROOT1 whose role is to; 355 // create and initialize the TROOT object itself.; 356 // At the very end of the TROOT constructor the value of the function pointer; 357 // is switch to & GetROOT2 whose role is to initialize the interpreter.; 358 ; 359 // This mechanism was primarily intended to fix the issues with order in which; 360 // global TROOT and LLVM globals are init",MatchSource.WIKI,doc/v632/TROOT_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/TROOT_8cxx_source.html
https://root.cern/doc/v632/TROOT_8cxx_source.html:19929,Energy Efficiency,schedul,scheduler,19929,"e:; 517 ///; 518 /// - RDataFrame internally runs the event-loop by parallelizing over clusters of entries; 519 /// - TTree::GetEntry reads multiple branches in parallel; 520 /// - TTree::FlushBaskets writes multiple baskets to disk in parallel; 521 /// - TTreeCacheUnzip decompresses the baskets contained in a TTreeCache in parallel; 522 /// - THx::Fit performs in parallel the evaluation of the objective function over the data; 523 /// - TMVA::DNN trains the deep neural networks in parallel; 524 /// - TMVA::BDT trains the classifier in parallel and multiclass BDTs are evaluated in parallel; 525 ///; 526 /// EnableImplicitMT calls in turn EnableThreadSafety.; 527 /// The 'numthreads' parameter allows to control the number of threads to; 528 /// be used by the implicit multi-threading. However, this parameter is just; 529 /// a hint for ROOT: it will try to satisfy the request if the execution; 530 /// scenario allows it. For example, if ROOT is configured to use an external; 531 /// scheduler, setting a value for 'numthreads' might not have any effect.; 532 /// The maximum number of threads can be influenced by the environment; 533 /// variable `ROOT_MAX_THREADS`: `export ROOT_MAX_THREADS=2` will try to set; 534 /// the maximum number of active threads to 2, if the scheduling library; 535 /// (such as tbb) ""permits"".; 536 ///; 537 /// \note Use `DisableImplicitMT()` to disable multi-threading (some locks will remain in place as; 538 /// described in EnableThreadSafety()). `EnableImplicitMT(1)` creates a thread-pool of size 1.; 539 void EnableImplicitMT(UInt_t numthreads); 540 {; 541#ifdef R__USE_IMT; 542 if (ROOT::Internal::IsImplicitMTEnabledImpl()); 543 return;; 544 EnableThreadSafety();; 545 static void (*sym)(UInt_t) = (void(*)(UInt_t))Internal::GetSymInLibImt(""ROOT_TImplicitMT_EnableImplicitMT"");; 546 if (sym); 547 sym(numthreads);; 548 ROOT::Internal::IsImplicitMTEnabledImpl() = true;; 549#else; 550 ::Warning(""EnableImplicitMT"", ""Cannot enable implicit multi-th",MatchSource.WIKI,doc/v632/TROOT_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/TROOT_8cxx_source.html
https://root.cern/doc/v632/TROOT_8cxx_source.html:20217,Energy Efficiency,schedul,scheduling,20217,"rites multiple baskets to disk in parallel; 521 /// - TTreeCacheUnzip decompresses the baskets contained in a TTreeCache in parallel; 522 /// - THx::Fit performs in parallel the evaluation of the objective function over the data; 523 /// - TMVA::DNN trains the deep neural networks in parallel; 524 /// - TMVA::BDT trains the classifier in parallel and multiclass BDTs are evaluated in parallel; 525 ///; 526 /// EnableImplicitMT calls in turn EnableThreadSafety.; 527 /// The 'numthreads' parameter allows to control the number of threads to; 528 /// be used by the implicit multi-threading. However, this parameter is just; 529 /// a hint for ROOT: it will try to satisfy the request if the execution; 530 /// scenario allows it. For example, if ROOT is configured to use an external; 531 /// scheduler, setting a value for 'numthreads' might not have any effect.; 532 /// The maximum number of threads can be influenced by the environment; 533 /// variable `ROOT_MAX_THREADS`: `export ROOT_MAX_THREADS=2` will try to set; 534 /// the maximum number of active threads to 2, if the scheduling library; 535 /// (such as tbb) ""permits"".; 536 ///; 537 /// \note Use `DisableImplicitMT()` to disable multi-threading (some locks will remain in place as; 538 /// described in EnableThreadSafety()). `EnableImplicitMT(1)` creates a thread-pool of size 1.; 539 void EnableImplicitMT(UInt_t numthreads); 540 {; 541#ifdef R__USE_IMT; 542 if (ROOT::Internal::IsImplicitMTEnabledImpl()); 543 return;; 544 EnableThreadSafety();; 545 static void (*sym)(UInt_t) = (void(*)(UInt_t))Internal::GetSymInLibImt(""ROOT_TImplicitMT_EnableImplicitMT"");; 546 if (sym); 547 sym(numthreads);; 548 ROOT::Internal::IsImplicitMTEnabledImpl() = true;; 549#else; 550 ::Warning(""EnableImplicitMT"", ""Cannot enable implicit multi-threading with %d threads, please build ROOT with -Dimt=ON"", numthreads);; 551#endif; 552 }; 553 ; 554 ////////////////////////////////////////////////////////////////////////////////; 555 /// Disables th",MatchSource.WIKI,doc/v632/TROOT_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/TROOT_8cxx_source.html
https://root.cern/doc/v632/TROOT_8cxx_source.html:5567,Integrability,rout,routines,5567,"""TListOfEnumsWithLock.h""; 149#include ""TListOfFunctions.h""; 150#include ""TListOfFunctionTemplates.h""; 151#include ""TFunctionTemplate.h""; 152#include ""ThreadLocalStorage.h""; 153#include ""TVirtualMapFile.h""; 154#include ""TVirtualRWMutex.h""; 155#include ""TVirtualX.h""; 156 ; 157#if defined(R__UNIX); 158#if defined(R__HAS_COCOA); 159#include ""TMacOSXSystem.h""; 160#include ""TUrl.h""; 161#else; 162#include ""TUnixSystem.h""; 163#endif; 164#elif defined(R__WIN32); 165#include ""TWinNTSystem.h""; 166#endif; 167 ; 168extern ""C"" void R__SetZipMode(int);; 169 ; 170static DestroyInterpreter_t *gDestroyInterpreter = nullptr;; 171static void *gInterpreterLib = nullptr;; 172 ; 173// Mutex for protection of concurrent gROOT access; 174TVirtualMutex* gROOTMutex = nullptr;; 175ROOT::TVirtualRWMutex *ROOT::gCoreMutex = nullptr;; 176 ; 177// For accessing TThread::Tsd indirectly.; 178void **(*gThreadTsd)(void*,Int_t) = nullptr;; 179 ; 180//-------- Names of next three routines are a small homage to CMZ --------------; 181////////////////////////////////////////////////////////////////////////////////; 182/// Return version id as an integer, i.e. ""2.22/04"" -> 22204.; 183 ; 184static Int_t IVERSQ(); 185{; 186 Int_t maj, min, cycle;; 187 sscanf(ROOT_RELEASE, ""%d.%d.%d"", &maj, &min, &cycle);; 188 return 10000*maj + 100*min + cycle;; 189}; 190 ; 191////////////////////////////////////////////////////////////////////////////////; 192/// Return built date as integer, i.e. ""Apr 28 2000"" -> 20000428.; 193 ; 194static Int_t IDATQQ(const char *date); 195{; 196 if (!date) {; 197 Error(""TSystem::IDATQQ"", ""nullptr date string, expected e.g. 'Dec 21 2022'"");; 198 return -1;; 199 }; 200 ; 201 static const char *months[] = {""Jan"",""Feb"",""Mar"",""Apr"",""May"",; 202 ""Jun"",""Jul"",""Aug"",""Sep"",""Oct"",; 203 ""Nov"",""Dec""};; 204 char sm[12];; 205 Int_t yy, mm=0, dd;; 206 if (sscanf(date, ""%s %d %d"", sm, &dd, &yy) != 3) {; 207 Error(""TSystem::IDATQQ"", ""Cannot parse date string '%s', expected e.g. 'Dec 21 2022'"", date);; 208 r",MatchSource.WIKI,doc/v632/TROOT_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/TROOT_8cxx_source.html
https://root.cern/doc/v632/TROOT_8cxx_source.html:10079,Integrability,wrap,wrapper,10079,"77 const char* fPayloadCode; // Additional code to be given to cling at library load; 278 const char* fFwdDeclCode; // Additional code to let cling know about selected classes and functions; 279 const char** fIncludePaths; // 0-terminated array of header files; 280 void (*fTriggerFunc)(); // Pointer to the dict initialization used to find the library name; 281 const char** fClassesHeaders; // 0-terminated list of classes and related header files; 282 const TROOT::FwdDeclArgsToKeepCollection_t fFwdNargsToKeepColl; // Collection of; 283 // pairs of template fwd decls and number of; 284 bool fHasCxxModule; // Whether this module has a C++ module alongside it.; 285 };; 286 ; 287 std::vector<ModuleHeaderInfo_t>& GetModuleHeaderInfoBuffer() {; 288 static std::vector<ModuleHeaderInfo_t> moduleHeaderInfoBuffer;; 289 return moduleHeaderInfoBuffer;; 290 }; 291}; 292 ; 293Int_t TROOT::fgDirLevel = 0;; 294Bool_t TROOT::fgRootInit = kFALSE;; 295 ; 296static void at_exit_of_TROOT() {; 297 if (ROOT::Internal::gROOTLocal); 298 ROOT::Internal::gROOTLocal->~TROOT();; 299}; 300 ; 301// This local static object initializes the ROOT system; 302namespace ROOT {; 303namespace Internal {; 304 class TROOTAllocator {; 305 // Simple wrapper to separate, time-wise, the call to the; 306 // TROOT destructor and the actual free-ing of the memory.; 307 //; 308 // Since the interpreter implementation (currently TCling) is; 309 // loaded via dlopen by libCore, the destruction of its global; 310 // variable (i.e. in particular clang's) is scheduled before; 311 // those in libCore so we need to schedule the call to the TROOT; 312 // destructor before that *but* we want to make sure the memory; 313 // stay around until libCore itself is unloaded so that code; 314 // using gROOT can 'properly' check for validity.; 315 //; 316 // The order of loading for is:; 317 // libCore.so; 318 // libRint.so; 319 // ... anything other library hard linked to the executable ...; 320 // ... for example libEvent; 321 // l",MatchSource.WIKI,doc/v632/TROOT_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/TROOT_8cxx_source.html
https://root.cern/doc/v632/TROOT_8cxx_source.html:25063,Integrability,depend,dependencies,25063,"of the TROOT object initializes; 623/// the ROOT system. It must be the first ROOT related action that is; 624/// performed by a program. The TROOT object must be created on the stack; 625/// (can not be called via new since ""operator new"" is protected). The; 626/// TROOT object is either created as a global object (outside the main(); 627/// program), or it is one of the first objects created in main().; 628/// Make sure that the TROOT object stays in scope for as long as ROOT; 629/// related actions are performed. TROOT is a so called singleton so; 630/// only one instance of it can be created. The single TROOT object can; 631/// always be accessed via the global pointer gROOT.; 632/// The name and title arguments can be used to identify the running; 633/// application. The initfunc argument can contain an array of; 634/// function pointers (last element must be 0). These functions are; 635/// executed at the end of the constructor. This way one can easily; 636/// extend the ROOT system without adding permanent dependencies; 637/// (e.g. the graphics system is initialized via such a function).; 638 ; 639TROOT::TROOT(const char *name, const char *title, VoidFuncPtr_t *initfunc); 640 : TDirectory(), fLineIsProcessing(0), fVersion(0), fVersionInt(0), fVersionCode(0),; 641 fVersionDate(0), fVersionTime(0), fBuiltDate(0), fBuiltTime(0),; 642 fTimer(0), fApplication(nullptr), fInterpreter(nullptr), fBatch(kTRUE),; 643 fIsWebDisplay(kFALSE), fIsWebDisplayBatch(kFALSE), fEditHistograms(kTRUE),; 644 fFromPopUp(kTRUE),fMustClean(kTRUE),fForceStyle(kFALSE),; 645 fInterrupt(kFALSE),fEscape(kFALSE),fExecutingMacro(kFALSE),fEditorMode(0),; 646 fPrimitive(nullptr),fSelectPad(nullptr),fClasses(nullptr),fTypes(nullptr),fGlobals(nullptr),fGlobalFunctions(nullptr),; 647 fClosedObjects(nullptr),fFiles(nullptr),fMappedFiles(nullptr),fSockets(nullptr),fCanvases(nullptr),fStyles(nullptr),fFunctions(nullptr),; 648 fTasks(nullptr),fColors(nullptr),fGeometries(nullptr),fBrowsers(nullptr),fS",MatchSource.WIKI,doc/v632/TROOT_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/TROOT_8cxx_source.html
https://root.cern/doc/v632/TROOT_8cxx_source.html:26949,Integrability,interface,interface,26949,", fVersionCode(0),; 641 fVersionDate(0), fVersionTime(0), fBuiltDate(0), fBuiltTime(0),; 642 fTimer(0), fApplication(nullptr), fInterpreter(nullptr), fBatch(kTRUE),; 643 fIsWebDisplay(kFALSE), fIsWebDisplayBatch(kFALSE), fEditHistograms(kTRUE),; 644 fFromPopUp(kTRUE),fMustClean(kTRUE),fForceStyle(kFALSE),; 645 fInterrupt(kFALSE),fEscape(kFALSE),fExecutingMacro(kFALSE),fEditorMode(0),; 646 fPrimitive(nullptr),fSelectPad(nullptr),fClasses(nullptr),fTypes(nullptr),fGlobals(nullptr),fGlobalFunctions(nullptr),; 647 fClosedObjects(nullptr),fFiles(nullptr),fMappedFiles(nullptr),fSockets(nullptr),fCanvases(nullptr),fStyles(nullptr),fFunctions(nullptr),; 648 fTasks(nullptr),fColors(nullptr),fGeometries(nullptr),fBrowsers(nullptr),fSpecials(nullptr),fCleanups(nullptr),; 649 fMessageHandlers(nullptr),fStreamerInfo(nullptr),fClassGenerators(nullptr),fSecContexts(nullptr),; 650 fProofs(nullptr),fClipboard(nullptr),fDataSets(nullptr),fUUIDs(nullptr),fRootFolder(nullptr),fBrowsables(nullptr),; 651 fPluginManager(nullptr); 652{; 653 if (fgRootInit || ROOT::Internal::gROOTLocal) {; 654 //Warning(""TROOT"", ""only one instance of TROOT allowed"");; 655 return;; 656 }; 657 ; 658 R__LOCKGUARD(gROOTMutex);; 659 ; 660 ROOT::Internal::gROOTLocal = this;; 661 gDirectory = nullptr;; 662 ; 663 SetName(name);; 664 SetTitle(title);; 665 ; 666 // will be used by global ""operator delete"" so make sure it is set; 667 // before anything is deleted; 668 fMappedFiles = nullptr;; 669 ; 670 // create already here, but only initialize it after gEnv has been created; 671 gPluginMgr = fPluginManager = new TPluginManager;; 672 ; 673 // Initialize Operating System interface; 674 InitSystem();; 675 ; 676 // Initialize static directory functions; 677 GetRootSys();; 678 GetBinDir();; 679 GetLibDir();; 680 GetIncludeDir();; 681 GetEtcDir();; 682 GetDataDir();; 683 GetDocDir();; 684 GetMacroDir();; 685 GetTutorialDir();; 686 GetSourceDir();; 687 GetIconPath();; 688 GetTTFFontDir();; 689 ; 690 gRootDir = GetRootSys().",MatchSource.WIKI,doc/v632/TROOT_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/TROOT_8cxx_source.html
https://root.cern/doc/v632/TROOT_8cxx_source.html:27393,Integrability,interface,interface,27393,"reate already here, but only initialize it after gEnv has been created; 671 gPluginMgr = fPluginManager = new TPluginManager;; 672 ; 673 // Initialize Operating System interface; 674 InitSystem();; 675 ; 676 // Initialize static directory functions; 677 GetRootSys();; 678 GetBinDir();; 679 GetLibDir();; 680 GetIncludeDir();; 681 GetEtcDir();; 682 GetDataDir();; 683 GetDocDir();; 684 GetMacroDir();; 685 GetTutorialDir();; 686 GetSourceDir();; 687 GetIconPath();; 688 GetTTFFontDir();; 689 ; 690 gRootDir = GetRootSys().Data();; 691 ; 692 TDirectory::BuildDirectory(nullptr, nullptr);; 693 ; 694 // Initialize interface to CINT C++ interpreter; 695 fVersionInt = 0; // check in TROOT dtor in case TCling fails; 696 fClasses = nullptr; // might be checked via TCling ctor; 697 fEnums = nullptr;; 698 ; 699 fConfigOptions = R__CONFIGUREOPTIONS;; 700 fConfigFeatures = R__CONFIGUREFEATURES;; 701 fVersion = ROOT_RELEASE;; 702 fVersionCode = ROOT_VERSION_CODE;; 703 fVersionInt = IVERSQ();; 704 fVersionDate = IDATQQ(ROOT_RELEASE_DATE);; 705 fVersionTime = ITIMQQ(ROOT_RELEASE_TIME);; 706 fBuiltDate = IDATQQ(__DATE__);; 707 fBuiltTime = ITIMQQ(__TIME__);; 708 ; 709 ReadGitInfo();; 710 ; 711 fClasses = new THashTable(800,3); fClasses->UseRWLock();; 712 //fIdMap = new IdMap_t;; 713 fStreamerInfo = new TObjArray(100); fStreamerInfo->UseRWLock();; 714 fClassGenerators = new TList;; 715 ; 716 // usedToIdentifyRootClingByDlSym is available when TROOT is part of; 717 // rootcling.; 718 if (!dlsym(RTLD_DEFAULT, ""usedToIdentifyRootClingByDlSym"")) {; 719 // initialize plugin manager early; 720 fPluginManager->LoadHandlersFromEnv(gEnv);; 721 }; 722 ; 723 TSystemDirectory *workdir = new TSystemDirectory(""workdir"", gSystem->WorkingDirectory());; 724 ; 725 auto setNameLocked = [](TSeqCollection *l, const char *collection_name) {; 726 l->SetName(collection_name);; 727 l->UseRWLock();; 728 return l;; 729 };; 730 ; 731 fTimer = 0;; 732 fApplication = nullptr;; 733 fColors = setNameLocked(new TObjArray(",MatchSource.WIKI,doc/v632/TROOT_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/TROOT_8cxx_source.html
https://root.cern/doc/v632/TROOT_8cxx_source.html:38822,Integrability,depend,dependent,38822,"tions);; 960 fEnums.load()->Delete();; 961 ; 962 // FIXME: Causes segfault in rootcling, debug and uncomment; 963 // fClasses->Delete(); SafeDelete(fClasses); // TClass'es must be deleted last; 964#endif; 965 ; 966 // Remove shared libraries produced by the TSystem::CompileMacro() call; 967 gSystem->CleanCompiledMacros();; 968 ; 969 // Cleanup system class; 970 ROOT::Internal::SetErrorSystemMsgHandler(ROOT::Internal::ErrorSystemMsgHandlerFunc_t());; 971 SetErrorHandler(ROOT::Internal::MinimalErrorHandler);; 972 ROOT::Internal::ReleaseDefaultErrorHandler();; 973 delete gSystem;; 974 ; 975 // ROOT-6022:; 976 // if (gInterpreterLib) dlclose(gInterpreterLib);; 977#ifdef R__COMPLETE_MEM_TERMINATION; 978 // On some 'newer' platform (Fedora Core 17+, Ubuntu 12), the; 979 // initialization order is (by default?) is 'wrong' and so we can't; 980 // delete the interpreter now .. because any of the static in the; 981 // interpreter's library have already been deleted.; 982 // On the link line, we must list the most dependent .o file; 983 // and end with the least dependent (LLVM libraries), unfortunately,; 984 // Fedora Core 17+ or Ubuntu 12 will also execute the initialization; 985 // in the same order (hence doing libCore's before LLVM's and; 986 // vice et versa for both the destructor. We worked around the; 987 // initialization order by delay the TROOT creation until first use.; 988 // We can not do the same for destruction as we have no way of knowing; 989 // the last access ...; 990 // So for now, let's avoid delete TCling except in the special build; 991 // checking the completeness of the termination deletion.; 992 ; 993 // TODO: Should we do more cleanup here than just call delete?; 994 // Segfaults rootcling in some cases, debug and uncomment:; 995 //; 996 // delete fInterpreter;; 997 ; 998 // We cannot delete fCleanups because of the logic in atexit which needs it.; 999 SafeDelete(fCleanups);; 1000#endif; 1001 ; 1002#ifdef _MSC_VER; 1003 // usedToIdentifyRootClingBy",MatchSource.WIKI,doc/v632/TROOT_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/TROOT_8cxx_source.html
https://root.cern/doc/v632/TROOT_8cxx_source.html:38871,Integrability,depend,dependent,38871,"lass'es must be deleted last; 964#endif; 965 ; 966 // Remove shared libraries produced by the TSystem::CompileMacro() call; 967 gSystem->CleanCompiledMacros();; 968 ; 969 // Cleanup system class; 970 ROOT::Internal::SetErrorSystemMsgHandler(ROOT::Internal::ErrorSystemMsgHandlerFunc_t());; 971 SetErrorHandler(ROOT::Internal::MinimalErrorHandler);; 972 ROOT::Internal::ReleaseDefaultErrorHandler();; 973 delete gSystem;; 974 ; 975 // ROOT-6022:; 976 // if (gInterpreterLib) dlclose(gInterpreterLib);; 977#ifdef R__COMPLETE_MEM_TERMINATION; 978 // On some 'newer' platform (Fedora Core 17+, Ubuntu 12), the; 979 // initialization order is (by default?) is 'wrong' and so we can't; 980 // delete the interpreter now .. because any of the static in the; 981 // interpreter's library have already been deleted.; 982 // On the link line, we must list the most dependent .o file; 983 // and end with the least dependent (LLVM libraries), unfortunately,; 984 // Fedora Core 17+ or Ubuntu 12 will also execute the initialization; 985 // in the same order (hence doing libCore's before LLVM's and; 986 // vice et versa for both the destructor. We worked around the; 987 // initialization order by delay the TROOT creation until first use.; 988 // We can not do the same for destruction as we have no way of knowing; 989 // the last access ...; 990 // So for now, let's avoid delete TCling except in the special build; 991 // checking the completeness of the termination deletion.; 992 ; 993 // TODO: Should we do more cleanup here than just call delete?; 994 // Segfaults rootcling in some cases, debug and uncomment:; 995 //; 996 // delete fInterpreter;; 997 ; 998 // We cannot delete fCleanups because of the logic in atexit which needs it.; 999 SafeDelete(fCleanups);; 1000#endif; 1001 ; 1002#ifdef _MSC_VER; 1003 // usedToIdentifyRootClingByDlSym is available when TROOT is part of rootcling.; 1004 if (dlsym(RTLD_DEFAULT, ""usedToIdentifyRootClingByDlSym"")) {; 1005 // deleting the interpreter makes thing",MatchSource.WIKI,doc/v632/TROOT_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/TROOT_8cxx_source.html
https://root.cern/doc/v632/TROOT_8cxx_source.html:40465,Integrability,rout,routine,40465,"here than just call delete?; 994 // Segfaults rootcling in some cases, debug and uncomment:; 995 //; 996 // delete fInterpreter;; 997 ; 998 // We cannot delete fCleanups because of the logic in atexit which needs it.; 999 SafeDelete(fCleanups);; 1000#endif; 1001 ; 1002#ifdef _MSC_VER; 1003 // usedToIdentifyRootClingByDlSym is available when TROOT is part of rootcling.; 1004 if (dlsym(RTLD_DEFAULT, ""usedToIdentifyRootClingByDlSym"")) {; 1005 // deleting the interpreter makes things crash at exit in some cases; 1006 delete fInterpreter;; 1007 }; 1008#else; 1009 // deleting the interpreter makes things crash at exit in some cases; 1010 delete fInterpreter;; 1011#endif; 1012 ; 1013 // Prints memory stats; 1014 TStorage::PrintStatistics();; 1015 ; 1016 gROOTLocal = nullptr;; 1017 fgRootInit = kFALSE;; 1018 }; 1019}; 1020 ; 1021////////////////////////////////////////////////////////////////////////////////; 1022/// Add a class to the list and map of classes.; 1023/// This routine is deprecated, use TClass::AddClass directly.; 1024 ; 1025void TROOT::AddClass(TClass *cl); 1026{; 1027 TClass::AddClass(cl);; 1028}; 1029 ; 1030////////////////////////////////////////////////////////////////////////////////; 1031/// Add a class generator. This generator will be called by TClass::GetClass; 1032/// in case its does not find a loaded rootcint dictionary to request the; 1033/// creation of a TClass object.; 1034 ; 1035void TROOT::AddClassGenerator(TClassGenerator *generator); 1036{; 1037 if (!generator) return;; 1038 fClassGenerators->Add(generator);; 1039}; 1040 ; 1041////////////////////////////////////////////////////////////////////////////////; 1042/// Append object to this directory.; 1043///; 1044/// If replace is true:; 1045/// remove any existing objects with the same same (if the name is not """"); 1046 ; 1047void TROOT::Append(TObject *obj, Bool_t replace /* = kFALSE */); 1048{; 1049 R__LOCKGUARD(gROOTMutex);; 1050 TDirectory::Append(obj,replace);; 1051}; 1052 ; 1053//////",MatchSource.WIKI,doc/v632/TROOT_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/TROOT_8cxx_source.html
https://root.cern/doc/v632/TROOT_8cxx_source.html:64000,Integrability,rout,routine,64000,"tOfGlobals(load)->FindObject(name);; 1634}; 1635 ; 1636////////////////////////////////////////////////////////////////////////////////; 1637/// Return pointer to global variable with address addr.; 1638 ; 1639TGlobal *TROOT::GetGlobal(const TObject *addr, Bool_t /* load */) const; 1640{; 1641 if (addr == nullptr || ((Longptr_t)addr) == -1) return nullptr;; 1642 ; 1643 TInterpreter::DeclId_t decl = gInterpreter->GetDataMemberAtAddr(addr);; 1644 if (decl) {; 1645 TListOfDataMembers *globals = ((TListOfDataMembers*)(gROOT->GetListOfGlobals(kFALSE)));; 1646 return (TGlobal*)globals->Get(decl);; 1647 }; 1648 // If we are actually looking for a global that is held by a global; 1649 // pointer (for example gRandom), we need to find a pointer with the; 1650 // correct value.; 1651 decl = gInterpreter->GetDataMemberWithValue(addr);; 1652 if (decl) {; 1653 TListOfDataMembers *globals = ((TListOfDataMembers*)(gROOT->GetListOfGlobals(kFALSE)));; 1654 return (TGlobal*)globals->Get(decl);; 1655 }; 1656 return nullptr;; 1657}; 1658 ; 1659////////////////////////////////////////////////////////////////////////////////; 1660/// Internal routine returning, and creating if necessary, the list; 1661/// of global function.; 1662 ; 1663TListOfFunctions *TROOT::GetGlobalFunctions(); 1664{; 1665 if (!fGlobalFunctions) fGlobalFunctions = new TListOfFunctions(nullptr);; 1666 return fGlobalFunctions;; 1667}; 1668 ; 1669////////////////////////////////////////////////////////////////////////////////; 1670/// Return the collection of functions named ""name"".; 1671 ; 1672TCollection *TROOT::GetListOfFunctionOverloads(const char* name) const; 1673{; 1674 return ((TListOfFunctions*)fGlobalFunctions)->GetListForObject(name);; 1675}; 1676 ; 1677////////////////////////////////////////////////////////////////////////////////; 1678/// Return pointer to global function by name.; 1679/// If params != 0 it will also resolve overloading other it returns the first; 1680/// name match.; 1681/// If params ==",MatchSource.WIKI,doc/v632/TROOT_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/TROOT_8cxx_source.html
https://root.cern/doc/v632/TROOT_8cxx_source.html:75956,Integrability,interface,interface,75956,"where);; 1941 }; 1942 ; 1943 TString className = gSystem->BaseName(stem);; 1944 TClass* cla = R__GetClassIfKnown(className);; 1945 if (!cla) {; 1946 // Try again with modifications to the file name:; 1947 className = stem;; 1948 className.ReplaceAll(""/"", ""::"");; 1949 className.ReplaceAll(""\\"", ""::"");; 1950 if (className.Contains("":::"")) {; 1951 // ""C:\dir"" becomes ""C:::dir"".; 1952 // fname corresponds to whatever is stated after #include and; 1953 // a full path name usually means that it's not a regular #include; 1954 // but e.g. a "".L"", so we can assume that this is not a header of; 1955 // a class in a namespace (a global-namespace class would have been; 1956 // detected already before).; 1957 return 0;; 1958 }; 1959 cla = R__GetClassIfKnown(className);; 1960 }; 1961 ; 1962 if (!cla) {; 1963 return 0;; 1964 }; 1965 ; 1966 // cla is valid, check wether it's actually in the header of the same name:; 1967 if (cla->GetDeclFileLine() <= 0) return 0; // to a void an error with VisualC++; 1968 TString decfile = gSystem->BaseName(cla->GetDeclFileName());; 1969 if (decfile != gSystem->BaseName(fname)) {; 1970 return 0;; 1971 }; 1972 return 1;; 1973}; 1974 ; 1975////////////////////////////////////////////////////////////////////////////////; 1976/// Initialize operating system interface.; 1977 ; 1978void TROOT::InitSystem(); 1979{; 1980 if (gSystem == nullptr) {; 1981#if defined(R__UNIX); 1982#if defined(R__HAS_COCOA); 1983 gSystem = new TMacOSXSystem;; 1984#else; 1985 gSystem = new TUnixSystem;; 1986#endif; 1987#elif defined(R__WIN32); 1988 gSystem = new TWinNTSystem;; 1989#else; 1990 gSystem = new TSystem;; 1991#endif; 1992 ; 1993 if (gSystem->Init()); 1994 fprintf(stderr, ""Fatal in <TROOT::InitSystem>: can't init operating system layer\n"");; 1995 ; 1996 if (!gSystem->HomeDirectory()) {; 1997 fprintf(stderr, ""Fatal in <TROOT::InitSystem>: HOME directory not set\n"");; 1998 fprintf(stderr, ""Fix this by defining the HOME shell variable\n"");; 1999 }; 2000 ; 2001 // read defa",MatchSource.WIKI,doc/v632/TROOT_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/TROOT_8cxx_source.html
https://root.cern/doc/v632/TROOT_8cxx_source.html:80251,Integrability,message,message,80251,"OOT is part of; 2067 // rootcling.; 2068 if (!dlsym(RTLD_DEFAULT, ""usedToIdentifyRootClingByDlSym""); 2069 && !dlsym(RTLD_DEFAULT, ""usedToIdentifyStaticRoot"")) {; 2070 char *libRIO = gSystem->DynamicPathName(""libRIO"");; 2071 void *libRIOHandle = dlopen(libRIO, RTLD_NOW|RTLD_GLOBAL);; 2072 delete [] libRIO;; 2073 if (!libRIOHandle) {; 2074 TString err = dlerror();; 2075 fprintf(stderr, ""Fatal in <TROOT::InitInterpreter>: cannot load library %s\n"", err.Data());; 2076 exit(1);; 2077 }; 2078 ; 2079 char *libcling = gSystem->DynamicPathName(""libCling"");; 2080 gInterpreterLib = dlopen(libcling, RTLD_LAZY|RTLD_LOCAL);; 2081 delete [] libcling;; 2082 ; 2083 if (!gInterpreterLib) {; 2084 TString err = dlerror();; 2085 fprintf(stderr, ""Fatal in <TROOT::InitInterpreter>: cannot load library %s\n"", err.Data());; 2086 exit(1);; 2087 }; 2088 dlerror(); // reset error message; 2089 } else {; 2090 gInterpreterLib = RTLD_DEFAULT;; 2091 }; 2092 CreateInterpreter_t *CreateInterpreter = (CreateInterpreter_t*) dlsym(gInterpreterLib, ""CreateInterpreter"");; 2093 if (!CreateInterpreter) {; 2094 TString err = dlerror();; 2095 fprintf(stderr, ""Fatal in <TROOT::InitInterpreter>: cannot load symbol %s\n"", err.Data());; 2096 exit(1);; 2097 }; 2098 // Schedule the destruction of TROOT.; 2099 atexit(at_exit_of_TROOT);; 2100 ; 2101 gDestroyInterpreter = (DestroyInterpreter_t*) dlsym(gInterpreterLib, ""DestroyInterpreter"");; 2102 if (!gDestroyInterpreter) {; 2103 TString err = dlerror();; 2104 fprintf(stderr, ""Fatal in <TROOT::InitInterpreter>: cannot load symbol %s\n"", err.Data());; 2105 exit(1);; 2106 }; 2107 ; 2108 const char *interpArgs[] = {; 2109#ifdef NDEBUG; 2110 ""-DNDEBUG"",; 2111#else; 2112 ""-UNDEBUG"",; 2113#endif; 2114#ifdef DEBUG; 2115 ""-DDEBUG"",; 2116#else; 2117 ""-UDEBUG"",; 2118#endif; 2119#ifdef _DEBUG; 2120 ""-D_DEBUG"",; 2121#else; 2122 ""-U_DEBUG"",; 2123#endif; 2124 nullptr};; 2125 ; 2126 fInterpreter = CreateInterpreter(gInterpreterLib, interpArgs);; 2127 ; 2128 fCleanups->Add(fInterpret",MatchSource.WIKI,doc/v632/TROOT_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/TROOT_8cxx_source.html
https://root.cern/doc/v632/TROOT_8cxx_source.html:89217,Integrability,message,message,89217," ACLiC. The filename must have the format:; 2311/// [path/]macro.C[+|++[g|O]][(args)].; 2312/// The possible error codes are defined by TInterpreter::EErrorCode.; 2313/// If padUpdate is true (default) update the current pad.; 2314/// Returns the macro return value.; 2315 ; 2316Longptr_t TROOT::Macro(const char *filename, Int_t *error, Bool_t padUpdate); 2317{; 2318 Longptr_t result = 0;; 2319 ; 2320 if (fInterpreter) {; 2321 TString aclicMode;; 2322 TString arguments;; 2323 TString io;; 2324 TString fname = gSystem->SplitAclicMode(filename, aclicMode, arguments, io);; 2325 ; 2326 char *mac = gSystem->Which(GetMacroPath(), fname, kReadPermission);; 2327 if (!mac) {; 2328 Error(""Macro"", ""macro %s not found in path %s"", fname.Data(), GetMacroPath());; 2329 if (error); 2330 *error = TInterpreter::kFatal;; 2331 } else {; 2332 fname = mac;; 2333 fname += aclicMode;; 2334 fname += arguments;; 2335 fname += io;; 2336 result = gInterpreter->ExecuteMacro(fname, (TInterpreter::EErrorCode*)error);; 2337 }; 2338 delete [] mac;; 2339 ; 2340 if (padUpdate && gPad); 2341 gPad->Update();; 2342 }; 2343 ; 2344 return result;; 2345}; 2346 ; 2347////////////////////////////////////////////////////////////////////////////////; 2348/// Process message id called by obj.; 2349 ; 2350void TROOT::Message(Int_t id, const TObject *obj); 2351{; 2352 TIter next(fMessageHandlers);; 2353 TMessageHandler *mh;; 2354 while ((mh = (TMessageHandler*)next())) {; 2355 mh->HandleMessage(id,obj);; 2356 }; 2357}; 2358 ; 2359////////////////////////////////////////////////////////////////////////////////; 2360/// Process interpreter command via TApplication::ProcessLine().; 2361/// On Win32 the line will be processed asynchronously by sending; 2362/// it to the CINT interpreter thread. For explicit synchronous processing; 2363/// use ProcessLineSync(). On non-Win32 platforms there is no difference; 2364/// between ProcessLine() and ProcessLineSync().; 2365/// The possible error codes are defined by TInterpret",MatchSource.WIKI,doc/v632/TROOT_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/TROOT_8cxx_source.html
https://root.cern/doc/v632/TROOT_8cxx_source.html:97225,Integrability,rout,routine,97225,"9 const char* fwdDeclCode,; 2540 void (*triggerFunc)(),; 2541 const TInterpreter::FwdDeclArgsToKeepCollection_t& fwdDeclsArgToSkip,; 2542 const char** classesHeaders,; 2543 bool hasCxxModule); 2544{; 2545 ; 2546 // First a side track to insure proper end of process behavior.; 2547 ; 2548 // Register for each loaded dictionary (and thus for each library),; 2549 // that we need to Close the ROOT files as soon as this library; 2550 // might start being unloaded after main.; 2551 //; 2552 // By calling atexit here (rather than directly from within the; 2553 // library) we make sure that this is not called if the library is; 2554 // 'only' dlclosed.; 2555 ; 2556 // On Ubuntu the linker strips the unused libraries. Eventhough; 2557 // stressHistogram is explicitly linked against libNet, it is not; 2558 // retained and thus is loaded only as needed in the middle part of; 2559 // the execution. Concretely this also means that it is loaded; 2560 // *after* the construction of the TApplication object and thus; 2561 // after the registration (atexit) of the EndOfProcessCleanups; 2562 // routine. Consequently, after the end of main, libNet is; 2563 // unloaded before EndOfProcessCleanups is called. When; 2564 // EndOfProcessCleanups is executed it indirectly needs the TClass; 2565 // for TSocket and its search will use resources that have already; 2566 // been unloaded (technically the function static in TUnixSystem's; 2567 // DynamicPath and the dictionary from libNet).; 2568 ; 2569 // Similarly, the ordering (before this commit) was broken in the; 2570 // following case:; 2571 ; 2572 // TApplication creation (EndOfProcessCleanups registration); 2573 // load UserLibrary; 2574 // create TFile; 2575 // Append UserObject to TFile; 2576 ; 2577 // and after the end of main the order of execution was; 2578 ; 2579 // unload UserLibrary; 2580 // call EndOfProcessCleanups; 2581 // Write the TFile; 2582 // attempt to write the user object.; 2583 // ....; 2584 ; 2585 // where what we nee",MatchSource.WIKI,doc/v632/TROOT_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/TROOT_8cxx_source.html
https://root.cern/doc/v632/TROOT_8cxx_source.html:99999,Integrability,rout,routine,99999,"; 2602 ; 2603 // Now register with TCling.; 2604 if (TROOT::Initialized()) {; 2605 gCling->RegisterModule(modulename, headers, includePaths, payloadCode, fwdDeclCode, triggerFunc,; 2606 fwdDeclsArgToSkip, classesHeaders, false, hasCxxModule);; 2607 } else {; 2608 GetModuleHeaderInfoBuffer().push_back(ModuleHeaderInfo_t(modulename, headers, includePaths, payloadCode,; 2609 fwdDeclCode, triggerFunc, fwdDeclsArgToSkip,; 2610 classesHeaders, hasCxxModule));; 2611 }; 2612}; 2613 ; 2614////////////////////////////////////////////////////////////////////////////////; 2615/// Remove an object from the in-memory list.; 2616/// Since TROOT is global resource, this is lock protected.; 2617 ; 2618TObject *TROOT::Remove(TObject* obj); 2619{; 2620 R__LOCKGUARD(gROOTMutex);; 2621 return TDirectory::Remove(obj);; 2622}; 2623 ; 2624////////////////////////////////////////////////////////////////////////////////; 2625/// Remove a class from the list and map of classes.; 2626/// This routine is deprecated, use TClass::RemoveClass directly.; 2627 ; 2628void TROOT::RemoveClass(TClass *oldcl); 2629{; 2630 TClass::RemoveClass(oldcl);; 2631}; 2632 ; 2633////////////////////////////////////////////////////////////////////////////////; 2634/// Delete all global interpreter objects created since the last call to Reset; 2635///; 2636/// If option=""a"" is set reset to startup context (i.e. unload also; 2637/// all loaded files, classes, structs, typedefs, etc.).; 2638///; 2639/// This function is typically used at the beginning (or end) of an unnamed macro; 2640/// to clean the environment.; 2641///; 2642/// IMPORTANT WARNING:; 2643/// Do not use this call from within any function (neither compiled nor; 2644/// interpreted. This should only be used from a unnamed macro; 2645/// (which starts with a { (curly braces) ). For example, using TROOT::Reset; 2646/// from within an interpreted function will lead to the unloading of the; 2647/// dictionary and source file, including the one defining the fu",MatchSource.WIKI,doc/v632/TROOT_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/TROOT_8cxx_source.html
https://root.cern/doc/v632/TROOT_8cxx_source.html:108132,Integrability,message,message,108132,"qt5"": uses QWebEngine from Qt5, no real http server started (requires `qt5web` component build for ROOT); 2821/// - ""qt6"": uses QWebEngine from Qt6, no real http server started (requires `qt6web` component build for ROOT); 2822/// - ""cef"": uses Chromium Embeded Framework, no real http server started (requires `cefweb` component build for ROOT); 2823/// - ""local"": select on of available local (without http server) engines like qt5/qt6/cef; 2824/// - ""default"": system default web browser, invoked with `xdg-open` on Linux, `start` on Mac or `open` on Windows; 2825/// - ""on"": try ""local"", then ""native"", then ""default"" option; 2826/// - ""off"": turns off the web display and comes back to normal graphics in; 2827/// interactive mode.; 2828/// - ""server:port"": turns the web display into server mode with specified port. Web widgets will not be displayed,; 2829/// only text message with window URL will be printed on standard output; 2830 ; 2831void TROOT::SetWebDisplay(const char *webdisplay); 2832{; 2833 const char *wd = webdisplay ? webdisplay : """";; 2834 ; 2835 // store default values to set them back when needed; 2836 static TString brName = gEnv->GetValue(""Browser.Name"", """");; 2837 static TString trName = gEnv->GetValue(""TreeViewer.Name"", """");; 2838 ; 2839 fIsWebDisplayBatch = fBatch;; 2840 ; 2841 if (!strcmp(wd, ""off"")) {; 2842 fIsWebDisplay = kFALSE;; 2843 fWebDisplay = ""off"";; 2844 } else {; 2845 fIsWebDisplay = kTRUE;; 2846 ; 2847 // handle server mode; 2848 if (!strncmp(wd, ""server"", 6)) {; 2849 fWebDisplay = ""server"";; 2850 fIsWebDisplayBatch = kFALSE;; 2851 if (wd[6] == ':') {; 2852 if ((wd[7] >= '0') && (wd[7] <= '9')) {; 2853 auto port = TString(wd+7).Atoi();; 2854 if (port > 0); 2855 gEnv->SetValue(""WebGui.HttpPort"", port);; 2856 else; 2857 Error(""SetWebDisplay"", ""Wrong port parameter %s for server"", wd+7);; 2858 } else if (wd[7]) {; 2859 gEnv->SetValue(""WebGui.UnixSocket"", wd+7);; 2860 }; 2861 }; 2862 } else {; 2863 fWebDisplay = wd;; 2864 }; 2865 }; 2866 ; 28",MatchSource.WIKI,doc/v632/TROOT_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/TROOT_8cxx_source.html
https://root.cern/doc/v632/TROOT_8cxx_source.html:112707,Integrability,inject,inject,112707,"(a << 16) + (b << 8) + c;; 2936}; 2937 ; 2938////////////////////////////////////////////////////////////////////////////////; 2939/// Return ROOT version code as defined in RVersion.h.; 2940 ; 2941Int_t TROOT::RootVersionCode(); 2942{; 2943 return ROOT_VERSION_CODE;; 2944}; 2945////////////////////////////////////////////////////////////////////////////////; 2946/// Provide command line arguments to the interpreter construction.; 2947/// These arguments are added to the existing flags (e.g. `-DNDEBUG`).; 2948/// They are evaluated once per process, at the time where TROOT (and thus; 2949/// TInterpreter) is constructed.; 2950/// Returns the new flags.; 2951 ; 2952const std::vector<std::string> &TROOT::AddExtraInterpreterArgs(const std::vector<std::string> &args) {; 2953 static std::vector<std::string> sArgs = {};; 2954 sArgs.insert(sArgs.begin(), args.begin(), args.end());; 2955 return sArgs;; 2956}; 2957 ; 2958////////////////////////////////////////////////////////////////////////////////; 2959/// INTERNAL function!; 2960/// Used by rootcling to inject interpreter arguments through a C-interface layer.; 2961 ; 2962const char**& TROOT::GetExtraInterpreterArgs() {; 2963 static const char** extraInterpArgs = nullptr;; 2964 return extraInterpArgs;; 2965}; 2966 ; 2967////////////////////////////////////////////////////////////////////////////////; 2968 ; 2969#ifdef ROOTPREFIX; 2970static Bool_t IgnorePrefix() {; 2971 static Bool_t ignorePrefix = gSystem->Getenv(""ROOTIGNOREPREFIX"");; 2972 return ignorePrefix;; 2973}; 2974#endif; 2975 ; 2976////////////////////////////////////////////////////////////////////////////////; 2977/// Get the rootsys directory in the installation. Static utility function.; 2978 ; 2979const TString& TROOT::GetRootSys() {; 2980 // Avoid returning a reference to a temporary because of the conversion; 2981 // between std::string and TString.; 2982 const static TString rootsys = ROOT::FoundationUtils::GetRootSys();; 2983 return rootsys;; 2984}; 298",MatchSource.WIKI,doc/v632/TROOT_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/TROOT_8cxx_source.html
https://root.cern/doc/v632/TROOT_8cxx_source.html:112748,Integrability,interface,interface,112748,"(a << 16) + (b << 8) + c;; 2936}; 2937 ; 2938////////////////////////////////////////////////////////////////////////////////; 2939/// Return ROOT version code as defined in RVersion.h.; 2940 ; 2941Int_t TROOT::RootVersionCode(); 2942{; 2943 return ROOT_VERSION_CODE;; 2944}; 2945////////////////////////////////////////////////////////////////////////////////; 2946/// Provide command line arguments to the interpreter construction.; 2947/// These arguments are added to the existing flags (e.g. `-DNDEBUG`).; 2948/// They are evaluated once per process, at the time where TROOT (and thus; 2949/// TInterpreter) is constructed.; 2950/// Returns the new flags.; 2951 ; 2952const std::vector<std::string> &TROOT::AddExtraInterpreterArgs(const std::vector<std::string> &args) {; 2953 static std::vector<std::string> sArgs = {};; 2954 sArgs.insert(sArgs.begin(), args.begin(), args.end());; 2955 return sArgs;; 2956}; 2957 ; 2958////////////////////////////////////////////////////////////////////////////////; 2959/// INTERNAL function!; 2960/// Used by rootcling to inject interpreter arguments through a C-interface layer.; 2961 ; 2962const char**& TROOT::GetExtraInterpreterArgs() {; 2963 static const char** extraInterpArgs = nullptr;; 2964 return extraInterpArgs;; 2965}; 2966 ; 2967////////////////////////////////////////////////////////////////////////////////; 2968 ; 2969#ifdef ROOTPREFIX; 2970static Bool_t IgnorePrefix() {; 2971 static Bool_t ignorePrefix = gSystem->Getenv(""ROOTIGNOREPREFIX"");; 2972 return ignorePrefix;; 2973}; 2974#endif; 2975 ; 2976////////////////////////////////////////////////////////////////////////////////; 2977/// Get the rootsys directory in the installation. Static utility function.; 2978 ; 2979const TString& TROOT::GetRootSys() {; 2980 // Avoid returning a reference to a temporary because of the conversion; 2981 // between std::string and TString.; 2982 const static TString rootsys = ROOT::FoundationUtils::GetRootSys();; 2983 return rootsys;; 2984}; 298",MatchSource.WIKI,doc/v632/TROOT_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/TROOT_8cxx_source.html
https://root.cern/doc/v632/TROOT_8cxx_source.html:130327,Integrability,interface,interface,130327,"ualX.h:339; TWinNTSystem.h; ThreadLocalStorage.h; Windows4Root.h; protoconst char * protoDefinition civetweb.c:17536; ROOT::Internal::TROOTAllocatorDefinition TROOT.cxx:304; ROOT::Internal::TROOTAllocator::TROOTAllocatorTROOTAllocator()Definition TROOT.cxx:341; ROOT::Internal::TROOTAllocator::fHolderchar fHolder[sizeof(TROOT)]Definition TROOT.cxx:338; ROOT::Internal::TROOTAllocator::fObjTROOT fObjDefinition TROOT.cxx:337; ROOT::Internal::TROOTAllocator::~TROOTAllocator~TROOTAllocator()Definition TROOT.cxx:344; ROOT::TVirtualRWMutexDefinition TVirtualRWMutex.h:39; TApplication::CreateApplicationstatic void CreateApplication()Static function used to create a default application environment.Definition TApplication.cxx:1964; TBrowserUsing a TBrowser one can browse all ROOT objects.Definition TBrowser.h:37; TBrowser::SetRefreshFlagvoid SetRefreshFlag(Bool_t flag)Definition TBrowser.h:99; TCanvasThe Canvas class.Definition TCanvas.h:23; TClassGeneratorObjects following this interface can be passed onto the TROOT object to implement a user customized w...Definition TClassGenerator.h:28; TClassTableThis class registers for all classes their name, id and dictionary function in a hash table.Definition TClassTable.h:37; TClassTClass instances represent classes, structs and namespaces in the ROOT type system.Definition TClass.h:81; TClass::AddClassstatic void AddClass(TClass *cl)static: Add a class to the list and map of classes.Definition TClass.cxx:494; TClass::LoadClassstatic TClass * LoadClass(const char *requestedname, Bool_t silent)Helper function used by TClass::GetClass().Definition TClass.cxx:5749; TClass::GetDeclFileLineShort_t GetDeclFileLine() constDefinition TClass.h:429; TClass::RemoveClassstatic void RemoveClass(TClass *cl)static: Remove a class from the list and map of classesDefinition TClass.cxx:520; TClass::GetClassInfoClassInfo_t * GetClassInfo() constDefinition TClass.h:433; TClass::InheritsFromBool_t InheritsFrom(const char *cl) const overrideReturn kTRUE i",MatchSource.WIKI,doc/v632/TROOT_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/TROOT_8cxx_source.html
https://root.cern/doc/v632/TROOT_8cxx_source.html:135359,Integrability,interface,interface,135359,"aults.Definition TDirectory.cxx:249; TDirectory::CurrentDirectorystatic std::atomic< TDirectory * > & CurrentDirectory()Return the current directory for the current thread.Definition TDirectory.cxx:432; TDirectory::Removevirtual TObject * Remove(TObject *)Remove an object from the in-memory list.Definition TDirectory.cxx:1212; TDirectory::fListTList * fListDefinition TDirectory.h:142; TEnvThe TEnv class reads config files, by default named .rootrc.Definition TEnv.h:124; TEnv::GetValuevirtual Int_t GetValue(const char *name, Int_t dflt) constReturns the integer value for a resource.Definition TEnv.cxx:491; TEnv::SetValuevirtual void SetValue(const char *name, const char *value, EEnvLevel level=kEnvChange, const char *type=nullptr)Set the value of a resource or create a new resource.Definition TEnv.cxx:736; TFileA ROOT file is an on-disk file, usually with extension .root, that stores objects in a file-system-li...Definition TFile.h:53; TFolder<div class=""legacybox""><h2>Legacy Code</h2> TFolder is a legacy interface: there will be no bug fixes...Definition TFolder.h:30; TFolder::FindObjectAnyvirtual TObject * FindObjectAny(const char *name) constReturn a pointer to the first object with name starting at this folder.Definition TFolder.cxx:343; TFolder::AddFolderTFolder * AddFolder(const char *name, const char *title, TCollection *collection=nullptr)Create a new folder and add it to the list of folders of this folder, return a pointer to the created...Definition TFolder.cxx:182; TFunctionTemplateDictionary for function template This class describes one single function template.Definition TFunctionTemplate.h:26; TFunctionGlobal functions class (global functions are obtained from CINT).Definition TFunction.h:30; TGlobalMappedFunction::MakeFunctorstatic void MakeFunctor(const char *name, const char *type, GlobFunc &func)Definition TGlobal.h:73; TGlobalMappedFunction::GetEarlyRegisteredGlobalsstatic TList & GetEarlyRegisteredGlobals()Returns list collected globals Used to st",MatchSource.WIKI,doc/v632/TROOT_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/TROOT_8cxx_source.html
https://root.cern/doc/v632/TROOT_8cxx_source.html:140579,Integrability,message,messages,140579," the functions known to the interpreter for the scope 'fClass' into this collection.Definition TListOfFunctions.cxx:374; TListOfFunctions::Unloadvoid Unload()Mark 'all func' as being unloaded.Definition TListOfFunctions.cxx:409; TListOfTypesA collection of TDataType designed to hold the typedef information and numerical type information.Definition TListOfTypes.h:31; TListA doubly linked list.Definition TList.h:38; TList::Clearvoid Clear(Option_t *option="""") overrideRemove all objects from the list.Definition TList.cxx:400; TList::Addvoid Add(TObject *obj) overrideDefinition TList.h:83; TList::AddLastvoid AddLast(TObject *obj) overrideAdd object at the end of the list.Definition TList.cxx:150; TList::FirstLinkvirtual TObjLink * FirstLink() constDefinition TList.h:104; TList::Deletevoid Delete(Option_t *option="""") overrideRemove all objects from the list AND delete all heap based objects.Definition TList.cxx:468; TMacOSXSystemDefinition TMacOSXSystem.h:39; TMessageHandlerHandle messages that might be generated by the system.Definition TMessageHandler.h:34; TMessageHandler::HandleMessagevirtual void HandleMessage(Long_t id, const TObject *obj)Store message origin, keep statistics and call Notify().Definition TMessageHandler.cxx:133; TNamed::SetTitlevirtual void SetTitle(const char *title="""")Set the title of the TNamed.Definition TNamed.cxx:164; TNamed::SetNamevirtual void SetName(const char *name)Set the name of the TNamed.Definition TNamed.cxx:140; TObjArrayAn array of TObjects.Definition TObjArray.h:31; TObjArray::AtTObject * At(Int_t idx) const overrideDefinition TObjArray.h:164; TObjLinkWrapper around a TObject so it can be stored in a TList.Definition TList.h:123; TObjectMother of all ROOT objects.Definition TObject.h:41; TObject::SetObjectStatstatic void SetObjectStat(Bool_t stat)Turn on/off tracking of objects in the TObjectTable.Definition TObject.cxx:1068; TObject::GetNamevirtual const char * GetName() constReturns name of object.Definition TObject.cxx:439; TOb",MatchSource.WIKI,doc/v632/TROOT_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/TROOT_8cxx_source.html
https://root.cern/doc/v632/TROOT_8cxx_source.html:140752,Integrability,message,message,140752,"Unloadvoid Unload()Mark 'all func' as being unloaded.Definition TListOfFunctions.cxx:409; TListOfTypesA collection of TDataType designed to hold the typedef information and numerical type information.Definition TListOfTypes.h:31; TListA doubly linked list.Definition TList.h:38; TList::Clearvoid Clear(Option_t *option="""") overrideRemove all objects from the list.Definition TList.cxx:400; TList::Addvoid Add(TObject *obj) overrideDefinition TList.h:83; TList::AddLastvoid AddLast(TObject *obj) overrideAdd object at the end of the list.Definition TList.cxx:150; TList::FirstLinkvirtual TObjLink * FirstLink() constDefinition TList.h:104; TList::Deletevoid Delete(Option_t *option="""") overrideRemove all objects from the list AND delete all heap based objects.Definition TList.cxx:468; TMacOSXSystemDefinition TMacOSXSystem.h:39; TMessageHandlerHandle messages that might be generated by the system.Definition TMessageHandler.h:34; TMessageHandler::HandleMessagevirtual void HandleMessage(Long_t id, const TObject *obj)Store message origin, keep statistics and call Notify().Definition TMessageHandler.cxx:133; TNamed::SetTitlevirtual void SetTitle(const char *title="""")Set the title of the TNamed.Definition TNamed.cxx:164; TNamed::SetNamevirtual void SetName(const char *name)Set the name of the TNamed.Definition TNamed.cxx:140; TObjArrayAn array of TObjects.Definition TObjArray.h:31; TObjArray::AtTObject * At(Int_t idx) const overrideDefinition TObjArray.h:164; TObjLinkWrapper around a TObject so it can be stored in a TList.Definition TList.h:123; TObjectMother of all ROOT objects.Definition TObject.h:41; TObject::SetObjectStatstatic void SetObjectStat(Bool_t stat)Turn on/off tracking of objects in the TObjectTable.Definition TObject.cxx:1068; TObject::GetNamevirtual const char * GetName() constReturns name of object.Definition TObject.cxx:439; TObject::ClassNamevirtual const char * ClassName() constReturns name of class to which the object belongs.Definition TObject.cxx:207; TObject:",MatchSource.WIKI,doc/v632/TROOT_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/TROOT_8cxx_source.html
https://root.cern/doc/v632/TROOT_8cxx_source.html:141820,Integrability,message,message,141820,"TMessageHandler.cxx:133; TNamed::SetTitlevirtual void SetTitle(const char *title="""")Set the title of the TNamed.Definition TNamed.cxx:164; TNamed::SetNamevirtual void SetName(const char *name)Set the name of the TNamed.Definition TNamed.cxx:140; TObjArrayAn array of TObjects.Definition TObjArray.h:31; TObjArray::AtTObject * At(Int_t idx) const overrideDefinition TObjArray.h:164; TObjLinkWrapper around a TObject so it can be stored in a TList.Definition TList.h:123; TObjectMother of all ROOT objects.Definition TObject.h:41; TObject::SetObjectStatstatic void SetObjectStat(Bool_t stat)Turn on/off tracking of objects in the TObjectTable.Definition TObject.cxx:1068; TObject::GetNamevirtual const char * GetName() constReturns name of object.Definition TObject.cxx:439; TObject::ClassNamevirtual const char * ClassName() constReturns name of class to which the object belongs.Definition TObject.cxx:207; TObject::Warningvirtual void Warning(const char *method, const char *msgfmt,...) constIssue warning message.Definition TObject.cxx:973; TObject::FindObjectvirtual TObject * FindObject(const char *name) constMust be redefined in derived classes.Definition TObject.cxx:403; TObject::SetBitvoid SetBit(UInt_t f, Bool_t set)Set or unset the user status bits as specified in f.Definition TObject.cxx:780; TObject::Errorvirtual void Error(const char *method, const char *msgfmt,...) constIssue error message.Definition TObject.cxx:987; TObject::Fatalvirtual void Fatal(const char *method, const char *msgfmt,...) constIssue fatal error message.Definition TObject.cxx:1015; TObject::kInvalidObject@ kInvalidObjectif object ctor succeeded but object should not be usedDefinition TObject.h:72; TObject::kMustCleanup@ kMustCleanupif object destructor must call RecursiveRemove()Definition TObject.h:64; TPluginManagerThis class implements a plugin library manager.Definition TPluginManager.h:258; TPluginManager::LoadHandlersFromEnvvoid LoadHandlersFromEnv(TEnv *env)Load plugin handlers specified in con",MatchSource.WIKI,doc/v632/TROOT_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/TROOT_8cxx_source.html
https://root.cern/doc/v632/TROOT_8cxx_source.html:142214,Integrability,message,message,142214,"er around a TObject so it can be stored in a TList.Definition TList.h:123; TObjectMother of all ROOT objects.Definition TObject.h:41; TObject::SetObjectStatstatic void SetObjectStat(Bool_t stat)Turn on/off tracking of objects in the TObjectTable.Definition TObject.cxx:1068; TObject::GetNamevirtual const char * GetName() constReturns name of object.Definition TObject.cxx:439; TObject::ClassNamevirtual const char * ClassName() constReturns name of class to which the object belongs.Definition TObject.cxx:207; TObject::Warningvirtual void Warning(const char *method, const char *msgfmt,...) constIssue warning message.Definition TObject.cxx:973; TObject::FindObjectvirtual TObject * FindObject(const char *name) constMust be redefined in derived classes.Definition TObject.cxx:403; TObject::SetBitvoid SetBit(UInt_t f, Bool_t set)Set or unset the user status bits as specified in f.Definition TObject.cxx:780; TObject::Errorvirtual void Error(const char *method, const char *msgfmt,...) constIssue error message.Definition TObject.cxx:987; TObject::Fatalvirtual void Fatal(const char *method, const char *msgfmt,...) constIssue fatal error message.Definition TObject.cxx:1015; TObject::kInvalidObject@ kInvalidObjectif object ctor succeeded but object should not be usedDefinition TObject.h:72; TObject::kMustCleanup@ kMustCleanupif object destructor must call RecursiveRemove()Definition TObject.h:64; TPluginManagerThis class implements a plugin library manager.Definition TPluginManager.h:258; TPluginManager::LoadHandlersFromEnvvoid LoadHandlersFromEnv(TEnv *env)Load plugin handlers specified in config file, like:Definition TPluginManager.cxx:391; TProcessID::Cleanupstatic void Cleanup()static function (called by TROOT destructor) to delete all TProcessIDsDefinition TProcessID.cxx:204; TProcessID::AddProcessIDstatic TProcessID * AddProcessID()Static function to add a new TProcessID to the list of PIDs.Definition TProcessID.cxx:116; TProcessUUIDThis class is a specialized TProcessID mana",MatchSource.WIKI,doc/v632/TROOT_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/TROOT_8cxx_source.html
https://root.cern/doc/v632/TROOT_8cxx_source.html:142350,Integrability,message,message,142350," TObject::SetObjectStatstatic void SetObjectStat(Bool_t stat)Turn on/off tracking of objects in the TObjectTable.Definition TObject.cxx:1068; TObject::GetNamevirtual const char * GetName() constReturns name of object.Definition TObject.cxx:439; TObject::ClassNamevirtual const char * ClassName() constReturns name of class to which the object belongs.Definition TObject.cxx:207; TObject::Warningvirtual void Warning(const char *method, const char *msgfmt,...) constIssue warning message.Definition TObject.cxx:973; TObject::FindObjectvirtual TObject * FindObject(const char *name) constMust be redefined in derived classes.Definition TObject.cxx:403; TObject::SetBitvoid SetBit(UInt_t f, Bool_t set)Set or unset the user status bits as specified in f.Definition TObject.cxx:780; TObject::Errorvirtual void Error(const char *method, const char *msgfmt,...) constIssue error message.Definition TObject.cxx:987; TObject::Fatalvirtual void Fatal(const char *method, const char *msgfmt,...) constIssue fatal error message.Definition TObject.cxx:1015; TObject::kInvalidObject@ kInvalidObjectif object ctor succeeded but object should not be usedDefinition TObject.h:72; TObject::kMustCleanup@ kMustCleanupif object destructor must call RecursiveRemove()Definition TObject.h:64; TPluginManagerThis class implements a plugin library manager.Definition TPluginManager.h:258; TPluginManager::LoadHandlersFromEnvvoid LoadHandlersFromEnv(TEnv *env)Load plugin handlers specified in config file, like:Definition TPluginManager.cxx:391; TProcessID::Cleanupstatic void Cleanup()static function (called by TROOT destructor) to delete all TProcessIDsDefinition TProcessID.cxx:204; TProcessID::AddProcessIDstatic TProcessID * AddProcessID()Static function to add a new TProcessID to the list of PIDs.Definition TProcessID.cxx:116; TProcessUUIDThis class is a specialized TProcessID managing the list of UUIDs.Definition TProcessUUID.h:32; TQObject::BlockAllSignalsstatic Bool_t BlockAllSignals(Bool_t b)Block or unblock",MatchSource.WIKI,doc/v632/TROOT_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/TROOT_8cxx_source.html
https://root.cern/doc/v632/TROOT_8cxx_source.html:143975,Integrability,message,message,143975,"delete all TProcessIDsDefinition TProcessID.cxx:204; TProcessID::AddProcessIDstatic TProcessID * AddProcessID()Static function to add a new TProcessID to the list of PIDs.Definition TProcessID.cxx:116; TProcessUUIDThis class is a specialized TProcessID managing the list of UUIDs.Definition TProcessUUID.h:32; TQObject::BlockAllSignalsstatic Bool_t BlockAllSignals(Bool_t b)Block or unblock all signals. Returns the previous block status.Definition TQObject.cxx:1057; TROOTROOT top level object description.Definition TROOT.h:94; TROOT::IncreaseDirLevelstatic Int_t IncreaseDirLevel()Increase the indentation level for ls().Definition TROOT.cxx:2883; TROOT::IgnoreIncludeInt_t IgnoreInclude(const char *fname, const char *expandedfname)Return 1 if the name of the given include file corresponds to a class that is known to ROOT,...Definition TROOT.cxx:1928; TROOT::fVersionCodeInt_t fVersionCodeROOT version code as used in RVersion.h.Definition TROOT.h:115; TROOT::Messagevoid Message(Int_t id, const TObject *obj)Process message id called by obj.Definition TROOT.cxx:2350; TROOT::RemoveClassvoid RemoveClass(TClass *)Remove a class from the list and map of classes.Definition TROOT.cxx:2628; TROOT::fProofsTSeqCollection * fProofsList of proof sessions.Definition TROOT.h:162; TROOT::fClassGeneratorsTCollection * fClassGeneratorsList of user defined class generators;.Definition TROOT.h:160; TROOT::TROOTTROOT()Only used by Dictionary.Definition TROOT.cxx:605; TROOT::SetCutClassNamevoid SetCutClassName(const char *name=""TCutG"")Set the default graphical cut class name for the graphics editor By default the graphics editor creat...Definition TROOT.cxx:2683; TROOT::fCanvasesTSeqCollection * fCanvasesList of canvases.Definition TROOT.h:149; TROOT::FindObjectAnyFileTObject * FindObjectAnyFile(const char *name) const overrideScan the memory lists of all files for an object with name.Definition TROOT.cxx:1436; TROOT::fPrimitiveconst TObject * fPrimitiveCurrently selected primitive.Definition T",MatchSource.WIKI,doc/v632/TROOT_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/TROOT_8cxx_source.html
https://root.cern/doc/v632/TROOT_8cxx_source.html:148279,Integrability,message,message,148279,"t char * GetMacroPath()Get macro search path. Static utility function.Definition TROOT.cxx:2762; TROOT::fFunctionsTCollection * fFunctionsList of analytic functions.Definition TROOT.h:151; TROOT::SaveContextvoid SaveContext()Save the current interpreter context.Definition TROOT.cxx:2671; TROOT::IsExecutingMacroBool_t IsExecutingMacro() constDefinition TROOT.h:280; TROOT::GetTypeTDataType * GetType(const char *name, Bool_t load=kFALSE) constReturn pointer to type with name.Definition TROOT.cxx:1562; TROOT::Initializestatic void Initialize()Initialize ROOT explicitly.Definition TROOT.cxx:2899; TROOT::ShutDownstatic void ShutDown()Shut down ROOT.Definition TROOT.cxx:3136; TROOT::GetFunctionTObject * GetFunction(const char *name) constReturn pointer to function with name.Definition TROOT.cxx:1587; TROOT::ConvertVersionCode2Intstatic Int_t ConvertVersionCode2Int(Int_t code)Convert version code to an integer, i.e. 331527 -> 51507.Definition TROOT.cxx:2922; TROOT::fMessageHandlersTSeqCollection * fMessageHandlersList of message handlers.Definition TROOT.h:158; TROOT::SetStylevoid SetStyle(const char *stylename=""Default"")Change current style to style with name stylename.Definition TROOT.cxx:2730; TROOT::fEnumsAListOfEnums_t fEnumsList of enum types.Definition TROOT.h:165; TROOT::ReadGitInfovoid ReadGitInfo()Read Git commit SHA1 and branch name.Definition TROOT.cxx:2429; TROOT::fgRootInitstatic Bool_t fgRootInitSingleton initialization flag.Definition TROOT.h:103; TROOT::RefreshBrowsersvoid RefreshBrowsers()Refresh all browsers.Definition TROOT.cxx:2512; TROOT::CloseFilesvoid CloseFiles()Close any files and sockets that gROOT knows about.Definition TROOT.cxx:1168; TROOT::fApplicationstd::atomic< TApplication * > fApplicationPointer to current application.Definition TROOT.h:124; TROOT::FindObjectPathNameconst char * FindObjectPathName(const TObject *obj) constReturn path name of obj somewhere in the //root/... path.Definition TROOT.cxx:1473; TROOT::ConvertVersionInt2Codestatic",MatchSource.WIKI,doc/v632/TROOT_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/TROOT_8cxx_source.html
https://root.cern/doc/v632/TROOT_8cxx_source.html:154269,Integrability,synchroniz,synchronize,154269,"OT::fSecContextsTSeqCollection * fSecContextsList of security contexts (TSecContext)Definition TROOT.h:161; TROOT::fWebDisplayTString fWebDisplayIf not empty it defines where web graphics should be rendered (cef, qt5, browser.....Definition TROOT.h:127; TROOT::GetTutorialsDirstatic const char * GetTutorialsDir()Get the tutorials directory in the installation.Definition TROOT.cxx:3211; TROOT::GetListOfFunctionOverloadsTCollection * GetListOfFunctionOverloads(const char *name) constReturn the collection of functions named ""name"".Definition TROOT.cxx:1672; TROOT::fCleanupsTSeqCollection * fCleanupsList of recursiveRemove collections.Definition TROOT.h:157; TROOT::Initializedstatic Bool_t Initialized()Return kTRUE if the TROOT object has been initialized.Definition TROOT.cxx:2906; TROOT::SetBatchvoid SetBatch(Bool_t batch=kTRUE)Set batch mode for ROOT If the argument evaluates to true, the session does not use interactive graph...Definition TROOT.cxx:2803; TROOT::fLineIsProcessingInt_t fLineIsProcessingTo synchronize multi-threads.Definition TROOT.h:100; TROOT::GetSourceDirstatic const TString & GetSourceDir()Get the source directory in the installation. Static utility function.Definition TROOT.cxx:3147; TROOT::GetMacroDirstatic const TString & GetMacroDir()Get the macro directory in the installation. Static utility function.Definition TROOT.cxx:3094; TROOT::fGitCommitTString fGitCommitGit commit SHA1 of built.Definition TROOT.h:120; TROOT::ProcessLineLongptr_t ProcessLine(const char *line, Int_t *error=nullptr)Process interpreter command via TApplication::ProcessLine().Definition TROOT.cxx:2370; TROOT::fClosedObjectsTSeqCollection * fClosedObjectsList of closed objects from the list of files and sockets, so we can delete them if neededCl.Definition TROOT.h:145; TROOT::fTasksTSeqCollection * fTasksList of tasks.Definition TROOT.h:152; TROOT::fClipboardTSeqCollection * fClipboardList of clipboard objects.Definition TROOT.h:163; TROOT::GetGitDateconst char * GetGitDate()R",MatchSource.WIKI,doc/v632/TROOT_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/TROOT_8cxx_source.html
https://root.cern/doc/v632/TROOT_8cxx_source.html:157622,Integrability,rout,routine,157622,"OT.cxx:2316; TROOT::fBuiltTimeInt_t fBuiltTimeTime of ROOT built.Definition TROOT.h:119; TROOT::AddExtraInterpreterArgsstatic const std::vector< std::string > & AddExtraInterpreterArgs(const std::vector< std::string > &args)Provide command line arguments to the interpreter construction.Definition TROOT.cxx:2952; TROOT::GetClassTClass * GetClass(const char *name, Bool_t load=kTRUE, Bool_t silent=kFALSE) constReturn pointer to class with name. Obsolete, use TClass::GetClass directly.Definition TROOT.cxx:1518; TROOT::fSelectPadTVirtualPad * fSelectPadCurrently selected pad.Definition TROOT.h:139; TROOT::fFilesTSeqCollection * fFilesList of files.Definition TROOT.h:146; TROOT::Browsevoid Browse(TBrowser *b) overrideAdd browsable objects to TBrowser.Definition TROOT.cxx:1056; TROOT::GetRootSysstatic const TString & GetRootSys()Get the rootsys directory in the installation. Static utility function.Definition TROOT.cxx:2979; TROOT::GetGlobalFunctionsTListOfFunctions * GetGlobalFunctions()Internal routine returning, and creating if necessary, the list of global function.Definition TROOT.cxx:1663; TROOT::fInterruptBool_t fInterruptTrue if macro should be interrupted.Definition TROOT.h:134; TROOT::fMustCleanBool_t fMustCleanTrue if object destructor scans canvases.Definition TROOT.h:132; TROOT::LoadClassInt_t LoadClass(const char *classname, const char *libname, Bool_t check=kFALSE)Check if class ""classname"" is known to the interpreter (in fact, this check is not needed anymore,...Definition TROOT.cxx:2183; TROOT::GetGlobalFunctionTFunction * GetGlobalFunction(const char *name, const char *params=nullptr, Bool_t load=kFALSE)Return pointer to global function by name.Definition TROOT.cxx:1685; TROOT::AddClassvoid AddClass(TClass *cl)Add a class to the list and map of classes.Definition TROOT.cxx:1025; TROOT::RootVersionCodestatic Int_t RootVersionCode()Return ROOT version code as defined in RVersion.h.Definition TROOT.cxx:2941; TROOT::FindSpecialObjectTObject * FindSpecialObject",MatchSource.WIKI,doc/v632/TROOT_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/TROOT_8cxx_source.html
https://root.cern/doc/v632/TROOT_8cxx_source.html:158902,Integrability,interface,interface,158902," scans canvases.Definition TROOT.h:132; TROOT::LoadClassInt_t LoadClass(const char *classname, const char *libname, Bool_t check=kFALSE)Check if class ""classname"" is known to the interpreter (in fact, this check is not needed anymore,...Definition TROOT.cxx:2183; TROOT::GetGlobalFunctionTFunction * GetGlobalFunction(const char *name, const char *params=nullptr, Bool_t load=kFALSE)Return pointer to global function by name.Definition TROOT.cxx:1685; TROOT::AddClassvoid AddClass(TClass *cl)Add a class to the list and map of classes.Definition TROOT.cxx:1025; TROOT::RootVersionCodestatic Int_t RootVersionCode()Return ROOT version code as defined in RVersion.h.Definition TROOT.cxx:2941; TROOT::FindSpecialObjectTObject * FindSpecialObject(const char *name, void *&where)Returns address and folder of a ROOT object if it exists.Definition TROOT.cxx:1367; TROOT::RemoveTObject * Remove(TObject *) overrideRemove an object from the in-memory list.Definition TROOT.cxx:2618; TROOT::InitSystemvoid InitSystem()Operating System interface.Definition TROOT.cxx:1978; TROOT::ProcessLineFastLongptr_t ProcessLineFast(const char *line, Int_t *error=nullptr)Process interpreter command directly via CINT interpreter.Definition TROOT.cxx:2407; TROOT::ClassSavedBool_t ClassSaved(TClass *cl)return class status 'ClassSaved' for class cl This function is called by the SavePrimitive functions ...Definition TROOT.cxx:1083; TROOT::fGitBranchTString fGitBranchGit branch.Definition TROOT.h:121; TROOT::GetListOfTypesTCollection * GetListOfTypes(Bool_t load=kFALSE)Return a dynamic list giving access to all TDataTypes (typedefs) currently defined.Definition TROOT.cxx:1865; TROOT::fgDirLevelstatic Int_t fgDirLevelIndentation level for ls()Definition TROOT.h:102; TROOT::IsRootFileBool_t IsRootFile(const char *filename) constReturn true if the file is local and is (likely) to be a ROOT file.Definition TROOT.cxx:2230; TROOT::IndentLevelstatic void IndentLevel()Functions used by ls() to indent an object hierarch",MatchSource.WIKI,doc/v632/TROOT_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/TROOT_8cxx_source.html
https://root.cern/doc/v632/TROOT_8cxx_source.html:160419,Integrability,inject,inject,160419,ection * GetListOfTypes(Bool_t load=kFALSE)Return a dynamic list giving access to all TDataTypes (typedefs) currently defined.Definition TROOT.cxx:1865; TROOT::fgDirLevelstatic Int_t fgDirLevelIndentation level for ls()Definition TROOT.h:102; TROOT::IsRootFileBool_t IsRootFile(const char *filename) constReturn true if the file is local and is (likely) to be a ROOT file.Definition TROOT.cxx:2230; TROOT::IndentLevelstatic void IndentLevel()Functions used by ls() to indent an object hierarchy.Definition TROOT.cxx:2891; TROOT::GetDocDirstatic const TString & GetDocDir()Get the documentation directory in the installation. Static utility function.Definition TROOT.cxx:3078; TROOT::GetEtcDirstatic const TString & GetEtcDir()Get the sysconfig directory in the installation. Static utility function.Definition TROOT.cxx:3052; TROOT::GetNclassesInt_t GetNclasses() constGet number of classes.Definition TROOT.cxx:1876; TROOT::GetExtraInterpreterArgsstatic const char **& GetExtraInterpreterArgs()INTERNAL function! Used by rootcling to inject interpreter arguments through a C-interface layer.Definition TROOT.cxx:2962; TROOT::SetMacroPathstatic void SetMacroPath(const char *newpath)Set or extend the macro search path.Definition TROOT.cxx:2788; TROOT::InitThreadsvoid InitThreads()Initialize threads library.Definition TROOT.cxx:2053; TROOT::fUUIDsTProcessUUID * fUUIDsPointer to TProcessID managing TUUIDs.Definition TROOT.h:166; TROOT::fConfigFeaturesTString fConfigFeaturesROOT ./configure detected build features.Definition TROOT.h:112; TROOT::GetFunctionTemplateTFunctionTemplate * GetFunctionTemplate(const char *name)Definition TROOT.cxx:1618; TROOT::fPluginManagerTPluginManager * fPluginManagerKeeps track of plugin library handlers.Definition TROOT.h:169; TROOT::GetGeometryTObject * GetGeometry(const char *name) constReturn pointer to Geometry with name.Definition TROOT.cxx:1747; TROOT::RecursiveRemovevoid RecursiveRemove(TObject *obj) overrideRecursively remove this object from the l,MatchSource.WIKI,doc/v632/TROOT_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/TROOT_8cxx_source.html
https://root.cern/doc/v632/TROOT_8cxx_source.html:160460,Integrability,interface,interface,160460,ection * GetListOfTypes(Bool_t load=kFALSE)Return a dynamic list giving access to all TDataTypes (typedefs) currently defined.Definition TROOT.cxx:1865; TROOT::fgDirLevelstatic Int_t fgDirLevelIndentation level for ls()Definition TROOT.h:102; TROOT::IsRootFileBool_t IsRootFile(const char *filename) constReturn true if the file is local and is (likely) to be a ROOT file.Definition TROOT.cxx:2230; TROOT::IndentLevelstatic void IndentLevel()Functions used by ls() to indent an object hierarchy.Definition TROOT.cxx:2891; TROOT::GetDocDirstatic const TString & GetDocDir()Get the documentation directory in the installation. Static utility function.Definition TROOT.cxx:3078; TROOT::GetEtcDirstatic const TString & GetEtcDir()Get the sysconfig directory in the installation. Static utility function.Definition TROOT.cxx:3052; TROOT::GetNclassesInt_t GetNclasses() constGet number of classes.Definition TROOT.cxx:1876; TROOT::GetExtraInterpreterArgsstatic const char **& GetExtraInterpreterArgs()INTERNAL function! Used by rootcling to inject interpreter arguments through a C-interface layer.Definition TROOT.cxx:2962; TROOT::SetMacroPathstatic void SetMacroPath(const char *newpath)Set or extend the macro search path.Definition TROOT.cxx:2788; TROOT::InitThreadsvoid InitThreads()Initialize threads library.Definition TROOT.cxx:2053; TROOT::fUUIDsTProcessUUID * fUUIDsPointer to TProcessID managing TUUIDs.Definition TROOT.h:166; TROOT::fConfigFeaturesTString fConfigFeaturesROOT ./configure detected build features.Definition TROOT.h:112; TROOT::GetFunctionTemplateTFunctionTemplate * GetFunctionTemplate(const char *name)Definition TROOT.cxx:1618; TROOT::fPluginManagerTPluginManager * fPluginManagerKeeps track of plugin library handlers.Definition TROOT.h:169; TROOT::GetGeometryTObject * GetGeometry(const char *name) constReturn pointer to Geometry with name.Definition TROOT.cxx:1747; TROOT::RecursiveRemovevoid RecursiveRemove(TObject *obj) overrideRecursively remove this object from the l,MatchSource.WIKI,doc/v632/TROOT_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/TROOT_8cxx_source.html
https://root.cern/doc/v632/TROOT_8cxx_source.html:166415,Integrability,interface,interface,166415," kBothDefinition TString.h:276; TString::kIgnoreCase@ kIgnoreCaseDefinition TString.h:277; TString::LastSsiz_t Last(char c) constFind last occurrence of a character c.Definition TString.cxx:931; TString::BeginsWithBool_t BeginsWith(const char *s, ECaseCompare cmp=kExact) constDefinition TString.h:623; TString::IsNullBool_t IsNull() constDefinition TString.h:414; TString::RemoveTString & Remove(Ssiz_t pos)Definition TString.h:685; TString::Formvoid Form(const char *fmt,...)Formats a string using a printf style format descriptor.Definition TString.cxx:2356; TString::ContainsBool_t Contains(const char *pat, ECaseCompare cmp=kExact) constDefinition TString.h:632; TStyleTStyle objects may be created to define special styles.Definition TStyle.h:29; TStyle::BuildStylesstatic void BuildStyles()Create some standard styles.Definition TStyle.cxx:524; TSystemDirectoryDescribes an Operating System directory for the browser.Definition TSystemDirectory.h:32; TSystemAbstract base class defining a generic interface to the underlying Operating System.Definition TSystem.h:260; TSystem::DynFindSymbolvirtual Func_t DynFindSymbol(const char *module, const char *entry)Find specific entry point in specified library.Definition TSystem.cxx:2044; TSystem::Getenvvirtual const char * Getenv(const char *env)Get environment variable.Definition TSystem.cxx:1665; TSystem::SplitAclicModevirtual TString SplitAclicMode(const char *filename, TString &mode, TString &args, TString &io) constThis method split a filename of the form:Definition TSystem.cxx:4258; TSystem::CleanCompiledMacrosvirtual void CleanCompiledMacros()Remove the shared libs produced by the CompileMacro() function, together with their rootmaps,...Definition TSystem.cxx:4369; TSystem::Loadvirtual int Load(const char *module, const char *entry="""", Bool_t system=kFALSE)Load a shared library.Definition TSystem.cxx:1857; TSystem::GetPathInfoint GetPathInfo(const char *path, Long_t *id, Long_t *size, Long_t *flags, Long_t *modtime)Get info abo",MatchSource.WIKI,doc/v632/TROOT_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/TROOT_8cxx_source.html
https://root.cern/doc/v632/TROOT_8cxx_source.html:167900,Integrability,interface,interface,167900,"ing &io) constThis method split a filename of the form:Definition TSystem.cxx:4258; TSystem::CleanCompiledMacrosvirtual void CleanCompiledMacros()Remove the shared libs produced by the CompileMacro() function, together with their rootmaps,...Definition TSystem.cxx:4369; TSystem::Loadvirtual int Load(const char *module, const char *entry="""", Bool_t system=kFALSE)Load a shared library.Definition TSystem.cxx:1857; TSystem::GetPathInfoint GetPathInfo(const char *path, Long_t *id, Long_t *size, Long_t *flags, Long_t *modtime)Get info about a file: id, size, flags, modification time.Definition TSystem.cxx:1398; TSystem::PrependPathNamevirtual const char * PrependPathName(const char *dir, TString &name)Concatenate a directory and a file name.Definition TSystem.cxx:1081; TSystem::AccessPathNamevirtual Bool_t AccessPathName(const char *path, EAccessMode mode=kFileExists)Returns FALSE if one can access a file using the specified access mode.Definition TSystem.cxx:1296; TSystem::Initvirtual Bool_t Init()Initialize the OS interface.Definition TSystem.cxx:183; TSystem::BaseNamevirtual const char * BaseName(const char *pathname)Base name of a file name. Base name of /user/root is root.Definition TSystem.cxx:934; TSystem::WorkingDirectoryvirtual const char * WorkingDirectory()Return working directory.Definition TSystem.cxx:871; TSystem::Whichvirtual char * Which(const char *search, const char *file, EAccessMode mode=kFileExists)Find location of file in a search path.Definition TSystem.cxx:1548; TSystem::HomeDirectoryvirtual const char * HomeDirectory(const char *userName=nullptr)Return the user's home directory.Definition TSystem.cxx:887; TSystem::GetErrorvirtual const char * GetError()Return system error string.Definition TSystem.cxx:254; TSystem::ResetSignalsvirtual void ResetSignals()Reset signals handlers to previous behaviour.Definition TSystem.cxx:584; TSystem::DynamicPathNamechar * DynamicPathName(const char *lib, Bool_t quiet=kFALSE)Find a dynamic library called lib using ",MatchSource.WIKI,doc/v632/TROOT_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/TROOT_8cxx_source.html
https://root.cern/doc/v632/TROOT_8cxx_source.html:169079,Integrability,interface,interface,169079,"root.Definition TSystem.cxx:934; TSystem::WorkingDirectoryvirtual const char * WorkingDirectory()Return working directory.Definition TSystem.cxx:871; TSystem::Whichvirtual char * Which(const char *search, const char *file, EAccessMode mode=kFileExists)Find location of file in a search path.Definition TSystem.cxx:1548; TSystem::HomeDirectoryvirtual const char * HomeDirectory(const char *userName=nullptr)Return the user's home directory.Definition TSystem.cxx:887; TSystem::GetErrorvirtual const char * GetError()Return system error string.Definition TSystem.cxx:254; TSystem::ResetSignalsvirtual void ResetSignals()Reset signals handlers to previous behaviour.Definition TSystem.cxx:584; TSystem::DynamicPathNamechar * DynamicPathName(const char *lib, Bool_t quiet=kFALSE)Find a dynamic library called lib using the system search paths.Definition TSystem.cxx:2020; TUnixSystemDefinition TUnixSystem.h:32; TUrlThis class represents a WWW compatible URL.Definition TUrl.h:33; TVirtualMutexThis class implements a mutex interface.Definition TVirtualMutex.h:32; TVirtualPadTVirtualPad is an abstract base class for the Pad and Canvas classes.Definition TVirtualPad.h:51; TVirtualPad::Padstatic TVirtualPad *& Pad()Return the current pad for the current thread.Definition TVirtualPad.cxx:82; TVirtualPad::GetVirtCanvasvirtual TVirtualPad * GetVirtCanvas() const =0; TVirtualXSemi-Abstract base class defining a generic interface to the underlying, low level,...Definition TVirtualX.h:46; TVirtualX::Instancestatic TVirtualX *& Instance()Returns gVirtualX global.Definition TVirtualX.cxx:57; TWinNTSystemDefinition TWinNTSystem.h:58; bool; int; unsigned int; lineTLine * lineDefinition entrylistblock_figure1.C:235; f1TF1 * f1Definition legend1.C:11; ROOT::Detail::HasBeenDeletedR__ALWAYS_INLINE bool HasBeenDeleted(const TObject *obj)Check if the TObject's memory has been deleted.Definition TObject.h:402; ROOT::FoundationUtils::GetIncludeDirconst std::string & GetIncludeDir()\ returns the include dir",MatchSource.WIKI,doc/v632/TROOT_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/TROOT_8cxx_source.html
https://root.cern/doc/v632/TROOT_8cxx_source.html:169476,Integrability,interface,interface,169476,"rectory(const char *userName=nullptr)Return the user's home directory.Definition TSystem.cxx:887; TSystem::GetErrorvirtual const char * GetError()Return system error string.Definition TSystem.cxx:254; TSystem::ResetSignalsvirtual void ResetSignals()Reset signals handlers to previous behaviour.Definition TSystem.cxx:584; TSystem::DynamicPathNamechar * DynamicPathName(const char *lib, Bool_t quiet=kFALSE)Find a dynamic library called lib using the system search paths.Definition TSystem.cxx:2020; TUnixSystemDefinition TUnixSystem.h:32; TUrlThis class represents a WWW compatible URL.Definition TUrl.h:33; TVirtualMutexThis class implements a mutex interface.Definition TVirtualMutex.h:32; TVirtualPadTVirtualPad is an abstract base class for the Pad and Canvas classes.Definition TVirtualPad.h:51; TVirtualPad::Padstatic TVirtualPad *& Pad()Return the current pad for the current thread.Definition TVirtualPad.cxx:82; TVirtualPad::GetVirtCanvasvirtual TVirtualPad * GetVirtCanvas() const =0; TVirtualXSemi-Abstract base class defining a generic interface to the underlying, low level,...Definition TVirtualX.h:46; TVirtualX::Instancestatic TVirtualX *& Instance()Returns gVirtualX global.Definition TVirtualX.cxx:57; TWinNTSystemDefinition TWinNTSystem.h:58; bool; int; unsigned int; lineTLine * lineDefinition entrylistblock_figure1.C:235; f1TF1 * f1Definition legend1.C:11; ROOT::Detail::HasBeenDeletedR__ALWAYS_INLINE bool HasBeenDeleted(const TObject *obj)Check if the TObject's memory has been deleted.Definition TObject.h:402; ROOT::FoundationUtils::GetIncludeDirconst std::string & GetIncludeDir()\ returns the include directory in the installation.Definition FoundationUtils.cxx:180; ROOT::FoundationUtils::GetRootSysconst std::string & GetRootSys()Definition FoundationUtils.cxx:158; ROOT::FoundationUtils::GetEtcDirconst std::string & GetEtcDir()Definition FoundationUtils.cxx:195; ROOT::Internal::VecOps::voidvoid(off) SmallVectorTemplateBase< T; ROOT::InternalDefinition TErrorDefaultHa",MatchSource.WIKI,doc/v632/TROOT_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/TROOT_8cxx_source.html
https://root.cern/doc/v632/TROOT_8cxx_source.html:171755,Integrability,message,message,171755,"lDefinition TROOT.h:379; ROOT::Internal::DisableParBranchProcessingvoid DisableParBranchProcessing()Globally disables the IMT use case of parallel branch processing, deactivating the corresponding lock...Definition TROOT.cxx:434; ROOT::Internal::ErrorSystemMsgHandlerFunc_tstd::function< const char *()> ErrorSystemMsgHandlerFunc_tRetrieves the error string associated with the last system error.Definition TError.h:59; ROOT::Internal::IsImplicitMTEnabledImplstatic Bool_t & IsImplicitMTEnabledImpl()Keeps track of the status of ImplicitMT w/o resorting to the load of libImt.Definition TROOT.cxx:463; ROOT::Internal::MinimalErrorHandlervoid MinimalErrorHandler(int level, Bool_t abort, const char *location, const char *msg)A very simple error handler that is usually replaced by the TROOT default error handler.Definition TError.cxx:67; ROOT::Internal::GetROOTFun_tTROOT *(* GetROOTFun_t)()Definition TROOT.cxx:397; ROOT::Internal::SetErrorSystemMsgHandlerErrorSystemMsgHandlerFunc_t SetErrorSystemMsgHandler(ErrorSystemMsgHandlerFunc_t h)Returns the previous system error message handler.Definition TError.cxx:56; ROOT::Internal::EnableParBranchProcessingvoid EnableParBranchProcessing()Globally enables the parallel branch processing, which is a case of implicit multi-threading (IMT) in...Definition TROOT.cxx:420; ROOT::Internal::IsParBranchProcessingEnabledBool_t IsParBranchProcessingEnabled()Returns true if parallel branch processing is enabled.Definition TROOT.cxx:447; ROOT::Internal::GetROOT2TROOT * GetROOT2()Definition TROOT.cxx:387; ROOT::Internal::GetROOT1TROOT * GetROOT1()Definition TROOT.cxx:380; ROOT::Internal::ReleaseDefaultErrorHandlervoid ReleaseDefaultErrorHandler()Destructs resources that are taken by using the default error handler.Definition TErrorDefaultHandler.cxx:47; ROOT::Minuit2::GradientParameterSpace::Internal@ Internal; ROOTtbb::task_arena is an alias of tbb::interface7::task_arena, which doesn't allow to forward declare tb...Definition EExecutionPolicy.hxx",MatchSource.WIKI,doc/v632/TROOT_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/TROOT_8cxx_source.html
https://root.cern/doc/v632/TROOT_8cxx_source.html:10342,Modifiability,variab,variable,10342,"asses and related header files; 282 const TROOT::FwdDeclArgsToKeepCollection_t fFwdNargsToKeepColl; // Collection of; 283 // pairs of template fwd decls and number of; 284 bool fHasCxxModule; // Whether this module has a C++ module alongside it.; 285 };; 286 ; 287 std::vector<ModuleHeaderInfo_t>& GetModuleHeaderInfoBuffer() {; 288 static std::vector<ModuleHeaderInfo_t> moduleHeaderInfoBuffer;; 289 return moduleHeaderInfoBuffer;; 290 }; 291}; 292 ; 293Int_t TROOT::fgDirLevel = 0;; 294Bool_t TROOT::fgRootInit = kFALSE;; 295 ; 296static void at_exit_of_TROOT() {; 297 if (ROOT::Internal::gROOTLocal); 298 ROOT::Internal::gROOTLocal->~TROOT();; 299}; 300 ; 301// This local static object initializes the ROOT system; 302namespace ROOT {; 303namespace Internal {; 304 class TROOTAllocator {; 305 // Simple wrapper to separate, time-wise, the call to the; 306 // TROOT destructor and the actual free-ing of the memory.; 307 //; 308 // Since the interpreter implementation (currently TCling) is; 309 // loaded via dlopen by libCore, the destruction of its global; 310 // variable (i.e. in particular clang's) is scheduled before; 311 // those in libCore so we need to schedule the call to the TROOT; 312 // destructor before that *but* we want to make sure the memory; 313 // stay around until libCore itself is unloaded so that code; 314 // using gROOT can 'properly' check for validity.; 315 //; 316 // The order of loading for is:; 317 // libCore.so; 318 // libRint.so; 319 // ... anything other library hard linked to the executable ...; 320 // ... for example libEvent; 321 // libCling.so; 322 // ... other libraries like libTree for example ....; 323 // and the destruction order is (of course) the reverse.; 324 // By default the unloading of the dictionary, does use; 325 // the service of the interpreter ... which of course; 326 // fails if libCling is already unloaded by that information; 327 // has not been registered per se.; 328 //; 329 // To solve this problem, we now schedule the de",MatchSource.WIKI,doc/v632/TROOT_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/TROOT_8cxx_source.html
https://root.cern/doc/v632/TROOT_8cxx_source.html:17471,Modifiability,plug-in,plug-ins,17471," Internal sub namespace; 470// back to ROOT namespace; 471 ; 472 TROOT *GetROOT() {; 473 return (*Internal::gGetROOT)();; 474 }; 475 ; 476 TString &GetMacroPath() {; 477 static TString macroPath;; 478 return macroPath;; 479 }; 480 ; 481 // clang-format off; 482 ////////////////////////////////////////////////////////////////////////////////; 483 /// Enables the global mutex to make ROOT thread safe/aware.; 484 ///; 485 /// The following becomes safe:; 486 /// - concurrent construction and destruction of TObjects, including the ones registered in ROOT's global lists (e.g. gROOT->GetListOfCleanups(), gROOT->GetListOfFiles()); 487 /// - concurrent usage of _different_ ROOT objects from different threads, including ones with global state (e.g. TFile, TTree, TChain) with the exception of graphics classes (e.g. TCanvas); 488 /// - concurrent calls to ROOT's type system classes, e.g. TClass and TEnum; 489 /// - concurrent calls to the interpreter through gInterpreter; 490 /// - concurrent loading of ROOT plug-ins; 491 ///; 492 /// In addition, gDirectory, gFile and gPad become a thread-local variable.; 493 /// In all threads, gDirectory defaults to gROOT, a singleton which supports thread-safe insertion and deletion of contents.; 494 /// gFile and gPad default to nullptr, as it is for single-thread programs.; 495 ///; 496 /// The ROOT graphics subsystem is not made thread-safe by this method. In particular drawing or printing different; 497 /// canvases from different threads (and analogous operations such as invoking `Draw` on a `TObject`) is not thread-safe.; 498 ///; 499 /// Note that there is no `DisableThreadSafety()`. ROOT's thread-safety features cannot be disabled once activated.; 500 // clang-format on; 501 void EnableThreadSafety(); 502 {; 503 static void (*sym)() = (void(*)())Internal::GetSymInLibImt(""ROOT_TThread_Initialize"");; 504 if (sym); 505 sym();; 506 }; 507 ; 508 ////////////////////////////////////////////////////////////////////////////////; 509 /// @p",MatchSource.WIKI,doc/v632/TROOT_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/TROOT_8cxx_source.html
https://root.cern/doc/v632/TROOT_8cxx_source.html:17560,Modifiability,variab,variable,17560," Internal sub namespace; 470// back to ROOT namespace; 471 ; 472 TROOT *GetROOT() {; 473 return (*Internal::gGetROOT)();; 474 }; 475 ; 476 TString &GetMacroPath() {; 477 static TString macroPath;; 478 return macroPath;; 479 }; 480 ; 481 // clang-format off; 482 ////////////////////////////////////////////////////////////////////////////////; 483 /// Enables the global mutex to make ROOT thread safe/aware.; 484 ///; 485 /// The following becomes safe:; 486 /// - concurrent construction and destruction of TObjects, including the ones registered in ROOT's global lists (e.g. gROOT->GetListOfCleanups(), gROOT->GetListOfFiles()); 487 /// - concurrent usage of _different_ ROOT objects from different threads, including ones with global state (e.g. TFile, TTree, TChain) with the exception of graphics classes (e.g. TCanvas); 488 /// - concurrent calls to ROOT's type system classes, e.g. TClass and TEnum; 489 /// - concurrent calls to the interpreter through gInterpreter; 490 /// - concurrent loading of ROOT plug-ins; 491 ///; 492 /// In addition, gDirectory, gFile and gPad become a thread-local variable.; 493 /// In all threads, gDirectory defaults to gROOT, a singleton which supports thread-safe insertion and deletion of contents.; 494 /// gFile and gPad default to nullptr, as it is for single-thread programs.; 495 ///; 496 /// The ROOT graphics subsystem is not made thread-safe by this method. In particular drawing or printing different; 497 /// canvases from different threads (and analogous operations such as invoking `Draw` on a `TObject`) is not thread-safe.; 498 ///; 499 /// Note that there is no `DisableThreadSafety()`. ROOT's thread-safety features cannot be disabled once activated.; 500 // clang-format on; 501 void EnableThreadSafety(); 502 {; 503 static void (*sym)() = (void(*)())Internal::GetSymInLibImt(""ROOT_TThread_Initialize"");; 504 if (sym); 505 sym();; 506 }; 507 ; 508 ////////////////////////////////////////////////////////////////////////////////; 509 /// @p",MatchSource.WIKI,doc/v632/TROOT_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/TROOT_8cxx_source.html
https://root.cern/doc/v632/TROOT_8cxx_source.html:19890,Modifiability,config,configured,19890,"e:; 517 ///; 518 /// - RDataFrame internally runs the event-loop by parallelizing over clusters of entries; 519 /// - TTree::GetEntry reads multiple branches in parallel; 520 /// - TTree::FlushBaskets writes multiple baskets to disk in parallel; 521 /// - TTreeCacheUnzip decompresses the baskets contained in a TTreeCache in parallel; 522 /// - THx::Fit performs in parallel the evaluation of the objective function over the data; 523 /// - TMVA::DNN trains the deep neural networks in parallel; 524 /// - TMVA::BDT trains the classifier in parallel and multiclass BDTs are evaluated in parallel; 525 ///; 526 /// EnableImplicitMT calls in turn EnableThreadSafety.; 527 /// The 'numthreads' parameter allows to control the number of threads to; 528 /// be used by the implicit multi-threading. However, this parameter is just; 529 /// a hint for ROOT: it will try to satisfy the request if the execution; 530 /// scenario allows it. For example, if ROOT is configured to use an external; 531 /// scheduler, setting a value for 'numthreads' might not have any effect.; 532 /// The maximum number of threads can be influenced by the environment; 533 /// variable `ROOT_MAX_THREADS`: `export ROOT_MAX_THREADS=2` will try to set; 534 /// the maximum number of active threads to 2, if the scheduling library; 535 /// (such as tbb) ""permits"".; 536 ///; 537 /// \note Use `DisableImplicitMT()` to disable multi-threading (some locks will remain in place as; 538 /// described in EnableThreadSafety()). `EnableImplicitMT(1)` creates a thread-pool of size 1.; 539 void EnableImplicitMT(UInt_t numthreads); 540 {; 541#ifdef R__USE_IMT; 542 if (ROOT::Internal::IsImplicitMTEnabledImpl()); 543 return;; 544 EnableThreadSafety();; 545 static void (*sym)(UInt_t) = (void(*)(UInt_t))Internal::GetSymInLibImt(""ROOT_TImplicitMT_EnableImplicitMT"");; 546 if (sym); 547 sym(numthreads);; 548 ROOT::Internal::IsImplicitMTEnabledImpl() = true;; 549#else; 550 ::Warning(""EnableImplicitMT"", ""Cannot enable implicit multi-th",MatchSource.WIKI,doc/v632/TROOT_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/TROOT_8cxx_source.html
https://root.cern/doc/v632/TROOT_8cxx_source.html:20085,Modifiability,variab,variable,20085,"rites multiple baskets to disk in parallel; 521 /// - TTreeCacheUnzip decompresses the baskets contained in a TTreeCache in parallel; 522 /// - THx::Fit performs in parallel the evaluation of the objective function over the data; 523 /// - TMVA::DNN trains the deep neural networks in parallel; 524 /// - TMVA::BDT trains the classifier in parallel and multiclass BDTs are evaluated in parallel; 525 ///; 526 /// EnableImplicitMT calls in turn EnableThreadSafety.; 527 /// The 'numthreads' parameter allows to control the number of threads to; 528 /// be used by the implicit multi-threading. However, this parameter is just; 529 /// a hint for ROOT: it will try to satisfy the request if the execution; 530 /// scenario allows it. For example, if ROOT is configured to use an external; 531 /// scheduler, setting a value for 'numthreads' might not have any effect.; 532 /// The maximum number of threads can be influenced by the environment; 533 /// variable `ROOT_MAX_THREADS`: `export ROOT_MAX_THREADS=2` will try to set; 534 /// the maximum number of active threads to 2, if the scheduling library; 535 /// (such as tbb) ""permits"".; 536 ///; 537 /// \note Use `DisableImplicitMT()` to disable multi-threading (some locks will remain in place as; 538 /// described in EnableThreadSafety()). `EnableImplicitMT(1)` creates a thread-pool of size 1.; 539 void EnableImplicitMT(UInt_t numthreads); 540 {; 541#ifdef R__USE_IMT; 542 if (ROOT::Internal::IsImplicitMTEnabledImpl()); 543 return;; 544 EnableThreadSafety();; 545 static void (*sym)(UInt_t) = (void(*)(UInt_t))Internal::GetSymInLibImt(""ROOT_TImplicitMT_EnableImplicitMT"");; 546 if (sym); 547 sym(numthreads);; 548 ROOT::Internal::IsImplicitMTEnabledImpl() = true;; 549#else; 550 ::Warning(""EnableImplicitMT"", ""Cannot enable implicit multi-threading with %d threads, please build ROOT with -Dimt=ON"", numthreads);; 551#endif; 552 }; 553 ; 554 ////////////////////////////////////////////////////////////////////////////////; 555 /// Disables th",MatchSource.WIKI,doc/v632/TROOT_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/TROOT_8cxx_source.html
https://root.cern/doc/v632/TROOT_8cxx_source.html:22553,Modifiability,variab,variable,22553,";; 565#endif; 566 }; 567 ; 568 ////////////////////////////////////////////////////////////////////////////////; 569 /// Returns true if the implicit multi-threading in ROOT is enabled.; 570 Bool_t IsImplicitMTEnabled(); 571 {; 572 return ROOT::Internal::IsImplicitMTEnabledImpl();; 573 }; 574 ; 575 ////////////////////////////////////////////////////////////////////////////////; 576 /// Returns the size of ROOT's thread pool; 577 UInt_t GetThreadPoolSize(); 578 {; 579#ifdef R__USE_IMT; 580 static UInt_t (*sym)() = (UInt_t(*)())Internal::GetSymInLibImt(""ROOT_MT_GetThreadPoolSize"");; 581 if (sym); 582 return sym();; 583 else; 584 return 0;; 585#else; 586 return 0;; 587#endif; 588 }; 589} // end of ROOT namespace; 590 ; 591TROOT *ROOT::Internal::gROOTLocal = ROOT::GetROOT();; 592 ; 593// Global debug flag (set to > 0 to get debug output).; 594// Can be set either via the interpreter (gDebug is exported to CINT),; 595// via the rootrc resource ""Root.Debug"", via the shell environment variable; 596// ROOTDEBUG, or via the debugger.; 597Int_t gDebug;; 598 ; 599 ; 600ClassImp(TROOT);; 601 ; 602////////////////////////////////////////////////////////////////////////////////; 603/// Default ctor.; 604 ; 605TROOT::TROOT() : TDirectory(),; 606 fLineIsProcessing(0), fVersion(0), fVersionInt(0), fVersionCode(0),; 607 fVersionDate(0), fVersionTime(0), fBuiltDate(0), fBuiltTime(0),; 608 fTimer(0), fApplication(nullptr), fInterpreter(nullptr), fBatch(kTRUE),; 609 fIsWebDisplay(kFALSE), fIsWebDisplayBatch(kFALSE), fEditHistograms(kTRUE),; 610 fFromPopUp(kTRUE),fMustClean(kTRUE),fForceStyle(kFALSE),; 611 fInterrupt(kFALSE),fEscape(kFALSE),fExecutingMacro(kFALSE),fEditorMode(0),; 612 fPrimitive(nullptr),fSelectPad(nullptr),fClasses(nullptr),fTypes(nullptr),fGlobals(nullptr),fGlobalFunctions(nullptr),; 613 fClosedObjects(nullptr),fFiles(nullptr),fMappedFiles(nullptr),fSockets(nullptr),fCanvases(nullptr),fStyles(nullptr),fFunctions(nullptr),; 614 fTasks(nullptr),fColors(nullptr),fGeometri",MatchSource.WIKI,doc/v632/TROOT_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/TROOT_8cxx_source.html
https://root.cern/doc/v632/TROOT_8cxx_source.html:25015,Modifiability,extend,extend,25015,"of the TROOT object initializes; 623/// the ROOT system. It must be the first ROOT related action that is; 624/// performed by a program. The TROOT object must be created on the stack; 625/// (can not be called via new since ""operator new"" is protected). The; 626/// TROOT object is either created as a global object (outside the main(); 627/// program), or it is one of the first objects created in main().; 628/// Make sure that the TROOT object stays in scope for as long as ROOT; 629/// related actions are performed. TROOT is a so called singleton so; 630/// only one instance of it can be created. The single TROOT object can; 631/// always be accessed via the global pointer gROOT.; 632/// The name and title arguments can be used to identify the running; 633/// application. The initfunc argument can contain an array of; 634/// function pointers (last element must be 0). These functions are; 635/// executed at the end of the constructor. This way one can easily; 636/// extend the ROOT system without adding permanent dependencies; 637/// (e.g. the graphics system is initialized via such a function).; 638 ; 639TROOT::TROOT(const char *name, const char *title, VoidFuncPtr_t *initfunc); 640 : TDirectory(), fLineIsProcessing(0), fVersion(0), fVersionInt(0), fVersionCode(0),; 641 fVersionDate(0), fVersionTime(0), fBuiltDate(0), fBuiltTime(0),; 642 fTimer(0), fApplication(nullptr), fInterpreter(nullptr), fBatch(kTRUE),; 643 fIsWebDisplay(kFALSE), fIsWebDisplayBatch(kFALSE), fEditHistograms(kTRUE),; 644 fFromPopUp(kTRUE),fMustClean(kTRUE),fForceStyle(kFALSE),; 645 fInterrupt(kFALSE),fEscape(kFALSE),fExecutingMacro(kFALSE),fEditorMode(0),; 646 fPrimitive(nullptr),fSelectPad(nullptr),fClasses(nullptr),fTypes(nullptr),fGlobals(nullptr),fGlobalFunctions(nullptr),; 647 fClosedObjects(nullptr),fFiles(nullptr),fMappedFiles(nullptr),fSockets(nullptr),fCanvases(nullptr),fStyles(nullptr),fFunctions(nullptr),; 648 fTasks(nullptr),fColors(nullptr),fGeometries(nullptr),fBrowsers(nullptr),fS",MatchSource.WIKI,doc/v632/TROOT_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/TROOT_8cxx_source.html
https://root.cern/doc/v632/TROOT_8cxx_source.html:28347,Modifiability,plugin,plugin,28347,"NFIGUREOPTIONS;; 700 fConfigFeatures = R__CONFIGUREFEATURES;; 701 fVersion = ROOT_RELEASE;; 702 fVersionCode = ROOT_VERSION_CODE;; 703 fVersionInt = IVERSQ();; 704 fVersionDate = IDATQQ(ROOT_RELEASE_DATE);; 705 fVersionTime = ITIMQQ(ROOT_RELEASE_TIME);; 706 fBuiltDate = IDATQQ(__DATE__);; 707 fBuiltTime = ITIMQQ(__TIME__);; 708 ; 709 ReadGitInfo();; 710 ; 711 fClasses = new THashTable(800,3); fClasses->UseRWLock();; 712 //fIdMap = new IdMap_t;; 713 fStreamerInfo = new TObjArray(100); fStreamerInfo->UseRWLock();; 714 fClassGenerators = new TList;; 715 ; 716 // usedToIdentifyRootClingByDlSym is available when TROOT is part of; 717 // rootcling.; 718 if (!dlsym(RTLD_DEFAULT, ""usedToIdentifyRootClingByDlSym"")) {; 719 // initialize plugin manager early; 720 fPluginManager->LoadHandlersFromEnv(gEnv);; 721 }; 722 ; 723 TSystemDirectory *workdir = new TSystemDirectory(""workdir"", gSystem->WorkingDirectory());; 724 ; 725 auto setNameLocked = [](TSeqCollection *l, const char *collection_name) {; 726 l->SetName(collection_name);; 727 l->UseRWLock();; 728 return l;; 729 };; 730 ; 731 fTimer = 0;; 732 fApplication = nullptr;; 733 fColors = setNameLocked(new TObjArray(1000), ""ListOfColors"");; 734 fTypes = nullptr;; 735 fGlobals = nullptr;; 736 fGlobalFunctions = nullptr;; 737 // fList was created in TDirectory::Build but with different sizing.; 738 delete fList;; 739 fList = new THashList(1000,3); fList->UseRWLock();; 740 fClosedObjects = setNameLocked(new TList, ""ClosedFiles"");; 741 fFiles = setNameLocked(new TList, ""Files"");; 742 fMappedFiles = setNameLocked(new TList, ""MappedFiles"");; 743 fSockets = setNameLocked(new TList, ""Sockets"");; 744 fCanvases = setNameLocked(new TList, ""Canvases"");; 745 fStyles = setNameLocked(new TList, ""Styles"");; 746 fFunctions = setNameLocked(new TList, ""Functions"");; 747 fTasks = setNameLocked(new TList, ""Tasks"");; 748 fGeometries = setNameLocked(new TList, ""Geometries"");; 749 fBrowsers = setNameLocked(new TList, ""Browsers"");; 750 fSpecials = setNa",MatchSource.WIKI,doc/v632/TROOT_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/TROOT_8cxx_source.html
https://root.cern/doc/v632/TROOT_8cxx_source.html:56200,Modifiability,variab,variable,56200,"///////////////////////////////////////////////////////////////////////; 1434/// Scan the memory lists of all files for an object with name; 1435 ; 1436TObject *TROOT::FindObjectAnyFile(const char *name) const; 1437{; 1438 R__LOCKGUARD(gROOTMutex);; 1439 TDirectory *d;; 1440 TIter next(GetListOfFiles());; 1441 while ((d = (TDirectory*)next())) {; 1442 // Call explicitly TDirectory::FindObject to restrict the search to the; 1443 // already in memory object.; 1444 TObject *obj = d->TDirectory::FindObject(name);; 1445 if (obj) return obj;; 1446 }; 1447 return nullptr;; 1448}; 1449 ; 1450////////////////////////////////////////////////////////////////////////////////; 1451/// Returns class name of a ROOT object including CINT globals.; 1452 ; 1453const char *TROOT::FindObjectClassName(const char *name) const; 1454{; 1455 // Search first in the list of ""standard"" objects; 1456 TObject *obj = FindObject(name);; 1457 if (obj) return obj->ClassName();; 1458 ; 1459 // Is it a global variable?; 1460 TGlobal *g = GetGlobal(name);; 1461 if (g) return g->GetTypeName();; 1462 ; 1463 return nullptr;; 1464}; 1465 ; 1466////////////////////////////////////////////////////////////////////////////////; 1467/// Return path name of obj somewhere in the //root/... path.; 1468/// The function returns the first occurence of the object in the list; 1469/// of folders. The returned string points to a static char array in TROOT.; 1470/// If this function is called in a loop or recursively, it is the; 1471/// user's responsibility to copy this string in their area.; 1472 ; 1473const char *TROOT::FindObjectPathName(const TObject *) const; 1474{; 1475 Error(""FindObjectPathName"",""Not yet implemented"");; 1476 return ""??"";; 1477}; 1478 ; 1479////////////////////////////////////////////////////////////////////////////////; 1480/// return a TClass object corresponding to 'name' assuming it is an STL container.; 1481/// In particular we looking for possible alternative name (default template; 1482/// ",MatchSource.WIKI,doc/v632/TROOT_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/TROOT_8cxx_source.html
https://root.cern/doc/v632/TROOT_8cxx_source.html:62624,Modifiability,variab,variable,62624,"ject and the if statement; 1596 bool wasInited = isInited.load();; 1597 ; 1598 auto f1 = fFunctions->FindObject(name);; 1599 if (f1 || wasInited); 1600 return f1;; 1601 ; 1602 // If 2 threads gets here at the same time, the static initialization ""lock""; 1603 // will stall one of them until ProcessLine is finished and both will return the; 1604 // correct answer.; 1605 // Note: if one (or more) thread(s) is suspended right after the 'isInited.load()`; 1606 // and restart after this thread has finished the initialization (i.e. a rare case),; 1607 // the only penalty we pay is a spurious 2nd lookup for an unknown function.; 1608 [[maybe_unused]] static const auto _res = []() {; 1609 gROOT->ProcessLine(""TF1::InitStandardFunctions();"");; 1610 isInited = true;; 1611 return true;; 1612 }();; 1613 return fFunctions->FindObject(name);; 1614}; 1615 ; 1616////////////////////////////////////////////////////////////////////////////////; 1617 ; 1618TFunctionTemplate *TROOT::GetFunctionTemplate(const char *name); 1619{; 1620 if (!gInterpreter) return nullptr;; 1621 ; 1622 if (!fFuncTemplate) fFuncTemplate = new TListOfFunctionTemplates(nullptr);; 1623 ; 1624 return (TFunctionTemplate*)fFuncTemplate->FindObject(name);; 1625}; 1626 ; 1627////////////////////////////////////////////////////////////////////////////////; 1628/// Return pointer to global variable by name. If load is true force; 1629/// reading of all currently defined globals from CINT (more expensive).; 1630 ; 1631TGlobal *TROOT::GetGlobal(const char *name, Bool_t load) const; 1632{; 1633 return (TGlobal *)gROOT->GetListOfGlobals(load)->FindObject(name);; 1634}; 1635 ; 1636////////////////////////////////////////////////////////////////////////////////; 1637/// Return pointer to global variable with address addr.; 1638 ; 1639TGlobal *TROOT::GetGlobal(const TObject *addr, Bool_t /* load */) const; 1640{; 1641 if (addr == nullptr || ((Longptr_t)addr) == -1) return nullptr;; 1642 ; 1643 TInterpreter::DeclId_t decl = gInte",MatchSource.WIKI,doc/v632/TROOT_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/TROOT_8cxx_source.html
https://root.cern/doc/v632/TROOT_8cxx_source.html:63031,Modifiability,variab,variable,63031,"8 [[maybe_unused]] static const auto _res = []() {; 1609 gROOT->ProcessLine(""TF1::InitStandardFunctions();"");; 1610 isInited = true;; 1611 return true;; 1612 }();; 1613 return fFunctions->FindObject(name);; 1614}; 1615 ; 1616////////////////////////////////////////////////////////////////////////////////; 1617 ; 1618TFunctionTemplate *TROOT::GetFunctionTemplate(const char *name); 1619{; 1620 if (!gInterpreter) return nullptr;; 1621 ; 1622 if (!fFuncTemplate) fFuncTemplate = new TListOfFunctionTemplates(nullptr);; 1623 ; 1624 return (TFunctionTemplate*)fFuncTemplate->FindObject(name);; 1625}; 1626 ; 1627////////////////////////////////////////////////////////////////////////////////; 1628/// Return pointer to global variable by name. If load is true force; 1629/// reading of all currently defined globals from CINT (more expensive).; 1630 ; 1631TGlobal *TROOT::GetGlobal(const char *name, Bool_t load) const; 1632{; 1633 return (TGlobal *)gROOT->GetListOfGlobals(load)->FindObject(name);; 1634}; 1635 ; 1636////////////////////////////////////////////////////////////////////////////////; 1637/// Return pointer to global variable with address addr.; 1638 ; 1639TGlobal *TROOT::GetGlobal(const TObject *addr, Bool_t /* load */) const; 1640{; 1641 if (addr == nullptr || ((Longptr_t)addr) == -1) return nullptr;; 1642 ; 1643 TInterpreter::DeclId_t decl = gInterpreter->GetDataMemberAtAddr(addr);; 1644 if (decl) {; 1645 TListOfDataMembers *globals = ((TListOfDataMembers*)(gROOT->GetListOfGlobals(kFALSE)));; 1646 return (TGlobal*)globals->Get(decl);; 1647 }; 1648 // If we are actually looking for a global that is held by a global; 1649 // pointer (for example gRandom), we need to find a pointer with the; 1650 // correct value.; 1651 decl = gInterpreter->GetDataMemberWithValue(addr);; 1652 if (decl) {; 1653 TListOfDataMembers *globals = ((TListOfDataMembers*)(gROOT->GetListOfGlobals(kFALSE)));; 1654 return (TGlobal*)globals->Get(decl);; 1655 }; 1656 return nullptr;; 1657}; 1658 ; 165",MatchSource.WIKI,doc/v632/TROOT_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/TROOT_8cxx_source.html
https://root.cern/doc/v632/TROOT_8cxx_source.html:76618,Modifiability,variab,variable,76618,"56 // detected already before).; 1957 return 0;; 1958 }; 1959 cla = R__GetClassIfKnown(className);; 1960 }; 1961 ; 1962 if (!cla) {; 1963 return 0;; 1964 }; 1965 ; 1966 // cla is valid, check wether it's actually in the header of the same name:; 1967 if (cla->GetDeclFileLine() <= 0) return 0; // to a void an error with VisualC++; 1968 TString decfile = gSystem->BaseName(cla->GetDeclFileName());; 1969 if (decfile != gSystem->BaseName(fname)) {; 1970 return 0;; 1971 }; 1972 return 1;; 1973}; 1974 ; 1975////////////////////////////////////////////////////////////////////////////////; 1976/// Initialize operating system interface.; 1977 ; 1978void TROOT::InitSystem(); 1979{; 1980 if (gSystem == nullptr) {; 1981#if defined(R__UNIX); 1982#if defined(R__HAS_COCOA); 1983 gSystem = new TMacOSXSystem;; 1984#else; 1985 gSystem = new TUnixSystem;; 1986#endif; 1987#elif defined(R__WIN32); 1988 gSystem = new TWinNTSystem;; 1989#else; 1990 gSystem = new TSystem;; 1991#endif; 1992 ; 1993 if (gSystem->Init()); 1994 fprintf(stderr, ""Fatal in <TROOT::InitSystem>: can't init operating system layer\n"");; 1995 ; 1996 if (!gSystem->HomeDirectory()) {; 1997 fprintf(stderr, ""Fatal in <TROOT::InitSystem>: HOME directory not set\n"");; 1998 fprintf(stderr, ""Fix this by defining the HOME shell variable\n"");; 1999 }; 2000 ; 2001 // read default files; 2002 gEnv = new TEnv("".rootrc"");; 2003 ; 2004 ROOT::Internal::SetErrorSystemMsgHandler([](){ return gSystem->GetError(); });; 2005 SetErrorHandler(DefaultErrorHandler);; 2006 ; 2007 gDebug = gEnv->GetValue(""Root.Debug"", 0);; 2008 ; 2009 if (!gEnv->GetValue(""Root.ErrorHandlers"", 1)); 2010 gSystem->ResetSignals();; 2011 ; 2012 // The old ""Root.ZipMode"" had a discrepancy between documentation vs actual meaning.; 2013 // Also, a value with the meaning ""default"" wasn't available. To solved this,; 2014 // ""Root.ZipMode"" was replaced by ""Root.CompressionAlgorithm"". Warn about usage of; 2015 // the old value, if it's set to 0, but silently translate the set",MatchSource.WIKI,doc/v632/TROOT_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/TROOT_8cxx_source.html
https://root.cern/doc/v632/TROOT_8cxx_source.html:91610,Modifiability,variab,variable,91610,"interpreter command via TApplication::ProcessLine().; 2383/// On Win32 the line will be processed synchronously (i.e. it will; 2384/// only return when the CINT interpreter thread has finished executing; 2385/// the line). On non-Win32 platforms there is no difference between; 2386/// ProcessLine() and ProcessLineSync().; 2387/// The possible error codes are defined by TInterpreter::EErrorCode.; 2388/// Returns the result of the command, cast to a Longptr_t.; 2389 ; 2390Longptr_t TROOT::ProcessLineSync(const char *line, Int_t *error); 2391{; 2392 TString sline = line;; 2393 sline = sline.Strip(TString::kBoth);; 2394 ; 2395 if (!fApplication.load()); 2396 TApplication::CreateApplication();; 2397 ; 2398 return (*fApplication).ProcessLine(sline, kTRUE, error);; 2399}; 2400 ; 2401////////////////////////////////////////////////////////////////////////////////; 2402/// Process interpreter command directly via CINT interpreter.; 2403/// Only executable statements are allowed (no variable declarations),; 2404/// In all other cases use TROOT::ProcessLine().; 2405/// The possible error codes are defined by TInterpreter::EErrorCode.; 2406 ; 2407Longptr_t TROOT::ProcessLineFast(const char *line, Int_t *error); 2408{; 2409 TString sline = line;; 2410 sline = sline.Strip(TString::kBoth);; 2411 ; 2412 if (!fApplication.load()); 2413 TApplication::CreateApplication();; 2414 ; 2415 Longptr_t result = 0;; 2416 ; 2417 if (fInterpreter) {; 2418 TInterpreter::EErrorCode *code = (TInterpreter::EErrorCode*)error;; 2419 result = gInterpreter->Calc(sline, code);; 2420 }; 2421 ; 2422 return result;; 2423}; 2424 ; 2425////////////////////////////////////////////////////////////////////////////////; 2426/// Read Git commit information and branch name from the; 2427/// etc/gitinfo.txt file.; 2428 ; 2429void TROOT::ReadGitInfo(); 2430{; 2431 TString filename = ""gitinfo.txt"";; 2432 gSystem->PrependPathName(TROOT::GetEtcDir(), filename);; 2433 ; 2434 FILE *fp = fopen(filename, ""r"");; 2435 if (fp)",MatchSource.WIKI,doc/v632/TROOT_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/TROOT_8cxx_source.html
https://root.cern/doc/v632/TROOT_8cxx_source.html:105733,Modifiability,extend,extend,105733,"seDirLevel(); 2747{; 2748 return --fgDirLevel;; 2749}; 2750 ; 2751////////////////////////////////////////////////////////////////////////////////; 2752///return directory level; 2753 ; 2754Int_t TROOT::GetDirLevel(); 2755{; 2756 return fgDirLevel;; 2757}; 2758 ; 2759////////////////////////////////////////////////////////////////////////////////; 2760/// Get macro search path. Static utility function.; 2761 ; 2762const char *TROOT::GetMacroPath(); 2763{; 2764 TString &macroPath = ROOT::GetMacroPath();; 2765 ; 2766 if (macroPath.Length() == 0) {; 2767 macroPath = gEnv->GetValue(""Root.MacroPath"", (char*)nullptr);; 2768#if defined(R__WIN32); 2769 macroPath.ReplaceAll(""; "", "";"");; 2770#else; 2771 macroPath.ReplaceAll("": "", "":"");; 2772#endif; 2773 if (macroPath.Length() == 0); 2774#if !defined(R__WIN32); 2775 macroPath = "".:"" + TROOT::GetMacroDir();; 2776#else; 2777 macroPath = "".;"" + TROOT::GetMacroDir();; 2778#endif; 2779 }; 2780 ; 2781 return macroPath;; 2782}; 2783 ; 2784////////////////////////////////////////////////////////////////////////////////; 2785/// Set or extend the macro search path. Static utility function.; 2786/// If newpath=0 or """" reset to value specified in the rootrc file.; 2787 ; 2788void TROOT::SetMacroPath(const char *newpath); 2789{; 2790 TString &macroPath = ROOT::GetMacroPath();; 2791 ; 2792 if (!newpath || !*newpath); 2793 macroPath = """";; 2794 else; 2795 macroPath = newpath;; 2796}; 2797 ; 2798////////////////////////////////////////////////////////////////////////////////; 2799/// Set batch mode for ROOT; 2800/// If the argument evaluates to `true`, the session does not use interactive graphics.; 2801/// If web graphics runs in server mode, the web widgets are still available via URL; 2802 ; 2803void TROOT::SetBatch(Bool_t batch); 2804{; 2805 fIsWebDisplayBatch = fBatch = batch;; 2806 if (fIsWebDisplayBatch && (fWebDisplay == ""server"")); 2807 fIsWebDisplayBatch = kFALSE;; 2808}; 2809 ; 2810//////////////////////////////////////////////////",MatchSource.WIKI,doc/v632/TROOT_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/TROOT_8cxx_source.html
https://root.cern/doc/v632/TROOT_8cxx_source.html:109312,Modifiability,config,configured,109312,"alues to set them back when needed; 2836 static TString brName = gEnv->GetValue(""Browser.Name"", """");; 2837 static TString trName = gEnv->GetValue(""TreeViewer.Name"", """");; 2838 ; 2839 fIsWebDisplayBatch = fBatch;; 2840 ; 2841 if (!strcmp(wd, ""off"")) {; 2842 fIsWebDisplay = kFALSE;; 2843 fWebDisplay = ""off"";; 2844 } else {; 2845 fIsWebDisplay = kTRUE;; 2846 ; 2847 // handle server mode; 2848 if (!strncmp(wd, ""server"", 6)) {; 2849 fWebDisplay = ""server"";; 2850 fIsWebDisplayBatch = kFALSE;; 2851 if (wd[6] == ':') {; 2852 if ((wd[7] >= '0') && (wd[7] <= '9')) {; 2853 auto port = TString(wd+7).Atoi();; 2854 if (port > 0); 2855 gEnv->SetValue(""WebGui.HttpPort"", port);; 2856 else; 2857 Error(""SetWebDisplay"", ""Wrong port parameter %s for server"", wd+7);; 2858 } else if (wd[7]) {; 2859 gEnv->SetValue(""WebGui.UnixSocket"", wd+7);; 2860 }; 2861 }; 2862 } else {; 2863 fWebDisplay = wd;; 2864 }; 2865 }; 2866 ; 2867 if (fIsWebDisplay) {; 2868 // restore browser classes configured at the moment when gROOT->SetWebDisplay() was called for the first time; 2869 // This is necessary when SetWebDisplay() called several times and therefore current settings may differ; 2870 gEnv->SetValue(""Canvas.Name"", ""TWebCanvas"");; 2871 gEnv->SetValue(""Browser.Name"", brName);; 2872 gEnv->SetValue(""TreeViewer.Name"", ""RTreeViewer"");; 2873 } else {; 2874 gEnv->SetValue(""Canvas.Name"", ""TRootCanvas"");; 2875 gEnv->SetValue(""Browser.Name"", ""TRootBrowser"");; 2876 gEnv->SetValue(""TreeViewer.Name"", trName);; 2877 }; 2878}; 2879 ; 2880////////////////////////////////////////////////////////////////////////////////; 2881/// Increase the indentation level for ls().; 2882 ; 2883Int_t TROOT::IncreaseDirLevel(); 2884{; 2885 return ++fgDirLevel;; 2886}; 2887 ; 2888////////////////////////////////////////////////////////////////////////////////; 2889/// Functions used by ls() to indent an object hierarchy.; 2890 ; 2891void TROOT::IndentLevel(); 2892{; 2893 for (int i = 0; i < fgDirLevel; i++) std::cout.put(' ');; 2894}; 2",MatchSource.WIKI,doc/v632/TROOT_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/TROOT_8cxx_source.html
https://root.cern/doc/v632/TROOT_8cxx_source.html:131358,Modifiability,inherit,inherits,131358,"nterface can be passed onto the TROOT object to implement a user customized w...Definition TClassGenerator.h:28; TClassTableThis class registers for all classes their name, id and dictionary function in a hash table.Definition TClassTable.h:37; TClassTClass instances represent classes, structs and namespaces in the ROOT type system.Definition TClass.h:81; TClass::AddClassstatic void AddClass(TClass *cl)static: Add a class to the list and map of classes.Definition TClass.cxx:494; TClass::LoadClassstatic TClass * LoadClass(const char *requestedname, Bool_t silent)Helper function used by TClass::GetClass().Definition TClass.cxx:5749; TClass::GetDeclFileLineShort_t GetDeclFileLine() constDefinition TClass.h:429; TClass::RemoveClassstatic void RemoveClass(TClass *cl)static: Remove a class from the list and map of classesDefinition TClass.cxx:520; TClass::GetClassInfoClassInfo_t * GetClassInfo() constDefinition TClass.h:433; TClass::InheritsFromBool_t InheritsFrom(const char *cl) const overrideReturn kTRUE if this class inherits from a class with name ""classname"".Definition TClass.cxx:4874; TClass::GetDeclFileNameconst char * GetDeclFileName() constReturn name of the file containing the declaration of this class.Definition TClass.cxx:3463; TClass::GetClassstatic TClass * GetClass(const char *name, Bool_t load=kTRUE, Bool_t silent=kFALSE)Static method returning pointer to TClass of the specified class name.Definition TClass.cxx:2968; TCollectionCollection abstract base class.Definition TCollection.h:65; TCollection::RecursiveRemovevoid RecursiveRemove(TObject *obj) overrideRemove object from this collection and recursively remove the object from all other objects (and coll...Definition TCollection.cxx:574; TCollection::UseRWLockvirtual bool UseRWLock(Bool_t enable=true)Set this collection to use a RW lock upon access, making it thread safe.Definition TCollection.cxx:761; TCollection::AddAllvirtual void AddAll(const TCollection *col)Add all objects from collection col to th",MatchSource.WIKI,doc/v632/TROOT_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/TROOT_8cxx_source.html
https://root.cern/doc/v632/TROOT_8cxx_source.html:134752,Modifiability,config,config,134752,"tDefinition TDirectory.h:222; TDirectory::lsvoid ls(Option_t *option="""") const overrideList Directory contents.Definition TDirectory.cxx:1143; TDirectory::Appendvirtual void Append(TObject *obj, Bool_t replace=kFALSE)Append object to this directory.Definition TDirectory.cxx:199; TDirectory::SetNamevoid SetName(const char *newname) overrideSet the name for directory If the directory name is changed after the directory was written once,...Definition TDirectory.cxx:1287; TDirectory::BuildDirectoryvoid BuildDirectory(TFile *motherFile, TDirectory *motherDir)Initialise directory to defaults.Definition TDirectory.cxx:249; TDirectory::CurrentDirectorystatic std::atomic< TDirectory * > & CurrentDirectory()Return the current directory for the current thread.Definition TDirectory.cxx:432; TDirectory::Removevirtual TObject * Remove(TObject *)Remove an object from the in-memory list.Definition TDirectory.cxx:1212; TDirectory::fListTList * fListDefinition TDirectory.h:142; TEnvThe TEnv class reads config files, by default named .rootrc.Definition TEnv.h:124; TEnv::GetValuevirtual Int_t GetValue(const char *name, Int_t dflt) constReturns the integer value for a resource.Definition TEnv.cxx:491; TEnv::SetValuevirtual void SetValue(const char *name, const char *value, EEnvLevel level=kEnvChange, const char *type=nullptr)Set the value of a resource or create a new resource.Definition TEnv.cxx:736; TFileA ROOT file is an on-disk file, usually with extension .root, that stores objects in a file-system-li...Definition TFile.h:53; TFolder<div class=""legacybox""><h2>Legacy Code</h2> TFolder is a legacy interface: there will be no bug fixes...Definition TFolder.h:30; TFolder::FindObjectAnyvirtual TObject * FindObjectAny(const char *name) constReturn a pointer to the first object with name starting at this folder.Definition TFolder.cxx:343; TFolder::AddFolderTFolder * AddFolder(const char *name, const char *title, TCollection *collection=nullptr)Create a new folder and add it to the list of",MatchSource.WIKI,doc/v632/TROOT_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/TROOT_8cxx_source.html
https://root.cern/doc/v632/TROOT_8cxx_source.html:136427,Modifiability,variab,variables,136427,"nyvirtual TObject * FindObjectAny(const char *name) constReturn a pointer to the first object with name starting at this folder.Definition TFolder.cxx:343; TFolder::AddFolderTFolder * AddFolder(const char *name, const char *title, TCollection *collection=nullptr)Create a new folder and add it to the list of folders of this folder, return a pointer to the created...Definition TFolder.cxx:182; TFunctionTemplateDictionary for function template This class describes one single function template.Definition TFunctionTemplate.h:26; TFunctionGlobal functions class (global functions are obtained from CINT).Definition TFunction.h:30; TGlobalMappedFunction::MakeFunctorstatic void MakeFunctor(const char *name, const char *type, GlobFunc &func)Definition TGlobal.h:73; TGlobalMappedFunction::GetEarlyRegisteredGlobalsstatic TList & GetEarlyRegisteredGlobals()Returns list collected globals Used to storeTGlobalMappedFunctions from other libs,...Definition TGlobal.cxx:189; TGlobalGlobal variables class (global variables are obtained from CINT).Definition TGlobal.h:28; TGuiFactoryThis ABC is a factory for GUI components.Definition TGuiFactory.h:42; THashListTHashList implements a hybrid collection class consisting of a hash table and a list to store TObject...Definition THashList.h:34; THashTableTHashTable implements a hash table to store TObject's.Definition THashTable.h:35; TInterpreter::RegisterModulevirtual void RegisterModule(const char *, const char **, const char **, const char *, const char *, void(*)(), const FwdDeclArgsToKeepCollection_t &fwdDeclArgsToKeep, const char **classesHeaders, Bool_t lateRegistration=false, Bool_t hasCxxModule=false)=0; TInterpreter::Resetvirtual void Reset()=0; TInterpreter::Initializevirtual void Initialize()=0; TInterpreter::FwdDeclArgsToKeepCollection_tstd::vector< std::pair< std::string, int > > FwdDeclArgsToKeepCollection_tDefinition TInterpreter.h:133; TInterpreter::SaveContextvirtual void SaveContext()=0; TInterpreter::DeclId_tTDictionary::Dec",MatchSource.WIKI,doc/v632/TROOT_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/TROOT_8cxx_source.html
https://root.cern/doc/v632/TROOT_8cxx_source.html:136451,Modifiability,variab,variables,136451,"nyvirtual TObject * FindObjectAny(const char *name) constReturn a pointer to the first object with name starting at this folder.Definition TFolder.cxx:343; TFolder::AddFolderTFolder * AddFolder(const char *name, const char *title, TCollection *collection=nullptr)Create a new folder and add it to the list of folders of this folder, return a pointer to the created...Definition TFolder.cxx:182; TFunctionTemplateDictionary for function template This class describes one single function template.Definition TFunctionTemplate.h:26; TFunctionGlobal functions class (global functions are obtained from CINT).Definition TFunction.h:30; TGlobalMappedFunction::MakeFunctorstatic void MakeFunctor(const char *name, const char *type, GlobFunc &func)Definition TGlobal.h:73; TGlobalMappedFunction::GetEarlyRegisteredGlobalsstatic TList & GetEarlyRegisteredGlobals()Returns list collected globals Used to storeTGlobalMappedFunctions from other libs,...Definition TGlobal.cxx:189; TGlobalGlobal variables class (global variables are obtained from CINT).Definition TGlobal.h:28; TGuiFactoryThis ABC is a factory for GUI components.Definition TGuiFactory.h:42; THashListTHashList implements a hybrid collection class consisting of a hash table and a list to store TObject...Definition THashList.h:34; THashTableTHashTable implements a hash table to store TObject's.Definition THashTable.h:35; TInterpreter::RegisterModulevirtual void RegisterModule(const char *, const char **, const char **, const char *, const char *, void(*)(), const FwdDeclArgsToKeepCollection_t &fwdDeclArgsToKeep, const char **classesHeaders, Bool_t lateRegistration=false, Bool_t hasCxxModule=false)=0; TInterpreter::Resetvirtual void Reset()=0; TInterpreter::Initializevirtual void Initialize()=0; TInterpreter::FwdDeclArgsToKeepCollection_tstd::vector< std::pair< std::string, int > > FwdDeclArgsToKeepCollection_tDefinition TInterpreter.h:133; TInterpreter::SaveContextvirtual void SaveContext()=0; TInterpreter::DeclId_tTDictionary::Dec",MatchSource.WIKI,doc/v632/TROOT_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/TROOT_8cxx_source.html
https://root.cern/doc/v632/TROOT_8cxx_source.html:142651,Modifiability,plugin,plugin,142651,"stReturns name of class to which the object belongs.Definition TObject.cxx:207; TObject::Warningvirtual void Warning(const char *method, const char *msgfmt,...) constIssue warning message.Definition TObject.cxx:973; TObject::FindObjectvirtual TObject * FindObject(const char *name) constMust be redefined in derived classes.Definition TObject.cxx:403; TObject::SetBitvoid SetBit(UInt_t f, Bool_t set)Set or unset the user status bits as specified in f.Definition TObject.cxx:780; TObject::Errorvirtual void Error(const char *method, const char *msgfmt,...) constIssue error message.Definition TObject.cxx:987; TObject::Fatalvirtual void Fatal(const char *method, const char *msgfmt,...) constIssue fatal error message.Definition TObject.cxx:1015; TObject::kInvalidObject@ kInvalidObjectif object ctor succeeded but object should not be usedDefinition TObject.h:72; TObject::kMustCleanup@ kMustCleanupif object destructor must call RecursiveRemove()Definition TObject.h:64; TPluginManagerThis class implements a plugin library manager.Definition TPluginManager.h:258; TPluginManager::LoadHandlersFromEnvvoid LoadHandlersFromEnv(TEnv *env)Load plugin handlers specified in config file, like:Definition TPluginManager.cxx:391; TProcessID::Cleanupstatic void Cleanup()static function (called by TROOT destructor) to delete all TProcessIDsDefinition TProcessID.cxx:204; TProcessID::AddProcessIDstatic TProcessID * AddProcessID()Static function to add a new TProcessID to the list of PIDs.Definition TProcessID.cxx:116; TProcessUUIDThis class is a specialized TProcessID managing the list of UUIDs.Definition TProcessUUID.h:32; TQObject::BlockAllSignalsstatic Bool_t BlockAllSignals(Bool_t b)Block or unblock all signals. Returns the previous block status.Definition TQObject.cxx:1057; TROOTROOT top level object description.Definition TROOT.h:94; TROOT::IncreaseDirLevelstatic Int_t IncreaseDirLevel()Increase the indentation level for ls().Definition TROOT.cxx:2883; TROOT::IgnoreIncludeInt_t IgnoreInclud",MatchSource.WIKI,doc/v632/TROOT_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/TROOT_8cxx_source.html
https://root.cern/doc/v632/TROOT_8cxx_source.html:142782,Modifiability,plugin,plugin,142782,"const char *msgfmt,...) constIssue warning message.Definition TObject.cxx:973; TObject::FindObjectvirtual TObject * FindObject(const char *name) constMust be redefined in derived classes.Definition TObject.cxx:403; TObject::SetBitvoid SetBit(UInt_t f, Bool_t set)Set or unset the user status bits as specified in f.Definition TObject.cxx:780; TObject::Errorvirtual void Error(const char *method, const char *msgfmt,...) constIssue error message.Definition TObject.cxx:987; TObject::Fatalvirtual void Fatal(const char *method, const char *msgfmt,...) constIssue fatal error message.Definition TObject.cxx:1015; TObject::kInvalidObject@ kInvalidObjectif object ctor succeeded but object should not be usedDefinition TObject.h:72; TObject::kMustCleanup@ kMustCleanupif object destructor must call RecursiveRemove()Definition TObject.h:64; TPluginManagerThis class implements a plugin library manager.Definition TPluginManager.h:258; TPluginManager::LoadHandlersFromEnvvoid LoadHandlersFromEnv(TEnv *env)Load plugin handlers specified in config file, like:Definition TPluginManager.cxx:391; TProcessID::Cleanupstatic void Cleanup()static function (called by TROOT destructor) to delete all TProcessIDsDefinition TProcessID.cxx:204; TProcessID::AddProcessIDstatic TProcessID * AddProcessID()Static function to add a new TProcessID to the list of PIDs.Definition TProcessID.cxx:116; TProcessUUIDThis class is a specialized TProcessID managing the list of UUIDs.Definition TProcessUUID.h:32; TQObject::BlockAllSignalsstatic Bool_t BlockAllSignals(Bool_t b)Block or unblock all signals. Returns the previous block status.Definition TQObject.cxx:1057; TROOTROOT top level object description.Definition TROOT.h:94; TROOT::IncreaseDirLevelstatic Int_t IncreaseDirLevel()Increase the indentation level for ls().Definition TROOT.cxx:2883; TROOT::IgnoreIncludeInt_t IgnoreInclude(const char *fname, const char *expandedfname)Return 1 if the name of the given include file corresponds to a class that is known to ROO",MatchSource.WIKI,doc/v632/TROOT_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/TROOT_8cxx_source.html
https://root.cern/doc/v632/TROOT_8cxx_source.html:142811,Modifiability,config,config,142811,"const char *msgfmt,...) constIssue warning message.Definition TObject.cxx:973; TObject::FindObjectvirtual TObject * FindObject(const char *name) constMust be redefined in derived classes.Definition TObject.cxx:403; TObject::SetBitvoid SetBit(UInt_t f, Bool_t set)Set or unset the user status bits as specified in f.Definition TObject.cxx:780; TObject::Errorvirtual void Error(const char *method, const char *msgfmt,...) constIssue error message.Definition TObject.cxx:987; TObject::Fatalvirtual void Fatal(const char *method, const char *msgfmt,...) constIssue fatal error message.Definition TObject.cxx:1015; TObject::kInvalidObject@ kInvalidObjectif object ctor succeeded but object should not be usedDefinition TObject.h:72; TObject::kMustCleanup@ kMustCleanupif object destructor must call RecursiveRemove()Definition TObject.h:64; TPluginManagerThis class implements a plugin library manager.Definition TPluginManager.h:258; TPluginManager::LoadHandlersFromEnvvoid LoadHandlersFromEnv(TEnv *env)Load plugin handlers specified in config file, like:Definition TPluginManager.cxx:391; TProcessID::Cleanupstatic void Cleanup()static function (called by TROOT destructor) to delete all TProcessIDsDefinition TProcessID.cxx:204; TProcessID::AddProcessIDstatic TProcessID * AddProcessID()Static function to add a new TProcessID to the list of PIDs.Definition TProcessID.cxx:116; TProcessUUIDThis class is a specialized TProcessID managing the list of UUIDs.Definition TProcessUUID.h:32; TQObject::BlockAllSignalsstatic Bool_t BlockAllSignals(Bool_t b)Block or unblock all signals. Returns the previous block status.Definition TQObject.cxx:1057; TROOTROOT top level object description.Definition TROOT.h:94; TROOT::IncreaseDirLevelstatic Int_t IncreaseDirLevel()Increase the indentation level for ls().Definition TROOT.cxx:2883; TROOT::IgnoreIncludeInt_t IgnoreInclude(const char *fname, const char *expandedfname)Return 1 if the name of the given include file corresponds to a class that is known to ROO",MatchSource.WIKI,doc/v632/TROOT_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/TROOT_8cxx_source.html
https://root.cern/doc/v632/TROOT_8cxx_source.html:150176,Modifiability,variab,variable,150176,"constReturn path name of obj somewhere in the //root/... path.Definition TROOT.cxx:1473; TROOT::ConvertVersionInt2Codestatic Int_t ConvertVersionInt2Code(Int_t v)Convert version as an integer to version code as used in RVersion.h.Definition TROOT.cxx:2930; TROOT::ResetClassSavedvoid ResetClassSaved()Reset the ClassSaved status of all classes.Definition TROOT.cxx:1096; TROOT::GetTTFFontDirstatic const TString & GetTTFFontDir()Get the fonts directory in the installation. Static utility function.Definition TROOT.cxx:3189; TROOT::fForceStyleBool_t fForceStyleForce setting of current style when reading objects.Definition TROOT.h:133; TROOT::MakeDefCanvasTCanvas * MakeDefCanvas() constReturn a default canvas.Definition TROOT.cxx:1554; TROOT::fTypesTCollection * fTypesList of data types definition.Definition TROOT.h:141; TROOT::GetColorTColor * GetColor(Int_t color) constReturn address of color with index color.Definition TROOT.cxx:1536; TROOT::GetGlobalTGlobal * GetGlobal(const char *name, Bool_t load=kFALSE) constReturn pointer to global variable by name.Definition TROOT.cxx:1631; TROOT::FindSTLClassTClass * FindSTLClass(const char *name, Bool_t load, Bool_t silent=kFALSE) constreturn a TClass object corresponding to 'name' assuming it is an STL container.Definition TROOT.cxx:1484; TROOT::fStreamerInfoTSeqCollection * fStreamerInfoList of active StreamerInfo classes.Definition TROOT.h:159; TROOT::Appendvoid Append(TObject *obj, Bool_t replace=kFALSE) overrideAppend object to this directory.Definition TROOT.cxx:1047; TROOT::GetIconPathstatic const TString & GetIconPath()Get the icon path in the installation. Static utility function.Definition TROOT.cxx:3168; TROOT::GetListOfGlobalFunctionsTCollection * GetListOfGlobalFunctions(Bool_t load=kFALSE)Return list containing the TFunctions currently defined.Definition TROOT.cxx:1826; TROOT::fGitDateTString fGitDateDate and time when make was run.Definition TROOT.h:122; TROOT::fSpecialsTSeqCollection * fSpecialsList of special obj",MatchSource.WIKI,doc/v632/TROOT_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/TROOT_8cxx_source.html
https://root.cern/doc/v632/TROOT_8cxx_source.html:152075,Modifiability,variab,variables,152075,"nition TROOT.h:122; TROOT::fSpecialsTSeqCollection * fSpecialsList of special objects.Definition TROOT.h:156; TROOT::GetListOfFunctionTemplatesTCollection * GetListOfFunctionTemplates()Definition TROOT.cxx:1771; TROOT::RegisterModulestatic void RegisterModule(const char *modulename, const char **headers, const char **includePaths, const char *payLoadCode, const char *fwdDeclCode, void(*triggerFunc)(), const FwdDeclArgsToKeepCollection_t &fwdDeclsArgToSkip, const char **classesHeaders, bool hasCxxModule=false)Called by static dictionary initialization to register clang modules for headers.Definition TROOT.cxx:2535; TROOT::FindObjectTObject * FindObject(const char *name) const overrideReturns address of a ROOT object if it exists.Definition TROOT.cxx:1313; TROOT::fClassesTCollection * fClassesList of classes definition.Definition TROOT.h:140; TROOT::fEditHistogramsBool_t fEditHistogramsTrue if histograms can be edited with the mouse.Definition TROOT.h:130; TROOT::fGlobalsTListOfDataMembers * fGlobalsList of global variables.Definition TROOT.h:143; TROOT::fFuncTemplateTListOfFunctionTemplates * fFuncTemplateList of global function templates.Definition TROOT.h:142; TROOT::fTimerInt_t fTimerTimer flag.Definition TROOT.h:123; TROOT::fDataSetsTSeqCollection * fDataSetsList of data sets (TDSet or TChain)Definition TROOT.h:164; TROOT::fConfigOptionsTString fConfigOptionsROOT ./configure set build options.Definition TROOT.h:111; TROOT::GetStyleTStyle * GetStyle(const char *name) constReturn pointer to style with name.Definition TROOT.cxx:1579; TROOT::GetListOfEnumsTCollection * GetListOfEnums(Bool_t load=kFALSE)Definition TROOT.cxx:1754; TROOT::ProcessLineSyncLongptr_t ProcessLineSync(const char *line, Int_t *error=nullptr)Process interpreter command via TApplication::ProcessLine().Definition TROOT.cxx:2390; TROOT::InitInterpretervoid InitInterpreter()Initialize interpreter (cling)Definition TROOT.cxx:2064; TROOT::GetListOfGlobalsTCollection * GetListOfGlobals(Bool_t load=kFA",MatchSource.WIKI,doc/v632/TROOT_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/TROOT_8cxx_source.html
https://root.cern/doc/v632/TROOT_8cxx_source.html:152438,Modifiability,config,configure,152438," const FwdDeclArgsToKeepCollection_t &fwdDeclsArgToSkip, const char **classesHeaders, bool hasCxxModule=false)Called by static dictionary initialization to register clang modules for headers.Definition TROOT.cxx:2535; TROOT::FindObjectTObject * FindObject(const char *name) const overrideReturns address of a ROOT object if it exists.Definition TROOT.cxx:1313; TROOT::fClassesTCollection * fClassesList of classes definition.Definition TROOT.h:140; TROOT::fEditHistogramsBool_t fEditHistogramsTrue if histograms can be edited with the mouse.Definition TROOT.h:130; TROOT::fGlobalsTListOfDataMembers * fGlobalsList of global variables.Definition TROOT.h:143; TROOT::fFuncTemplateTListOfFunctionTemplates * fFuncTemplateList of global function templates.Definition TROOT.h:142; TROOT::fTimerInt_t fTimerTimer flag.Definition TROOT.h:123; TROOT::fDataSetsTSeqCollection * fDataSetsList of data sets (TDSet or TChain)Definition TROOT.h:164; TROOT::fConfigOptionsTString fConfigOptionsROOT ./configure set build options.Definition TROOT.h:111; TROOT::GetStyleTStyle * GetStyle(const char *name) constReturn pointer to style with name.Definition TROOT.cxx:1579; TROOT::GetListOfEnumsTCollection * GetListOfEnums(Bool_t load=kFALSE)Definition TROOT.cxx:1754; TROOT::ProcessLineSyncLongptr_t ProcessLineSync(const char *line, Int_t *error=nullptr)Process interpreter command via TApplication::ProcessLine().Definition TROOT.cxx:2390; TROOT::InitInterpretervoid InitInterpreter()Initialize interpreter (cling)Definition TROOT.cxx:2064; TROOT::GetListOfGlobalsTCollection * GetListOfGlobals(Bool_t load=kFALSE)Return list containing the TGlobals currently defined.Definition TROOT.cxx:1788; TROOT::SetDirLevelstatic void SetDirLevel(Int_t level=0)Return Indentation level for ls().Definition TROOT.cxx:2914; TROOT::fSecContextsTSeqCollection * fSecContextsList of security contexts (TSecContext)Definition TROOT.h:161; TROOT::fWebDisplayTString fWebDisplayIf not empty it defines where web graphics should be re",MatchSource.WIKI,doc/v632/TROOT_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/TROOT_8cxx_source.html
https://root.cern/doc/v632/TROOT_8cxx_source.html:160574,Modifiability,extend,extend,160574,rLevelstatic Int_t fgDirLevelIndentation level for ls()Definition TROOT.h:102; TROOT::IsRootFileBool_t IsRootFile(const char *filename) constReturn true if the file is local and is (likely) to be a ROOT file.Definition TROOT.cxx:2230; TROOT::IndentLevelstatic void IndentLevel()Functions used by ls() to indent an object hierarchy.Definition TROOT.cxx:2891; TROOT::GetDocDirstatic const TString & GetDocDir()Get the documentation directory in the installation. Static utility function.Definition TROOT.cxx:3078; TROOT::GetEtcDirstatic const TString & GetEtcDir()Get the sysconfig directory in the installation. Static utility function.Definition TROOT.cxx:3052; TROOT::GetNclassesInt_t GetNclasses() constGet number of classes.Definition TROOT.cxx:1876; TROOT::GetExtraInterpreterArgsstatic const char **& GetExtraInterpreterArgs()INTERNAL function! Used by rootcling to inject interpreter arguments through a C-interface layer.Definition TROOT.cxx:2962; TROOT::SetMacroPathstatic void SetMacroPath(const char *newpath)Set or extend the macro search path.Definition TROOT.cxx:2788; TROOT::InitThreadsvoid InitThreads()Initialize threads library.Definition TROOT.cxx:2053; TROOT::fUUIDsTProcessUUID * fUUIDsPointer to TProcessID managing TUUIDs.Definition TROOT.h:166; TROOT::fConfigFeaturesTString fConfigFeaturesROOT ./configure detected build features.Definition TROOT.h:112; TROOT::GetFunctionTemplateTFunctionTemplate * GetFunctionTemplate(const char *name)Definition TROOT.cxx:1618; TROOT::fPluginManagerTPluginManager * fPluginManagerKeeps track of plugin library handlers.Definition TROOT.h:169; TROOT::GetGeometryTObject * GetGeometry(const char *name) constReturn pointer to Geometry with name.Definition TROOT.cxx:1747; TROOT::RecursiveRemovevoid RecursiveRemove(TObject *obj) overrideRecursively remove this object from the list of Cleanups.Definition TROOT.cxx:2498; TROOT::fExecutingMacroBool_t fExecutingMacroTrue while executing a TMacro.Definition TROOT.h:136; TROOT::fBuiltDateInt_t ,MatchSource.WIKI,doc/v632/TROOT_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/TROOT_8cxx_source.html
https://root.cern/doc/v632/TROOT_8cxx_source.html:160868,Modifiability,config,configure,160868,ition TROOT.cxx:2891; TROOT::GetDocDirstatic const TString & GetDocDir()Get the documentation directory in the installation. Static utility function.Definition TROOT.cxx:3078; TROOT::GetEtcDirstatic const TString & GetEtcDir()Get the sysconfig directory in the installation. Static utility function.Definition TROOT.cxx:3052; TROOT::GetNclassesInt_t GetNclasses() constGet number of classes.Definition TROOT.cxx:1876; TROOT::GetExtraInterpreterArgsstatic const char **& GetExtraInterpreterArgs()INTERNAL function! Used by rootcling to inject interpreter arguments through a C-interface layer.Definition TROOT.cxx:2962; TROOT::SetMacroPathstatic void SetMacroPath(const char *newpath)Set or extend the macro search path.Definition TROOT.cxx:2788; TROOT::InitThreadsvoid InitThreads()Initialize threads library.Definition TROOT.cxx:2053; TROOT::fUUIDsTProcessUUID * fUUIDsPointer to TProcessID managing TUUIDs.Definition TROOT.h:166; TROOT::fConfigFeaturesTString fConfigFeaturesROOT ./configure detected build features.Definition TROOT.h:112; TROOT::GetFunctionTemplateTFunctionTemplate * GetFunctionTemplate(const char *name)Definition TROOT.cxx:1618; TROOT::fPluginManagerTPluginManager * fPluginManagerKeeps track of plugin library handlers.Definition TROOT.h:169; TROOT::GetGeometryTObject * GetGeometry(const char *name) constReturn pointer to Geometry with name.Definition TROOT.cxx:1747; TROOT::RecursiveRemovevoid RecursiveRemove(TObject *obj) overrideRecursively remove this object from the list of Cleanups.Definition TROOT.cxx:2498; TROOT::fExecutingMacroBool_t fExecutingMacroTrue while executing a TMacro.Definition TROOT.h:136; TROOT::fBuiltDateInt_t fBuiltDateDate of ROOT built.Definition TROOT.h:118; TROOT::fIsWebDisplayBatchBool_t fIsWebDisplayBatchTrue if web widgets are not displayed.Definition TROOT.h:129; TROOT::GetSharedLibDirstatic const TString & GetSharedLibDir()Get the shared libraries directory in the installation. Static utility function.Definition TROOT.cxx:3031; TRO,MatchSource.WIKI,doc/v632/TROOT_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/TROOT_8cxx_source.html
https://root.cern/doc/v632/TROOT_8cxx_source.html:161103,Modifiability,plugin,plugin,161103,static const TString & GetEtcDir()Get the sysconfig directory in the installation. Static utility function.Definition TROOT.cxx:3052; TROOT::GetNclassesInt_t GetNclasses() constGet number of classes.Definition TROOT.cxx:1876; TROOT::GetExtraInterpreterArgsstatic const char **& GetExtraInterpreterArgs()INTERNAL function! Used by rootcling to inject interpreter arguments through a C-interface layer.Definition TROOT.cxx:2962; TROOT::SetMacroPathstatic void SetMacroPath(const char *newpath)Set or extend the macro search path.Definition TROOT.cxx:2788; TROOT::InitThreadsvoid InitThreads()Initialize threads library.Definition TROOT.cxx:2053; TROOT::fUUIDsTProcessUUID * fUUIDsPointer to TProcessID managing TUUIDs.Definition TROOT.h:166; TROOT::fConfigFeaturesTString fConfigFeaturesROOT ./configure detected build features.Definition TROOT.h:112; TROOT::GetFunctionTemplateTFunctionTemplate * GetFunctionTemplate(const char *name)Definition TROOT.cxx:1618; TROOT::fPluginManagerTPluginManager * fPluginManagerKeeps track of plugin library handlers.Definition TROOT.h:169; TROOT::GetGeometryTObject * GetGeometry(const char *name) constReturn pointer to Geometry with name.Definition TROOT.cxx:1747; TROOT::RecursiveRemovevoid RecursiveRemove(TObject *obj) overrideRecursively remove this object from the list of Cleanups.Definition TROOT.cxx:2498; TROOT::fExecutingMacroBool_t fExecutingMacroTrue while executing a TMacro.Definition TROOT.h:136; TROOT::fBuiltDateInt_t fBuiltDateDate of ROOT built.Definition TROOT.h:118; TROOT::fIsWebDisplayBatchBool_t fIsWebDisplayBatchTrue if web widgets are not displayed.Definition TROOT.h:129; TROOT::GetSharedLibDirstatic const TString & GetSharedLibDir()Get the shared libraries directory in the installation. Static utility function.Definition TROOT.cxx:3031; TROOT::fMappedFilesTSeqCollection * fMappedFilesList of memory mapped files.Definition TROOT.h:147; TROOT::GetNtypesInt_t GetNtypes() constGet number of types.Definition TROOT.cxx:1884; TROOT::Lo,MatchSource.WIKI,doc/v632/TROOT_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/TROOT_8cxx_source.html
https://root.cern/doc/v632/TROOT_8cxx_source.html:166726,Modifiability,variab,variable,166726,"Definition TString.h:623; TString::IsNullBool_t IsNull() constDefinition TString.h:414; TString::RemoveTString & Remove(Ssiz_t pos)Definition TString.h:685; TString::Formvoid Form(const char *fmt,...)Formats a string using a printf style format descriptor.Definition TString.cxx:2356; TString::ContainsBool_t Contains(const char *pat, ECaseCompare cmp=kExact) constDefinition TString.h:632; TStyleTStyle objects may be created to define special styles.Definition TStyle.h:29; TStyle::BuildStylesstatic void BuildStyles()Create some standard styles.Definition TStyle.cxx:524; TSystemDirectoryDescribes an Operating System directory for the browser.Definition TSystemDirectory.h:32; TSystemAbstract base class defining a generic interface to the underlying Operating System.Definition TSystem.h:260; TSystem::DynFindSymbolvirtual Func_t DynFindSymbol(const char *module, const char *entry)Find specific entry point in specified library.Definition TSystem.cxx:2044; TSystem::Getenvvirtual const char * Getenv(const char *env)Get environment variable.Definition TSystem.cxx:1665; TSystem::SplitAclicModevirtual TString SplitAclicMode(const char *filename, TString &mode, TString &args, TString &io) constThis method split a filename of the form:Definition TSystem.cxx:4258; TSystem::CleanCompiledMacrosvirtual void CleanCompiledMacros()Remove the shared libs produced by the CompileMacro() function, together with their rootmaps,...Definition TSystem.cxx:4369; TSystem::Loadvirtual int Load(const char *module, const char *entry="""", Bool_t system=kFALSE)Load a shared library.Definition TSystem.cxx:1857; TSystem::GetPathInfoint GetPathInfo(const char *path, Long_t *id, Long_t *size, Long_t *flags, Long_t *modtime)Get info about a file: id, size, flags, modification time.Definition TSystem.cxx:1398; TSystem::PrependPathNamevirtual const char * PrependPathName(const char *dir, TString &name)Concatenate a directory and a file name.Definition TSystem.cxx:1081; TSystem::AccessPathNamevirtual Bool_t Ac",MatchSource.WIKI,doc/v632/TROOT_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/TROOT_8cxx_source.html
https://root.cern/doc/v632/TROOT_8cxx_source.html:5305,Performance,concurren,concurrent,5305,"cation.h""; 138#include ""TInterpreter.h""; 139#include ""TGuiFactory.h""; 140#include ""TMessageHandler.h""; 141#include ""TFolder.h""; 142#include ""TQObject.h""; 143#include ""TProcessUUID.h""; 144#include ""TPluginManager.h""; 145#include ""TVirtualMutex.h""; 146#include ""TListOfTypes.h""; 147#include ""TListOfDataMembers.h""; 148#include ""TListOfEnumsWithLock.h""; 149#include ""TListOfFunctions.h""; 150#include ""TListOfFunctionTemplates.h""; 151#include ""TFunctionTemplate.h""; 152#include ""ThreadLocalStorage.h""; 153#include ""TVirtualMapFile.h""; 154#include ""TVirtualRWMutex.h""; 155#include ""TVirtualX.h""; 156 ; 157#if defined(R__UNIX); 158#if defined(R__HAS_COCOA); 159#include ""TMacOSXSystem.h""; 160#include ""TUrl.h""; 161#else; 162#include ""TUnixSystem.h""; 163#endif; 164#elif defined(R__WIN32); 165#include ""TWinNTSystem.h""; 166#endif; 167 ; 168extern ""C"" void R__SetZipMode(int);; 169 ; 170static DestroyInterpreter_t *gDestroyInterpreter = nullptr;; 171static void *gInterpreterLib = nullptr;; 172 ; 173// Mutex for protection of concurrent gROOT access; 174TVirtualMutex* gROOTMutex = nullptr;; 175ROOT::TVirtualRWMutex *ROOT::gCoreMutex = nullptr;; 176 ; 177// For accessing TThread::Tsd indirectly.; 178void **(*gThreadTsd)(void*,Int_t) = nullptr;; 179 ; 180//-------- Names of next three routines are a small homage to CMZ --------------; 181////////////////////////////////////////////////////////////////////////////////; 182/// Return version id as an integer, i.e. ""2.22/04"" -> 22204.; 183 ; 184static Int_t IVERSQ(); 185{; 186 Int_t maj, min, cycle;; 187 sscanf(ROOT_RELEASE, ""%d.%d.%d"", &maj, &min, &cycle);; 188 return 10000*maj + 100*min + cycle;; 189}; 190 ; 191////////////////////////////////////////////////////////////////////////////////; 192/// Return built date as integer, i.e. ""Apr 28 2000"" -> 20000428.; 193 ; 194static Int_t IDATQQ(const char *date); 195{; 196 if (!date) {; 197 Error(""TSystem::IDATQQ"", ""nullptr date string, expected e.g. 'Dec 21 2022'"");; 198 return -1;; 199 }; 200 ;",MatchSource.WIKI,doc/v632/TROOT_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/TROOT_8cxx_source.html
https://root.cern/doc/v632/TROOT_8cxx_source.html:8933,Performance,load,load,8933,"///////////////////////////////////////////////////; 249/// A module and its headers. Intentionally not a copy:; 250/// If these strings end up in this struct they are; 251/// long lived by definition because they get passed in; 252/// before initialization of TCling.; 253 ; 254namespace {; 255 struct ModuleHeaderInfo_t {; 256 ModuleHeaderInfo_t(const char* moduleName,; 257 const char** headers,; 258 const char** includePaths,; 259 const char* payloadCode,; 260 const char* fwdDeclCode,; 261 void (*triggerFunc)(),; 262 const TROOT::FwdDeclArgsToKeepCollection_t& fwdDeclsArgToSkip,; 263 const char **classesHeaders,; 264 bool hasCxxModule):; 265 fModuleName(moduleName),; 266 fHeaders(headers),; 267 fPayloadCode(payloadCode),; 268 fFwdDeclCode(fwdDeclCode),; 269 fIncludePaths(includePaths),; 270 fTriggerFunc(triggerFunc),; 271 fClassesHeaders(classesHeaders),; 272 fFwdNargsToKeepColl(fwdDeclsArgToSkip),; 273 fHasCxxModule(hasCxxModule) {}; 274 ; 275 const char* fModuleName; // module name; 276 const char** fHeaders; // 0-terminated array of header files; 277 const char* fPayloadCode; // Additional code to be given to cling at library load; 278 const char* fFwdDeclCode; // Additional code to let cling know about selected classes and functions; 279 const char** fIncludePaths; // 0-terminated array of header files; 280 void (*fTriggerFunc)(); // Pointer to the dict initialization used to find the library name; 281 const char** fClassesHeaders; // 0-terminated list of classes and related header files; 282 const TROOT::FwdDeclArgsToKeepCollection_t fFwdNargsToKeepColl; // Collection of; 283 // pairs of template fwd decls and number of; 284 bool fHasCxxModule; // Whether this module has a C++ module alongside it.; 285 };; 286 ; 287 std::vector<ModuleHeaderInfo_t>& GetModuleHeaderInfoBuffer() {; 288 static std::vector<ModuleHeaderInfo_t> moduleHeaderInfoBuffer;; 289 return moduleHeaderInfoBuffer;; 290 }; 291}; 292 ; 293Int_t TROOT::fgDirLevel = 0;; 294Bool_t TROOT::fgRootInit ",MatchSource.WIKI,doc/v632/TROOT_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/TROOT_8cxx_source.html
https://root.cern/doc/v632/TROOT_8cxx_source.html:10274,Performance,load,loaded,10274,"asses and related header files; 282 const TROOT::FwdDeclArgsToKeepCollection_t fFwdNargsToKeepColl; // Collection of; 283 // pairs of template fwd decls and number of; 284 bool fHasCxxModule; // Whether this module has a C++ module alongside it.; 285 };; 286 ; 287 std::vector<ModuleHeaderInfo_t>& GetModuleHeaderInfoBuffer() {; 288 static std::vector<ModuleHeaderInfo_t> moduleHeaderInfoBuffer;; 289 return moduleHeaderInfoBuffer;; 290 }; 291}; 292 ; 293Int_t TROOT::fgDirLevel = 0;; 294Bool_t TROOT::fgRootInit = kFALSE;; 295 ; 296static void at_exit_of_TROOT() {; 297 if (ROOT::Internal::gROOTLocal); 298 ROOT::Internal::gROOTLocal->~TROOT();; 299}; 300 ; 301// This local static object initializes the ROOT system; 302namespace ROOT {; 303namespace Internal {; 304 class TROOTAllocator {; 305 // Simple wrapper to separate, time-wise, the call to the; 306 // TROOT destructor and the actual free-ing of the memory.; 307 //; 308 // Since the interpreter implementation (currently TCling) is; 309 // loaded via dlopen by libCore, the destruction of its global; 310 // variable (i.e. in particular clang's) is scheduled before; 311 // those in libCore so we need to schedule the call to the TROOT; 312 // destructor before that *but* we want to make sure the memory; 313 // stay around until libCore itself is unloaded so that code; 314 // using gROOT can 'properly' check for validity.; 315 //; 316 // The order of loading for is:; 317 // libCore.so; 318 // libRint.so; 319 // ... anything other library hard linked to the executable ...; 320 // ... for example libEvent; 321 // libCling.so; 322 // ... other libraries like libTree for example ....; 323 // and the destruction order is (of course) the reverse.; 324 // By default the unloading of the dictionary, does use; 325 // the service of the interpreter ... which of course; 326 // fails if libCling is already unloaded by that information; 327 // has not been registered per se.; 328 //; 329 // To solve this problem, we now schedule the de",MatchSource.WIKI,doc/v632/TROOT_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/TROOT_8cxx_source.html
https://root.cern/doc/v632/TROOT_8cxx_source.html:10689,Performance,load,loading,10689,"erInfoBuffer;; 290 }; 291}; 292 ; 293Int_t TROOT::fgDirLevel = 0;; 294Bool_t TROOT::fgRootInit = kFALSE;; 295 ; 296static void at_exit_of_TROOT() {; 297 if (ROOT::Internal::gROOTLocal); 298 ROOT::Internal::gROOTLocal->~TROOT();; 299}; 300 ; 301// This local static object initializes the ROOT system; 302namespace ROOT {; 303namespace Internal {; 304 class TROOTAllocator {; 305 // Simple wrapper to separate, time-wise, the call to the; 306 // TROOT destructor and the actual free-ing of the memory.; 307 //; 308 // Since the interpreter implementation (currently TCling) is; 309 // loaded via dlopen by libCore, the destruction of its global; 310 // variable (i.e. in particular clang's) is scheduled before; 311 // those in libCore so we need to schedule the call to the TROOT; 312 // destructor before that *but* we want to make sure the memory; 313 // stay around until libCore itself is unloaded so that code; 314 // using gROOT can 'properly' check for validity.; 315 //; 316 // The order of loading for is:; 317 // libCore.so; 318 // libRint.so; 319 // ... anything other library hard linked to the executable ...; 320 // ... for example libEvent; 321 // libCling.so; 322 // ... other libraries like libTree for example ....; 323 // and the destruction order is (of course) the reverse.; 324 // By default the unloading of the dictionary, does use; 325 // the service of the interpreter ... which of course; 326 // fails if libCling is already unloaded by that information; 327 // has not been registered per se.; 328 //; 329 // To solve this problem, we now schedule the destruction; 330 // of the TROOT object to happen _just_ before the; 331 // unloading/destruction of libCling so that we can; 332 // maximize the amount of clean-up we can do correctly; 333 // and we can still allocate the TROOT object's memory; 334 // statically.; 335 //; 336 union {; 337 TROOT fObj;; 338 char fHolder[sizeof(TROOT)];; 339 };; 340 public:; 341 TROOTAllocator(): fObj(""root"", ""The ROOT of EVERYTHING"");",MatchSource.WIKI,doc/v632/TROOT_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/TROOT_8cxx_source.html
https://root.cern/doc/v632/TROOT_8cxx_source.html:12972,Performance,load,loading,12972,"nction pointer.; 353 ; 354 // Initially this function pointer's value is & GetROOT1 whose role is to; 355 // create and initialize the TROOT object itself.; 356 // At the very end of the TROOT constructor the value of the function pointer; 357 // is switch to & GetROOT2 whose role is to initialize the interpreter.; 358 ; 359 // This mechanism was primarily intended to fix the issues with order in which; 360 // global TROOT and LLVM globals are initialized. TROOT was initializing; 361 // Cling, but Cling could not be used yet due to LLVM globals not being; 362 // Initialized yet. The solution is to delay initializing the interpreter in; 363 // TROOT till after main() when all LLVM globals are initialized.; 364 ; 365 // Technically, the mechanism used actually delay the interpreter; 366 // initialization until the first use of gROOT *after* the end of the; 367 // TROOT constructor.; 368 ; 369 // So to delay until after the start of main, we also made sure that none; 370 // of the ROOT code (mostly the dictionary code) used during library loading; 371 // is using gROOT (directly or indirectly).; 372 ; 373 // In practice, the initialization of the interpreter is now delayed until; 374 // the first use gROOT (or gInterpreter) after the start of main (but user; 375 // could easily break this by using gROOT in their library initialization; 376 // code).; 377 ; 378 extern TROOT *gROOTLocal;; 379 ; 380 TROOT *GetROOT1() {; 381 if (gROOTLocal); 382 return gROOTLocal;; 383 static TROOTAllocator alloc;; 384 return gROOTLocal;; 385 }; 386 ; 387 TROOT *GetROOT2() {; 388 static Bool_t initInterpreter = kFALSE;; 389 if (!initInterpreter) {; 390 initInterpreter = kTRUE;; 391 gROOTLocal->InitInterpreter();; 392 // Load and init threads library; 393 gROOTLocal->InitThreads();; 394 }; 395 return gROOTLocal;; 396 }; 397 typedef TROOT *(*GetROOTFun_t)();; 398 ; 399 static GetROOTFun_t gGetROOT = &GetROOT1;; 400 ; 401 static Func_t GetSymInLibImt(const char *funcname); 402 {; 403 const st",MatchSource.WIKI,doc/v632/TROOT_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/TROOT_8cxx_source.html
https://root.cern/doc/v632/TROOT_8cxx_source.html:13930,Performance,load,loadSuccess,13930,"t use of gROOT *after* the end of the; 367 // TROOT constructor.; 368 ; 369 // So to delay until after the start of main, we also made sure that none; 370 // of the ROOT code (mostly the dictionary code) used during library loading; 371 // is using gROOT (directly or indirectly).; 372 ; 373 // In practice, the initialization of the interpreter is now delayed until; 374 // the first use gROOT (or gInterpreter) after the start of main (but user; 375 // could easily break this by using gROOT in their library initialization; 376 // code).; 377 ; 378 extern TROOT *gROOTLocal;; 379 ; 380 TROOT *GetROOT1() {; 381 if (gROOTLocal); 382 return gROOTLocal;; 383 static TROOTAllocator alloc;; 384 return gROOTLocal;; 385 }; 386 ; 387 TROOT *GetROOT2() {; 388 static Bool_t initInterpreter = kFALSE;; 389 if (!initInterpreter) {; 390 initInterpreter = kTRUE;; 391 gROOTLocal->InitInterpreter();; 392 // Load and init threads library; 393 gROOTLocal->InitThreads();; 394 }; 395 return gROOTLocal;; 396 }; 397 typedef TROOT *(*GetROOTFun_t)();; 398 ; 399 static GetROOTFun_t gGetROOT = &GetROOT1;; 400 ; 401 static Func_t GetSymInLibImt(const char *funcname); 402 {; 403 const static bool loadSuccess = dlsym(RTLD_DEFAULT, ""usedToIdentifyRootClingByDlSym"")? false : 0 <= gSystem->Load(""libImt"");; 404 if (loadSuccess) {; 405 if (auto sym = gSystem->DynFindSymbol(nullptr, funcname)) {; 406 return sym;; 407 } else {; 408 Error(""GetSymInLibImt"", ""Cannot get symbol %s."", funcname);; 409 }; 410 }; 411 return nullptr;; 412 }; 413 ; 414 //////////////////////////////////////////////////////////////////////////////; 415 /// Globally enables the parallel branch processing, which is a case of; 416 /// implicit multi-threading (IMT) in ROOT, activating the required locks.; 417 /// This IMT use case, implemented in TTree::GetEntry, spawns a task for; 418 /// each branch of the tree. Therefore, a task takes care of the reading,; 419 /// decompression and deserialisation of a given branch.; 420 void EnablePa",MatchSource.WIKI,doc/v632/TROOT_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/TROOT_8cxx_source.html
https://root.cern/doc/v632/TROOT_8cxx_source.html:14046,Performance,load,loadSuccess,14046,"t use of gROOT *after* the end of the; 367 // TROOT constructor.; 368 ; 369 // So to delay until after the start of main, we also made sure that none; 370 // of the ROOT code (mostly the dictionary code) used during library loading; 371 // is using gROOT (directly or indirectly).; 372 ; 373 // In practice, the initialization of the interpreter is now delayed until; 374 // the first use gROOT (or gInterpreter) after the start of main (but user; 375 // could easily break this by using gROOT in their library initialization; 376 // code).; 377 ; 378 extern TROOT *gROOTLocal;; 379 ; 380 TROOT *GetROOT1() {; 381 if (gROOTLocal); 382 return gROOTLocal;; 383 static TROOTAllocator alloc;; 384 return gROOTLocal;; 385 }; 386 ; 387 TROOT *GetROOT2() {; 388 static Bool_t initInterpreter = kFALSE;; 389 if (!initInterpreter) {; 390 initInterpreter = kTRUE;; 391 gROOTLocal->InitInterpreter();; 392 // Load and init threads library; 393 gROOTLocal->InitThreads();; 394 }; 395 return gROOTLocal;; 396 }; 397 typedef TROOT *(*GetROOTFun_t)();; 398 ; 399 static GetROOTFun_t gGetROOT = &GetROOT1;; 400 ; 401 static Func_t GetSymInLibImt(const char *funcname); 402 {; 403 const static bool loadSuccess = dlsym(RTLD_DEFAULT, ""usedToIdentifyRootClingByDlSym"")? false : 0 <= gSystem->Load(""libImt"");; 404 if (loadSuccess) {; 405 if (auto sym = gSystem->DynFindSymbol(nullptr, funcname)) {; 406 return sym;; 407 } else {; 408 Error(""GetSymInLibImt"", ""Cannot get symbol %s."", funcname);; 409 }; 410 }; 411 return nullptr;; 412 }; 413 ; 414 //////////////////////////////////////////////////////////////////////////////; 415 /// Globally enables the parallel branch processing, which is a case of; 416 /// implicit multi-threading (IMT) in ROOT, activating the required locks.; 417 /// This IMT use case, implemented in TTree::GetEntry, spawns a task for; 418 /// each branch of the tree. Therefore, a task takes care of the reading,; 419 /// decompression and deserialisation of a given branch.; 420 void EnablePa",MatchSource.WIKI,doc/v632/TROOT_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/TROOT_8cxx_source.html
https://root.cern/doc/v632/TROOT_8cxx_source.html:14449,Performance,multi-thread,multi-threading,14449,"81 if (gROOTLocal); 382 return gROOTLocal;; 383 static TROOTAllocator alloc;; 384 return gROOTLocal;; 385 }; 386 ; 387 TROOT *GetROOT2() {; 388 static Bool_t initInterpreter = kFALSE;; 389 if (!initInterpreter) {; 390 initInterpreter = kTRUE;; 391 gROOTLocal->InitInterpreter();; 392 // Load and init threads library; 393 gROOTLocal->InitThreads();; 394 }; 395 return gROOTLocal;; 396 }; 397 typedef TROOT *(*GetROOTFun_t)();; 398 ; 399 static GetROOTFun_t gGetROOT = &GetROOT1;; 400 ; 401 static Func_t GetSymInLibImt(const char *funcname); 402 {; 403 const static bool loadSuccess = dlsym(RTLD_DEFAULT, ""usedToIdentifyRootClingByDlSym"")? false : 0 <= gSystem->Load(""libImt"");; 404 if (loadSuccess) {; 405 if (auto sym = gSystem->DynFindSymbol(nullptr, funcname)) {; 406 return sym;; 407 } else {; 408 Error(""GetSymInLibImt"", ""Cannot get symbol %s."", funcname);; 409 }; 410 }; 411 return nullptr;; 412 }; 413 ; 414 //////////////////////////////////////////////////////////////////////////////; 415 /// Globally enables the parallel branch processing, which is a case of; 416 /// implicit multi-threading (IMT) in ROOT, activating the required locks.; 417 /// This IMT use case, implemented in TTree::GetEntry, spawns a task for; 418 /// each branch of the tree. Therefore, a task takes care of the reading,; 419 /// decompression and deserialisation of a given branch.; 420 void EnableParBranchProcessing(); 421 {; 422#ifdef R__USE_IMT; 423 static void (*sym)() = (void(*)())Internal::GetSymInLibImt(""ROOT_TImplicitMT_EnableParBranchProcessing"");; 424 if (sym); 425 sym();; 426#else; 427 ::Warning(""EnableParBranchProcessing"", ""Cannot enable parallel branch processing, please build ROOT with -Dimt=ON"");; 428#endif; 429 }; 430 ; 431 //////////////////////////////////////////////////////////////////////////////; 432 /// Globally disables the IMT use case of parallel branch processing,; 433 /// deactivating the corresponding locks.; 434 void DisableParBranchProcessing(); 435 {; 436#ifdef R__USE",MatchSource.WIKI,doc/v632/TROOT_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/TROOT_8cxx_source.html
https://root.cern/doc/v632/TROOT_8cxx_source.html:16271,Performance,load,load,16271,"435 {; 436#ifdef R__USE_IMT; 437 static void (*sym)() = (void(*)())Internal::GetSymInLibImt(""ROOT_TImplicitMT_DisableParBranchProcessing"");; 438 if (sym); 439 sym();; 440#else; 441 ::Warning(""DisableParBranchProcessing"", ""Cannot disable parallel branch processing, please build ROOT with -Dimt=ON"");; 442#endif; 443 }; 444 ; 445 //////////////////////////////////////////////////////////////////////////////; 446 /// Returns true if parallel branch processing is enabled.; 447 Bool_t IsParBranchProcessingEnabled(); 448 {; 449#ifdef R__USE_IMT; 450 static Bool_t (*sym)() = (Bool_t(*)())Internal::GetSymInLibImt(""ROOT_TImplicitMT_IsParBranchProcessingEnabled"");; 451 if (sym); 452 return sym();; 453 else; 454 return kFALSE;; 455#else; 456 return kFALSE;; 457#endif; 458 }; 459 ; 460 ////////////////////////////////////////////////////////////////////////////////; 461 /// Keeps track of the status of ImplicitMT w/o resorting to the load of; 462 /// libImt; 463 static Bool_t &IsImplicitMTEnabledImpl(); 464 {; 465 static Bool_t isImplicitMTEnabled = kFALSE;; 466 return isImplicitMTEnabled;; 467 }; 468 ; 469} // end of Internal sub namespace; 470// back to ROOT namespace; 471 ; 472 TROOT *GetROOT() {; 473 return (*Internal::gGetROOT)();; 474 }; 475 ; 476 TString &GetMacroPath() {; 477 static TString macroPath;; 478 return macroPath;; 479 }; 480 ; 481 // clang-format off; 482 ////////////////////////////////////////////////////////////////////////////////; 483 /// Enables the global mutex to make ROOT thread safe/aware.; 484 ///; 485 /// The following becomes safe:; 486 /// - concurrent construction and destruction of TObjects, including the ones registered in ROOT's global lists (e.g. gROOT->GetListOfCleanups(), gROOT->GetListOfFiles()); 487 /// - concurrent usage of _different_ ROOT objects from different threads, including ones with global state (e.g. TFile, TTree, TChain) with the exception of graphics classes (e.g. TCanvas); 488 /// - concurrent calls to ROOT's type system cla",MatchSource.WIKI,doc/v632/TROOT_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/TROOT_8cxx_source.html
https://root.cern/doc/v632/TROOT_8cxx_source.html:16924,Performance,concurren,concurrent,16924,"ROOT_TImplicitMT_IsParBranchProcessingEnabled"");; 451 if (sym); 452 return sym();; 453 else; 454 return kFALSE;; 455#else; 456 return kFALSE;; 457#endif; 458 }; 459 ; 460 ////////////////////////////////////////////////////////////////////////////////; 461 /// Keeps track of the status of ImplicitMT w/o resorting to the load of; 462 /// libImt; 463 static Bool_t &IsImplicitMTEnabledImpl(); 464 {; 465 static Bool_t isImplicitMTEnabled = kFALSE;; 466 return isImplicitMTEnabled;; 467 }; 468 ; 469} // end of Internal sub namespace; 470// back to ROOT namespace; 471 ; 472 TROOT *GetROOT() {; 473 return (*Internal::gGetROOT)();; 474 }; 475 ; 476 TString &GetMacroPath() {; 477 static TString macroPath;; 478 return macroPath;; 479 }; 480 ; 481 // clang-format off; 482 ////////////////////////////////////////////////////////////////////////////////; 483 /// Enables the global mutex to make ROOT thread safe/aware.; 484 ///; 485 /// The following becomes safe:; 486 /// - concurrent construction and destruction of TObjects, including the ones registered in ROOT's global lists (e.g. gROOT->GetListOfCleanups(), gROOT->GetListOfFiles()); 487 /// - concurrent usage of _different_ ROOT objects from different threads, including ones with global state (e.g. TFile, TTree, TChain) with the exception of graphics classes (e.g. TCanvas); 488 /// - concurrent calls to ROOT's type system classes, e.g. TClass and TEnum; 489 /// - concurrent calls to the interpreter through gInterpreter; 490 /// - concurrent loading of ROOT plug-ins; 491 ///; 492 /// In addition, gDirectory, gFile and gPad become a thread-local variable.; 493 /// In all threads, gDirectory defaults to gROOT, a singleton which supports thread-safe insertion and deletion of contents.; 494 /// gFile and gPad default to nullptr, as it is for single-thread programs.; 495 ///; 496 /// The ROOT graphics subsystem is not made thread-safe by this method. In particular drawing or printing different; 497 /// canvases from different thread",MatchSource.WIKI,doc/v632/TROOT_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/TROOT_8cxx_source.html
https://root.cern/doc/v632/TROOT_8cxx_source.html:17100,Performance,concurren,concurrent,17100,"////////////////////////////////////////////////////////////////////////////////; 461 /// Keeps track of the status of ImplicitMT w/o resorting to the load of; 462 /// libImt; 463 static Bool_t &IsImplicitMTEnabledImpl(); 464 {; 465 static Bool_t isImplicitMTEnabled = kFALSE;; 466 return isImplicitMTEnabled;; 467 }; 468 ; 469} // end of Internal sub namespace; 470// back to ROOT namespace; 471 ; 472 TROOT *GetROOT() {; 473 return (*Internal::gGetROOT)();; 474 }; 475 ; 476 TString &GetMacroPath() {; 477 static TString macroPath;; 478 return macroPath;; 479 }; 480 ; 481 // clang-format off; 482 ////////////////////////////////////////////////////////////////////////////////; 483 /// Enables the global mutex to make ROOT thread safe/aware.; 484 ///; 485 /// The following becomes safe:; 486 /// - concurrent construction and destruction of TObjects, including the ones registered in ROOT's global lists (e.g. gROOT->GetListOfCleanups(), gROOT->GetListOfFiles()); 487 /// - concurrent usage of _different_ ROOT objects from different threads, including ones with global state (e.g. TFile, TTree, TChain) with the exception of graphics classes (e.g. TCanvas); 488 /// - concurrent calls to ROOT's type system classes, e.g. TClass and TEnum; 489 /// - concurrent calls to the interpreter through gInterpreter; 490 /// - concurrent loading of ROOT plug-ins; 491 ///; 492 /// In addition, gDirectory, gFile and gPad become a thread-local variable.; 493 /// In all threads, gDirectory defaults to gROOT, a singleton which supports thread-safe insertion and deletion of contents.; 494 /// gFile and gPad default to nullptr, as it is for single-thread programs.; 495 ///; 496 /// The ROOT graphics subsystem is not made thread-safe by this method. In particular drawing or printing different; 497 /// canvases from different threads (and analogous operations such as invoking `Draw` on a `TObject`) is not thread-safe.; 498 ///; 499 /// Note that there is no `DisableThreadSafety()`. ROOT's thread-saf",MatchSource.WIKI,doc/v632/TROOT_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/TROOT_8cxx_source.html
https://root.cern/doc/v632/TROOT_8cxx_source.html:17295,Performance,concurren,concurrent,17295,"ol_t &IsImplicitMTEnabledImpl(); 464 {; 465 static Bool_t isImplicitMTEnabled = kFALSE;; 466 return isImplicitMTEnabled;; 467 }; 468 ; 469} // end of Internal sub namespace; 470// back to ROOT namespace; 471 ; 472 TROOT *GetROOT() {; 473 return (*Internal::gGetROOT)();; 474 }; 475 ; 476 TString &GetMacroPath() {; 477 static TString macroPath;; 478 return macroPath;; 479 }; 480 ; 481 // clang-format off; 482 ////////////////////////////////////////////////////////////////////////////////; 483 /// Enables the global mutex to make ROOT thread safe/aware.; 484 ///; 485 /// The following becomes safe:; 486 /// - concurrent construction and destruction of TObjects, including the ones registered in ROOT's global lists (e.g. gROOT->GetListOfCleanups(), gROOT->GetListOfFiles()); 487 /// - concurrent usage of _different_ ROOT objects from different threads, including ones with global state (e.g. TFile, TTree, TChain) with the exception of graphics classes (e.g. TCanvas); 488 /// - concurrent calls to ROOT's type system classes, e.g. TClass and TEnum; 489 /// - concurrent calls to the interpreter through gInterpreter; 490 /// - concurrent loading of ROOT plug-ins; 491 ///; 492 /// In addition, gDirectory, gFile and gPad become a thread-local variable.; 493 /// In all threads, gDirectory defaults to gROOT, a singleton which supports thread-safe insertion and deletion of contents.; 494 /// gFile and gPad default to nullptr, as it is for single-thread programs.; 495 ///; 496 /// The ROOT graphics subsystem is not made thread-safe by this method. In particular drawing or printing different; 497 /// canvases from different threads (and analogous operations such as invoking `Draw` on a `TObject`) is not thread-safe.; 498 ///; 499 /// Note that there is no `DisableThreadSafety()`. ROOT's thread-safety features cannot be disabled once activated.; 500 // clang-format on; 501 void EnableThreadSafety(); 502 {; 503 static void (*sym)() = (void(*)())Internal::GetSymInLibImt(""ROOT_TThread_In",MatchSource.WIKI,doc/v632/TROOT_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/TROOT_8cxx_source.html
https://root.cern/doc/v632/TROOT_8cxx_source.html:17376,Performance,concurren,concurrent,17376," Internal sub namespace; 470// back to ROOT namespace; 471 ; 472 TROOT *GetROOT() {; 473 return (*Internal::gGetROOT)();; 474 }; 475 ; 476 TString &GetMacroPath() {; 477 static TString macroPath;; 478 return macroPath;; 479 }; 480 ; 481 // clang-format off; 482 ////////////////////////////////////////////////////////////////////////////////; 483 /// Enables the global mutex to make ROOT thread safe/aware.; 484 ///; 485 /// The following becomes safe:; 486 /// - concurrent construction and destruction of TObjects, including the ones registered in ROOT's global lists (e.g. gROOT->GetListOfCleanups(), gROOT->GetListOfFiles()); 487 /// - concurrent usage of _different_ ROOT objects from different threads, including ones with global state (e.g. TFile, TTree, TChain) with the exception of graphics classes (e.g. TCanvas); 488 /// - concurrent calls to ROOT's type system classes, e.g. TClass and TEnum; 489 /// - concurrent calls to the interpreter through gInterpreter; 490 /// - concurrent loading of ROOT plug-ins; 491 ///; 492 /// In addition, gDirectory, gFile and gPad become a thread-local variable.; 493 /// In all threads, gDirectory defaults to gROOT, a singleton which supports thread-safe insertion and deletion of contents.; 494 /// gFile and gPad default to nullptr, as it is for single-thread programs.; 495 ///; 496 /// The ROOT graphics subsystem is not made thread-safe by this method. In particular drawing or printing different; 497 /// canvases from different threads (and analogous operations such as invoking `Draw` on a `TObject`) is not thread-safe.; 498 ///; 499 /// Note that there is no `DisableThreadSafety()`. ROOT's thread-safety features cannot be disabled once activated.; 500 // clang-format on; 501 void EnableThreadSafety(); 502 {; 503 static void (*sym)() = (void(*)())Internal::GetSymInLibImt(""ROOT_TThread_Initialize"");; 504 if (sym); 505 sym();; 506 }; 507 ; 508 ////////////////////////////////////////////////////////////////////////////////; 509 /// @p",MatchSource.WIKI,doc/v632/TROOT_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/TROOT_8cxx_source.html
https://root.cern/doc/v632/TROOT_8cxx_source.html:17444,Performance,concurren,concurrent,17444," Internal sub namespace; 470// back to ROOT namespace; 471 ; 472 TROOT *GetROOT() {; 473 return (*Internal::gGetROOT)();; 474 }; 475 ; 476 TString &GetMacroPath() {; 477 static TString macroPath;; 478 return macroPath;; 479 }; 480 ; 481 // clang-format off; 482 ////////////////////////////////////////////////////////////////////////////////; 483 /// Enables the global mutex to make ROOT thread safe/aware.; 484 ///; 485 /// The following becomes safe:; 486 /// - concurrent construction and destruction of TObjects, including the ones registered in ROOT's global lists (e.g. gROOT->GetListOfCleanups(), gROOT->GetListOfFiles()); 487 /// - concurrent usage of _different_ ROOT objects from different threads, including ones with global state (e.g. TFile, TTree, TChain) with the exception of graphics classes (e.g. TCanvas); 488 /// - concurrent calls to ROOT's type system classes, e.g. TClass and TEnum; 489 /// - concurrent calls to the interpreter through gInterpreter; 490 /// - concurrent loading of ROOT plug-ins; 491 ///; 492 /// In addition, gDirectory, gFile and gPad become a thread-local variable.; 493 /// In all threads, gDirectory defaults to gROOT, a singleton which supports thread-safe insertion and deletion of contents.; 494 /// gFile and gPad default to nullptr, as it is for single-thread programs.; 495 ///; 496 /// The ROOT graphics subsystem is not made thread-safe by this method. In particular drawing or printing different; 497 /// canvases from different threads (and analogous operations such as invoking `Draw` on a `TObject`) is not thread-safe.; 498 ///; 499 /// Note that there is no `DisableThreadSafety()`. ROOT's thread-safety features cannot be disabled once activated.; 500 // clang-format on; 501 void EnableThreadSafety(); 502 {; 503 static void (*sym)() = (void(*)())Internal::GetSymInLibImt(""ROOT_TThread_Initialize"");; 504 if (sym); 505 sym();; 506 }; 507 ; 508 ////////////////////////////////////////////////////////////////////////////////; 509 /// @p",MatchSource.WIKI,doc/v632/TROOT_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/TROOT_8cxx_source.html
https://root.cern/doc/v632/TROOT_8cxx_source.html:17455,Performance,load,loading,17455," Internal sub namespace; 470// back to ROOT namespace; 471 ; 472 TROOT *GetROOT() {; 473 return (*Internal::gGetROOT)();; 474 }; 475 ; 476 TString &GetMacroPath() {; 477 static TString macroPath;; 478 return macroPath;; 479 }; 480 ; 481 // clang-format off; 482 ////////////////////////////////////////////////////////////////////////////////; 483 /// Enables the global mutex to make ROOT thread safe/aware.; 484 ///; 485 /// The following becomes safe:; 486 /// - concurrent construction and destruction of TObjects, including the ones registered in ROOT's global lists (e.g. gROOT->GetListOfCleanups(), gROOT->GetListOfFiles()); 487 /// - concurrent usage of _different_ ROOT objects from different threads, including ones with global state (e.g. TFile, TTree, TChain) with the exception of graphics classes (e.g. TCanvas); 488 /// - concurrent calls to ROOT's type system classes, e.g. TClass and TEnum; 489 /// - concurrent calls to the interpreter through gInterpreter; 490 /// - concurrent loading of ROOT plug-ins; 491 ///; 492 /// In addition, gDirectory, gFile and gPad become a thread-local variable.; 493 /// In all threads, gDirectory defaults to gROOT, a singleton which supports thread-safe insertion and deletion of contents.; 494 /// gFile and gPad default to nullptr, as it is for single-thread programs.; 495 ///; 496 /// The ROOT graphics subsystem is not made thread-safe by this method. In particular drawing or printing different; 497 /// canvases from different threads (and analogous operations such as invoking `Draw` on a `TObject`) is not thread-safe.; 498 ///; 499 /// Note that there is no `DisableThreadSafety()`. ROOT's thread-safety features cannot be disabled once activated.; 500 // clang-format on; 501 void EnableThreadSafety(); 502 {; 503 static void (*sym)() = (void(*)())Internal::GetSymInLibImt(""ROOT_TThread_Initialize"");; 504 if (sym); 505 sym();; 506 }; 507 ; 508 ////////////////////////////////////////////////////////////////////////////////; 509 /// @p",MatchSource.WIKI,doc/v632/TROOT_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/TROOT_8cxx_source.html
https://root.cern/doc/v632/TROOT_8cxx_source.html:18859,Performance,multi-thread,multi-threading,18859,"mat on; 501 void EnableThreadSafety(); 502 {; 503 static void (*sym)() = (void(*)())Internal::GetSymInLibImt(""ROOT_TThread_Initialize"");; 504 if (sym); 505 sym();; 506 }; 507 ; 508 ////////////////////////////////////////////////////////////////////////////////; 509 /// @param[in] numthreads Number of threads to use. If not specified or; 510 /// set to zero, the number of threads is automatically; 511 /// decided by the implementation. Any other value is; 512 /// used as a hint.; 513 ///; 514 /// ROOT must be built with the compilation flag `imt=ON` for this feature to be available.; 515 /// The following objects and methods automatically take advantage of; 516 /// multi-threading if a call to `EnableImplicitMT` has been made before usage:; 517 ///; 518 /// - RDataFrame internally runs the event-loop by parallelizing over clusters of entries; 519 /// - TTree::GetEntry reads multiple branches in parallel; 520 /// - TTree::FlushBaskets writes multiple baskets to disk in parallel; 521 /// - TTreeCacheUnzip decompresses the baskets contained in a TTreeCache in parallel; 522 /// - THx::Fit performs in parallel the evaluation of the objective function over the data; 523 /// - TMVA::DNN trains the deep neural networks in parallel; 524 /// - TMVA::BDT trains the classifier in parallel and multiclass BDTs are evaluated in parallel; 525 ///; 526 /// EnableImplicitMT calls in turn EnableThreadSafety.; 527 /// The 'numthreads' parameter allows to control the number of threads to; 528 /// be used by the implicit multi-threading. However, this parameter is just; 529 /// a hint for ROOT: it will try to satisfy the request if the execution; 530 /// scenario allows it. For example, if ROOT is configured to use an external; 531 /// scheduler, setting a value for 'numthreads' might not have any effect.; 532 /// The maximum number of threads can be influenced by the environment; 533 /// variable `ROOT_MAX_THREADS`: `export ROOT_MAX_THREADS=2` will try to set; 534 /// the maximum number ",MatchSource.WIKI,doc/v632/TROOT_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/TROOT_8cxx_source.html
https://root.cern/doc/v632/TROOT_8cxx_source.html:19287,Performance,perform,performs,19287,"mat on; 501 void EnableThreadSafety(); 502 {; 503 static void (*sym)() = (void(*)())Internal::GetSymInLibImt(""ROOT_TThread_Initialize"");; 504 if (sym); 505 sym();; 506 }; 507 ; 508 ////////////////////////////////////////////////////////////////////////////////; 509 /// @param[in] numthreads Number of threads to use. If not specified or; 510 /// set to zero, the number of threads is automatically; 511 /// decided by the implementation. Any other value is; 512 /// used as a hint.; 513 ///; 514 /// ROOT must be built with the compilation flag `imt=ON` for this feature to be available.; 515 /// The following objects and methods automatically take advantage of; 516 /// multi-threading if a call to `EnableImplicitMT` has been made before usage:; 517 ///; 518 /// - RDataFrame internally runs the event-loop by parallelizing over clusters of entries; 519 /// - TTree::GetEntry reads multiple branches in parallel; 520 /// - TTree::FlushBaskets writes multiple baskets to disk in parallel; 521 /// - TTreeCacheUnzip decompresses the baskets contained in a TTreeCache in parallel; 522 /// - THx::Fit performs in parallel the evaluation of the objective function over the data; 523 /// - TMVA::DNN trains the deep neural networks in parallel; 524 /// - TMVA::BDT trains the classifier in parallel and multiclass BDTs are evaluated in parallel; 525 ///; 526 /// EnableImplicitMT calls in turn EnableThreadSafety.; 527 /// The 'numthreads' parameter allows to control the number of threads to; 528 /// be used by the implicit multi-threading. However, this parameter is just; 529 /// a hint for ROOT: it will try to satisfy the request if the execution; 530 /// scenario allows it. For example, if ROOT is configured to use an external; 531 /// scheduler, setting a value for 'numthreads' might not have any effect.; 532 /// The maximum number of threads can be influenced by the environment; 533 /// variable `ROOT_MAX_THREADS`: `export ROOT_MAX_THREADS=2` will try to set; 534 /// the maximum number ",MatchSource.WIKI,doc/v632/TROOT_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/TROOT_8cxx_source.html
https://root.cern/doc/v632/TROOT_8cxx_source.html:19710,Performance,multi-thread,multi-threading,19710,"a hint.; 513 ///; 514 /// ROOT must be built with the compilation flag `imt=ON` for this feature to be available.; 515 /// The following objects and methods automatically take advantage of; 516 /// multi-threading if a call to `EnableImplicitMT` has been made before usage:; 517 ///; 518 /// - RDataFrame internally runs the event-loop by parallelizing over clusters of entries; 519 /// - TTree::GetEntry reads multiple branches in parallel; 520 /// - TTree::FlushBaskets writes multiple baskets to disk in parallel; 521 /// - TTreeCacheUnzip decompresses the baskets contained in a TTreeCache in parallel; 522 /// - THx::Fit performs in parallel the evaluation of the objective function over the data; 523 /// - TMVA::DNN trains the deep neural networks in parallel; 524 /// - TMVA::BDT trains the classifier in parallel and multiclass BDTs are evaluated in parallel; 525 ///; 526 /// EnableImplicitMT calls in turn EnableThreadSafety.; 527 /// The 'numthreads' parameter allows to control the number of threads to; 528 /// be used by the implicit multi-threading. However, this parameter is just; 529 /// a hint for ROOT: it will try to satisfy the request if the execution; 530 /// scenario allows it. For example, if ROOT is configured to use an external; 531 /// scheduler, setting a value for 'numthreads' might not have any effect.; 532 /// The maximum number of threads can be influenced by the environment; 533 /// variable `ROOT_MAX_THREADS`: `export ROOT_MAX_THREADS=2` will try to set; 534 /// the maximum number of active threads to 2, if the scheduling library; 535 /// (such as tbb) ""permits"".; 536 ///; 537 /// \note Use `DisableImplicitMT()` to disable multi-threading (some locks will remain in place as; 538 /// described in EnableThreadSafety()). `EnableImplicitMT(1)` creates a thread-pool of size 1.; 539 void EnableImplicitMT(UInt_t numthreads); 540 {; 541#ifdef R__USE_IMT; 542 if (ROOT::Internal::IsImplicitMTEnabledImpl()); 543 return;; 544 EnableThreadSafety();; 545 static ",MatchSource.WIKI,doc/v632/TROOT_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/TROOT_8cxx_source.html
https://root.cern/doc/v632/TROOT_8cxx_source.html:20331,Performance,multi-thread,multi-threading,20331," over the data; 523 /// - TMVA::DNN trains the deep neural networks in parallel; 524 /// - TMVA::BDT trains the classifier in parallel and multiclass BDTs are evaluated in parallel; 525 ///; 526 /// EnableImplicitMT calls in turn EnableThreadSafety.; 527 /// The 'numthreads' parameter allows to control the number of threads to; 528 /// be used by the implicit multi-threading. However, this parameter is just; 529 /// a hint for ROOT: it will try to satisfy the request if the execution; 530 /// scenario allows it. For example, if ROOT is configured to use an external; 531 /// scheduler, setting a value for 'numthreads' might not have any effect.; 532 /// The maximum number of threads can be influenced by the environment; 533 /// variable `ROOT_MAX_THREADS`: `export ROOT_MAX_THREADS=2` will try to set; 534 /// the maximum number of active threads to 2, if the scheduling library; 535 /// (such as tbb) ""permits"".; 536 ///; 537 /// \note Use `DisableImplicitMT()` to disable multi-threading (some locks will remain in place as; 538 /// described in EnableThreadSafety()). `EnableImplicitMT(1)` creates a thread-pool of size 1.; 539 void EnableImplicitMT(UInt_t numthreads); 540 {; 541#ifdef R__USE_IMT; 542 if (ROOT::Internal::IsImplicitMTEnabledImpl()); 543 return;; 544 EnableThreadSafety();; 545 static void (*sym)(UInt_t) = (void(*)(UInt_t))Internal::GetSymInLibImt(""ROOT_TImplicitMT_EnableImplicitMT"");; 546 if (sym); 547 sym(numthreads);; 548 ROOT::Internal::IsImplicitMTEnabledImpl() = true;; 549#else; 550 ::Warning(""EnableImplicitMT"", ""Cannot enable implicit multi-threading with %d threads, please build ROOT with -Dimt=ON"", numthreads);; 551#endif; 552 }; 553 ; 554 ////////////////////////////////////////////////////////////////////////////////; 555 /// Disables the implicit multi-threading in ROOT (see EnableImplicitMT).; 556 void DisableImplicitMT(); 557 {; 558#ifdef R__USE_IMT; 559 static void (*sym)() = (void(*)())Internal::GetSymInLibImt(""ROOT_TImplicitMT_DisableImplici",MatchSource.WIKI,doc/v632/TROOT_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/TROOT_8cxx_source.html
https://root.cern/doc/v632/TROOT_8cxx_source.html:20924,Performance,multi-thread,multi-threading,20924," 530 /// scenario allows it. For example, if ROOT is configured to use an external; 531 /// scheduler, setting a value for 'numthreads' might not have any effect.; 532 /// The maximum number of threads can be influenced by the environment; 533 /// variable `ROOT_MAX_THREADS`: `export ROOT_MAX_THREADS=2` will try to set; 534 /// the maximum number of active threads to 2, if the scheduling library; 535 /// (such as tbb) ""permits"".; 536 ///; 537 /// \note Use `DisableImplicitMT()` to disable multi-threading (some locks will remain in place as; 538 /// described in EnableThreadSafety()). `EnableImplicitMT(1)` creates a thread-pool of size 1.; 539 void EnableImplicitMT(UInt_t numthreads); 540 {; 541#ifdef R__USE_IMT; 542 if (ROOT::Internal::IsImplicitMTEnabledImpl()); 543 return;; 544 EnableThreadSafety();; 545 static void (*sym)(UInt_t) = (void(*)(UInt_t))Internal::GetSymInLibImt(""ROOT_TImplicitMT_EnableImplicitMT"");; 546 if (sym); 547 sym(numthreads);; 548 ROOT::Internal::IsImplicitMTEnabledImpl() = true;; 549#else; 550 ::Warning(""EnableImplicitMT"", ""Cannot enable implicit multi-threading with %d threads, please build ROOT with -Dimt=ON"", numthreads);; 551#endif; 552 }; 553 ; 554 ////////////////////////////////////////////////////////////////////////////////; 555 /// Disables the implicit multi-threading in ROOT (see EnableImplicitMT).; 556 void DisableImplicitMT(); 557 {; 558#ifdef R__USE_IMT; 559 static void (*sym)() = (void(*)())Internal::GetSymInLibImt(""ROOT_TImplicitMT_DisableImplicitMT"");; 560 if (sym); 561 sym();; 562 ROOT::Internal::IsImplicitMTEnabledImpl() = kFALSE;; 563#else; 564 ::Warning(""DisableImplicitMT"", ""Cannot disable implicit multi-threading, please build ROOT with -Dimt=ON"");; 565#endif; 566 }; 567 ; 568 ////////////////////////////////////////////////////////////////////////////////; 569 /// Returns true if the implicit multi-threading in ROOT is enabled.; 570 Bool_t IsImplicitMTEnabled(); 571 {; 572 return ROOT::Internal::IsImplicitMTEnabledImpl",MatchSource.WIKI,doc/v632/TROOT_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/TROOT_8cxx_source.html
https://root.cern/doc/v632/TROOT_8cxx_source.html:21145,Performance,multi-thread,multi-threading,21145," 530 /// scenario allows it. For example, if ROOT is configured to use an external; 531 /// scheduler, setting a value for 'numthreads' might not have any effect.; 532 /// The maximum number of threads can be influenced by the environment; 533 /// variable `ROOT_MAX_THREADS`: `export ROOT_MAX_THREADS=2` will try to set; 534 /// the maximum number of active threads to 2, if the scheduling library; 535 /// (such as tbb) ""permits"".; 536 ///; 537 /// \note Use `DisableImplicitMT()` to disable multi-threading (some locks will remain in place as; 538 /// described in EnableThreadSafety()). `EnableImplicitMT(1)` creates a thread-pool of size 1.; 539 void EnableImplicitMT(UInt_t numthreads); 540 {; 541#ifdef R__USE_IMT; 542 if (ROOT::Internal::IsImplicitMTEnabledImpl()); 543 return;; 544 EnableThreadSafety();; 545 static void (*sym)(UInt_t) = (void(*)(UInt_t))Internal::GetSymInLibImt(""ROOT_TImplicitMT_EnableImplicitMT"");; 546 if (sym); 547 sym(numthreads);; 548 ROOT::Internal::IsImplicitMTEnabledImpl() = true;; 549#else; 550 ::Warning(""EnableImplicitMT"", ""Cannot enable implicit multi-threading with %d threads, please build ROOT with -Dimt=ON"", numthreads);; 551#endif; 552 }; 553 ; 554 ////////////////////////////////////////////////////////////////////////////////; 555 /// Disables the implicit multi-threading in ROOT (see EnableImplicitMT).; 556 void DisableImplicitMT(); 557 {; 558#ifdef R__USE_IMT; 559 static void (*sym)() = (void(*)())Internal::GetSymInLibImt(""ROOT_TImplicitMT_DisableImplicitMT"");; 560 if (sym); 561 sym();; 562 ROOT::Internal::IsImplicitMTEnabledImpl() = kFALSE;; 563#else; 564 ::Warning(""DisableImplicitMT"", ""Cannot disable implicit multi-threading, please build ROOT with -Dimt=ON"");; 565#endif; 566 }; 567 ; 568 ////////////////////////////////////////////////////////////////////////////////; 569 /// Returns true if the implicit multi-threading in ROOT is enabled.; 570 Bool_t IsImplicitMTEnabled(); 571 {; 572 return ROOT::Internal::IsImplicitMTEnabledImpl",MatchSource.WIKI,doc/v632/TROOT_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/TROOT_8cxx_source.html
https://root.cern/doc/v632/TROOT_8cxx_source.html:21509,Performance,multi-thread,multi-threading,21509,"ool of size 1.; 539 void EnableImplicitMT(UInt_t numthreads); 540 {; 541#ifdef R__USE_IMT; 542 if (ROOT::Internal::IsImplicitMTEnabledImpl()); 543 return;; 544 EnableThreadSafety();; 545 static void (*sym)(UInt_t) = (void(*)(UInt_t))Internal::GetSymInLibImt(""ROOT_TImplicitMT_EnableImplicitMT"");; 546 if (sym); 547 sym(numthreads);; 548 ROOT::Internal::IsImplicitMTEnabledImpl() = true;; 549#else; 550 ::Warning(""EnableImplicitMT"", ""Cannot enable implicit multi-threading with %d threads, please build ROOT with -Dimt=ON"", numthreads);; 551#endif; 552 }; 553 ; 554 ////////////////////////////////////////////////////////////////////////////////; 555 /// Disables the implicit multi-threading in ROOT (see EnableImplicitMT).; 556 void DisableImplicitMT(); 557 {; 558#ifdef R__USE_IMT; 559 static void (*sym)() = (void(*)())Internal::GetSymInLibImt(""ROOT_TImplicitMT_DisableImplicitMT"");; 560 if (sym); 561 sym();; 562 ROOT::Internal::IsImplicitMTEnabledImpl() = kFALSE;; 563#else; 564 ::Warning(""DisableImplicitMT"", ""Cannot disable implicit multi-threading, please build ROOT with -Dimt=ON"");; 565#endif; 566 }; 567 ; 568 ////////////////////////////////////////////////////////////////////////////////; 569 /// Returns true if the implicit multi-threading in ROOT is enabled.; 570 Bool_t IsImplicitMTEnabled(); 571 {; 572 return ROOT::Internal::IsImplicitMTEnabledImpl();; 573 }; 574 ; 575 ////////////////////////////////////////////////////////////////////////////////; 576 /// Returns the size of ROOT's thread pool; 577 UInt_t GetThreadPoolSize(); 578 {; 579#ifdef R__USE_IMT; 580 static UInt_t (*sym)() = (UInt_t(*)())Internal::GetSymInLibImt(""ROOT_MT_GetThreadPoolSize"");; 581 if (sym); 582 return sym();; 583 else; 584 return 0;; 585#else; 586 return 0;; 587#endif; 588 }; 589} // end of ROOT namespace; 590 ; 591TROOT *ROOT::Internal::gROOTLocal = ROOT::GetROOT();; 592 ; 593// Global debug flag (set to > 0 to get debug output).; 594// Can be set either via the interpreter (gDebug is expor",MatchSource.WIKI,doc/v632/TROOT_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/TROOT_8cxx_source.html
https://root.cern/doc/v632/TROOT_8cxx_source.html:21709,Performance,multi-thread,multi-threading,21709,"ool of size 1.; 539 void EnableImplicitMT(UInt_t numthreads); 540 {; 541#ifdef R__USE_IMT; 542 if (ROOT::Internal::IsImplicitMTEnabledImpl()); 543 return;; 544 EnableThreadSafety();; 545 static void (*sym)(UInt_t) = (void(*)(UInt_t))Internal::GetSymInLibImt(""ROOT_TImplicitMT_EnableImplicitMT"");; 546 if (sym); 547 sym(numthreads);; 548 ROOT::Internal::IsImplicitMTEnabledImpl() = true;; 549#else; 550 ::Warning(""EnableImplicitMT"", ""Cannot enable implicit multi-threading with %d threads, please build ROOT with -Dimt=ON"", numthreads);; 551#endif; 552 }; 553 ; 554 ////////////////////////////////////////////////////////////////////////////////; 555 /// Disables the implicit multi-threading in ROOT (see EnableImplicitMT).; 556 void DisableImplicitMT(); 557 {; 558#ifdef R__USE_IMT; 559 static void (*sym)() = (void(*)())Internal::GetSymInLibImt(""ROOT_TImplicitMT_DisableImplicitMT"");; 560 if (sym); 561 sym();; 562 ROOT::Internal::IsImplicitMTEnabledImpl() = kFALSE;; 563#else; 564 ::Warning(""DisableImplicitMT"", ""Cannot disable implicit multi-threading, please build ROOT with -Dimt=ON"");; 565#endif; 566 }; 567 ; 568 ////////////////////////////////////////////////////////////////////////////////; 569 /// Returns true if the implicit multi-threading in ROOT is enabled.; 570 Bool_t IsImplicitMTEnabled(); 571 {; 572 return ROOT::Internal::IsImplicitMTEnabledImpl();; 573 }; 574 ; 575 ////////////////////////////////////////////////////////////////////////////////; 576 /// Returns the size of ROOT's thread pool; 577 UInt_t GetThreadPoolSize(); 578 {; 579#ifdef R__USE_IMT; 580 static UInt_t (*sym)() = (UInt_t(*)())Internal::GetSymInLibImt(""ROOT_MT_GetThreadPoolSize"");; 581 if (sym); 582 return sym();; 583 else; 584 return 0;; 585#else; 586 return 0;; 587#endif; 588 }; 589} // end of ROOT namespace; 590 ; 591TROOT *ROOT::Internal::gROOTLocal = ROOT::GetROOT();; 592 ; 593// Global debug flag (set to > 0 to get debug output).; 594// Can be set either via the interpreter (gDebug is expor",MatchSource.WIKI,doc/v632/TROOT_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/TROOT_8cxx_source.html
https://root.cern/doc/v632/TROOT_8cxx_source.html:24148,Performance,perform,performed,24148,"ustClean(kTRUE),fForceStyle(kFALSE),; 611 fInterrupt(kFALSE),fEscape(kFALSE),fExecutingMacro(kFALSE),fEditorMode(0),; 612 fPrimitive(nullptr),fSelectPad(nullptr),fClasses(nullptr),fTypes(nullptr),fGlobals(nullptr),fGlobalFunctions(nullptr),; 613 fClosedObjects(nullptr),fFiles(nullptr),fMappedFiles(nullptr),fSockets(nullptr),fCanvases(nullptr),fStyles(nullptr),fFunctions(nullptr),; 614 fTasks(nullptr),fColors(nullptr),fGeometries(nullptr),fBrowsers(nullptr),fSpecials(nullptr),fCleanups(nullptr),; 615 fMessageHandlers(nullptr),fStreamerInfo(nullptr),fClassGenerators(nullptr),fSecContexts(nullptr),; 616 fProofs(nullptr),fClipboard(nullptr),fDataSets(nullptr),fUUIDs(nullptr),fRootFolder(nullptr),fBrowsables(nullptr),; 617 fPluginManager(nullptr); 618{; 619}; 620 ; 621////////////////////////////////////////////////////////////////////////////////; 622/// Initialize the ROOT system. The creation of the TROOT object initializes; 623/// the ROOT system. It must be the first ROOT related action that is; 624/// performed by a program. The TROOT object must be created on the stack; 625/// (can not be called via new since ""operator new"" is protected). The; 626/// TROOT object is either created as a global object (outside the main(); 627/// program), or it is one of the first objects created in main().; 628/// Make sure that the TROOT object stays in scope for as long as ROOT; 629/// related actions are performed. TROOT is a so called singleton so; 630/// only one instance of it can be created. The single TROOT object can; 631/// always be accessed via the global pointer gROOT.; 632/// The name and title arguments can be used to identify the running; 633/// application. The initfunc argument can contain an array of; 634/// function pointers (last element must be 0). These functions are; 635/// executed at the end of the constructor. This way one can easily; 636/// extend the ROOT system without adding permanent dependencies; 637/// (e.g. the graphics system is initialized via su",MatchSource.WIKI,doc/v632/TROOT_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/TROOT_8cxx_source.html
https://root.cern/doc/v632/TROOT_8cxx_source.html:24545,Performance,perform,performed,24545,"ions(nullptr),; 614 fTasks(nullptr),fColors(nullptr),fGeometries(nullptr),fBrowsers(nullptr),fSpecials(nullptr),fCleanups(nullptr),; 615 fMessageHandlers(nullptr),fStreamerInfo(nullptr),fClassGenerators(nullptr),fSecContexts(nullptr),; 616 fProofs(nullptr),fClipboard(nullptr),fDataSets(nullptr),fUUIDs(nullptr),fRootFolder(nullptr),fBrowsables(nullptr),; 617 fPluginManager(nullptr); 618{; 619}; 620 ; 621////////////////////////////////////////////////////////////////////////////////; 622/// Initialize the ROOT system. The creation of the TROOT object initializes; 623/// the ROOT system. It must be the first ROOT related action that is; 624/// performed by a program. The TROOT object must be created on the stack; 625/// (can not be called via new since ""operator new"" is protected). The; 626/// TROOT object is either created as a global object (outside the main(); 627/// program), or it is one of the first objects created in main().; 628/// Make sure that the TROOT object stays in scope for as long as ROOT; 629/// related actions are performed. TROOT is a so called singleton so; 630/// only one instance of it can be created. The single TROOT object can; 631/// always be accessed via the global pointer gROOT.; 632/// The name and title arguments can be used to identify the running; 633/// application. The initfunc argument can contain an array of; 634/// function pointers (last element must be 0). These functions are; 635/// executed at the end of the constructor. This way one can easily; 636/// extend the ROOT system without adding permanent dependencies; 637/// (e.g. the graphics system is initialized via such a function).; 638 ; 639TROOT::TROOT(const char *name, const char *title, VoidFuncPtr_t *initfunc); 640 : TDirectory(), fLineIsProcessing(0), fVersion(0), fVersionInt(0), fVersionCode(0),; 641 fVersionDate(0), fVersionTime(0), fBuiltDate(0), fBuiltTime(0),; 642 fTimer(0), fApplication(nullptr), fInterpreter(nullptr), fBatch(kTRUE),; 643 fIsWebDisplay(kFALSE), fIs",MatchSource.WIKI,doc/v632/TROOT_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/TROOT_8cxx_source.html
https://root.cern/doc/v632/TROOT_8cxx_source.html:37823,Performance,load,load,37823," 942#ifdef R__COMPLETE_MEM_TERMINATION; 943 SafeDelete(fCanvases);; 944 SafeDelete(fTasks);; 945 SafeDelete(fProofs);; 946 SafeDelete(fDataSets);; 947 SafeDelete(fClipboard);; 948 ; 949 fCleanups->Clear();; 950 delete fPluginManager; gPluginMgr = fPluginManager = 0;; 951 delete gClassTable; gClassTable = 0;; 952 delete gEnv; gEnv = 0;; 953 ; 954 if (fTypes) fTypes->Delete();; 955 SafeDelete(fTypes);; 956 if (fGlobals) fGlobals->Delete();; 957 SafeDelete(fGlobals);; 958 if (fGlobalFunctions) fGlobalFunctions->Delete();; 959 SafeDelete(fGlobalFunctions);; 960 fEnums.load()->Delete();; 961 ; 962 // FIXME: Causes segfault in rootcling, debug and uncomment; 963 // fClasses->Delete(); SafeDelete(fClasses); // TClass'es must be deleted last; 964#endif; 965 ; 966 // Remove shared libraries produced by the TSystem::CompileMacro() call; 967 gSystem->CleanCompiledMacros();; 968 ; 969 // Cleanup system class; 970 ROOT::Internal::SetErrorSystemMsgHandler(ROOT::Internal::ErrorSystemMsgHandlerFunc_t());; 971 SetErrorHandler(ROOT::Internal::MinimalErrorHandler);; 972 ROOT::Internal::ReleaseDefaultErrorHandler();; 973 delete gSystem;; 974 ; 975 // ROOT-6022:; 976 // if (gInterpreterLib) dlclose(gInterpreterLib);; 977#ifdef R__COMPLETE_MEM_TERMINATION; 978 // On some 'newer' platform (Fedora Core 17+, Ubuntu 12), the; 979 // initialization order is (by default?) is 'wrong' and so we can't; 980 // delete the interpreter now .. because any of the static in the; 981 // interpreter's library have already been deleted.; 982 // On the link line, we must list the most dependent .o file; 983 // and end with the least dependent (LLVM libraries), unfortunately,; 984 // Fedora Core 17+ or Ubuntu 12 will also execute the initialization; 985 // in the same order (hence doing libCore's before LLVM's and; 986 // vice et versa for both the destructor. We worked around the; 987 // initialization order by delay the TROOT creation until first use.; 988 // We can not do the same for destruction as we hav",MatchSource.WIKI,doc/v632/TROOT_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/TROOT_8cxx_source.html
https://root.cern/doc/v632/TROOT_8cxx_source.html:40818,Performance,load,loaded,40818,"vailable when TROOT is part of rootcling.; 1004 if (dlsym(RTLD_DEFAULT, ""usedToIdentifyRootClingByDlSym"")) {; 1005 // deleting the interpreter makes things crash at exit in some cases; 1006 delete fInterpreter;; 1007 }; 1008#else; 1009 // deleting the interpreter makes things crash at exit in some cases; 1010 delete fInterpreter;; 1011#endif; 1012 ; 1013 // Prints memory stats; 1014 TStorage::PrintStatistics();; 1015 ; 1016 gROOTLocal = nullptr;; 1017 fgRootInit = kFALSE;; 1018 }; 1019}; 1020 ; 1021////////////////////////////////////////////////////////////////////////////////; 1022/// Add a class to the list and map of classes.; 1023/// This routine is deprecated, use TClass::AddClass directly.; 1024 ; 1025void TROOT::AddClass(TClass *cl); 1026{; 1027 TClass::AddClass(cl);; 1028}; 1029 ; 1030////////////////////////////////////////////////////////////////////////////////; 1031/// Add a class generator. This generator will be called by TClass::GetClass; 1032/// in case its does not find a loaded rootcint dictionary to request the; 1033/// creation of a TClass object.; 1034 ; 1035void TROOT::AddClassGenerator(TClassGenerator *generator); 1036{; 1037 if (!generator) return;; 1038 fClassGenerators->Add(generator);; 1039}; 1040 ; 1041////////////////////////////////////////////////////////////////////////////////; 1042/// Append object to this directory.; 1043///; 1044/// If replace is true:; 1045/// remove any existing objects with the same same (if the name is not """"); 1046 ; 1047void TROOT::Append(TObject *obj, Bool_t replace /* = kFALSE */); 1048{; 1049 R__LOCKGUARD(gROOTMutex);; 1050 TDirectory::Append(obj,replace);; 1051}; 1052 ; 1053////////////////////////////////////////////////////////////////////////////////; 1054/// Add browsable objects to TBrowser.; 1055 ; 1056void TROOT::Browse(TBrowser *b); 1057{; 1058 TObject *obj;; 1059 TIter next(fBrowsables);; 1060 ; 1061 while ((obj = (TObject *) next())) {; 1062 const char *opt = next.GetOption();; 1063 if (opt && ",MatchSource.WIKI,doc/v632/TROOT_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/TROOT_8cxx_source.html
https://root.cern/doc/v632/TROOT_8cxx_source.html:57333,Performance,load,load,57333,"ce of the object in the list; 1469/// of folders. The returned string points to a static char array in TROOT.; 1470/// If this function is called in a loop or recursively, it is the; 1471/// user's responsibility to copy this string in their area.; 1472 ; 1473const char *TROOT::FindObjectPathName(const TObject *) const; 1474{; 1475 Error(""FindObjectPathName"",""Not yet implemented"");; 1476 return ""??"";; 1477}; 1478 ; 1479////////////////////////////////////////////////////////////////////////////////; 1480/// return a TClass object corresponding to 'name' assuming it is an STL container.; 1481/// In particular we looking for possible alternative name (default template; 1482/// parameter, typedefs template arguments, typedefed name).; 1483 ; 1484TClass *TROOT::FindSTLClass(const char *name, Bool_t load, Bool_t silent) const; 1485{; 1486 // Example of inputs are; 1487 // vector<int> (*); 1488 // vector<Int_t>; 1489 // vector<long long>; 1490 // vector<Long_64_t> (*); 1491 // vector<int, allocator<int> >; 1492 // vector<Int_t, allocator<int> >; 1493 //; 1494 // One of the possibly expensive operation is the resolving of the typedef; 1495 // which can provoke the parsing of the header files (and/or the loading; 1496 // of clang pcms information).; 1497 ; 1498 R__LOCKGUARD(gInterpreterMutex);; 1499 ; 1500 // Remove std::, allocator, typedef, add Long64_t, etc. in just one call.; 1501 std::string normalized;; 1502 TClassEdit::GetNormalizedName(normalized, name);; 1503 ; 1504 TClass *cl = nullptr;; 1505 if (normalized != name) cl = TClass::GetClass(normalized.c_str(),load,silent);; 1506 ; 1507 if (load && cl==nullptr) {; 1508 // Create an Emulated class for this container.; 1509 cl = gInterpreter->GenerateTClass(normalized.c_str(), kTRUE, silent);; 1510 }; 1511 ; 1512 return cl;; 1513}; 1514 ; 1515////////////////////////////////////////////////////////////////////////////////; 1516/// Return pointer to class with name. Obsolete, use TClass::GetClass directly; 1517 ; 1518TCl",MatchSource.WIKI,doc/v632/TROOT_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/TROOT_8cxx_source.html
https://root.cern/doc/v632/TROOT_8cxx_source.html:57743,Performance,load,loading,57743,"ce of the object in the list; 1469/// of folders. The returned string points to a static char array in TROOT.; 1470/// If this function is called in a loop or recursively, it is the; 1471/// user's responsibility to copy this string in their area.; 1472 ; 1473const char *TROOT::FindObjectPathName(const TObject *) const; 1474{; 1475 Error(""FindObjectPathName"",""Not yet implemented"");; 1476 return ""??"";; 1477}; 1478 ; 1479////////////////////////////////////////////////////////////////////////////////; 1480/// return a TClass object corresponding to 'name' assuming it is an STL container.; 1481/// In particular we looking for possible alternative name (default template; 1482/// parameter, typedefs template arguments, typedefed name).; 1483 ; 1484TClass *TROOT::FindSTLClass(const char *name, Bool_t load, Bool_t silent) const; 1485{; 1486 // Example of inputs are; 1487 // vector<int> (*); 1488 // vector<Int_t>; 1489 // vector<long long>; 1490 // vector<Long_64_t> (*); 1491 // vector<int, allocator<int> >; 1492 // vector<Int_t, allocator<int> >; 1493 //; 1494 // One of the possibly expensive operation is the resolving of the typedef; 1495 // which can provoke the parsing of the header files (and/or the loading; 1496 // of clang pcms information).; 1497 ; 1498 R__LOCKGUARD(gInterpreterMutex);; 1499 ; 1500 // Remove std::, allocator, typedef, add Long64_t, etc. in just one call.; 1501 std::string normalized;; 1502 TClassEdit::GetNormalizedName(normalized, name);; 1503 ; 1504 TClass *cl = nullptr;; 1505 if (normalized != name) cl = TClass::GetClass(normalized.c_str(),load,silent);; 1506 ; 1507 if (load && cl==nullptr) {; 1508 // Create an Emulated class for this container.; 1509 cl = gInterpreter->GenerateTClass(normalized.c_str(), kTRUE, silent);; 1510 }; 1511 ; 1512 return cl;; 1513}; 1514 ; 1515////////////////////////////////////////////////////////////////////////////////; 1516/// Return pointer to class with name. Obsolete, use TClass::GetClass directly; 1517 ; 1518TCl",MatchSource.WIKI,doc/v632/TROOT_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/TROOT_8cxx_source.html
https://root.cern/doc/v632/TROOT_8cxx_source.html:58112,Performance,load,load,58112,"sible alternative name (default template; 1482/// parameter, typedefs template arguments, typedefed name).; 1483 ; 1484TClass *TROOT::FindSTLClass(const char *name, Bool_t load, Bool_t silent) const; 1485{; 1486 // Example of inputs are; 1487 // vector<int> (*); 1488 // vector<Int_t>; 1489 // vector<long long>; 1490 // vector<Long_64_t> (*); 1491 // vector<int, allocator<int> >; 1492 // vector<Int_t, allocator<int> >; 1493 //; 1494 // One of the possibly expensive operation is the resolving of the typedef; 1495 // which can provoke the parsing of the header files (and/or the loading; 1496 // of clang pcms information).; 1497 ; 1498 R__LOCKGUARD(gInterpreterMutex);; 1499 ; 1500 // Remove std::, allocator, typedef, add Long64_t, etc. in just one call.; 1501 std::string normalized;; 1502 TClassEdit::GetNormalizedName(normalized, name);; 1503 ; 1504 TClass *cl = nullptr;; 1505 if (normalized != name) cl = TClass::GetClass(normalized.c_str(),load,silent);; 1506 ; 1507 if (load && cl==nullptr) {; 1508 // Create an Emulated class for this container.; 1509 cl = gInterpreter->GenerateTClass(normalized.c_str(), kTRUE, silent);; 1510 }; 1511 ; 1512 return cl;; 1513}; 1514 ; 1515////////////////////////////////////////////////////////////////////////////////; 1516/// Return pointer to class with name. Obsolete, use TClass::GetClass directly; 1517 ; 1518TClass *TROOT::GetClass(const char *name, Bool_t load, Bool_t silent) const; 1519{; 1520 return TClass::GetClass(name,load,silent);; 1521}; 1522 ; 1523 ; 1524////////////////////////////////////////////////////////////////////////////////; 1525/// Return pointer to class from its name. Obsolete, use TClass::GetClass directly; 1526/// See TClass::GetClass; 1527 ; 1528TClass *TROOT::GetClass(const std::type_info& typeinfo, Bool_t load, Bool_t silent) const; 1529{; 1530 return TClass::GetClass(typeinfo,load,silent);; 1531}; 1532 ; 1533////////////////////////////////////////////////////////////////////////////////; 1534/// Return add",MatchSource.WIKI,doc/v632/TROOT_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/TROOT_8cxx_source.html
https://root.cern/doc/v632/TROOT_8cxx_source.html:58143,Performance,load,load,58143,"sible alternative name (default template; 1482/// parameter, typedefs template arguments, typedefed name).; 1483 ; 1484TClass *TROOT::FindSTLClass(const char *name, Bool_t load, Bool_t silent) const; 1485{; 1486 // Example of inputs are; 1487 // vector<int> (*); 1488 // vector<Int_t>; 1489 // vector<long long>; 1490 // vector<Long_64_t> (*); 1491 // vector<int, allocator<int> >; 1492 // vector<Int_t, allocator<int> >; 1493 //; 1494 // One of the possibly expensive operation is the resolving of the typedef; 1495 // which can provoke the parsing of the header files (and/or the loading; 1496 // of clang pcms information).; 1497 ; 1498 R__LOCKGUARD(gInterpreterMutex);; 1499 ; 1500 // Remove std::, allocator, typedef, add Long64_t, etc. in just one call.; 1501 std::string normalized;; 1502 TClassEdit::GetNormalizedName(normalized, name);; 1503 ; 1504 TClass *cl = nullptr;; 1505 if (normalized != name) cl = TClass::GetClass(normalized.c_str(),load,silent);; 1506 ; 1507 if (load && cl==nullptr) {; 1508 // Create an Emulated class for this container.; 1509 cl = gInterpreter->GenerateTClass(normalized.c_str(), kTRUE, silent);; 1510 }; 1511 ; 1512 return cl;; 1513}; 1514 ; 1515////////////////////////////////////////////////////////////////////////////////; 1516/// Return pointer to class with name. Obsolete, use TClass::GetClass directly; 1517 ; 1518TClass *TROOT::GetClass(const char *name, Bool_t load, Bool_t silent) const; 1519{; 1520 return TClass::GetClass(name,load,silent);; 1521}; 1522 ; 1523 ; 1524////////////////////////////////////////////////////////////////////////////////; 1525/// Return pointer to class from its name. Obsolete, use TClass::GetClass directly; 1526/// See TClass::GetClass; 1527 ; 1528TClass *TROOT::GetClass(const std::type_info& typeinfo, Bool_t load, Bool_t silent) const; 1529{; 1530 return TClass::GetClass(typeinfo,load,silent);; 1531}; 1532 ; 1533////////////////////////////////////////////////////////////////////////////////; 1534/// Return add",MatchSource.WIKI,doc/v632/TROOT_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/TROOT_8cxx_source.html
https://root.cern/doc/v632/TROOT_8cxx_source.html:58573,Performance,load,load,58573,"is the resolving of the typedef; 1495 // which can provoke the parsing of the header files (and/or the loading; 1496 // of clang pcms information).; 1497 ; 1498 R__LOCKGUARD(gInterpreterMutex);; 1499 ; 1500 // Remove std::, allocator, typedef, add Long64_t, etc. in just one call.; 1501 std::string normalized;; 1502 TClassEdit::GetNormalizedName(normalized, name);; 1503 ; 1504 TClass *cl = nullptr;; 1505 if (normalized != name) cl = TClass::GetClass(normalized.c_str(),load,silent);; 1506 ; 1507 if (load && cl==nullptr) {; 1508 // Create an Emulated class for this container.; 1509 cl = gInterpreter->GenerateTClass(normalized.c_str(), kTRUE, silent);; 1510 }; 1511 ; 1512 return cl;; 1513}; 1514 ; 1515////////////////////////////////////////////////////////////////////////////////; 1516/// Return pointer to class with name. Obsolete, use TClass::GetClass directly; 1517 ; 1518TClass *TROOT::GetClass(const char *name, Bool_t load, Bool_t silent) const; 1519{; 1520 return TClass::GetClass(name,load,silent);; 1521}; 1522 ; 1523 ; 1524////////////////////////////////////////////////////////////////////////////////; 1525/// Return pointer to class from its name. Obsolete, use TClass::GetClass directly; 1526/// See TClass::GetClass; 1527 ; 1528TClass *TROOT::GetClass(const std::type_info& typeinfo, Bool_t load, Bool_t silent) const; 1529{; 1530 return TClass::GetClass(typeinfo,load,silent);; 1531}; 1532 ; 1533////////////////////////////////////////////////////////////////////////////////; 1534/// Return address of color with index color.; 1535 ; 1536TColor *TROOT::GetColor(Int_t color) const; 1537{; 1538 TColor::InitializeColors();; 1539 TObjArray *lcolors = (TObjArray*) GetListOfColors();; 1540 if (!lcolors) return nullptr;; 1541 if (color < 0 || color >= lcolors->GetSize()) return nullptr;; 1542 TColor *col = (TColor*)lcolors->At(color);; 1543 if (col && col->GetNumber() == color) return col;; 1544 TIter next(lcolors);; 1545 while ((col = (TColor *) next())); 1546 if (col->G",MatchSource.WIKI,doc/v632/TROOT_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/TROOT_8cxx_source.html
https://root.cern/doc/v632/TROOT_8cxx_source.html:58642,Performance,load,load,58642,"is the resolving of the typedef; 1495 // which can provoke the parsing of the header files (and/or the loading; 1496 // of clang pcms information).; 1497 ; 1498 R__LOCKGUARD(gInterpreterMutex);; 1499 ; 1500 // Remove std::, allocator, typedef, add Long64_t, etc. in just one call.; 1501 std::string normalized;; 1502 TClassEdit::GetNormalizedName(normalized, name);; 1503 ; 1504 TClass *cl = nullptr;; 1505 if (normalized != name) cl = TClass::GetClass(normalized.c_str(),load,silent);; 1506 ; 1507 if (load && cl==nullptr) {; 1508 // Create an Emulated class for this container.; 1509 cl = gInterpreter->GenerateTClass(normalized.c_str(), kTRUE, silent);; 1510 }; 1511 ; 1512 return cl;; 1513}; 1514 ; 1515////////////////////////////////////////////////////////////////////////////////; 1516/// Return pointer to class with name. Obsolete, use TClass::GetClass directly; 1517 ; 1518TClass *TROOT::GetClass(const char *name, Bool_t load, Bool_t silent) const; 1519{; 1520 return TClass::GetClass(name,load,silent);; 1521}; 1522 ; 1523 ; 1524////////////////////////////////////////////////////////////////////////////////; 1525/// Return pointer to class from its name. Obsolete, use TClass::GetClass directly; 1526/// See TClass::GetClass; 1527 ; 1528TClass *TROOT::GetClass(const std::type_info& typeinfo, Bool_t load, Bool_t silent) const; 1529{; 1530 return TClass::GetClass(typeinfo,load,silent);; 1531}; 1532 ; 1533////////////////////////////////////////////////////////////////////////////////; 1534/// Return address of color with index color.; 1535 ; 1536TColor *TROOT::GetColor(Int_t color) const; 1537{; 1538 TColor::InitializeColors();; 1539 TObjArray *lcolors = (TObjArray*) GetListOfColors();; 1540 if (!lcolors) return nullptr;; 1541 if (color < 0 || color >= lcolors->GetSize()) return nullptr;; 1542 TColor *col = (TColor*)lcolors->At(color);; 1543 if (col && col->GetNumber() == color) return col;; 1544 TIter next(lcolors);; 1545 while ((col = (TColor *) next())); 1546 if (col->G",MatchSource.WIKI,doc/v632/TROOT_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/TROOT_8cxx_source.html
https://root.cern/doc/v632/TROOT_8cxx_source.html:58956,Performance,load,load,58956,"me);; 1503 ; 1504 TClass *cl = nullptr;; 1505 if (normalized != name) cl = TClass::GetClass(normalized.c_str(),load,silent);; 1506 ; 1507 if (load && cl==nullptr) {; 1508 // Create an Emulated class for this container.; 1509 cl = gInterpreter->GenerateTClass(normalized.c_str(), kTRUE, silent);; 1510 }; 1511 ; 1512 return cl;; 1513}; 1514 ; 1515////////////////////////////////////////////////////////////////////////////////; 1516/// Return pointer to class with name. Obsolete, use TClass::GetClass directly; 1517 ; 1518TClass *TROOT::GetClass(const char *name, Bool_t load, Bool_t silent) const; 1519{; 1520 return TClass::GetClass(name,load,silent);; 1521}; 1522 ; 1523 ; 1524////////////////////////////////////////////////////////////////////////////////; 1525/// Return pointer to class from its name. Obsolete, use TClass::GetClass directly; 1526/// See TClass::GetClass; 1527 ; 1528TClass *TROOT::GetClass(const std::type_info& typeinfo, Bool_t load, Bool_t silent) const; 1529{; 1530 return TClass::GetClass(typeinfo,load,silent);; 1531}; 1532 ; 1533////////////////////////////////////////////////////////////////////////////////; 1534/// Return address of color with index color.; 1535 ; 1536TColor *TROOT::GetColor(Int_t color) const; 1537{; 1538 TColor::InitializeColors();; 1539 TObjArray *lcolors = (TObjArray*) GetListOfColors();; 1540 if (!lcolors) return nullptr;; 1541 if (color < 0 || color >= lcolors->GetSize()) return nullptr;; 1542 TColor *col = (TColor*)lcolors->At(color);; 1543 if (col && col->GetNumber() == color) return col;; 1544 TIter next(lcolors);; 1545 while ((col = (TColor *) next())); 1546 if (col->GetNumber() == color) return col;; 1547 ; 1548 return nullptr;; 1549}; 1550 ; 1551////////////////////////////////////////////////////////////////////////////////; 1552/// Return a default canvas.; 1553 ; 1554TCanvas *TROOT::MakeDefCanvas() const; 1555{; 1556 return (TCanvas*)gROOT->ProcessLine(""TCanvas::MakeDefCanvas();"");; 1557}; 1558 ; 1559/////////////////",MatchSource.WIKI,doc/v632/TROOT_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/TROOT_8cxx_source.html
https://root.cern/doc/v632/TROOT_8cxx_source.html:59029,Performance,load,load,59029,"me);; 1503 ; 1504 TClass *cl = nullptr;; 1505 if (normalized != name) cl = TClass::GetClass(normalized.c_str(),load,silent);; 1506 ; 1507 if (load && cl==nullptr) {; 1508 // Create an Emulated class for this container.; 1509 cl = gInterpreter->GenerateTClass(normalized.c_str(), kTRUE, silent);; 1510 }; 1511 ; 1512 return cl;; 1513}; 1514 ; 1515////////////////////////////////////////////////////////////////////////////////; 1516/// Return pointer to class with name. Obsolete, use TClass::GetClass directly; 1517 ; 1518TClass *TROOT::GetClass(const char *name, Bool_t load, Bool_t silent) const; 1519{; 1520 return TClass::GetClass(name,load,silent);; 1521}; 1522 ; 1523 ; 1524////////////////////////////////////////////////////////////////////////////////; 1525/// Return pointer to class from its name. Obsolete, use TClass::GetClass directly; 1526/// See TClass::GetClass; 1527 ; 1528TClass *TROOT::GetClass(const std::type_info& typeinfo, Bool_t load, Bool_t silent) const; 1529{; 1530 return TClass::GetClass(typeinfo,load,silent);; 1531}; 1532 ; 1533////////////////////////////////////////////////////////////////////////////////; 1534/// Return address of color with index color.; 1535 ; 1536TColor *TROOT::GetColor(Int_t color) const; 1537{; 1538 TColor::InitializeColors();; 1539 TObjArray *lcolors = (TObjArray*) GetListOfColors();; 1540 if (!lcolors) return nullptr;; 1541 if (color < 0 || color >= lcolors->GetSize()) return nullptr;; 1542 TColor *col = (TColor*)lcolors->At(color);; 1543 if (col && col->GetNumber() == color) return col;; 1544 TIter next(lcolors);; 1545 while ((col = (TColor *) next())); 1546 if (col->GetNumber() == color) return col;; 1547 ; 1548 return nullptr;; 1549}; 1550 ; 1551////////////////////////////////////////////////////////////////////////////////; 1552/// Return a default canvas.; 1553 ; 1554TCanvas *TROOT::MakeDefCanvas() const; 1555{; 1556 return (TCanvas*)gROOT->ProcessLine(""TCanvas::MakeDefCanvas();"");; 1557}; 1558 ; 1559/////////////////",MatchSource.WIKI,doc/v632/TROOT_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/TROOT_8cxx_source.html
https://root.cern/doc/v632/TROOT_8cxx_source.html:60175,Performance,load,load,60175,"1538 TColor::InitializeColors();; 1539 TObjArray *lcolors = (TObjArray*) GetListOfColors();; 1540 if (!lcolors) return nullptr;; 1541 if (color < 0 || color >= lcolors->GetSize()) return nullptr;; 1542 TColor *col = (TColor*)lcolors->At(color);; 1543 if (col && col->GetNumber() == color) return col;; 1544 TIter next(lcolors);; 1545 while ((col = (TColor *) next())); 1546 if (col->GetNumber() == color) return col;; 1547 ; 1548 return nullptr;; 1549}; 1550 ; 1551////////////////////////////////////////////////////////////////////////////////; 1552/// Return a default canvas.; 1553 ; 1554TCanvas *TROOT::MakeDefCanvas() const; 1555{; 1556 return (TCanvas*)gROOT->ProcessLine(""TCanvas::MakeDefCanvas();"");; 1557}; 1558 ; 1559////////////////////////////////////////////////////////////////////////////////; 1560/// Return pointer to type with name.; 1561 ; 1562TDataType *TROOT::GetType(const char *name, Bool_t /* load */) const; 1563{; 1564 return (TDataType*)gROOT->GetListOfTypes()->FindObject(name);; 1565}; 1566 ; 1567////////////////////////////////////////////////////////////////////////////////; 1568/// Return pointer to file with name.; 1569 ; 1570TFile *TROOT::GetFile(const char *name) const; 1571{; 1572 R__LOCKGUARD(gROOTMutex);; 1573 return (TFile*)GetListOfFiles()->FindObject(name);; 1574}; 1575 ; 1576////////////////////////////////////////////////////////////////////////////////; 1577/// Return pointer to style with name; 1578 ; 1579TStyle *TROOT::GetStyle(const char *name) const; 1580{; 1581 return (TStyle*)GetListOfStyles()->FindObject(name);; 1582}; 1583 ; 1584////////////////////////////////////////////////////////////////////////////////; 1585/// Return pointer to function with name.; 1586 ; 1587TObject *TROOT::GetFunction(const char *name) const; 1588{; 1589 if (!name || !*name); 1590 return nullptr;; 1591 ; 1592 static std::atomic<bool> isInited = false;; 1593 ; 1594 // Capture the state before calling FindObject as it could change; 1595 // between the end ",MatchSource.WIKI,doc/v632/TROOT_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/TROOT_8cxx_source.html
https://root.cern/doc/v632/TROOT_8cxx_source.html:61325,Performance,load,load,61325," R__LOCKGUARD(gROOTMutex);; 1573 return (TFile*)GetListOfFiles()->FindObject(name);; 1574}; 1575 ; 1576////////////////////////////////////////////////////////////////////////////////; 1577/// Return pointer to style with name; 1578 ; 1579TStyle *TROOT::GetStyle(const char *name) const; 1580{; 1581 return (TStyle*)GetListOfStyles()->FindObject(name);; 1582}; 1583 ; 1584////////////////////////////////////////////////////////////////////////////////; 1585/// Return pointer to function with name.; 1586 ; 1587TObject *TROOT::GetFunction(const char *name) const; 1588{; 1589 if (!name || !*name); 1590 return nullptr;; 1591 ; 1592 static std::atomic<bool> isInited = false;; 1593 ; 1594 // Capture the state before calling FindObject as it could change; 1595 // between the end of FindObject and the if statement; 1596 bool wasInited = isInited.load();; 1597 ; 1598 auto f1 = fFunctions->FindObject(name);; 1599 if (f1 || wasInited); 1600 return f1;; 1601 ; 1602 // If 2 threads gets here at the same time, the static initialization ""lock""; 1603 // will stall one of them until ProcessLine is finished and both will return the; 1604 // correct answer.; 1605 // Note: if one (or more) thread(s) is suspended right after the 'isInited.load()`; 1606 // and restart after this thread has finished the initialization (i.e. a rare case),; 1607 // the only penalty we pay is a spurious 2nd lookup for an unknown function.; 1608 [[maybe_unused]] static const auto _res = []() {; 1609 gROOT->ProcessLine(""TF1::InitStandardFunctions();"");; 1610 isInited = true;; 1611 return true;; 1612 }();; 1613 return fFunctions->FindObject(name);; 1614}; 1615 ; 1616////////////////////////////////////////////////////////////////////////////////; 1617 ; 1618TFunctionTemplate *TROOT::GetFunctionTemplate(const char *name); 1619{; 1620 if (!gInterpreter) return nullptr;; 1621 ; 1622 if (!fFuncTemplate) fFuncTemplate = new TListOfFunctionTemplates(nullptr);; 1623 ; 1624 return (TFunctionTemplate*)fFuncTemplate->FindOb",MatchSource.WIKI,doc/v632/TROOT_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/TROOT_8cxx_source.html
https://root.cern/doc/v632/TROOT_8cxx_source.html:61713,Performance,load,load,61713,"ame) const; 1580{; 1581 return (TStyle*)GetListOfStyles()->FindObject(name);; 1582}; 1583 ; 1584////////////////////////////////////////////////////////////////////////////////; 1585/// Return pointer to function with name.; 1586 ; 1587TObject *TROOT::GetFunction(const char *name) const; 1588{; 1589 if (!name || !*name); 1590 return nullptr;; 1591 ; 1592 static std::atomic<bool> isInited = false;; 1593 ; 1594 // Capture the state before calling FindObject as it could change; 1595 // between the end of FindObject and the if statement; 1596 bool wasInited = isInited.load();; 1597 ; 1598 auto f1 = fFunctions->FindObject(name);; 1599 if (f1 || wasInited); 1600 return f1;; 1601 ; 1602 // If 2 threads gets here at the same time, the static initialization ""lock""; 1603 // will stall one of them until ProcessLine is finished and both will return the; 1604 // correct answer.; 1605 // Note: if one (or more) thread(s) is suspended right after the 'isInited.load()`; 1606 // and restart after this thread has finished the initialization (i.e. a rare case),; 1607 // the only penalty we pay is a spurious 2nd lookup for an unknown function.; 1608 [[maybe_unused]] static const auto _res = []() {; 1609 gROOT->ProcessLine(""TF1::InitStandardFunctions();"");; 1610 isInited = true;; 1611 return true;; 1612 }();; 1613 return fFunctions->FindObject(name);; 1614}; 1615 ; 1616////////////////////////////////////////////////////////////////////////////////; 1617 ; 1618TFunctionTemplate *TROOT::GetFunctionTemplate(const char *name); 1619{; 1620 if (!gInterpreter) return nullptr;; 1621 ; 1622 if (!fFuncTemplate) fFuncTemplate = new TListOfFunctionTemplates(nullptr);; 1623 ; 1624 return (TFunctionTemplate*)fFuncTemplate->FindObject(name);; 1625}; 1626 ; 1627////////////////////////////////////////////////////////////////////////////////; 1628/// Return pointer to global variable by name. If load is true force; 1629/// reading of all currently defined globals from CINT (more expensive).; 1630 ; 1631",MatchSource.WIKI,doc/v632/TROOT_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/TROOT_8cxx_source.html
https://root.cern/doc/v632/TROOT_8cxx_source.html:62645,Performance,load,load,62645,"t after the 'isInited.load()`; 1606 // and restart after this thread has finished the initialization (i.e. a rare case),; 1607 // the only penalty we pay is a spurious 2nd lookup for an unknown function.; 1608 [[maybe_unused]] static const auto _res = []() {; 1609 gROOT->ProcessLine(""TF1::InitStandardFunctions();"");; 1610 isInited = true;; 1611 return true;; 1612 }();; 1613 return fFunctions->FindObject(name);; 1614}; 1615 ; 1616////////////////////////////////////////////////////////////////////////////////; 1617 ; 1618TFunctionTemplate *TROOT::GetFunctionTemplate(const char *name); 1619{; 1620 if (!gInterpreter) return nullptr;; 1621 ; 1622 if (!fFuncTemplate) fFuncTemplate = new TListOfFunctionTemplates(nullptr);; 1623 ; 1624 return (TFunctionTemplate*)fFuncTemplate->FindObject(name);; 1625}; 1626 ; 1627////////////////////////////////////////////////////////////////////////////////; 1628/// Return pointer to global variable by name. If load is true force; 1629/// reading of all currently defined globals from CINT (more expensive).; 1630 ; 1631TGlobal *TROOT::GetGlobal(const char *name, Bool_t load) const; 1632{; 1633 return (TGlobal *)gROOT->GetListOfGlobals(load)->FindObject(name);; 1634}; 1635 ; 1636////////////////////////////////////////////////////////////////////////////////; 1637/// Return pointer to global variable with address addr.; 1638 ; 1639TGlobal *TROOT::GetGlobal(const TObject *addr, Bool_t /* load */) const; 1640{; 1641 if (addr == nullptr || ((Longptr_t)addr) == -1) return nullptr;; 1642 ; 1643 TInterpreter::DeclId_t decl = gInterpreter->GetDataMemberAtAddr(addr);; 1644 if (decl) {; 1645 TListOfDataMembers *globals = ((TListOfDataMembers*)(gROOT->GetListOfGlobals(kFALSE)));; 1646 return (TGlobal*)globals->Get(decl);; 1647 }; 1648 // If we are actually looking for a global that is held by a global; 1649 // pointer (for example gRandom), we need to find a pointer with the; 1650 // correct value.; 1651 decl = gInterpreter->GetDataMemberWithValue(a",MatchSource.WIKI,doc/v632/TROOT_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/TROOT_8cxx_source.html
https://root.cern/doc/v632/TROOT_8cxx_source.html:62805,Performance,load,load,62805,"8 [[maybe_unused]] static const auto _res = []() {; 1609 gROOT->ProcessLine(""TF1::InitStandardFunctions();"");; 1610 isInited = true;; 1611 return true;; 1612 }();; 1613 return fFunctions->FindObject(name);; 1614}; 1615 ; 1616////////////////////////////////////////////////////////////////////////////////; 1617 ; 1618TFunctionTemplate *TROOT::GetFunctionTemplate(const char *name); 1619{; 1620 if (!gInterpreter) return nullptr;; 1621 ; 1622 if (!fFuncTemplate) fFuncTemplate = new TListOfFunctionTemplates(nullptr);; 1623 ; 1624 return (TFunctionTemplate*)fFuncTemplate->FindObject(name);; 1625}; 1626 ; 1627////////////////////////////////////////////////////////////////////////////////; 1628/// Return pointer to global variable by name. If load is true force; 1629/// reading of all currently defined globals from CINT (more expensive).; 1630 ; 1631TGlobal *TROOT::GetGlobal(const char *name, Bool_t load) const; 1632{; 1633 return (TGlobal *)gROOT->GetListOfGlobals(load)->FindObject(name);; 1634}; 1635 ; 1636////////////////////////////////////////////////////////////////////////////////; 1637/// Return pointer to global variable with address addr.; 1638 ; 1639TGlobal *TROOT::GetGlobal(const TObject *addr, Bool_t /* load */) const; 1640{; 1641 if (addr == nullptr || ((Longptr_t)addr) == -1) return nullptr;; 1642 ; 1643 TInterpreter::DeclId_t decl = gInterpreter->GetDataMemberAtAddr(addr);; 1644 if (decl) {; 1645 TListOfDataMembers *globals = ((TListOfDataMembers*)(gROOT->GetListOfGlobals(kFALSE)));; 1646 return (TGlobal*)globals->Get(decl);; 1647 }; 1648 // If we are actually looking for a global that is held by a global; 1649 // pointer (for example gRandom), we need to find a pointer with the; 1650 // correct value.; 1651 decl = gInterpreter->GetDataMemberWithValue(addr);; 1652 if (decl) {; 1653 TListOfDataMembers *globals = ((TListOfDataMembers*)(gROOT->GetListOfGlobals(kFALSE)));; 1654 return (TGlobal*)globals->Get(decl);; 1655 }; 1656 return nullptr;; 1657}; 1658 ; 165",MatchSource.WIKI,doc/v632/TROOT_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/TROOT_8cxx_source.html
https://root.cern/doc/v632/TROOT_8cxx_source.html:62872,Performance,load,load,62872,"8 [[maybe_unused]] static const auto _res = []() {; 1609 gROOT->ProcessLine(""TF1::InitStandardFunctions();"");; 1610 isInited = true;; 1611 return true;; 1612 }();; 1613 return fFunctions->FindObject(name);; 1614}; 1615 ; 1616////////////////////////////////////////////////////////////////////////////////; 1617 ; 1618TFunctionTemplate *TROOT::GetFunctionTemplate(const char *name); 1619{; 1620 if (!gInterpreter) return nullptr;; 1621 ; 1622 if (!fFuncTemplate) fFuncTemplate = new TListOfFunctionTemplates(nullptr);; 1623 ; 1624 return (TFunctionTemplate*)fFuncTemplate->FindObject(name);; 1625}; 1626 ; 1627////////////////////////////////////////////////////////////////////////////////; 1628/// Return pointer to global variable by name. If load is true force; 1629/// reading of all currently defined globals from CINT (more expensive).; 1630 ; 1631TGlobal *TROOT::GetGlobal(const char *name, Bool_t load) const; 1632{; 1633 return (TGlobal *)gROOT->GetListOfGlobals(load)->FindObject(name);; 1634}; 1635 ; 1636////////////////////////////////////////////////////////////////////////////////; 1637/// Return pointer to global variable with address addr.; 1638 ; 1639TGlobal *TROOT::GetGlobal(const TObject *addr, Bool_t /* load */) const; 1640{; 1641 if (addr == nullptr || ((Longptr_t)addr) == -1) return nullptr;; 1642 ; 1643 TInterpreter::DeclId_t decl = gInterpreter->GetDataMemberAtAddr(addr);; 1644 if (decl) {; 1645 TListOfDataMembers *globals = ((TListOfDataMembers*)(gROOT->GetListOfGlobals(kFALSE)));; 1646 return (TGlobal*)globals->Get(decl);; 1647 }; 1648 // If we are actually looking for a global that is held by a global; 1649 // pointer (for example gRandom), we need to find a pointer with the; 1650 // correct value.; 1651 decl = gInterpreter->GetDataMemberWithValue(addr);; 1652 if (decl) {; 1653 TListOfDataMembers *globals = ((TListOfDataMembers*)(gROOT->GetListOfGlobals(kFALSE)));; 1654 return (TGlobal*)globals->Get(decl);; 1655 }; 1656 return nullptr;; 1657}; 1658 ; 165",MatchSource.WIKI,doc/v632/TROOT_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/TROOT_8cxx_source.html
https://root.cern/doc/v632/TROOT_8cxx_source.html:63128,Performance,load,load,63128,"FuncTemplate) fFuncTemplate = new TListOfFunctionTemplates(nullptr);; 1623 ; 1624 return (TFunctionTemplate*)fFuncTemplate->FindObject(name);; 1625}; 1626 ; 1627////////////////////////////////////////////////////////////////////////////////; 1628/// Return pointer to global variable by name. If load is true force; 1629/// reading of all currently defined globals from CINT (more expensive).; 1630 ; 1631TGlobal *TROOT::GetGlobal(const char *name, Bool_t load) const; 1632{; 1633 return (TGlobal *)gROOT->GetListOfGlobals(load)->FindObject(name);; 1634}; 1635 ; 1636////////////////////////////////////////////////////////////////////////////////; 1637/// Return pointer to global variable with address addr.; 1638 ; 1639TGlobal *TROOT::GetGlobal(const TObject *addr, Bool_t /* load */) const; 1640{; 1641 if (addr == nullptr || ((Longptr_t)addr) == -1) return nullptr;; 1642 ; 1643 TInterpreter::DeclId_t decl = gInterpreter->GetDataMemberAtAddr(addr);; 1644 if (decl) {; 1645 TListOfDataMembers *globals = ((TListOfDataMembers*)(gROOT->GetListOfGlobals(kFALSE)));; 1646 return (TGlobal*)globals->Get(decl);; 1647 }; 1648 // If we are actually looking for a global that is held by a global; 1649 // pointer (for example gRandom), we need to find a pointer with the; 1650 // correct value.; 1651 decl = gInterpreter->GetDataMemberWithValue(addr);; 1652 if (decl) {; 1653 TListOfDataMembers *globals = ((TListOfDataMembers*)(gROOT->GetListOfGlobals(kFALSE)));; 1654 return (TGlobal*)globals->Get(decl);; 1655 }; 1656 return nullptr;; 1657}; 1658 ; 1659////////////////////////////////////////////////////////////////////////////////; 1660/// Internal routine returning, and creating if necessary, the list; 1661/// of global function.; 1662 ; 1663TListOfFunctions *TROOT::GetGlobalFunctions(); 1664{; 1665 if (!fGlobalFunctions) fGlobalFunctions = new TListOfFunctions(nullptr);; 1666 return fGlobalFunctions;; 1667}; 1668 ; 1669///////////////////////////////////////////////////////////////////////",MatchSource.WIKI,doc/v632/TROOT_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/TROOT_8cxx_source.html
https://root.cern/doc/v632/TROOT_8cxx_source.html:64868,Performance,load,load,64868,"659////////////////////////////////////////////////////////////////////////////////; 1660/// Internal routine returning, and creating if necessary, the list; 1661/// of global function.; 1662 ; 1663TListOfFunctions *TROOT::GetGlobalFunctions(); 1664{; 1665 if (!fGlobalFunctions) fGlobalFunctions = new TListOfFunctions(nullptr);; 1666 return fGlobalFunctions;; 1667}; 1668 ; 1669////////////////////////////////////////////////////////////////////////////////; 1670/// Return the collection of functions named ""name"".; 1671 ; 1672TCollection *TROOT::GetListOfFunctionOverloads(const char* name) const; 1673{; 1674 return ((TListOfFunctions*)fGlobalFunctions)->GetListForObject(name);; 1675}; 1676 ; 1677////////////////////////////////////////////////////////////////////////////////; 1678/// Return pointer to global function by name.; 1679/// If params != 0 it will also resolve overloading other it returns the first; 1680/// name match.; 1681/// If params == 0 and load is true force reading of all currently defined; 1682/// global functions from Cling.; 1683/// The param string must be of the form: ""3189,\""aap\"",1.3"".; 1684 ; 1685TFunction *TROOT::GetGlobalFunction(const char *function, const char *params,; 1686 Bool_t load); 1687{; 1688 if (!params) {; 1689 R__LOCKGUARD(gROOTMutex);; 1690 return (TFunction *)GetListOfGlobalFunctions(load)->FindObject(function);; 1691 } else {; 1692 if (!fInterpreter); 1693 Fatal(""GetGlobalFunction"", ""fInterpreter not initialized"");; 1694 ; 1695 R__LOCKGUARD(gROOTMutex);; 1696 TInterpreter::DeclId_t decl = gInterpreter->GetFunctionWithValues(nullptr,; 1697 function, params,; 1698 false);; 1699 ; 1700 if (!decl) return nullptr;; 1701 ; 1702 TFunction *f = GetGlobalFunctions()->Get(decl);; 1703 if (f) return f;; 1704 ; 1705 Error(""GetGlobalFunction"",; 1706 ""\nDid not find matching TFunction <%s> with \""%s\""."",; 1707 function,params);; 1708 return nullptr;; 1709 }; 1710}; 1711 ; 1712//////////////////////////////////////////////////////////////",MatchSource.WIKI,doc/v632/TROOT_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/TROOT_8cxx_source.html
https://root.cern/doc/v632/TROOT_8cxx_source.html:65128,Performance,load,load,65128," functions named ""name"".; 1671 ; 1672TCollection *TROOT::GetListOfFunctionOverloads(const char* name) const; 1673{; 1674 return ((TListOfFunctions*)fGlobalFunctions)->GetListForObject(name);; 1675}; 1676 ; 1677////////////////////////////////////////////////////////////////////////////////; 1678/// Return pointer to global function by name.; 1679/// If params != 0 it will also resolve overloading other it returns the first; 1680/// name match.; 1681/// If params == 0 and load is true force reading of all currently defined; 1682/// global functions from Cling.; 1683/// The param string must be of the form: ""3189,\""aap\"",1.3"".; 1684 ; 1685TFunction *TROOT::GetGlobalFunction(const char *function, const char *params,; 1686 Bool_t load); 1687{; 1688 if (!params) {; 1689 R__LOCKGUARD(gROOTMutex);; 1690 return (TFunction *)GetListOfGlobalFunctions(load)->FindObject(function);; 1691 } else {; 1692 if (!fInterpreter); 1693 Fatal(""GetGlobalFunction"", ""fInterpreter not initialized"");; 1694 ; 1695 R__LOCKGUARD(gROOTMutex);; 1696 TInterpreter::DeclId_t decl = gInterpreter->GetFunctionWithValues(nullptr,; 1697 function, params,; 1698 false);; 1699 ; 1700 if (!decl) return nullptr;; 1701 ; 1702 TFunction *f = GetGlobalFunctions()->Get(decl);; 1703 if (f) return f;; 1704 ; 1705 Error(""GetGlobalFunction"",; 1706 ""\nDid not find matching TFunction <%s> with \""%s\""."",; 1707 function,params);; 1708 return nullptr;; 1709 }; 1710}; 1711 ; 1712////////////////////////////////////////////////////////////////////////////////; 1713/// Return pointer to global function by name. If proto != 0; 1714/// it will also resolve overloading. If load is true force reading; 1715/// of all currently defined global functions from CINT (more expensive).; 1716/// The proto string must be of the form: ""int, char*, float"".; 1717 ; 1718TFunction *TROOT::GetGlobalFunctionWithPrototype(const char *function,; 1719 const char *proto, Bool_t load); 1720{; 1721 if (!proto) {; 1722 R__LOCKGUARD(gROOTMutex);; 1723 ret",MatchSource.WIKI,doc/v632/TROOT_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/TROOT_8cxx_source.html
https://root.cern/doc/v632/TROOT_8cxx_source.html:65245,Performance,load,load,65245," functions named ""name"".; 1671 ; 1672TCollection *TROOT::GetListOfFunctionOverloads(const char* name) const; 1673{; 1674 return ((TListOfFunctions*)fGlobalFunctions)->GetListForObject(name);; 1675}; 1676 ; 1677////////////////////////////////////////////////////////////////////////////////; 1678/// Return pointer to global function by name.; 1679/// If params != 0 it will also resolve overloading other it returns the first; 1680/// name match.; 1681/// If params == 0 and load is true force reading of all currently defined; 1682/// global functions from Cling.; 1683/// The param string must be of the form: ""3189,\""aap\"",1.3"".; 1684 ; 1685TFunction *TROOT::GetGlobalFunction(const char *function, const char *params,; 1686 Bool_t load); 1687{; 1688 if (!params) {; 1689 R__LOCKGUARD(gROOTMutex);; 1690 return (TFunction *)GetListOfGlobalFunctions(load)->FindObject(function);; 1691 } else {; 1692 if (!fInterpreter); 1693 Fatal(""GetGlobalFunction"", ""fInterpreter not initialized"");; 1694 ; 1695 R__LOCKGUARD(gROOTMutex);; 1696 TInterpreter::DeclId_t decl = gInterpreter->GetFunctionWithValues(nullptr,; 1697 function, params,; 1698 false);; 1699 ; 1700 if (!decl) return nullptr;; 1701 ; 1702 TFunction *f = GetGlobalFunctions()->Get(decl);; 1703 if (f) return f;; 1704 ; 1705 Error(""GetGlobalFunction"",; 1706 ""\nDid not find matching TFunction <%s> with \""%s\""."",; 1707 function,params);; 1708 return nullptr;; 1709 }; 1710}; 1711 ; 1712////////////////////////////////////////////////////////////////////////////////; 1713/// Return pointer to global function by name. If proto != 0; 1714/// it will also resolve overloading. If load is true force reading; 1715/// of all currently defined global functions from CINT (more expensive).; 1716/// The proto string must be of the form: ""int, char*, float"".; 1717 ; 1718TFunction *TROOT::GetGlobalFunctionWithPrototype(const char *function,; 1719 const char *proto, Bool_t load); 1720{; 1721 if (!proto) {; 1722 R__LOCKGUARD(gROOTMutex);; 1723 ret",MatchSource.WIKI,doc/v632/TROOT_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/TROOT_8cxx_source.html
https://root.cern/doc/v632/TROOT_8cxx_source.html:66029,Performance,load,load,66029,"char *function, const char *params,; 1686 Bool_t load); 1687{; 1688 if (!params) {; 1689 R__LOCKGUARD(gROOTMutex);; 1690 return (TFunction *)GetListOfGlobalFunctions(load)->FindObject(function);; 1691 } else {; 1692 if (!fInterpreter); 1693 Fatal(""GetGlobalFunction"", ""fInterpreter not initialized"");; 1694 ; 1695 R__LOCKGUARD(gROOTMutex);; 1696 TInterpreter::DeclId_t decl = gInterpreter->GetFunctionWithValues(nullptr,; 1697 function, params,; 1698 false);; 1699 ; 1700 if (!decl) return nullptr;; 1701 ; 1702 TFunction *f = GetGlobalFunctions()->Get(decl);; 1703 if (f) return f;; 1704 ; 1705 Error(""GetGlobalFunction"",; 1706 ""\nDid not find matching TFunction <%s> with \""%s\""."",; 1707 function,params);; 1708 return nullptr;; 1709 }; 1710}; 1711 ; 1712////////////////////////////////////////////////////////////////////////////////; 1713/// Return pointer to global function by name. If proto != 0; 1714/// it will also resolve overloading. If load is true force reading; 1715/// of all currently defined global functions from CINT (more expensive).; 1716/// The proto string must be of the form: ""int, char*, float"".; 1717 ; 1718TFunction *TROOT::GetGlobalFunctionWithPrototype(const char *function,; 1719 const char *proto, Bool_t load); 1720{; 1721 if (!proto) {; 1722 R__LOCKGUARD(gROOTMutex);; 1723 return (TFunction *)GetListOfGlobalFunctions(load)->FindObject(function);; 1724 } else {; 1725 if (!fInterpreter); 1726 Fatal(""GetGlobalFunctionWithPrototype"", ""fInterpreter not initialized"");; 1727 ; 1728 R__LOCKGUARD(gROOTMutex);; 1729 TInterpreter::DeclId_t decl = gInterpreter->GetFunctionWithPrototype(nullptr,; 1730 function, proto);; 1731 ; 1732 if (!decl) return nullptr;; 1733 ; 1734 TFunction *f = GetGlobalFunctions()->Get(decl);; 1735 if (f) return f;; 1736 ; 1737 Error(""GetGlobalFunctionWithPrototype"",; 1738 ""\nDid not find matching TFunction <%s> with \""%s\""."",; 1739 function,proto);; 1740 return nullptr;; 1741 }; 1742}; 1743 ; 1744/////////////////////////////////////////",MatchSource.WIKI,doc/v632/TROOT_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/TROOT_8cxx_source.html
https://root.cern/doc/v632/TROOT_8cxx_source.html:66318,Performance,load,load,66318," ; 1702 TFunction *f = GetGlobalFunctions()->Get(decl);; 1703 if (f) return f;; 1704 ; 1705 Error(""GetGlobalFunction"",; 1706 ""\nDid not find matching TFunction <%s> with \""%s\""."",; 1707 function,params);; 1708 return nullptr;; 1709 }; 1710}; 1711 ; 1712////////////////////////////////////////////////////////////////////////////////; 1713/// Return pointer to global function by name. If proto != 0; 1714/// it will also resolve overloading. If load is true force reading; 1715/// of all currently defined global functions from CINT (more expensive).; 1716/// The proto string must be of the form: ""int, char*, float"".; 1717 ; 1718TFunction *TROOT::GetGlobalFunctionWithPrototype(const char *function,; 1719 const char *proto, Bool_t load); 1720{; 1721 if (!proto) {; 1722 R__LOCKGUARD(gROOTMutex);; 1723 return (TFunction *)GetListOfGlobalFunctions(load)->FindObject(function);; 1724 } else {; 1725 if (!fInterpreter); 1726 Fatal(""GetGlobalFunctionWithPrototype"", ""fInterpreter not initialized"");; 1727 ; 1728 R__LOCKGUARD(gROOTMutex);; 1729 TInterpreter::DeclId_t decl = gInterpreter->GetFunctionWithPrototype(nullptr,; 1730 function, proto);; 1731 ; 1732 if (!decl) return nullptr;; 1733 ; 1734 TFunction *f = GetGlobalFunctions()->Get(decl);; 1735 if (f) return f;; 1736 ; 1737 Error(""GetGlobalFunctionWithPrototype"",; 1738 ""\nDid not find matching TFunction <%s> with \""%s\""."",; 1739 function,proto);; 1740 return nullptr;; 1741 }; 1742}; 1743 ; 1744////////////////////////////////////////////////////////////////////////////////; 1745/// Return pointer to Geometry with name; 1746 ; 1747TObject *TROOT::GetGeometry(const char *name) const; 1748{; 1749 return GetListOfGeometries()->FindObject(name);; 1750}; 1751 ; 1752////////////////////////////////////////////////////////////////////////////////; 1753 ; 1754TCollection *TROOT::GetListOfEnums(Bool_t load /* = kTRUE */); 1755{; 1756 if(!fEnums.load()) {; 1757 R__LOCKGUARD(gROOTMutex);; 1758 // Test again just in case, another thread did",MatchSource.WIKI,doc/v632/TROOT_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/TROOT_8cxx_source.html
https://root.cern/doc/v632/TROOT_8cxx_source.html:66434,Performance,load,load,66434," ; 1702 TFunction *f = GetGlobalFunctions()->Get(decl);; 1703 if (f) return f;; 1704 ; 1705 Error(""GetGlobalFunction"",; 1706 ""\nDid not find matching TFunction <%s> with \""%s\""."",; 1707 function,params);; 1708 return nullptr;; 1709 }; 1710}; 1711 ; 1712////////////////////////////////////////////////////////////////////////////////; 1713/// Return pointer to global function by name. If proto != 0; 1714/// it will also resolve overloading. If load is true force reading; 1715/// of all currently defined global functions from CINT (more expensive).; 1716/// The proto string must be of the form: ""int, char*, float"".; 1717 ; 1718TFunction *TROOT::GetGlobalFunctionWithPrototype(const char *function,; 1719 const char *proto, Bool_t load); 1720{; 1721 if (!proto) {; 1722 R__LOCKGUARD(gROOTMutex);; 1723 return (TFunction *)GetListOfGlobalFunctions(load)->FindObject(function);; 1724 } else {; 1725 if (!fInterpreter); 1726 Fatal(""GetGlobalFunctionWithPrototype"", ""fInterpreter not initialized"");; 1727 ; 1728 R__LOCKGUARD(gROOTMutex);; 1729 TInterpreter::DeclId_t decl = gInterpreter->GetFunctionWithPrototype(nullptr,; 1730 function, proto);; 1731 ; 1732 if (!decl) return nullptr;; 1733 ; 1734 TFunction *f = GetGlobalFunctions()->Get(decl);; 1735 if (f) return f;; 1736 ; 1737 Error(""GetGlobalFunctionWithPrototype"",; 1738 ""\nDid not find matching TFunction <%s> with \""%s\""."",; 1739 function,proto);; 1740 return nullptr;; 1741 }; 1742}; 1743 ; 1744////////////////////////////////////////////////////////////////////////////////; 1745/// Return pointer to Geometry with name; 1746 ; 1747TObject *TROOT::GetGeometry(const char *name) const; 1748{; 1749 return GetListOfGeometries()->FindObject(name);; 1750}; 1751 ; 1752////////////////////////////////////////////////////////////////////////////////; 1753 ; 1754TCollection *TROOT::GetListOfEnums(Bool_t load /* = kTRUE */); 1755{; 1756 if(!fEnums.load()) {; 1757 R__LOCKGUARD(gROOTMutex);; 1758 // Test again just in case, another thread did",MatchSource.WIKI,doc/v632/TROOT_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/TROOT_8cxx_source.html
https://root.cern/doc/v632/TROOT_8cxx_source.html:67445,Performance,load,load,67445,"TROOT::GetGlobalFunctionWithPrototype(const char *function,; 1719 const char *proto, Bool_t load); 1720{; 1721 if (!proto) {; 1722 R__LOCKGUARD(gROOTMutex);; 1723 return (TFunction *)GetListOfGlobalFunctions(load)->FindObject(function);; 1724 } else {; 1725 if (!fInterpreter); 1726 Fatal(""GetGlobalFunctionWithPrototype"", ""fInterpreter not initialized"");; 1727 ; 1728 R__LOCKGUARD(gROOTMutex);; 1729 TInterpreter::DeclId_t decl = gInterpreter->GetFunctionWithPrototype(nullptr,; 1730 function, proto);; 1731 ; 1732 if (!decl) return nullptr;; 1733 ; 1734 TFunction *f = GetGlobalFunctions()->Get(decl);; 1735 if (f) return f;; 1736 ; 1737 Error(""GetGlobalFunctionWithPrototype"",; 1738 ""\nDid not find matching TFunction <%s> with \""%s\""."",; 1739 function,proto);; 1740 return nullptr;; 1741 }; 1742}; 1743 ; 1744////////////////////////////////////////////////////////////////////////////////; 1745/// Return pointer to Geometry with name; 1746 ; 1747TObject *TROOT::GetGeometry(const char *name) const; 1748{; 1749 return GetListOfGeometries()->FindObject(name);; 1750}; 1751 ; 1752////////////////////////////////////////////////////////////////////////////////; 1753 ; 1754TCollection *TROOT::GetListOfEnums(Bool_t load /* = kTRUE */); 1755{; 1756 if(!fEnums.load()) {; 1757 R__LOCKGUARD(gROOTMutex);; 1758 // Test again just in case, another thread did the work while we were; 1759 // waiting.; 1760 if (!fEnums.load()) fEnums = new TListOfEnumsWithLock(nullptr);; 1761 }; 1762 if (load) {; 1763 R__LOCKGUARD(gROOTMutex);; 1764 (*fEnums).Load(); // Refresh the list of enums.; 1765 }; 1766 return fEnums.load();; 1767}; 1768 ; 1769////////////////////////////////////////////////////////////////////////////////; 1770 ; 1771TCollection *TROOT::GetListOfFunctionTemplates(); 1772{; 1773 R__LOCKGUARD(gROOTMutex);; 1774 if(!fFuncTemplate) {; 1775 fFuncTemplate = new TListOfFunctionTemplates(nullptr);; 1776 }; 1777 return fFuncTemplate;; 1778}; 1779 ; 1780/////////////////////////////////////////",MatchSource.WIKI,doc/v632/TROOT_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/TROOT_8cxx_source.html
https://root.cern/doc/v632/TROOT_8cxx_source.html:67489,Performance,load,load,67489,"preter not initialized"");; 1727 ; 1728 R__LOCKGUARD(gROOTMutex);; 1729 TInterpreter::DeclId_t decl = gInterpreter->GetFunctionWithPrototype(nullptr,; 1730 function, proto);; 1731 ; 1732 if (!decl) return nullptr;; 1733 ; 1734 TFunction *f = GetGlobalFunctions()->Get(decl);; 1735 if (f) return f;; 1736 ; 1737 Error(""GetGlobalFunctionWithPrototype"",; 1738 ""\nDid not find matching TFunction <%s> with \""%s\""."",; 1739 function,proto);; 1740 return nullptr;; 1741 }; 1742}; 1743 ; 1744////////////////////////////////////////////////////////////////////////////////; 1745/// Return pointer to Geometry with name; 1746 ; 1747TObject *TROOT::GetGeometry(const char *name) const; 1748{; 1749 return GetListOfGeometries()->FindObject(name);; 1750}; 1751 ; 1752////////////////////////////////////////////////////////////////////////////////; 1753 ; 1754TCollection *TROOT::GetListOfEnums(Bool_t load /* = kTRUE */); 1755{; 1756 if(!fEnums.load()) {; 1757 R__LOCKGUARD(gROOTMutex);; 1758 // Test again just in case, another thread did the work while we were; 1759 // waiting.; 1760 if (!fEnums.load()) fEnums = new TListOfEnumsWithLock(nullptr);; 1761 }; 1762 if (load) {; 1763 R__LOCKGUARD(gROOTMutex);; 1764 (*fEnums).Load(); // Refresh the list of enums.; 1765 }; 1766 return fEnums.load();; 1767}; 1768 ; 1769////////////////////////////////////////////////////////////////////////////////; 1770 ; 1771TCollection *TROOT::GetListOfFunctionTemplates(); 1772{; 1773 R__LOCKGUARD(gROOTMutex);; 1774 if(!fFuncTemplate) {; 1775 fFuncTemplate = new TListOfFunctionTemplates(nullptr);; 1776 }; 1777 return fFuncTemplate;; 1778}; 1779 ; 1780////////////////////////////////////////////////////////////////////////////////; 1781/// Return list containing the TGlobals currently defined.; 1782/// Since globals are created and deleted during execution of the; 1783/// program, we need to update the list of globals every time we; 1784/// execute this method. However, when calling this function in; 1785/// a (tigh",MatchSource.WIKI,doc/v632/TROOT_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/TROOT_8cxx_source.html
https://root.cern/doc/v632/TROOT_8cxx_source.html:67643,Performance,load,load,67643,"1730 function, proto);; 1731 ; 1732 if (!decl) return nullptr;; 1733 ; 1734 TFunction *f = GetGlobalFunctions()->Get(decl);; 1735 if (f) return f;; 1736 ; 1737 Error(""GetGlobalFunctionWithPrototype"",; 1738 ""\nDid not find matching TFunction <%s> with \""%s\""."",; 1739 function,proto);; 1740 return nullptr;; 1741 }; 1742}; 1743 ; 1744////////////////////////////////////////////////////////////////////////////////; 1745/// Return pointer to Geometry with name; 1746 ; 1747TObject *TROOT::GetGeometry(const char *name) const; 1748{; 1749 return GetListOfGeometries()->FindObject(name);; 1750}; 1751 ; 1752////////////////////////////////////////////////////////////////////////////////; 1753 ; 1754TCollection *TROOT::GetListOfEnums(Bool_t load /* = kTRUE */); 1755{; 1756 if(!fEnums.load()) {; 1757 R__LOCKGUARD(gROOTMutex);; 1758 // Test again just in case, another thread did the work while we were; 1759 // waiting.; 1760 if (!fEnums.load()) fEnums = new TListOfEnumsWithLock(nullptr);; 1761 }; 1762 if (load) {; 1763 R__LOCKGUARD(gROOTMutex);; 1764 (*fEnums).Load(); // Refresh the list of enums.; 1765 }; 1766 return fEnums.load();; 1767}; 1768 ; 1769////////////////////////////////////////////////////////////////////////////////; 1770 ; 1771TCollection *TROOT::GetListOfFunctionTemplates(); 1772{; 1773 R__LOCKGUARD(gROOTMutex);; 1774 if(!fFuncTemplate) {; 1775 fFuncTemplate = new TListOfFunctionTemplates(nullptr);; 1776 }; 1777 return fFuncTemplate;; 1778}; 1779 ; 1780////////////////////////////////////////////////////////////////////////////////; 1781/// Return list containing the TGlobals currently defined.; 1782/// Since globals are created and deleted during execution of the; 1783/// program, we need to update the list of globals every time we; 1784/// execute this method. However, when calling this function in; 1785/// a (tight) loop where no interpreter symbols will be created; 1786/// you can set load=kFALSE (default).; 1787 ; 1788TCollection *TROOT::GetListOfGlobals(Boo",MatchSource.WIKI,doc/v632/TROOT_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/TROOT_8cxx_source.html
https://root.cern/doc/v632/TROOT_8cxx_source.html:67713,Performance,load,load,67713,"1730 function, proto);; 1731 ; 1732 if (!decl) return nullptr;; 1733 ; 1734 TFunction *f = GetGlobalFunctions()->Get(decl);; 1735 if (f) return f;; 1736 ; 1737 Error(""GetGlobalFunctionWithPrototype"",; 1738 ""\nDid not find matching TFunction <%s> with \""%s\""."",; 1739 function,proto);; 1740 return nullptr;; 1741 }; 1742}; 1743 ; 1744////////////////////////////////////////////////////////////////////////////////; 1745/// Return pointer to Geometry with name; 1746 ; 1747TObject *TROOT::GetGeometry(const char *name) const; 1748{; 1749 return GetListOfGeometries()->FindObject(name);; 1750}; 1751 ; 1752////////////////////////////////////////////////////////////////////////////////; 1753 ; 1754TCollection *TROOT::GetListOfEnums(Bool_t load /* = kTRUE */); 1755{; 1756 if(!fEnums.load()) {; 1757 R__LOCKGUARD(gROOTMutex);; 1758 // Test again just in case, another thread did the work while we were; 1759 // waiting.; 1760 if (!fEnums.load()) fEnums = new TListOfEnumsWithLock(nullptr);; 1761 }; 1762 if (load) {; 1763 R__LOCKGUARD(gROOTMutex);; 1764 (*fEnums).Load(); // Refresh the list of enums.; 1765 }; 1766 return fEnums.load();; 1767}; 1768 ; 1769////////////////////////////////////////////////////////////////////////////////; 1770 ; 1771TCollection *TROOT::GetListOfFunctionTemplates(); 1772{; 1773 R__LOCKGUARD(gROOTMutex);; 1774 if(!fFuncTemplate) {; 1775 fFuncTemplate = new TListOfFunctionTemplates(nullptr);; 1776 }; 1777 return fFuncTemplate;; 1778}; 1779 ; 1780////////////////////////////////////////////////////////////////////////////////; 1781/// Return list containing the TGlobals currently defined.; 1782/// Since globals are created and deleted during execution of the; 1783/// program, we need to update the list of globals every time we; 1784/// execute this method. However, when calling this function in; 1785/// a (tight) loop where no interpreter symbols will be created; 1786/// you can set load=kFALSE (default).; 1787 ; 1788TCollection *TROOT::GetListOfGlobals(Boo",MatchSource.WIKI,doc/v632/TROOT_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/TROOT_8cxx_source.html
https://root.cern/doc/v632/TROOT_8cxx_source.html:67835,Performance,load,load,67835,"/////////////////////////////////////; 1745/// Return pointer to Geometry with name; 1746 ; 1747TObject *TROOT::GetGeometry(const char *name) const; 1748{; 1749 return GetListOfGeometries()->FindObject(name);; 1750}; 1751 ; 1752////////////////////////////////////////////////////////////////////////////////; 1753 ; 1754TCollection *TROOT::GetListOfEnums(Bool_t load /* = kTRUE */); 1755{; 1756 if(!fEnums.load()) {; 1757 R__LOCKGUARD(gROOTMutex);; 1758 // Test again just in case, another thread did the work while we were; 1759 // waiting.; 1760 if (!fEnums.load()) fEnums = new TListOfEnumsWithLock(nullptr);; 1761 }; 1762 if (load) {; 1763 R__LOCKGUARD(gROOTMutex);; 1764 (*fEnums).Load(); // Refresh the list of enums.; 1765 }; 1766 return fEnums.load();; 1767}; 1768 ; 1769////////////////////////////////////////////////////////////////////////////////; 1770 ; 1771TCollection *TROOT::GetListOfFunctionTemplates(); 1772{; 1773 R__LOCKGUARD(gROOTMutex);; 1774 if(!fFuncTemplate) {; 1775 fFuncTemplate = new TListOfFunctionTemplates(nullptr);; 1776 }; 1777 return fFuncTemplate;; 1778}; 1779 ; 1780////////////////////////////////////////////////////////////////////////////////; 1781/// Return list containing the TGlobals currently defined.; 1782/// Since globals are created and deleted during execution of the; 1783/// program, we need to update the list of globals every time we; 1784/// execute this method. However, when calling this function in; 1785/// a (tight) loop where no interpreter symbols will be created; 1786/// you can set load=kFALSE (default).; 1787 ; 1788TCollection *TROOT::GetListOfGlobals(Bool_t load); 1789{; 1790 if (!fGlobals) {; 1791 fGlobals = new TListOfDataMembers(nullptr, TDictionary::EMemberSelection::kAlsoUsingDecls);; 1792 // We add to the list the ""funcky-fake"" globals.; 1793 ; 1794 // provide special functor for gROOT, while ROOT::GetROOT() does not return reference; 1795 TGlobalMappedFunction::MakeFunctor(""gROOT"", ""TROOT*"", ROOT::GetROOT, [] {; 1796",MatchSource.WIKI,doc/v632/TROOT_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/TROOT_8cxx_source.html
https://root.cern/doc/v632/TROOT_8cxx_source.html:68631,Performance,load,load,68631,"ad did the work while we were; 1759 // waiting.; 1760 if (!fEnums.load()) fEnums = new TListOfEnumsWithLock(nullptr);; 1761 }; 1762 if (load) {; 1763 R__LOCKGUARD(gROOTMutex);; 1764 (*fEnums).Load(); // Refresh the list of enums.; 1765 }; 1766 return fEnums.load();; 1767}; 1768 ; 1769////////////////////////////////////////////////////////////////////////////////; 1770 ; 1771TCollection *TROOT::GetListOfFunctionTemplates(); 1772{; 1773 R__LOCKGUARD(gROOTMutex);; 1774 if(!fFuncTemplate) {; 1775 fFuncTemplate = new TListOfFunctionTemplates(nullptr);; 1776 }; 1777 return fFuncTemplate;; 1778}; 1779 ; 1780////////////////////////////////////////////////////////////////////////////////; 1781/// Return list containing the TGlobals currently defined.; 1782/// Since globals are created and deleted during execution of the; 1783/// program, we need to update the list of globals every time we; 1784/// execute this method. However, when calling this function in; 1785/// a (tight) loop where no interpreter symbols will be created; 1786/// you can set load=kFALSE (default).; 1787 ; 1788TCollection *TROOT::GetListOfGlobals(Bool_t load); 1789{; 1790 if (!fGlobals) {; 1791 fGlobals = new TListOfDataMembers(nullptr, TDictionary::EMemberSelection::kAlsoUsingDecls);; 1792 // We add to the list the ""funcky-fake"" globals.; 1793 ; 1794 // provide special functor for gROOT, while ROOT::GetROOT() does not return reference; 1795 TGlobalMappedFunction::MakeFunctor(""gROOT"", ""TROOT*"", ROOT::GetROOT, [] {; 1796 ROOT::GetROOT();; 1797 return (void *)&ROOT::Internal::gROOTLocal;; 1798 });; 1799 ; 1800 TGlobalMappedFunction::MakeFunctor(""gPad"", ""TVirtualPad*"", TVirtualPad::Pad);; 1801 TGlobalMappedFunction::MakeFunctor(""gVirtualX"", ""TVirtualX*"", TVirtualX::Instance);; 1802 TGlobalMappedFunction::MakeFunctor(""gDirectory"", ""TDirectory*"", TDirectory::CurrentDirectory);; 1803 ; 1804 // Don't let TGlobalMappedFunction delete our globals, now that we take them.; 1805 fGlobals->AddAll(&TGlobalMappedFuncti",MatchSource.WIKI,doc/v632/TROOT_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/TROOT_8cxx_source.html
https://root.cern/doc/v632/TROOT_8cxx_source.html:68710,Performance,load,load,68710,"; // Refresh the list of enums.; 1765 }; 1766 return fEnums.load();; 1767}; 1768 ; 1769////////////////////////////////////////////////////////////////////////////////; 1770 ; 1771TCollection *TROOT::GetListOfFunctionTemplates(); 1772{; 1773 R__LOCKGUARD(gROOTMutex);; 1774 if(!fFuncTemplate) {; 1775 fFuncTemplate = new TListOfFunctionTemplates(nullptr);; 1776 }; 1777 return fFuncTemplate;; 1778}; 1779 ; 1780////////////////////////////////////////////////////////////////////////////////; 1781/// Return list containing the TGlobals currently defined.; 1782/// Since globals are created and deleted during execution of the; 1783/// program, we need to update the list of globals every time we; 1784/// execute this method. However, when calling this function in; 1785/// a (tight) loop where no interpreter symbols will be created; 1786/// you can set load=kFALSE (default).; 1787 ; 1788TCollection *TROOT::GetListOfGlobals(Bool_t load); 1789{; 1790 if (!fGlobals) {; 1791 fGlobals = new TListOfDataMembers(nullptr, TDictionary::EMemberSelection::kAlsoUsingDecls);; 1792 // We add to the list the ""funcky-fake"" globals.; 1793 ; 1794 // provide special functor for gROOT, while ROOT::GetROOT() does not return reference; 1795 TGlobalMappedFunction::MakeFunctor(""gROOT"", ""TROOT*"", ROOT::GetROOT, [] {; 1796 ROOT::GetROOT();; 1797 return (void *)&ROOT::Internal::gROOTLocal;; 1798 });; 1799 ; 1800 TGlobalMappedFunction::MakeFunctor(""gPad"", ""TVirtualPad*"", TVirtualPad::Pad);; 1801 TGlobalMappedFunction::MakeFunctor(""gVirtualX"", ""TVirtualX*"", TVirtualX::Instance);; 1802 TGlobalMappedFunction::MakeFunctor(""gDirectory"", ""TDirectory*"", TDirectory::CurrentDirectory);; 1803 ; 1804 // Don't let TGlobalMappedFunction delete our globals, now that we take them.; 1805 fGlobals->AddAll(&TGlobalMappedFunction::GetEarlyRegisteredGlobals());; 1806 TGlobalMappedFunction::GetEarlyRegisteredGlobals().SetOwner(kFALSE);; 1807 TGlobalMappedFunction::GetEarlyRegisteredGlobals().Clear();; 1808 }; 1809 ; 1810 if ",MatchSource.WIKI,doc/v632/TROOT_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/TROOT_8cxx_source.html
https://root.cern/doc/v632/TROOT_8cxx_source.html:69874,Performance,load,load,69874,"vide special functor for gROOT, while ROOT::GetROOT() does not return reference; 1795 TGlobalMappedFunction::MakeFunctor(""gROOT"", ""TROOT*"", ROOT::GetROOT, [] {; 1796 ROOT::GetROOT();; 1797 return (void *)&ROOT::Internal::gROOTLocal;; 1798 });; 1799 ; 1800 TGlobalMappedFunction::MakeFunctor(""gPad"", ""TVirtualPad*"", TVirtualPad::Pad);; 1801 TGlobalMappedFunction::MakeFunctor(""gVirtualX"", ""TVirtualX*"", TVirtualX::Instance);; 1802 TGlobalMappedFunction::MakeFunctor(""gDirectory"", ""TDirectory*"", TDirectory::CurrentDirectory);; 1803 ; 1804 // Don't let TGlobalMappedFunction delete our globals, now that we take them.; 1805 fGlobals->AddAll(&TGlobalMappedFunction::GetEarlyRegisteredGlobals());; 1806 TGlobalMappedFunction::GetEarlyRegisteredGlobals().SetOwner(kFALSE);; 1807 TGlobalMappedFunction::GetEarlyRegisteredGlobals().Clear();; 1808 }; 1809 ; 1810 if (!fInterpreter); 1811 Fatal(""GetListOfGlobals"", ""fInterpreter not initialized"");; 1812 ; 1813 if (load) fGlobals->Load();; 1814 ; 1815 return fGlobals;; 1816}; 1817 ; 1818////////////////////////////////////////////////////////////////////////////////; 1819/// Return list containing the TFunctions currently defined.; 1820/// Since functions are created and deleted during execution of the; 1821/// program, we need to update the list of functions every time we; 1822/// execute this method. However, when calling this function in; 1823/// a (tight) loop where no interpreter symbols will be created; 1824/// you can set load=kFALSE (default).; 1825 ; 1826TCollection *TROOT::GetListOfGlobalFunctions(Bool_t load); 1827{; 1828 R__LOCKGUARD(gROOTMutex);; 1829 ; 1830 if (!fGlobalFunctions) {; 1831 fGlobalFunctions = new TListOfFunctions(nullptr);; 1832 }; 1833 ; 1834 if (!fInterpreter); 1835 Fatal(""GetListOfGlobalFunctions"", ""fInterpreter not initialized"");; 1836 ; 1837 // A thread that calls with load==true and a thread that calls with load==false; 1838 // will conflict here (the load==true will be updating the list while the; 1839 //",MatchSource.WIKI,doc/v632/TROOT_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/TROOT_8cxx_source.html
https://root.cern/doc/v632/TROOT_8cxx_source.html:70398,Performance,load,load,70398,"802 TGlobalMappedFunction::MakeFunctor(""gDirectory"", ""TDirectory*"", TDirectory::CurrentDirectory);; 1803 ; 1804 // Don't let TGlobalMappedFunction delete our globals, now that we take them.; 1805 fGlobals->AddAll(&TGlobalMappedFunction::GetEarlyRegisteredGlobals());; 1806 TGlobalMappedFunction::GetEarlyRegisteredGlobals().SetOwner(kFALSE);; 1807 TGlobalMappedFunction::GetEarlyRegisteredGlobals().Clear();; 1808 }; 1809 ; 1810 if (!fInterpreter); 1811 Fatal(""GetListOfGlobals"", ""fInterpreter not initialized"");; 1812 ; 1813 if (load) fGlobals->Load();; 1814 ; 1815 return fGlobals;; 1816}; 1817 ; 1818////////////////////////////////////////////////////////////////////////////////; 1819/// Return list containing the TFunctions currently defined.; 1820/// Since functions are created and deleted during execution of the; 1821/// program, we need to update the list of functions every time we; 1822/// execute this method. However, when calling this function in; 1823/// a (tight) loop where no interpreter symbols will be created; 1824/// you can set load=kFALSE (default).; 1825 ; 1826TCollection *TROOT::GetListOfGlobalFunctions(Bool_t load); 1827{; 1828 R__LOCKGUARD(gROOTMutex);; 1829 ; 1830 if (!fGlobalFunctions) {; 1831 fGlobalFunctions = new TListOfFunctions(nullptr);; 1832 }; 1833 ; 1834 if (!fInterpreter); 1835 Fatal(""GetListOfGlobalFunctions"", ""fInterpreter not initialized"");; 1836 ; 1837 // A thread that calls with load==true and a thread that calls with load==false; 1838 // will conflict here (the load==true will be updating the list while the; 1839 // other is reading it). To solve the problem, we could use a read-write lock; 1840 // inside the list itself.; 1841 if (load) fGlobalFunctions->Load();; 1842 ; 1843 return fGlobalFunctions;; 1844}; 1845 ; 1846////////////////////////////////////////////////////////////////////////////////; 1847/// Return a dynamic list giving access to all TDataTypes (typedefs); 1848/// currently defined.; 1849///; 1850/// The list is popul",MatchSource.WIKI,doc/v632/TROOT_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/TROOT_8cxx_source.html
https://root.cern/doc/v632/TROOT_8cxx_source.html:70485,Performance,load,load,70485,"LSE);; 1807 TGlobalMappedFunction::GetEarlyRegisteredGlobals().Clear();; 1808 }; 1809 ; 1810 if (!fInterpreter); 1811 Fatal(""GetListOfGlobals"", ""fInterpreter not initialized"");; 1812 ; 1813 if (load) fGlobals->Load();; 1814 ; 1815 return fGlobals;; 1816}; 1817 ; 1818////////////////////////////////////////////////////////////////////////////////; 1819/// Return list containing the TFunctions currently defined.; 1820/// Since functions are created and deleted during execution of the; 1821/// program, we need to update the list of functions every time we; 1822/// execute this method. However, when calling this function in; 1823/// a (tight) loop where no interpreter symbols will be created; 1824/// you can set load=kFALSE (default).; 1825 ; 1826TCollection *TROOT::GetListOfGlobalFunctions(Bool_t load); 1827{; 1828 R__LOCKGUARD(gROOTMutex);; 1829 ; 1830 if (!fGlobalFunctions) {; 1831 fGlobalFunctions = new TListOfFunctions(nullptr);; 1832 }; 1833 ; 1834 if (!fInterpreter); 1835 Fatal(""GetListOfGlobalFunctions"", ""fInterpreter not initialized"");; 1836 ; 1837 // A thread that calls with load==true and a thread that calls with load==false; 1838 // will conflict here (the load==true will be updating the list while the; 1839 // other is reading it). To solve the problem, we could use a read-write lock; 1840 // inside the list itself.; 1841 if (load) fGlobalFunctions->Load();; 1842 ; 1843 return fGlobalFunctions;; 1844}; 1845 ; 1846////////////////////////////////////////////////////////////////////////////////; 1847/// Return a dynamic list giving access to all TDataTypes (typedefs); 1848/// currently defined.; 1849///; 1850/// The list is populated on demand. Calling; 1851/// ~~~ {.cpp}; 1852/// gROOT->GetListOfTypes()->FindObject(nameoftype);; 1853/// ~~~; 1854/// will return the TDataType corresponding to 'nameoftype'. If the; 1855/// TDataType is not already in the list itself and the type does exist,; 1856/// a new TDataType will be created and added to the list.; 1857/",MatchSource.WIKI,doc/v632/TROOT_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/TROOT_8cxx_source.html
https://root.cern/doc/v632/TROOT_8cxx_source.html:70778,Performance,load,load,70778,"LSE);; 1807 TGlobalMappedFunction::GetEarlyRegisteredGlobals().Clear();; 1808 }; 1809 ; 1810 if (!fInterpreter); 1811 Fatal(""GetListOfGlobals"", ""fInterpreter not initialized"");; 1812 ; 1813 if (load) fGlobals->Load();; 1814 ; 1815 return fGlobals;; 1816}; 1817 ; 1818////////////////////////////////////////////////////////////////////////////////; 1819/// Return list containing the TFunctions currently defined.; 1820/// Since functions are created and deleted during execution of the; 1821/// program, we need to update the list of functions every time we; 1822/// execute this method. However, when calling this function in; 1823/// a (tight) loop where no interpreter symbols will be created; 1824/// you can set load=kFALSE (default).; 1825 ; 1826TCollection *TROOT::GetListOfGlobalFunctions(Bool_t load); 1827{; 1828 R__LOCKGUARD(gROOTMutex);; 1829 ; 1830 if (!fGlobalFunctions) {; 1831 fGlobalFunctions = new TListOfFunctions(nullptr);; 1832 }; 1833 ; 1834 if (!fInterpreter); 1835 Fatal(""GetListOfGlobalFunctions"", ""fInterpreter not initialized"");; 1836 ; 1837 // A thread that calls with load==true and a thread that calls with load==false; 1838 // will conflict here (the load==true will be updating the list while the; 1839 // other is reading it). To solve the problem, we could use a read-write lock; 1840 // inside the list itself.; 1841 if (load) fGlobalFunctions->Load();; 1842 ; 1843 return fGlobalFunctions;; 1844}; 1845 ; 1846////////////////////////////////////////////////////////////////////////////////; 1847/// Return a dynamic list giving access to all TDataTypes (typedefs); 1848/// currently defined.; 1849///; 1850/// The list is populated on demand. Calling; 1851/// ~~~ {.cpp}; 1852/// gROOT->GetListOfTypes()->FindObject(nameoftype);; 1853/// ~~~; 1854/// will return the TDataType corresponding to 'nameoftype'. If the; 1855/// TDataType is not already in the list itself and the type does exist,; 1856/// a new TDataType will be created and added to the list.; 1857/",MatchSource.WIKI,doc/v632/TROOT_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/TROOT_8cxx_source.html
https://root.cern/doc/v632/TROOT_8cxx_source.html:70818,Performance,load,load,70818,"LSE);; 1807 TGlobalMappedFunction::GetEarlyRegisteredGlobals().Clear();; 1808 }; 1809 ; 1810 if (!fInterpreter); 1811 Fatal(""GetListOfGlobals"", ""fInterpreter not initialized"");; 1812 ; 1813 if (load) fGlobals->Load();; 1814 ; 1815 return fGlobals;; 1816}; 1817 ; 1818////////////////////////////////////////////////////////////////////////////////; 1819/// Return list containing the TFunctions currently defined.; 1820/// Since functions are created and deleted during execution of the; 1821/// program, we need to update the list of functions every time we; 1822/// execute this method. However, when calling this function in; 1823/// a (tight) loop where no interpreter symbols will be created; 1824/// you can set load=kFALSE (default).; 1825 ; 1826TCollection *TROOT::GetListOfGlobalFunctions(Bool_t load); 1827{; 1828 R__LOCKGUARD(gROOTMutex);; 1829 ; 1830 if (!fGlobalFunctions) {; 1831 fGlobalFunctions = new TListOfFunctions(nullptr);; 1832 }; 1833 ; 1834 if (!fInterpreter); 1835 Fatal(""GetListOfGlobalFunctions"", ""fInterpreter not initialized"");; 1836 ; 1837 // A thread that calls with load==true and a thread that calls with load==false; 1838 // will conflict here (the load==true will be updating the list while the; 1839 // other is reading it). To solve the problem, we could use a read-write lock; 1840 // inside the list itself.; 1841 if (load) fGlobalFunctions->Load();; 1842 ; 1843 return fGlobalFunctions;; 1844}; 1845 ; 1846////////////////////////////////////////////////////////////////////////////////; 1847/// Return a dynamic list giving access to all TDataTypes (typedefs); 1848/// currently defined.; 1849///; 1850/// The list is populated on demand. Calling; 1851/// ~~~ {.cpp}; 1852/// gROOT->GetListOfTypes()->FindObject(nameoftype);; 1853/// ~~~; 1854/// will return the TDataType corresponding to 'nameoftype'. If the; 1855/// TDataType is not already in the list itself and the type does exist,; 1856/// a new TDataType will be created and added to the list.; 1857/",MatchSource.WIKI,doc/v632/TROOT_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/TROOT_8cxx_source.html
https://root.cern/doc/v632/TROOT_8cxx_source.html:70863,Performance,load,load,70863,"LSE);; 1807 TGlobalMappedFunction::GetEarlyRegisteredGlobals().Clear();; 1808 }; 1809 ; 1810 if (!fInterpreter); 1811 Fatal(""GetListOfGlobals"", ""fInterpreter not initialized"");; 1812 ; 1813 if (load) fGlobals->Load();; 1814 ; 1815 return fGlobals;; 1816}; 1817 ; 1818////////////////////////////////////////////////////////////////////////////////; 1819/// Return list containing the TFunctions currently defined.; 1820/// Since functions are created and deleted during execution of the; 1821/// program, we need to update the list of functions every time we; 1822/// execute this method. However, when calling this function in; 1823/// a (tight) loop where no interpreter symbols will be created; 1824/// you can set load=kFALSE (default).; 1825 ; 1826TCollection *TROOT::GetListOfGlobalFunctions(Bool_t load); 1827{; 1828 R__LOCKGUARD(gROOTMutex);; 1829 ; 1830 if (!fGlobalFunctions) {; 1831 fGlobalFunctions = new TListOfFunctions(nullptr);; 1832 }; 1833 ; 1834 if (!fInterpreter); 1835 Fatal(""GetListOfGlobalFunctions"", ""fInterpreter not initialized"");; 1836 ; 1837 // A thread that calls with load==true and a thread that calls with load==false; 1838 // will conflict here (the load==true will be updating the list while the; 1839 // other is reading it). To solve the problem, we could use a read-write lock; 1840 // inside the list itself.; 1841 if (load) fGlobalFunctions->Load();; 1842 ; 1843 return fGlobalFunctions;; 1844}; 1845 ; 1846////////////////////////////////////////////////////////////////////////////////; 1847/// Return a dynamic list giving access to all TDataTypes (typedefs); 1848/// currently defined.; 1849///; 1850/// The list is populated on demand. Calling; 1851/// ~~~ {.cpp}; 1852/// gROOT->GetListOfTypes()->FindObject(nameoftype);; 1853/// ~~~; 1854/// will return the TDataType corresponding to 'nameoftype'. If the; 1855/// TDataType is not already in the list itself and the type does exist,; 1856/// a new TDataType will be created and added to the list.; 1857/",MatchSource.WIKI,doc/v632/TROOT_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/TROOT_8cxx_source.html
https://root.cern/doc/v632/TROOT_8cxx_source.html:71037,Performance,load,load,71037," 1821/// program, we need to update the list of functions every time we; 1822/// execute this method. However, when calling this function in; 1823/// a (tight) loop where no interpreter symbols will be created; 1824/// you can set load=kFALSE (default).; 1825 ; 1826TCollection *TROOT::GetListOfGlobalFunctions(Bool_t load); 1827{; 1828 R__LOCKGUARD(gROOTMutex);; 1829 ; 1830 if (!fGlobalFunctions) {; 1831 fGlobalFunctions = new TListOfFunctions(nullptr);; 1832 }; 1833 ; 1834 if (!fInterpreter); 1835 Fatal(""GetListOfGlobalFunctions"", ""fInterpreter not initialized"");; 1836 ; 1837 // A thread that calls with load==true and a thread that calls with load==false; 1838 // will conflict here (the load==true will be updating the list while the; 1839 // other is reading it). To solve the problem, we could use a read-write lock; 1840 // inside the list itself.; 1841 if (load) fGlobalFunctions->Load();; 1842 ; 1843 return fGlobalFunctions;; 1844}; 1845 ; 1846////////////////////////////////////////////////////////////////////////////////; 1847/// Return a dynamic list giving access to all TDataTypes (typedefs); 1848/// currently defined.; 1849///; 1850/// The list is populated on demand. Calling; 1851/// ~~~ {.cpp}; 1852/// gROOT->GetListOfTypes()->FindObject(nameoftype);; 1853/// ~~~; 1854/// will return the TDataType corresponding to 'nameoftype'. If the; 1855/// TDataType is not already in the list itself and the type does exist,; 1856/// a new TDataType will be created and added to the list.; 1857///; 1858/// Calling; 1859/// ~~~ {.cpp}; 1860/// gROOT->GetListOfTypes()->ls(); // or Print(); 1861/// ~~~; 1862/// list only the typedefs that have been previously accessed through the; 1863/// list (plus the builtins types).; 1864 ; 1865TCollection *TROOT::GetListOfTypes(Bool_t /* load */); 1866{; 1867 if (!fInterpreter); 1868 Fatal(""GetListOfTypes"", ""fInterpreter not initialized"");; 1869 ; 1870 return fTypes;; 1871}; 1872 ; 1873////////////////////////////////////////////////////",MatchSource.WIKI,doc/v632/TROOT_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/TROOT_8cxx_source.html
https://root.cern/doc/v632/TROOT_8cxx_source.html:71964,Performance,load,load,71964,");; 1842 ; 1843 return fGlobalFunctions;; 1844}; 1845 ; 1846////////////////////////////////////////////////////////////////////////////////; 1847/// Return a dynamic list giving access to all TDataTypes (typedefs); 1848/// currently defined.; 1849///; 1850/// The list is populated on demand. Calling; 1851/// ~~~ {.cpp}; 1852/// gROOT->GetListOfTypes()->FindObject(nameoftype);; 1853/// ~~~; 1854/// will return the TDataType corresponding to 'nameoftype'. If the; 1855/// TDataType is not already in the list itself and the type does exist,; 1856/// a new TDataType will be created and added to the list.; 1857///; 1858/// Calling; 1859/// ~~~ {.cpp}; 1860/// gROOT->GetListOfTypes()->ls(); // or Print(); 1861/// ~~~; 1862/// list only the typedefs that have been previously accessed through the; 1863/// list (plus the builtins types).; 1864 ; 1865TCollection *TROOT::GetListOfTypes(Bool_t /* load */); 1866{; 1867 if (!fInterpreter); 1868 Fatal(""GetListOfTypes"", ""fInterpreter not initialized"");; 1869 ; 1870 return fTypes;; 1871}; 1872 ; 1873////////////////////////////////////////////////////////////////////////////////; 1874/// Get number of classes.; 1875 ; 1876Int_t TROOT::GetNclasses() const; 1877{; 1878 return fClasses->GetSize();; 1879}; 1880 ; 1881////////////////////////////////////////////////////////////////////////////////; 1882/// Get number of types.; 1883 ; 1884Int_t TROOT::GetNtypes() const; 1885{; 1886 return fTypes->GetSize();; 1887}; 1888 ; 1889////////////////////////////////////////////////////////////////////////////////; 1890/// Execute command when system has been idle for idleTimeInSec seconds.; 1891 ; 1892void TROOT::Idle(UInt_t idleTimeInSec, const char *command); 1893{; 1894 if (!fApplication.load()); 1895 TApplication::CreateApplication();; 1896 ; 1897 if (idleTimeInSec <= 0); 1898 (*fApplication).RemoveIdleTimer();; 1899 else; 1900 (*fApplication).SetIdleTimer(idleTimeInSec, command);; 1901}; 1902 ; 1903///////////////////////////////////////////",MatchSource.WIKI,doc/v632/TROOT_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/TROOT_8cxx_source.html
https://root.cern/doc/v632/TROOT_8cxx_source.html:72807,Performance,load,load,72807," the; 1863/// list (plus the builtins types).; 1864 ; 1865TCollection *TROOT::GetListOfTypes(Bool_t /* load */); 1866{; 1867 if (!fInterpreter); 1868 Fatal(""GetListOfTypes"", ""fInterpreter not initialized"");; 1869 ; 1870 return fTypes;; 1871}; 1872 ; 1873////////////////////////////////////////////////////////////////////////////////; 1874/// Get number of classes.; 1875 ; 1876Int_t TROOT::GetNclasses() const; 1877{; 1878 return fClasses->GetSize();; 1879}; 1880 ; 1881////////////////////////////////////////////////////////////////////////////////; 1882/// Get number of types.; 1883 ; 1884Int_t TROOT::GetNtypes() const; 1885{; 1886 return fTypes->GetSize();; 1887}; 1888 ; 1889////////////////////////////////////////////////////////////////////////////////; 1890/// Execute command when system has been idle for idleTimeInSec seconds.; 1891 ; 1892void TROOT::Idle(UInt_t idleTimeInSec, const char *command); 1893{; 1894 if (!fApplication.load()); 1895 TApplication::CreateApplication();; 1896 ; 1897 if (idleTimeInSec <= 0); 1898 (*fApplication).RemoveIdleTimer();; 1899 else; 1900 (*fApplication).SetIdleTimer(idleTimeInSec, command);; 1901}; 1902 ; 1903////////////////////////////////////////////////////////////////////////////////; 1904/// Check whether className is a known class, and only autoload; 1905/// if we can. Helper function for TROOT::IgnoreInclude().; 1906 ; 1907static TClass* R__GetClassIfKnown(const char* className); 1908{; 1909 // Check whether the class is available for auto-loading first:; 1910 const char* libsToLoad = gInterpreter->GetClassSharedLibs(className);; 1911 TClass* cla = nullptr;; 1912 if (libsToLoad) {; 1913 // trigger autoload, and only create TClass in this case.; 1914 return TClass::GetClass(className);; 1915 } else if (gROOT->GetListOfClasses(); 1916 && (cla = (TClass*)gROOT->GetListOfClasses()->FindObject(className))) {; 1917 // cla assigned in if statement; 1918 } else if (gClassTable->FindObject(className)) {; 1919 return TClass::GetClas",MatchSource.WIKI,doc/v632/TROOT_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/TROOT_8cxx_source.html
https://root.cern/doc/v632/TROOT_8cxx_source.html:73369,Performance,load,loading,73369,"///////; 1882/// Get number of types.; 1883 ; 1884Int_t TROOT::GetNtypes() const; 1885{; 1886 return fTypes->GetSize();; 1887}; 1888 ; 1889////////////////////////////////////////////////////////////////////////////////; 1890/// Execute command when system has been idle for idleTimeInSec seconds.; 1891 ; 1892void TROOT::Idle(UInt_t idleTimeInSec, const char *command); 1893{; 1894 if (!fApplication.load()); 1895 TApplication::CreateApplication();; 1896 ; 1897 if (idleTimeInSec <= 0); 1898 (*fApplication).RemoveIdleTimer();; 1899 else; 1900 (*fApplication).SetIdleTimer(idleTimeInSec, command);; 1901}; 1902 ; 1903////////////////////////////////////////////////////////////////////////////////; 1904/// Check whether className is a known class, and only autoload; 1905/// if we can. Helper function for TROOT::IgnoreInclude().; 1906 ; 1907static TClass* R__GetClassIfKnown(const char* className); 1908{; 1909 // Check whether the class is available for auto-loading first:; 1910 const char* libsToLoad = gInterpreter->GetClassSharedLibs(className);; 1911 TClass* cla = nullptr;; 1912 if (libsToLoad) {; 1913 // trigger autoload, and only create TClass in this case.; 1914 return TClass::GetClass(className);; 1915 } else if (gROOT->GetListOfClasses(); 1916 && (cla = (TClass*)gROOT->GetListOfClasses()->FindObject(className))) {; 1917 // cla assigned in if statement; 1918 } else if (gClassTable->FindObject(className)) {; 1919 return TClass::GetClass(className);; 1920 }; 1921 return cla;; 1922}; 1923 ; 1924////////////////////////////////////////////////////////////////////////////////; 1925/// Return 1 if the name of the given include file corresponds to a class that; 1926/// is known to ROOT, e.g. ""TLorentzVector.h"" versus TLorentzVector.; 1927 ; 1928Int_t TROOT::IgnoreInclude(const char *fname, const char * /*expandedfname*/); 1929{; 1930 if (fname == nullptr) return 0;; 1931 ; 1932 TString stem(fname);; 1933 // Remove extension if any, ignore files with extension not being .h*; 19",MatchSource.WIKI,doc/v632/TROOT_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/TROOT_8cxx_source.html
https://root.cern/doc/v632/TROOT_8cxx_source.html:79816,Performance,load,load,79816,"; 2045#endif; 2046 TObject::SetObjectStat(gEnv->GetValue(""Root.ObjectStat"", 0));; 2047 }; 2048}; 2049 ; 2050////////////////////////////////////////////////////////////////////////////////; 2051/// Load and initialize thread library.; 2052 ; 2053void TROOT::InitThreads(); 2054{; 2055 if (gEnv->GetValue(""Root.UseThreads"", 0) || gEnv->GetValue(""Root.EnableThreadSafety"", 0)) {; 2056 ROOT::EnableThreadSafety();; 2057 }; 2058}; 2059 ; 2060////////////////////////////////////////////////////////////////////////////////; 2061/// Initialize the interpreter. Should be called only after main(),; 2062/// to make sure LLVM/Clang is fully initialized.; 2063 ; 2064void TROOT::InitInterpreter(); 2065{; 2066 // usedToIdentifyRootClingByDlSym is available when TROOT is part of; 2067 // rootcling.; 2068 if (!dlsym(RTLD_DEFAULT, ""usedToIdentifyRootClingByDlSym""); 2069 && !dlsym(RTLD_DEFAULT, ""usedToIdentifyStaticRoot"")) {; 2070 char *libRIO = gSystem->DynamicPathName(""libRIO"");; 2071 void *libRIOHandle = dlopen(libRIO, RTLD_NOW|RTLD_GLOBAL);; 2072 delete [] libRIO;; 2073 if (!libRIOHandle) {; 2074 TString err = dlerror();; 2075 fprintf(stderr, ""Fatal in <TROOT::InitInterpreter>: cannot load library %s\n"", err.Data());; 2076 exit(1);; 2077 }; 2078 ; 2079 char *libcling = gSystem->DynamicPathName(""libCling"");; 2080 gInterpreterLib = dlopen(libcling, RTLD_LAZY|RTLD_LOCAL);; 2081 delete [] libcling;; 2082 ; 2083 if (!gInterpreterLib) {; 2084 TString err = dlerror();; 2085 fprintf(stderr, ""Fatal in <TROOT::InitInterpreter>: cannot load library %s\n"", err.Data());; 2086 exit(1);; 2087 }; 2088 dlerror(); // reset error message; 2089 } else {; 2090 gInterpreterLib = RTLD_DEFAULT;; 2091 }; 2092 CreateInterpreter_t *CreateInterpreter = (CreateInterpreter_t*) dlsym(gInterpreterLib, ""CreateInterpreter"");; 2093 if (!CreateInterpreter) {; 2094 TString err = dlerror();; 2095 fprintf(stderr, ""Fatal in <TROOT::InitInterpreter>: cannot load symbol %s\n"", err.Data());; 2096 exit(1);; 2097 }; 2098 // Sch",MatchSource.WIKI,doc/v632/TROOT_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/TROOT_8cxx_source.html
https://root.cern/doc/v632/TROOT_8cxx_source.html:80163,Performance,load,load,80163,"ROOT::EnableThreadSafety();; 2057 }; 2058}; 2059 ; 2060////////////////////////////////////////////////////////////////////////////////; 2061/// Initialize the interpreter. Should be called only after main(),; 2062/// to make sure LLVM/Clang is fully initialized.; 2063 ; 2064void TROOT::InitInterpreter(); 2065{; 2066 // usedToIdentifyRootClingByDlSym is available when TROOT is part of; 2067 // rootcling.; 2068 if (!dlsym(RTLD_DEFAULT, ""usedToIdentifyRootClingByDlSym""); 2069 && !dlsym(RTLD_DEFAULT, ""usedToIdentifyStaticRoot"")) {; 2070 char *libRIO = gSystem->DynamicPathName(""libRIO"");; 2071 void *libRIOHandle = dlopen(libRIO, RTLD_NOW|RTLD_GLOBAL);; 2072 delete [] libRIO;; 2073 if (!libRIOHandle) {; 2074 TString err = dlerror();; 2075 fprintf(stderr, ""Fatal in <TROOT::InitInterpreter>: cannot load library %s\n"", err.Data());; 2076 exit(1);; 2077 }; 2078 ; 2079 char *libcling = gSystem->DynamicPathName(""libCling"");; 2080 gInterpreterLib = dlopen(libcling, RTLD_LAZY|RTLD_LOCAL);; 2081 delete [] libcling;; 2082 ; 2083 if (!gInterpreterLib) {; 2084 TString err = dlerror();; 2085 fprintf(stderr, ""Fatal in <TROOT::InitInterpreter>: cannot load library %s\n"", err.Data());; 2086 exit(1);; 2087 }; 2088 dlerror(); // reset error message; 2089 } else {; 2090 gInterpreterLib = RTLD_DEFAULT;; 2091 }; 2092 CreateInterpreter_t *CreateInterpreter = (CreateInterpreter_t*) dlsym(gInterpreterLib, ""CreateInterpreter"");; 2093 if (!CreateInterpreter) {; 2094 TString err = dlerror();; 2095 fprintf(stderr, ""Fatal in <TROOT::InitInterpreter>: cannot load symbol %s\n"", err.Data());; 2096 exit(1);; 2097 }; 2098 // Schedule the destruction of TROOT.; 2099 atexit(at_exit_of_TROOT);; 2100 ; 2101 gDestroyInterpreter = (DestroyInterpreter_t*) dlsym(gInterpreterLib, ""DestroyInterpreter"");; 2102 if (!gDestroyInterpreter) {; 2103 TString err = dlerror();; 2104 fprintf(stderr, ""Fatal in <TROOT::InitInterpreter>: cannot load symbol %s\n"", err.Data());; 2105 exit(1);; 2106 }; 2107 ; 2108 const char *inter",MatchSource.WIKI,doc/v632/TROOT_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/TROOT_8cxx_source.html
https://root.cern/doc/v632/TROOT_8cxx_source.html:80563,Performance,load,load,80563,"OOT is part of; 2067 // rootcling.; 2068 if (!dlsym(RTLD_DEFAULT, ""usedToIdentifyRootClingByDlSym""); 2069 && !dlsym(RTLD_DEFAULT, ""usedToIdentifyStaticRoot"")) {; 2070 char *libRIO = gSystem->DynamicPathName(""libRIO"");; 2071 void *libRIOHandle = dlopen(libRIO, RTLD_NOW|RTLD_GLOBAL);; 2072 delete [] libRIO;; 2073 if (!libRIOHandle) {; 2074 TString err = dlerror();; 2075 fprintf(stderr, ""Fatal in <TROOT::InitInterpreter>: cannot load library %s\n"", err.Data());; 2076 exit(1);; 2077 }; 2078 ; 2079 char *libcling = gSystem->DynamicPathName(""libCling"");; 2080 gInterpreterLib = dlopen(libcling, RTLD_LAZY|RTLD_LOCAL);; 2081 delete [] libcling;; 2082 ; 2083 if (!gInterpreterLib) {; 2084 TString err = dlerror();; 2085 fprintf(stderr, ""Fatal in <TROOT::InitInterpreter>: cannot load library %s\n"", err.Data());; 2086 exit(1);; 2087 }; 2088 dlerror(); // reset error message; 2089 } else {; 2090 gInterpreterLib = RTLD_DEFAULT;; 2091 }; 2092 CreateInterpreter_t *CreateInterpreter = (CreateInterpreter_t*) dlsym(gInterpreterLib, ""CreateInterpreter"");; 2093 if (!CreateInterpreter) {; 2094 TString err = dlerror();; 2095 fprintf(stderr, ""Fatal in <TROOT::InitInterpreter>: cannot load symbol %s\n"", err.Data());; 2096 exit(1);; 2097 }; 2098 // Schedule the destruction of TROOT.; 2099 atexit(at_exit_of_TROOT);; 2100 ; 2101 gDestroyInterpreter = (DestroyInterpreter_t*) dlsym(gInterpreterLib, ""DestroyInterpreter"");; 2102 if (!gDestroyInterpreter) {; 2103 TString err = dlerror();; 2104 fprintf(stderr, ""Fatal in <TROOT::InitInterpreter>: cannot load symbol %s\n"", err.Data());; 2105 exit(1);; 2106 }; 2107 ; 2108 const char *interpArgs[] = {; 2109#ifdef NDEBUG; 2110 ""-DNDEBUG"",; 2111#else; 2112 ""-UNDEBUG"",; 2113#endif; 2114#ifdef DEBUG; 2115 ""-DDEBUG"",; 2116#else; 2117 ""-UDEBUG"",; 2118#endif; 2119#ifdef _DEBUG; 2120 ""-D_DEBUG"",; 2121#else; 2122 ""-U_DEBUG"",; 2123#endif; 2124 nullptr};; 2125 ; 2126 fInterpreter = CreateInterpreter(gInterpreterLib, interpArgs);; 2127 ; 2128 fCleanups->Add(fInterpret",MatchSource.WIKI,doc/v632/TROOT_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/TROOT_8cxx_source.html
https://root.cern/doc/v632/TROOT_8cxx_source.html:80929,Performance,load,load,80929,">: cannot load library %s\n"", err.Data());; 2076 exit(1);; 2077 }; 2078 ; 2079 char *libcling = gSystem->DynamicPathName(""libCling"");; 2080 gInterpreterLib = dlopen(libcling, RTLD_LAZY|RTLD_LOCAL);; 2081 delete [] libcling;; 2082 ; 2083 if (!gInterpreterLib) {; 2084 TString err = dlerror();; 2085 fprintf(stderr, ""Fatal in <TROOT::InitInterpreter>: cannot load library %s\n"", err.Data());; 2086 exit(1);; 2087 }; 2088 dlerror(); // reset error message; 2089 } else {; 2090 gInterpreterLib = RTLD_DEFAULT;; 2091 }; 2092 CreateInterpreter_t *CreateInterpreter = (CreateInterpreter_t*) dlsym(gInterpreterLib, ""CreateInterpreter"");; 2093 if (!CreateInterpreter) {; 2094 TString err = dlerror();; 2095 fprintf(stderr, ""Fatal in <TROOT::InitInterpreter>: cannot load symbol %s\n"", err.Data());; 2096 exit(1);; 2097 }; 2098 // Schedule the destruction of TROOT.; 2099 atexit(at_exit_of_TROOT);; 2100 ; 2101 gDestroyInterpreter = (DestroyInterpreter_t*) dlsym(gInterpreterLib, ""DestroyInterpreter"");; 2102 if (!gDestroyInterpreter) {; 2103 TString err = dlerror();; 2104 fprintf(stderr, ""Fatal in <TROOT::InitInterpreter>: cannot load symbol %s\n"", err.Data());; 2105 exit(1);; 2106 }; 2107 ; 2108 const char *interpArgs[] = {; 2109#ifdef NDEBUG; 2110 ""-DNDEBUG"",; 2111#else; 2112 ""-UNDEBUG"",; 2113#endif; 2114#ifdef DEBUG; 2115 ""-DDEBUG"",; 2116#else; 2117 ""-UDEBUG"",; 2118#endif; 2119#ifdef _DEBUG; 2120 ""-D_DEBUG"",; 2121#else; 2122 ""-U_DEBUG"",; 2123#endif; 2124 nullptr};; 2125 ; 2126 fInterpreter = CreateInterpreter(gInterpreterLib, interpArgs);; 2127 ; 2128 fCleanups->Add(fInterpreter);; 2129 fInterpreter->SetBit(kMustCleanup);; 2130 ; 2131 fgRootInit = kTRUE;; 2132 ; 2133 // initialize gClassTable is not already done; 2134 if (!gClassTable); 2135 new TClassTable;; 2136 ; 2137 // Initialize all registered dictionaries.; 2138 for (std::vector<ModuleHeaderInfo_t>::const_iterator; 2139 li = GetModuleHeaderInfoBuffer().begin(),; 2140 le = GetModuleHeaderInfoBuffer().end(); li != le; ++li) {; 2141 /",MatchSource.WIKI,doc/v632/TROOT_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/TROOT_8cxx_source.html
https://root.cern/doc/v632/TROOT_8cxx_source.html:82414,Performance,load,load,82414,"fgRootInit = kTRUE;; 2132 ; 2133 // initialize gClassTable is not already done; 2134 if (!gClassTable); 2135 new TClassTable;; 2136 ; 2137 // Initialize all registered dictionaries.; 2138 for (std::vector<ModuleHeaderInfo_t>::const_iterator; 2139 li = GetModuleHeaderInfoBuffer().begin(),; 2140 le = GetModuleHeaderInfoBuffer().end(); li != le; ++li) {; 2141 // process buffered module registrations; 2142 fInterpreter->RegisterModule(li->fModuleName,; 2143 li->fHeaders,; 2144 li->fIncludePaths,; 2145 li->fPayloadCode,; 2146 li->fFwdDeclCode,; 2147 li->fTriggerFunc,; 2148 li->fFwdNargsToKeepColl,; 2149 li->fClassesHeaders,; 2150 kTRUE /*lateRegistration*/,; 2151 li->fHasCxxModule);; 2152 }; 2153 GetModuleHeaderInfoBuffer().clear();; 2154 ; 2155 fInterpreter->Initialize();; 2156}; 2157 ; 2158////////////////////////////////////////////////////////////////////////////////; 2159/// Helper function used by TClass::GetClass().; 2160/// This function attempts to load the dictionary for 'classname'; 2161/// either from the TClassTable or from the list of generator.; 2162/// If silent is 'true', do not warn about missing dictionary for the class.; 2163/// (typically used for class that are used only for transient members); 2164///; 2165/// The 'requestedname' is expected to be already normalized.; 2166 ; 2167TClass *TROOT::LoadClass(const char *requestedname, Bool_t silent) const; 2168{; 2169 return TClass::LoadClass(requestedname, silent);; 2170}; 2171 ; 2172////////////////////////////////////////////////////////////////////////////////; 2173/// Check if class ""classname"" is known to the interpreter (in fact,; 2174/// this check is not needed anymore, so classname is ignored). If; 2175/// not it will load library ""libname"". If the library couldn't be found with original; 2176/// libname and if the name was not prefixed with lib, try to prefix with ""lib"" and search again.; 2177/// If DynamicPathName still couldn't find the library, return -1.; 2178/// If check is true it will o",MatchSource.WIKI,doc/v632/TROOT_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/TROOT_8cxx_source.html
https://root.cern/doc/v632/TROOT_8cxx_source.html:83167,Performance,load,load,83167,"oBuffer().clear();; 2154 ; 2155 fInterpreter->Initialize();; 2156}; 2157 ; 2158////////////////////////////////////////////////////////////////////////////////; 2159/// Helper function used by TClass::GetClass().; 2160/// This function attempts to load the dictionary for 'classname'; 2161/// either from the TClassTable or from the list of generator.; 2162/// If silent is 'true', do not warn about missing dictionary for the class.; 2163/// (typically used for class that are used only for transient members); 2164///; 2165/// The 'requestedname' is expected to be already normalized.; 2166 ; 2167TClass *TROOT::LoadClass(const char *requestedname, Bool_t silent) const; 2168{; 2169 return TClass::LoadClass(requestedname, silent);; 2170}; 2171 ; 2172////////////////////////////////////////////////////////////////////////////////; 2173/// Check if class ""classname"" is known to the interpreter (in fact,; 2174/// this check is not needed anymore, so classname is ignored). If; 2175/// not it will load library ""libname"". If the library couldn't be found with original; 2176/// libname and if the name was not prefixed with lib, try to prefix with ""lib"" and search again.; 2177/// If DynamicPathName still couldn't find the library, return -1.; 2178/// If check is true it will only check if libname exists and is; 2179/// readable.; 2180/// Returns 0 on successful loading, -1 in case libname does not; 2181/// exist or in case of error and -2 in case of version mismatch.; 2182 ; 2183Int_t TROOT::LoadClass(const char * /*classname*/, const char *libname,; 2184 Bool_t check); 2185{; 2186 TString lib(libname);; 2187 ; 2188 // Check if libname exists in path or not; 2189 if (char *path = gSystem->DynamicPathName(lib, kTRUE)) {; 2190 // If check == true, only check if it exists and if it's readable; 2191 if (check) {; 2192 delete [] path;; 2193 return 0;; 2194 }; 2195 ; 2196 // If check == false, try to load the library; 2197 else {; 2198 int err = gSystem->Load(path, nullptr, kTRUE);; 219",MatchSource.WIKI,doc/v632/TROOT_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/TROOT_8cxx_source.html
https://root.cern/doc/v632/TROOT_8cxx_source.html:83535,Performance,load,loading,83535,"ng dictionary for the class.; 2163/// (typically used for class that are used only for transient members); 2164///; 2165/// The 'requestedname' is expected to be already normalized.; 2166 ; 2167TClass *TROOT::LoadClass(const char *requestedname, Bool_t silent) const; 2168{; 2169 return TClass::LoadClass(requestedname, silent);; 2170}; 2171 ; 2172////////////////////////////////////////////////////////////////////////////////; 2173/// Check if class ""classname"" is known to the interpreter (in fact,; 2174/// this check is not needed anymore, so classname is ignored). If; 2175/// not it will load library ""libname"". If the library couldn't be found with original; 2176/// libname and if the name was not prefixed with lib, try to prefix with ""lib"" and search again.; 2177/// If DynamicPathName still couldn't find the library, return -1.; 2178/// If check is true it will only check if libname exists and is; 2179/// readable.; 2180/// Returns 0 on successful loading, -1 in case libname does not; 2181/// exist or in case of error and -2 in case of version mismatch.; 2182 ; 2183Int_t TROOT::LoadClass(const char * /*classname*/, const char *libname,; 2184 Bool_t check); 2185{; 2186 TString lib(libname);; 2187 ; 2188 // Check if libname exists in path or not; 2189 if (char *path = gSystem->DynamicPathName(lib, kTRUE)) {; 2190 // If check == true, only check if it exists and if it's readable; 2191 if (check) {; 2192 delete [] path;; 2193 return 0;; 2194 }; 2195 ; 2196 // If check == false, try to load the library; 2197 else {; 2198 int err = gSystem->Load(path, nullptr, kTRUE);; 2199 delete [] path;; 2200 ; 2201 // TSystem::Load returns 1 when the library was already loaded, return success in this case.; 2202 if (err == 1); 2203 err = 0;; 2204 return err;; 2205 }; 2206 } else {; 2207 // This is the branch where libname didn't exist; 2208 if (check) {; 2209 FileStat_t stat;; 2210 if (!gSystem->GetPathInfo(libname, stat) && (R_ISREG(stat.fMode) &&; 2211 !gSystem->AccessPathName(libn",MatchSource.WIKI,doc/v632/TROOT_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/TROOT_8cxx_source.html
https://root.cern/doc/v632/TROOT_8cxx_source.html:84079,Performance,load,load,84079,"//////////////////////////////////; 2173/// Check if class ""classname"" is known to the interpreter (in fact,; 2174/// this check is not needed anymore, so classname is ignored). If; 2175/// not it will load library ""libname"". If the library couldn't be found with original; 2176/// libname and if the name was not prefixed with lib, try to prefix with ""lib"" and search again.; 2177/// If DynamicPathName still couldn't find the library, return -1.; 2178/// If check is true it will only check if libname exists and is; 2179/// readable.; 2180/// Returns 0 on successful loading, -1 in case libname does not; 2181/// exist or in case of error and -2 in case of version mismatch.; 2182 ; 2183Int_t TROOT::LoadClass(const char * /*classname*/, const char *libname,; 2184 Bool_t check); 2185{; 2186 TString lib(libname);; 2187 ; 2188 // Check if libname exists in path or not; 2189 if (char *path = gSystem->DynamicPathName(lib, kTRUE)) {; 2190 // If check == true, only check if it exists and if it's readable; 2191 if (check) {; 2192 delete [] path;; 2193 return 0;; 2194 }; 2195 ; 2196 // If check == false, try to load the library; 2197 else {; 2198 int err = gSystem->Load(path, nullptr, kTRUE);; 2199 delete [] path;; 2200 ; 2201 // TSystem::Load returns 1 when the library was already loaded, return success in this case.; 2202 if (err == 1); 2203 err = 0;; 2204 return err;; 2205 }; 2206 } else {; 2207 // This is the branch where libname didn't exist; 2208 if (check) {; 2209 FileStat_t stat;; 2210 if (!gSystem->GetPathInfo(libname, stat) && (R_ISREG(stat.fMode) &&; 2211 !gSystem->AccessPathName(libname, kReadPermission))); 2212 return 0;; 2213 }; 2214 ; 2215 // Take care of user who didn't write the whole name; 2216 if (!lib.BeginsWith(""lib"")) {; 2217 lib = ""lib"" + lib;; 2218 return LoadClass("""", lib.Data(), check);; 2219 }; 2220 }; 2221 ; 2222 // Execution reaches here when library was prefixed with lib, check is false and couldn't find; 2223 // the library name.; 2224 return -1;; 222",MatchSource.WIKI,doc/v632/TROOT_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/TROOT_8cxx_source.html
https://root.cern/doc/v632/TROOT_8cxx_source.html:84253,Performance,load,loaded,84253,"//////////////////////////////////; 2173/// Check if class ""classname"" is known to the interpreter (in fact,; 2174/// this check is not needed anymore, so classname is ignored). If; 2175/// not it will load library ""libname"". If the library couldn't be found with original; 2176/// libname and if the name was not prefixed with lib, try to prefix with ""lib"" and search again.; 2177/// If DynamicPathName still couldn't find the library, return -1.; 2178/// If check is true it will only check if libname exists and is; 2179/// readable.; 2180/// Returns 0 on successful loading, -1 in case libname does not; 2181/// exist or in case of error and -2 in case of version mismatch.; 2182 ; 2183Int_t TROOT::LoadClass(const char * /*classname*/, const char *libname,; 2184 Bool_t check); 2185{; 2186 TString lib(libname);; 2187 ; 2188 // Check if libname exists in path or not; 2189 if (char *path = gSystem->DynamicPathName(lib, kTRUE)) {; 2190 // If check == true, only check if it exists and if it's readable; 2191 if (check) {; 2192 delete [] path;; 2193 return 0;; 2194 }; 2195 ; 2196 // If check == false, try to load the library; 2197 else {; 2198 int err = gSystem->Load(path, nullptr, kTRUE);; 2199 delete [] path;; 2200 ; 2201 // TSystem::Load returns 1 when the library was already loaded, return success in this case.; 2202 if (err == 1); 2203 err = 0;; 2204 return err;; 2205 }; 2206 } else {; 2207 // This is the branch where libname didn't exist; 2208 if (check) {; 2209 FileStat_t stat;; 2210 if (!gSystem->GetPathInfo(libname, stat) && (R_ISREG(stat.fMode) &&; 2211 !gSystem->AccessPathName(libname, kReadPermission))); 2212 return 0;; 2213 }; 2214 ; 2215 // Take care of user who didn't write the whole name; 2216 if (!lib.BeginsWith(""lib"")) {; 2217 lib = ""lib"" + lib;; 2218 return LoadClass("""", lib.Data(), check);; 2219 }; 2220 }; 2221 ; 2222 // Execution reaches here when library was prefixed with lib, check is false and couldn't find; 2223 // the library name.; 2224 return -1;; 222",MatchSource.WIKI,doc/v632/TROOT_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/TROOT_8cxx_source.html
https://root.cern/doc/v632/TROOT_8cxx_source.html:86560,Performance,load,loading,86560,"//////////; 2245/// To list all objects of the application.; 2246/// Loop on all objects created in the ROOT linked lists.; 2247/// Objects may be files and windows or any other object directly; 2248/// attached to the ROOT linked list.; 2249 ; 2250void TROOT::ls(Option_t *option) const; 2251{; 2252// TObject::SetDirLevel();; 2253// GetList()->R__FOR_EACH(TObject,ls)(option);; 2254 TDirectory::ls(option);; 2255}; 2256 ; 2257////////////////////////////////////////////////////////////////////////////////; 2258/// Load a macro in the interpreter's memory. Equivalent to the command line; 2259/// command "".L filename"". If the filename has ""+"" or ""++"" appended; 2260/// the macro will be compiled by ACLiC. The filename must have the format:; 2261/// [path/]macro.C[+|++[g|O]].; 2262/// The possible error codes are defined by TInterpreter::EErrorCode.; 2263/// If check is true it will only check if filename exists and is; 2264/// readable.; 2265/// Returns 0 on successful loading and -1 in case filename does not; 2266/// exist or in case of error.; 2267 ; 2268Int_t TROOT::LoadMacro(const char *filename, int *error, Bool_t check); 2269{; 2270 Int_t err = -1;; 2271 Int_t lerr, *terr;; 2272 if (error); 2273 terr = error;; 2274 else; 2275 terr = &lerr;; 2276 ; 2277 if (fInterpreter) {; 2278 TString aclicMode;; 2279 TString arguments;; 2280 TString io;; 2281 TString fname = gSystem->SplitAclicMode(filename, aclicMode, arguments, io);; 2282 ; 2283 if (arguments.Length()) {; 2284 Warning(""LoadMacro"", ""argument(%s) ignored in %s"", arguments.Data(), GetMacroPath());; 2285 }; 2286 char *mac = gSystem->Which(GetMacroPath(), fname, kReadPermission);; 2287 if (!mac) {; 2288 if (!check); 2289 Error(""LoadMacro"", ""macro %s not found in path %s"", fname.Data(), GetMacroPath());; 2290 *terr = TInterpreter::kFatal;; 2291 } else {; 2292 err = 0;; 2293 if (!check) {; 2294 fname = mac;; 2295 fname += aclicMode;; 2296 fname += io;; 2297 gInterpreter->LoadMacro(fname.Data(), (TInterpreter::EErrorCo",MatchSource.WIKI,doc/v632/TROOT_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/TROOT_8cxx_source.html
https://root.cern/doc/v632/TROOT_8cxx_source.html:90385,Performance,load,load,90385,"5 mh->HandleMessage(id,obj);; 2356 }; 2357}; 2358 ; 2359////////////////////////////////////////////////////////////////////////////////; 2360/// Process interpreter command via TApplication::ProcessLine().; 2361/// On Win32 the line will be processed asynchronously by sending; 2362/// it to the CINT interpreter thread. For explicit synchronous processing; 2363/// use ProcessLineSync(). On non-Win32 platforms there is no difference; 2364/// between ProcessLine() and ProcessLineSync().; 2365/// The possible error codes are defined by TInterpreter::EErrorCode. In; 2366/// particular, error will equal to TInterpreter::kProcessing until the; 2367/// CINT interpreted thread has finished executing the line.; 2368/// Returns the result of the command, cast to a Longptr_t.; 2369 ; 2370Longptr_t TROOT::ProcessLine(const char *line, Int_t *error); 2371{; 2372 TString sline = line;; 2373 sline = sline.Strip(TString::kBoth);; 2374 ; 2375 if (!fApplication.load()); 2376 TApplication::CreateApplication();; 2377 ; 2378 return (*fApplication).ProcessLine(sline, kFALSE, error);; 2379}; 2380 ; 2381////////////////////////////////////////////////////////////////////////////////; 2382/// Process interpreter command via TApplication::ProcessLine().; 2383/// On Win32 the line will be processed synchronously (i.e. it will; 2384/// only return when the CINT interpreter thread has finished executing; 2385/// the line). On non-Win32 platforms there is no difference between; 2386/// ProcessLine() and ProcessLineSync().; 2387/// The possible error codes are defined by TInterpreter::EErrorCode.; 2388/// Returns the result of the command, cast to a Longptr_t.; 2389 ; 2390Longptr_t TROOT::ProcessLineSync(const char *line, Int_t *error); 2391{; 2392 TString sline = line;; 2393 sline = sline.Strip(TString::kBoth);; 2394 ; 2395 if (!fApplication.load()); 2396 TApplication::CreateApplication();; 2397 ; 2398 return (*fApplication).ProcessLine(sline, kTRUE, error);; 2399}; 2400 ; 2401///////////////////",MatchSource.WIKI,doc/v632/TROOT_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/TROOT_8cxx_source.html
https://root.cern/doc/v632/TROOT_8cxx_source.html:91271,Performance,load,load,91271,"373 sline = sline.Strip(TString::kBoth);; 2374 ; 2375 if (!fApplication.load()); 2376 TApplication::CreateApplication();; 2377 ; 2378 return (*fApplication).ProcessLine(sline, kFALSE, error);; 2379}; 2380 ; 2381////////////////////////////////////////////////////////////////////////////////; 2382/// Process interpreter command via TApplication::ProcessLine().; 2383/// On Win32 the line will be processed synchronously (i.e. it will; 2384/// only return when the CINT interpreter thread has finished executing; 2385/// the line). On non-Win32 platforms there is no difference between; 2386/// ProcessLine() and ProcessLineSync().; 2387/// The possible error codes are defined by TInterpreter::EErrorCode.; 2388/// Returns the result of the command, cast to a Longptr_t.; 2389 ; 2390Longptr_t TROOT::ProcessLineSync(const char *line, Int_t *error); 2391{; 2392 TString sline = line;; 2393 sline = sline.Strip(TString::kBoth);; 2394 ; 2395 if (!fApplication.load()); 2396 TApplication::CreateApplication();; 2397 ; 2398 return (*fApplication).ProcessLine(sline, kTRUE, error);; 2399}; 2400 ; 2401////////////////////////////////////////////////////////////////////////////////; 2402/// Process interpreter command directly via CINT interpreter.; 2403/// Only executable statements are allowed (no variable declarations),; 2404/// In all other cases use TROOT::ProcessLine().; 2405/// The possible error codes are defined by TInterpreter::EErrorCode.; 2406 ; 2407Longptr_t TROOT::ProcessLineFast(const char *line, Int_t *error); 2408{; 2409 TString sline = line;; 2410 sline = sline.Strip(TString::kBoth);; 2411 ; 2412 if (!fApplication.load()); 2413 TApplication::CreateApplication();; 2414 ; 2415 Longptr_t result = 0;; 2416 ; 2417 if (fInterpreter) {; 2418 TInterpreter::EErrorCode *code = (TInterpreter::EErrorCode*)error;; 2419 result = gInterpreter->Calc(sline, code);; 2420 }; 2421 ; 2422 return result;; 2423}; 2424 ; 2425////////////////////////////////////////////////////////////////////////",MatchSource.WIKI,doc/v632/TROOT_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/TROOT_8cxx_source.html
https://root.cern/doc/v632/TROOT_8cxx_source.html:91949,Performance,load,load,91949,"tring sline = line;; 2393 sline = sline.Strip(TString::kBoth);; 2394 ; 2395 if (!fApplication.load()); 2396 TApplication::CreateApplication();; 2397 ; 2398 return (*fApplication).ProcessLine(sline, kTRUE, error);; 2399}; 2400 ; 2401////////////////////////////////////////////////////////////////////////////////; 2402/// Process interpreter command directly via CINT interpreter.; 2403/// Only executable statements are allowed (no variable declarations),; 2404/// In all other cases use TROOT::ProcessLine().; 2405/// The possible error codes are defined by TInterpreter::EErrorCode.; 2406 ; 2407Longptr_t TROOT::ProcessLineFast(const char *line, Int_t *error); 2408{; 2409 TString sline = line;; 2410 sline = sline.Strip(TString::kBoth);; 2411 ; 2412 if (!fApplication.load()); 2413 TApplication::CreateApplication();; 2414 ; 2415 Longptr_t result = 0;; 2416 ; 2417 if (fInterpreter) {; 2418 TInterpreter::EErrorCode *code = (TInterpreter::EErrorCode*)error;; 2419 result = gInterpreter->Calc(sline, code);; 2420 }; 2421 ; 2422 return result;; 2423}; 2424 ; 2425////////////////////////////////////////////////////////////////////////////////; 2426/// Read Git commit information and branch name from the; 2427/// etc/gitinfo.txt file.; 2428 ; 2429void TROOT::ReadGitInfo(); 2430{; 2431 TString filename = ""gitinfo.txt"";; 2432 gSystem->PrependPathName(TROOT::GetEtcDir(), filename);; 2433 ; 2434 FILE *fp = fopen(filename, ""r"");; 2435 if (fp) {; 2436 TString s;; 2437 // read branch name; 2438 s.Gets(fp);; 2439 fGitBranch = s;; 2440 // read commit hash; 2441 s.Gets(fp);; 2442 fGitCommit = s;; 2443 // read date/time make was run; 2444 s.Gets(fp);; 2445 fGitDate = s;; 2446 fclose(fp);; 2447 } else {; 2448 Error(""ReadGitInfo()"", ""Cannot determine git info: etc/gitinfo.txt not found!"");; 2449 }; 2450}; 2451 ; 2452Bool_t &GetReadingObject() {; 2453 TTHREAD_TLS(Bool_t) fgReadingObject = false;; 2454 return fgReadingObject;; 2455}; 2456 ; 2457/////////////////////////////////////////////////////",MatchSource.WIKI,doc/v632/TROOT_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/TROOT_8cxx_source.html
https://root.cern/doc/v632/TROOT_8cxx_source.html:96442,Performance,load,loaded,96442,"524 if (TROOT::Initialized() && ROOT::Internal::gROOTLocal) {; 2525 gROOT->CloseFiles();; 2526 }; 2527}; 2528 ; 2529////////////////////////////////////////////////////////////////////////////////; 2530/// Called by static dictionary initialization to register clang modules; 2531/// for headers. Calls TCling::RegisterModule() unless gCling; 2532/// is NULL, i.e. during startup, where the information is buffered in; 2533/// the static GetModuleHeaderInfoBuffer().; 2534 ; 2535void TROOT::RegisterModule(const char* modulename,; 2536 const char** headers,; 2537 const char** includePaths,; 2538 const char* payloadCode,; 2539 const char* fwdDeclCode,; 2540 void (*triggerFunc)(),; 2541 const TInterpreter::FwdDeclArgsToKeepCollection_t& fwdDeclsArgToSkip,; 2542 const char** classesHeaders,; 2543 bool hasCxxModule); 2544{; 2545 ; 2546 // First a side track to insure proper end of process behavior.; 2547 ; 2548 // Register for each loaded dictionary (and thus for each library),; 2549 // that we need to Close the ROOT files as soon as this library; 2550 // might start being unloaded after main.; 2551 //; 2552 // By calling atexit here (rather than directly from within the; 2553 // library) we make sure that this is not called if the library is; 2554 // 'only' dlclosed.; 2555 ; 2556 // On Ubuntu the linker strips the unused libraries. Eventhough; 2557 // stressHistogram is explicitly linked against libNet, it is not; 2558 // retained and thus is loaded only as needed in the middle part of; 2559 // the execution. Concretely this also means that it is loaded; 2560 // *after* the construction of the TApplication object and thus; 2561 // after the registration (atexit) of the EndOfProcessCleanups; 2562 // routine. Consequently, after the end of main, libNet is; 2563 // unloaded before EndOfProcessCleanups is called. When; 2564 // EndOfProcessCleanups is executed it indirectly needs the TClass; 2565 // for TSocket and its search will use resources that have already; 2566 // been unlo",MatchSource.WIKI,doc/v632/TROOT_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/TROOT_8cxx_source.html
https://root.cern/doc/v632/TROOT_8cxx_source.html:96964,Performance,load,loaded,96964,"tic GetModuleHeaderInfoBuffer().; 2534 ; 2535void TROOT::RegisterModule(const char* modulename,; 2536 const char** headers,; 2537 const char** includePaths,; 2538 const char* payloadCode,; 2539 const char* fwdDeclCode,; 2540 void (*triggerFunc)(),; 2541 const TInterpreter::FwdDeclArgsToKeepCollection_t& fwdDeclsArgToSkip,; 2542 const char** classesHeaders,; 2543 bool hasCxxModule); 2544{; 2545 ; 2546 // First a side track to insure proper end of process behavior.; 2547 ; 2548 // Register for each loaded dictionary (and thus for each library),; 2549 // that we need to Close the ROOT files as soon as this library; 2550 // might start being unloaded after main.; 2551 //; 2552 // By calling atexit here (rather than directly from within the; 2553 // library) we make sure that this is not called if the library is; 2554 // 'only' dlclosed.; 2555 ; 2556 // On Ubuntu the linker strips the unused libraries. Eventhough; 2557 // stressHistogram is explicitly linked against libNet, it is not; 2558 // retained and thus is loaded only as needed in the middle part of; 2559 // the execution. Concretely this also means that it is loaded; 2560 // *after* the construction of the TApplication object and thus; 2561 // after the registration (atexit) of the EndOfProcessCleanups; 2562 // routine. Consequently, after the end of main, libNet is; 2563 // unloaded before EndOfProcessCleanups is called. When; 2564 // EndOfProcessCleanups is executed it indirectly needs the TClass; 2565 // for TSocket and its search will use resources that have already; 2566 // been unloaded (technically the function static in TUnixSystem's; 2567 // DynamicPath and the dictionary from libNet).; 2568 ; 2569 // Similarly, the ordering (before this commit) was broken in the; 2570 // following case:; 2571 ; 2572 // TApplication creation (EndOfProcessCleanups registration); 2573 // load UserLibrary; 2574 // create TFile; 2575 // Append UserObject to TFile; 2576 ; 2577 // and after the end of main the order of executio",MatchSource.WIKI,doc/v632/TROOT_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/TROOT_8cxx_source.html
https://root.cern/doc/v632/TROOT_8cxx_source.html:97070,Performance,load,loaded,97070,"9 const char* fwdDeclCode,; 2540 void (*triggerFunc)(),; 2541 const TInterpreter::FwdDeclArgsToKeepCollection_t& fwdDeclsArgToSkip,; 2542 const char** classesHeaders,; 2543 bool hasCxxModule); 2544{; 2545 ; 2546 // First a side track to insure proper end of process behavior.; 2547 ; 2548 // Register for each loaded dictionary (and thus for each library),; 2549 // that we need to Close the ROOT files as soon as this library; 2550 // might start being unloaded after main.; 2551 //; 2552 // By calling atexit here (rather than directly from within the; 2553 // library) we make sure that this is not called if the library is; 2554 // 'only' dlclosed.; 2555 ; 2556 // On Ubuntu the linker strips the unused libraries. Eventhough; 2557 // stressHistogram is explicitly linked against libNet, it is not; 2558 // retained and thus is loaded only as needed in the middle part of; 2559 // the execution. Concretely this also means that it is loaded; 2560 // *after* the construction of the TApplication object and thus; 2561 // after the registration (atexit) of the EndOfProcessCleanups; 2562 // routine. Consequently, after the end of main, libNet is; 2563 // unloaded before EndOfProcessCleanups is called. When; 2564 // EndOfProcessCleanups is executed it indirectly needs the TClass; 2565 // for TSocket and its search will use resources that have already; 2566 // been unloaded (technically the function static in TUnixSystem's; 2567 // DynamicPath and the dictionary from libNet).; 2568 ; 2569 // Similarly, the ordering (before this commit) was broken in the; 2570 // following case:; 2571 ; 2572 // TApplication creation (EndOfProcessCleanups registration); 2573 // load UserLibrary; 2574 // create TFile; 2575 // Append UserObject to TFile; 2576 ; 2577 // and after the end of main the order of execution was; 2578 ; 2579 // unload UserLibrary; 2580 // call EndOfProcessCleanups; 2581 // Write the TFile; 2582 // attempt to write the user object.; 2583 // ....; 2584 ; 2585 // where what we nee",MatchSource.WIKI,doc/v632/TROOT_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/TROOT_8cxx_source.html
https://root.cern/doc/v632/TROOT_8cxx_source.html:97803,Performance,load,load,97803,". Eventhough; 2557 // stressHistogram is explicitly linked against libNet, it is not; 2558 // retained and thus is loaded only as needed in the middle part of; 2559 // the execution. Concretely this also means that it is loaded; 2560 // *after* the construction of the TApplication object and thus; 2561 // after the registration (atexit) of the EndOfProcessCleanups; 2562 // routine. Consequently, after the end of main, libNet is; 2563 // unloaded before EndOfProcessCleanups is called. When; 2564 // EndOfProcessCleanups is executed it indirectly needs the TClass; 2565 // for TSocket and its search will use resources that have already; 2566 // been unloaded (technically the function static in TUnixSystem's; 2567 // DynamicPath and the dictionary from libNet).; 2568 ; 2569 // Similarly, the ordering (before this commit) was broken in the; 2570 // following case:; 2571 ; 2572 // TApplication creation (EndOfProcessCleanups registration); 2573 // load UserLibrary; 2574 // create TFile; 2575 // Append UserObject to TFile; 2576 ; 2577 // and after the end of main the order of execution was; 2578 ; 2579 // unload UserLibrary; 2580 // call EndOfProcessCleanups; 2581 // Write the TFile; 2582 // attempt to write the user object.; 2583 // ....; 2584 ; 2585 // where what we need is to have the files closen/written before; 2586 // the unloading of the library.; 2587 ; 2588 // To solve the problem we now register an atexit function for; 2589 // every dictionary thus making sure there is at least one executed; 2590 // before the first library tear down after main.; 2591 ; 2592 // If atexit is called directly within a library's code, the; 2593 // function will called *either* when the library is 'dlclose'd or; 2594 // after then end of main (whichever comes first). We do *not*; 2595 // want the files to be closed whenever a library is unloaded via; 2596 // dlclose. To avoid this, we add the function (CallCloseFiles); 2597 // from the dictionary indirectly (via ROOT::RegisterModule). In",MatchSource.WIKI,doc/v632/TROOT_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/TROOT_8cxx_source.html
https://root.cern/doc/v632/TROOT_8cxx_source.html:100427,Performance,load,loaded,100427,",; 2610 classesHeaders, hasCxxModule));; 2611 }; 2612}; 2613 ; 2614////////////////////////////////////////////////////////////////////////////////; 2615/// Remove an object from the in-memory list.; 2616/// Since TROOT is global resource, this is lock protected.; 2617 ; 2618TObject *TROOT::Remove(TObject* obj); 2619{; 2620 R__LOCKGUARD(gROOTMutex);; 2621 return TDirectory::Remove(obj);; 2622}; 2623 ; 2624////////////////////////////////////////////////////////////////////////////////; 2625/// Remove a class from the list and map of classes.; 2626/// This routine is deprecated, use TClass::RemoveClass directly.; 2627 ; 2628void TROOT::RemoveClass(TClass *oldcl); 2629{; 2630 TClass::RemoveClass(oldcl);; 2631}; 2632 ; 2633////////////////////////////////////////////////////////////////////////////////; 2634/// Delete all global interpreter objects created since the last call to Reset; 2635///; 2636/// If option=""a"" is set reset to startup context (i.e. unload also; 2637/// all loaded files, classes, structs, typedefs, etc.).; 2638///; 2639/// This function is typically used at the beginning (or end) of an unnamed macro; 2640/// to clean the environment.; 2641///; 2642/// IMPORTANT WARNING:; 2643/// Do not use this call from within any function (neither compiled nor; 2644/// interpreted. This should only be used from a unnamed macro; 2645/// (which starts with a { (curly braces) ). For example, using TROOT::Reset; 2646/// from within an interpreted function will lead to the unloading of the; 2647/// dictionary and source file, including the one defining the function being; 2648/// executed.; 2649///; 2650 ; 2651void TROOT::Reset(Option_t *option); 2652{; 2653 if (IsExecutingMacro()) return; //True when TMacro::Exec runs; 2654 if (fInterpreter) {; 2655 if (!strncmp(option, ""a"", 1)) {; 2656 fInterpreter->Reset();; 2657 fInterpreter->SaveContext();; 2658 } else; 2659 gInterpreter->ResetGlobals();; 2660 ; 2661 if (fGlobals) fGlobals->Unload();; 2662 if (fGlobalFunctions) f",MatchSource.WIKI,doc/v632/TROOT_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/TROOT_8cxx_source.html
https://root.cern/doc/v632/TROOT_8cxx_source.html:131648,Performance,load,load,131648,".Definition TClass.h:81; TClass::AddClassstatic void AddClass(TClass *cl)static: Add a class to the list and map of classes.Definition TClass.cxx:494; TClass::LoadClassstatic TClass * LoadClass(const char *requestedname, Bool_t silent)Helper function used by TClass::GetClass().Definition TClass.cxx:5749; TClass::GetDeclFileLineShort_t GetDeclFileLine() constDefinition TClass.h:429; TClass::RemoveClassstatic void RemoveClass(TClass *cl)static: Remove a class from the list and map of classesDefinition TClass.cxx:520; TClass::GetClassInfoClassInfo_t * GetClassInfo() constDefinition TClass.h:433; TClass::InheritsFromBool_t InheritsFrom(const char *cl) const overrideReturn kTRUE if this class inherits from a class with name ""classname"".Definition TClass.cxx:4874; TClass::GetDeclFileNameconst char * GetDeclFileName() constReturn name of the file containing the declaration of this class.Definition TClass.cxx:3463; TClass::GetClassstatic TClass * GetClass(const char *name, Bool_t load=kTRUE, Bool_t silent=kFALSE)Static method returning pointer to TClass of the specified class name.Definition TClass.cxx:2968; TCollectionCollection abstract base class.Definition TCollection.h:65; TCollection::RecursiveRemovevoid RecursiveRemove(TObject *obj) overrideRemove object from this collection and recursively remove the object from all other objects (and coll...Definition TCollection.cxx:574; TCollection::UseRWLockvirtual bool UseRWLock(Bool_t enable=true)Set this collection to use a RW lock upon access, making it thread safe.Definition TCollection.cxx:761; TCollection::AddAllvirtual void AddAll(const TCollection *col)Add all objects from collection col to this collection.Definition TCollection.cxx:195; TCollection::SetOwnervirtual void SetOwner(Bool_t enable=kTRUE)Set whether this collection is the owner (enable==true) of its content.Definition TCollection.cxx:746; TCollection::Addvirtual void Add(TObject *obj)=0; TCollection::FindObjectTObject * FindObject(const char *name) const over",MatchSource.WIKI,doc/v632/TROOT_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/TROOT_8cxx_source.html
https://root.cern/doc/v632/TROOT_8cxx_source.html:147676,Performance,load,load,147676,"ectory in the installation. Static utility function.Definition TROOT.cxx:3042; TROOT::fFromPopUpBool_t fFromPopUpTrue if command executed from a popup menu.Definition TROOT.h:131; TROOT::Idlevoid Idle(UInt_t idleTimeInSec, const char *command=nullptr)Execute command when system has been idle for idleTimeInSec seconds.Definition TROOT.cxx:1892; TROOT::fSocketsTSeqCollection * fSocketsList of network sockets.Definition TROOT.h:148; TROOT::lsvoid ls(Option_t *option="""") const overrideTo list all objects of the application.Definition TROOT.cxx:2250; TROOT::GetMacroPathstatic const char * GetMacroPath()Get macro search path. Static utility function.Definition TROOT.cxx:2762; TROOT::fFunctionsTCollection * fFunctionsList of analytic functions.Definition TROOT.h:151; TROOT::SaveContextvoid SaveContext()Save the current interpreter context.Definition TROOT.cxx:2671; TROOT::IsExecutingMacroBool_t IsExecutingMacro() constDefinition TROOT.h:280; TROOT::GetTypeTDataType * GetType(const char *name, Bool_t load=kFALSE) constReturn pointer to type with name.Definition TROOT.cxx:1562; TROOT::Initializestatic void Initialize()Initialize ROOT explicitly.Definition TROOT.cxx:2899; TROOT::ShutDownstatic void ShutDown()Shut down ROOT.Definition TROOT.cxx:3136; TROOT::GetFunctionTObject * GetFunction(const char *name) constReturn pointer to function with name.Definition TROOT.cxx:1587; TROOT::ConvertVersionCode2Intstatic Int_t ConvertVersionCode2Int(Int_t code)Convert version code to an integer, i.e. 331527 -> 51507.Definition TROOT.cxx:2922; TROOT::fMessageHandlersTSeqCollection * fMessageHandlersList of message handlers.Definition TROOT.h:158; TROOT::SetStylevoid SetStyle(const char *stylename=""Default"")Change current style to style with name stylename.Definition TROOT.cxx:2730; TROOT::fEnumsAListOfEnums_t fEnumsList of enum types.Definition TROOT.h:165; TROOT::ReadGitInfovoid ReadGitInfo()Read Git commit SHA1 and branch name.Definition TROOT.cxx:2429; TROOT::fgRootInitstatic Bool_t fgR",MatchSource.WIKI,doc/v632/TROOT_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/TROOT_8cxx_source.html
https://root.cern/doc/v632/TROOT_8cxx_source.html:150133,Performance,load,load,150133,"constReturn path name of obj somewhere in the //root/... path.Definition TROOT.cxx:1473; TROOT::ConvertVersionInt2Codestatic Int_t ConvertVersionInt2Code(Int_t v)Convert version as an integer to version code as used in RVersion.h.Definition TROOT.cxx:2930; TROOT::ResetClassSavedvoid ResetClassSaved()Reset the ClassSaved status of all classes.Definition TROOT.cxx:1096; TROOT::GetTTFFontDirstatic const TString & GetTTFFontDir()Get the fonts directory in the installation. Static utility function.Definition TROOT.cxx:3189; TROOT::fForceStyleBool_t fForceStyleForce setting of current style when reading objects.Definition TROOT.h:133; TROOT::MakeDefCanvasTCanvas * MakeDefCanvas() constReturn a default canvas.Definition TROOT.cxx:1554; TROOT::fTypesTCollection * fTypesList of data types definition.Definition TROOT.h:141; TROOT::GetColorTColor * GetColor(Int_t color) constReturn address of color with index color.Definition TROOT.cxx:1536; TROOT::GetGlobalTGlobal * GetGlobal(const char *name, Bool_t load=kFALSE) constReturn pointer to global variable by name.Definition TROOT.cxx:1631; TROOT::FindSTLClassTClass * FindSTLClass(const char *name, Bool_t load, Bool_t silent=kFALSE) constreturn a TClass object corresponding to 'name' assuming it is an STL container.Definition TROOT.cxx:1484; TROOT::fStreamerInfoTSeqCollection * fStreamerInfoList of active StreamerInfo classes.Definition TROOT.h:159; TROOT::Appendvoid Append(TObject *obj, Bool_t replace=kFALSE) overrideAppend object to this directory.Definition TROOT.cxx:1047; TROOT::GetIconPathstatic const TString & GetIconPath()Get the icon path in the installation. Static utility function.Definition TROOT.cxx:3168; TROOT::GetListOfGlobalFunctionsTCollection * GetListOfGlobalFunctions(Bool_t load=kFALSE)Return list containing the TFunctions currently defined.Definition TROOT.cxx:1826; TROOT::fGitDateTString fGitDateDate and time when make was run.Definition TROOT.h:122; TROOT::fSpecialsTSeqCollection * fSpecialsList of special obj",MatchSource.WIKI,doc/v632/TROOT_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/TROOT_8cxx_source.html
https://root.cern/doc/v632/TROOT_8cxx_source.html:150286,Performance,load,load,150286," as an integer to version code as used in RVersion.h.Definition TROOT.cxx:2930; TROOT::ResetClassSavedvoid ResetClassSaved()Reset the ClassSaved status of all classes.Definition TROOT.cxx:1096; TROOT::GetTTFFontDirstatic const TString & GetTTFFontDir()Get the fonts directory in the installation. Static utility function.Definition TROOT.cxx:3189; TROOT::fForceStyleBool_t fForceStyleForce setting of current style when reading objects.Definition TROOT.h:133; TROOT::MakeDefCanvasTCanvas * MakeDefCanvas() constReturn a default canvas.Definition TROOT.cxx:1554; TROOT::fTypesTCollection * fTypesList of data types definition.Definition TROOT.h:141; TROOT::GetColorTColor * GetColor(Int_t color) constReturn address of color with index color.Definition TROOT.cxx:1536; TROOT::GetGlobalTGlobal * GetGlobal(const char *name, Bool_t load=kFALSE) constReturn pointer to global variable by name.Definition TROOT.cxx:1631; TROOT::FindSTLClassTClass * FindSTLClass(const char *name, Bool_t load, Bool_t silent=kFALSE) constreturn a TClass object corresponding to 'name' assuming it is an STL container.Definition TROOT.cxx:1484; TROOT::fStreamerInfoTSeqCollection * fStreamerInfoList of active StreamerInfo classes.Definition TROOT.h:159; TROOT::Appendvoid Append(TObject *obj, Bool_t replace=kFALSE) overrideAppend object to this directory.Definition TROOT.cxx:1047; TROOT::GetIconPathstatic const TString & GetIconPath()Get the icon path in the installation. Static utility function.Definition TROOT.cxx:3168; TROOT::GetListOfGlobalFunctionsTCollection * GetListOfGlobalFunctions(Bool_t load=kFALSE)Return list containing the TFunctions currently defined.Definition TROOT.cxx:1826; TROOT::fGitDateTString fGitDateDate and time when make was run.Definition TROOT.h:122; TROOT::fSpecialsTSeqCollection * fSpecialsList of special objects.Definition TROOT.h:156; TROOT::GetListOfFunctionTemplatesTCollection * GetListOfFunctionTemplates()Definition TROOT.cxx:1771; TROOT::RegisterModulestatic void RegisterModu",MatchSource.WIKI,doc/v632/TROOT_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/TROOT_8cxx_source.html
https://root.cern/doc/v632/TROOT_8cxx_source.html:150885,Performance,load,load,150885,"ypesTCollection * fTypesList of data types definition.Definition TROOT.h:141; TROOT::GetColorTColor * GetColor(Int_t color) constReturn address of color with index color.Definition TROOT.cxx:1536; TROOT::GetGlobalTGlobal * GetGlobal(const char *name, Bool_t load=kFALSE) constReturn pointer to global variable by name.Definition TROOT.cxx:1631; TROOT::FindSTLClassTClass * FindSTLClass(const char *name, Bool_t load, Bool_t silent=kFALSE) constreturn a TClass object corresponding to 'name' assuming it is an STL container.Definition TROOT.cxx:1484; TROOT::fStreamerInfoTSeqCollection * fStreamerInfoList of active StreamerInfo classes.Definition TROOT.h:159; TROOT::Appendvoid Append(TObject *obj, Bool_t replace=kFALSE) overrideAppend object to this directory.Definition TROOT.cxx:1047; TROOT::GetIconPathstatic const TString & GetIconPath()Get the icon path in the installation. Static utility function.Definition TROOT.cxx:3168; TROOT::GetListOfGlobalFunctionsTCollection * GetListOfGlobalFunctions(Bool_t load=kFALSE)Return list containing the TFunctions currently defined.Definition TROOT.cxx:1826; TROOT::fGitDateTString fGitDateDate and time when make was run.Definition TROOT.h:122; TROOT::fSpecialsTSeqCollection * fSpecialsList of special objects.Definition TROOT.h:156; TROOT::GetListOfFunctionTemplatesTCollection * GetListOfFunctionTemplates()Definition TROOT.cxx:1771; TROOT::RegisterModulestatic void RegisterModule(const char *modulename, const char **headers, const char **includePaths, const char *payLoadCode, const char *fwdDeclCode, void(*triggerFunc)(), const FwdDeclArgsToKeepCollection_t &fwdDeclsArgToSkip, const char **classesHeaders, bool hasCxxModule=false)Called by static dictionary initialization to register clang modules for headers.Definition TROOT.cxx:2535; TROOT::FindObjectTObject * FindObject(const char *name) const overrideReturns address of a ROOT object if it exists.Definition TROOT.cxx:1313; TROOT::fClassesTCollection * fClassesList of classes definition.",MatchSource.WIKI,doc/v632/TROOT_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/TROOT_8cxx_source.html
https://root.cern/doc/v632/TROOT_8cxx_source.html:152664,Performance,load,load,152664,"inition TROOT.cxx:2535; TROOT::FindObjectTObject * FindObject(const char *name) const overrideReturns address of a ROOT object if it exists.Definition TROOT.cxx:1313; TROOT::fClassesTCollection * fClassesList of classes definition.Definition TROOT.h:140; TROOT::fEditHistogramsBool_t fEditHistogramsTrue if histograms can be edited with the mouse.Definition TROOT.h:130; TROOT::fGlobalsTListOfDataMembers * fGlobalsList of global variables.Definition TROOT.h:143; TROOT::fFuncTemplateTListOfFunctionTemplates * fFuncTemplateList of global function templates.Definition TROOT.h:142; TROOT::fTimerInt_t fTimerTimer flag.Definition TROOT.h:123; TROOT::fDataSetsTSeqCollection * fDataSetsList of data sets (TDSet or TChain)Definition TROOT.h:164; TROOT::fConfigOptionsTString fConfigOptionsROOT ./configure set build options.Definition TROOT.h:111; TROOT::GetStyleTStyle * GetStyle(const char *name) constReturn pointer to style with name.Definition TROOT.cxx:1579; TROOT::GetListOfEnumsTCollection * GetListOfEnums(Bool_t load=kFALSE)Definition TROOT.cxx:1754; TROOT::ProcessLineSyncLongptr_t ProcessLineSync(const char *line, Int_t *error=nullptr)Process interpreter command via TApplication::ProcessLine().Definition TROOT.cxx:2390; TROOT::InitInterpretervoid InitInterpreter()Initialize interpreter (cling)Definition TROOT.cxx:2064; TROOT::GetListOfGlobalsTCollection * GetListOfGlobals(Bool_t load=kFALSE)Return list containing the TGlobals currently defined.Definition TROOT.cxx:1788; TROOT::SetDirLevelstatic void SetDirLevel(Int_t level=0)Return Indentation level for ls().Definition TROOT.cxx:2914; TROOT::fSecContextsTSeqCollection * fSecContextsList of security contexts (TSecContext)Definition TROOT.h:161; TROOT::fWebDisplayTString fWebDisplayIf not empty it defines where web graphics should be rendered (cef, qt5, browser.....Definition TROOT.h:127; TROOT::GetTutorialsDirstatic const char * GetTutorialsDir()Get the tutorials directory in the installation.Definition TROOT.cxx:3211; TROOT",MatchSource.WIKI,doc/v632/TROOT_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/TROOT_8cxx_source.html
https://root.cern/doc/v632/TROOT_8cxx_source.html:153039,Performance,load,load,153039,"OfDataMembers * fGlobalsList of global variables.Definition TROOT.h:143; TROOT::fFuncTemplateTListOfFunctionTemplates * fFuncTemplateList of global function templates.Definition TROOT.h:142; TROOT::fTimerInt_t fTimerTimer flag.Definition TROOT.h:123; TROOT::fDataSetsTSeqCollection * fDataSetsList of data sets (TDSet or TChain)Definition TROOT.h:164; TROOT::fConfigOptionsTString fConfigOptionsROOT ./configure set build options.Definition TROOT.h:111; TROOT::GetStyleTStyle * GetStyle(const char *name) constReturn pointer to style with name.Definition TROOT.cxx:1579; TROOT::GetListOfEnumsTCollection * GetListOfEnums(Bool_t load=kFALSE)Definition TROOT.cxx:1754; TROOT::ProcessLineSyncLongptr_t ProcessLineSync(const char *line, Int_t *error=nullptr)Process interpreter command via TApplication::ProcessLine().Definition TROOT.cxx:2390; TROOT::InitInterpretervoid InitInterpreter()Initialize interpreter (cling)Definition TROOT.cxx:2064; TROOT::GetListOfGlobalsTCollection * GetListOfGlobals(Bool_t load=kFALSE)Return list containing the TGlobals currently defined.Definition TROOT.cxx:1788; TROOT::SetDirLevelstatic void SetDirLevel(Int_t level=0)Return Indentation level for ls().Definition TROOT.cxx:2914; TROOT::fSecContextsTSeqCollection * fSecContextsList of security contexts (TSecContext)Definition TROOT.h:161; TROOT::fWebDisplayTString fWebDisplayIf not empty it defines where web graphics should be rendered (cef, qt5, browser.....Definition TROOT.h:127; TROOT::GetTutorialsDirstatic const char * GetTutorialsDir()Get the tutorials directory in the installation.Definition TROOT.cxx:3211; TROOT::GetListOfFunctionOverloadsTCollection * GetListOfFunctionOverloads(const char *name) constReturn the collection of functions named ""name"".Definition TROOT.cxx:1672; TROOT::fCleanupsTSeqCollection * fCleanupsList of recursiveRemove collections.Definition TROOT.h:157; TROOT::Initializedstatic Bool_t Initialized()Return kTRUE if the TROOT object has been initialized.Definition TROOT.cxx:290",MatchSource.WIKI,doc/v632/TROOT_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/TROOT_8cxx_source.html
https://root.cern/doc/v632/TROOT_8cxx_source.html:154281,Performance,multi-thread,multi-threads,154281,"OT::fSecContextsTSeqCollection * fSecContextsList of security contexts (TSecContext)Definition TROOT.h:161; TROOT::fWebDisplayTString fWebDisplayIf not empty it defines where web graphics should be rendered (cef, qt5, browser.....Definition TROOT.h:127; TROOT::GetTutorialsDirstatic const char * GetTutorialsDir()Get the tutorials directory in the installation.Definition TROOT.cxx:3211; TROOT::GetListOfFunctionOverloadsTCollection * GetListOfFunctionOverloads(const char *name) constReturn the collection of functions named ""name"".Definition TROOT.cxx:1672; TROOT::fCleanupsTSeqCollection * fCleanupsList of recursiveRemove collections.Definition TROOT.h:157; TROOT::Initializedstatic Bool_t Initialized()Return kTRUE if the TROOT object has been initialized.Definition TROOT.cxx:2906; TROOT::SetBatchvoid SetBatch(Bool_t batch=kTRUE)Set batch mode for ROOT If the argument evaluates to true, the session does not use interactive graph...Definition TROOT.cxx:2803; TROOT::fLineIsProcessingInt_t fLineIsProcessingTo synchronize multi-threads.Definition TROOT.h:100; TROOT::GetSourceDirstatic const TString & GetSourceDir()Get the source directory in the installation. Static utility function.Definition TROOT.cxx:3147; TROOT::GetMacroDirstatic const TString & GetMacroDir()Get the macro directory in the installation. Static utility function.Definition TROOT.cxx:3094; TROOT::fGitCommitTString fGitCommitGit commit SHA1 of built.Definition TROOT.h:120; TROOT::ProcessLineLongptr_t ProcessLine(const char *line, Int_t *error=nullptr)Process interpreter command via TApplication::ProcessLine().Definition TROOT.cxx:2370; TROOT::fClosedObjectsTSeqCollection * fClosedObjectsList of closed objects from the list of files and sockets, so we can delete them if neededCl.Definition TROOT.h:145; TROOT::fTasksTSeqCollection * fTasksList of tasks.Definition TROOT.h:152; TROOT::fClipboardTSeqCollection * fClipboardList of clipboard objects.Definition TROOT.h:163; TROOT::GetGitDateconst char * GetGitDate()R",MatchSource.WIKI,doc/v632/TROOT_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/TROOT_8cxx_source.html
https://root.cern/doc/v632/TROOT_8cxx_source.html:155926,Performance,load,load,155926,"sedObjectsTSeqCollection * fClosedObjectsList of closed objects from the list of files and sockets, so we can delete them if neededCl.Definition TROOT.h:145; TROOT::fTasksTSeqCollection * fTasksList of tasks.Definition TROOT.h:152; TROOT::fClipboardTSeqCollection * fClipboardList of clipboard objects.Definition TROOT.h:163; TROOT::GetGitDateconst char * GetGitDate()Return date/time make was run.Definition TROOT.cxx:2474; TROOT::SetEditorModevoid SetEditorMode(const char *mode="""")Set editor mode.Definition TROOT.cxx:2704; TROOT::GetTutorialDirstatic const TString & GetTutorialDir()Get the tutorials directory in the installation. Static utility function.Definition TROOT.cxx:3115; TROOT::~TROOTvirtual ~TROOT()Clean up and free resources used by ROOT (files, network sockets, shared memory segments,...Definition TROOT.cxx:867; TROOT::fColorsTSeqCollection * fColorsList of colors.Definition TROOT.h:153; TROOT::GetGlobalFunctionWithPrototypeTFunction * GetGlobalFunctionWithPrototype(const char *name, const char *proto=nullptr, Bool_t load=kFALSE)Return pointer to global function by name.Definition TROOT.cxx:1718; TROOT::GetListOfBrowsersTSeqCollection * GetListOfBrowsers() constDefinition TROOT.h:245; TROOT::ReadingObjectBool_t ReadingObject() constDeprecated (will be removed in next release).Definition TROOT.cxx:2460; TROOT::fStylesTSeqCollection * fStylesList of styles.Definition TROOT.h:150; TROOT::fVersionDateInt_t fVersionDateDate of ROOT version (ex 951226)Definition TROOT.h:116; TROOT::GetListOfColorsTSeqCollection * GetListOfColors() constDefinition TROOT.h:232; TROOT::MacroLongptr_t Macro(const char *filename, Int_t *error=nullptr, Bool_t padUpdate=kTRUE)Execute a macro in the interpreter.Definition TROOT.cxx:2316; TROOT::fBuiltTimeInt_t fBuiltTimeTime of ROOT built.Definition TROOT.h:119; TROOT::AddExtraInterpreterArgsstatic const std::vector< std::string > & AddExtraInterpreterArgs(const std::vector< std::string > &args)Provide command line arguments to the inter",MatchSource.WIKI,doc/v632/TROOT_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/TROOT_8cxx_source.html
https://root.cern/doc/v632/TROOT_8cxx_source.html:156989,Performance,load,load,156989,"TROOT.cxx:1718; TROOT::GetListOfBrowsersTSeqCollection * GetListOfBrowsers() constDefinition TROOT.h:245; TROOT::ReadingObjectBool_t ReadingObject() constDeprecated (will be removed in next release).Definition TROOT.cxx:2460; TROOT::fStylesTSeqCollection * fStylesList of styles.Definition TROOT.h:150; TROOT::fVersionDateInt_t fVersionDateDate of ROOT version (ex 951226)Definition TROOT.h:116; TROOT::GetListOfColorsTSeqCollection * GetListOfColors() constDefinition TROOT.h:232; TROOT::MacroLongptr_t Macro(const char *filename, Int_t *error=nullptr, Bool_t padUpdate=kTRUE)Execute a macro in the interpreter.Definition TROOT.cxx:2316; TROOT::fBuiltTimeInt_t fBuiltTimeTime of ROOT built.Definition TROOT.h:119; TROOT::AddExtraInterpreterArgsstatic const std::vector< std::string > & AddExtraInterpreterArgs(const std::vector< std::string > &args)Provide command line arguments to the interpreter construction.Definition TROOT.cxx:2952; TROOT::GetClassTClass * GetClass(const char *name, Bool_t load=kTRUE, Bool_t silent=kFALSE) constReturn pointer to class with name. Obsolete, use TClass::GetClass directly.Definition TROOT.cxx:1518; TROOT::fSelectPadTVirtualPad * fSelectPadCurrently selected pad.Definition TROOT.h:139; TROOT::fFilesTSeqCollection * fFilesList of files.Definition TROOT.h:146; TROOT::Browsevoid Browse(TBrowser *b) overrideAdd browsable objects to TBrowser.Definition TROOT.cxx:1056; TROOT::GetRootSysstatic const TString & GetRootSys()Get the rootsys directory in the installation. Static utility function.Definition TROOT.cxx:2979; TROOT::GetGlobalFunctionsTListOfFunctions * GetGlobalFunctions()Internal routine returning, and creating if necessary, the list of global function.Definition TROOT.cxx:1663; TROOT::fInterruptBool_t fInterruptTrue if macro should be interrupted.Definition TROOT.h:134; TROOT::fMustCleanBool_t fMustCleanTrue if object destructor scans canvases.Definition TROOT.h:132; TROOT::LoadClassInt_t LoadClass(const char *classname, const char *libname, ",MatchSource.WIKI,doc/v632/TROOT_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/TROOT_8cxx_source.html
https://root.cern/doc/v632/TROOT_8cxx_source.html:158247,Performance,load,load,158247,"9; TROOT::fFilesTSeqCollection * fFilesList of files.Definition TROOT.h:146; TROOT::Browsevoid Browse(TBrowser *b) overrideAdd browsable objects to TBrowser.Definition TROOT.cxx:1056; TROOT::GetRootSysstatic const TString & GetRootSys()Get the rootsys directory in the installation. Static utility function.Definition TROOT.cxx:2979; TROOT::GetGlobalFunctionsTListOfFunctions * GetGlobalFunctions()Internal routine returning, and creating if necessary, the list of global function.Definition TROOT.cxx:1663; TROOT::fInterruptBool_t fInterruptTrue if macro should be interrupted.Definition TROOT.h:134; TROOT::fMustCleanBool_t fMustCleanTrue if object destructor scans canvases.Definition TROOT.h:132; TROOT::LoadClassInt_t LoadClass(const char *classname, const char *libname, Bool_t check=kFALSE)Check if class ""classname"" is known to the interpreter (in fact, this check is not needed anymore,...Definition TROOT.cxx:2183; TROOT::GetGlobalFunctionTFunction * GetGlobalFunction(const char *name, const char *params=nullptr, Bool_t load=kFALSE)Return pointer to global function by name.Definition TROOT.cxx:1685; TROOT::AddClassvoid AddClass(TClass *cl)Add a class to the list and map of classes.Definition TROOT.cxx:1025; TROOT::RootVersionCodestatic Int_t RootVersionCode()Return ROOT version code as defined in RVersion.h.Definition TROOT.cxx:2941; TROOT::FindSpecialObjectTObject * FindSpecialObject(const char *name, void *&where)Returns address and folder of a ROOT object if it exists.Definition TROOT.cxx:1367; TROOT::RemoveTObject * Remove(TObject *) overrideRemove an object from the in-memory list.Definition TROOT.cxx:2618; TROOT::InitSystemvoid InitSystem()Operating System interface.Definition TROOT.cxx:1978; TROOT::ProcessLineFastLongptr_t ProcessLineFast(const char *line, Int_t *error=nullptr)Process interpreter command directly via CINT interpreter.Definition TROOT.cxx:2407; TROOT::ClassSavedBool_t ClassSaved(TClass *cl)return class status 'ClassSaved' for class cl This function",MatchSource.WIKI,doc/v632/TROOT_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/TROOT_8cxx_source.html
https://root.cern/doc/v632/TROOT_8cxx_source.html:159415,Performance,load,load,159415,"x:1025; TROOT::RootVersionCodestatic Int_t RootVersionCode()Return ROOT version code as defined in RVersion.h.Definition TROOT.cxx:2941; TROOT::FindSpecialObjectTObject * FindSpecialObject(const char *name, void *&where)Returns address and folder of a ROOT object if it exists.Definition TROOT.cxx:1367; TROOT::RemoveTObject * Remove(TObject *) overrideRemove an object from the in-memory list.Definition TROOT.cxx:2618; TROOT::InitSystemvoid InitSystem()Operating System interface.Definition TROOT.cxx:1978; TROOT::ProcessLineFastLongptr_t ProcessLineFast(const char *line, Int_t *error=nullptr)Process interpreter command directly via CINT interpreter.Definition TROOT.cxx:2407; TROOT::ClassSavedBool_t ClassSaved(TClass *cl)return class status 'ClassSaved' for class cl This function is called by the SavePrimitive functions ...Definition TROOT.cxx:1083; TROOT::fGitBranchTString fGitBranchGit branch.Definition TROOT.h:121; TROOT::GetListOfTypesTCollection * GetListOfTypes(Bool_t load=kFALSE)Return a dynamic list giving access to all TDataTypes (typedefs) currently defined.Definition TROOT.cxx:1865; TROOT::fgDirLevelstatic Int_t fgDirLevelIndentation level for ls()Definition TROOT.h:102; TROOT::IsRootFileBool_t IsRootFile(const char *filename) constReturn true if the file is local and is (likely) to be a ROOT file.Definition TROOT.cxx:2230; TROOT::IndentLevelstatic void IndentLevel()Functions used by ls() to indent an object hierarchy.Definition TROOT.cxx:2891; TROOT::GetDocDirstatic const TString & GetDocDir()Get the documentation directory in the installation. Static utility function.Definition TROOT.cxx:3078; TROOT::GetEtcDirstatic const TString & GetEtcDir()Get the sysconfig directory in the installation. Static utility function.Definition TROOT.cxx:3052; TROOT::GetNclassesInt_t GetNclasses() constGet number of classes.Definition TROOT.cxx:1876; TROOT::GetExtraInterpreterArgsstatic const char **& GetExtraInterpreterArgs()INTERNAL function! Used by rootcling to inject inter",MatchSource.WIKI,doc/v632/TROOT_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/TROOT_8cxx_source.html
https://root.cern/doc/v632/TROOT_8cxx_source.html:171241,Performance,load,load,171241," GetRootSys()Definition FoundationUtils.cxx:158; ROOT::FoundationUtils::GetEtcDirconst std::string & GetEtcDir()Definition FoundationUtils.cxx:195; ROOT::Internal::VecOps::voidvoid(off) SmallVectorTemplateBase< T; ROOT::InternalDefinition TErrorDefaultHandler.hxx:16; ROOT::Internal::GetSymInLibImtstatic Func_t GetSymInLibImt(const char *funcname)Definition TROOT.cxx:401; ROOT::Internal::gGetROOTstatic GetROOTFun_t gGetROOTDefinition TROOT.cxx:399; ROOT::Internal::gROOTLocalR__EXTERN TROOT * gROOTLocalDefinition TROOT.h:379; ROOT::Internal::DisableParBranchProcessingvoid DisableParBranchProcessing()Globally disables the IMT use case of parallel branch processing, deactivating the corresponding lock...Definition TROOT.cxx:434; ROOT::Internal::ErrorSystemMsgHandlerFunc_tstd::function< const char *()> ErrorSystemMsgHandlerFunc_tRetrieves the error string associated with the last system error.Definition TError.h:59; ROOT::Internal::IsImplicitMTEnabledImplstatic Bool_t & IsImplicitMTEnabledImpl()Keeps track of the status of ImplicitMT w/o resorting to the load of libImt.Definition TROOT.cxx:463; ROOT::Internal::MinimalErrorHandlervoid MinimalErrorHandler(int level, Bool_t abort, const char *location, const char *msg)A very simple error handler that is usually replaced by the TROOT default error handler.Definition TError.cxx:67; ROOT::Internal::GetROOTFun_tTROOT *(* GetROOTFun_t)()Definition TROOT.cxx:397; ROOT::Internal::SetErrorSystemMsgHandlerErrorSystemMsgHandlerFunc_t SetErrorSystemMsgHandler(ErrorSystemMsgHandlerFunc_t h)Returns the previous system error message handler.Definition TError.cxx:56; ROOT::Internal::EnableParBranchProcessingvoid EnableParBranchProcessing()Globally enables the parallel branch processing, which is a case of implicit multi-threading (IMT) in...Definition TROOT.cxx:420; ROOT::Internal::IsParBranchProcessingEnabledBool_t IsParBranchProcessingEnabled()Returns true if parallel branch processing is enabled.Definition TROOT.cxx:447; ROOT::Internal",MatchSource.WIKI,doc/v632/TROOT_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/TROOT_8cxx_source.html
https://root.cern/doc/v632/TROOT_8cxx_source.html:171947,Performance,multi-thread,multi-threading,171947,"k...Definition TROOT.cxx:434; ROOT::Internal::ErrorSystemMsgHandlerFunc_tstd::function< const char *()> ErrorSystemMsgHandlerFunc_tRetrieves the error string associated with the last system error.Definition TError.h:59; ROOT::Internal::IsImplicitMTEnabledImplstatic Bool_t & IsImplicitMTEnabledImpl()Keeps track of the status of ImplicitMT w/o resorting to the load of libImt.Definition TROOT.cxx:463; ROOT::Internal::MinimalErrorHandlervoid MinimalErrorHandler(int level, Bool_t abort, const char *location, const char *msg)A very simple error handler that is usually replaced by the TROOT default error handler.Definition TError.cxx:67; ROOT::Internal::GetROOTFun_tTROOT *(* GetROOTFun_t)()Definition TROOT.cxx:397; ROOT::Internal::SetErrorSystemMsgHandlerErrorSystemMsgHandlerFunc_t SetErrorSystemMsgHandler(ErrorSystemMsgHandlerFunc_t h)Returns the previous system error message handler.Definition TError.cxx:56; ROOT::Internal::EnableParBranchProcessingvoid EnableParBranchProcessing()Globally enables the parallel branch processing, which is a case of implicit multi-threading (IMT) in...Definition TROOT.cxx:420; ROOT::Internal::IsParBranchProcessingEnabledBool_t IsParBranchProcessingEnabled()Returns true if parallel branch processing is enabled.Definition TROOT.cxx:447; ROOT::Internal::GetROOT2TROOT * GetROOT2()Definition TROOT.cxx:387; ROOT::Internal::GetROOT1TROOT * GetROOT1()Definition TROOT.cxx:380; ROOT::Internal::ReleaseDefaultErrorHandlervoid ReleaseDefaultErrorHandler()Destructs resources that are taken by using the default error handler.Definition TErrorDefaultHandler.cxx:47; ROOT::Minuit2::GradientParameterSpace::Internal@ Internal; ROOTtbb::task_arena is an alias of tbb::interface7::task_arena, which doesn't allow to forward declare tb...Definition EExecutionPolicy.hxx:4; ROOT::GetMacroPathTString & GetMacroPath()Definition TROOT.cxx:476; ROOT::EnableImplicitMTvoid EnableImplicitMT(UInt_t numthreads=0)Enable ROOT's implicit multi-threading for all objects and method",MatchSource.WIKI,doc/v632/TROOT_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/TROOT_8cxx_source.html
https://root.cern/doc/v632/TROOT_8cxx_source.html:172839,Performance,multi-thread,multi-threading,172839,"ocessingvoid EnableParBranchProcessing()Globally enables the parallel branch processing, which is a case of implicit multi-threading (IMT) in...Definition TROOT.cxx:420; ROOT::Internal::IsParBranchProcessingEnabledBool_t IsParBranchProcessingEnabled()Returns true if parallel branch processing is enabled.Definition TROOT.cxx:447; ROOT::Internal::GetROOT2TROOT * GetROOT2()Definition TROOT.cxx:387; ROOT::Internal::GetROOT1TROOT * GetROOT1()Definition TROOT.cxx:380; ROOT::Internal::ReleaseDefaultErrorHandlervoid ReleaseDefaultErrorHandler()Destructs resources that are taken by using the default error handler.Definition TErrorDefaultHandler.cxx:47; ROOT::Minuit2::GradientParameterSpace::Internal@ Internal; ROOTtbb::task_arena is an alias of tbb::interface7::task_arena, which doesn't allow to forward declare tb...Definition EExecutionPolicy.hxx:4; ROOT::GetMacroPathTString & GetMacroPath()Definition TROOT.cxx:476; ROOT::EnableImplicitMTvoid EnableImplicitMT(UInt_t numthreads=0)Enable ROOT's implicit multi-threading for all objects and methods that provide an internal paralleli...Definition TROOT.cxx:539; ROOT::IsImplicitMTEnabledBool_t IsImplicitMTEnabled()Returns true if the implicit multi-threading in ROOT is enabled.Definition TROOT.cxx:570; ROOT::GetThreadPoolSizeUInt_t GetThreadPoolSize()Returns the size of ROOT's thread pool.Definition TROOT.cxx:577; ROOT::gCoreMutexR__EXTERN TVirtualRWMutex * gCoreMutexDefinition TVirtualRWMutex.h:37; ROOT::EnableThreadSafetyvoid EnableThreadSafety()Enable support for multi-threading within the ROOT code in particular, enables the global mutex to ma...Definition TROOT.cxx:501; ROOT::GetROOTTROOT * GetROOT()Definition TROOT.cxx:472; ROOT::DisableImplicitMTvoid DisableImplicitMT()Disables the implicit multi-threading in ROOT (see EnableImplicitMT).Definition TROOT.cxx:556; TClassEdit::GetNormalizedNamevoid GetNormalizedName(std::string &norm_name, std::string_view name)Return the normalized name.Definition TClassEdit.cxx:854; v@ vDefi",MatchSource.WIKI,doc/v632/TROOT_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/TROOT_8cxx_source.html
https://root.cern/doc/v632/TROOT_8cxx_source.html:173028,Performance,multi-thread,multi-threading,173028,"ROOT::Internal::IsParBranchProcessingEnabledBool_t IsParBranchProcessingEnabled()Returns true if parallel branch processing is enabled.Definition TROOT.cxx:447; ROOT::Internal::GetROOT2TROOT * GetROOT2()Definition TROOT.cxx:387; ROOT::Internal::GetROOT1TROOT * GetROOT1()Definition TROOT.cxx:380; ROOT::Internal::ReleaseDefaultErrorHandlervoid ReleaseDefaultErrorHandler()Destructs resources that are taken by using the default error handler.Definition TErrorDefaultHandler.cxx:47; ROOT::Minuit2::GradientParameterSpace::Internal@ Internal; ROOTtbb::task_arena is an alias of tbb::interface7::task_arena, which doesn't allow to forward declare tb...Definition EExecutionPolicy.hxx:4; ROOT::GetMacroPathTString & GetMacroPath()Definition TROOT.cxx:476; ROOT::EnableImplicitMTvoid EnableImplicitMT(UInt_t numthreads=0)Enable ROOT's implicit multi-threading for all objects and methods that provide an internal paralleli...Definition TROOT.cxx:539; ROOT::IsImplicitMTEnabledBool_t IsImplicitMTEnabled()Returns true if the implicit multi-threading in ROOT is enabled.Definition TROOT.cxx:570; ROOT::GetThreadPoolSizeUInt_t GetThreadPoolSize()Returns the size of ROOT's thread pool.Definition TROOT.cxx:577; ROOT::gCoreMutexR__EXTERN TVirtualRWMutex * gCoreMutexDefinition TVirtualRWMutex.h:37; ROOT::EnableThreadSafetyvoid EnableThreadSafety()Enable support for multi-threading within the ROOT code in particular, enables the global mutex to ma...Definition TROOT.cxx:501; ROOT::GetROOTTROOT * GetROOT()Definition TROOT.cxx:472; ROOT::DisableImplicitMTvoid DisableImplicitMT()Disables the implicit multi-threading in ROOT (see EnableImplicitMT).Definition TROOT.cxx:556; TClassEdit::GetNormalizedNamevoid GetNormalizedName(std::string &norm_name, std::string_view name)Return the normalized name.Definition TClassEdit.cxx:854; v@ vDefinition rootcling_impl.cxx:3687; FileStat_tDefinition TSystem.h:122; FileStat_t::fModeInt_t fModeDefinition TSystem.h:125; socketDefinition civetweb.c:1894; mTMarker mDef",MatchSource.WIKI,doc/v632/TROOT_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/TROOT_8cxx_source.html
https://root.cern/doc/v632/TROOT_8cxx_source.html:173358,Performance,multi-thread,multi-threading,173358,"OT2TROOT * GetROOT2()Definition TROOT.cxx:387; ROOT::Internal::GetROOT1TROOT * GetROOT1()Definition TROOT.cxx:380; ROOT::Internal::ReleaseDefaultErrorHandlervoid ReleaseDefaultErrorHandler()Destructs resources that are taken by using the default error handler.Definition TErrorDefaultHandler.cxx:47; ROOT::Minuit2::GradientParameterSpace::Internal@ Internal; ROOTtbb::task_arena is an alias of tbb::interface7::task_arena, which doesn't allow to forward declare tb...Definition EExecutionPolicy.hxx:4; ROOT::GetMacroPathTString & GetMacroPath()Definition TROOT.cxx:476; ROOT::EnableImplicitMTvoid EnableImplicitMT(UInt_t numthreads=0)Enable ROOT's implicit multi-threading for all objects and methods that provide an internal paralleli...Definition TROOT.cxx:539; ROOT::IsImplicitMTEnabledBool_t IsImplicitMTEnabled()Returns true if the implicit multi-threading in ROOT is enabled.Definition TROOT.cxx:570; ROOT::GetThreadPoolSizeUInt_t GetThreadPoolSize()Returns the size of ROOT's thread pool.Definition TROOT.cxx:577; ROOT::gCoreMutexR__EXTERN TVirtualRWMutex * gCoreMutexDefinition TVirtualRWMutex.h:37; ROOT::EnableThreadSafetyvoid EnableThreadSafety()Enable support for multi-threading within the ROOT code in particular, enables the global mutex to ma...Definition TROOT.cxx:501; ROOT::GetROOTTROOT * GetROOT()Definition TROOT.cxx:472; ROOT::DisableImplicitMTvoid DisableImplicitMT()Disables the implicit multi-threading in ROOT (see EnableImplicitMT).Definition TROOT.cxx:556; TClassEdit::GetNormalizedNamevoid GetNormalizedName(std::string &norm_name, std::string_view name)Return the normalized name.Definition TClassEdit.cxx:854; v@ vDefinition rootcling_impl.cxx:3687; FileStat_tDefinition TSystem.h:122; FileStat_t::fModeInt_t fModeDefinition TSystem.h:125; socketDefinition civetweb.c:1894; mTMarker mDefinition textangle.C:8; lTLine lDefinition textangle.C:4. corebasesrcTROOT.cxx. ROOT v6-32 - Reference Guide Generated on Fri Nov 1 2024 15:06:53 (GVA Time) using Doxygen 1.9.8 ; . ",MatchSource.WIKI,doc/v632/TROOT_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/TROOT_8cxx_source.html
https://root.cern/doc/v632/TROOT_8cxx_source.html:173594,Performance,multi-thread,multi-threading,173594,"OT2TROOT * GetROOT2()Definition TROOT.cxx:387; ROOT::Internal::GetROOT1TROOT * GetROOT1()Definition TROOT.cxx:380; ROOT::Internal::ReleaseDefaultErrorHandlervoid ReleaseDefaultErrorHandler()Destructs resources that are taken by using the default error handler.Definition TErrorDefaultHandler.cxx:47; ROOT::Minuit2::GradientParameterSpace::Internal@ Internal; ROOTtbb::task_arena is an alias of tbb::interface7::task_arena, which doesn't allow to forward declare tb...Definition EExecutionPolicy.hxx:4; ROOT::GetMacroPathTString & GetMacroPath()Definition TROOT.cxx:476; ROOT::EnableImplicitMTvoid EnableImplicitMT(UInt_t numthreads=0)Enable ROOT's implicit multi-threading for all objects and methods that provide an internal paralleli...Definition TROOT.cxx:539; ROOT::IsImplicitMTEnabledBool_t IsImplicitMTEnabled()Returns true if the implicit multi-threading in ROOT is enabled.Definition TROOT.cxx:570; ROOT::GetThreadPoolSizeUInt_t GetThreadPoolSize()Returns the size of ROOT's thread pool.Definition TROOT.cxx:577; ROOT::gCoreMutexR__EXTERN TVirtualRWMutex * gCoreMutexDefinition TVirtualRWMutex.h:37; ROOT::EnableThreadSafetyvoid EnableThreadSafety()Enable support for multi-threading within the ROOT code in particular, enables the global mutex to ma...Definition TROOT.cxx:501; ROOT::GetROOTTROOT * GetROOT()Definition TROOT.cxx:472; ROOT::DisableImplicitMTvoid DisableImplicitMT()Disables the implicit multi-threading in ROOT (see EnableImplicitMT).Definition TROOT.cxx:556; TClassEdit::GetNormalizedNamevoid GetNormalizedName(std::string &norm_name, std::string_view name)Return the normalized name.Definition TClassEdit.cxx:854; v@ vDefinition rootcling_impl.cxx:3687; FileStat_tDefinition TSystem.h:122; FileStat_t::fModeInt_t fModeDefinition TSystem.h:125; socketDefinition civetweb.c:1894; mTMarker mDefinition textangle.C:8; lTLine lDefinition textangle.C:4. corebasesrcTROOT.cxx. ROOT v6-32 - Reference Guide Generated on Fri Nov 1 2024 15:06:53 (GVA Time) using Doxygen 1.9.8 ; . ",MatchSource.WIKI,doc/v632/TROOT_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/TROOT_8cxx_source.html
https://root.cern/doc/v632/TROOT_8cxx_source.html:16855,Safety,safe,safe,16855,"435 {; 436#ifdef R__USE_IMT; 437 static void (*sym)() = (void(*)())Internal::GetSymInLibImt(""ROOT_TImplicitMT_DisableParBranchProcessing"");; 438 if (sym); 439 sym();; 440#else; 441 ::Warning(""DisableParBranchProcessing"", ""Cannot disable parallel branch processing, please build ROOT with -Dimt=ON"");; 442#endif; 443 }; 444 ; 445 //////////////////////////////////////////////////////////////////////////////; 446 /// Returns true if parallel branch processing is enabled.; 447 Bool_t IsParBranchProcessingEnabled(); 448 {; 449#ifdef R__USE_IMT; 450 static Bool_t (*sym)() = (Bool_t(*)())Internal::GetSymInLibImt(""ROOT_TImplicitMT_IsParBranchProcessingEnabled"");; 451 if (sym); 452 return sym();; 453 else; 454 return kFALSE;; 455#else; 456 return kFALSE;; 457#endif; 458 }; 459 ; 460 ////////////////////////////////////////////////////////////////////////////////; 461 /// Keeps track of the status of ImplicitMT w/o resorting to the load of; 462 /// libImt; 463 static Bool_t &IsImplicitMTEnabledImpl(); 464 {; 465 static Bool_t isImplicitMTEnabled = kFALSE;; 466 return isImplicitMTEnabled;; 467 }; 468 ; 469} // end of Internal sub namespace; 470// back to ROOT namespace; 471 ; 472 TROOT *GetROOT() {; 473 return (*Internal::gGetROOT)();; 474 }; 475 ; 476 TString &GetMacroPath() {; 477 static TString macroPath;; 478 return macroPath;; 479 }; 480 ; 481 // clang-format off; 482 ////////////////////////////////////////////////////////////////////////////////; 483 /// Enables the global mutex to make ROOT thread safe/aware.; 484 ///; 485 /// The following becomes safe:; 486 /// - concurrent construction and destruction of TObjects, including the ones registered in ROOT's global lists (e.g. gROOT->GetListOfCleanups(), gROOT->GetListOfFiles()); 487 /// - concurrent usage of _different_ ROOT objects from different threads, including ones with global state (e.g. TFile, TTree, TChain) with the exception of graphics classes (e.g. TCanvas); 488 /// - concurrent calls to ROOT's type system cla",MatchSource.WIKI,doc/v632/TROOT_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/TROOT_8cxx_source.html
https://root.cern/doc/v632/TROOT_8cxx_source.html:16907,Safety,safe,safe,16907,"ROOT_TImplicitMT_IsParBranchProcessingEnabled"");; 451 if (sym); 452 return sym();; 453 else; 454 return kFALSE;; 455#else; 456 return kFALSE;; 457#endif; 458 }; 459 ; 460 ////////////////////////////////////////////////////////////////////////////////; 461 /// Keeps track of the status of ImplicitMT w/o resorting to the load of; 462 /// libImt; 463 static Bool_t &IsImplicitMTEnabledImpl(); 464 {; 465 static Bool_t isImplicitMTEnabled = kFALSE;; 466 return isImplicitMTEnabled;; 467 }; 468 ; 469} // end of Internal sub namespace; 470// back to ROOT namespace; 471 ; 472 TROOT *GetROOT() {; 473 return (*Internal::gGetROOT)();; 474 }; 475 ; 476 TString &GetMacroPath() {; 477 static TString macroPath;; 478 return macroPath;; 479 }; 480 ; 481 // clang-format off; 482 ////////////////////////////////////////////////////////////////////////////////; 483 /// Enables the global mutex to make ROOT thread safe/aware.; 484 ///; 485 /// The following becomes safe:; 486 /// - concurrent construction and destruction of TObjects, including the ones registered in ROOT's global lists (e.g. gROOT->GetListOfCleanups(), gROOT->GetListOfFiles()); 487 /// - concurrent usage of _different_ ROOT objects from different threads, including ones with global state (e.g. TFile, TTree, TChain) with the exception of graphics classes (e.g. TCanvas); 488 /// - concurrent calls to ROOT's type system classes, e.g. TClass and TEnum; 489 /// - concurrent calls to the interpreter through gInterpreter; 490 /// - concurrent loading of ROOT plug-ins; 491 ///; 492 /// In addition, gDirectory, gFile and gPad become a thread-local variable.; 493 /// In all threads, gDirectory defaults to gROOT, a singleton which supports thread-safe insertion and deletion of contents.; 494 /// gFile and gPad default to nullptr, as it is for single-thread programs.; 495 ///; 496 /// The ROOT graphics subsystem is not made thread-safe by this method. In particular drawing or printing different; 497 /// canvases from different thread",MatchSource.WIKI,doc/v632/TROOT_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/TROOT_8cxx_source.html
https://root.cern/doc/v632/TROOT_8cxx_source.html:17659,Safety,safe,safe,17659," TString macroPath;; 478 return macroPath;; 479 }; 480 ; 481 // clang-format off; 482 ////////////////////////////////////////////////////////////////////////////////; 483 /// Enables the global mutex to make ROOT thread safe/aware.; 484 ///; 485 /// The following becomes safe:; 486 /// - concurrent construction and destruction of TObjects, including the ones registered in ROOT's global lists (e.g. gROOT->GetListOfCleanups(), gROOT->GetListOfFiles()); 487 /// - concurrent usage of _different_ ROOT objects from different threads, including ones with global state (e.g. TFile, TTree, TChain) with the exception of graphics classes (e.g. TCanvas); 488 /// - concurrent calls to ROOT's type system classes, e.g. TClass and TEnum; 489 /// - concurrent calls to the interpreter through gInterpreter; 490 /// - concurrent loading of ROOT plug-ins; 491 ///; 492 /// In addition, gDirectory, gFile and gPad become a thread-local variable.; 493 /// In all threads, gDirectory defaults to gROOT, a singleton which supports thread-safe insertion and deletion of contents.; 494 /// gFile and gPad default to nullptr, as it is for single-thread programs.; 495 ///; 496 /// The ROOT graphics subsystem is not made thread-safe by this method. In particular drawing or printing different; 497 /// canvases from different threads (and analogous operations such as invoking `Draw` on a `TObject`) is not thread-safe.; 498 ///; 499 /// Note that there is no `DisableThreadSafety()`. ROOT's thread-safety features cannot be disabled once activated.; 500 // clang-format on; 501 void EnableThreadSafety(); 502 {; 503 static void (*sym)() = (void(*)())Internal::GetSymInLibImt(""ROOT_TThread_Initialize"");; 504 if (sym); 505 sym();; 506 }; 507 ; 508 ////////////////////////////////////////////////////////////////////////////////; 509 /// @param[in] numthreads Number of threads to use. If not specified or; 510 /// set to zero, the number of threads is automatically; 511 /// decided by the implementation. Any other",MatchSource.WIKI,doc/v632/TROOT_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/TROOT_8cxx_source.html
https://root.cern/doc/v632/TROOT_8cxx_source.html:17846,Safety,safe,safe,17846,"lobal mutex to make ROOT thread safe/aware.; 484 ///; 485 /// The following becomes safe:; 486 /// - concurrent construction and destruction of TObjects, including the ones registered in ROOT's global lists (e.g. gROOT->GetListOfCleanups(), gROOT->GetListOfFiles()); 487 /// - concurrent usage of _different_ ROOT objects from different threads, including ones with global state (e.g. TFile, TTree, TChain) with the exception of graphics classes (e.g. TCanvas); 488 /// - concurrent calls to ROOT's type system classes, e.g. TClass and TEnum; 489 /// - concurrent calls to the interpreter through gInterpreter; 490 /// - concurrent loading of ROOT plug-ins; 491 ///; 492 /// In addition, gDirectory, gFile and gPad become a thread-local variable.; 493 /// In all threads, gDirectory defaults to gROOT, a singleton which supports thread-safe insertion and deletion of contents.; 494 /// gFile and gPad default to nullptr, as it is for single-thread programs.; 495 ///; 496 /// The ROOT graphics subsystem is not made thread-safe by this method. In particular drawing or printing different; 497 /// canvases from different threads (and analogous operations such as invoking `Draw` on a `TObject`) is not thread-safe.; 498 ///; 499 /// Note that there is no `DisableThreadSafety()`. ROOT's thread-safety features cannot be disabled once activated.; 500 // clang-format on; 501 void EnableThreadSafety(); 502 {; 503 static void (*sym)() = (void(*)())Internal::GetSymInLibImt(""ROOT_TThread_Initialize"");; 504 if (sym); 505 sym();; 506 }; 507 ; 508 ////////////////////////////////////////////////////////////////////////////////; 509 /// @param[in] numthreads Number of threads to use. If not specified or; 510 /// set to zero, the number of threads is automatically; 511 /// decided by the implementation. Any other value is; 512 /// used as a hint.; 513 ///; 514 /// ROOT must be built with the compilation flag `imt=ON` for this feature to be available.; 515 /// The following objects and methods autom",MatchSource.WIKI,doc/v632/TROOT_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/TROOT_8cxx_source.html
https://root.cern/doc/v632/TROOT_8cxx_source.html:18032,Safety,safe,safe,18032," destruction of TObjects, including the ones registered in ROOT's global lists (e.g. gROOT->GetListOfCleanups(), gROOT->GetListOfFiles()); 487 /// - concurrent usage of _different_ ROOT objects from different threads, including ones with global state (e.g. TFile, TTree, TChain) with the exception of graphics classes (e.g. TCanvas); 488 /// - concurrent calls to ROOT's type system classes, e.g. TClass and TEnum; 489 /// - concurrent calls to the interpreter through gInterpreter; 490 /// - concurrent loading of ROOT plug-ins; 491 ///; 492 /// In addition, gDirectory, gFile and gPad become a thread-local variable.; 493 /// In all threads, gDirectory defaults to gROOT, a singleton which supports thread-safe insertion and deletion of contents.; 494 /// gFile and gPad default to nullptr, as it is for single-thread programs.; 495 ///; 496 /// The ROOT graphics subsystem is not made thread-safe by this method. In particular drawing or printing different; 497 /// canvases from different threads (and analogous operations such as invoking `Draw` on a `TObject`) is not thread-safe.; 498 ///; 499 /// Note that there is no `DisableThreadSafety()`. ROOT's thread-safety features cannot be disabled once activated.; 500 // clang-format on; 501 void EnableThreadSafety(); 502 {; 503 static void (*sym)() = (void(*)())Internal::GetSymInLibImt(""ROOT_TThread_Initialize"");; 504 if (sym); 505 sym();; 506 }; 507 ; 508 ////////////////////////////////////////////////////////////////////////////////; 509 /// @param[in] numthreads Number of threads to use. If not specified or; 510 /// set to zero, the number of threads is automatically; 511 /// decided by the implementation. Any other value is; 512 /// used as a hint.; 513 ///; 514 /// ROOT must be built with the compilation flag `imt=ON` for this feature to be available.; 515 /// The following objects and methods automatically take advantage of; 516 /// multi-threading if a call to `EnableImplicitMT` has been made before usage:; 517 ///; 518 ///",MatchSource.WIKI,doc/v632/TROOT_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/TROOT_8cxx_source.html
https://root.cern/doc/v632/TROOT_8cxx_source.html:18117,Safety,safe,safety,18117,"OT objects from different threads, including ones with global state (e.g. TFile, TTree, TChain) with the exception of graphics classes (e.g. TCanvas); 488 /// - concurrent calls to ROOT's type system classes, e.g. TClass and TEnum; 489 /// - concurrent calls to the interpreter through gInterpreter; 490 /// - concurrent loading of ROOT plug-ins; 491 ///; 492 /// In addition, gDirectory, gFile and gPad become a thread-local variable.; 493 /// In all threads, gDirectory defaults to gROOT, a singleton which supports thread-safe insertion and deletion of contents.; 494 /// gFile and gPad default to nullptr, as it is for single-thread programs.; 495 ///; 496 /// The ROOT graphics subsystem is not made thread-safe by this method. In particular drawing or printing different; 497 /// canvases from different threads (and analogous operations such as invoking `Draw` on a `TObject`) is not thread-safe.; 498 ///; 499 /// Note that there is no `DisableThreadSafety()`. ROOT's thread-safety features cannot be disabled once activated.; 500 // clang-format on; 501 void EnableThreadSafety(); 502 {; 503 static void (*sym)() = (void(*)())Internal::GetSymInLibImt(""ROOT_TThread_Initialize"");; 504 if (sym); 505 sym();; 506 }; 507 ; 508 ////////////////////////////////////////////////////////////////////////////////; 509 /// @param[in] numthreads Number of threads to use. If not specified or; 510 /// set to zero, the number of threads is automatically; 511 /// decided by the implementation. Any other value is; 512 /// used as a hint.; 513 ///; 514 /// ROOT must be built with the compilation flag `imt=ON` for this feature to be available.; 515 /// The following objects and methods automatically take advantage of; 516 /// multi-threading if a call to `EnableImplicitMT` has been made before usage:; 517 ///; 518 /// - RDataFrame internally runs the event-loop by parallelizing over clusters of entries; 519 /// - TTree::GetEntry reads multiple branches in parallel; 520 /// - TTree::FlushBaskets wr",MatchSource.WIKI,doc/v632/TROOT_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/TROOT_8cxx_source.html
https://root.cern/doc/v632/TROOT_8cxx_source.html:35366,Safety,avoid,avoid,35366,"ources used by ROOT (files, network sockets,; 865/// shared memory segments, etc.).; 866 ; 867TROOT::~TROOT(); 868{; 869 using namespace ROOT::Internal;; 870 ; 871 if (gROOTLocal == this) {; 872 ; 873 // TMapFile must be closed before they are deleted, so run CloseFiles; 874 // (possibly a second time if the application has an explicit TApplication; 875 // object, but in that this is a no-op). TMapFile needs the slow close; 876 // so that the custome operator delete can properly find out whether the; 877 // memory being 'freed' is part of a memory mapped file or not.; 878 CloseFiles();; 879 ; 880 // If the interpreter has not yet been initialized, don't bother; 881 gGetROOT = &GetROOT1;; 882 ; 883 // Mark the object as invalid, so that we can veto some actions; 884 // (like autoloading) while we are in the destructor.; 885 SetBit(TObject::kInvalidObject);; 886 ; 887 // Turn-off the global mutex to avoid recreating mutexes that have; 888 // already been deleted during the destruction phase; 889 if (gGlobalMutex) {; 890 TVirtualMutex *m = gGlobalMutex;; 891 gGlobalMutex = nullptr;; 892 delete m;; 893 }; 894 ; 895 // Return when error occurred in TCling, i.e. when setup file(s) are; 896 // out of date; 897 if (!fVersionInt) return;; 898 ; 899 // ATTENTION!!! Order is important!; 900 ; 901 SafeDelete(fBrowsables);; 902 ; 903 // FIXME: Causes rootcling to deadlock, debug and uncomment; 904 // SafeDelete(fRootFolder);; 905 ; 906#ifdef R__COMPLETE_MEM_TERMINATION; 907 fSpecials->Delete(); SafeDelete(fSpecials); // delete special objects : PostScript, Minuit, Html; 908#endif; 909 ; 910 fClosedObjects->Delete(""slow""); // and closed files; 911 fFiles->Delete(""slow""); // and files; 912 SafeDelete(fFiles);; 913 fSecContexts->Delete(""slow""); SafeDelete(fSecContexts); // and security contexts; 914 fSockets->Delete(); SafeDelete(fSockets); // and sockets; 915 fMappedFiles->Delete(""slow""); // and mapped files; 916 TSeqCollection *tl = fMappedFiles; fMappedFiles = nullptr; delete tl;",MatchSource.WIKI,doc/v632/TROOT_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/TROOT_8cxx_source.html
https://root.cern/doc/v632/TROOT_8cxx_source.html:39327,Safety,avoid,avoid,39327,"73 delete gSystem;; 974 ; 975 // ROOT-6022:; 976 // if (gInterpreterLib) dlclose(gInterpreterLib);; 977#ifdef R__COMPLETE_MEM_TERMINATION; 978 // On some 'newer' platform (Fedora Core 17+, Ubuntu 12), the; 979 // initialization order is (by default?) is 'wrong' and so we can't; 980 // delete the interpreter now .. because any of the static in the; 981 // interpreter's library have already been deleted.; 982 // On the link line, we must list the most dependent .o file; 983 // and end with the least dependent (LLVM libraries), unfortunately,; 984 // Fedora Core 17+ or Ubuntu 12 will also execute the initialization; 985 // in the same order (hence doing libCore's before LLVM's and; 986 // vice et versa for both the destructor. We worked around the; 987 // initialization order by delay the TROOT creation until first use.; 988 // We can not do the same for destruction as we have no way of knowing; 989 // the last access ...; 990 // So for now, let's avoid delete TCling except in the special build; 991 // checking the completeness of the termination deletion.; 992 ; 993 // TODO: Should we do more cleanup here than just call delete?; 994 // Segfaults rootcling in some cases, debug and uncomment:; 995 //; 996 // delete fInterpreter;; 997 ; 998 // We cannot delete fCleanups because of the logic in atexit which needs it.; 999 SafeDelete(fCleanups);; 1000#endif; 1001 ; 1002#ifdef _MSC_VER; 1003 // usedToIdentifyRootClingByDlSym is available when TROOT is part of rootcling.; 1004 if (dlsym(RTLD_DEFAULT, ""usedToIdentifyRootClingByDlSym"")) {; 1005 // deleting the interpreter makes things crash at exit in some cases; 1006 delete fInterpreter;; 1007 }; 1008#else; 1009 // deleting the interpreter makes things crash at exit in some cases; 1010 delete fInterpreter;; 1011#endif; 1012 ; 1013 // Prints memory stats; 1014 TStorage::PrintStatistics();; 1015 ; 1016 gROOTLocal = nullptr;; 1017 fgRootInit = kFALSE;; 1018 }; 1019}; 1020 ; 1021////////////////////////////////////////////////////",MatchSource.WIKI,doc/v632/TROOT_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/TROOT_8cxx_source.html
https://root.cern/doc/v632/TROOT_8cxx_source.html:44185,Safety,avoid,avoid,44185,"he deletion ot update the list itself.; 1107 ; 1108 static TObject harmless;; 1109 TObjLink *cursor = files->FirstLink();; 1110 while (cursor) {; 1111 Content *dir = static_cast<Content*>( cursor->GetObject() );; 1112 if (dir) {; 1113 // In order for the iterator to stay valid, we must; 1114 // prevent the removal of the object (dir) from the list; 1115 // (which is done in TFile::Close). We can also can not; 1116 // just move to the next iterator since the Close might; 1117 // also (indirectly) remove that file.; 1118 // So we SetObject to a harmless value, so that 'dir'; 1119 // is not seen as part of the list.; 1120 // We will later, remove all the object (see files->Clear(); 1121 cursor->SetObject(&harmless); // this must not be zero otherwise things go wrong.; 1122 // See related comment at the files->Clear(""nodelete"");; 1123 dir->Close(""nodelete"");; 1124 // Put it back; 1125 cursor->SetObject(dir);; 1126 }; 1127 cursor = cursor->Next();; 1128 };; 1129 // Now were done, clear the list but do not delete the objects as; 1130 // they have been moved to the list of closed objects and must be; 1131 // deleted from there in order to avoid a double delete from a; 1132 // use objects (on the interpreter stack).; 1133 files->Clear(""nodelete"");; 1134 }; 1135 ; 1136 static void R__ListSlowDeleteContent(TList *files); 1137 {; 1138 // Routine to delete the content of list of files using the 'slow' techniques; 1139 ; 1140 static TObject harmless;; 1141 TObjLink *cursor = files->FirstLink();; 1142 while (cursor) {; 1143 TDirectory *dir = dynamic_cast<TDirectory*>( cursor->GetObject() );; 1144 if (dir) {; 1145 // In order for the iterator to stay valid, we must; 1146 // prevent the removal of the object (dir) from the list; 1147 // (which is done in TFile::Close). We can also can not; 1148 // just move to the next iterator since the Close might; 1149 // also (indirectly) remove that file.; 1150 // So we SetObject to a harmless value, so that 'dir'; 1151 // is not seen as part o",MatchSource.WIKI,doc/v632/TROOT_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/TROOT_8cxx_source.html
https://root.cern/doc/v632/TROOT_8cxx_source.html:75338,Safety,detect,detected,75338,"return 0;; 1931 ; 1932 TString stem(fname);; 1933 // Remove extension if any, ignore files with extension not being .h*; 1934 Int_t where = stem.Last('.');; 1935 if (where != kNPOS) {; 1936 if (stem.EndsWith("".so"") || stem.EndsWith("".sl"") ||; 1937 stem.EndsWith("".dl"") || stem.EndsWith("".a"") ||; 1938 stem.EndsWith("".dll"", TString::kIgnoreCase)); 1939 return 0;; 1940 stem.Remove(where);; 1941 }; 1942 ; 1943 TString className = gSystem->BaseName(stem);; 1944 TClass* cla = R__GetClassIfKnown(className);; 1945 if (!cla) {; 1946 // Try again with modifications to the file name:; 1947 className = stem;; 1948 className.ReplaceAll(""/"", ""::"");; 1949 className.ReplaceAll(""\\"", ""::"");; 1950 if (className.Contains("":::"")) {; 1951 // ""C:\dir"" becomes ""C:::dir"".; 1952 // fname corresponds to whatever is stated after #include and; 1953 // a full path name usually means that it's not a regular #include; 1954 // but e.g. a "".L"", so we can assume that this is not a header of; 1955 // a class in a namespace (a global-namespace class would have been; 1956 // detected already before).; 1957 return 0;; 1958 }; 1959 cla = R__GetClassIfKnown(className);; 1960 }; 1961 ; 1962 if (!cla) {; 1963 return 0;; 1964 }; 1965 ; 1966 // cla is valid, check wether it's actually in the header of the same name:; 1967 if (cla->GetDeclFileLine() <= 0) return 0; // to a void an error with VisualC++; 1968 TString decfile = gSystem->BaseName(cla->GetDeclFileName());; 1969 if (decfile != gSystem->BaseName(fname)) {; 1970 return 0;; 1971 }; 1972 return 1;; 1973}; 1974 ; 1975////////////////////////////////////////////////////////////////////////////////; 1976/// Initialize operating system interface.; 1977 ; 1978void TROOT::InitSystem(); 1979{; 1980 if (gSystem == nullptr) {; 1981#if defined(R__UNIX); 1982#if defined(R__HAS_COCOA); 1983 gSystem = new TMacOSXSystem;; 1984#else; 1985 gSystem = new TUnixSystem;; 1986#endif; 1987#elif defined(R__WIN32); 1988 gSystem = new TWinNTSystem;; 1989#else; 1990 gSystem = new",MatchSource.WIKI,doc/v632/TROOT_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/TROOT_8cxx_source.html
https://root.cern/doc/v632/TROOT_8cxx_source.html:98731,Safety,avoid,avoid,98731,"ation); 2573 // load UserLibrary; 2574 // create TFile; 2575 // Append UserObject to TFile; 2576 ; 2577 // and after the end of main the order of execution was; 2578 ; 2579 // unload UserLibrary; 2580 // call EndOfProcessCleanups; 2581 // Write the TFile; 2582 // attempt to write the user object.; 2583 // ....; 2584 ; 2585 // where what we need is to have the files closen/written before; 2586 // the unloading of the library.; 2587 ; 2588 // To solve the problem we now register an atexit function for; 2589 // every dictionary thus making sure there is at least one executed; 2590 // before the first library tear down after main.; 2591 ; 2592 // If atexit is called directly within a library's code, the; 2593 // function will called *either* when the library is 'dlclose'd or; 2594 // after then end of main (whichever comes first). We do *not*; 2595 // want the files to be closed whenever a library is unloaded via; 2596 // dlclose. To avoid this, we add the function (CallCloseFiles); 2597 // from the dictionary indirectly (via ROOT::RegisterModule). In; 2598 // this case the function will only only be called either when; 2599 // libCore is 'dlclose'd or right after the end of main.; 2600 ; 2601 atexit(CallCloseFiles);; 2602 ; 2603 // Now register with TCling.; 2604 if (TROOT::Initialized()) {; 2605 gCling->RegisterModule(modulename, headers, includePaths, payloadCode, fwdDeclCode, triggerFunc,; 2606 fwdDeclsArgToSkip, classesHeaders, false, hasCxxModule);; 2607 } else {; 2608 GetModuleHeaderInfoBuffer().push_back(ModuleHeaderInfo_t(modulename, headers, includePaths, payloadCode,; 2609 fwdDeclCode, triggerFunc, fwdDeclsArgToSkip,; 2610 classesHeaders, hasCxxModule));; 2611 }; 2612}; 2613 ; 2614////////////////////////////////////////////////////////////////////////////////; 2615/// Remove an object from the in-memory list.; 2616/// Since TROOT is global resource, this is lock protected.; 2617 ; 2618TObject *TROOT::Remove(TObject* obj); 2619{; 2620 R__LOCKGUARD(gROOTMutex)",MatchSource.WIKI,doc/v632/TROOT_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/TROOT_8cxx_source.html
https://root.cern/doc/v632/TROOT_8cxx_source.html:132188,Safety,safe,safe,132188,"ss from the list and map of classesDefinition TClass.cxx:520; TClass::GetClassInfoClassInfo_t * GetClassInfo() constDefinition TClass.h:433; TClass::InheritsFromBool_t InheritsFrom(const char *cl) const overrideReturn kTRUE if this class inherits from a class with name ""classname"".Definition TClass.cxx:4874; TClass::GetDeclFileNameconst char * GetDeclFileName() constReturn name of the file containing the declaration of this class.Definition TClass.cxx:3463; TClass::GetClassstatic TClass * GetClass(const char *name, Bool_t load=kTRUE, Bool_t silent=kFALSE)Static method returning pointer to TClass of the specified class name.Definition TClass.cxx:2968; TCollectionCollection abstract base class.Definition TCollection.h:65; TCollection::RecursiveRemovevoid RecursiveRemove(TObject *obj) overrideRemove object from this collection and recursively remove the object from all other objects (and coll...Definition TCollection.cxx:574; TCollection::UseRWLockvirtual bool UseRWLock(Bool_t enable=true)Set this collection to use a RW lock upon access, making it thread safe.Definition TCollection.cxx:761; TCollection::AddAllvirtual void AddAll(const TCollection *col)Add all objects from collection col to this collection.Definition TCollection.cxx:195; TCollection::SetOwnervirtual void SetOwner(Bool_t enable=kTRUE)Set whether this collection is the owner (enable==true) of its content.Definition TCollection.cxx:746; TCollection::Addvirtual void Add(TObject *obj)=0; TCollection::FindObjectTObject * FindObject(const char *name) const overrideFind an object in this collection using its name.Definition TCollection.cxx:312; TCollection::Deletevoid Delete(Option_t *option="""") override=0Delete this object.; TCollection::Clearvoid Clear(Option_t *option="""") override=0; TCollection::GetSizevirtual Int_t GetSize() constReturn the capacity of the collection, i.e.Definition TCollection.h:184; TColorThe color creation and management class.Definition TColor.h:21; TColor::InitializeColorsstatic void I",MatchSource.WIKI,doc/v632/TROOT_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/TROOT_8cxx_source.html
https://root.cern/doc/v632/TROOT_8cxx_source.html:160878,Safety,detect,detected,160878,ition TROOT.cxx:2891; TROOT::GetDocDirstatic const TString & GetDocDir()Get the documentation directory in the installation. Static utility function.Definition TROOT.cxx:3078; TROOT::GetEtcDirstatic const TString & GetEtcDir()Get the sysconfig directory in the installation. Static utility function.Definition TROOT.cxx:3052; TROOT::GetNclassesInt_t GetNclasses() constGet number of classes.Definition TROOT.cxx:1876; TROOT::GetExtraInterpreterArgsstatic const char **& GetExtraInterpreterArgs()INTERNAL function! Used by rootcling to inject interpreter arguments through a C-interface layer.Definition TROOT.cxx:2962; TROOT::SetMacroPathstatic void SetMacroPath(const char *newpath)Set or extend the macro search path.Definition TROOT.cxx:2788; TROOT::InitThreadsvoid InitThreads()Initialize threads library.Definition TROOT.cxx:2053; TROOT::fUUIDsTProcessUUID * fUUIDsPointer to TProcessID managing TUUIDs.Definition TROOT.h:166; TROOT::fConfigFeaturesTString fConfigFeaturesROOT ./configure detected build features.Definition TROOT.h:112; TROOT::GetFunctionTemplateTFunctionTemplate * GetFunctionTemplate(const char *name)Definition TROOT.cxx:1618; TROOT::fPluginManagerTPluginManager * fPluginManagerKeeps track of plugin library handlers.Definition TROOT.h:169; TROOT::GetGeometryTObject * GetGeometry(const char *name) constReturn pointer to Geometry with name.Definition TROOT.cxx:1747; TROOT::RecursiveRemovevoid RecursiveRemove(TObject *obj) overrideRecursively remove this object from the list of Cleanups.Definition TROOT.cxx:2498; TROOT::fExecutingMacroBool_t fExecutingMacroTrue while executing a TMacro.Definition TROOT.h:136; TROOT::fBuiltDateInt_t fBuiltDateDate of ROOT built.Definition TROOT.h:118; TROOT::fIsWebDisplayBatchBool_t fIsWebDisplayBatchTrue if web widgets are not displayed.Definition TROOT.h:129; TROOT::GetSharedLibDirstatic const TString & GetSharedLibDir()Get the shared libraries directory in the installation. Static utility function.Definition TROOT.cxx:3031; TRO,MatchSource.WIKI,doc/v632/TROOT_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/TROOT_8cxx_source.html
https://root.cern/doc/v632/TROOT_8cxx_source.html:171360,Safety,abort,abort,171360,"e< T; ROOT::InternalDefinition TErrorDefaultHandler.hxx:16; ROOT::Internal::GetSymInLibImtstatic Func_t GetSymInLibImt(const char *funcname)Definition TROOT.cxx:401; ROOT::Internal::gGetROOTstatic GetROOTFun_t gGetROOTDefinition TROOT.cxx:399; ROOT::Internal::gROOTLocalR__EXTERN TROOT * gROOTLocalDefinition TROOT.h:379; ROOT::Internal::DisableParBranchProcessingvoid DisableParBranchProcessing()Globally disables the IMT use case of parallel branch processing, deactivating the corresponding lock...Definition TROOT.cxx:434; ROOT::Internal::ErrorSystemMsgHandlerFunc_tstd::function< const char *()> ErrorSystemMsgHandlerFunc_tRetrieves the error string associated with the last system error.Definition TError.h:59; ROOT::Internal::IsImplicitMTEnabledImplstatic Bool_t & IsImplicitMTEnabledImpl()Keeps track of the status of ImplicitMT w/o resorting to the load of libImt.Definition TROOT.cxx:463; ROOT::Internal::MinimalErrorHandlervoid MinimalErrorHandler(int level, Bool_t abort, const char *location, const char *msg)A very simple error handler that is usually replaced by the TROOT default error handler.Definition TError.cxx:67; ROOT::Internal::GetROOTFun_tTROOT *(* GetROOTFun_t)()Definition TROOT.cxx:397; ROOT::Internal::SetErrorSystemMsgHandlerErrorSystemMsgHandlerFunc_t SetErrorSystemMsgHandler(ErrorSystemMsgHandlerFunc_t h)Returns the previous system error message handler.Definition TError.cxx:56; ROOT::Internal::EnableParBranchProcessingvoid EnableParBranchProcessing()Globally enables the parallel branch processing, which is a case of implicit multi-threading (IMT) in...Definition TROOT.cxx:420; ROOT::Internal::IsParBranchProcessingEnabledBool_t IsParBranchProcessingEnabled()Returns true if parallel branch processing is enabled.Definition TROOT.cxx:447; ROOT::Internal::GetROOT2TROOT * GetROOT2()Definition TROOT.cxx:387; ROOT::Internal::GetROOT1TROOT * GetROOT1()Definition TROOT.cxx:380; ROOT::Internal::ReleaseDefaultErrorHandlervoid ReleaseDefaultErrorHandler()Destructs r",MatchSource.WIKI,doc/v632/TROOT_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/TROOT_8cxx_source.html
https://root.cern/doc/v632/TROOT_8cxx_source.html:789,Security,access,accessible,789,". ROOT: core/base/src/TROOT.cxx Source File. ; ROOT ; . v6-32. Reference Guide ; . . Loading...; Searching...; No Matches. TROOT.cxx. Go to the documentation of this file. 1// @(#)root/base:$Id$; 2// Author: Rene Brun 08/12/94; 3 ; 4/*************************************************************************; 5 * Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; 6 * All rights reserved. *; 7 * *; 8 * For the licensing terms see $ROOTSYS/LICENSE. *; 9 * For the list of contributors see $ROOTSYS/README/CREDITS. *; 10 *************************************************************************/; 11 ; 12/** \class TROOT; 13\ingroup Base; 14 ; 15ROOT top level object description.; 16 ; 17The TROOT object is the entry point to the ROOT system.; 18The single instance of TROOT is accessible via the global gROOT.; 19Using the gROOT pointer one has access to basically every object; 20created in a ROOT based program. The TROOT object is essentially a; 21container of several lists pointing to the main ROOT objects.; 22 ; 23The following lists are accessible from gROOT object:; 24 ; 25~~~ {.cpp}; 26 gROOT->GetListOfClasses; 27 gROOT->GetListOfColors; 28 gROOT->GetListOfTypes; 29 gROOT->GetListOfGlobals; 30 gROOT->GetListOfGlobalFunctions; 31 gROOT->GetListOfFiles; 32 gROOT->GetListOfMappedFiles; 33 gROOT->GetListOfSockets; 34 gROOT->GetListOfSecContexts; 35 gROOT->GetListOfCanvases; 36 gROOT->GetListOfStyles; 37 gROOT->GetListOfFunctions; 38 gROOT->GetListOfSpecials (for example graphical cuts); 39 gROOT->GetListOfGeometries; 40 gROOT->GetListOfBrowsers; 41 gROOT->GetListOfCleanups; 42 gROOT->GetListOfMessageHandlers; 43~~~; 44 ; 45The TROOT class provides also many useful services:; 46 - Get pointer to an object in any of the lists above; 47 - Time utilities TROOT::Time; 48 ; 49The ROOT object must be created as a static object. An example; 50of a main program creating an interactive version is shown below:; 51 ; 52### Example of a main program; 53 ; 54~~~ {.cpp}; 55 #incl",MatchSource.WIKI,doc/v632/TROOT_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/TROOT_8cxx_source.html
https://root.cern/doc/v632/TROOT_8cxx_source.html:857,Security,access,access,857,". ROOT: core/base/src/TROOT.cxx Source File. ; ROOT ; . v6-32. Reference Guide ; . . Loading...; Searching...; No Matches. TROOT.cxx. Go to the documentation of this file. 1// @(#)root/base:$Id$; 2// Author: Rene Brun 08/12/94; 3 ; 4/*************************************************************************; 5 * Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; 6 * All rights reserved. *; 7 * *; 8 * For the licensing terms see $ROOTSYS/LICENSE. *; 9 * For the list of contributors see $ROOTSYS/README/CREDITS. *; 10 *************************************************************************/; 11 ; 12/** \class TROOT; 13\ingroup Base; 14 ; 15ROOT top level object description.; 16 ; 17The TROOT object is the entry point to the ROOT system.; 18The single instance of TROOT is accessible via the global gROOT.; 19Using the gROOT pointer one has access to basically every object; 20created in a ROOT based program. The TROOT object is essentially a; 21container of several lists pointing to the main ROOT objects.; 22 ; 23The following lists are accessible from gROOT object:; 24 ; 25~~~ {.cpp}; 26 gROOT->GetListOfClasses; 27 gROOT->GetListOfColors; 28 gROOT->GetListOfTypes; 29 gROOT->GetListOfGlobals; 30 gROOT->GetListOfGlobalFunctions; 31 gROOT->GetListOfFiles; 32 gROOT->GetListOfMappedFiles; 33 gROOT->GetListOfSockets; 34 gROOT->GetListOfSecContexts; 35 gROOT->GetListOfCanvases; 36 gROOT->GetListOfStyles; 37 gROOT->GetListOfFunctions; 38 gROOT->GetListOfSpecials (for example graphical cuts); 39 gROOT->GetListOfGeometries; 40 gROOT->GetListOfBrowsers; 41 gROOT->GetListOfCleanups; 42 gROOT->GetListOfMessageHandlers; 43~~~; 44 ; 45The TROOT class provides also many useful services:; 46 - Get pointer to an object in any of the lists above; 47 - Time utilities TROOT::Time; 48 ; 49The ROOT object must be created as a static object. An example; 50of a main program creating an interactive version is shown below:; 51 ; 52### Example of a main program; 53 ; 54~~~ {.cpp}; 55 #incl",MatchSource.WIKI,doc/v632/TROOT_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/TROOT_8cxx_source.html
https://root.cern/doc/v632/TROOT_8cxx_source.html:1057,Security,access,accessible,1057,". Reference Guide ; . . Loading...; Searching...; No Matches. TROOT.cxx. Go to the documentation of this file. 1// @(#)root/base:$Id$; 2// Author: Rene Brun 08/12/94; 3 ; 4/*************************************************************************; 5 * Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; 6 * All rights reserved. *; 7 * *; 8 * For the licensing terms see $ROOTSYS/LICENSE. *; 9 * For the list of contributors see $ROOTSYS/README/CREDITS. *; 10 *************************************************************************/; 11 ; 12/** \class TROOT; 13\ingroup Base; 14 ; 15ROOT top level object description.; 16 ; 17The TROOT object is the entry point to the ROOT system.; 18The single instance of TROOT is accessible via the global gROOT.; 19Using the gROOT pointer one has access to basically every object; 20created in a ROOT based program. The TROOT object is essentially a; 21container of several lists pointing to the main ROOT objects.; 22 ; 23The following lists are accessible from gROOT object:; 24 ; 25~~~ {.cpp}; 26 gROOT->GetListOfClasses; 27 gROOT->GetListOfColors; 28 gROOT->GetListOfTypes; 29 gROOT->GetListOfGlobals; 30 gROOT->GetListOfGlobalFunctions; 31 gROOT->GetListOfFiles; 32 gROOT->GetListOfMappedFiles; 33 gROOT->GetListOfSockets; 34 gROOT->GetListOfSecContexts; 35 gROOT->GetListOfCanvases; 36 gROOT->GetListOfStyles; 37 gROOT->GetListOfFunctions; 38 gROOT->GetListOfSpecials (for example graphical cuts); 39 gROOT->GetListOfGeometries; 40 gROOT->GetListOfBrowsers; 41 gROOT->GetListOfCleanups; 42 gROOT->GetListOfMessageHandlers; 43~~~; 44 ; 45The TROOT class provides also many useful services:; 46 - Get pointer to an object in any of the lists above; 47 - Time utilities TROOT::Time; 48 ; 49The ROOT object must be created as a static object. An example; 50of a main program creating an interactive version is shown below:; 51 ; 52### Example of a main program; 53 ; 54~~~ {.cpp}; 55 #include ""TRint.h""; 56 ; 57 int main(int argc, char **argv); 58 {; ",MatchSource.WIKI,doc/v632/TROOT_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/v632/TROOT_8cxx_source.html
